<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Class ElasticsearchClient | Elasticsearch.NET </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Class ElasticsearchClient | Elasticsearch.NET ">
      
      <meta name="description" content="A strongly-typed client for communicating with Elasticsearch server endpoints.">
      <link rel="icon" href="../favicon.ico">
      <link rel="stylesheet" href="../public/docfx.min.css">
      <link rel="stylesheet" href="../public/main.css">
      <meta name="docfx:navrel" content="../toc.html">
      <meta name="docfx:tocrel" content="toc.html">
      
      <meta name="docfx:rel" content="../">
      
      
      <meta name="docfx:docurl" content="https://github.com/elastic/elasticsearch-net/new/8.18.3/apiSpec/new?filename=Elastic_Clients_Elasticsearch_ElasticsearchClient.md&amp;value=---%0Auid%3A%20Elastic.Clients.Elasticsearch.ElasticsearchClient%0Asummary%3A%20&#39;*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax&#39;%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="ManagedReference">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../index.html">
            <img id="logo" class="svg" src="../images/logo.svg" alt="Elasticsearch.NET">
            Elasticsearch.NET
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient">



  <h1 id="Elastic_Clients_Elasticsearch_ElasticsearchClient" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient" class="text-break">
Class ElasticsearchClient  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Shared/Client/ElasticsearchClient.cs/#L23"><i class="bi bi-code-slash"></i></a>
  </h1>

  <div class="facts text-secondary">
    <dl><dt>Namespace</dt><dd><a class="xref" href="Elastic.html">Elastic</a>.<a class="xref" href="Elastic.Clients.html">Clients</a>.<a class="xref" href="Elastic.Clients.Elasticsearch.html">Elasticsearch</a></dd></dl>
  <dl><dt>Assembly</dt><dd>Elastic.Clients.Elasticsearch.dll</dd></dl>
  </div>

  <div class="markdown summary"><p>A strongly-typed client for communicating with Elasticsearch server endpoints.</p>
</div>
  <div class="markdown conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public class ElasticsearchClient</code></pre>
  </div>




  <dl class="typelist inheritance">
    <dt>Inheritance</dt>
    <dd>
      <div><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.object">object</a></div>
      <div><span class="xref">ElasticsearchClient</span></div>
    </dd>
  </dl>



  <dl class="typelist inheritedMembers">
    <dt>Inherited Members</dt>
    <dd>
    <div>
      <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.object.equals#system-object-equals(system-object)">object.Equals(object)</a>
    </div>
    <div>
      <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.object.equals#system-object-equals(system-object-system-object)">object.Equals(object, object)</a>
    </div>
    <div>
      <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.object.gethashcode">object.GetHashCode()</a>
    </div>
    <div>
      <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.object.gettype">object.GetType()</a>
    </div>
    <div>
      <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.object.memberwiseclone">object.MemberwiseClone()</a>
    </div>
    <div>
      <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.object.referenceequals">object.ReferenceEquals(object, object)</a>
    </div>
    <div>
      <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.object.tostring">object.ToString()</a>
    </div>
  </dd></dl>

  <dl class="typelist extensionMethods">
    <dt>Extension Methods</dt>
    <dd>
  <div>
      <a class="xref" href="Elastic.Clients.Elasticsearch.IndexManyExtensions.html#Elastic_Clients_Elasticsearch_IndexManyExtensions_IndexManyAsync__1_Elastic_Clients_Elasticsearch_ElasticsearchClient_System_Collections_Generic_IEnumerable___0__Elastic_Clients_Elasticsearch_IndexName_System_Threading_CancellationToken_">IndexManyExtensions.IndexManyAsync&lt;T&gt;(ElasticsearchClient, IEnumerable&lt;T&gt;, IndexName, CancellationToken)</a>
  </div>
  <div>
      <a class="xref" href="Elastic.Clients.Elasticsearch.IndexManyExtensions.html#Elastic_Clients_Elasticsearch_IndexManyExtensions_IndexManyAsync__1_Elastic_Clients_Elasticsearch_ElasticsearchClient_System_Collections_Generic_IEnumerable___0__System_Threading_CancellationToken_">IndexManyExtensions.IndexManyAsync&lt;T&gt;(ElasticsearchClient, IEnumerable&lt;T&gt;, CancellationToken)</a>
  </div>
  <div>
      <a class="xref" href="Elastic.Clients.Elasticsearch.IndexManyExtensions.html#Elastic_Clients_Elasticsearch_IndexManyExtensions_IndexMany__1_Elastic_Clients_Elasticsearch_ElasticsearchClient_System_Collections_Generic_IEnumerable___0__">IndexManyExtensions.IndexMany&lt;T&gt;(ElasticsearchClient, IEnumerable&lt;T&gt;)</a>
  </div>
  <div>
      <a class="xref" href="Elastic.Clients.Elasticsearch.IndexManyExtensions.html#Elastic_Clients_Elasticsearch_IndexManyExtensions_IndexMany__1_Elastic_Clients_Elasticsearch_ElasticsearchClient_System_Collections_Generic_IEnumerable___0__Elastic_Clients_Elasticsearch_IndexName_">IndexManyExtensions.IndexMany&lt;T&gt;(ElasticsearchClient, IEnumerable&lt;T&gt;, IndexName)</a>
  </div>
  <div>
      <a class="xref" href="Elastic.Clients.Elasticsearch.SuffixExtensions.html#Elastic_Clients_Elasticsearch_SuffixExtensions_Suffix_System_Object_System_String_">SuffixExtensions.Suffix(object, string)</a>
  </div>
  </dd></dl>





  <h2 class="section" id="constructors">Constructors
</h2>


  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient__ctor_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.#ctor*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient__ctor" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.#ctor">
  ElasticsearchClient()
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Shared/Client/ElasticsearchClient.cs/#L36"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Creates a client configured to connect to http://localhost:9200.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ElasticsearchClient()</code></pre>
  </div>













  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient__ctor_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.#ctor*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient__ctor_Elastic_Clients_Elasticsearch_IElasticsearchClientSettings_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.#ctor(Elastic.Clients.Elasticsearch.IElasticsearchClientSettings)">
  ElasticsearchClient(IElasticsearchClientSettings)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Shared/Client/ElasticsearchClient.cs/#L63"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Creates a client using the provided configuration to initialise the client.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ElasticsearchClient(IElasticsearchClientSettings elasticsearchClientSettings)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>elasticsearchClientSettings</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IElasticsearchClientSettings.html">IElasticsearchClientSettings</a></dt>
    <dd><p>The <a class="xref" href="Elastic.Clients.Elasticsearch.IElasticsearchClientSettings.html">IElasticsearchClientSettings</a> used to configure the client.</p>
</dd>
  </dl>












  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient__ctor_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.#ctor*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient__ctor_System_String_Elastic_Transport_AuthorizationHeader_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.#ctor(System.String,Elastic.Transport.AuthorizationHeader)">
  ElasticsearchClient(string, AuthorizationHeader)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Shared/Client/ElasticsearchClient.cs/#L54"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Creates a client configured to communicate with Elastic Cloud using the provided <code class="paramref">cloudId</code>.</p>
<p>See the <a class="xref" href="https://github.com/elastic/elastic-transport-net/blob/8.18.3/src/Elastic.Transport/Components/NodePool/CloudNodePool.cs">CloudNodePool</a> documentation for more information on how to obtain your Cloud Id.</p>
  <p>
    If you want more control, use the <a class="xref" href="Elastic.Clients.Elasticsearch.ElasticsearchClient.html#Elastic_Clients_Elasticsearch_ElasticsearchClient__ctor_Elastic_Clients_Elasticsearch_IElasticsearchClientSettings_">ElasticsearchClient(IElasticsearchClientSettings)</a> constructor and
    pass an instance of <a class="xref" href="Elastic.Clients.Elasticsearch.ElasticsearchClient.html#Elastic_Clients_Elasticsearch_ElasticsearchClient_ElasticsearchClientSettings">ElasticsearchClientSettings</a> that takes a <code class="paramref">cloudId</code> in its constructor as well.
  </p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ElasticsearchClient(string cloudId, AuthorizationHeader credentials)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>cloudId</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a></dt>
    <dd><p>The Cloud ID of an Elastic Cloud deployment.</p>
</dd>
    <dt><code>credentials</code> <a class="xref" href="https://github.com/elastic/elastic-transport-net/blob/8.18.3/src/Elastic.Transport/Configuration/Security/AuthorizationHeader.cs">AuthorizationHeader</a></dt>
    <dd><p>The credentials to use for the connection.</p>
</dd>
  </dl>












  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient__ctor_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.#ctor*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient__ctor_System_Uri_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.#ctor(System.Uri)">
  ElasticsearchClient(Uri)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Shared/Client/ElasticsearchClient.cs/#L42"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Creates a client configured to connect to a node reachable at the provided <code class="paramref">uri</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ElasticsearchClient(Uri uri)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>uri</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.uri">Uri</a></dt>
    <dd><p>The <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.uri">Uri</a> to connect to.</p>
</dd>
  </dl>












  <h2 class="section" id="properties">Properties
</h2>


  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_AsyncSearch_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.AsyncSearch*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_AsyncSearch" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.AsyncSearch">
  AsyncSearch
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L59"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"></div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual AsyncSearchNamespacedClient AsyncSearch { get; }</code></pre>
  </div>





  <h4 class="section">Property Value</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.AsyncSearch.AsyncSearchNamespacedClient.html">AsyncSearchNamespacedClient</a></dt>
    <dd></dd>
  </dl>








  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Cluster_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Cluster*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Cluster" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Cluster">
  Cluster
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L60"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"></div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual ClusterNamespacedClient Cluster { get; }</code></pre>
  </div>





  <h4 class="section">Property Value</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.Cluster.ClusterNamespacedClient.html">ClusterNamespacedClient</a></dt>
    <dd></dd>
  </dl>








  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_CrossClusterReplication_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.CrossClusterReplication*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_CrossClusterReplication" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.CrossClusterReplication">
  CrossClusterReplication
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L61"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"></div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual CrossClusterReplicationNamespacedClient CrossClusterReplication { get; }</code></pre>
  </div>





  <h4 class="section">Property Value</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.CrossClusterReplication.CrossClusterReplicationNamespacedClient.html">CrossClusterReplicationNamespacedClient</a></dt>
    <dd></dd>
  </dl>








  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DanglingIndices_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DanglingIndices*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DanglingIndices" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DanglingIndices">
  DanglingIndices
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L62"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"></div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual DanglingIndicesNamespacedClient DanglingIndices { get; }</code></pre>
  </div>





  <h4 class="section">Property Value</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.DanglingIndices.DanglingIndicesNamespacedClient.html">DanglingIndicesNamespacedClient</a></dt>
    <dd></dd>
  </dl>








  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ElasticsearchClientSettings_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ElasticsearchClientSettings*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ElasticsearchClientSettings" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ElasticsearchClientSettings">
  ElasticsearchClientSettings
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Shared/Client/ElasticsearchClient.cs/#L81"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"></div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public IElasticsearchClientSettings ElasticsearchClientSettings { get; }</code></pre>
  </div>





  <h4 class="section">Property Value</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.IElasticsearchClientSettings.html">IElasticsearchClientSettings</a></dt>
    <dd></dd>
  </dl>








  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Enrich_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Enrich*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Enrich" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Enrich">
  Enrich
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L63"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"></div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual EnrichNamespacedClient Enrich { get; }</code></pre>
  </div>





  <h4 class="section">Property Value</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.Enrich.EnrichNamespacedClient.html">EnrichNamespacedClient</a></dt>
    <dd></dd>
  </dl>








  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Eql_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Eql*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Eql" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Eql">
  Eql
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L64"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"></div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual EqlNamespacedClient Eql { get; }</code></pre>
  </div>





  <h4 class="section">Property Value</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.Eql.EqlNamespacedClient.html">EqlNamespacedClient</a></dt>
    <dd></dd>
  </dl>








  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Esql_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Esql*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Esql" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Esql">
  Esql
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L65"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"></div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual EsqlNamespacedClient Esql { get; }</code></pre>
  </div>





  <h4 class="section">Property Value</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.Esql.EsqlNamespacedClient.html">EsqlNamespacedClient</a></dt>
    <dd></dd>
  </dl>








  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Features_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Features*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Features" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Features">
  Features
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L66"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"></div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual FeaturesNamespacedClient Features { get; }</code></pre>
  </div>





  <h4 class="section">Property Value</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.Features.FeaturesNamespacedClient.html">FeaturesNamespacedClient</a></dt>
    <dd></dd>
  </dl>








  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Graph_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Graph*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Graph" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Graph">
  Graph
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L67"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"></div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual GraphNamespacedClient Graph { get; }</code></pre>
  </div>





  <h4 class="section">Property Value</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.Graph.GraphNamespacedClient.html">GraphNamespacedClient</a></dt>
    <dd></dd>
  </dl>








  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_IndexLifecycleManagement_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.IndexLifecycleManagement*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_IndexLifecycleManagement" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.IndexLifecycleManagement">
  IndexLifecycleManagement
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L68"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"></div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual IndexLifecycleManagementNamespacedClient IndexLifecycleManagement { get; }</code></pre>
  </div>





  <h4 class="section">Property Value</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.IndexLifecycleManagement.IndexLifecycleManagementNamespacedClient.html">IndexLifecycleManagementNamespacedClient</a></dt>
    <dd></dd>
  </dl>








  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Indices_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Indices*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Indices" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Indices">
  Indices
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L69"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"></div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual IndicesNamespacedClient Indices { get; }</code></pre>
  </div>





  <h4 class="section">Property Value</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.IndexManagement.IndicesNamespacedClient.html">IndicesNamespacedClient</a></dt>
    <dd></dd>
  </dl>








  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Infer_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Infer*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Infer" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Infer">
  Infer
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Shared/Client/ElasticsearchClient.cs/#L82"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"></div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public Inferrer Infer { get; }</code></pre>
  </div>





  <h4 class="section">Property Value</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.Inferrer.html">Inferrer</a></dt>
    <dd></dd>
  </dl>








  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Inference_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Inference*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Inference" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Inference">
  Inference
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L70"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"></div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual InferenceNamespacedClient Inference { get; }</code></pre>
  </div>





  <h4 class="section">Property Value</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.Inference.InferenceNamespacedClient.html">InferenceNamespacedClient</a></dt>
    <dd></dd>
  </dl>








  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Ingest_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Ingest*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Ingest" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Ingest">
  Ingest
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L71"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"></div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual IngestNamespacedClient Ingest { get; }</code></pre>
  </div>





  <h4 class="section">Property Value</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.Ingest.IngestNamespacedClient.html">IngestNamespacedClient</a></dt>
    <dd></dd>
  </dl>








  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_LicenseManagement_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.LicenseManagement*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_LicenseManagement" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.LicenseManagement">
  LicenseManagement
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L72"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"></div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual LicenseManagementNamespacedClient LicenseManagement { get; }</code></pre>
  </div>





  <h4 class="section">Property Value</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.LicenseManagement.LicenseManagementNamespacedClient.html">LicenseManagementNamespacedClient</a></dt>
    <dd></dd>
  </dl>








  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MachineLearning_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MachineLearning*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MachineLearning" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MachineLearning">
  MachineLearning
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L73"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"></div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual MachineLearningNamespacedClient MachineLearning { get; }</code></pre>
  </div>





  <h4 class="section">Property Value</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.MachineLearning.MachineLearningNamespacedClient.html">MachineLearningNamespacedClient</a></dt>
    <dd></dd>
  </dl>








  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Nodes_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Nodes*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Nodes" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Nodes">
  Nodes
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L74"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"></div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual NodesNamespacedClient Nodes { get; }</code></pre>
  </div>





  <h4 class="section">Property Value</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.Nodes.NodesNamespacedClient.html">NodesNamespacedClient</a></dt>
    <dd></dd>
  </dl>








  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_QueryRules_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.QueryRules*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_QueryRules" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.QueryRules">
  QueryRules
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L75"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"></div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual QueryRulesNamespacedClient QueryRules { get; }</code></pre>
  </div>





  <h4 class="section">Property Value</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.QueryRules.QueryRulesNamespacedClient.html">QueryRulesNamespacedClient</a></dt>
    <dd></dd>
  </dl>








  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_RequestResponseSerializer_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.RequestResponseSerializer*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_RequestResponseSerializer" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.RequestResponseSerializer">
  RequestResponseSerializer
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Shared/Client/ElasticsearchClient.cs/#L83"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"></div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public Serializer RequestResponseSerializer { get; }</code></pre>
  </div>





  <h4 class="section">Property Value</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://github.com/elastic/elastic-transport-net/blob/8.18.3/src/Elastic.Transport/Components/Serialization/Serializer.cs">Serializer</a></dt>
    <dd></dd>
  </dl>








  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Rollup_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Rollup*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Rollup" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Rollup">
  Rollup
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L76"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"></div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual RollupNamespacedClient Rollup { get; }</code></pre>
  </div>





  <h4 class="section">Property Value</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.Rollup.RollupNamespacedClient.html">RollupNamespacedClient</a></dt>
    <dd></dd>
  </dl>








  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchApplication_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchApplication*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchApplication" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchApplication">
  SearchApplication
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L78"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"></div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual SearchApplicationNamespacedClient SearchApplication { get; }</code></pre>
  </div>





  <h4 class="section">Property Value</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.SearchApplication.SearchApplicationNamespacedClient.html">SearchApplicationNamespacedClient</a></dt>
    <dd></dd>
  </dl>








  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchableSnapshots_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchableSnapshots*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchableSnapshots" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchableSnapshots">
  SearchableSnapshots
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L77"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"></div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual SearchableSnapshotsNamespacedClient SearchableSnapshots { get; }</code></pre>
  </div>





  <h4 class="section">Property Value</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.SearchableSnapshots.SearchableSnapshotsNamespacedClient.html">SearchableSnapshotsNamespacedClient</a></dt>
    <dd></dd>
  </dl>








  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Security_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Security*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Security" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Security">
  Security
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L79"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"></div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual SecurityNamespacedClient Security { get; }</code></pre>
  </div>





  <h4 class="section">Property Value</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.Security.SecurityNamespacedClient.html">SecurityNamespacedClient</a></dt>
    <dd></dd>
  </dl>








  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Simulate_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Simulate*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Simulate" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Simulate">
  Simulate
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L80"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"></div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual SimulateNamespacedClient Simulate { get; }</code></pre>
  </div>





  <h4 class="section">Property Value</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.Simulate.SimulateNamespacedClient.html">SimulateNamespacedClient</a></dt>
    <dd></dd>
  </dl>








  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Snapshot_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Snapshot*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Snapshot" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Snapshot">
  Snapshot
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L81"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"></div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual SnapshotNamespacedClient Snapshot { get; }</code></pre>
  </div>





  <h4 class="section">Property Value</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.Snapshot.SnapshotNamespacedClient.html">SnapshotNamespacedClient</a></dt>
    <dd></dd>
  </dl>








  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SnapshotLifecycleManagement_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SnapshotLifecycleManagement*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SnapshotLifecycleManagement" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SnapshotLifecycleManagement">
  SnapshotLifecycleManagement
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L82"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"></div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual SnapshotLifecycleManagementNamespacedClient SnapshotLifecycleManagement { get; }</code></pre>
  </div>





  <h4 class="section">Property Value</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.SnapshotLifecycleManagement.SnapshotLifecycleManagementNamespacedClient.html">SnapshotLifecycleManagementNamespacedClient</a></dt>
    <dd></dd>
  </dl>








  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SourceSerializer_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SourceSerializer*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SourceSerializer" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SourceSerializer">
  SourceSerializer
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Shared/Client/ElasticsearchClient.cs/#L84"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"></div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public Serializer SourceSerializer { get; }</code></pre>
  </div>





  <h4 class="section">Property Value</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://github.com/elastic/elastic-transport-net/blob/8.18.3/src/Elastic.Transport/Components/Serialization/Serializer.cs">Serializer</a></dt>
    <dd></dd>
  </dl>








  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Sql_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Sql*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Sql" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Sql">
  Sql
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L83"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"></div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual SqlNamespacedClient Sql { get; }</code></pre>
  </div>





  <h4 class="section">Property Value</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.Sql.SqlNamespacedClient.html">SqlNamespacedClient</a></dt>
    <dd></dd>
  </dl>








  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Synonyms_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Synonyms*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Synonyms" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Synonyms">
  Synonyms
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L84"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"></div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual SynonymsNamespacedClient Synonyms { get; }</code></pre>
  </div>





  <h4 class="section">Property Value</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.Synonyms.SynonymsNamespacedClient.html">SynonymsNamespacedClient</a></dt>
    <dd></dd>
  </dl>








  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Tasks_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Tasks*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Tasks" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Tasks">
  Tasks
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L85"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"></div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual TasksNamespacedClient Tasks { get; }</code></pre>
  </div>





  <h4 class="section">Property Value</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.Tasks.TasksNamespacedClient.html">TasksNamespacedClient</a></dt>
    <dd></dd>
  </dl>








  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_TextStructure_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.TextStructure*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_TextStructure" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.TextStructure">
  TextStructure
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L86"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"></div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual TextStructureNamespacedClient TextStructure { get; }</code></pre>
  </div>





  <h4 class="section">Property Value</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.TextStructure.TextStructureNamespacedClient.html">TextStructureNamespacedClient</a></dt>
    <dd></dd>
  </dl>








  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_TransformManagement_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.TransformManagement*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_TransformManagement" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.TransformManagement">
  TransformManagement
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L87"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"></div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual TransformManagementNamespacedClient TransformManagement { get; }</code></pre>
  </div>





  <h4 class="section">Property Value</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.TransformManagement.TransformManagementNamespacedClient.html">TransformManagementNamespacedClient</a></dt>
    <dd></dd>
  </dl>








  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Transport_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Transport*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Transport" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Transport">
  Transport
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Shared/Client/ElasticsearchClient.cs/#L85"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"></div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ITransport&lt;IElasticsearchClientSettings&gt; Transport { get; }</code></pre>
  </div>





  <h4 class="section">Property Value</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://github.com/elastic/elastic-transport-net/blob/8.18.3/src/Elastic.Transport/ITransport.cs">ITransport</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.IElasticsearchClientSettings.html">IElasticsearchClientSettings</a>&gt;</dt>
    <dd></dd>
  </dl>








  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Xpack_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Xpack*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Xpack" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Xpack">
  Xpack
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L88"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"></div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual XpackNamespacedClient Xpack { get; }</code></pre>
  </div>





  <h4 class="section">Property Value</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.Xpack.XpackNamespacedClient.html">XpackNamespacedClient</a></dt>
    <dd></dd>
  </dl>








  <h2 class="section" id="methods">Methods
</h2>


  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Bulk_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Bulk*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Bulk" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Bulk">
  Bulk()
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L2303"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Bulk index or delete documents.
Perform multiple <code>index</code>, <code>create</code>, <code>delete</code>, and <code>update</code> actions in a single request.
This reduces overhead and can greatly increase indexing speed.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or index alias:
</p>
<ul><li>
<p>
To use the <code>create</code> action, you must have the <code>create_doc</code>, <code>create</code>, <code>index</code>, or <code>write</code> index privilege. Data streams support only the <code>create</code> action.
</p>
</li><li>
<p>
To use the <code>index</code> action, you must have the <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To use the <code>delete</code> action, you must have the <code>delete</code> or <code>write</code> index privilege.
</p>
</li><li>
<p>
To use the <code>update</code> action, you must have the <code>index</code> or <code>write</code> index privilege.
</p>
</li><li>
<p>
To automatically create a data stream or index with a bulk API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege.
</p>
</li><li>
<p>
To make the result of a bulk operation visible to search using the <code>refresh</code> parameter, you must have the <code>maintenance</code> or <code>manage</code> index privilege.
</p>
</li></ul>
<p>
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
The actions are specified in the request body using a newline delimited JSON (NDJSON) structure:
</p>
<pre><code class="lang-csharp">action_and_meta_data\n
optional_source\n
action_and_meta_data\n
optional_source\n
....
action_and_meta_data\n
optional_source\n</code></pre>
<p>
The <code>index</code> and <code>create</code> actions expect a source on the next line and have the same semantics as the <code>op_type</code> parameter in the standard index API.
A <code>create</code> action fails if a document with the same ID already exists in the target
An <code>index</code> action adds or replaces a document as necessary.
</p>
<p>
NOTE: Data streams support only the <code>create</code> action.
To update or delete a document in a data stream, you must target the backing index containing the document.
</p>
<p>
An <code>update</code> action expects that the partial doc, upsert, and script and its options are specified on the next line.
</p>
<p>
A <code>delete</code> action does not expect a source on the next line and has the same semantics as the standard delete API.
</p>
<p>
NOTE: The final line of data must end with a newline character (<code>\n</code>).
Each newline character may be preceded by a carriage return (<code>\r</code>).
When sending NDJSON data to the <code>_bulk</code> endpoint, use a <code>Content-Type</code> header of <code>application/json</code> or <code>application/x-ndjson</code>.
Because this format uses literal newline characters (<code>\n</code>) as delimiters, make sure that the JSON actions and sources are not pretty printed.
</p>
<p>
If you provide a target in the request path, it is used for any actions that don't explicitly specify an <code>_index</code> argument.
</p>
<p>
A note on the format: the idea here is to make processing as fast as possible.
As some of the actions are redirected to other shards on other nodes, only <code>action_meta_data</code> is parsed on the receiving node side.
</p>
<p>
Client libraries using this protocol should try and strive to do something similar on the client side, and reduce buffering as much as possible.
</p>
<p>
There is no "correct" number of actions to perform in a single bulk request.
Experiment with different settings to find the optimal size for your particular workload.
Note that Elasticsearch limits the maximum size of a HTTP request to 100mb by default so clients must ensure that no request exceeds this size.
It is not possible to index a single document that exceeds the size limit, so you must pre-process any such documents into smaller pieces before sending them to Elasticsearch.
For instance, split documents into pages or chapters before indexing them, or store raw binary data in a system outside Elasticsearch and replace the raw data with a link to the external system in the documents that you send to Elasticsearch.
</p>
<p>
<strong>Client suppport for bulk requests</strong>
</p>
<p>
Some of the officially supported clients provide helpers to assist with bulk requests and reindexing:
</p>
<ul><li>
<p>
Go: Check out <code>esutil.BulkIndexer</code>
</p>
</li><li>
<p>
Perl: Check out <code>Search::Elasticsearch::Client::5_0::Bulk</code> and <code>Search::Elasticsearch::Client::5_0::Scroll</code>
</p>
</li><li>
<p>
Python: Check out <code>elasticsearch.helpers.*</code>
</p>
</li><li>
<p>
JavaScript: Check out <code>client.helpers.*</code>
</p>
</li><li>
<p>
.NET: Check out <code>BulkAllObservable</code>
</p>
</li><li>
<p>
PHP: Check out bulk indexing.
</p>
</li></ul>
<p>
<strong>Submitting bulk requests with cURL</strong>
</p>
<p>
If you're providing text file input to <code>curl</code>, you must use the <code>--data-binary</code> flag instead of plain <code>-d</code>.
The latter doesn't preserve newlines. For example:
</p>
<pre><code class="lang-csharp">$ cat requests
{ "index" : { "_index" : "test", "_id" : "1" } }
{ "field1" : "value1" }
$ curl -s -H "Content-Type: application/x-ndjson" -XPOST localhost:9200/_bulk --data-binary "@requests"; echo
{"took":7, "errors": false, "items":[{"index":{"_index":"test","_id":"1","_version":1,"result":"created","forced_refresh":false}}]}</code></pre>
<p>
<strong>Optimistic concurrency control</strong>
</p>
<p>
Each <code>index</code> and <code>delete</code> action within a bulk API call may include the <code>if_seq_no</code> and <code>if_primary_term</code> parameters in their respective action and meta data lines.
The <code>if_seq_no</code> and <code>if_primary_term</code> parameters control how operations are run, based on the last modification to existing documents. See Optimistic concurrency control for more details.
</p>
<p>
<strong>Versioning</strong>
</p>
<p>
Each bulk item can include the version value using the <code>version</code> field.
It automatically follows the behavior of the index or delete operation based on the <code>_version</code> mapping.
It also support the <code>version_type</code>.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
Each bulk item can include the routing value using the <code>routing</code> field.
It automatically follows the behavior of the index or delete operation based on the <code>_routing</code> mapping.
</p>
<p>
NOTE: Data streams do not support custom routing unless they were created with the <code>allow_custom_routing</code> setting enabled in the template.
</p>
<p>
<strong>Wait for active shards</strong>
</p>
<p>
When making bulk calls, you can set the <code>wait_for_active_shards</code> parameter to require a minimum number of shard copies to be active before starting to process the bulk request.
</p>
<p>
<strong>Refresh</strong>
</p>
<p>
Control when the changes made by this request are visible to search.
</p>
<p>
NOTE: Only the shards that receive the bulk request will be affected by refresh.
Imagine a <code>_bulk?refresh=wait_for</code> request with three documents in it that happen to be routed to different shards in an index with five shards.
The request will only wait for those three shards to refresh.
The other two shards that make up the index do not participate in the <code>_bulk</code> request at all.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-bulk.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual BulkResponse Bulk()</code></pre>
  </div>


  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.BulkResponse.html">BulkResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Bulk_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Bulk*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Bulk_Elastic_Clients_Elasticsearch_BulkRequest_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Bulk(Elastic.Clients.Elasticsearch.BulkRequest)">
  Bulk(BulkRequest)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L315"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Bulk index or delete documents.
Perform multiple <code>index</code>, <code>create</code>, <code>delete</code>, and <code>update</code> actions in a single request.
This reduces overhead and can greatly increase indexing speed.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or index alias:
</p>
<ul><li>
<p>
To use the <code>create</code> action, you must have the <code>create_doc</code>, <code>create</code>, <code>index</code>, or <code>write</code> index privilege. Data streams support only the <code>create</code> action.
</p>
</li><li>
<p>
To use the <code>index</code> action, you must have the <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To use the <code>delete</code> action, you must have the <code>delete</code> or <code>write</code> index privilege.
</p>
</li><li>
<p>
To use the <code>update</code> action, you must have the <code>index</code> or <code>write</code> index privilege.
</p>
</li><li>
<p>
To automatically create a data stream or index with a bulk API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege.
</p>
</li><li>
<p>
To make the result of a bulk operation visible to search using the <code>refresh</code> parameter, you must have the <code>maintenance</code> or <code>manage</code> index privilege.
</p>
</li></ul>
<p>
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
The actions are specified in the request body using a newline delimited JSON (NDJSON) structure:
</p>
<pre><code class="lang-csharp">action_and_meta_data\n
optional_source\n
action_and_meta_data\n
optional_source\n
....
action_and_meta_data\n
optional_source\n</code></pre>
<p>
The <code>index</code> and <code>create</code> actions expect a source on the next line and have the same semantics as the <code>op_type</code> parameter in the standard index API.
A <code>create</code> action fails if a document with the same ID already exists in the target
An <code>index</code> action adds or replaces a document as necessary.
</p>
<p>
NOTE: Data streams support only the <code>create</code> action.
To update or delete a document in a data stream, you must target the backing index containing the document.
</p>
<p>
An <code>update</code> action expects that the partial doc, upsert, and script and its options are specified on the next line.
</p>
<p>
A <code>delete</code> action does not expect a source on the next line and has the same semantics as the standard delete API.
</p>
<p>
NOTE: The final line of data must end with a newline character (<code>\n</code>).
Each newline character may be preceded by a carriage return (<code>\r</code>).
When sending NDJSON data to the <code>_bulk</code> endpoint, use a <code>Content-Type</code> header of <code>application/json</code> or <code>application/x-ndjson</code>.
Because this format uses literal newline characters (<code>\n</code>) as delimiters, make sure that the JSON actions and sources are not pretty printed.
</p>
<p>
If you provide a target in the request path, it is used for any actions that don't explicitly specify an <code>_index</code> argument.
</p>
<p>
A note on the format: the idea here is to make processing as fast as possible.
As some of the actions are redirected to other shards on other nodes, only <code>action_meta_data</code> is parsed on the receiving node side.
</p>
<p>
Client libraries using this protocol should try and strive to do something similar on the client side, and reduce buffering as much as possible.
</p>
<p>
There is no "correct" number of actions to perform in a single bulk request.
Experiment with different settings to find the optimal size for your particular workload.
Note that Elasticsearch limits the maximum size of a HTTP request to 100mb by default so clients must ensure that no request exceeds this size.
It is not possible to index a single document that exceeds the size limit, so you must pre-process any such documents into smaller pieces before sending them to Elasticsearch.
For instance, split documents into pages or chapters before indexing them, or store raw binary data in a system outside Elasticsearch and replace the raw data with a link to the external system in the documents that you send to Elasticsearch.
</p>
<p>
<strong>Client suppport for bulk requests</strong>
</p>
<p>
Some of the officially supported clients provide helpers to assist with bulk requests and reindexing:
</p>
<ul><li>
<p>
Go: Check out <code>esutil.BulkIndexer</code>
</p>
</li><li>
<p>
Perl: Check out <code>Search::Elasticsearch::Client::5_0::Bulk</code> and <code>Search::Elasticsearch::Client::5_0::Scroll</code>
</p>
</li><li>
<p>
Python: Check out <code>elasticsearch.helpers.*</code>
</p>
</li><li>
<p>
JavaScript: Check out <code>client.helpers.*</code>
</p>
</li><li>
<p>
.NET: Check out <code>BulkAllObservable</code>
</p>
</li><li>
<p>
PHP: Check out bulk indexing.
</p>
</li></ul>
<p>
<strong>Submitting bulk requests with cURL</strong>
</p>
<p>
If you're providing text file input to <code>curl</code>, you must use the <code>--data-binary</code> flag instead of plain <code>-d</code>.
The latter doesn't preserve newlines. For example:
</p>
<pre><code class="lang-csharp">$ cat requests
{ "index" : { "_index" : "test", "_id" : "1" } }
{ "field1" : "value1" }
$ curl -s -H "Content-Type: application/x-ndjson" -XPOST localhost:9200/_bulk --data-binary "@requests"; echo
{"took":7, "errors": false, "items":[{"index":{"_index":"test","_id":"1","_version":1,"result":"created","forced_refresh":false}}]}</code></pre>
<p>
<strong>Optimistic concurrency control</strong>
</p>
<p>
Each <code>index</code> and <code>delete</code> action within a bulk API call may include the <code>if_seq_no</code> and <code>if_primary_term</code> parameters in their respective action and meta data lines.
The <code>if_seq_no</code> and <code>if_primary_term</code> parameters control how operations are run, based on the last modification to existing documents. See Optimistic concurrency control for more details.
</p>
<p>
<strong>Versioning</strong>
</p>
<p>
Each bulk item can include the version value using the <code>version</code> field.
It automatically follows the behavior of the index or delete operation based on the <code>_version</code> mapping.
It also support the <code>version_type</code>.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
Each bulk item can include the routing value using the <code>routing</code> field.
It automatically follows the behavior of the index or delete operation based on the <code>_routing</code> mapping.
</p>
<p>
NOTE: Data streams do not support custom routing unless they were created with the <code>allow_custom_routing</code> setting enabled in the template.
</p>
<p>
<strong>Wait for active shards</strong>
</p>
<p>
When making bulk calls, you can set the <code>wait_for_active_shards</code> parameter to require a minimum number of shard copies to be active before starting to process the bulk request.
</p>
<p>
<strong>Refresh</strong>
</p>
<p>
Control when the changes made by this request are visible to search.
</p>
<p>
NOTE: Only the shards that receive the bulk request will be affected by refresh.
Imagine a <code>_bulk?refresh=wait_for</code> request with three documents in it that happen to be routed to different shards in an index with five shards.
The request will only wait for those three shards to refresh.
The other two shards that make up the index do not participate in the <code>_bulk</code> request at all.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-bulk.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual BulkResponse Bulk(BulkRequest request)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.BulkRequest.html">BulkRequest</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.BulkResponse.html">BulkResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Bulk_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Bulk*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Bulk_Elastic_Clients_Elasticsearch_BulkRequestDescriptor_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Bulk(Elastic.Clients.Elasticsearch.BulkRequestDescriptor)">
  Bulk(BulkRequestDescriptor)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L1706"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Bulk index or delete documents.
Perform multiple <code>index</code>, <code>create</code>, <code>delete</code>, and <code>update</code> actions in a single request.
This reduces overhead and can greatly increase indexing speed.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or index alias:
</p>
<ul><li>
<p>
To use the <code>create</code> action, you must have the <code>create_doc</code>, <code>create</code>, <code>index</code>, or <code>write</code> index privilege. Data streams support only the <code>create</code> action.
</p>
</li><li>
<p>
To use the <code>index</code> action, you must have the <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To use the <code>delete</code> action, you must have the <code>delete</code> or <code>write</code> index privilege.
</p>
</li><li>
<p>
To use the <code>update</code> action, you must have the <code>index</code> or <code>write</code> index privilege.
</p>
</li><li>
<p>
To automatically create a data stream or index with a bulk API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege.
</p>
</li><li>
<p>
To make the result of a bulk operation visible to search using the <code>refresh</code> parameter, you must have the <code>maintenance</code> or <code>manage</code> index privilege.
</p>
</li></ul>
<p>
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
The actions are specified in the request body using a newline delimited JSON (NDJSON) structure:
</p>
<pre><code class="lang-csharp">action_and_meta_data\n
optional_source\n
action_and_meta_data\n
optional_source\n
....
action_and_meta_data\n
optional_source\n</code></pre>
<p>
The <code>index</code> and <code>create</code> actions expect a source on the next line and have the same semantics as the <code>op_type</code> parameter in the standard index API.
A <code>create</code> action fails if a document with the same ID already exists in the target
An <code>index</code> action adds or replaces a document as necessary.
</p>
<p>
NOTE: Data streams support only the <code>create</code> action.
To update or delete a document in a data stream, you must target the backing index containing the document.
</p>
<p>
An <code>update</code> action expects that the partial doc, upsert, and script and its options are specified on the next line.
</p>
<p>
A <code>delete</code> action does not expect a source on the next line and has the same semantics as the standard delete API.
</p>
<p>
NOTE: The final line of data must end with a newline character (<code>\n</code>).
Each newline character may be preceded by a carriage return (<code>\r</code>).
When sending NDJSON data to the <code>_bulk</code> endpoint, use a <code>Content-Type</code> header of <code>application/json</code> or <code>application/x-ndjson</code>.
Because this format uses literal newline characters (<code>\n</code>) as delimiters, make sure that the JSON actions and sources are not pretty printed.
</p>
<p>
If you provide a target in the request path, it is used for any actions that don't explicitly specify an <code>_index</code> argument.
</p>
<p>
A note on the format: the idea here is to make processing as fast as possible.
As some of the actions are redirected to other shards on other nodes, only <code>action_meta_data</code> is parsed on the receiving node side.
</p>
<p>
Client libraries using this protocol should try and strive to do something similar on the client side, and reduce buffering as much as possible.
</p>
<p>
There is no "correct" number of actions to perform in a single bulk request.
Experiment with different settings to find the optimal size for your particular workload.
Note that Elasticsearch limits the maximum size of a HTTP request to 100mb by default so clients must ensure that no request exceeds this size.
It is not possible to index a single document that exceeds the size limit, so you must pre-process any such documents into smaller pieces before sending them to Elasticsearch.
For instance, split documents into pages or chapters before indexing them, or store raw binary data in a system outside Elasticsearch and replace the raw data with a link to the external system in the documents that you send to Elasticsearch.
</p>
<p>
<strong>Client suppport for bulk requests</strong>
</p>
<p>
Some of the officially supported clients provide helpers to assist with bulk requests and reindexing:
</p>
<ul><li>
<p>
Go: Check out <code>esutil.BulkIndexer</code>
</p>
</li><li>
<p>
Perl: Check out <code>Search::Elasticsearch::Client::5_0::Bulk</code> and <code>Search::Elasticsearch::Client::5_0::Scroll</code>
</p>
</li><li>
<p>
Python: Check out <code>elasticsearch.helpers.*</code>
</p>
</li><li>
<p>
JavaScript: Check out <code>client.helpers.*</code>
</p>
</li><li>
<p>
.NET: Check out <code>BulkAllObservable</code>
</p>
</li><li>
<p>
PHP: Check out bulk indexing.
</p>
</li></ul>
<p>
<strong>Submitting bulk requests with cURL</strong>
</p>
<p>
If you're providing text file input to <code>curl</code>, you must use the <code>--data-binary</code> flag instead of plain <code>-d</code>.
The latter doesn't preserve newlines. For example:
</p>
<pre><code class="lang-csharp">$ cat requests
{ "index" : { "_index" : "test", "_id" : "1" } }
{ "field1" : "value1" }
$ curl -s -H "Content-Type: application/x-ndjson" -XPOST localhost:9200/_bulk --data-binary "@requests"; echo
{"took":7, "errors": false, "items":[{"index":{"_index":"test","_id":"1","_version":1,"result":"created","forced_refresh":false}}]}</code></pre>
<p>
<strong>Optimistic concurrency control</strong>
</p>
<p>
Each <code>index</code> and <code>delete</code> action within a bulk API call may include the <code>if_seq_no</code> and <code>if_primary_term</code> parameters in their respective action and meta data lines.
The <code>if_seq_no</code> and <code>if_primary_term</code> parameters control how operations are run, based on the last modification to existing documents. See Optimistic concurrency control for more details.
</p>
<p>
<strong>Versioning</strong>
</p>
<p>
Each bulk item can include the version value using the <code>version</code> field.
It automatically follows the behavior of the index or delete operation based on the <code>_version</code> mapping.
It also support the <code>version_type</code>.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
Each bulk item can include the routing value using the <code>routing</code> field.
It automatically follows the behavior of the index or delete operation based on the <code>_routing</code> mapping.
</p>
<p>
NOTE: Data streams do not support custom routing unless they were created with the <code>allow_custom_routing</code> setting enabled in the template.
</p>
<p>
<strong>Wait for active shards</strong>
</p>
<p>
When making bulk calls, you can set the <code>wait_for_active_shards</code> parameter to require a minimum number of shard copies to be active before starting to process the bulk request.
</p>
<p>
<strong>Refresh</strong>
</p>
<p>
Control when the changes made by this request are visible to search.
</p>
<p>
NOTE: Only the shards that receive the bulk request will be affected by refresh.
Imagine a <code>_bulk?refresh=wait_for</code> request with three documents in it that happen to be routed to different shards in an index with five shards.
The request will only wait for those three shards to refresh.
The other two shards that make up the index do not participate in the <code>_bulk</code> request at all.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-bulk.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual BulkResponse Bulk(BulkRequestDescriptor descriptor)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.BulkRequestDescriptor.html">BulkRequestDescriptor</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.BulkResponse.html">BulkResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Bulk_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Bulk*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Bulk_Elastic_Clients_Elasticsearch_IndexName_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Bulk(Elastic.Clients.Elasticsearch.IndexName)">
  Bulk(IndexName?)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L1904"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Bulk index or delete documents.
Perform multiple <code>index</code>, <code>create</code>, <code>delete</code>, and <code>update</code> actions in a single request.
This reduces overhead and can greatly increase indexing speed.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or index alias:
</p>
<ul><li>
<p>
To use the <code>create</code> action, you must have the <code>create_doc</code>, <code>create</code>, <code>index</code>, or <code>write</code> index privilege. Data streams support only the <code>create</code> action.
</p>
</li><li>
<p>
To use the <code>index</code> action, you must have the <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To use the <code>delete</code> action, you must have the <code>delete</code> or <code>write</code> index privilege.
</p>
</li><li>
<p>
To use the <code>update</code> action, you must have the <code>index</code> or <code>write</code> index privilege.
</p>
</li><li>
<p>
To automatically create a data stream or index with a bulk API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege.
</p>
</li><li>
<p>
To make the result of a bulk operation visible to search using the <code>refresh</code> parameter, you must have the <code>maintenance</code> or <code>manage</code> index privilege.
</p>
</li></ul>
<p>
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
The actions are specified in the request body using a newline delimited JSON (NDJSON) structure:
</p>
<pre><code class="lang-csharp">action_and_meta_data\n
optional_source\n
action_and_meta_data\n
optional_source\n
....
action_and_meta_data\n
optional_source\n</code></pre>
<p>
The <code>index</code> and <code>create</code> actions expect a source on the next line and have the same semantics as the <code>op_type</code> parameter in the standard index API.
A <code>create</code> action fails if a document with the same ID already exists in the target
An <code>index</code> action adds or replaces a document as necessary.
</p>
<p>
NOTE: Data streams support only the <code>create</code> action.
To update or delete a document in a data stream, you must target the backing index containing the document.
</p>
<p>
An <code>update</code> action expects that the partial doc, upsert, and script and its options are specified on the next line.
</p>
<p>
A <code>delete</code> action does not expect a source on the next line and has the same semantics as the standard delete API.
</p>
<p>
NOTE: The final line of data must end with a newline character (<code>\n</code>).
Each newline character may be preceded by a carriage return (<code>\r</code>).
When sending NDJSON data to the <code>_bulk</code> endpoint, use a <code>Content-Type</code> header of <code>application/json</code> or <code>application/x-ndjson</code>.
Because this format uses literal newline characters (<code>\n</code>) as delimiters, make sure that the JSON actions and sources are not pretty printed.
</p>
<p>
If you provide a target in the request path, it is used for any actions that don't explicitly specify an <code>_index</code> argument.
</p>
<p>
A note on the format: the idea here is to make processing as fast as possible.
As some of the actions are redirected to other shards on other nodes, only <code>action_meta_data</code> is parsed on the receiving node side.
</p>
<p>
Client libraries using this protocol should try and strive to do something similar on the client side, and reduce buffering as much as possible.
</p>
<p>
There is no "correct" number of actions to perform in a single bulk request.
Experiment with different settings to find the optimal size for your particular workload.
Note that Elasticsearch limits the maximum size of a HTTP request to 100mb by default so clients must ensure that no request exceeds this size.
It is not possible to index a single document that exceeds the size limit, so you must pre-process any such documents into smaller pieces before sending them to Elasticsearch.
For instance, split documents into pages or chapters before indexing them, or store raw binary data in a system outside Elasticsearch and replace the raw data with a link to the external system in the documents that you send to Elasticsearch.
</p>
<p>
<strong>Client suppport for bulk requests</strong>
</p>
<p>
Some of the officially supported clients provide helpers to assist with bulk requests and reindexing:
</p>
<ul><li>
<p>
Go: Check out <code>esutil.BulkIndexer</code>
</p>
</li><li>
<p>
Perl: Check out <code>Search::Elasticsearch::Client::5_0::Bulk</code> and <code>Search::Elasticsearch::Client::5_0::Scroll</code>
</p>
</li><li>
<p>
Python: Check out <code>elasticsearch.helpers.*</code>
</p>
</li><li>
<p>
JavaScript: Check out <code>client.helpers.*</code>
</p>
</li><li>
<p>
.NET: Check out <code>BulkAllObservable</code>
</p>
</li><li>
<p>
PHP: Check out bulk indexing.
</p>
</li></ul>
<p>
<strong>Submitting bulk requests with cURL</strong>
</p>
<p>
If you're providing text file input to <code>curl</code>, you must use the <code>--data-binary</code> flag instead of plain <code>-d</code>.
The latter doesn't preserve newlines. For example:
</p>
<pre><code class="lang-csharp">$ cat requests
{ "index" : { "_index" : "test", "_id" : "1" } }
{ "field1" : "value1" }
$ curl -s -H "Content-Type: application/x-ndjson" -XPOST localhost:9200/_bulk --data-binary "@requests"; echo
{"took":7, "errors": false, "items":[{"index":{"_index":"test","_id":"1","_version":1,"result":"created","forced_refresh":false}}]}</code></pre>
<p>
<strong>Optimistic concurrency control</strong>
</p>
<p>
Each <code>index</code> and <code>delete</code> action within a bulk API call may include the <code>if_seq_no</code> and <code>if_primary_term</code> parameters in their respective action and meta data lines.
The <code>if_seq_no</code> and <code>if_primary_term</code> parameters control how operations are run, based on the last modification to existing documents. See Optimistic concurrency control for more details.
</p>
<p>
<strong>Versioning</strong>
</p>
<p>
Each bulk item can include the version value using the <code>version</code> field.
It automatically follows the behavior of the index or delete operation based on the <code>_version</code> mapping.
It also support the <code>version_type</code>.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
Each bulk item can include the routing value using the <code>routing</code> field.
It automatically follows the behavior of the index or delete operation based on the <code>_routing</code> mapping.
</p>
<p>
NOTE: Data streams do not support custom routing unless they were created with the <code>allow_custom_routing</code> setting enabled in the template.
</p>
<p>
<strong>Wait for active shards</strong>
</p>
<p>
When making bulk calls, you can set the <code>wait_for_active_shards</code> parameter to require a minimum number of shard copies to be active before starting to process the bulk request.
</p>
<p>
<strong>Refresh</strong>
</p>
<p>
Control when the changes made by this request are visible to search.
</p>
<p>
NOTE: Only the shards that receive the bulk request will be affected by refresh.
Imagine a <code>_bulk?refresh=wait_for</code> request with three documents in it that happen to be routed to different shards in an index with five shards.
The request will only wait for those three shards to refresh.
The other two shards that make up the index do not participate in the <code>_bulk</code> request at all.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-bulk.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual BulkResponse Bulk(IndexName? index)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.BulkResponse.html">BulkResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Bulk_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Bulk*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Bulk_Elastic_Clients_Elasticsearch_IndexName_System_Action_Elastic_Clients_Elasticsearch_BulkRequestDescriptor__" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Bulk(Elastic.Clients.Elasticsearch.IndexName,System.Action{Elastic.Clients.Elasticsearch.BulkRequestDescriptor})">
  Bulk(IndexName?, Action&lt;BulkRequestDescriptor&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L2103"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Bulk index or delete documents.
Perform multiple <code>index</code>, <code>create</code>, <code>delete</code>, and <code>update</code> actions in a single request.
This reduces overhead and can greatly increase indexing speed.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or index alias:
</p>
<ul><li>
<p>
To use the <code>create</code> action, you must have the <code>create_doc</code>, <code>create</code>, <code>index</code>, or <code>write</code> index privilege. Data streams support only the <code>create</code> action.
</p>
</li><li>
<p>
To use the <code>index</code> action, you must have the <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To use the <code>delete</code> action, you must have the <code>delete</code> or <code>write</code> index privilege.
</p>
</li><li>
<p>
To use the <code>update</code> action, you must have the <code>index</code> or <code>write</code> index privilege.
</p>
</li><li>
<p>
To automatically create a data stream or index with a bulk API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege.
</p>
</li><li>
<p>
To make the result of a bulk operation visible to search using the <code>refresh</code> parameter, you must have the <code>maintenance</code> or <code>manage</code> index privilege.
</p>
</li></ul>
<p>
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
The actions are specified in the request body using a newline delimited JSON (NDJSON) structure:
</p>
<pre><code class="lang-csharp">action_and_meta_data\n
optional_source\n
action_and_meta_data\n
optional_source\n
....
action_and_meta_data\n
optional_source\n</code></pre>
<p>
The <code>index</code> and <code>create</code> actions expect a source on the next line and have the same semantics as the <code>op_type</code> parameter in the standard index API.
A <code>create</code> action fails if a document with the same ID already exists in the target
An <code>index</code> action adds or replaces a document as necessary.
</p>
<p>
NOTE: Data streams support only the <code>create</code> action.
To update or delete a document in a data stream, you must target the backing index containing the document.
</p>
<p>
An <code>update</code> action expects that the partial doc, upsert, and script and its options are specified on the next line.
</p>
<p>
A <code>delete</code> action does not expect a source on the next line and has the same semantics as the standard delete API.
</p>
<p>
NOTE: The final line of data must end with a newline character (<code>\n</code>).
Each newline character may be preceded by a carriage return (<code>\r</code>).
When sending NDJSON data to the <code>_bulk</code> endpoint, use a <code>Content-Type</code> header of <code>application/json</code> or <code>application/x-ndjson</code>.
Because this format uses literal newline characters (<code>\n</code>) as delimiters, make sure that the JSON actions and sources are not pretty printed.
</p>
<p>
If you provide a target in the request path, it is used for any actions that don't explicitly specify an <code>_index</code> argument.
</p>
<p>
A note on the format: the idea here is to make processing as fast as possible.
As some of the actions are redirected to other shards on other nodes, only <code>action_meta_data</code> is parsed on the receiving node side.
</p>
<p>
Client libraries using this protocol should try and strive to do something similar on the client side, and reduce buffering as much as possible.
</p>
<p>
There is no "correct" number of actions to perform in a single bulk request.
Experiment with different settings to find the optimal size for your particular workload.
Note that Elasticsearch limits the maximum size of a HTTP request to 100mb by default so clients must ensure that no request exceeds this size.
It is not possible to index a single document that exceeds the size limit, so you must pre-process any such documents into smaller pieces before sending them to Elasticsearch.
For instance, split documents into pages or chapters before indexing them, or store raw binary data in a system outside Elasticsearch and replace the raw data with a link to the external system in the documents that you send to Elasticsearch.
</p>
<p>
<strong>Client suppport for bulk requests</strong>
</p>
<p>
Some of the officially supported clients provide helpers to assist with bulk requests and reindexing:
</p>
<ul><li>
<p>
Go: Check out <code>esutil.BulkIndexer</code>
</p>
</li><li>
<p>
Perl: Check out <code>Search::Elasticsearch::Client::5_0::Bulk</code> and <code>Search::Elasticsearch::Client::5_0::Scroll</code>
</p>
</li><li>
<p>
Python: Check out <code>elasticsearch.helpers.*</code>
</p>
</li><li>
<p>
JavaScript: Check out <code>client.helpers.*</code>
</p>
</li><li>
<p>
.NET: Check out <code>BulkAllObservable</code>
</p>
</li><li>
<p>
PHP: Check out bulk indexing.
</p>
</li></ul>
<p>
<strong>Submitting bulk requests with cURL</strong>
</p>
<p>
If you're providing text file input to <code>curl</code>, you must use the <code>--data-binary</code> flag instead of plain <code>-d</code>.
The latter doesn't preserve newlines. For example:
</p>
<pre><code class="lang-csharp">$ cat requests
{ "index" : { "_index" : "test", "_id" : "1" } }
{ "field1" : "value1" }
$ curl -s -H "Content-Type: application/x-ndjson" -XPOST localhost:9200/_bulk --data-binary "@requests"; echo
{"took":7, "errors": false, "items":[{"index":{"_index":"test","_id":"1","_version":1,"result":"created","forced_refresh":false}}]}</code></pre>
<p>
<strong>Optimistic concurrency control</strong>
</p>
<p>
Each <code>index</code> and <code>delete</code> action within a bulk API call may include the <code>if_seq_no</code> and <code>if_primary_term</code> parameters in their respective action and meta data lines.
The <code>if_seq_no</code> and <code>if_primary_term</code> parameters control how operations are run, based on the last modification to existing documents. See Optimistic concurrency control for more details.
</p>
<p>
<strong>Versioning</strong>
</p>
<p>
Each bulk item can include the version value using the <code>version</code> field.
It automatically follows the behavior of the index or delete operation based on the <code>_version</code> mapping.
It also support the <code>version_type</code>.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
Each bulk item can include the routing value using the <code>routing</code> field.
It automatically follows the behavior of the index or delete operation based on the <code>_routing</code> mapping.
</p>
<p>
NOTE: Data streams do not support custom routing unless they were created with the <code>allow_custom_routing</code> setting enabled in the template.
</p>
<p>
<strong>Wait for active shards</strong>
</p>
<p>
When making bulk calls, you can set the <code>wait_for_active_shards</code> parameter to require a minimum number of shard copies to be active before starting to process the bulk request.
</p>
<p>
<strong>Refresh</strong>
</p>
<p>
Control when the changes made by this request are visible to search.
</p>
<p>
NOTE: Only the shards that receive the bulk request will be affected by refresh.
Imagine a <code>_bulk?refresh=wait_for</code> request with three documents in it that happen to be routed to different shards in an index with five shards.
The request will only wait for those three shards to refresh.
The other two shards that make up the index do not participate in the <code>_bulk</code> request at all.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-bulk.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual BulkResponse Bulk(IndexName? index, Action&lt;BulkRequestDescriptor&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.BulkRequestDescriptor.html">BulkRequestDescriptor</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.BulkResponse.html">BulkResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Bulk_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Bulk*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Bulk_System_Action_Elastic_Clients_Elasticsearch_BulkRequestDescriptor__" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Bulk(System.Action{Elastic.Clients.Elasticsearch.BulkRequestDescriptor})">
  Bulk(Action&lt;BulkRequestDescriptor&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L2502"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Bulk index or delete documents.
Perform multiple <code>index</code>, <code>create</code>, <code>delete</code>, and <code>update</code> actions in a single request.
This reduces overhead and can greatly increase indexing speed.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or index alias:
</p>
<ul><li>
<p>
To use the <code>create</code> action, you must have the <code>create_doc</code>, <code>create</code>, <code>index</code>, or <code>write</code> index privilege. Data streams support only the <code>create</code> action.
</p>
</li><li>
<p>
To use the <code>index</code> action, you must have the <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To use the <code>delete</code> action, you must have the <code>delete</code> or <code>write</code> index privilege.
</p>
</li><li>
<p>
To use the <code>update</code> action, you must have the <code>index</code> or <code>write</code> index privilege.
</p>
</li><li>
<p>
To automatically create a data stream or index with a bulk API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege.
</p>
</li><li>
<p>
To make the result of a bulk operation visible to search using the <code>refresh</code> parameter, you must have the <code>maintenance</code> or <code>manage</code> index privilege.
</p>
</li></ul>
<p>
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
The actions are specified in the request body using a newline delimited JSON (NDJSON) structure:
</p>
<pre><code class="lang-csharp">action_and_meta_data\n
optional_source\n
action_and_meta_data\n
optional_source\n
....
action_and_meta_data\n
optional_source\n</code></pre>
<p>
The <code>index</code> and <code>create</code> actions expect a source on the next line and have the same semantics as the <code>op_type</code> parameter in the standard index API.
A <code>create</code> action fails if a document with the same ID already exists in the target
An <code>index</code> action adds or replaces a document as necessary.
</p>
<p>
NOTE: Data streams support only the <code>create</code> action.
To update or delete a document in a data stream, you must target the backing index containing the document.
</p>
<p>
An <code>update</code> action expects that the partial doc, upsert, and script and its options are specified on the next line.
</p>
<p>
A <code>delete</code> action does not expect a source on the next line and has the same semantics as the standard delete API.
</p>
<p>
NOTE: The final line of data must end with a newline character (<code>\n</code>).
Each newline character may be preceded by a carriage return (<code>\r</code>).
When sending NDJSON data to the <code>_bulk</code> endpoint, use a <code>Content-Type</code> header of <code>application/json</code> or <code>application/x-ndjson</code>.
Because this format uses literal newline characters (<code>\n</code>) as delimiters, make sure that the JSON actions and sources are not pretty printed.
</p>
<p>
If you provide a target in the request path, it is used for any actions that don't explicitly specify an <code>_index</code> argument.
</p>
<p>
A note on the format: the idea here is to make processing as fast as possible.
As some of the actions are redirected to other shards on other nodes, only <code>action_meta_data</code> is parsed on the receiving node side.
</p>
<p>
Client libraries using this protocol should try and strive to do something similar on the client side, and reduce buffering as much as possible.
</p>
<p>
There is no "correct" number of actions to perform in a single bulk request.
Experiment with different settings to find the optimal size for your particular workload.
Note that Elasticsearch limits the maximum size of a HTTP request to 100mb by default so clients must ensure that no request exceeds this size.
It is not possible to index a single document that exceeds the size limit, so you must pre-process any such documents into smaller pieces before sending them to Elasticsearch.
For instance, split documents into pages or chapters before indexing them, or store raw binary data in a system outside Elasticsearch and replace the raw data with a link to the external system in the documents that you send to Elasticsearch.
</p>
<p>
<strong>Client suppport for bulk requests</strong>
</p>
<p>
Some of the officially supported clients provide helpers to assist with bulk requests and reindexing:
</p>
<ul><li>
<p>
Go: Check out <code>esutil.BulkIndexer</code>
</p>
</li><li>
<p>
Perl: Check out <code>Search::Elasticsearch::Client::5_0::Bulk</code> and <code>Search::Elasticsearch::Client::5_0::Scroll</code>
</p>
</li><li>
<p>
Python: Check out <code>elasticsearch.helpers.*</code>
</p>
</li><li>
<p>
JavaScript: Check out <code>client.helpers.*</code>
</p>
</li><li>
<p>
.NET: Check out <code>BulkAllObservable</code>
</p>
</li><li>
<p>
PHP: Check out bulk indexing.
</p>
</li></ul>
<p>
<strong>Submitting bulk requests with cURL</strong>
</p>
<p>
If you're providing text file input to <code>curl</code>, you must use the <code>--data-binary</code> flag instead of plain <code>-d</code>.
The latter doesn't preserve newlines. For example:
</p>
<pre><code class="lang-csharp">$ cat requests
{ "index" : { "_index" : "test", "_id" : "1" } }
{ "field1" : "value1" }
$ curl -s -H "Content-Type: application/x-ndjson" -XPOST localhost:9200/_bulk --data-binary "@requests"; echo
{"took":7, "errors": false, "items":[{"index":{"_index":"test","_id":"1","_version":1,"result":"created","forced_refresh":false}}]}</code></pre>
<p>
<strong>Optimistic concurrency control</strong>
</p>
<p>
Each <code>index</code> and <code>delete</code> action within a bulk API call may include the <code>if_seq_no</code> and <code>if_primary_term</code> parameters in their respective action and meta data lines.
The <code>if_seq_no</code> and <code>if_primary_term</code> parameters control how operations are run, based on the last modification to existing documents. See Optimistic concurrency control for more details.
</p>
<p>
<strong>Versioning</strong>
</p>
<p>
Each bulk item can include the version value using the <code>version</code> field.
It automatically follows the behavior of the index or delete operation based on the <code>_version</code> mapping.
It also support the <code>version_type</code>.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
Each bulk item can include the routing value using the <code>routing</code> field.
It automatically follows the behavior of the index or delete operation based on the <code>_routing</code> mapping.
</p>
<p>
NOTE: Data streams do not support custom routing unless they were created with the <code>allow_custom_routing</code> setting enabled in the template.
</p>
<p>
<strong>Wait for active shards</strong>
</p>
<p>
When making bulk calls, you can set the <code>wait_for_active_shards</code> parameter to require a minimum number of shard copies to be active before starting to process the bulk request.
</p>
<p>
<strong>Refresh</strong>
</p>
<p>
Control when the changes made by this request are visible to search.
</p>
<p>
NOTE: Only the shards that receive the bulk request will be affected by refresh.
Imagine a <code>_bulk?refresh=wait_for</code> request with three documents in it that happen to be routed to different shards in an index with five shards.
The request will only wait for those three shards to refresh.
The other two shards that make up the index do not participate in the <code>_bulk</code> request at all.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-bulk.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual BulkResponse Bulk(Action&lt;BulkRequestDescriptor&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.BulkRequestDescriptor.html">BulkRequestDescriptor</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.BulkResponse.html">BulkResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_BulkAll_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.BulkAll*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_BulkAll__1_Elastic_Clients_Elasticsearch_IBulkAllRequest___0__System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.BulkAll``1(Elastic.Clients.Elasticsearch.IBulkAllRequest{``0},System.Threading.CancellationToken)">
  BulkAll&lt;T&gt;(IBulkAllRequest&lt;T&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Shared/Client/ElasticsearchClient-BulkAll.cs/#L22"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"></div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual BulkAllObservable&lt;T&gt; BulkAll&lt;T&gt;(IBulkAllRequest&lt;T&gt; request, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IBulkAllRequest-1.html">IBulkAllRequest</a>&lt;T&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.BulkAllObservable-1.html">BulkAllObservable</a>&lt;T&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>T</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_BulkAll_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.BulkAll*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_BulkAll__1_System_Collections_Generic_IEnumerable___0__System_Action_Elastic_Clients_Elasticsearch_BulkAllRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.BulkAll``1(System.Collections.Generic.IEnumerable{``0},System.Action{Elastic.Clients.Elasticsearch.BulkAllRequestDescriptor{``0}},System.Threading.CancellationToken)">
  BulkAll&lt;T&gt;(IEnumerable&lt;T&gt;, Action&lt;BulkAllRequestDescriptor&lt;T&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Shared/Client/ElasticsearchClient-BulkAll.cs/#L15"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"></div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual BulkAllObservable&lt;T&gt; BulkAll&lt;T&gt;(IEnumerable&lt;T&gt; documents, Action&lt;BulkAllRequestDescriptor&lt;T&gt;&gt; configure, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>documents</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.collections.generic.ienumerable-1">IEnumerable</a>&lt;T&gt;</dt>
    <dd></dd>
    <dt><code>configure</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.BulkAllRequestDescriptor-1.html">BulkAllRequestDescriptor</a>&lt;T&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.BulkAllObservable-1.html">BulkAllObservable</a>&lt;T&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>T</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_BulkAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.BulkAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_BulkAsync_Elastic_Clients_Elasticsearch_BulkRequest_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.BulkAsync(Elastic.Clients.Elasticsearch.BulkRequest,System.Threading.CancellationToken)">
  BulkAsync(BulkRequest, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L513"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Bulk index or delete documents.
Perform multiple <code>index</code>, <code>create</code>, <code>delete</code>, and <code>update</code> actions in a single request.
This reduces overhead and can greatly increase indexing speed.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or index alias:
</p>
<ul><li>
<p>
To use the <code>create</code> action, you must have the <code>create_doc</code>, <code>create</code>, <code>index</code>, or <code>write</code> index privilege. Data streams support only the <code>create</code> action.
</p>
</li><li>
<p>
To use the <code>index</code> action, you must have the <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To use the <code>delete</code> action, you must have the <code>delete</code> or <code>write</code> index privilege.
</p>
</li><li>
<p>
To use the <code>update</code> action, you must have the <code>index</code> or <code>write</code> index privilege.
</p>
</li><li>
<p>
To automatically create a data stream or index with a bulk API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege.
</p>
</li><li>
<p>
To make the result of a bulk operation visible to search using the <code>refresh</code> parameter, you must have the <code>maintenance</code> or <code>manage</code> index privilege.
</p>
</li></ul>
<p>
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
The actions are specified in the request body using a newline delimited JSON (NDJSON) structure:
</p>
<pre><code class="lang-csharp">action_and_meta_data\n
optional_source\n
action_and_meta_data\n
optional_source\n
....
action_and_meta_data\n
optional_source\n</code></pre>
<p>
The <code>index</code> and <code>create</code> actions expect a source on the next line and have the same semantics as the <code>op_type</code> parameter in the standard index API.
A <code>create</code> action fails if a document with the same ID already exists in the target
An <code>index</code> action adds or replaces a document as necessary.
</p>
<p>
NOTE: Data streams support only the <code>create</code> action.
To update or delete a document in a data stream, you must target the backing index containing the document.
</p>
<p>
An <code>update</code> action expects that the partial doc, upsert, and script and its options are specified on the next line.
</p>
<p>
A <code>delete</code> action does not expect a source on the next line and has the same semantics as the standard delete API.
</p>
<p>
NOTE: The final line of data must end with a newline character (<code>\n</code>).
Each newline character may be preceded by a carriage return (<code>\r</code>).
When sending NDJSON data to the <code>_bulk</code> endpoint, use a <code>Content-Type</code> header of <code>application/json</code> or <code>application/x-ndjson</code>.
Because this format uses literal newline characters (<code>\n</code>) as delimiters, make sure that the JSON actions and sources are not pretty printed.
</p>
<p>
If you provide a target in the request path, it is used for any actions that don't explicitly specify an <code>_index</code> argument.
</p>
<p>
A note on the format: the idea here is to make processing as fast as possible.
As some of the actions are redirected to other shards on other nodes, only <code>action_meta_data</code> is parsed on the receiving node side.
</p>
<p>
Client libraries using this protocol should try and strive to do something similar on the client side, and reduce buffering as much as possible.
</p>
<p>
There is no "correct" number of actions to perform in a single bulk request.
Experiment with different settings to find the optimal size for your particular workload.
Note that Elasticsearch limits the maximum size of a HTTP request to 100mb by default so clients must ensure that no request exceeds this size.
It is not possible to index a single document that exceeds the size limit, so you must pre-process any such documents into smaller pieces before sending them to Elasticsearch.
For instance, split documents into pages or chapters before indexing them, or store raw binary data in a system outside Elasticsearch and replace the raw data with a link to the external system in the documents that you send to Elasticsearch.
</p>
<p>
<strong>Client suppport for bulk requests</strong>
</p>
<p>
Some of the officially supported clients provide helpers to assist with bulk requests and reindexing:
</p>
<ul><li>
<p>
Go: Check out <code>esutil.BulkIndexer</code>
</p>
</li><li>
<p>
Perl: Check out <code>Search::Elasticsearch::Client::5_0::Bulk</code> and <code>Search::Elasticsearch::Client::5_0::Scroll</code>
</p>
</li><li>
<p>
Python: Check out <code>elasticsearch.helpers.*</code>
</p>
</li><li>
<p>
JavaScript: Check out <code>client.helpers.*</code>
</p>
</li><li>
<p>
.NET: Check out <code>BulkAllObservable</code>
</p>
</li><li>
<p>
PHP: Check out bulk indexing.
</p>
</li></ul>
<p>
<strong>Submitting bulk requests with cURL</strong>
</p>
<p>
If you're providing text file input to <code>curl</code>, you must use the <code>--data-binary</code> flag instead of plain <code>-d</code>.
The latter doesn't preserve newlines. For example:
</p>
<pre><code class="lang-csharp">$ cat requests
{ "index" : { "_index" : "test", "_id" : "1" } }
{ "field1" : "value1" }
$ curl -s -H "Content-Type: application/x-ndjson" -XPOST localhost:9200/_bulk --data-binary "@requests"; echo
{"took":7, "errors": false, "items":[{"index":{"_index":"test","_id":"1","_version":1,"result":"created","forced_refresh":false}}]}</code></pre>
<p>
<strong>Optimistic concurrency control</strong>
</p>
<p>
Each <code>index</code> and <code>delete</code> action within a bulk API call may include the <code>if_seq_no</code> and <code>if_primary_term</code> parameters in their respective action and meta data lines.
The <code>if_seq_no</code> and <code>if_primary_term</code> parameters control how operations are run, based on the last modification to existing documents. See Optimistic concurrency control for more details.
</p>
<p>
<strong>Versioning</strong>
</p>
<p>
Each bulk item can include the version value using the <code>version</code> field.
It automatically follows the behavior of the index or delete operation based on the <code>_version</code> mapping.
It also support the <code>version_type</code>.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
Each bulk item can include the routing value using the <code>routing</code> field.
It automatically follows the behavior of the index or delete operation based on the <code>_routing</code> mapping.
</p>
<p>
NOTE: Data streams do not support custom routing unless they were created with the <code>allow_custom_routing</code> setting enabled in the template.
</p>
<p>
<strong>Wait for active shards</strong>
</p>
<p>
When making bulk calls, you can set the <code>wait_for_active_shards</code> parameter to require a minimum number of shard copies to be active before starting to process the bulk request.
</p>
<p>
<strong>Refresh</strong>
</p>
<p>
Control when the changes made by this request are visible to search.
</p>
<p>
NOTE: Only the shards that receive the bulk request will be affected by refresh.
Imagine a <code>_bulk?refresh=wait_for</code> request with three documents in it that happen to be routed to different shards in an index with five shards.
The request will only wait for those three shards to refresh.
The other two shards that make up the index do not participate in the <code>_bulk</code> request at all.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-bulk.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;BulkResponse&gt; BulkAsync(BulkRequest request, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.BulkRequest.html">BulkRequest</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.BulkResponse.html">BulkResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_BulkAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.BulkAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_BulkAsync_Elastic_Clients_Elasticsearch_BulkRequestDescriptor_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.BulkAsync(Elastic.Clients.Elasticsearch.BulkRequestDescriptor,System.Threading.CancellationToken)">
  BulkAsync(BulkRequestDescriptor, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L3693"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Bulk index or delete documents.
Perform multiple <code>index</code>, <code>create</code>, <code>delete</code>, and <code>update</code> actions in a single request.
This reduces overhead and can greatly increase indexing speed.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or index alias:
</p>
<ul><li>
<p>
To use the <code>create</code> action, you must have the <code>create_doc</code>, <code>create</code>, <code>index</code>, or <code>write</code> index privilege. Data streams support only the <code>create</code> action.
</p>
</li><li>
<p>
To use the <code>index</code> action, you must have the <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To use the <code>delete</code> action, you must have the <code>delete</code> or <code>write</code> index privilege.
</p>
</li><li>
<p>
To use the <code>update</code> action, you must have the <code>index</code> or <code>write</code> index privilege.
</p>
</li><li>
<p>
To automatically create a data stream or index with a bulk API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege.
</p>
</li><li>
<p>
To make the result of a bulk operation visible to search using the <code>refresh</code> parameter, you must have the <code>maintenance</code> or <code>manage</code> index privilege.
</p>
</li></ul>
<p>
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
The actions are specified in the request body using a newline delimited JSON (NDJSON) structure:
</p>
<pre><code class="lang-csharp">action_and_meta_data\n
optional_source\n
action_and_meta_data\n
optional_source\n
....
action_and_meta_data\n
optional_source\n</code></pre>
<p>
The <code>index</code> and <code>create</code> actions expect a source on the next line and have the same semantics as the <code>op_type</code> parameter in the standard index API.
A <code>create</code> action fails if a document with the same ID already exists in the target
An <code>index</code> action adds or replaces a document as necessary.
</p>
<p>
NOTE: Data streams support only the <code>create</code> action.
To update or delete a document in a data stream, you must target the backing index containing the document.
</p>
<p>
An <code>update</code> action expects that the partial doc, upsert, and script and its options are specified on the next line.
</p>
<p>
A <code>delete</code> action does not expect a source on the next line and has the same semantics as the standard delete API.
</p>
<p>
NOTE: The final line of data must end with a newline character (<code>\n</code>).
Each newline character may be preceded by a carriage return (<code>\r</code>).
When sending NDJSON data to the <code>_bulk</code> endpoint, use a <code>Content-Type</code> header of <code>application/json</code> or <code>application/x-ndjson</code>.
Because this format uses literal newline characters (<code>\n</code>) as delimiters, make sure that the JSON actions and sources are not pretty printed.
</p>
<p>
If you provide a target in the request path, it is used for any actions that don't explicitly specify an <code>_index</code> argument.
</p>
<p>
A note on the format: the idea here is to make processing as fast as possible.
As some of the actions are redirected to other shards on other nodes, only <code>action_meta_data</code> is parsed on the receiving node side.
</p>
<p>
Client libraries using this protocol should try and strive to do something similar on the client side, and reduce buffering as much as possible.
</p>
<p>
There is no "correct" number of actions to perform in a single bulk request.
Experiment with different settings to find the optimal size for your particular workload.
Note that Elasticsearch limits the maximum size of a HTTP request to 100mb by default so clients must ensure that no request exceeds this size.
It is not possible to index a single document that exceeds the size limit, so you must pre-process any such documents into smaller pieces before sending them to Elasticsearch.
For instance, split documents into pages or chapters before indexing them, or store raw binary data in a system outside Elasticsearch and replace the raw data with a link to the external system in the documents that you send to Elasticsearch.
</p>
<p>
<strong>Client suppport for bulk requests</strong>
</p>
<p>
Some of the officially supported clients provide helpers to assist with bulk requests and reindexing:
</p>
<ul><li>
<p>
Go: Check out <code>esutil.BulkIndexer</code>
</p>
</li><li>
<p>
Perl: Check out <code>Search::Elasticsearch::Client::5_0::Bulk</code> and <code>Search::Elasticsearch::Client::5_0::Scroll</code>
</p>
</li><li>
<p>
Python: Check out <code>elasticsearch.helpers.*</code>
</p>
</li><li>
<p>
JavaScript: Check out <code>client.helpers.*</code>
</p>
</li><li>
<p>
.NET: Check out <code>BulkAllObservable</code>
</p>
</li><li>
<p>
PHP: Check out bulk indexing.
</p>
</li></ul>
<p>
<strong>Submitting bulk requests with cURL</strong>
</p>
<p>
If you're providing text file input to <code>curl</code>, you must use the <code>--data-binary</code> flag instead of plain <code>-d</code>.
The latter doesn't preserve newlines. For example:
</p>
<pre><code class="lang-csharp">$ cat requests
{ "index" : { "_index" : "test", "_id" : "1" } }
{ "field1" : "value1" }
$ curl -s -H "Content-Type: application/x-ndjson" -XPOST localhost:9200/_bulk --data-binary "@requests"; echo
{"took":7, "errors": false, "items":[{"index":{"_index":"test","_id":"1","_version":1,"result":"created","forced_refresh":false}}]}</code></pre>
<p>
<strong>Optimistic concurrency control</strong>
</p>
<p>
Each <code>index</code> and <code>delete</code> action within a bulk API call may include the <code>if_seq_no</code> and <code>if_primary_term</code> parameters in their respective action and meta data lines.
The <code>if_seq_no</code> and <code>if_primary_term</code> parameters control how operations are run, based on the last modification to existing documents. See Optimistic concurrency control for more details.
</p>
<p>
<strong>Versioning</strong>
</p>
<p>
Each bulk item can include the version value using the <code>version</code> field.
It automatically follows the behavior of the index or delete operation based on the <code>_version</code> mapping.
It also support the <code>version_type</code>.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
Each bulk item can include the routing value using the <code>routing</code> field.
It automatically follows the behavior of the index or delete operation based on the <code>_routing</code> mapping.
</p>
<p>
NOTE: Data streams do not support custom routing unless they were created with the <code>allow_custom_routing</code> setting enabled in the template.
</p>
<p>
<strong>Wait for active shards</strong>
</p>
<p>
When making bulk calls, you can set the <code>wait_for_active_shards</code> parameter to require a minimum number of shard copies to be active before starting to process the bulk request.
</p>
<p>
<strong>Refresh</strong>
</p>
<p>
Control when the changes made by this request are visible to search.
</p>
<p>
NOTE: Only the shards that receive the bulk request will be affected by refresh.
Imagine a <code>_bulk?refresh=wait_for</code> request with three documents in it that happen to be routed to different shards in an index with five shards.
The request will only wait for those three shards to refresh.
The other two shards that make up the index do not participate in the <code>_bulk</code> request at all.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-bulk.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;BulkResponse&gt; BulkAsync(BulkRequestDescriptor descriptor, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.BulkRequestDescriptor.html">BulkRequestDescriptor</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.BulkResponse.html">BulkResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_BulkAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.BulkAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_BulkAsync_Elastic_Clients_Elasticsearch_IndexName_System_Action_Elastic_Clients_Elasticsearch_BulkRequestDescriptor__System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.BulkAsync(Elastic.Clients.Elasticsearch.IndexName,System.Action{Elastic.Clients.Elasticsearch.BulkRequestDescriptor},System.Threading.CancellationToken)">
  BulkAsync(IndexName?, Action&lt;BulkRequestDescriptor&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L4088"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Bulk index or delete documents.
Perform multiple <code>index</code>, <code>create</code>, <code>delete</code>, and <code>update</code> actions in a single request.
This reduces overhead and can greatly increase indexing speed.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or index alias:
</p>
<ul><li>
<p>
To use the <code>create</code> action, you must have the <code>create_doc</code>, <code>create</code>, <code>index</code>, or <code>write</code> index privilege. Data streams support only the <code>create</code> action.
</p>
</li><li>
<p>
To use the <code>index</code> action, you must have the <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To use the <code>delete</code> action, you must have the <code>delete</code> or <code>write</code> index privilege.
</p>
</li><li>
<p>
To use the <code>update</code> action, you must have the <code>index</code> or <code>write</code> index privilege.
</p>
</li><li>
<p>
To automatically create a data stream or index with a bulk API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege.
</p>
</li><li>
<p>
To make the result of a bulk operation visible to search using the <code>refresh</code> parameter, you must have the <code>maintenance</code> or <code>manage</code> index privilege.
</p>
</li></ul>
<p>
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
The actions are specified in the request body using a newline delimited JSON (NDJSON) structure:
</p>
<pre><code class="lang-csharp">action_and_meta_data\n
optional_source\n
action_and_meta_data\n
optional_source\n
....
action_and_meta_data\n
optional_source\n</code></pre>
<p>
The <code>index</code> and <code>create</code> actions expect a source on the next line and have the same semantics as the <code>op_type</code> parameter in the standard index API.
A <code>create</code> action fails if a document with the same ID already exists in the target
An <code>index</code> action adds or replaces a document as necessary.
</p>
<p>
NOTE: Data streams support only the <code>create</code> action.
To update or delete a document in a data stream, you must target the backing index containing the document.
</p>
<p>
An <code>update</code> action expects that the partial doc, upsert, and script and its options are specified on the next line.
</p>
<p>
A <code>delete</code> action does not expect a source on the next line and has the same semantics as the standard delete API.
</p>
<p>
NOTE: The final line of data must end with a newline character (<code>\n</code>).
Each newline character may be preceded by a carriage return (<code>\r</code>).
When sending NDJSON data to the <code>_bulk</code> endpoint, use a <code>Content-Type</code> header of <code>application/json</code> or <code>application/x-ndjson</code>.
Because this format uses literal newline characters (<code>\n</code>) as delimiters, make sure that the JSON actions and sources are not pretty printed.
</p>
<p>
If you provide a target in the request path, it is used for any actions that don't explicitly specify an <code>_index</code> argument.
</p>
<p>
A note on the format: the idea here is to make processing as fast as possible.
As some of the actions are redirected to other shards on other nodes, only <code>action_meta_data</code> is parsed on the receiving node side.
</p>
<p>
Client libraries using this protocol should try and strive to do something similar on the client side, and reduce buffering as much as possible.
</p>
<p>
There is no "correct" number of actions to perform in a single bulk request.
Experiment with different settings to find the optimal size for your particular workload.
Note that Elasticsearch limits the maximum size of a HTTP request to 100mb by default so clients must ensure that no request exceeds this size.
It is not possible to index a single document that exceeds the size limit, so you must pre-process any such documents into smaller pieces before sending them to Elasticsearch.
For instance, split documents into pages or chapters before indexing them, or store raw binary data in a system outside Elasticsearch and replace the raw data with a link to the external system in the documents that you send to Elasticsearch.
</p>
<p>
<strong>Client suppport for bulk requests</strong>
</p>
<p>
Some of the officially supported clients provide helpers to assist with bulk requests and reindexing:
</p>
<ul><li>
<p>
Go: Check out <code>esutil.BulkIndexer</code>
</p>
</li><li>
<p>
Perl: Check out <code>Search::Elasticsearch::Client::5_0::Bulk</code> and <code>Search::Elasticsearch::Client::5_0::Scroll</code>
</p>
</li><li>
<p>
Python: Check out <code>elasticsearch.helpers.*</code>
</p>
</li><li>
<p>
JavaScript: Check out <code>client.helpers.*</code>
</p>
</li><li>
<p>
.NET: Check out <code>BulkAllObservable</code>
</p>
</li><li>
<p>
PHP: Check out bulk indexing.
</p>
</li></ul>
<p>
<strong>Submitting bulk requests with cURL</strong>
</p>
<p>
If you're providing text file input to <code>curl</code>, you must use the <code>--data-binary</code> flag instead of plain <code>-d</code>.
The latter doesn't preserve newlines. For example:
</p>
<pre><code class="lang-csharp">$ cat requests
{ "index" : { "_index" : "test", "_id" : "1" } }
{ "field1" : "value1" }
$ curl -s -H "Content-Type: application/x-ndjson" -XPOST localhost:9200/_bulk --data-binary "@requests"; echo
{"took":7, "errors": false, "items":[{"index":{"_index":"test","_id":"1","_version":1,"result":"created","forced_refresh":false}}]}</code></pre>
<p>
<strong>Optimistic concurrency control</strong>
</p>
<p>
Each <code>index</code> and <code>delete</code> action within a bulk API call may include the <code>if_seq_no</code> and <code>if_primary_term</code> parameters in their respective action and meta data lines.
The <code>if_seq_no</code> and <code>if_primary_term</code> parameters control how operations are run, based on the last modification to existing documents. See Optimistic concurrency control for more details.
</p>
<p>
<strong>Versioning</strong>
</p>
<p>
Each bulk item can include the version value using the <code>version</code> field.
It automatically follows the behavior of the index or delete operation based on the <code>_version</code> mapping.
It also support the <code>version_type</code>.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
Each bulk item can include the routing value using the <code>routing</code> field.
It automatically follows the behavior of the index or delete operation based on the <code>_routing</code> mapping.
</p>
<p>
NOTE: Data streams do not support custom routing unless they were created with the <code>allow_custom_routing</code> setting enabled in the template.
</p>
<p>
<strong>Wait for active shards</strong>
</p>
<p>
When making bulk calls, you can set the <code>wait_for_active_shards</code> parameter to require a minimum number of shard copies to be active before starting to process the bulk request.
</p>
<p>
<strong>Refresh</strong>
</p>
<p>
Control when the changes made by this request are visible to search.
</p>
<p>
NOTE: Only the shards that receive the bulk request will be affected by refresh.
Imagine a <code>_bulk?refresh=wait_for</code> request with three documents in it that happen to be routed to different shards in an index with five shards.
The request will only wait for those three shards to refresh.
The other two shards that make up the index do not participate in the <code>_bulk</code> request at all.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-bulk.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;BulkResponse&gt; BulkAsync(IndexName? index, Action&lt;BulkRequestDescriptor&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.BulkRequestDescriptor.html">BulkRequestDescriptor</a>&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.BulkResponse.html">BulkResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_BulkAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.BulkAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_BulkAsync_Elastic_Clients_Elasticsearch_IndexName_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.BulkAsync(Elastic.Clients.Elasticsearch.IndexName,System.Threading.CancellationToken)">
  BulkAsync(IndexName?, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L3890"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Bulk index or delete documents.
Perform multiple <code>index</code>, <code>create</code>, <code>delete</code>, and <code>update</code> actions in a single request.
This reduces overhead and can greatly increase indexing speed.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or index alias:
</p>
<ul><li>
<p>
To use the <code>create</code> action, you must have the <code>create_doc</code>, <code>create</code>, <code>index</code>, or <code>write</code> index privilege. Data streams support only the <code>create</code> action.
</p>
</li><li>
<p>
To use the <code>index</code> action, you must have the <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To use the <code>delete</code> action, you must have the <code>delete</code> or <code>write</code> index privilege.
</p>
</li><li>
<p>
To use the <code>update</code> action, you must have the <code>index</code> or <code>write</code> index privilege.
</p>
</li><li>
<p>
To automatically create a data stream or index with a bulk API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege.
</p>
</li><li>
<p>
To make the result of a bulk operation visible to search using the <code>refresh</code> parameter, you must have the <code>maintenance</code> or <code>manage</code> index privilege.
</p>
</li></ul>
<p>
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
The actions are specified in the request body using a newline delimited JSON (NDJSON) structure:
</p>
<pre><code class="lang-csharp">action_and_meta_data\n
optional_source\n
action_and_meta_data\n
optional_source\n
....
action_and_meta_data\n
optional_source\n</code></pre>
<p>
The <code>index</code> and <code>create</code> actions expect a source on the next line and have the same semantics as the <code>op_type</code> parameter in the standard index API.
A <code>create</code> action fails if a document with the same ID already exists in the target
An <code>index</code> action adds or replaces a document as necessary.
</p>
<p>
NOTE: Data streams support only the <code>create</code> action.
To update or delete a document in a data stream, you must target the backing index containing the document.
</p>
<p>
An <code>update</code> action expects that the partial doc, upsert, and script and its options are specified on the next line.
</p>
<p>
A <code>delete</code> action does not expect a source on the next line and has the same semantics as the standard delete API.
</p>
<p>
NOTE: The final line of data must end with a newline character (<code>\n</code>).
Each newline character may be preceded by a carriage return (<code>\r</code>).
When sending NDJSON data to the <code>_bulk</code> endpoint, use a <code>Content-Type</code> header of <code>application/json</code> or <code>application/x-ndjson</code>.
Because this format uses literal newline characters (<code>\n</code>) as delimiters, make sure that the JSON actions and sources are not pretty printed.
</p>
<p>
If you provide a target in the request path, it is used for any actions that don't explicitly specify an <code>_index</code> argument.
</p>
<p>
A note on the format: the idea here is to make processing as fast as possible.
As some of the actions are redirected to other shards on other nodes, only <code>action_meta_data</code> is parsed on the receiving node side.
</p>
<p>
Client libraries using this protocol should try and strive to do something similar on the client side, and reduce buffering as much as possible.
</p>
<p>
There is no "correct" number of actions to perform in a single bulk request.
Experiment with different settings to find the optimal size for your particular workload.
Note that Elasticsearch limits the maximum size of a HTTP request to 100mb by default so clients must ensure that no request exceeds this size.
It is not possible to index a single document that exceeds the size limit, so you must pre-process any such documents into smaller pieces before sending them to Elasticsearch.
For instance, split documents into pages or chapters before indexing them, or store raw binary data in a system outside Elasticsearch and replace the raw data with a link to the external system in the documents that you send to Elasticsearch.
</p>
<p>
<strong>Client suppport for bulk requests</strong>
</p>
<p>
Some of the officially supported clients provide helpers to assist with bulk requests and reindexing:
</p>
<ul><li>
<p>
Go: Check out <code>esutil.BulkIndexer</code>
</p>
</li><li>
<p>
Perl: Check out <code>Search::Elasticsearch::Client::5_0::Bulk</code> and <code>Search::Elasticsearch::Client::5_0::Scroll</code>
</p>
</li><li>
<p>
Python: Check out <code>elasticsearch.helpers.*</code>
</p>
</li><li>
<p>
JavaScript: Check out <code>client.helpers.*</code>
</p>
</li><li>
<p>
.NET: Check out <code>BulkAllObservable</code>
</p>
</li><li>
<p>
PHP: Check out bulk indexing.
</p>
</li></ul>
<p>
<strong>Submitting bulk requests with cURL</strong>
</p>
<p>
If you're providing text file input to <code>curl</code>, you must use the <code>--data-binary</code> flag instead of plain <code>-d</code>.
The latter doesn't preserve newlines. For example:
</p>
<pre><code class="lang-csharp">$ cat requests
{ "index" : { "_index" : "test", "_id" : "1" } }
{ "field1" : "value1" }
$ curl -s -H "Content-Type: application/x-ndjson" -XPOST localhost:9200/_bulk --data-binary "@requests"; echo
{"took":7, "errors": false, "items":[{"index":{"_index":"test","_id":"1","_version":1,"result":"created","forced_refresh":false}}]}</code></pre>
<p>
<strong>Optimistic concurrency control</strong>
</p>
<p>
Each <code>index</code> and <code>delete</code> action within a bulk API call may include the <code>if_seq_no</code> and <code>if_primary_term</code> parameters in their respective action and meta data lines.
The <code>if_seq_no</code> and <code>if_primary_term</code> parameters control how operations are run, based on the last modification to existing documents. See Optimistic concurrency control for more details.
</p>
<p>
<strong>Versioning</strong>
</p>
<p>
Each bulk item can include the version value using the <code>version</code> field.
It automatically follows the behavior of the index or delete operation based on the <code>_version</code> mapping.
It also support the <code>version_type</code>.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
Each bulk item can include the routing value using the <code>routing</code> field.
It automatically follows the behavior of the index or delete operation based on the <code>_routing</code> mapping.
</p>
<p>
NOTE: Data streams do not support custom routing unless they were created with the <code>allow_custom_routing</code> setting enabled in the template.
</p>
<p>
<strong>Wait for active shards</strong>
</p>
<p>
When making bulk calls, you can set the <code>wait_for_active_shards</code> parameter to require a minimum number of shard copies to be active before starting to process the bulk request.
</p>
<p>
<strong>Refresh</strong>
</p>
<p>
Control when the changes made by this request are visible to search.
</p>
<p>
NOTE: Only the shards that receive the bulk request will be affected by refresh.
Imagine a <code>_bulk?refresh=wait_for</code> request with three documents in it that happen to be routed to different shards in an index with five shards.
The request will only wait for those three shards to refresh.
The other two shards that make up the index do not participate in the <code>_bulk</code> request at all.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-bulk.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;BulkResponse&gt; BulkAsync(IndexName? index, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.BulkResponse.html">BulkResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_BulkAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.BulkAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_BulkAsync_System_Action_Elastic_Clients_Elasticsearch_BulkRequestDescriptor__System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.BulkAsync(System.Action{Elastic.Clients.Elasticsearch.BulkRequestDescriptor},System.Threading.CancellationToken)">
  BulkAsync(Action&lt;BulkRequestDescriptor&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L4485"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Bulk index or delete documents.
Perform multiple <code>index</code>, <code>create</code>, <code>delete</code>, and <code>update</code> actions in a single request.
This reduces overhead and can greatly increase indexing speed.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or index alias:
</p>
<ul><li>
<p>
To use the <code>create</code> action, you must have the <code>create_doc</code>, <code>create</code>, <code>index</code>, or <code>write</code> index privilege. Data streams support only the <code>create</code> action.
</p>
</li><li>
<p>
To use the <code>index</code> action, you must have the <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To use the <code>delete</code> action, you must have the <code>delete</code> or <code>write</code> index privilege.
</p>
</li><li>
<p>
To use the <code>update</code> action, you must have the <code>index</code> or <code>write</code> index privilege.
</p>
</li><li>
<p>
To automatically create a data stream or index with a bulk API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege.
</p>
</li><li>
<p>
To make the result of a bulk operation visible to search using the <code>refresh</code> parameter, you must have the <code>maintenance</code> or <code>manage</code> index privilege.
</p>
</li></ul>
<p>
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
The actions are specified in the request body using a newline delimited JSON (NDJSON) structure:
</p>
<pre><code class="lang-csharp">action_and_meta_data\n
optional_source\n
action_and_meta_data\n
optional_source\n
....
action_and_meta_data\n
optional_source\n</code></pre>
<p>
The <code>index</code> and <code>create</code> actions expect a source on the next line and have the same semantics as the <code>op_type</code> parameter in the standard index API.
A <code>create</code> action fails if a document with the same ID already exists in the target
An <code>index</code> action adds or replaces a document as necessary.
</p>
<p>
NOTE: Data streams support only the <code>create</code> action.
To update or delete a document in a data stream, you must target the backing index containing the document.
</p>
<p>
An <code>update</code> action expects that the partial doc, upsert, and script and its options are specified on the next line.
</p>
<p>
A <code>delete</code> action does not expect a source on the next line and has the same semantics as the standard delete API.
</p>
<p>
NOTE: The final line of data must end with a newline character (<code>\n</code>).
Each newline character may be preceded by a carriage return (<code>\r</code>).
When sending NDJSON data to the <code>_bulk</code> endpoint, use a <code>Content-Type</code> header of <code>application/json</code> or <code>application/x-ndjson</code>.
Because this format uses literal newline characters (<code>\n</code>) as delimiters, make sure that the JSON actions and sources are not pretty printed.
</p>
<p>
If you provide a target in the request path, it is used for any actions that don't explicitly specify an <code>_index</code> argument.
</p>
<p>
A note on the format: the idea here is to make processing as fast as possible.
As some of the actions are redirected to other shards on other nodes, only <code>action_meta_data</code> is parsed on the receiving node side.
</p>
<p>
Client libraries using this protocol should try and strive to do something similar on the client side, and reduce buffering as much as possible.
</p>
<p>
There is no "correct" number of actions to perform in a single bulk request.
Experiment with different settings to find the optimal size for your particular workload.
Note that Elasticsearch limits the maximum size of a HTTP request to 100mb by default so clients must ensure that no request exceeds this size.
It is not possible to index a single document that exceeds the size limit, so you must pre-process any such documents into smaller pieces before sending them to Elasticsearch.
For instance, split documents into pages or chapters before indexing them, or store raw binary data in a system outside Elasticsearch and replace the raw data with a link to the external system in the documents that you send to Elasticsearch.
</p>
<p>
<strong>Client suppport for bulk requests</strong>
</p>
<p>
Some of the officially supported clients provide helpers to assist with bulk requests and reindexing:
</p>
<ul><li>
<p>
Go: Check out <code>esutil.BulkIndexer</code>
</p>
</li><li>
<p>
Perl: Check out <code>Search::Elasticsearch::Client::5_0::Bulk</code> and <code>Search::Elasticsearch::Client::5_0::Scroll</code>
</p>
</li><li>
<p>
Python: Check out <code>elasticsearch.helpers.*</code>
</p>
</li><li>
<p>
JavaScript: Check out <code>client.helpers.*</code>
</p>
</li><li>
<p>
.NET: Check out <code>BulkAllObservable</code>
</p>
</li><li>
<p>
PHP: Check out bulk indexing.
</p>
</li></ul>
<p>
<strong>Submitting bulk requests with cURL</strong>
</p>
<p>
If you're providing text file input to <code>curl</code>, you must use the <code>--data-binary</code> flag instead of plain <code>-d</code>.
The latter doesn't preserve newlines. For example:
</p>
<pre><code class="lang-csharp">$ cat requests
{ "index" : { "_index" : "test", "_id" : "1" } }
{ "field1" : "value1" }
$ curl -s -H "Content-Type: application/x-ndjson" -XPOST localhost:9200/_bulk --data-binary "@requests"; echo
{"took":7, "errors": false, "items":[{"index":{"_index":"test","_id":"1","_version":1,"result":"created","forced_refresh":false}}]}</code></pre>
<p>
<strong>Optimistic concurrency control</strong>
</p>
<p>
Each <code>index</code> and <code>delete</code> action within a bulk API call may include the <code>if_seq_no</code> and <code>if_primary_term</code> parameters in their respective action and meta data lines.
The <code>if_seq_no</code> and <code>if_primary_term</code> parameters control how operations are run, based on the last modification to existing documents. See Optimistic concurrency control for more details.
</p>
<p>
<strong>Versioning</strong>
</p>
<p>
Each bulk item can include the version value using the <code>version</code> field.
It automatically follows the behavior of the index or delete operation based on the <code>_version</code> mapping.
It also support the <code>version_type</code>.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
Each bulk item can include the routing value using the <code>routing</code> field.
It automatically follows the behavior of the index or delete operation based on the <code>_routing</code> mapping.
</p>
<p>
NOTE: Data streams do not support custom routing unless they were created with the <code>allow_custom_routing</code> setting enabled in the template.
</p>
<p>
<strong>Wait for active shards</strong>
</p>
<p>
When making bulk calls, you can set the <code>wait_for_active_shards</code> parameter to require a minimum number of shard copies to be active before starting to process the bulk request.
</p>
<p>
<strong>Refresh</strong>
</p>
<p>
Control when the changes made by this request are visible to search.
</p>
<p>
NOTE: Only the shards that receive the bulk request will be affected by refresh.
Imagine a <code>_bulk?refresh=wait_for</code> request with three documents in it that happen to be routed to different shards in an index with five shards.
The request will only wait for those three shards to refresh.
The other two shards that make up the index do not participate in the <code>_bulk</code> request at all.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-bulk.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;BulkResponse&gt; BulkAsync(Action&lt;BulkRequestDescriptor&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.BulkRequestDescriptor.html">BulkRequestDescriptor</a>&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.BulkResponse.html">BulkResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_BulkAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.BulkAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_BulkAsync_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.BulkAsync(System.Threading.CancellationToken)">
  BulkAsync(CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L4287"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Bulk index or delete documents.
Perform multiple <code>index</code>, <code>create</code>, <code>delete</code>, and <code>update</code> actions in a single request.
This reduces overhead and can greatly increase indexing speed.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or index alias:
</p>
<ul><li>
<p>
To use the <code>create</code> action, you must have the <code>create_doc</code>, <code>create</code>, <code>index</code>, or <code>write</code> index privilege. Data streams support only the <code>create</code> action.
</p>
</li><li>
<p>
To use the <code>index</code> action, you must have the <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To use the <code>delete</code> action, you must have the <code>delete</code> or <code>write</code> index privilege.
</p>
</li><li>
<p>
To use the <code>update</code> action, you must have the <code>index</code> or <code>write</code> index privilege.
</p>
</li><li>
<p>
To automatically create a data stream or index with a bulk API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege.
</p>
</li><li>
<p>
To make the result of a bulk operation visible to search using the <code>refresh</code> parameter, you must have the <code>maintenance</code> or <code>manage</code> index privilege.
</p>
</li></ul>
<p>
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
The actions are specified in the request body using a newline delimited JSON (NDJSON) structure:
</p>
<pre><code class="lang-csharp">action_and_meta_data\n
optional_source\n
action_and_meta_data\n
optional_source\n
....
action_and_meta_data\n
optional_source\n</code></pre>
<p>
The <code>index</code> and <code>create</code> actions expect a source on the next line and have the same semantics as the <code>op_type</code> parameter in the standard index API.
A <code>create</code> action fails if a document with the same ID already exists in the target
An <code>index</code> action adds or replaces a document as necessary.
</p>
<p>
NOTE: Data streams support only the <code>create</code> action.
To update or delete a document in a data stream, you must target the backing index containing the document.
</p>
<p>
An <code>update</code> action expects that the partial doc, upsert, and script and its options are specified on the next line.
</p>
<p>
A <code>delete</code> action does not expect a source on the next line and has the same semantics as the standard delete API.
</p>
<p>
NOTE: The final line of data must end with a newline character (<code>\n</code>).
Each newline character may be preceded by a carriage return (<code>\r</code>).
When sending NDJSON data to the <code>_bulk</code> endpoint, use a <code>Content-Type</code> header of <code>application/json</code> or <code>application/x-ndjson</code>.
Because this format uses literal newline characters (<code>\n</code>) as delimiters, make sure that the JSON actions and sources are not pretty printed.
</p>
<p>
If you provide a target in the request path, it is used for any actions that don't explicitly specify an <code>_index</code> argument.
</p>
<p>
A note on the format: the idea here is to make processing as fast as possible.
As some of the actions are redirected to other shards on other nodes, only <code>action_meta_data</code> is parsed on the receiving node side.
</p>
<p>
Client libraries using this protocol should try and strive to do something similar on the client side, and reduce buffering as much as possible.
</p>
<p>
There is no "correct" number of actions to perform in a single bulk request.
Experiment with different settings to find the optimal size for your particular workload.
Note that Elasticsearch limits the maximum size of a HTTP request to 100mb by default so clients must ensure that no request exceeds this size.
It is not possible to index a single document that exceeds the size limit, so you must pre-process any such documents into smaller pieces before sending them to Elasticsearch.
For instance, split documents into pages or chapters before indexing them, or store raw binary data in a system outside Elasticsearch and replace the raw data with a link to the external system in the documents that you send to Elasticsearch.
</p>
<p>
<strong>Client suppport for bulk requests</strong>
</p>
<p>
Some of the officially supported clients provide helpers to assist with bulk requests and reindexing:
</p>
<ul><li>
<p>
Go: Check out <code>esutil.BulkIndexer</code>
</p>
</li><li>
<p>
Perl: Check out <code>Search::Elasticsearch::Client::5_0::Bulk</code> and <code>Search::Elasticsearch::Client::5_0::Scroll</code>
</p>
</li><li>
<p>
Python: Check out <code>elasticsearch.helpers.*</code>
</p>
</li><li>
<p>
JavaScript: Check out <code>client.helpers.*</code>
</p>
</li><li>
<p>
.NET: Check out <code>BulkAllObservable</code>
</p>
</li><li>
<p>
PHP: Check out bulk indexing.
</p>
</li></ul>
<p>
<strong>Submitting bulk requests with cURL</strong>
</p>
<p>
If you're providing text file input to <code>curl</code>, you must use the <code>--data-binary</code> flag instead of plain <code>-d</code>.
The latter doesn't preserve newlines. For example:
</p>
<pre><code class="lang-csharp">$ cat requests
{ "index" : { "_index" : "test", "_id" : "1" } }
{ "field1" : "value1" }
$ curl -s -H "Content-Type: application/x-ndjson" -XPOST localhost:9200/_bulk --data-binary "@requests"; echo
{"took":7, "errors": false, "items":[{"index":{"_index":"test","_id":"1","_version":1,"result":"created","forced_refresh":false}}]}</code></pre>
<p>
<strong>Optimistic concurrency control</strong>
</p>
<p>
Each <code>index</code> and <code>delete</code> action within a bulk API call may include the <code>if_seq_no</code> and <code>if_primary_term</code> parameters in their respective action and meta data lines.
The <code>if_seq_no</code> and <code>if_primary_term</code> parameters control how operations are run, based on the last modification to existing documents. See Optimistic concurrency control for more details.
</p>
<p>
<strong>Versioning</strong>
</p>
<p>
Each bulk item can include the version value using the <code>version</code> field.
It automatically follows the behavior of the index or delete operation based on the <code>_version</code> mapping.
It also support the <code>version_type</code>.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
Each bulk item can include the routing value using the <code>routing</code> field.
It automatically follows the behavior of the index or delete operation based on the <code>_routing</code> mapping.
</p>
<p>
NOTE: Data streams do not support custom routing unless they were created with the <code>allow_custom_routing</code> setting enabled in the template.
</p>
<p>
<strong>Wait for active shards</strong>
</p>
<p>
When making bulk calls, you can set the <code>wait_for_active_shards</code> parameter to require a minimum number of shard copies to be active before starting to process the bulk request.
</p>
<p>
<strong>Refresh</strong>
</p>
<p>
Control when the changes made by this request are visible to search.
</p>
<p>
NOTE: Only the shards that receive the bulk request will be affected by refresh.
Imagine a <code>_bulk?refresh=wait_for</code> request with three documents in it that happen to be routed to different shards in an index with five shards.
The request will only wait for those three shards to refresh.
The other two shards that make up the index do not participate in the <code>_bulk</code> request at all.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-bulk.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;BulkResponse&gt; BulkAsync(CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.BulkResponse.html">BulkResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_BulkAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.BulkAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_BulkAsync__1_Elastic_Clients_Elasticsearch_BulkRequestDescriptor___0__System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.BulkAsync``1(Elastic.Clients.Elasticsearch.BulkRequestDescriptor{``0},System.Threading.CancellationToken)">
  BulkAsync&lt;TDocument&gt;(BulkRequestDescriptor&lt;TDocument&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L2702"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Bulk index or delete documents.
Perform multiple <code>index</code>, <code>create</code>, <code>delete</code>, and <code>update</code> actions in a single request.
This reduces overhead and can greatly increase indexing speed.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or index alias:
</p>
<ul><li>
<p>
To use the <code>create</code> action, you must have the <code>create_doc</code>, <code>create</code>, <code>index</code>, or <code>write</code> index privilege. Data streams support only the <code>create</code> action.
</p>
</li><li>
<p>
To use the <code>index</code> action, you must have the <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To use the <code>delete</code> action, you must have the <code>delete</code> or <code>write</code> index privilege.
</p>
</li><li>
<p>
To use the <code>update</code> action, you must have the <code>index</code> or <code>write</code> index privilege.
</p>
</li><li>
<p>
To automatically create a data stream or index with a bulk API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege.
</p>
</li><li>
<p>
To make the result of a bulk operation visible to search using the <code>refresh</code> parameter, you must have the <code>maintenance</code> or <code>manage</code> index privilege.
</p>
</li></ul>
<p>
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
The actions are specified in the request body using a newline delimited JSON (NDJSON) structure:
</p>
<pre><code class="lang-csharp">action_and_meta_data\n
optional_source\n
action_and_meta_data\n
optional_source\n
....
action_and_meta_data\n
optional_source\n</code></pre>
<p>
The <code>index</code> and <code>create</code> actions expect a source on the next line and have the same semantics as the <code>op_type</code> parameter in the standard index API.
A <code>create</code> action fails if a document with the same ID already exists in the target
An <code>index</code> action adds or replaces a document as necessary.
</p>
<p>
NOTE: Data streams support only the <code>create</code> action.
To update or delete a document in a data stream, you must target the backing index containing the document.
</p>
<p>
An <code>update</code> action expects that the partial doc, upsert, and script and its options are specified on the next line.
</p>
<p>
A <code>delete</code> action does not expect a source on the next line and has the same semantics as the standard delete API.
</p>
<p>
NOTE: The final line of data must end with a newline character (<code>\n</code>).
Each newline character may be preceded by a carriage return (<code>\r</code>).
When sending NDJSON data to the <code>_bulk</code> endpoint, use a <code>Content-Type</code> header of <code>application/json</code> or <code>application/x-ndjson</code>.
Because this format uses literal newline characters (<code>\n</code>) as delimiters, make sure that the JSON actions and sources are not pretty printed.
</p>
<p>
If you provide a target in the request path, it is used for any actions that don't explicitly specify an <code>_index</code> argument.
</p>
<p>
A note on the format: the idea here is to make processing as fast as possible.
As some of the actions are redirected to other shards on other nodes, only <code>action_meta_data</code> is parsed on the receiving node side.
</p>
<p>
Client libraries using this protocol should try and strive to do something similar on the client side, and reduce buffering as much as possible.
</p>
<p>
There is no "correct" number of actions to perform in a single bulk request.
Experiment with different settings to find the optimal size for your particular workload.
Note that Elasticsearch limits the maximum size of a HTTP request to 100mb by default so clients must ensure that no request exceeds this size.
It is not possible to index a single document that exceeds the size limit, so you must pre-process any such documents into smaller pieces before sending them to Elasticsearch.
For instance, split documents into pages or chapters before indexing them, or store raw binary data in a system outside Elasticsearch and replace the raw data with a link to the external system in the documents that you send to Elasticsearch.
</p>
<p>
<strong>Client suppport for bulk requests</strong>
</p>
<p>
Some of the officially supported clients provide helpers to assist with bulk requests and reindexing:
</p>
<ul><li>
<p>
Go: Check out <code>esutil.BulkIndexer</code>
</p>
</li><li>
<p>
Perl: Check out <code>Search::Elasticsearch::Client::5_0::Bulk</code> and <code>Search::Elasticsearch::Client::5_0::Scroll</code>
</p>
</li><li>
<p>
Python: Check out <code>elasticsearch.helpers.*</code>
</p>
</li><li>
<p>
JavaScript: Check out <code>client.helpers.*</code>
</p>
</li><li>
<p>
.NET: Check out <code>BulkAllObservable</code>
</p>
</li><li>
<p>
PHP: Check out bulk indexing.
</p>
</li></ul>
<p>
<strong>Submitting bulk requests with cURL</strong>
</p>
<p>
If you're providing text file input to <code>curl</code>, you must use the <code>--data-binary</code> flag instead of plain <code>-d</code>.
The latter doesn't preserve newlines. For example:
</p>
<pre><code class="lang-csharp">$ cat requests
{ "index" : { "_index" : "test", "_id" : "1" } }
{ "field1" : "value1" }
$ curl -s -H "Content-Type: application/x-ndjson" -XPOST localhost:9200/_bulk --data-binary "@requests"; echo
{"took":7, "errors": false, "items":[{"index":{"_index":"test","_id":"1","_version":1,"result":"created","forced_refresh":false}}]}</code></pre>
<p>
<strong>Optimistic concurrency control</strong>
</p>
<p>
Each <code>index</code> and <code>delete</code> action within a bulk API call may include the <code>if_seq_no</code> and <code>if_primary_term</code> parameters in their respective action and meta data lines.
The <code>if_seq_no</code> and <code>if_primary_term</code> parameters control how operations are run, based on the last modification to existing documents. See Optimistic concurrency control for more details.
</p>
<p>
<strong>Versioning</strong>
</p>
<p>
Each bulk item can include the version value using the <code>version</code> field.
It automatically follows the behavior of the index or delete operation based on the <code>_version</code> mapping.
It also support the <code>version_type</code>.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
Each bulk item can include the routing value using the <code>routing</code> field.
It automatically follows the behavior of the index or delete operation based on the <code>_routing</code> mapping.
</p>
<p>
NOTE: Data streams do not support custom routing unless they were created with the <code>allow_custom_routing</code> setting enabled in the template.
</p>
<p>
<strong>Wait for active shards</strong>
</p>
<p>
When making bulk calls, you can set the <code>wait_for_active_shards</code> parameter to require a minimum number of shard copies to be active before starting to process the bulk request.
</p>
<p>
<strong>Refresh</strong>
</p>
<p>
Control when the changes made by this request are visible to search.
</p>
<p>
NOTE: Only the shards that receive the bulk request will be affected by refresh.
Imagine a <code>_bulk?refresh=wait_for</code> request with three documents in it that happen to be routed to different shards in an index with five shards.
The request will only wait for those three shards to refresh.
The other two shards that make up the index do not participate in the <code>_bulk</code> request at all.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-bulk.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;BulkResponse&gt; BulkAsync&lt;TDocument&gt;(BulkRequestDescriptor&lt;TDocument&gt; descriptor, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.BulkRequestDescriptor-1.html">BulkRequestDescriptor</a>&lt;TDocument&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.BulkResponse.html">BulkResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_BulkAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.BulkAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_BulkAsync__1_Elastic_Clients_Elasticsearch_IndexName_System_Action_Elastic_Clients_Elasticsearch_BulkRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.BulkAsync``1(Elastic.Clients.Elasticsearch.IndexName,System.Action{Elastic.Clients.Elasticsearch.BulkRequestDescriptor{``0}},System.Threading.CancellationToken)">
  BulkAsync&lt;TDocument&gt;(IndexName?, Action&lt;BulkRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L3097"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Bulk index or delete documents.
Perform multiple <code>index</code>, <code>create</code>, <code>delete</code>, and <code>update</code> actions in a single request.
This reduces overhead and can greatly increase indexing speed.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or index alias:
</p>
<ul><li>
<p>
To use the <code>create</code> action, you must have the <code>create_doc</code>, <code>create</code>, <code>index</code>, or <code>write</code> index privilege. Data streams support only the <code>create</code> action.
</p>
</li><li>
<p>
To use the <code>index</code> action, you must have the <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To use the <code>delete</code> action, you must have the <code>delete</code> or <code>write</code> index privilege.
</p>
</li><li>
<p>
To use the <code>update</code> action, you must have the <code>index</code> or <code>write</code> index privilege.
</p>
</li><li>
<p>
To automatically create a data stream or index with a bulk API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege.
</p>
</li><li>
<p>
To make the result of a bulk operation visible to search using the <code>refresh</code> parameter, you must have the <code>maintenance</code> or <code>manage</code> index privilege.
</p>
</li></ul>
<p>
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
The actions are specified in the request body using a newline delimited JSON (NDJSON) structure:
</p>
<pre><code class="lang-csharp">action_and_meta_data\n
optional_source\n
action_and_meta_data\n
optional_source\n
....
action_and_meta_data\n
optional_source\n</code></pre>
<p>
The <code>index</code> and <code>create</code> actions expect a source on the next line and have the same semantics as the <code>op_type</code> parameter in the standard index API.
A <code>create</code> action fails if a document with the same ID already exists in the target
An <code>index</code> action adds or replaces a document as necessary.
</p>
<p>
NOTE: Data streams support only the <code>create</code> action.
To update or delete a document in a data stream, you must target the backing index containing the document.
</p>
<p>
An <code>update</code> action expects that the partial doc, upsert, and script and its options are specified on the next line.
</p>
<p>
A <code>delete</code> action does not expect a source on the next line and has the same semantics as the standard delete API.
</p>
<p>
NOTE: The final line of data must end with a newline character (<code>\n</code>).
Each newline character may be preceded by a carriage return (<code>\r</code>).
When sending NDJSON data to the <code>_bulk</code> endpoint, use a <code>Content-Type</code> header of <code>application/json</code> or <code>application/x-ndjson</code>.
Because this format uses literal newline characters (<code>\n</code>) as delimiters, make sure that the JSON actions and sources are not pretty printed.
</p>
<p>
If you provide a target in the request path, it is used for any actions that don't explicitly specify an <code>_index</code> argument.
</p>
<p>
A note on the format: the idea here is to make processing as fast as possible.
As some of the actions are redirected to other shards on other nodes, only <code>action_meta_data</code> is parsed on the receiving node side.
</p>
<p>
Client libraries using this protocol should try and strive to do something similar on the client side, and reduce buffering as much as possible.
</p>
<p>
There is no "correct" number of actions to perform in a single bulk request.
Experiment with different settings to find the optimal size for your particular workload.
Note that Elasticsearch limits the maximum size of a HTTP request to 100mb by default so clients must ensure that no request exceeds this size.
It is not possible to index a single document that exceeds the size limit, so you must pre-process any such documents into smaller pieces before sending them to Elasticsearch.
For instance, split documents into pages or chapters before indexing them, or store raw binary data in a system outside Elasticsearch and replace the raw data with a link to the external system in the documents that you send to Elasticsearch.
</p>
<p>
<strong>Client suppport for bulk requests</strong>
</p>
<p>
Some of the officially supported clients provide helpers to assist with bulk requests and reindexing:
</p>
<ul><li>
<p>
Go: Check out <code>esutil.BulkIndexer</code>
</p>
</li><li>
<p>
Perl: Check out <code>Search::Elasticsearch::Client::5_0::Bulk</code> and <code>Search::Elasticsearch::Client::5_0::Scroll</code>
</p>
</li><li>
<p>
Python: Check out <code>elasticsearch.helpers.*</code>
</p>
</li><li>
<p>
JavaScript: Check out <code>client.helpers.*</code>
</p>
</li><li>
<p>
.NET: Check out <code>BulkAllObservable</code>
</p>
</li><li>
<p>
PHP: Check out bulk indexing.
</p>
</li></ul>
<p>
<strong>Submitting bulk requests with cURL</strong>
</p>
<p>
If you're providing text file input to <code>curl</code>, you must use the <code>--data-binary</code> flag instead of plain <code>-d</code>.
The latter doesn't preserve newlines. For example:
</p>
<pre><code class="lang-csharp">$ cat requests
{ "index" : { "_index" : "test", "_id" : "1" } }
{ "field1" : "value1" }
$ curl -s -H "Content-Type: application/x-ndjson" -XPOST localhost:9200/_bulk --data-binary "@requests"; echo
{"took":7, "errors": false, "items":[{"index":{"_index":"test","_id":"1","_version":1,"result":"created","forced_refresh":false}}]}</code></pre>
<p>
<strong>Optimistic concurrency control</strong>
</p>
<p>
Each <code>index</code> and <code>delete</code> action within a bulk API call may include the <code>if_seq_no</code> and <code>if_primary_term</code> parameters in their respective action and meta data lines.
The <code>if_seq_no</code> and <code>if_primary_term</code> parameters control how operations are run, based on the last modification to existing documents. See Optimistic concurrency control for more details.
</p>
<p>
<strong>Versioning</strong>
</p>
<p>
Each bulk item can include the version value using the <code>version</code> field.
It automatically follows the behavior of the index or delete operation based on the <code>_version</code> mapping.
It also support the <code>version_type</code>.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
Each bulk item can include the routing value using the <code>routing</code> field.
It automatically follows the behavior of the index or delete operation based on the <code>_routing</code> mapping.
</p>
<p>
NOTE: Data streams do not support custom routing unless they were created with the <code>allow_custom_routing</code> setting enabled in the template.
</p>
<p>
<strong>Wait for active shards</strong>
</p>
<p>
When making bulk calls, you can set the <code>wait_for_active_shards</code> parameter to require a minimum number of shard copies to be active before starting to process the bulk request.
</p>
<p>
<strong>Refresh</strong>
</p>
<p>
Control when the changes made by this request are visible to search.
</p>
<p>
NOTE: Only the shards that receive the bulk request will be affected by refresh.
Imagine a <code>_bulk?refresh=wait_for</code> request with three documents in it that happen to be routed to different shards in an index with five shards.
The request will only wait for those three shards to refresh.
The other two shards that make up the index do not participate in the <code>_bulk</code> request at all.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-bulk.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;BulkResponse&gt; BulkAsync&lt;TDocument&gt;(IndexName? index, Action&lt;BulkRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.BulkRequestDescriptor-1.html">BulkRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.BulkResponse.html">BulkResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_BulkAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.BulkAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_BulkAsync__1_Elastic_Clients_Elasticsearch_IndexName_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.BulkAsync``1(Elastic.Clients.Elasticsearch.IndexName,System.Threading.CancellationToken)">
  BulkAsync&lt;TDocument&gt;(IndexName?, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L2899"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Bulk index or delete documents.
Perform multiple <code>index</code>, <code>create</code>, <code>delete</code>, and <code>update</code> actions in a single request.
This reduces overhead and can greatly increase indexing speed.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or index alias:
</p>
<ul><li>
<p>
To use the <code>create</code> action, you must have the <code>create_doc</code>, <code>create</code>, <code>index</code>, or <code>write</code> index privilege. Data streams support only the <code>create</code> action.
</p>
</li><li>
<p>
To use the <code>index</code> action, you must have the <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To use the <code>delete</code> action, you must have the <code>delete</code> or <code>write</code> index privilege.
</p>
</li><li>
<p>
To use the <code>update</code> action, you must have the <code>index</code> or <code>write</code> index privilege.
</p>
</li><li>
<p>
To automatically create a data stream or index with a bulk API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege.
</p>
</li><li>
<p>
To make the result of a bulk operation visible to search using the <code>refresh</code> parameter, you must have the <code>maintenance</code> or <code>manage</code> index privilege.
</p>
</li></ul>
<p>
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
The actions are specified in the request body using a newline delimited JSON (NDJSON) structure:
</p>
<pre><code class="lang-csharp">action_and_meta_data\n
optional_source\n
action_and_meta_data\n
optional_source\n
....
action_and_meta_data\n
optional_source\n</code></pre>
<p>
The <code>index</code> and <code>create</code> actions expect a source on the next line and have the same semantics as the <code>op_type</code> parameter in the standard index API.
A <code>create</code> action fails if a document with the same ID already exists in the target
An <code>index</code> action adds or replaces a document as necessary.
</p>
<p>
NOTE: Data streams support only the <code>create</code> action.
To update or delete a document in a data stream, you must target the backing index containing the document.
</p>
<p>
An <code>update</code> action expects that the partial doc, upsert, and script and its options are specified on the next line.
</p>
<p>
A <code>delete</code> action does not expect a source on the next line and has the same semantics as the standard delete API.
</p>
<p>
NOTE: The final line of data must end with a newline character (<code>\n</code>).
Each newline character may be preceded by a carriage return (<code>\r</code>).
When sending NDJSON data to the <code>_bulk</code> endpoint, use a <code>Content-Type</code> header of <code>application/json</code> or <code>application/x-ndjson</code>.
Because this format uses literal newline characters (<code>\n</code>) as delimiters, make sure that the JSON actions and sources are not pretty printed.
</p>
<p>
If you provide a target in the request path, it is used for any actions that don't explicitly specify an <code>_index</code> argument.
</p>
<p>
A note on the format: the idea here is to make processing as fast as possible.
As some of the actions are redirected to other shards on other nodes, only <code>action_meta_data</code> is parsed on the receiving node side.
</p>
<p>
Client libraries using this protocol should try and strive to do something similar on the client side, and reduce buffering as much as possible.
</p>
<p>
There is no "correct" number of actions to perform in a single bulk request.
Experiment with different settings to find the optimal size for your particular workload.
Note that Elasticsearch limits the maximum size of a HTTP request to 100mb by default so clients must ensure that no request exceeds this size.
It is not possible to index a single document that exceeds the size limit, so you must pre-process any such documents into smaller pieces before sending them to Elasticsearch.
For instance, split documents into pages or chapters before indexing them, or store raw binary data in a system outside Elasticsearch and replace the raw data with a link to the external system in the documents that you send to Elasticsearch.
</p>
<p>
<strong>Client suppport for bulk requests</strong>
</p>
<p>
Some of the officially supported clients provide helpers to assist with bulk requests and reindexing:
</p>
<ul><li>
<p>
Go: Check out <code>esutil.BulkIndexer</code>
</p>
</li><li>
<p>
Perl: Check out <code>Search::Elasticsearch::Client::5_0::Bulk</code> and <code>Search::Elasticsearch::Client::5_0::Scroll</code>
</p>
</li><li>
<p>
Python: Check out <code>elasticsearch.helpers.*</code>
</p>
</li><li>
<p>
JavaScript: Check out <code>client.helpers.*</code>
</p>
</li><li>
<p>
.NET: Check out <code>BulkAllObservable</code>
</p>
</li><li>
<p>
PHP: Check out bulk indexing.
</p>
</li></ul>
<p>
<strong>Submitting bulk requests with cURL</strong>
</p>
<p>
If you're providing text file input to <code>curl</code>, you must use the <code>--data-binary</code> flag instead of plain <code>-d</code>.
The latter doesn't preserve newlines. For example:
</p>
<pre><code class="lang-csharp">$ cat requests
{ "index" : { "_index" : "test", "_id" : "1" } }
{ "field1" : "value1" }
$ curl -s -H "Content-Type: application/x-ndjson" -XPOST localhost:9200/_bulk --data-binary "@requests"; echo
{"took":7, "errors": false, "items":[{"index":{"_index":"test","_id":"1","_version":1,"result":"created","forced_refresh":false}}]}</code></pre>
<p>
<strong>Optimistic concurrency control</strong>
</p>
<p>
Each <code>index</code> and <code>delete</code> action within a bulk API call may include the <code>if_seq_no</code> and <code>if_primary_term</code> parameters in their respective action and meta data lines.
The <code>if_seq_no</code> and <code>if_primary_term</code> parameters control how operations are run, based on the last modification to existing documents. See Optimistic concurrency control for more details.
</p>
<p>
<strong>Versioning</strong>
</p>
<p>
Each bulk item can include the version value using the <code>version</code> field.
It automatically follows the behavior of the index or delete operation based on the <code>_version</code> mapping.
It also support the <code>version_type</code>.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
Each bulk item can include the routing value using the <code>routing</code> field.
It automatically follows the behavior of the index or delete operation based on the <code>_routing</code> mapping.
</p>
<p>
NOTE: Data streams do not support custom routing unless they were created with the <code>allow_custom_routing</code> setting enabled in the template.
</p>
<p>
<strong>Wait for active shards</strong>
</p>
<p>
When making bulk calls, you can set the <code>wait_for_active_shards</code> parameter to require a minimum number of shard copies to be active before starting to process the bulk request.
</p>
<p>
<strong>Refresh</strong>
</p>
<p>
Control when the changes made by this request are visible to search.
</p>
<p>
NOTE: Only the shards that receive the bulk request will be affected by refresh.
Imagine a <code>_bulk?refresh=wait_for</code> request with three documents in it that happen to be routed to different shards in an index with five shards.
The request will only wait for those three shards to refresh.
The other two shards that make up the index do not participate in the <code>_bulk</code> request at all.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-bulk.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;BulkResponse&gt; BulkAsync&lt;TDocument&gt;(IndexName? index, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.BulkResponse.html">BulkResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_BulkAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.BulkAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_BulkAsync__1_System_Action_Elastic_Clients_Elasticsearch_BulkRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.BulkAsync``1(System.Action{Elastic.Clients.Elasticsearch.BulkRequestDescriptor{``0}},System.Threading.CancellationToken)">
  BulkAsync&lt;TDocument&gt;(Action&lt;BulkRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L3494"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Bulk index or delete documents.
Perform multiple <code>index</code>, <code>create</code>, <code>delete</code>, and <code>update</code> actions in a single request.
This reduces overhead and can greatly increase indexing speed.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or index alias:
</p>
<ul><li>
<p>
To use the <code>create</code> action, you must have the <code>create_doc</code>, <code>create</code>, <code>index</code>, or <code>write</code> index privilege. Data streams support only the <code>create</code> action.
</p>
</li><li>
<p>
To use the <code>index</code> action, you must have the <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To use the <code>delete</code> action, you must have the <code>delete</code> or <code>write</code> index privilege.
</p>
</li><li>
<p>
To use the <code>update</code> action, you must have the <code>index</code> or <code>write</code> index privilege.
</p>
</li><li>
<p>
To automatically create a data stream or index with a bulk API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege.
</p>
</li><li>
<p>
To make the result of a bulk operation visible to search using the <code>refresh</code> parameter, you must have the <code>maintenance</code> or <code>manage</code> index privilege.
</p>
</li></ul>
<p>
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
The actions are specified in the request body using a newline delimited JSON (NDJSON) structure:
</p>
<pre><code class="lang-csharp">action_and_meta_data\n
optional_source\n
action_and_meta_data\n
optional_source\n
....
action_and_meta_data\n
optional_source\n</code></pre>
<p>
The <code>index</code> and <code>create</code> actions expect a source on the next line and have the same semantics as the <code>op_type</code> parameter in the standard index API.
A <code>create</code> action fails if a document with the same ID already exists in the target
An <code>index</code> action adds or replaces a document as necessary.
</p>
<p>
NOTE: Data streams support only the <code>create</code> action.
To update or delete a document in a data stream, you must target the backing index containing the document.
</p>
<p>
An <code>update</code> action expects that the partial doc, upsert, and script and its options are specified on the next line.
</p>
<p>
A <code>delete</code> action does not expect a source on the next line and has the same semantics as the standard delete API.
</p>
<p>
NOTE: The final line of data must end with a newline character (<code>\n</code>).
Each newline character may be preceded by a carriage return (<code>\r</code>).
When sending NDJSON data to the <code>_bulk</code> endpoint, use a <code>Content-Type</code> header of <code>application/json</code> or <code>application/x-ndjson</code>.
Because this format uses literal newline characters (<code>\n</code>) as delimiters, make sure that the JSON actions and sources are not pretty printed.
</p>
<p>
If you provide a target in the request path, it is used for any actions that don't explicitly specify an <code>_index</code> argument.
</p>
<p>
A note on the format: the idea here is to make processing as fast as possible.
As some of the actions are redirected to other shards on other nodes, only <code>action_meta_data</code> is parsed on the receiving node side.
</p>
<p>
Client libraries using this protocol should try and strive to do something similar on the client side, and reduce buffering as much as possible.
</p>
<p>
There is no "correct" number of actions to perform in a single bulk request.
Experiment with different settings to find the optimal size for your particular workload.
Note that Elasticsearch limits the maximum size of a HTTP request to 100mb by default so clients must ensure that no request exceeds this size.
It is not possible to index a single document that exceeds the size limit, so you must pre-process any such documents into smaller pieces before sending them to Elasticsearch.
For instance, split documents into pages or chapters before indexing them, or store raw binary data in a system outside Elasticsearch and replace the raw data with a link to the external system in the documents that you send to Elasticsearch.
</p>
<p>
<strong>Client suppport for bulk requests</strong>
</p>
<p>
Some of the officially supported clients provide helpers to assist with bulk requests and reindexing:
</p>
<ul><li>
<p>
Go: Check out <code>esutil.BulkIndexer</code>
</p>
</li><li>
<p>
Perl: Check out <code>Search::Elasticsearch::Client::5_0::Bulk</code> and <code>Search::Elasticsearch::Client::5_0::Scroll</code>
</p>
</li><li>
<p>
Python: Check out <code>elasticsearch.helpers.*</code>
</p>
</li><li>
<p>
JavaScript: Check out <code>client.helpers.*</code>
</p>
</li><li>
<p>
.NET: Check out <code>BulkAllObservable</code>
</p>
</li><li>
<p>
PHP: Check out bulk indexing.
</p>
</li></ul>
<p>
<strong>Submitting bulk requests with cURL</strong>
</p>
<p>
If you're providing text file input to <code>curl</code>, you must use the <code>--data-binary</code> flag instead of plain <code>-d</code>.
The latter doesn't preserve newlines. For example:
</p>
<pre><code class="lang-csharp">$ cat requests
{ "index" : { "_index" : "test", "_id" : "1" } }
{ "field1" : "value1" }
$ curl -s -H "Content-Type: application/x-ndjson" -XPOST localhost:9200/_bulk --data-binary "@requests"; echo
{"took":7, "errors": false, "items":[{"index":{"_index":"test","_id":"1","_version":1,"result":"created","forced_refresh":false}}]}</code></pre>
<p>
<strong>Optimistic concurrency control</strong>
</p>
<p>
Each <code>index</code> and <code>delete</code> action within a bulk API call may include the <code>if_seq_no</code> and <code>if_primary_term</code> parameters in their respective action and meta data lines.
The <code>if_seq_no</code> and <code>if_primary_term</code> parameters control how operations are run, based on the last modification to existing documents. See Optimistic concurrency control for more details.
</p>
<p>
<strong>Versioning</strong>
</p>
<p>
Each bulk item can include the version value using the <code>version</code> field.
It automatically follows the behavior of the index or delete operation based on the <code>_version</code> mapping.
It also support the <code>version_type</code>.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
Each bulk item can include the routing value using the <code>routing</code> field.
It automatically follows the behavior of the index or delete operation based on the <code>_routing</code> mapping.
</p>
<p>
NOTE: Data streams do not support custom routing unless they were created with the <code>allow_custom_routing</code> setting enabled in the template.
</p>
<p>
<strong>Wait for active shards</strong>
</p>
<p>
When making bulk calls, you can set the <code>wait_for_active_shards</code> parameter to require a minimum number of shard copies to be active before starting to process the bulk request.
</p>
<p>
<strong>Refresh</strong>
</p>
<p>
Control when the changes made by this request are visible to search.
</p>
<p>
NOTE: Only the shards that receive the bulk request will be affected by refresh.
Imagine a <code>_bulk?refresh=wait_for</code> request with three documents in it that happen to be routed to different shards in an index with five shards.
The request will only wait for those three shards to refresh.
The other two shards that make up the index do not participate in the <code>_bulk</code> request at all.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-bulk.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;BulkResponse&gt; BulkAsync&lt;TDocument&gt;(Action&lt;BulkRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.BulkRequestDescriptor-1.html">BulkRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.BulkResponse.html">BulkResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_BulkAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.BulkAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_BulkAsync__1_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.BulkAsync``1(System.Threading.CancellationToken)">
  BulkAsync&lt;TDocument&gt;(CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L3296"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Bulk index or delete documents.
Perform multiple <code>index</code>, <code>create</code>, <code>delete</code>, and <code>update</code> actions in a single request.
This reduces overhead and can greatly increase indexing speed.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or index alias:
</p>
<ul><li>
<p>
To use the <code>create</code> action, you must have the <code>create_doc</code>, <code>create</code>, <code>index</code>, or <code>write</code> index privilege. Data streams support only the <code>create</code> action.
</p>
</li><li>
<p>
To use the <code>index</code> action, you must have the <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To use the <code>delete</code> action, you must have the <code>delete</code> or <code>write</code> index privilege.
</p>
</li><li>
<p>
To use the <code>update</code> action, you must have the <code>index</code> or <code>write</code> index privilege.
</p>
</li><li>
<p>
To automatically create a data stream or index with a bulk API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege.
</p>
</li><li>
<p>
To make the result of a bulk operation visible to search using the <code>refresh</code> parameter, you must have the <code>maintenance</code> or <code>manage</code> index privilege.
</p>
</li></ul>
<p>
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
The actions are specified in the request body using a newline delimited JSON (NDJSON) structure:
</p>
<pre><code class="lang-csharp">action_and_meta_data\n
optional_source\n
action_and_meta_data\n
optional_source\n
....
action_and_meta_data\n
optional_source\n</code></pre>
<p>
The <code>index</code> and <code>create</code> actions expect a source on the next line and have the same semantics as the <code>op_type</code> parameter in the standard index API.
A <code>create</code> action fails if a document with the same ID already exists in the target
An <code>index</code> action adds or replaces a document as necessary.
</p>
<p>
NOTE: Data streams support only the <code>create</code> action.
To update or delete a document in a data stream, you must target the backing index containing the document.
</p>
<p>
An <code>update</code> action expects that the partial doc, upsert, and script and its options are specified on the next line.
</p>
<p>
A <code>delete</code> action does not expect a source on the next line and has the same semantics as the standard delete API.
</p>
<p>
NOTE: The final line of data must end with a newline character (<code>\n</code>).
Each newline character may be preceded by a carriage return (<code>\r</code>).
When sending NDJSON data to the <code>_bulk</code> endpoint, use a <code>Content-Type</code> header of <code>application/json</code> or <code>application/x-ndjson</code>.
Because this format uses literal newline characters (<code>\n</code>) as delimiters, make sure that the JSON actions and sources are not pretty printed.
</p>
<p>
If you provide a target in the request path, it is used for any actions that don't explicitly specify an <code>_index</code> argument.
</p>
<p>
A note on the format: the idea here is to make processing as fast as possible.
As some of the actions are redirected to other shards on other nodes, only <code>action_meta_data</code> is parsed on the receiving node side.
</p>
<p>
Client libraries using this protocol should try and strive to do something similar on the client side, and reduce buffering as much as possible.
</p>
<p>
There is no "correct" number of actions to perform in a single bulk request.
Experiment with different settings to find the optimal size for your particular workload.
Note that Elasticsearch limits the maximum size of a HTTP request to 100mb by default so clients must ensure that no request exceeds this size.
It is not possible to index a single document that exceeds the size limit, so you must pre-process any such documents into smaller pieces before sending them to Elasticsearch.
For instance, split documents into pages or chapters before indexing them, or store raw binary data in a system outside Elasticsearch and replace the raw data with a link to the external system in the documents that you send to Elasticsearch.
</p>
<p>
<strong>Client suppport for bulk requests</strong>
</p>
<p>
Some of the officially supported clients provide helpers to assist with bulk requests and reindexing:
</p>
<ul><li>
<p>
Go: Check out <code>esutil.BulkIndexer</code>
</p>
</li><li>
<p>
Perl: Check out <code>Search::Elasticsearch::Client::5_0::Bulk</code> and <code>Search::Elasticsearch::Client::5_0::Scroll</code>
</p>
</li><li>
<p>
Python: Check out <code>elasticsearch.helpers.*</code>
</p>
</li><li>
<p>
JavaScript: Check out <code>client.helpers.*</code>
</p>
</li><li>
<p>
.NET: Check out <code>BulkAllObservable</code>
</p>
</li><li>
<p>
PHP: Check out bulk indexing.
</p>
</li></ul>
<p>
<strong>Submitting bulk requests with cURL</strong>
</p>
<p>
If you're providing text file input to <code>curl</code>, you must use the <code>--data-binary</code> flag instead of plain <code>-d</code>.
The latter doesn't preserve newlines. For example:
</p>
<pre><code class="lang-csharp">$ cat requests
{ "index" : { "_index" : "test", "_id" : "1" } }
{ "field1" : "value1" }
$ curl -s -H "Content-Type: application/x-ndjson" -XPOST localhost:9200/_bulk --data-binary "@requests"; echo
{"took":7, "errors": false, "items":[{"index":{"_index":"test","_id":"1","_version":1,"result":"created","forced_refresh":false}}]}</code></pre>
<p>
<strong>Optimistic concurrency control</strong>
</p>
<p>
Each <code>index</code> and <code>delete</code> action within a bulk API call may include the <code>if_seq_no</code> and <code>if_primary_term</code> parameters in their respective action and meta data lines.
The <code>if_seq_no</code> and <code>if_primary_term</code> parameters control how operations are run, based on the last modification to existing documents. See Optimistic concurrency control for more details.
</p>
<p>
<strong>Versioning</strong>
</p>
<p>
Each bulk item can include the version value using the <code>version</code> field.
It automatically follows the behavior of the index or delete operation based on the <code>_version</code> mapping.
It also support the <code>version_type</code>.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
Each bulk item can include the routing value using the <code>routing</code> field.
It automatically follows the behavior of the index or delete operation based on the <code>_routing</code> mapping.
</p>
<p>
NOTE: Data streams do not support custom routing unless they were created with the <code>allow_custom_routing</code> setting enabled in the template.
</p>
<p>
<strong>Wait for active shards</strong>
</p>
<p>
When making bulk calls, you can set the <code>wait_for_active_shards</code> parameter to require a minimum number of shard copies to be active before starting to process the bulk request.
</p>
<p>
<strong>Refresh</strong>
</p>
<p>
Control when the changes made by this request are visible to search.
</p>
<p>
NOTE: Only the shards that receive the bulk request will be affected by refresh.
Imagine a <code>_bulk?refresh=wait_for</code> request with three documents in it that happen to be routed to different shards in an index with five shards.
The request will only wait for those three shards to refresh.
The other two shards that make up the index do not participate in the <code>_bulk</code> request at all.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-bulk.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;BulkResponse&gt; BulkAsync&lt;TDocument&gt;(CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.BulkResponse.html">BulkResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Bulk_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Bulk*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Bulk__1" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Bulk``1">
  Bulk&lt;TDocument&gt;()
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L1307"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Bulk index or delete documents.
Perform multiple <code>index</code>, <code>create</code>, <code>delete</code>, and <code>update</code> actions in a single request.
This reduces overhead and can greatly increase indexing speed.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or index alias:
</p>
<ul><li>
<p>
To use the <code>create</code> action, you must have the <code>create_doc</code>, <code>create</code>, <code>index</code>, or <code>write</code> index privilege. Data streams support only the <code>create</code> action.
</p>
</li><li>
<p>
To use the <code>index</code> action, you must have the <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To use the <code>delete</code> action, you must have the <code>delete</code> or <code>write</code> index privilege.
</p>
</li><li>
<p>
To use the <code>update</code> action, you must have the <code>index</code> or <code>write</code> index privilege.
</p>
</li><li>
<p>
To automatically create a data stream or index with a bulk API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege.
</p>
</li><li>
<p>
To make the result of a bulk operation visible to search using the <code>refresh</code> parameter, you must have the <code>maintenance</code> or <code>manage</code> index privilege.
</p>
</li></ul>
<p>
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
The actions are specified in the request body using a newline delimited JSON (NDJSON) structure:
</p>
<pre><code class="lang-csharp">action_and_meta_data\n
optional_source\n
action_and_meta_data\n
optional_source\n
....
action_and_meta_data\n
optional_source\n</code></pre>
<p>
The <code>index</code> and <code>create</code> actions expect a source on the next line and have the same semantics as the <code>op_type</code> parameter in the standard index API.
A <code>create</code> action fails if a document with the same ID already exists in the target
An <code>index</code> action adds or replaces a document as necessary.
</p>
<p>
NOTE: Data streams support only the <code>create</code> action.
To update or delete a document in a data stream, you must target the backing index containing the document.
</p>
<p>
An <code>update</code> action expects that the partial doc, upsert, and script and its options are specified on the next line.
</p>
<p>
A <code>delete</code> action does not expect a source on the next line and has the same semantics as the standard delete API.
</p>
<p>
NOTE: The final line of data must end with a newline character (<code>\n</code>).
Each newline character may be preceded by a carriage return (<code>\r</code>).
When sending NDJSON data to the <code>_bulk</code> endpoint, use a <code>Content-Type</code> header of <code>application/json</code> or <code>application/x-ndjson</code>.
Because this format uses literal newline characters (<code>\n</code>) as delimiters, make sure that the JSON actions and sources are not pretty printed.
</p>
<p>
If you provide a target in the request path, it is used for any actions that don't explicitly specify an <code>_index</code> argument.
</p>
<p>
A note on the format: the idea here is to make processing as fast as possible.
As some of the actions are redirected to other shards on other nodes, only <code>action_meta_data</code> is parsed on the receiving node side.
</p>
<p>
Client libraries using this protocol should try and strive to do something similar on the client side, and reduce buffering as much as possible.
</p>
<p>
There is no "correct" number of actions to perform in a single bulk request.
Experiment with different settings to find the optimal size for your particular workload.
Note that Elasticsearch limits the maximum size of a HTTP request to 100mb by default so clients must ensure that no request exceeds this size.
It is not possible to index a single document that exceeds the size limit, so you must pre-process any such documents into smaller pieces before sending them to Elasticsearch.
For instance, split documents into pages or chapters before indexing them, or store raw binary data in a system outside Elasticsearch and replace the raw data with a link to the external system in the documents that you send to Elasticsearch.
</p>
<p>
<strong>Client suppport for bulk requests</strong>
</p>
<p>
Some of the officially supported clients provide helpers to assist with bulk requests and reindexing:
</p>
<ul><li>
<p>
Go: Check out <code>esutil.BulkIndexer</code>
</p>
</li><li>
<p>
Perl: Check out <code>Search::Elasticsearch::Client::5_0::Bulk</code> and <code>Search::Elasticsearch::Client::5_0::Scroll</code>
</p>
</li><li>
<p>
Python: Check out <code>elasticsearch.helpers.*</code>
</p>
</li><li>
<p>
JavaScript: Check out <code>client.helpers.*</code>
</p>
</li><li>
<p>
.NET: Check out <code>BulkAllObservable</code>
</p>
</li><li>
<p>
PHP: Check out bulk indexing.
</p>
</li></ul>
<p>
<strong>Submitting bulk requests with cURL</strong>
</p>
<p>
If you're providing text file input to <code>curl</code>, you must use the <code>--data-binary</code> flag instead of plain <code>-d</code>.
The latter doesn't preserve newlines. For example:
</p>
<pre><code class="lang-csharp">$ cat requests
{ "index" : { "_index" : "test", "_id" : "1" } }
{ "field1" : "value1" }
$ curl -s -H "Content-Type: application/x-ndjson" -XPOST localhost:9200/_bulk --data-binary "@requests"; echo
{"took":7, "errors": false, "items":[{"index":{"_index":"test","_id":"1","_version":1,"result":"created","forced_refresh":false}}]}</code></pre>
<p>
<strong>Optimistic concurrency control</strong>
</p>
<p>
Each <code>index</code> and <code>delete</code> action within a bulk API call may include the <code>if_seq_no</code> and <code>if_primary_term</code> parameters in their respective action and meta data lines.
The <code>if_seq_no</code> and <code>if_primary_term</code> parameters control how operations are run, based on the last modification to existing documents. See Optimistic concurrency control for more details.
</p>
<p>
<strong>Versioning</strong>
</p>
<p>
Each bulk item can include the version value using the <code>version</code> field.
It automatically follows the behavior of the index or delete operation based on the <code>_version</code> mapping.
It also support the <code>version_type</code>.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
Each bulk item can include the routing value using the <code>routing</code> field.
It automatically follows the behavior of the index or delete operation based on the <code>_routing</code> mapping.
</p>
<p>
NOTE: Data streams do not support custom routing unless they were created with the <code>allow_custom_routing</code> setting enabled in the template.
</p>
<p>
<strong>Wait for active shards</strong>
</p>
<p>
When making bulk calls, you can set the <code>wait_for_active_shards</code> parameter to require a minimum number of shard copies to be active before starting to process the bulk request.
</p>
<p>
<strong>Refresh</strong>
</p>
<p>
Control when the changes made by this request are visible to search.
</p>
<p>
NOTE: Only the shards that receive the bulk request will be affected by refresh.
Imagine a <code>_bulk?refresh=wait_for</code> request with three documents in it that happen to be routed to different shards in an index with five shards.
The request will only wait for those three shards to refresh.
The other two shards that make up the index do not participate in the <code>_bulk</code> request at all.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-bulk.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual BulkResponse Bulk&lt;TDocument&gt;()</code></pre>
  </div>


  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.BulkResponse.html">BulkResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Bulk_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Bulk*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Bulk__1_Elastic_Clients_Elasticsearch_BulkRequestDescriptor___0__" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Bulk``1(Elastic.Clients.Elasticsearch.BulkRequestDescriptor{``0})">
  Bulk&lt;TDocument&gt;(BulkRequestDescriptor&lt;TDocument&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L710"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Bulk index or delete documents.
Perform multiple <code>index</code>, <code>create</code>, <code>delete</code>, and <code>update</code> actions in a single request.
This reduces overhead and can greatly increase indexing speed.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or index alias:
</p>
<ul><li>
<p>
To use the <code>create</code> action, you must have the <code>create_doc</code>, <code>create</code>, <code>index</code>, or <code>write</code> index privilege. Data streams support only the <code>create</code> action.
</p>
</li><li>
<p>
To use the <code>index</code> action, you must have the <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To use the <code>delete</code> action, you must have the <code>delete</code> or <code>write</code> index privilege.
</p>
</li><li>
<p>
To use the <code>update</code> action, you must have the <code>index</code> or <code>write</code> index privilege.
</p>
</li><li>
<p>
To automatically create a data stream or index with a bulk API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege.
</p>
</li><li>
<p>
To make the result of a bulk operation visible to search using the <code>refresh</code> parameter, you must have the <code>maintenance</code> or <code>manage</code> index privilege.
</p>
</li></ul>
<p>
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
The actions are specified in the request body using a newline delimited JSON (NDJSON) structure:
</p>
<pre><code class="lang-csharp">action_and_meta_data\n
optional_source\n
action_and_meta_data\n
optional_source\n
....
action_and_meta_data\n
optional_source\n</code></pre>
<p>
The <code>index</code> and <code>create</code> actions expect a source on the next line and have the same semantics as the <code>op_type</code> parameter in the standard index API.
A <code>create</code> action fails if a document with the same ID already exists in the target
An <code>index</code> action adds or replaces a document as necessary.
</p>
<p>
NOTE: Data streams support only the <code>create</code> action.
To update or delete a document in a data stream, you must target the backing index containing the document.
</p>
<p>
An <code>update</code> action expects that the partial doc, upsert, and script and its options are specified on the next line.
</p>
<p>
A <code>delete</code> action does not expect a source on the next line and has the same semantics as the standard delete API.
</p>
<p>
NOTE: The final line of data must end with a newline character (<code>\n</code>).
Each newline character may be preceded by a carriage return (<code>\r</code>).
When sending NDJSON data to the <code>_bulk</code> endpoint, use a <code>Content-Type</code> header of <code>application/json</code> or <code>application/x-ndjson</code>.
Because this format uses literal newline characters (<code>\n</code>) as delimiters, make sure that the JSON actions and sources are not pretty printed.
</p>
<p>
If you provide a target in the request path, it is used for any actions that don't explicitly specify an <code>_index</code> argument.
</p>
<p>
A note on the format: the idea here is to make processing as fast as possible.
As some of the actions are redirected to other shards on other nodes, only <code>action_meta_data</code> is parsed on the receiving node side.
</p>
<p>
Client libraries using this protocol should try and strive to do something similar on the client side, and reduce buffering as much as possible.
</p>
<p>
There is no "correct" number of actions to perform in a single bulk request.
Experiment with different settings to find the optimal size for your particular workload.
Note that Elasticsearch limits the maximum size of a HTTP request to 100mb by default so clients must ensure that no request exceeds this size.
It is not possible to index a single document that exceeds the size limit, so you must pre-process any such documents into smaller pieces before sending them to Elasticsearch.
For instance, split documents into pages or chapters before indexing them, or store raw binary data in a system outside Elasticsearch and replace the raw data with a link to the external system in the documents that you send to Elasticsearch.
</p>
<p>
<strong>Client suppport for bulk requests</strong>
</p>
<p>
Some of the officially supported clients provide helpers to assist with bulk requests and reindexing:
</p>
<ul><li>
<p>
Go: Check out <code>esutil.BulkIndexer</code>
</p>
</li><li>
<p>
Perl: Check out <code>Search::Elasticsearch::Client::5_0::Bulk</code> and <code>Search::Elasticsearch::Client::5_0::Scroll</code>
</p>
</li><li>
<p>
Python: Check out <code>elasticsearch.helpers.*</code>
</p>
</li><li>
<p>
JavaScript: Check out <code>client.helpers.*</code>
</p>
</li><li>
<p>
.NET: Check out <code>BulkAllObservable</code>
</p>
</li><li>
<p>
PHP: Check out bulk indexing.
</p>
</li></ul>
<p>
<strong>Submitting bulk requests with cURL</strong>
</p>
<p>
If you're providing text file input to <code>curl</code>, you must use the <code>--data-binary</code> flag instead of plain <code>-d</code>.
The latter doesn't preserve newlines. For example:
</p>
<pre><code class="lang-csharp">$ cat requests
{ "index" : { "_index" : "test", "_id" : "1" } }
{ "field1" : "value1" }
$ curl -s -H "Content-Type: application/x-ndjson" -XPOST localhost:9200/_bulk --data-binary "@requests"; echo
{"took":7, "errors": false, "items":[{"index":{"_index":"test","_id":"1","_version":1,"result":"created","forced_refresh":false}}]}</code></pre>
<p>
<strong>Optimistic concurrency control</strong>
</p>
<p>
Each <code>index</code> and <code>delete</code> action within a bulk API call may include the <code>if_seq_no</code> and <code>if_primary_term</code> parameters in their respective action and meta data lines.
The <code>if_seq_no</code> and <code>if_primary_term</code> parameters control how operations are run, based on the last modification to existing documents. See Optimistic concurrency control for more details.
</p>
<p>
<strong>Versioning</strong>
</p>
<p>
Each bulk item can include the version value using the <code>version</code> field.
It automatically follows the behavior of the index or delete operation based on the <code>_version</code> mapping.
It also support the <code>version_type</code>.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
Each bulk item can include the routing value using the <code>routing</code> field.
It automatically follows the behavior of the index or delete operation based on the <code>_routing</code> mapping.
</p>
<p>
NOTE: Data streams do not support custom routing unless they were created with the <code>allow_custom_routing</code> setting enabled in the template.
</p>
<p>
<strong>Wait for active shards</strong>
</p>
<p>
When making bulk calls, you can set the <code>wait_for_active_shards</code> parameter to require a minimum number of shard copies to be active before starting to process the bulk request.
</p>
<p>
<strong>Refresh</strong>
</p>
<p>
Control when the changes made by this request are visible to search.
</p>
<p>
NOTE: Only the shards that receive the bulk request will be affected by refresh.
Imagine a <code>_bulk?refresh=wait_for</code> request with three documents in it that happen to be routed to different shards in an index with five shards.
The request will only wait for those three shards to refresh.
The other two shards that make up the index do not participate in the <code>_bulk</code> request at all.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-bulk.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual BulkResponse Bulk&lt;TDocument&gt;(BulkRequestDescriptor&lt;TDocument&gt; descriptor)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.BulkRequestDescriptor-1.html">BulkRequestDescriptor</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.BulkResponse.html">BulkResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Bulk_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Bulk*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Bulk__1_Elastic_Clients_Elasticsearch_IndexName_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Bulk``1(Elastic.Clients.Elasticsearch.IndexName)">
  Bulk&lt;TDocument&gt;(IndexName?)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L908"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Bulk index or delete documents.
Perform multiple <code>index</code>, <code>create</code>, <code>delete</code>, and <code>update</code> actions in a single request.
This reduces overhead and can greatly increase indexing speed.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or index alias:
</p>
<ul><li>
<p>
To use the <code>create</code> action, you must have the <code>create_doc</code>, <code>create</code>, <code>index</code>, or <code>write</code> index privilege. Data streams support only the <code>create</code> action.
</p>
</li><li>
<p>
To use the <code>index</code> action, you must have the <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To use the <code>delete</code> action, you must have the <code>delete</code> or <code>write</code> index privilege.
</p>
</li><li>
<p>
To use the <code>update</code> action, you must have the <code>index</code> or <code>write</code> index privilege.
</p>
</li><li>
<p>
To automatically create a data stream or index with a bulk API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege.
</p>
</li><li>
<p>
To make the result of a bulk operation visible to search using the <code>refresh</code> parameter, you must have the <code>maintenance</code> or <code>manage</code> index privilege.
</p>
</li></ul>
<p>
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
The actions are specified in the request body using a newline delimited JSON (NDJSON) structure:
</p>
<pre><code class="lang-csharp">action_and_meta_data\n
optional_source\n
action_and_meta_data\n
optional_source\n
....
action_and_meta_data\n
optional_source\n</code></pre>
<p>
The <code>index</code> and <code>create</code> actions expect a source on the next line and have the same semantics as the <code>op_type</code> parameter in the standard index API.
A <code>create</code> action fails if a document with the same ID already exists in the target
An <code>index</code> action adds or replaces a document as necessary.
</p>
<p>
NOTE: Data streams support only the <code>create</code> action.
To update or delete a document in a data stream, you must target the backing index containing the document.
</p>
<p>
An <code>update</code> action expects that the partial doc, upsert, and script and its options are specified on the next line.
</p>
<p>
A <code>delete</code> action does not expect a source on the next line and has the same semantics as the standard delete API.
</p>
<p>
NOTE: The final line of data must end with a newline character (<code>\n</code>).
Each newline character may be preceded by a carriage return (<code>\r</code>).
When sending NDJSON data to the <code>_bulk</code> endpoint, use a <code>Content-Type</code> header of <code>application/json</code> or <code>application/x-ndjson</code>.
Because this format uses literal newline characters (<code>\n</code>) as delimiters, make sure that the JSON actions and sources are not pretty printed.
</p>
<p>
If you provide a target in the request path, it is used for any actions that don't explicitly specify an <code>_index</code> argument.
</p>
<p>
A note on the format: the idea here is to make processing as fast as possible.
As some of the actions are redirected to other shards on other nodes, only <code>action_meta_data</code> is parsed on the receiving node side.
</p>
<p>
Client libraries using this protocol should try and strive to do something similar on the client side, and reduce buffering as much as possible.
</p>
<p>
There is no "correct" number of actions to perform in a single bulk request.
Experiment with different settings to find the optimal size for your particular workload.
Note that Elasticsearch limits the maximum size of a HTTP request to 100mb by default so clients must ensure that no request exceeds this size.
It is not possible to index a single document that exceeds the size limit, so you must pre-process any such documents into smaller pieces before sending them to Elasticsearch.
For instance, split documents into pages or chapters before indexing them, or store raw binary data in a system outside Elasticsearch and replace the raw data with a link to the external system in the documents that you send to Elasticsearch.
</p>
<p>
<strong>Client suppport for bulk requests</strong>
</p>
<p>
Some of the officially supported clients provide helpers to assist with bulk requests and reindexing:
</p>
<ul><li>
<p>
Go: Check out <code>esutil.BulkIndexer</code>
</p>
</li><li>
<p>
Perl: Check out <code>Search::Elasticsearch::Client::5_0::Bulk</code> and <code>Search::Elasticsearch::Client::5_0::Scroll</code>
</p>
</li><li>
<p>
Python: Check out <code>elasticsearch.helpers.*</code>
</p>
</li><li>
<p>
JavaScript: Check out <code>client.helpers.*</code>
</p>
</li><li>
<p>
.NET: Check out <code>BulkAllObservable</code>
</p>
</li><li>
<p>
PHP: Check out bulk indexing.
</p>
</li></ul>
<p>
<strong>Submitting bulk requests with cURL</strong>
</p>
<p>
If you're providing text file input to <code>curl</code>, you must use the <code>--data-binary</code> flag instead of plain <code>-d</code>.
The latter doesn't preserve newlines. For example:
</p>
<pre><code class="lang-csharp">$ cat requests
{ "index" : { "_index" : "test", "_id" : "1" } }
{ "field1" : "value1" }
$ curl -s -H "Content-Type: application/x-ndjson" -XPOST localhost:9200/_bulk --data-binary "@requests"; echo
{"took":7, "errors": false, "items":[{"index":{"_index":"test","_id":"1","_version":1,"result":"created","forced_refresh":false}}]}</code></pre>
<p>
<strong>Optimistic concurrency control</strong>
</p>
<p>
Each <code>index</code> and <code>delete</code> action within a bulk API call may include the <code>if_seq_no</code> and <code>if_primary_term</code> parameters in their respective action and meta data lines.
The <code>if_seq_no</code> and <code>if_primary_term</code> parameters control how operations are run, based on the last modification to existing documents. See Optimistic concurrency control for more details.
</p>
<p>
<strong>Versioning</strong>
</p>
<p>
Each bulk item can include the version value using the <code>version</code> field.
It automatically follows the behavior of the index or delete operation based on the <code>_version</code> mapping.
It also support the <code>version_type</code>.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
Each bulk item can include the routing value using the <code>routing</code> field.
It automatically follows the behavior of the index or delete operation based on the <code>_routing</code> mapping.
</p>
<p>
NOTE: Data streams do not support custom routing unless they were created with the <code>allow_custom_routing</code> setting enabled in the template.
</p>
<p>
<strong>Wait for active shards</strong>
</p>
<p>
When making bulk calls, you can set the <code>wait_for_active_shards</code> parameter to require a minimum number of shard copies to be active before starting to process the bulk request.
</p>
<p>
<strong>Refresh</strong>
</p>
<p>
Control when the changes made by this request are visible to search.
</p>
<p>
NOTE: Only the shards that receive the bulk request will be affected by refresh.
Imagine a <code>_bulk?refresh=wait_for</code> request with three documents in it that happen to be routed to different shards in an index with five shards.
The request will only wait for those three shards to refresh.
The other two shards that make up the index do not participate in the <code>_bulk</code> request at all.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-bulk.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual BulkResponse Bulk&lt;TDocument&gt;(IndexName? index)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.BulkResponse.html">BulkResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Bulk_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Bulk*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Bulk__1_Elastic_Clients_Elasticsearch_IndexName_System_Action_Elastic_Clients_Elasticsearch_BulkRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Bulk``1(Elastic.Clients.Elasticsearch.IndexName,System.Action{Elastic.Clients.Elasticsearch.BulkRequestDescriptor{``0}})">
  Bulk&lt;TDocument&gt;(IndexName?, Action&lt;BulkRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L1107"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Bulk index or delete documents.
Perform multiple <code>index</code>, <code>create</code>, <code>delete</code>, and <code>update</code> actions in a single request.
This reduces overhead and can greatly increase indexing speed.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or index alias:
</p>
<ul><li>
<p>
To use the <code>create</code> action, you must have the <code>create_doc</code>, <code>create</code>, <code>index</code>, or <code>write</code> index privilege. Data streams support only the <code>create</code> action.
</p>
</li><li>
<p>
To use the <code>index</code> action, you must have the <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To use the <code>delete</code> action, you must have the <code>delete</code> or <code>write</code> index privilege.
</p>
</li><li>
<p>
To use the <code>update</code> action, you must have the <code>index</code> or <code>write</code> index privilege.
</p>
</li><li>
<p>
To automatically create a data stream or index with a bulk API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege.
</p>
</li><li>
<p>
To make the result of a bulk operation visible to search using the <code>refresh</code> parameter, you must have the <code>maintenance</code> or <code>manage</code> index privilege.
</p>
</li></ul>
<p>
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
The actions are specified in the request body using a newline delimited JSON (NDJSON) structure:
</p>
<pre><code class="lang-csharp">action_and_meta_data\n
optional_source\n
action_and_meta_data\n
optional_source\n
....
action_and_meta_data\n
optional_source\n</code></pre>
<p>
The <code>index</code> and <code>create</code> actions expect a source on the next line and have the same semantics as the <code>op_type</code> parameter in the standard index API.
A <code>create</code> action fails if a document with the same ID already exists in the target
An <code>index</code> action adds or replaces a document as necessary.
</p>
<p>
NOTE: Data streams support only the <code>create</code> action.
To update or delete a document in a data stream, you must target the backing index containing the document.
</p>
<p>
An <code>update</code> action expects that the partial doc, upsert, and script and its options are specified on the next line.
</p>
<p>
A <code>delete</code> action does not expect a source on the next line and has the same semantics as the standard delete API.
</p>
<p>
NOTE: The final line of data must end with a newline character (<code>\n</code>).
Each newline character may be preceded by a carriage return (<code>\r</code>).
When sending NDJSON data to the <code>_bulk</code> endpoint, use a <code>Content-Type</code> header of <code>application/json</code> or <code>application/x-ndjson</code>.
Because this format uses literal newline characters (<code>\n</code>) as delimiters, make sure that the JSON actions and sources are not pretty printed.
</p>
<p>
If you provide a target in the request path, it is used for any actions that don't explicitly specify an <code>_index</code> argument.
</p>
<p>
A note on the format: the idea here is to make processing as fast as possible.
As some of the actions are redirected to other shards on other nodes, only <code>action_meta_data</code> is parsed on the receiving node side.
</p>
<p>
Client libraries using this protocol should try and strive to do something similar on the client side, and reduce buffering as much as possible.
</p>
<p>
There is no "correct" number of actions to perform in a single bulk request.
Experiment with different settings to find the optimal size for your particular workload.
Note that Elasticsearch limits the maximum size of a HTTP request to 100mb by default so clients must ensure that no request exceeds this size.
It is not possible to index a single document that exceeds the size limit, so you must pre-process any such documents into smaller pieces before sending them to Elasticsearch.
For instance, split documents into pages or chapters before indexing them, or store raw binary data in a system outside Elasticsearch and replace the raw data with a link to the external system in the documents that you send to Elasticsearch.
</p>
<p>
<strong>Client suppport for bulk requests</strong>
</p>
<p>
Some of the officially supported clients provide helpers to assist with bulk requests and reindexing:
</p>
<ul><li>
<p>
Go: Check out <code>esutil.BulkIndexer</code>
</p>
</li><li>
<p>
Perl: Check out <code>Search::Elasticsearch::Client::5_0::Bulk</code> and <code>Search::Elasticsearch::Client::5_0::Scroll</code>
</p>
</li><li>
<p>
Python: Check out <code>elasticsearch.helpers.*</code>
</p>
</li><li>
<p>
JavaScript: Check out <code>client.helpers.*</code>
</p>
</li><li>
<p>
.NET: Check out <code>BulkAllObservable</code>
</p>
</li><li>
<p>
PHP: Check out bulk indexing.
</p>
</li></ul>
<p>
<strong>Submitting bulk requests with cURL</strong>
</p>
<p>
If you're providing text file input to <code>curl</code>, you must use the <code>--data-binary</code> flag instead of plain <code>-d</code>.
The latter doesn't preserve newlines. For example:
</p>
<pre><code class="lang-csharp">$ cat requests
{ "index" : { "_index" : "test", "_id" : "1" } }
{ "field1" : "value1" }
$ curl -s -H "Content-Type: application/x-ndjson" -XPOST localhost:9200/_bulk --data-binary "@requests"; echo
{"took":7, "errors": false, "items":[{"index":{"_index":"test","_id":"1","_version":1,"result":"created","forced_refresh":false}}]}</code></pre>
<p>
<strong>Optimistic concurrency control</strong>
</p>
<p>
Each <code>index</code> and <code>delete</code> action within a bulk API call may include the <code>if_seq_no</code> and <code>if_primary_term</code> parameters in their respective action and meta data lines.
The <code>if_seq_no</code> and <code>if_primary_term</code> parameters control how operations are run, based on the last modification to existing documents. See Optimistic concurrency control for more details.
</p>
<p>
<strong>Versioning</strong>
</p>
<p>
Each bulk item can include the version value using the <code>version</code> field.
It automatically follows the behavior of the index or delete operation based on the <code>_version</code> mapping.
It also support the <code>version_type</code>.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
Each bulk item can include the routing value using the <code>routing</code> field.
It automatically follows the behavior of the index or delete operation based on the <code>_routing</code> mapping.
</p>
<p>
NOTE: Data streams do not support custom routing unless they were created with the <code>allow_custom_routing</code> setting enabled in the template.
</p>
<p>
<strong>Wait for active shards</strong>
</p>
<p>
When making bulk calls, you can set the <code>wait_for_active_shards</code> parameter to require a minimum number of shard copies to be active before starting to process the bulk request.
</p>
<p>
<strong>Refresh</strong>
</p>
<p>
Control when the changes made by this request are visible to search.
</p>
<p>
NOTE: Only the shards that receive the bulk request will be affected by refresh.
Imagine a <code>_bulk?refresh=wait_for</code> request with three documents in it that happen to be routed to different shards in an index with five shards.
The request will only wait for those three shards to refresh.
The other two shards that make up the index do not participate in the <code>_bulk</code> request at all.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-bulk.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual BulkResponse Bulk&lt;TDocument&gt;(IndexName? index, Action&lt;BulkRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.BulkRequestDescriptor-1.html">BulkRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.BulkResponse.html">BulkResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Bulk_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Bulk*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Bulk__1_System_Action_Elastic_Clients_Elasticsearch_BulkRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Bulk``1(System.Action{Elastic.Clients.Elasticsearch.BulkRequestDescriptor{``0}})">
  Bulk&lt;TDocument&gt;(Action&lt;BulkRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L1506"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Bulk index or delete documents.
Perform multiple <code>index</code>, <code>create</code>, <code>delete</code>, and <code>update</code> actions in a single request.
This reduces overhead and can greatly increase indexing speed.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or index alias:
</p>
<ul><li>
<p>
To use the <code>create</code> action, you must have the <code>create_doc</code>, <code>create</code>, <code>index</code>, or <code>write</code> index privilege. Data streams support only the <code>create</code> action.
</p>
</li><li>
<p>
To use the <code>index</code> action, you must have the <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To use the <code>delete</code> action, you must have the <code>delete</code> or <code>write</code> index privilege.
</p>
</li><li>
<p>
To use the <code>update</code> action, you must have the <code>index</code> or <code>write</code> index privilege.
</p>
</li><li>
<p>
To automatically create a data stream or index with a bulk API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege.
</p>
</li><li>
<p>
To make the result of a bulk operation visible to search using the <code>refresh</code> parameter, you must have the <code>maintenance</code> or <code>manage</code> index privilege.
</p>
</li></ul>
<p>
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
The actions are specified in the request body using a newline delimited JSON (NDJSON) structure:
</p>
<pre><code class="lang-csharp">action_and_meta_data\n
optional_source\n
action_and_meta_data\n
optional_source\n
....
action_and_meta_data\n
optional_source\n</code></pre>
<p>
The <code>index</code> and <code>create</code> actions expect a source on the next line and have the same semantics as the <code>op_type</code> parameter in the standard index API.
A <code>create</code> action fails if a document with the same ID already exists in the target
An <code>index</code> action adds or replaces a document as necessary.
</p>
<p>
NOTE: Data streams support only the <code>create</code> action.
To update or delete a document in a data stream, you must target the backing index containing the document.
</p>
<p>
An <code>update</code> action expects that the partial doc, upsert, and script and its options are specified on the next line.
</p>
<p>
A <code>delete</code> action does not expect a source on the next line and has the same semantics as the standard delete API.
</p>
<p>
NOTE: The final line of data must end with a newline character (<code>\n</code>).
Each newline character may be preceded by a carriage return (<code>\r</code>).
When sending NDJSON data to the <code>_bulk</code> endpoint, use a <code>Content-Type</code> header of <code>application/json</code> or <code>application/x-ndjson</code>.
Because this format uses literal newline characters (<code>\n</code>) as delimiters, make sure that the JSON actions and sources are not pretty printed.
</p>
<p>
If you provide a target in the request path, it is used for any actions that don't explicitly specify an <code>_index</code> argument.
</p>
<p>
A note on the format: the idea here is to make processing as fast as possible.
As some of the actions are redirected to other shards on other nodes, only <code>action_meta_data</code> is parsed on the receiving node side.
</p>
<p>
Client libraries using this protocol should try and strive to do something similar on the client side, and reduce buffering as much as possible.
</p>
<p>
There is no "correct" number of actions to perform in a single bulk request.
Experiment with different settings to find the optimal size for your particular workload.
Note that Elasticsearch limits the maximum size of a HTTP request to 100mb by default so clients must ensure that no request exceeds this size.
It is not possible to index a single document that exceeds the size limit, so you must pre-process any such documents into smaller pieces before sending them to Elasticsearch.
For instance, split documents into pages or chapters before indexing them, or store raw binary data in a system outside Elasticsearch and replace the raw data with a link to the external system in the documents that you send to Elasticsearch.
</p>
<p>
<strong>Client suppport for bulk requests</strong>
</p>
<p>
Some of the officially supported clients provide helpers to assist with bulk requests and reindexing:
</p>
<ul><li>
<p>
Go: Check out <code>esutil.BulkIndexer</code>
</p>
</li><li>
<p>
Perl: Check out <code>Search::Elasticsearch::Client::5_0::Bulk</code> and <code>Search::Elasticsearch::Client::5_0::Scroll</code>
</p>
</li><li>
<p>
Python: Check out <code>elasticsearch.helpers.*</code>
</p>
</li><li>
<p>
JavaScript: Check out <code>client.helpers.*</code>
</p>
</li><li>
<p>
.NET: Check out <code>BulkAllObservable</code>
</p>
</li><li>
<p>
PHP: Check out bulk indexing.
</p>
</li></ul>
<p>
<strong>Submitting bulk requests with cURL</strong>
</p>
<p>
If you're providing text file input to <code>curl</code>, you must use the <code>--data-binary</code> flag instead of plain <code>-d</code>.
The latter doesn't preserve newlines. For example:
</p>
<pre><code class="lang-csharp">$ cat requests
{ "index" : { "_index" : "test", "_id" : "1" } }
{ "field1" : "value1" }
$ curl -s -H "Content-Type: application/x-ndjson" -XPOST localhost:9200/_bulk --data-binary "@requests"; echo
{"took":7, "errors": false, "items":[{"index":{"_index":"test","_id":"1","_version":1,"result":"created","forced_refresh":false}}]}</code></pre>
<p>
<strong>Optimistic concurrency control</strong>
</p>
<p>
Each <code>index</code> and <code>delete</code> action within a bulk API call may include the <code>if_seq_no</code> and <code>if_primary_term</code> parameters in their respective action and meta data lines.
The <code>if_seq_no</code> and <code>if_primary_term</code> parameters control how operations are run, based on the last modification to existing documents. See Optimistic concurrency control for more details.
</p>
<p>
<strong>Versioning</strong>
</p>
<p>
Each bulk item can include the version value using the <code>version</code> field.
It automatically follows the behavior of the index or delete operation based on the <code>_version</code> mapping.
It also support the <code>version_type</code>.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
Each bulk item can include the routing value using the <code>routing</code> field.
It automatically follows the behavior of the index or delete operation based on the <code>_routing</code> mapping.
</p>
<p>
NOTE: Data streams do not support custom routing unless they were created with the <code>allow_custom_routing</code> setting enabled in the template.
</p>
<p>
<strong>Wait for active shards</strong>
</p>
<p>
When making bulk calls, you can set the <code>wait_for_active_shards</code> parameter to require a minimum number of shard copies to be active before starting to process the bulk request.
</p>
<p>
<strong>Refresh</strong>
</p>
<p>
Control when the changes made by this request are visible to search.
</p>
<p>
NOTE: Only the shards that receive the bulk request will be affected by refresh.
Imagine a <code>_bulk?refresh=wait_for</code> request with three documents in it that happen to be routed to different shards in an index with five shards.
The request will only wait for those three shards to refresh.
The other two shards that make up the index do not participate in the <code>_bulk</code> request at all.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-bulk.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual BulkResponse Bulk&lt;TDocument&gt;(Action&lt;BulkRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.BulkRequestDescriptor-1.html">BulkRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.BulkResponse.html">BulkResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ClearScroll_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ClearScroll*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ClearScroll" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ClearScroll">
  ClearScroll()
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L4541"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Clear a scrolling search.
Clear the search context and results for a scrolling search.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/clear-scroll-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual ClearScrollResponse ClearScroll()</code></pre>
  </div>


  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ClearScrollResponse.html">ClearScrollResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ClearScroll_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ClearScroll*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ClearScroll_Elastic_Clients_Elasticsearch_ClearScrollRequest_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ClearScroll(Elastic.Clients.Elasticsearch.ClearScrollRequest)">
  ClearScroll(ClearScrollRequest)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L4500"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Clear a scrolling search.
Clear the search context and results for a scrolling search.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/clear-scroll-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual ClearScrollResponse ClearScroll(ClearScrollRequest request)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.ClearScrollRequest.html">ClearScrollRequest</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ClearScrollResponse.html">ClearScrollResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ClearScroll_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ClearScroll*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ClearScroll_Elastic_Clients_Elasticsearch_ClearScrollRequestDescriptor_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ClearScroll(Elastic.Clients.Elasticsearch.ClearScrollRequestDescriptor)">
  ClearScroll(ClearScrollRequestDescriptor)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L4527"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Clear a scrolling search.
Clear the search context and results for a scrolling search.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/clear-scroll-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual ClearScrollResponse ClearScroll(ClearScrollRequestDescriptor descriptor)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.ClearScrollRequestDescriptor.html">ClearScrollRequestDescriptor</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ClearScrollResponse.html">ClearScrollResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ClearScroll_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ClearScroll*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ClearScroll_System_Action_Elastic_Clients_Elasticsearch_ClearScrollRequestDescriptor__" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ClearScroll(System.Action{Elastic.Clients.Elasticsearch.ClearScrollRequestDescriptor})">
  ClearScroll(Action&lt;ClearScrollRequestDescriptor&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L4556"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Clear a scrolling search.
Clear the search context and results for a scrolling search.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/clear-scroll-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual ClearScrollResponse ClearScroll(Action&lt;ClearScrollRequestDescriptor&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ClearScrollRequestDescriptor.html">ClearScrollRequestDescriptor</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ClearScrollResponse.html">ClearScrollResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ClearScrollAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ClearScrollAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ClearScrollAsync_Elastic_Clients_Elasticsearch_ClearScrollRequest_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ClearScrollAsync(Elastic.Clients.Elasticsearch.ClearScrollRequest,System.Threading.CancellationToken)">
  ClearScrollAsync(ClearScrollRequest, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L4514"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Clear a scrolling search.
Clear the search context and results for a scrolling search.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/clear-scroll-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;ClearScrollResponse&gt; ClearScrollAsync(ClearScrollRequest request, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.ClearScrollRequest.html">ClearScrollRequest</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ClearScrollResponse.html">ClearScrollResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ClearScrollAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ClearScrollAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ClearScrollAsync_Elastic_Clients_Elasticsearch_ClearScrollRequestDescriptor_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ClearScrollAsync(Elastic.Clients.Elasticsearch.ClearScrollRequestDescriptor,System.Threading.CancellationToken)">
  ClearScrollAsync(ClearScrollRequestDescriptor, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L4572"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Clear a scrolling search.
Clear the search context and results for a scrolling search.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/clear-scroll-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;ClearScrollResponse&gt; ClearScrollAsync(ClearScrollRequestDescriptor descriptor, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.ClearScrollRequestDescriptor.html">ClearScrollRequestDescriptor</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ClearScrollResponse.html">ClearScrollResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ClearScrollAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ClearScrollAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ClearScrollAsync_System_Action_Elastic_Clients_Elasticsearch_ClearScrollRequestDescriptor__System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ClearScrollAsync(System.Action{Elastic.Clients.Elasticsearch.ClearScrollRequestDescriptor},System.Threading.CancellationToken)">
  ClearScrollAsync(Action&lt;ClearScrollRequestDescriptor&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L4599"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Clear a scrolling search.
Clear the search context and results for a scrolling search.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/clear-scroll-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;ClearScrollResponse&gt; ClearScrollAsync(Action&lt;ClearScrollRequestDescriptor&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ClearScrollRequestDescriptor.html">ClearScrollRequestDescriptor</a>&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ClearScrollResponse.html">ClearScrollResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ClearScrollAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ClearScrollAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ClearScrollAsync_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ClearScrollAsync(System.Threading.CancellationToken)">
  ClearScrollAsync(CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L4585"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Clear a scrolling search.
Clear the search context and results for a scrolling search.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/clear-scroll-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;ClearScrollResponse&gt; ClearScrollAsync(CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ClearScrollResponse.html">ClearScrollResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ClosePointInTime_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ClosePointInTime*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ClosePointInTime" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ClosePointInTime">
  ClosePointInTime()
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L4667"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Close a point in time.
A point in time must be opened explicitly before being used in search requests.
The <code>keep_alive</code> parameter tells Elasticsearch how long it should persist.
A point in time is automatically closed when the <code>keep_alive</code> period has elapsed.
However, keeping points in time has a cost; close them as soon as they are no longer required for search requests.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/point-in-time-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual ClosePointInTimeResponse ClosePointInTime()</code></pre>
  </div>


  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ClosePointInTimeResponse.html">ClosePointInTimeResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ClosePointInTime_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ClosePointInTime*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ClosePointInTime_Elastic_Clients_Elasticsearch_ClosePointInTimeRequest_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ClosePointInTime(Elastic.Clients.Elasticsearch.ClosePointInTimeRequest)">
  ClosePointInTime(ClosePointInTimeRequest)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L4617"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Close a point in time.
A point in time must be opened explicitly before being used in search requests.
The <code>keep_alive</code> parameter tells Elasticsearch how long it should persist.
A point in time is automatically closed when the <code>keep_alive</code> period has elapsed.
However, keeping points in time has a cost; close them as soon as they are no longer required for search requests.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/point-in-time-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual ClosePointInTimeResponse ClosePointInTime(ClosePointInTimeRequest request)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.ClosePointInTimeRequest.html">ClosePointInTimeRequest</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ClosePointInTimeResponse.html">ClosePointInTimeResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ClosePointInTime_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ClosePointInTime*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ClosePointInTime_Elastic_Clients_Elasticsearch_ClosePointInTimeRequestDescriptor_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ClosePointInTime(Elastic.Clients.Elasticsearch.ClosePointInTimeRequestDescriptor)">
  ClosePointInTime(ClosePointInTimeRequestDescriptor)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L4650"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Close a point in time.
A point in time must be opened explicitly before being used in search requests.
The <code>keep_alive</code> parameter tells Elasticsearch how long it should persist.
A point in time is automatically closed when the <code>keep_alive</code> period has elapsed.
However, keeping points in time has a cost; close them as soon as they are no longer required for search requests.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/point-in-time-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual ClosePointInTimeResponse ClosePointInTime(ClosePointInTimeRequestDescriptor descriptor)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.ClosePointInTimeRequestDescriptor.html">ClosePointInTimeRequestDescriptor</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ClosePointInTimeResponse.html">ClosePointInTimeResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ClosePointInTime_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ClosePointInTime*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ClosePointInTime_System_Action_Elastic_Clients_Elasticsearch_ClosePointInTimeRequestDescriptor__" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ClosePointInTime(System.Action{Elastic.Clients.Elasticsearch.ClosePointInTimeRequestDescriptor})">
  ClosePointInTime(Action&lt;ClosePointInTimeRequestDescriptor&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L4685"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Close a point in time.
A point in time must be opened explicitly before being used in search requests.
The <code>keep_alive</code> parameter tells Elasticsearch how long it should persist.
A point in time is automatically closed when the <code>keep_alive</code> period has elapsed.
However, keeping points in time has a cost; close them as soon as they are no longer required for search requests.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/point-in-time-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual ClosePointInTimeResponse ClosePointInTime(Action&lt;ClosePointInTimeRequestDescriptor&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ClosePointInTimeRequestDescriptor.html">ClosePointInTimeRequestDescriptor</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ClosePointInTimeResponse.html">ClosePointInTimeResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ClosePointInTimeAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ClosePointInTimeAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ClosePointInTimeAsync_Elastic_Clients_Elasticsearch_ClosePointInTimeRequest_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ClosePointInTimeAsync(Elastic.Clients.Elasticsearch.ClosePointInTimeRequest,System.Threading.CancellationToken)">
  ClosePointInTimeAsync(ClosePointInTimeRequest, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L4634"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Close a point in time.
A point in time must be opened explicitly before being used in search requests.
The <code>keep_alive</code> parameter tells Elasticsearch how long it should persist.
A point in time is automatically closed when the <code>keep_alive</code> period has elapsed.
However, keeping points in time has a cost; close them as soon as they are no longer required for search requests.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/point-in-time-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;ClosePointInTimeResponse&gt; ClosePointInTimeAsync(ClosePointInTimeRequest request, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.ClosePointInTimeRequest.html">ClosePointInTimeRequest</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ClosePointInTimeResponse.html">ClosePointInTimeResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ClosePointInTimeAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ClosePointInTimeAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ClosePointInTimeAsync_Elastic_Clients_Elasticsearch_ClosePointInTimeRequestDescriptor_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ClosePointInTimeAsync(Elastic.Clients.Elasticsearch.ClosePointInTimeRequestDescriptor,System.Threading.CancellationToken)">
  ClosePointInTimeAsync(ClosePointInTimeRequestDescriptor, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L4704"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Close a point in time.
A point in time must be opened explicitly before being used in search requests.
The <code>keep_alive</code> parameter tells Elasticsearch how long it should persist.
A point in time is automatically closed when the <code>keep_alive</code> period has elapsed.
However, keeping points in time has a cost; close them as soon as they are no longer required for search requests.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/point-in-time-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;ClosePointInTimeResponse&gt; ClosePointInTimeAsync(ClosePointInTimeRequestDescriptor descriptor, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.ClosePointInTimeRequestDescriptor.html">ClosePointInTimeRequestDescriptor</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ClosePointInTimeResponse.html">ClosePointInTimeResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ClosePointInTimeAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ClosePointInTimeAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ClosePointInTimeAsync_System_Action_Elastic_Clients_Elasticsearch_ClosePointInTimeRequestDescriptor__System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ClosePointInTimeAsync(System.Action{Elastic.Clients.Elasticsearch.ClosePointInTimeRequestDescriptor},System.Threading.CancellationToken)">
  ClosePointInTimeAsync(Action&lt;ClosePointInTimeRequestDescriptor&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L4737"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Close a point in time.
A point in time must be opened explicitly before being used in search requests.
The <code>keep_alive</code> parameter tells Elasticsearch how long it should persist.
A point in time is automatically closed when the <code>keep_alive</code> period has elapsed.
However, keeping points in time has a cost; close them as soon as they are no longer required for search requests.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/point-in-time-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;ClosePointInTimeResponse&gt; ClosePointInTimeAsync(Action&lt;ClosePointInTimeRequestDescriptor&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ClosePointInTimeRequestDescriptor.html">ClosePointInTimeRequestDescriptor</a>&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ClosePointInTimeResponse.html">ClosePointInTimeResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ClosePointInTimeAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ClosePointInTimeAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ClosePointInTimeAsync_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ClosePointInTimeAsync(System.Threading.CancellationToken)">
  ClosePointInTimeAsync(CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L4720"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Close a point in time.
A point in time must be opened explicitly before being used in search requests.
The <code>keep_alive</code> parameter tells Elasticsearch how long it should persist.
A point in time is automatically closed when the <code>keep_alive</code> period has elapsed.
However, keeping points in time has a cost; close them as soon as they are no longer required for search requests.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/point-in-time-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;ClosePointInTimeResponse&gt; ClosePointInTimeAsync(CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ClosePointInTimeResponse.html">ClosePointInTimeResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Count_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Count*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Count" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Count">
  Count()
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L5032"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Count search results.
Get the number of documents matching a query.
</p>
<p>
The query can be provided either by using a simple query string as a parameter, or by defining Query DSL within the request body.
The query is optional. When no query is provided, the API uses <code>match_all</code> to count all the documents.
</p>
<p>
The count API supports multi-target syntax. You can run a single count API search across multiple data streams and indices.
</p>
<p>
The operation is broadcast across all shards.
For each shard ID group, a replica is chosen and the search is run against it.
This means that replicas increase the scalability of the count.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-count.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual CountResponse Count()</code></pre>
  </div>


  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.CountResponse.html">CountResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Count_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Count*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Count_Elastic_Clients_Elasticsearch_CountRequest_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Count(Elastic.Clients.Elasticsearch.CountRequest)">
  Count(CountRequest)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L4764"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Count search results.
Get the number of documents matching a query.
</p>
<p>
The query can be provided either by using a simple query string as a parameter, or by defining Query DSL within the request body.
The query is optional. When no query is provided, the API uses <code>match_all</code> to count all the documents.
</p>
<p>
The count API supports multi-target syntax. You can run a single count API search across multiple data streams and indices.
</p>
<p>
The operation is broadcast across all shards.
For each shard ID group, a replica is chosen and the search is run against it.
This means that replicas increase the scalability of the count.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-count.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual CountResponse Count(CountRequest request)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.CountRequest.html">CountRequest</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.CountResponse.html">CountResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Count_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Count*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Count_Elastic_Clients_Elasticsearch_CountRequestDescriptor_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Count(Elastic.Clients.Elasticsearch.CountRequestDescriptor)">
  Count(CountRequestDescriptor)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L4951"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Count search results.
Get the number of documents matching a query.
</p>
<p>
The query can be provided either by using a simple query string as a parameter, or by defining Query DSL within the request body.
The query is optional. When no query is provided, the API uses <code>match_all</code> to count all the documents.
</p>
<p>
The count API supports multi-target syntax. You can run a single count API search across multiple data streams and indices.
</p>
<p>
The operation is broadcast across all shards.
For each shard ID group, a replica is chosen and the search is run against it.
This means that replicas increase the scalability of the count.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-count.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual CountResponse Count(CountRequestDescriptor descriptor)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.CountRequestDescriptor.html">CountRequestDescriptor</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.CountResponse.html">CountResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Count_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Count*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Count_Elastic_Clients_Elasticsearch_Indices_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Count(Elastic.Clients.Elasticsearch.Indices)">
  Count(Indices?)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L4977"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Count search results.
Get the number of documents matching a query.
</p>
<p>
The query can be provided either by using a simple query string as a parameter, or by defining Query DSL within the request body.
The query is optional. When no query is provided, the API uses <code>match_all</code> to count all the documents.
</p>
<p>
The count API supports multi-target syntax. You can run a single count API search across multiple data streams and indices.
</p>
<p>
The operation is broadcast across all shards.
For each shard ID group, a replica is chosen and the search is run against it.
This means that replicas increase the scalability of the count.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-count.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual CountResponse Count(Indices? indices)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>indices</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Indices.html">Indices</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.CountResponse.html">CountResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Count_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Count*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Count_Elastic_Clients_Elasticsearch_Indices_System_Action_Elastic_Clients_Elasticsearch_CountRequestDescriptor__" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Count(Elastic.Clients.Elasticsearch.Indices,System.Action{Elastic.Clients.Elasticsearch.CountRequestDescriptor})">
  Count(Indices?, Action&lt;CountRequestDescriptor&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L5004"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Count search results.
Get the number of documents matching a query.
</p>
<p>
The query can be provided either by using a simple query string as a parameter, or by defining Query DSL within the request body.
The query is optional. When no query is provided, the API uses <code>match_all</code> to count all the documents.
</p>
<p>
The count API supports multi-target syntax. You can run a single count API search across multiple data streams and indices.
</p>
<p>
The operation is broadcast across all shards.
For each shard ID group, a replica is chosen and the search is run against it.
This means that replicas increase the scalability of the count.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-count.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual CountResponse Count(Indices? indices, Action&lt;CountRequestDescriptor&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>indices</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Indices.html">Indices</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.CountRequestDescriptor.html">CountRequestDescriptor</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.CountResponse.html">CountResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Count_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Count*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Count_System_Action_Elastic_Clients_Elasticsearch_CountRequestDescriptor__" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Count(System.Action{Elastic.Clients.Elasticsearch.CountRequestDescriptor})">
  Count(Action&lt;CountRequestDescriptor&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L5059"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Count search results.
Get the number of documents matching a query.
</p>
<p>
The query can be provided either by using a simple query string as a parameter, or by defining Query DSL within the request body.
The query is optional. When no query is provided, the API uses <code>match_all</code> to count all the documents.
</p>
<p>
The count API supports multi-target syntax. You can run a single count API search across multiple data streams and indices.
</p>
<p>
The operation is broadcast across all shards.
For each shard ID group, a replica is chosen and the search is run against it.
This means that replicas increase the scalability of the count.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-count.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual CountResponse Count(Action&lt;CountRequestDescriptor&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.CountRequestDescriptor.html">CountRequestDescriptor</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.CountResponse.html">CountResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_CountAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.CountAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_CountAsync_Elastic_Clients_Elasticsearch_CountRequest_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.CountAsync(Elastic.Clients.Elasticsearch.CountRequest,System.Threading.CancellationToken)">
  CountAsync(CountRequest, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L4790"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Count search results.
Get the number of documents matching a query.
</p>
<p>
The query can be provided either by using a simple query string as a parameter, or by defining Query DSL within the request body.
The query is optional. When no query is provided, the API uses <code>match_all</code> to count all the documents.
</p>
<p>
The count API supports multi-target syntax. You can run a single count API search across multiple data streams and indices.
</p>
<p>
The operation is broadcast across all shards.
For each shard ID group, a replica is chosen and the search is run against it.
This means that replicas increase the scalability of the count.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-count.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;CountResponse&gt; CountAsync(CountRequest request, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.CountRequest.html">CountRequest</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.CountResponse.html">CountResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_CountAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.CountAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_CountAsync_Elastic_Clients_Elasticsearch_CountRequestDescriptor_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.CountAsync(Elastic.Clients.Elasticsearch.CountRequestDescriptor,System.Threading.CancellationToken)">
  CountAsync(CountRequestDescriptor, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L5218"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Count search results.
Get the number of documents matching a query.
</p>
<p>
The query can be provided either by using a simple query string as a parameter, or by defining Query DSL within the request body.
The query is optional. When no query is provided, the API uses <code>match_all</code> to count all the documents.
</p>
<p>
The count API supports multi-target syntax. You can run a single count API search across multiple data streams and indices.
</p>
<p>
The operation is broadcast across all shards.
For each shard ID group, a replica is chosen and the search is run against it.
This means that replicas increase the scalability of the count.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-count.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;CountResponse&gt; CountAsync(CountRequestDescriptor descriptor, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.CountRequestDescriptor.html">CountRequestDescriptor</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.CountResponse.html">CountResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_CountAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.CountAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_CountAsync_Elastic_Clients_Elasticsearch_Indices_System_Action_Elastic_Clients_Elasticsearch_CountRequestDescriptor__System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.CountAsync(Elastic.Clients.Elasticsearch.Indices,System.Action{Elastic.Clients.Elasticsearch.CountRequestDescriptor},System.Threading.CancellationToken)">
  CountAsync(Indices?, Action&lt;CountRequestDescriptor&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L5269"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Count search results.
Get the number of documents matching a query.
</p>
<p>
The query can be provided either by using a simple query string as a parameter, or by defining Query DSL within the request body.
The query is optional. When no query is provided, the API uses <code>match_all</code> to count all the documents.
</p>
<p>
The count API supports multi-target syntax. You can run a single count API search across multiple data streams and indices.
</p>
<p>
The operation is broadcast across all shards.
For each shard ID group, a replica is chosen and the search is run against it.
This means that replicas increase the scalability of the count.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-count.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;CountResponse&gt; CountAsync(Indices? indices, Action&lt;CountRequestDescriptor&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>indices</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Indices.html">Indices</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.CountRequestDescriptor.html">CountRequestDescriptor</a>&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.CountResponse.html">CountResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_CountAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.CountAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_CountAsync_Elastic_Clients_Elasticsearch_Indices_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.CountAsync(Elastic.Clients.Elasticsearch.Indices,System.Threading.CancellationToken)">
  CountAsync(Indices?, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L5243"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Count search results.
Get the number of documents matching a query.
</p>
<p>
The query can be provided either by using a simple query string as a parameter, or by defining Query DSL within the request body.
The query is optional. When no query is provided, the API uses <code>match_all</code> to count all the documents.
</p>
<p>
The count API supports multi-target syntax. You can run a single count API search across multiple data streams and indices.
</p>
<p>
The operation is broadcast across all shards.
For each shard ID group, a replica is chosen and the search is run against it.
This means that replicas increase the scalability of the count.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-count.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;CountResponse&gt; CountAsync(Indices? indices, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>indices</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Indices.html">Indices</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.CountResponse.html">CountResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_CountAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.CountAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_CountAsync_System_Action_Elastic_Clients_Elasticsearch_CountRequestDescriptor__System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.CountAsync(System.Action{Elastic.Clients.Elasticsearch.CountRequestDescriptor},System.Threading.CancellationToken)">
  CountAsync(Action&lt;CountRequestDescriptor&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L5322"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Count search results.
Get the number of documents matching a query.
</p>
<p>
The query can be provided either by using a simple query string as a parameter, or by defining Query DSL within the request body.
The query is optional. When no query is provided, the API uses <code>match_all</code> to count all the documents.
</p>
<p>
The count API supports multi-target syntax. You can run a single count API search across multiple data streams and indices.
</p>
<p>
The operation is broadcast across all shards.
For each shard ID group, a replica is chosen and the search is run against it.
This means that replicas increase the scalability of the count.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-count.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;CountResponse&gt; CountAsync(Action&lt;CountRequestDescriptor&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.CountRequestDescriptor.html">CountRequestDescriptor</a>&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.CountResponse.html">CountResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_CountAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.CountAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_CountAsync_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.CountAsync(System.Threading.CancellationToken)">
  CountAsync(CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L5296"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Count search results.
Get the number of documents matching a query.
</p>
<p>
The query can be provided either by using a simple query string as a parameter, or by defining Query DSL within the request body.
The query is optional. When no query is provided, the API uses <code>match_all</code> to count all the documents.
</p>
<p>
The count API supports multi-target syntax. You can run a single count API search across multiple data streams and indices.
</p>
<p>
The operation is broadcast across all shards.
For each shard ID group, a replica is chosen and the search is run against it.
This means that replicas increase the scalability of the count.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-count.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;CountResponse&gt; CountAsync(CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.CountResponse.html">CountResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_CountAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.CountAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_CountAsync__1_Elastic_Clients_Elasticsearch_CountRequestDescriptor___0__System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.CountAsync``1(Elastic.Clients.Elasticsearch.CountRequestDescriptor{``0},System.Threading.CancellationToken)">
  CountAsync&lt;TDocument&gt;(CountRequestDescriptor&lt;TDocument&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L5087"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Count search results.
Get the number of documents matching a query.
</p>
<p>
The query can be provided either by using a simple query string as a parameter, or by defining Query DSL within the request body.
The query is optional. When no query is provided, the API uses <code>match_all</code> to count all the documents.
</p>
<p>
The count API supports multi-target syntax. You can run a single count API search across multiple data streams and indices.
</p>
<p>
The operation is broadcast across all shards.
For each shard ID group, a replica is chosen and the search is run against it.
This means that replicas increase the scalability of the count.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-count.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;CountResponse&gt; CountAsync&lt;TDocument&gt;(CountRequestDescriptor&lt;TDocument&gt; descriptor, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.CountRequestDescriptor-1.html">CountRequestDescriptor</a>&lt;TDocument&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.CountResponse.html">CountResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_CountAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.CountAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_CountAsync__1_Elastic_Clients_Elasticsearch_Indices_System_Action_Elastic_Clients_Elasticsearch_CountRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.CountAsync``1(Elastic.Clients.Elasticsearch.Indices,System.Action{Elastic.Clients.Elasticsearch.CountRequestDescriptor{``0}},System.Threading.CancellationToken)">
  CountAsync&lt;TDocument&gt;(Indices?, Action&lt;CountRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L5138"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Count search results.
Get the number of documents matching a query.
</p>
<p>
The query can be provided either by using a simple query string as a parameter, or by defining Query DSL within the request body.
The query is optional. When no query is provided, the API uses <code>match_all</code> to count all the documents.
</p>
<p>
The count API supports multi-target syntax. You can run a single count API search across multiple data streams and indices.
</p>
<p>
The operation is broadcast across all shards.
For each shard ID group, a replica is chosen and the search is run against it.
This means that replicas increase the scalability of the count.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-count.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;CountResponse&gt; CountAsync&lt;TDocument&gt;(Indices? indices, Action&lt;CountRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>indices</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Indices.html">Indices</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.CountRequestDescriptor-1.html">CountRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.CountResponse.html">CountResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_CountAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.CountAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_CountAsync__1_Elastic_Clients_Elasticsearch_Indices_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.CountAsync``1(Elastic.Clients.Elasticsearch.Indices,System.Threading.CancellationToken)">
  CountAsync&lt;TDocument&gt;(Indices?, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L5112"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Count search results.
Get the number of documents matching a query.
</p>
<p>
The query can be provided either by using a simple query string as a parameter, or by defining Query DSL within the request body.
The query is optional. When no query is provided, the API uses <code>match_all</code> to count all the documents.
</p>
<p>
The count API supports multi-target syntax. You can run a single count API search across multiple data streams and indices.
</p>
<p>
The operation is broadcast across all shards.
For each shard ID group, a replica is chosen and the search is run against it.
This means that replicas increase the scalability of the count.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-count.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;CountResponse&gt; CountAsync&lt;TDocument&gt;(Indices? indices, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>indices</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Indices.html">Indices</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.CountResponse.html">CountResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_CountAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.CountAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_CountAsync__1_System_Action_Elastic_Clients_Elasticsearch_CountRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.CountAsync``1(System.Action{Elastic.Clients.Elasticsearch.CountRequestDescriptor{``0}},System.Threading.CancellationToken)">
  CountAsync&lt;TDocument&gt;(Action&lt;CountRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L5191"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Count search results.
Get the number of documents matching a query.
</p>
<p>
The query can be provided either by using a simple query string as a parameter, or by defining Query DSL within the request body.
The query is optional. When no query is provided, the API uses <code>match_all</code> to count all the documents.
</p>
<p>
The count API supports multi-target syntax. You can run a single count API search across multiple data streams and indices.
</p>
<p>
The operation is broadcast across all shards.
For each shard ID group, a replica is chosen and the search is run against it.
This means that replicas increase the scalability of the count.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-count.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;CountResponse&gt; CountAsync&lt;TDocument&gt;(Action&lt;CountRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.CountRequestDescriptor-1.html">CountRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.CountResponse.html">CountResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_CountAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.CountAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_CountAsync__1_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.CountAsync``1(System.Threading.CancellationToken)">
  CountAsync&lt;TDocument&gt;(CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L5165"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Count search results.
Get the number of documents matching a query.
</p>
<p>
The query can be provided either by using a simple query string as a parameter, or by defining Query DSL within the request body.
The query is optional. When no query is provided, the API uses <code>match_all</code> to count all the documents.
</p>
<p>
The count API supports multi-target syntax. You can run a single count API search across multiple data streams and indices.
</p>
<p>
The operation is broadcast across all shards.
For each shard ID group, a replica is chosen and the search is run against it.
This means that replicas increase the scalability of the count.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-count.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;CountResponse&gt; CountAsync&lt;TDocument&gt;(CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.CountResponse.html">CountResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Count_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Count*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Count__1" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Count``1">
  Count&lt;TDocument&gt;()
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L4896"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Count search results.
Get the number of documents matching a query.
</p>
<p>
The query can be provided either by using a simple query string as a parameter, or by defining Query DSL within the request body.
The query is optional. When no query is provided, the API uses <code>match_all</code> to count all the documents.
</p>
<p>
The count API supports multi-target syntax. You can run a single count API search across multiple data streams and indices.
</p>
<p>
The operation is broadcast across all shards.
For each shard ID group, a replica is chosen and the search is run against it.
This means that replicas increase the scalability of the count.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-count.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual CountResponse Count&lt;TDocument&gt;()</code></pre>
  </div>


  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.CountResponse.html">CountResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Count_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Count*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Count__1_Elastic_Clients_Elasticsearch_CountRequestDescriptor___0__" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Count``1(Elastic.Clients.Elasticsearch.CountRequestDescriptor{``0})">
  Count&lt;TDocument&gt;(CountRequestDescriptor&lt;TDocument&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L4815"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Count search results.
Get the number of documents matching a query.
</p>
<p>
The query can be provided either by using a simple query string as a parameter, or by defining Query DSL within the request body.
The query is optional. When no query is provided, the API uses <code>match_all</code> to count all the documents.
</p>
<p>
The count API supports multi-target syntax. You can run a single count API search across multiple data streams and indices.
</p>
<p>
The operation is broadcast across all shards.
For each shard ID group, a replica is chosen and the search is run against it.
This means that replicas increase the scalability of the count.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-count.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual CountResponse Count&lt;TDocument&gt;(CountRequestDescriptor&lt;TDocument&gt; descriptor)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.CountRequestDescriptor-1.html">CountRequestDescriptor</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.CountResponse.html">CountResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Count_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Count*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Count__1_Elastic_Clients_Elasticsearch_Indices_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Count``1(Elastic.Clients.Elasticsearch.Indices)">
  Count&lt;TDocument&gt;(Indices?)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L4841"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Count search results.
Get the number of documents matching a query.
</p>
<p>
The query can be provided either by using a simple query string as a parameter, or by defining Query DSL within the request body.
The query is optional. When no query is provided, the API uses <code>match_all</code> to count all the documents.
</p>
<p>
The count API supports multi-target syntax. You can run a single count API search across multiple data streams and indices.
</p>
<p>
The operation is broadcast across all shards.
For each shard ID group, a replica is chosen and the search is run against it.
This means that replicas increase the scalability of the count.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-count.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual CountResponse Count&lt;TDocument&gt;(Indices? indices)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>indices</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Indices.html">Indices</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.CountResponse.html">CountResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Count_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Count*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Count__1_Elastic_Clients_Elasticsearch_Indices_System_Action_Elastic_Clients_Elasticsearch_CountRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Count``1(Elastic.Clients.Elasticsearch.Indices,System.Action{Elastic.Clients.Elasticsearch.CountRequestDescriptor{``0}})">
  Count&lt;TDocument&gt;(Indices?, Action&lt;CountRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L4868"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Count search results.
Get the number of documents matching a query.
</p>
<p>
The query can be provided either by using a simple query string as a parameter, or by defining Query DSL within the request body.
The query is optional. When no query is provided, the API uses <code>match_all</code> to count all the documents.
</p>
<p>
The count API supports multi-target syntax. You can run a single count API search across multiple data streams and indices.
</p>
<p>
The operation is broadcast across all shards.
For each shard ID group, a replica is chosen and the search is run against it.
This means that replicas increase the scalability of the count.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-count.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual CountResponse Count&lt;TDocument&gt;(Indices? indices, Action&lt;CountRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>indices</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Indices.html">Indices</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.CountRequestDescriptor-1.html">CountRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.CountResponse.html">CountResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Count_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Count*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Count__1_System_Action_Elastic_Clients_Elasticsearch_CountRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Count``1(System.Action{Elastic.Clients.Elasticsearch.CountRequestDescriptor{``0}})">
  Count&lt;TDocument&gt;(Action&lt;CountRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L4923"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Count search results.
Get the number of documents matching a query.
</p>
<p>
The query can be provided either by using a simple query string as a parameter, or by defining Query DSL within the request body.
The query is optional. When no query is provided, the API uses <code>match_all</code> to count all the documents.
</p>
<p>
The count API supports multi-target syntax. You can run a single count API search across multiple data streams and indices.
</p>
<p>
The operation is broadcast across all shards.
For each shard ID group, a replica is chosen and the search is run against it.
This means that replicas increase the scalability of the count.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-count.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual CountResponse Count&lt;TDocument&gt;(Action&lt;CountRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.CountRequestDescriptor-1.html">CountRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.CountResponse.html">CountResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_CreateAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.CreateAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_CreateAsync__1_Elastic_Clients_Elasticsearch_CreateRequestDescriptor___0__System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.CreateAsync``1(Elastic.Clients.Elasticsearch.CreateRequestDescriptor{``0},System.Threading.CancellationToken)">
  CreateAsync&lt;TDocument&gt;(CreateRequestDescriptor&lt;TDocument&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L6702"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Create a new document in the index.
</p>
<p>
You can index a new JSON document with the <code>/&lt;target&gt;/_doc/</code> or <code>/&lt;target&gt;/_create/&lt;_id&gt;</code> APIs
Using <code>_create</code> guarantees that the document is indexed only if it does not already exist.
It returns a 409 response when a document with a same ID already exists in the index.
To update an existing document, you must use the <code>/&lt;target&gt;/_doc/</code> API.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or index alias:
</p>
<ul><li>
<p>
To add a document using the <code>PUT /&lt;target&gt;/_create/&lt;_id&gt;</code> or <code>POST /&lt;target&gt;/_create/&lt;_id&gt;</code> request formats, you must have the <code>create_doc</code>, <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To automatically create a data stream or index with this API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege.
</p>
</li></ul>
<p>
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
<strong>Automatically create data streams and indices</strong>
</p>
<p>
If the request's target doesn't exist and matches an index template with a <code>data_stream</code> definition, the index operation automatically creates the data stream.
</p>
<p>
If the target doesn't exist and doesn't match a data stream template, the operation automatically creates the index and applies any matching index templates.
</p>
<p>
NOTE: Elasticsearch includes several built-in index templates. To avoid naming collisions with these templates, refer to index pattern documentation.
</p>
<p>
If no mapping exists, the index operation creates a dynamic mapping.
By default, new fields and objects are automatically added to the mapping if needed.
</p>
<p>
Automatic index creation is controlled by the <code>action.auto_create_index</code> setting.
If it is <code>true</code>, any index can be created automatically.
You can modify this setting to explicitly allow or block automatic creation of indices that match specified patterns or set it to <code>false</code> to turn off automatic index creation entirely.
Specify a comma-separated list of patterns you want to allow or prefix each pattern with <code>+</code> or <code>-</code> to indicate whether it should be allowed or blocked.
When a list is specified, the default behaviour is to disallow.
</p>
<p>
NOTE: The <code>action.auto_create_index</code> setting affects the automatic creation of indices only.
It does not affect the creation of data streams.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
By default, shard placement — or routing — is controlled by using a hash of the document's ID value.
For more explicit control, the value fed into the hash function used by the router can be directly specified on a per-operation basis using the <code>routing</code> parameter.
</p>
<p>
When setting up explicit mapping, you can also use the <code>_routing</code> field to direct the index operation to extract the routing value from the document itself.
This does come at the (very minimal) cost of an additional document parsing pass.
If the <code>_routing</code> mapping is defined and set to be required, the index operation will fail if no routing value is provided or extracted.
</p>
<p>
NOTE: Data streams do not support custom routing unless they were created with the <code>allow_custom_routing</code> setting enabled in the template.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The index operation is directed to the primary shard based on its route and performed on the actual node containing this shard.
After the primary shard completes the operation, if needed, the update is distributed to applicable replicas.
</p>
<p>
<strong>Active shards</strong>
</p>
<p>
To improve the resiliency of writes to the system, indexing operations can be configured to wait for a certain number of active shard copies before proceeding with the operation.
If the requisite number of active shard copies are not available, then the write operation must wait and retry, until either the requisite shard copies have started or a timeout occurs.
By default, write operations only wait for the primary shards to be active before proceeding (that is to say <code>wait_for_active_shards</code> is <code>1</code>).
This default can be overridden in the index settings dynamically by setting <code>index.write.wait_for_active_shards</code>.
To alter this behavior per operation, use the <code>wait_for_active_shards request</code> parameter.
</p>
<p>
Valid values are all or any positive integer up to the total number of configured copies per shard in the index (which is <code>number_of_replicas</code>+1).
Specifying a negative value or a number greater than the number of shard copies will throw an error.
</p>
<p>
For example, suppose you have a cluster of three nodes, A, B, and C and you create an index index with the number of replicas set to 3 (resulting in 4 shard copies, one more copy than there are nodes).
If you attempt an indexing operation, by default the operation will only ensure the primary copy of each shard is available before proceeding.
This means that even if B and C went down and A hosted the primary shard copies, the indexing operation would still proceed with only one copy of the data.
If <code>wait_for_active_shards</code> is set on the request to <code>3</code> (and all three nodes are up), the indexing operation will require 3 active shard copies before proceeding.
This requirement should be met because there are 3 active nodes in the cluster, each one holding a copy of the shard.
However, if you set <code>wait_for_active_shards</code> to <code>all</code> (or to <code>4</code>, which is the same in this situation), the indexing operation will not proceed as you do not have all 4 copies of each shard active in the index.
The operation will timeout unless a new node is brought up in the cluster to host the fourth copy of the shard.
</p>
<p>
It is important to note that this setting greatly reduces the chances of the write operation not writing to the requisite number of shard copies, but it does not completely eliminate the possibility, because this check occurs before the write operation starts.
After the write operation is underway, it is still possible for replication to fail on any number of shard copies but still succeed on the primary.
The <code>_shards</code> section of the API response reveals the number of shard copies on which replication succeeded and failed.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-index_.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;CreateResponse&gt; CreateAsync&lt;TDocument&gt;(CreateRequestDescriptor&lt;TDocument&gt; descriptor, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.CreateRequestDescriptor-1.html">CreateRequestDescriptor</a>&lt;TDocument&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.CreateResponse.html">CreateResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_CreateAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.CreateAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_CreateAsync__1_Elastic_Clients_Elasticsearch_CreateRequest___0__System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.CreateAsync``1(Elastic.Clients.Elasticsearch.CreateRequest{``0},System.Threading.CancellationToken)">
  CreateAsync&lt;TDocument&gt;(CreateRequest&lt;TDocument&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L5551"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Create a new document in the index.
</p>
<p>
You can index a new JSON document with the <code>/&lt;target&gt;/_doc/</code> or <code>/&lt;target&gt;/_create/&lt;_id&gt;</code> APIs
Using <code>_create</code> guarantees that the document is indexed only if it does not already exist.
It returns a 409 response when a document with a same ID already exists in the index.
To update an existing document, you must use the <code>/&lt;target&gt;/_doc/</code> API.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or index alias:
</p>
<ul><li>
<p>
To add a document using the <code>PUT /&lt;target&gt;/_create/&lt;_id&gt;</code> or <code>POST /&lt;target&gt;/_create/&lt;_id&gt;</code> request formats, you must have the <code>create_doc</code>, <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To automatically create a data stream or index with this API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege.
</p>
</li></ul>
<p>
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
<strong>Automatically create data streams and indices</strong>
</p>
<p>
If the request's target doesn't exist and matches an index template with a <code>data_stream</code> definition, the index operation automatically creates the data stream.
</p>
<p>
If the target doesn't exist and doesn't match a data stream template, the operation automatically creates the index and applies any matching index templates.
</p>
<p>
NOTE: Elasticsearch includes several built-in index templates. To avoid naming collisions with these templates, refer to index pattern documentation.
</p>
<p>
If no mapping exists, the index operation creates a dynamic mapping.
By default, new fields and objects are automatically added to the mapping if needed.
</p>
<p>
Automatic index creation is controlled by the <code>action.auto_create_index</code> setting.
If it is <code>true</code>, any index can be created automatically.
You can modify this setting to explicitly allow or block automatic creation of indices that match specified patterns or set it to <code>false</code> to turn off automatic index creation entirely.
Specify a comma-separated list of patterns you want to allow or prefix each pattern with <code>+</code> or <code>-</code> to indicate whether it should be allowed or blocked.
When a list is specified, the default behaviour is to disallow.
</p>
<p>
NOTE: The <code>action.auto_create_index</code> setting affects the automatic creation of indices only.
It does not affect the creation of data streams.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
By default, shard placement — or routing — is controlled by using a hash of the document's ID value.
For more explicit control, the value fed into the hash function used by the router can be directly specified on a per-operation basis using the <code>routing</code> parameter.
</p>
<p>
When setting up explicit mapping, you can also use the <code>_routing</code> field to direct the index operation to extract the routing value from the document itself.
This does come at the (very minimal) cost of an additional document parsing pass.
If the <code>_routing</code> mapping is defined and set to be required, the index operation will fail if no routing value is provided or extracted.
</p>
<p>
NOTE: Data streams do not support custom routing unless they were created with the <code>allow_custom_routing</code> setting enabled in the template.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The index operation is directed to the primary shard based on its route and performed on the actual node containing this shard.
After the primary shard completes the operation, if needed, the update is distributed to applicable replicas.
</p>
<p>
<strong>Active shards</strong>
</p>
<p>
To improve the resiliency of writes to the system, indexing operations can be configured to wait for a certain number of active shard copies before proceeding with the operation.
If the requisite number of active shard copies are not available, then the write operation must wait and retry, until either the requisite shard copies have started or a timeout occurs.
By default, write operations only wait for the primary shards to be active before proceeding (that is to say <code>wait_for_active_shards</code> is <code>1</code>).
This default can be overridden in the index settings dynamically by setting <code>index.write.wait_for_active_shards</code>.
To alter this behavior per operation, use the <code>wait_for_active_shards request</code> parameter.
</p>
<p>
Valid values are all or any positive integer up to the total number of configured copies per shard in the index (which is <code>number_of_replicas</code>+1).
Specifying a negative value or a number greater than the number of shard copies will throw an error.
</p>
<p>
For example, suppose you have a cluster of three nodes, A, B, and C and you create an index index with the number of replicas set to 3 (resulting in 4 shard copies, one more copy than there are nodes).
If you attempt an indexing operation, by default the operation will only ensure the primary copy of each shard is available before proceeding.
This means that even if B and C went down and A hosted the primary shard copies, the indexing operation would still proceed with only one copy of the data.
If <code>wait_for_active_shards</code> is set on the request to <code>3</code> (and all three nodes are up), the indexing operation will require 3 active shard copies before proceeding.
This requirement should be met because there are 3 active nodes in the cluster, each one holding a copy of the shard.
However, if you set <code>wait_for_active_shards</code> to <code>all</code> (or to <code>4</code>, which is the same in this situation), the indexing operation will not proceed as you do not have all 4 copies of each shard active in the index.
The operation will timeout unless a new node is brought up in the cluster to host the fourth copy of the shard.
</p>
<p>
It is important to note that this setting greatly reduces the chances of the write operation not writing to the requisite number of shard copies, but it does not completely eliminate the possibility, because this check occurs before the write operation starts.
After the write operation is underway, it is still possible for replication to fail on any number of shard copies but still succeed on the primary.
The <code>_shards</code> section of the API response reveals the number of shard copies on which replication succeeded and failed.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-index_.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;CreateResponse&gt; CreateAsync&lt;TDocument&gt;(CreateRequest&lt;TDocument&gt; request, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.CreateRequest-1.html">CreateRequest</a>&lt;TDocument&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.CreateResponse.html">CreateResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_CreateAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.CreateAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_CreateAsync__1___0_Elastic_Clients_Elasticsearch_Id_System_Action_Elastic_Clients_Elasticsearch_CreateRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.CreateAsync``1(``0,Elastic.Clients.Elasticsearch.Id,System.Action{Elastic.Clients.Elasticsearch.CreateRequestDescriptor{``0}},System.Threading.CancellationToken)">
  CreateAsync&lt;TDocument&gt;(TDocument, Id, Action&lt;CreateRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L7616"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Create a new document in the index.
</p>
<p>
You can index a new JSON document with the <code>/&lt;target&gt;/_doc/</code> or <code>/&lt;target&gt;/_create/&lt;_id&gt;</code> APIs
Using <code>_create</code> guarantees that the document is indexed only if it does not already exist.
It returns a 409 response when a document with a same ID already exists in the index.
To update an existing document, you must use the <code>/&lt;target&gt;/_doc/</code> API.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or index alias:
</p>
<ul><li>
<p>
To add a document using the <code>PUT /&lt;target&gt;/_create/&lt;_id&gt;</code> or <code>POST /&lt;target&gt;/_create/&lt;_id&gt;</code> request formats, you must have the <code>create_doc</code>, <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To automatically create a data stream or index with this API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege.
</p>
</li></ul>
<p>
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
<strong>Automatically create data streams and indices</strong>
</p>
<p>
If the request's target doesn't exist and matches an index template with a <code>data_stream</code> definition, the index operation automatically creates the data stream.
</p>
<p>
If the target doesn't exist and doesn't match a data stream template, the operation automatically creates the index and applies any matching index templates.
</p>
<p>
NOTE: Elasticsearch includes several built-in index templates. To avoid naming collisions with these templates, refer to index pattern documentation.
</p>
<p>
If no mapping exists, the index operation creates a dynamic mapping.
By default, new fields and objects are automatically added to the mapping if needed.
</p>
<p>
Automatic index creation is controlled by the <code>action.auto_create_index</code> setting.
If it is <code>true</code>, any index can be created automatically.
You can modify this setting to explicitly allow or block automatic creation of indices that match specified patterns or set it to <code>false</code> to turn off automatic index creation entirely.
Specify a comma-separated list of patterns you want to allow or prefix each pattern with <code>+</code> or <code>-</code> to indicate whether it should be allowed or blocked.
When a list is specified, the default behaviour is to disallow.
</p>
<p>
NOTE: The <code>action.auto_create_index</code> setting affects the automatic creation of indices only.
It does not affect the creation of data streams.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
By default, shard placement — or routing — is controlled by using a hash of the document's ID value.
For more explicit control, the value fed into the hash function used by the router can be directly specified on a per-operation basis using the <code>routing</code> parameter.
</p>
<p>
When setting up explicit mapping, you can also use the <code>_routing</code> field to direct the index operation to extract the routing value from the document itself.
This does come at the (very minimal) cost of an additional document parsing pass.
If the <code>_routing</code> mapping is defined and set to be required, the index operation will fail if no routing value is provided or extracted.
</p>
<p>
NOTE: Data streams do not support custom routing unless they were created with the <code>allow_custom_routing</code> setting enabled in the template.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The index operation is directed to the primary shard based on its route and performed on the actual node containing this shard.
After the primary shard completes the operation, if needed, the update is distributed to applicable replicas.
</p>
<p>
<strong>Active shards</strong>
</p>
<p>
To improve the resiliency of writes to the system, indexing operations can be configured to wait for a certain number of active shard copies before proceeding with the operation.
If the requisite number of active shard copies are not available, then the write operation must wait and retry, until either the requisite shard copies have started or a timeout occurs.
By default, write operations only wait for the primary shards to be active before proceeding (that is to say <code>wait_for_active_shards</code> is <code>1</code>).
This default can be overridden in the index settings dynamically by setting <code>index.write.wait_for_active_shards</code>.
To alter this behavior per operation, use the <code>wait_for_active_shards request</code> parameter.
</p>
<p>
Valid values are all or any positive integer up to the total number of configured copies per shard in the index (which is <code>number_of_replicas</code>+1).
Specifying a negative value or a number greater than the number of shard copies will throw an error.
</p>
<p>
For example, suppose you have a cluster of three nodes, A, B, and C and you create an index index with the number of replicas set to 3 (resulting in 4 shard copies, one more copy than there are nodes).
If you attempt an indexing operation, by default the operation will only ensure the primary copy of each shard is available before proceeding.
This means that even if B and C went down and A hosted the primary shard copies, the indexing operation would still proceed with only one copy of the data.
If <code>wait_for_active_shards</code> is set on the request to <code>3</code> (and all three nodes are up), the indexing operation will require 3 active shard copies before proceeding.
This requirement should be met because there are 3 active nodes in the cluster, each one holding a copy of the shard.
However, if you set <code>wait_for_active_shards</code> to <code>all</code> (or to <code>4</code>, which is the same in this situation), the indexing operation will not proceed as you do not have all 4 copies of each shard active in the index.
The operation will timeout unless a new node is brought up in the cluster to host the fourth copy of the shard.
</p>
<p>
It is important to note that this setting greatly reduces the chances of the write operation not writing to the requisite number of shard copies, but it does not completely eliminate the possibility, because this check occurs before the write operation starts.
After the write operation is underway, it is still possible for replication to fail on any number of shard copies but still succeed on the primary.
The <code>_shards</code> section of the API response reveals the number of shard copies on which replication succeeded and failed.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-index_.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;CreateResponse&gt; CreateAsync&lt;TDocument&gt;(TDocument document, Id id, Action&lt;CreateRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.CreateRequestDescriptor-1.html">CreateRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.CreateResponse.html">CreateResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_CreateAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.CreateAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_CreateAsync__1___0_Elastic_Clients_Elasticsearch_Id_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.CreateAsync``1(``0,Elastic.Clients.Elasticsearch.Id,System.Threading.CancellationToken)">
  CreateAsync&lt;TDocument&gt;(TDocument, Id, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L7502"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Create a new document in the index.
</p>
<p>
You can index a new JSON document with the <code>/&lt;target&gt;/_doc/</code> or <code>/&lt;target&gt;/_create/&lt;_id&gt;</code> APIs
Using <code>_create</code> guarantees that the document is indexed only if it does not already exist.
It returns a 409 response when a document with a same ID already exists in the index.
To update an existing document, you must use the <code>/&lt;target&gt;/_doc/</code> API.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or index alias:
</p>
<ul><li>
<p>
To add a document using the <code>PUT /&lt;target&gt;/_create/&lt;_id&gt;</code> or <code>POST /&lt;target&gt;/_create/&lt;_id&gt;</code> request formats, you must have the <code>create_doc</code>, <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To automatically create a data stream or index with this API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege.
</p>
</li></ul>
<p>
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
<strong>Automatically create data streams and indices</strong>
</p>
<p>
If the request's target doesn't exist and matches an index template with a <code>data_stream</code> definition, the index operation automatically creates the data stream.
</p>
<p>
If the target doesn't exist and doesn't match a data stream template, the operation automatically creates the index and applies any matching index templates.
</p>
<p>
NOTE: Elasticsearch includes several built-in index templates. To avoid naming collisions with these templates, refer to index pattern documentation.
</p>
<p>
If no mapping exists, the index operation creates a dynamic mapping.
By default, new fields and objects are automatically added to the mapping if needed.
</p>
<p>
Automatic index creation is controlled by the <code>action.auto_create_index</code> setting.
If it is <code>true</code>, any index can be created automatically.
You can modify this setting to explicitly allow or block automatic creation of indices that match specified patterns or set it to <code>false</code> to turn off automatic index creation entirely.
Specify a comma-separated list of patterns you want to allow or prefix each pattern with <code>+</code> or <code>-</code> to indicate whether it should be allowed or blocked.
When a list is specified, the default behaviour is to disallow.
</p>
<p>
NOTE: The <code>action.auto_create_index</code> setting affects the automatic creation of indices only.
It does not affect the creation of data streams.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
By default, shard placement — or routing — is controlled by using a hash of the document's ID value.
For more explicit control, the value fed into the hash function used by the router can be directly specified on a per-operation basis using the <code>routing</code> parameter.
</p>
<p>
When setting up explicit mapping, you can also use the <code>_routing</code> field to direct the index operation to extract the routing value from the document itself.
This does come at the (very minimal) cost of an additional document parsing pass.
If the <code>_routing</code> mapping is defined and set to be required, the index operation will fail if no routing value is provided or extracted.
</p>
<p>
NOTE: Data streams do not support custom routing unless they were created with the <code>allow_custom_routing</code> setting enabled in the template.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The index operation is directed to the primary shard based on its route and performed on the actual node containing this shard.
After the primary shard completes the operation, if needed, the update is distributed to applicable replicas.
</p>
<p>
<strong>Active shards</strong>
</p>
<p>
To improve the resiliency of writes to the system, indexing operations can be configured to wait for a certain number of active shard copies before proceeding with the operation.
If the requisite number of active shard copies are not available, then the write operation must wait and retry, until either the requisite shard copies have started or a timeout occurs.
By default, write operations only wait for the primary shards to be active before proceeding (that is to say <code>wait_for_active_shards</code> is <code>1</code>).
This default can be overridden in the index settings dynamically by setting <code>index.write.wait_for_active_shards</code>.
To alter this behavior per operation, use the <code>wait_for_active_shards request</code> parameter.
</p>
<p>
Valid values are all or any positive integer up to the total number of configured copies per shard in the index (which is <code>number_of_replicas</code>+1).
Specifying a negative value or a number greater than the number of shard copies will throw an error.
</p>
<p>
For example, suppose you have a cluster of three nodes, A, B, and C and you create an index index with the number of replicas set to 3 (resulting in 4 shard copies, one more copy than there are nodes).
If you attempt an indexing operation, by default the operation will only ensure the primary copy of each shard is available before proceeding.
This means that even if B and C went down and A hosted the primary shard copies, the indexing operation would still proceed with only one copy of the data.
If <code>wait_for_active_shards</code> is set on the request to <code>3</code> (and all three nodes are up), the indexing operation will require 3 active shard copies before proceeding.
This requirement should be met because there are 3 active nodes in the cluster, each one holding a copy of the shard.
However, if you set <code>wait_for_active_shards</code> to <code>all</code> (or to <code>4</code>, which is the same in this situation), the indexing operation will not proceed as you do not have all 4 copies of each shard active in the index.
The operation will timeout unless a new node is brought up in the cluster to host the fourth copy of the shard.
</p>
<p>
It is important to note that this setting greatly reduces the chances of the write operation not writing to the requisite number of shard copies, but it does not completely eliminate the possibility, because this check occurs before the write operation starts.
After the write operation is underway, it is still possible for replication to fail on any number of shard copies but still succeed on the primary.
The <code>_shards</code> section of the API response reveals the number of shard copies on which replication succeeded and failed.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-index_.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;CreateResponse&gt; CreateAsync&lt;TDocument&gt;(TDocument document, Id id, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.CreateResponse.html">CreateResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_CreateAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.CreateAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_CreateAsync__1___0_Elastic_Clients_Elasticsearch_IndexName_Elastic_Clients_Elasticsearch_Id_System_Action_Elastic_Clients_Elasticsearch_CreateRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.CreateAsync``1(``0,Elastic.Clients.Elasticsearch.IndexName,Elastic.Clients.Elasticsearch.Id,System.Action{Elastic.Clients.Elasticsearch.CreateRequestDescriptor{``0}},System.Threading.CancellationToken)">
  CreateAsync&lt;TDocument&gt;(TDocument, IndexName, Id, Action&lt;CreateRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L6929"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Create a new document in the index.
</p>
<p>
You can index a new JSON document with the <code>/&lt;target&gt;/_doc/</code> or <code>/&lt;target&gt;/_create/&lt;_id&gt;</code> APIs
Using <code>_create</code> guarantees that the document is indexed only if it does not already exist.
It returns a 409 response when a document with a same ID already exists in the index.
To update an existing document, you must use the <code>/&lt;target&gt;/_doc/</code> API.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or index alias:
</p>
<ul><li>
<p>
To add a document using the <code>PUT /&lt;target&gt;/_create/&lt;_id&gt;</code> or <code>POST /&lt;target&gt;/_create/&lt;_id&gt;</code> request formats, you must have the <code>create_doc</code>, <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To automatically create a data stream or index with this API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege.
</p>
</li></ul>
<p>
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
<strong>Automatically create data streams and indices</strong>
</p>
<p>
If the request's target doesn't exist and matches an index template with a <code>data_stream</code> definition, the index operation automatically creates the data stream.
</p>
<p>
If the target doesn't exist and doesn't match a data stream template, the operation automatically creates the index and applies any matching index templates.
</p>
<p>
NOTE: Elasticsearch includes several built-in index templates. To avoid naming collisions with these templates, refer to index pattern documentation.
</p>
<p>
If no mapping exists, the index operation creates a dynamic mapping.
By default, new fields and objects are automatically added to the mapping if needed.
</p>
<p>
Automatic index creation is controlled by the <code>action.auto_create_index</code> setting.
If it is <code>true</code>, any index can be created automatically.
You can modify this setting to explicitly allow or block automatic creation of indices that match specified patterns or set it to <code>false</code> to turn off automatic index creation entirely.
Specify a comma-separated list of patterns you want to allow or prefix each pattern with <code>+</code> or <code>-</code> to indicate whether it should be allowed or blocked.
When a list is specified, the default behaviour is to disallow.
</p>
<p>
NOTE: The <code>action.auto_create_index</code> setting affects the automatic creation of indices only.
It does not affect the creation of data streams.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
By default, shard placement — or routing — is controlled by using a hash of the document's ID value.
For more explicit control, the value fed into the hash function used by the router can be directly specified on a per-operation basis using the <code>routing</code> parameter.
</p>
<p>
When setting up explicit mapping, you can also use the <code>_routing</code> field to direct the index operation to extract the routing value from the document itself.
This does come at the (very minimal) cost of an additional document parsing pass.
If the <code>_routing</code> mapping is defined and set to be required, the index operation will fail if no routing value is provided or extracted.
</p>
<p>
NOTE: Data streams do not support custom routing unless they were created with the <code>allow_custom_routing</code> setting enabled in the template.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The index operation is directed to the primary shard based on its route and performed on the actual node containing this shard.
After the primary shard completes the operation, if needed, the update is distributed to applicable replicas.
</p>
<p>
<strong>Active shards</strong>
</p>
<p>
To improve the resiliency of writes to the system, indexing operations can be configured to wait for a certain number of active shard copies before proceeding with the operation.
If the requisite number of active shard copies are not available, then the write operation must wait and retry, until either the requisite shard copies have started or a timeout occurs.
By default, write operations only wait for the primary shards to be active before proceeding (that is to say <code>wait_for_active_shards</code> is <code>1</code>).
This default can be overridden in the index settings dynamically by setting <code>index.write.wait_for_active_shards</code>.
To alter this behavior per operation, use the <code>wait_for_active_shards request</code> parameter.
</p>
<p>
Valid values are all or any positive integer up to the total number of configured copies per shard in the index (which is <code>number_of_replicas</code>+1).
Specifying a negative value or a number greater than the number of shard copies will throw an error.
</p>
<p>
For example, suppose you have a cluster of three nodes, A, B, and C and you create an index index with the number of replicas set to 3 (resulting in 4 shard copies, one more copy than there are nodes).
If you attempt an indexing operation, by default the operation will only ensure the primary copy of each shard is available before proceeding.
This means that even if B and C went down and A hosted the primary shard copies, the indexing operation would still proceed with only one copy of the data.
If <code>wait_for_active_shards</code> is set on the request to <code>3</code> (and all three nodes are up), the indexing operation will require 3 active shard copies before proceeding.
This requirement should be met because there are 3 active nodes in the cluster, each one holding a copy of the shard.
However, if you set <code>wait_for_active_shards</code> to <code>all</code> (or to <code>4</code>, which is the same in this situation), the indexing operation will not proceed as you do not have all 4 copies of each shard active in the index.
The operation will timeout unless a new node is brought up in the cluster to host the fourth copy of the shard.
</p>
<p>
It is important to note that this setting greatly reduces the chances of the write operation not writing to the requisite number of shard copies, but it does not completely eliminate the possibility, because this check occurs before the write operation starts.
After the write operation is underway, it is still possible for replication to fail on any number of shard copies but still succeed on the primary.
The <code>_shards</code> section of the API response reveals the number of shard copies on which replication succeeded and failed.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-index_.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;CreateResponse&gt; CreateAsync&lt;TDocument&gt;(TDocument document, IndexName index, Id id, Action&lt;CreateRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.CreateRequestDescriptor-1.html">CreateRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.CreateResponse.html">CreateResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_CreateAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.CreateAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_CreateAsync__1___0_Elastic_Clients_Elasticsearch_IndexName_Elastic_Clients_Elasticsearch_Id_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.CreateAsync``1(``0,Elastic.Clients.Elasticsearch.IndexName,Elastic.Clients.Elasticsearch.Id,System.Threading.CancellationToken)">
  CreateAsync&lt;TDocument&gt;(TDocument, IndexName, Id, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L6815"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Create a new document in the index.
</p>
<p>
You can index a new JSON document with the <code>/&lt;target&gt;/_doc/</code> or <code>/&lt;target&gt;/_create/&lt;_id&gt;</code> APIs
Using <code>_create</code> guarantees that the document is indexed only if it does not already exist.
It returns a 409 response when a document with a same ID already exists in the index.
To update an existing document, you must use the <code>/&lt;target&gt;/_doc/</code> API.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or index alias:
</p>
<ul><li>
<p>
To add a document using the <code>PUT /&lt;target&gt;/_create/&lt;_id&gt;</code> or <code>POST /&lt;target&gt;/_create/&lt;_id&gt;</code> request formats, you must have the <code>create_doc</code>, <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To automatically create a data stream or index with this API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege.
</p>
</li></ul>
<p>
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
<strong>Automatically create data streams and indices</strong>
</p>
<p>
If the request's target doesn't exist and matches an index template with a <code>data_stream</code> definition, the index operation automatically creates the data stream.
</p>
<p>
If the target doesn't exist and doesn't match a data stream template, the operation automatically creates the index and applies any matching index templates.
</p>
<p>
NOTE: Elasticsearch includes several built-in index templates. To avoid naming collisions with these templates, refer to index pattern documentation.
</p>
<p>
If no mapping exists, the index operation creates a dynamic mapping.
By default, new fields and objects are automatically added to the mapping if needed.
</p>
<p>
Automatic index creation is controlled by the <code>action.auto_create_index</code> setting.
If it is <code>true</code>, any index can be created automatically.
You can modify this setting to explicitly allow or block automatic creation of indices that match specified patterns or set it to <code>false</code> to turn off automatic index creation entirely.
Specify a comma-separated list of patterns you want to allow or prefix each pattern with <code>+</code> or <code>-</code> to indicate whether it should be allowed or blocked.
When a list is specified, the default behaviour is to disallow.
</p>
<p>
NOTE: The <code>action.auto_create_index</code> setting affects the automatic creation of indices only.
It does not affect the creation of data streams.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
By default, shard placement — or routing — is controlled by using a hash of the document's ID value.
For more explicit control, the value fed into the hash function used by the router can be directly specified on a per-operation basis using the <code>routing</code> parameter.
</p>
<p>
When setting up explicit mapping, you can also use the <code>_routing</code> field to direct the index operation to extract the routing value from the document itself.
This does come at the (very minimal) cost of an additional document parsing pass.
If the <code>_routing</code> mapping is defined and set to be required, the index operation will fail if no routing value is provided or extracted.
</p>
<p>
NOTE: Data streams do not support custom routing unless they were created with the <code>allow_custom_routing</code> setting enabled in the template.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The index operation is directed to the primary shard based on its route and performed on the actual node containing this shard.
After the primary shard completes the operation, if needed, the update is distributed to applicable replicas.
</p>
<p>
<strong>Active shards</strong>
</p>
<p>
To improve the resiliency of writes to the system, indexing operations can be configured to wait for a certain number of active shard copies before proceeding with the operation.
If the requisite number of active shard copies are not available, then the write operation must wait and retry, until either the requisite shard copies have started or a timeout occurs.
By default, write operations only wait for the primary shards to be active before proceeding (that is to say <code>wait_for_active_shards</code> is <code>1</code>).
This default can be overridden in the index settings dynamically by setting <code>index.write.wait_for_active_shards</code>.
To alter this behavior per operation, use the <code>wait_for_active_shards request</code> parameter.
</p>
<p>
Valid values are all or any positive integer up to the total number of configured copies per shard in the index (which is <code>number_of_replicas</code>+1).
Specifying a negative value or a number greater than the number of shard copies will throw an error.
</p>
<p>
For example, suppose you have a cluster of three nodes, A, B, and C and you create an index index with the number of replicas set to 3 (resulting in 4 shard copies, one more copy than there are nodes).
If you attempt an indexing operation, by default the operation will only ensure the primary copy of each shard is available before proceeding.
This means that even if B and C went down and A hosted the primary shard copies, the indexing operation would still proceed with only one copy of the data.
If <code>wait_for_active_shards</code> is set on the request to <code>3</code> (and all three nodes are up), the indexing operation will require 3 active shard copies before proceeding.
This requirement should be met because there are 3 active nodes in the cluster, each one holding a copy of the shard.
However, if you set <code>wait_for_active_shards</code> to <code>all</code> (or to <code>4</code>, which is the same in this situation), the indexing operation will not proceed as you do not have all 4 copies of each shard active in the index.
The operation will timeout unless a new node is brought up in the cluster to host the fourth copy of the shard.
</p>
<p>
It is important to note that this setting greatly reduces the chances of the write operation not writing to the requisite number of shard copies, but it does not completely eliminate the possibility, because this check occurs before the write operation starts.
After the write operation is underway, it is still possible for replication to fail on any number of shard copies but still succeed on the primary.
The <code>_shards</code> section of the API response reveals the number of shard copies on which replication succeeded and failed.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-index_.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;CreateResponse&gt; CreateAsync&lt;TDocument&gt;(TDocument document, IndexName index, Id id, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.CreateResponse.html">CreateResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_CreateAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.CreateAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_CreateAsync__1___0_Elastic_Clients_Elasticsearch_IndexName_System_Action_Elastic_Clients_Elasticsearch_CreateRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.CreateAsync``1(``0,Elastic.Clients.Elasticsearch.IndexName,System.Action{Elastic.Clients.Elasticsearch.CreateRequestDescriptor{``0}},System.Threading.CancellationToken)">
  CreateAsync&lt;TDocument&gt;(TDocument, IndexName, Action&lt;CreateRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L7387"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Create a new document in the index.
</p>
<p>
You can index a new JSON document with the <code>/&lt;target&gt;/_doc/</code> or <code>/&lt;target&gt;/_create/&lt;_id&gt;</code> APIs
Using <code>_create</code> guarantees that the document is indexed only if it does not already exist.
It returns a 409 response when a document with a same ID already exists in the index.
To update an existing document, you must use the <code>/&lt;target&gt;/_doc/</code> API.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or index alias:
</p>
<ul><li>
<p>
To add a document using the <code>PUT /&lt;target&gt;/_create/&lt;_id&gt;</code> or <code>POST /&lt;target&gt;/_create/&lt;_id&gt;</code> request formats, you must have the <code>create_doc</code>, <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To automatically create a data stream or index with this API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege.
</p>
</li></ul>
<p>
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
<strong>Automatically create data streams and indices</strong>
</p>
<p>
If the request's target doesn't exist and matches an index template with a <code>data_stream</code> definition, the index operation automatically creates the data stream.
</p>
<p>
If the target doesn't exist and doesn't match a data stream template, the operation automatically creates the index and applies any matching index templates.
</p>
<p>
NOTE: Elasticsearch includes several built-in index templates. To avoid naming collisions with these templates, refer to index pattern documentation.
</p>
<p>
If no mapping exists, the index operation creates a dynamic mapping.
By default, new fields and objects are automatically added to the mapping if needed.
</p>
<p>
Automatic index creation is controlled by the <code>action.auto_create_index</code> setting.
If it is <code>true</code>, any index can be created automatically.
You can modify this setting to explicitly allow or block automatic creation of indices that match specified patterns or set it to <code>false</code> to turn off automatic index creation entirely.
Specify a comma-separated list of patterns you want to allow or prefix each pattern with <code>+</code> or <code>-</code> to indicate whether it should be allowed or blocked.
When a list is specified, the default behaviour is to disallow.
</p>
<p>
NOTE: The <code>action.auto_create_index</code> setting affects the automatic creation of indices only.
It does not affect the creation of data streams.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
By default, shard placement — or routing — is controlled by using a hash of the document's ID value.
For more explicit control, the value fed into the hash function used by the router can be directly specified on a per-operation basis using the <code>routing</code> parameter.
</p>
<p>
When setting up explicit mapping, you can also use the <code>_routing</code> field to direct the index operation to extract the routing value from the document itself.
This does come at the (very minimal) cost of an additional document parsing pass.
If the <code>_routing</code> mapping is defined and set to be required, the index operation will fail if no routing value is provided or extracted.
</p>
<p>
NOTE: Data streams do not support custom routing unless they were created with the <code>allow_custom_routing</code> setting enabled in the template.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The index operation is directed to the primary shard based on its route and performed on the actual node containing this shard.
After the primary shard completes the operation, if needed, the update is distributed to applicable replicas.
</p>
<p>
<strong>Active shards</strong>
</p>
<p>
To improve the resiliency of writes to the system, indexing operations can be configured to wait for a certain number of active shard copies before proceeding with the operation.
If the requisite number of active shard copies are not available, then the write operation must wait and retry, until either the requisite shard copies have started or a timeout occurs.
By default, write operations only wait for the primary shards to be active before proceeding (that is to say <code>wait_for_active_shards</code> is <code>1</code>).
This default can be overridden in the index settings dynamically by setting <code>index.write.wait_for_active_shards</code>.
To alter this behavior per operation, use the <code>wait_for_active_shards request</code> parameter.
</p>
<p>
Valid values are all or any positive integer up to the total number of configured copies per shard in the index (which is <code>number_of_replicas</code>+1).
Specifying a negative value or a number greater than the number of shard copies will throw an error.
</p>
<p>
For example, suppose you have a cluster of three nodes, A, B, and C and you create an index index with the number of replicas set to 3 (resulting in 4 shard copies, one more copy than there are nodes).
If you attempt an indexing operation, by default the operation will only ensure the primary copy of each shard is available before proceeding.
This means that even if B and C went down and A hosted the primary shard copies, the indexing operation would still proceed with only one copy of the data.
If <code>wait_for_active_shards</code> is set on the request to <code>3</code> (and all three nodes are up), the indexing operation will require 3 active shard copies before proceeding.
This requirement should be met because there are 3 active nodes in the cluster, each one holding a copy of the shard.
However, if you set <code>wait_for_active_shards</code> to <code>all</code> (or to <code>4</code>, which is the same in this situation), the indexing operation will not proceed as you do not have all 4 copies of each shard active in the index.
The operation will timeout unless a new node is brought up in the cluster to host the fourth copy of the shard.
</p>
<p>
It is important to note that this setting greatly reduces the chances of the write operation not writing to the requisite number of shard copies, but it does not completely eliminate the possibility, because this check occurs before the write operation starts.
After the write operation is underway, it is still possible for replication to fail on any number of shard copies but still succeed on the primary.
The <code>_shards</code> section of the API response reveals the number of shard copies on which replication succeeded and failed.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-index_.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;CreateResponse&gt; CreateAsync&lt;TDocument&gt;(TDocument document, IndexName index, Action&lt;CreateRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.CreateRequestDescriptor-1.html">CreateRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.CreateResponse.html">CreateResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_CreateAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.CreateAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_CreateAsync__1___0_Elastic_Clients_Elasticsearch_IndexName_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.CreateAsync``1(``0,Elastic.Clients.Elasticsearch.IndexName,System.Threading.CancellationToken)">
  CreateAsync&lt;TDocument&gt;(TDocument, IndexName, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L7273"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Create a new document in the index.
</p>
<p>
You can index a new JSON document with the <code>/&lt;target&gt;/_doc/</code> or <code>/&lt;target&gt;/_create/&lt;_id&gt;</code> APIs
Using <code>_create</code> guarantees that the document is indexed only if it does not already exist.
It returns a 409 response when a document with a same ID already exists in the index.
To update an existing document, you must use the <code>/&lt;target&gt;/_doc/</code> API.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or index alias:
</p>
<ul><li>
<p>
To add a document using the <code>PUT /&lt;target&gt;/_create/&lt;_id&gt;</code> or <code>POST /&lt;target&gt;/_create/&lt;_id&gt;</code> request formats, you must have the <code>create_doc</code>, <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To automatically create a data stream or index with this API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege.
</p>
</li></ul>
<p>
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
<strong>Automatically create data streams and indices</strong>
</p>
<p>
If the request's target doesn't exist and matches an index template with a <code>data_stream</code> definition, the index operation automatically creates the data stream.
</p>
<p>
If the target doesn't exist and doesn't match a data stream template, the operation automatically creates the index and applies any matching index templates.
</p>
<p>
NOTE: Elasticsearch includes several built-in index templates. To avoid naming collisions with these templates, refer to index pattern documentation.
</p>
<p>
If no mapping exists, the index operation creates a dynamic mapping.
By default, new fields and objects are automatically added to the mapping if needed.
</p>
<p>
Automatic index creation is controlled by the <code>action.auto_create_index</code> setting.
If it is <code>true</code>, any index can be created automatically.
You can modify this setting to explicitly allow or block automatic creation of indices that match specified patterns or set it to <code>false</code> to turn off automatic index creation entirely.
Specify a comma-separated list of patterns you want to allow or prefix each pattern with <code>+</code> or <code>-</code> to indicate whether it should be allowed or blocked.
When a list is specified, the default behaviour is to disallow.
</p>
<p>
NOTE: The <code>action.auto_create_index</code> setting affects the automatic creation of indices only.
It does not affect the creation of data streams.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
By default, shard placement — or routing — is controlled by using a hash of the document's ID value.
For more explicit control, the value fed into the hash function used by the router can be directly specified on a per-operation basis using the <code>routing</code> parameter.
</p>
<p>
When setting up explicit mapping, you can also use the <code>_routing</code> field to direct the index operation to extract the routing value from the document itself.
This does come at the (very minimal) cost of an additional document parsing pass.
If the <code>_routing</code> mapping is defined and set to be required, the index operation will fail if no routing value is provided or extracted.
</p>
<p>
NOTE: Data streams do not support custom routing unless they were created with the <code>allow_custom_routing</code> setting enabled in the template.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The index operation is directed to the primary shard based on its route and performed on the actual node containing this shard.
After the primary shard completes the operation, if needed, the update is distributed to applicable replicas.
</p>
<p>
<strong>Active shards</strong>
</p>
<p>
To improve the resiliency of writes to the system, indexing operations can be configured to wait for a certain number of active shard copies before proceeding with the operation.
If the requisite number of active shard copies are not available, then the write operation must wait and retry, until either the requisite shard copies have started or a timeout occurs.
By default, write operations only wait for the primary shards to be active before proceeding (that is to say <code>wait_for_active_shards</code> is <code>1</code>).
This default can be overridden in the index settings dynamically by setting <code>index.write.wait_for_active_shards</code>.
To alter this behavior per operation, use the <code>wait_for_active_shards request</code> parameter.
</p>
<p>
Valid values are all or any positive integer up to the total number of configured copies per shard in the index (which is <code>number_of_replicas</code>+1).
Specifying a negative value or a number greater than the number of shard copies will throw an error.
</p>
<p>
For example, suppose you have a cluster of three nodes, A, B, and C and you create an index index with the number of replicas set to 3 (resulting in 4 shard copies, one more copy than there are nodes).
If you attempt an indexing operation, by default the operation will only ensure the primary copy of each shard is available before proceeding.
This means that even if B and C went down and A hosted the primary shard copies, the indexing operation would still proceed with only one copy of the data.
If <code>wait_for_active_shards</code> is set on the request to <code>3</code> (and all three nodes are up), the indexing operation will require 3 active shard copies before proceeding.
This requirement should be met because there are 3 active nodes in the cluster, each one holding a copy of the shard.
However, if you set <code>wait_for_active_shards</code> to <code>all</code> (or to <code>4</code>, which is the same in this situation), the indexing operation will not proceed as you do not have all 4 copies of each shard active in the index.
The operation will timeout unless a new node is brought up in the cluster to host the fourth copy of the shard.
</p>
<p>
It is important to note that this setting greatly reduces the chances of the write operation not writing to the requisite number of shard copies, but it does not completely eliminate the possibility, because this check occurs before the write operation starts.
After the write operation is underway, it is still possible for replication to fail on any number of shard copies but still succeed on the primary.
The <code>_shards</code> section of the API response reveals the number of shard copies on which replication succeeded and failed.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-index_.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;CreateResponse&gt; CreateAsync&lt;TDocument&gt;(TDocument document, IndexName index, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.CreateResponse.html">CreateResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_CreateAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.CreateAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_CreateAsync__1___0_System_Action_Elastic_Clients_Elasticsearch_CreateRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.CreateAsync``1(``0,System.Action{Elastic.Clients.Elasticsearch.CreateRequestDescriptor{``0}},System.Threading.CancellationToken)">
  CreateAsync&lt;TDocument&gt;(TDocument, Action&lt;CreateRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L7158"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Create a new document in the index.
</p>
<p>
You can index a new JSON document with the <code>/&lt;target&gt;/_doc/</code> or <code>/&lt;target&gt;/_create/&lt;_id&gt;</code> APIs
Using <code>_create</code> guarantees that the document is indexed only if it does not already exist.
It returns a 409 response when a document with a same ID already exists in the index.
To update an existing document, you must use the <code>/&lt;target&gt;/_doc/</code> API.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or index alias:
</p>
<ul><li>
<p>
To add a document using the <code>PUT /&lt;target&gt;/_create/&lt;_id&gt;</code> or <code>POST /&lt;target&gt;/_create/&lt;_id&gt;</code> request formats, you must have the <code>create_doc</code>, <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To automatically create a data stream or index with this API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege.
</p>
</li></ul>
<p>
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
<strong>Automatically create data streams and indices</strong>
</p>
<p>
If the request's target doesn't exist and matches an index template with a <code>data_stream</code> definition, the index operation automatically creates the data stream.
</p>
<p>
If the target doesn't exist and doesn't match a data stream template, the operation automatically creates the index and applies any matching index templates.
</p>
<p>
NOTE: Elasticsearch includes several built-in index templates. To avoid naming collisions with these templates, refer to index pattern documentation.
</p>
<p>
If no mapping exists, the index operation creates a dynamic mapping.
By default, new fields and objects are automatically added to the mapping if needed.
</p>
<p>
Automatic index creation is controlled by the <code>action.auto_create_index</code> setting.
If it is <code>true</code>, any index can be created automatically.
You can modify this setting to explicitly allow or block automatic creation of indices that match specified patterns or set it to <code>false</code> to turn off automatic index creation entirely.
Specify a comma-separated list of patterns you want to allow or prefix each pattern with <code>+</code> or <code>-</code> to indicate whether it should be allowed or blocked.
When a list is specified, the default behaviour is to disallow.
</p>
<p>
NOTE: The <code>action.auto_create_index</code> setting affects the automatic creation of indices only.
It does not affect the creation of data streams.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
By default, shard placement — or routing — is controlled by using a hash of the document's ID value.
For more explicit control, the value fed into the hash function used by the router can be directly specified on a per-operation basis using the <code>routing</code> parameter.
</p>
<p>
When setting up explicit mapping, you can also use the <code>_routing</code> field to direct the index operation to extract the routing value from the document itself.
This does come at the (very minimal) cost of an additional document parsing pass.
If the <code>_routing</code> mapping is defined and set to be required, the index operation will fail if no routing value is provided or extracted.
</p>
<p>
NOTE: Data streams do not support custom routing unless they were created with the <code>allow_custom_routing</code> setting enabled in the template.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The index operation is directed to the primary shard based on its route and performed on the actual node containing this shard.
After the primary shard completes the operation, if needed, the update is distributed to applicable replicas.
</p>
<p>
<strong>Active shards</strong>
</p>
<p>
To improve the resiliency of writes to the system, indexing operations can be configured to wait for a certain number of active shard copies before proceeding with the operation.
If the requisite number of active shard copies are not available, then the write operation must wait and retry, until either the requisite shard copies have started or a timeout occurs.
By default, write operations only wait for the primary shards to be active before proceeding (that is to say <code>wait_for_active_shards</code> is <code>1</code>).
This default can be overridden in the index settings dynamically by setting <code>index.write.wait_for_active_shards</code>.
To alter this behavior per operation, use the <code>wait_for_active_shards request</code> parameter.
</p>
<p>
Valid values are all or any positive integer up to the total number of configured copies per shard in the index (which is <code>number_of_replicas</code>+1).
Specifying a negative value or a number greater than the number of shard copies will throw an error.
</p>
<p>
For example, suppose you have a cluster of three nodes, A, B, and C and you create an index index with the number of replicas set to 3 (resulting in 4 shard copies, one more copy than there are nodes).
If you attempt an indexing operation, by default the operation will only ensure the primary copy of each shard is available before proceeding.
This means that even if B and C went down and A hosted the primary shard copies, the indexing operation would still proceed with only one copy of the data.
If <code>wait_for_active_shards</code> is set on the request to <code>3</code> (and all three nodes are up), the indexing operation will require 3 active shard copies before proceeding.
This requirement should be met because there are 3 active nodes in the cluster, each one holding a copy of the shard.
However, if you set <code>wait_for_active_shards</code> to <code>all</code> (or to <code>4</code>, which is the same in this situation), the indexing operation will not proceed as you do not have all 4 copies of each shard active in the index.
The operation will timeout unless a new node is brought up in the cluster to host the fourth copy of the shard.
</p>
<p>
It is important to note that this setting greatly reduces the chances of the write operation not writing to the requisite number of shard copies, but it does not completely eliminate the possibility, because this check occurs before the write operation starts.
After the write operation is underway, it is still possible for replication to fail on any number of shard copies but still succeed on the primary.
The <code>_shards</code> section of the API response reveals the number of shard copies on which replication succeeded and failed.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-index_.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;CreateResponse&gt; CreateAsync&lt;TDocument&gt;(TDocument document, Action&lt;CreateRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.CreateRequestDescriptor-1.html">CreateRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.CreateResponse.html">CreateResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_CreateAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.CreateAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_CreateAsync__1___0_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.CreateAsync``1(``0,System.Threading.CancellationToken)">
  CreateAsync&lt;TDocument&gt;(TDocument, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L7044"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Create a new document in the index.
</p>
<p>
You can index a new JSON document with the <code>/&lt;target&gt;/_doc/</code> or <code>/&lt;target&gt;/_create/&lt;_id&gt;</code> APIs
Using <code>_create</code> guarantees that the document is indexed only if it does not already exist.
It returns a 409 response when a document with a same ID already exists in the index.
To update an existing document, you must use the <code>/&lt;target&gt;/_doc/</code> API.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or index alias:
</p>
<ul><li>
<p>
To add a document using the <code>PUT /&lt;target&gt;/_create/&lt;_id&gt;</code> or <code>POST /&lt;target&gt;/_create/&lt;_id&gt;</code> request formats, you must have the <code>create_doc</code>, <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To automatically create a data stream or index with this API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege.
</p>
</li></ul>
<p>
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
<strong>Automatically create data streams and indices</strong>
</p>
<p>
If the request's target doesn't exist and matches an index template with a <code>data_stream</code> definition, the index operation automatically creates the data stream.
</p>
<p>
If the target doesn't exist and doesn't match a data stream template, the operation automatically creates the index and applies any matching index templates.
</p>
<p>
NOTE: Elasticsearch includes several built-in index templates. To avoid naming collisions with these templates, refer to index pattern documentation.
</p>
<p>
If no mapping exists, the index operation creates a dynamic mapping.
By default, new fields and objects are automatically added to the mapping if needed.
</p>
<p>
Automatic index creation is controlled by the <code>action.auto_create_index</code> setting.
If it is <code>true</code>, any index can be created automatically.
You can modify this setting to explicitly allow or block automatic creation of indices that match specified patterns or set it to <code>false</code> to turn off automatic index creation entirely.
Specify a comma-separated list of patterns you want to allow or prefix each pattern with <code>+</code> or <code>-</code> to indicate whether it should be allowed or blocked.
When a list is specified, the default behaviour is to disallow.
</p>
<p>
NOTE: The <code>action.auto_create_index</code> setting affects the automatic creation of indices only.
It does not affect the creation of data streams.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
By default, shard placement — or routing — is controlled by using a hash of the document's ID value.
For more explicit control, the value fed into the hash function used by the router can be directly specified on a per-operation basis using the <code>routing</code> parameter.
</p>
<p>
When setting up explicit mapping, you can also use the <code>_routing</code> field to direct the index operation to extract the routing value from the document itself.
This does come at the (very minimal) cost of an additional document parsing pass.
If the <code>_routing</code> mapping is defined and set to be required, the index operation will fail if no routing value is provided or extracted.
</p>
<p>
NOTE: Data streams do not support custom routing unless they were created with the <code>allow_custom_routing</code> setting enabled in the template.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The index operation is directed to the primary shard based on its route and performed on the actual node containing this shard.
After the primary shard completes the operation, if needed, the update is distributed to applicable replicas.
</p>
<p>
<strong>Active shards</strong>
</p>
<p>
To improve the resiliency of writes to the system, indexing operations can be configured to wait for a certain number of active shard copies before proceeding with the operation.
If the requisite number of active shard copies are not available, then the write operation must wait and retry, until either the requisite shard copies have started or a timeout occurs.
By default, write operations only wait for the primary shards to be active before proceeding (that is to say <code>wait_for_active_shards</code> is <code>1</code>).
This default can be overridden in the index settings dynamically by setting <code>index.write.wait_for_active_shards</code>.
To alter this behavior per operation, use the <code>wait_for_active_shards request</code> parameter.
</p>
<p>
Valid values are all or any positive integer up to the total number of configured copies per shard in the index (which is <code>number_of_replicas</code>+1).
Specifying a negative value or a number greater than the number of shard copies will throw an error.
</p>
<p>
For example, suppose you have a cluster of three nodes, A, B, and C and you create an index index with the number of replicas set to 3 (resulting in 4 shard copies, one more copy than there are nodes).
If you attempt an indexing operation, by default the operation will only ensure the primary copy of each shard is available before proceeding.
This means that even if B and C went down and A hosted the primary shard copies, the indexing operation would still proceed with only one copy of the data.
If <code>wait_for_active_shards</code> is set on the request to <code>3</code> (and all three nodes are up), the indexing operation will require 3 active shard copies before proceeding.
This requirement should be met because there are 3 active nodes in the cluster, each one holding a copy of the shard.
However, if you set <code>wait_for_active_shards</code> to <code>all</code> (or to <code>4</code>, which is the same in this situation), the indexing operation will not proceed as you do not have all 4 copies of each shard active in the index.
The operation will timeout unless a new node is brought up in the cluster to host the fourth copy of the shard.
</p>
<p>
It is important to note that this setting greatly reduces the chances of the write operation not writing to the requisite number of shard copies, but it does not completely eliminate the possibility, because this check occurs before the write operation starts.
After the write operation is underway, it is still possible for replication to fail on any number of shard copies but still succeed on the primary.
The <code>_shards</code> section of the API response reveals the number of shard copies on which replication succeeded and failed.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-index_.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;CreateResponse&gt; CreateAsync&lt;TDocument&gt;(TDocument document, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.CreateResponse.html">CreateResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Create_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Create*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Create__1_Elastic_Clients_Elasticsearch_CreateRequestDescriptor___0__" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Create``1(Elastic.Clients.Elasticsearch.CreateRequestDescriptor{``0})">
  Create&lt;TDocument&gt;(CreateRequestDescriptor&lt;TDocument&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L5664"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Create a new document in the index.
</p>
<p>
You can index a new JSON document with the <code>/&lt;target&gt;/_doc/</code> or <code>/&lt;target&gt;/_create/&lt;_id&gt;</code> APIs
Using <code>_create</code> guarantees that the document is indexed only if it does not already exist.
It returns a 409 response when a document with a same ID already exists in the index.
To update an existing document, you must use the <code>/&lt;target&gt;/_doc/</code> API.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or index alias:
</p>
<ul><li>
<p>
To add a document using the <code>PUT /&lt;target&gt;/_create/&lt;_id&gt;</code> or <code>POST /&lt;target&gt;/_create/&lt;_id&gt;</code> request formats, you must have the <code>create_doc</code>, <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To automatically create a data stream or index with this API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege.
</p>
</li></ul>
<p>
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
<strong>Automatically create data streams and indices</strong>
</p>
<p>
If the request's target doesn't exist and matches an index template with a <code>data_stream</code> definition, the index operation automatically creates the data stream.
</p>
<p>
If the target doesn't exist and doesn't match a data stream template, the operation automatically creates the index and applies any matching index templates.
</p>
<p>
NOTE: Elasticsearch includes several built-in index templates. To avoid naming collisions with these templates, refer to index pattern documentation.
</p>
<p>
If no mapping exists, the index operation creates a dynamic mapping.
By default, new fields and objects are automatically added to the mapping if needed.
</p>
<p>
Automatic index creation is controlled by the <code>action.auto_create_index</code> setting.
If it is <code>true</code>, any index can be created automatically.
You can modify this setting to explicitly allow or block automatic creation of indices that match specified patterns or set it to <code>false</code> to turn off automatic index creation entirely.
Specify a comma-separated list of patterns you want to allow or prefix each pattern with <code>+</code> or <code>-</code> to indicate whether it should be allowed or blocked.
When a list is specified, the default behaviour is to disallow.
</p>
<p>
NOTE: The <code>action.auto_create_index</code> setting affects the automatic creation of indices only.
It does not affect the creation of data streams.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
By default, shard placement — or routing — is controlled by using a hash of the document's ID value.
For more explicit control, the value fed into the hash function used by the router can be directly specified on a per-operation basis using the <code>routing</code> parameter.
</p>
<p>
When setting up explicit mapping, you can also use the <code>_routing</code> field to direct the index operation to extract the routing value from the document itself.
This does come at the (very minimal) cost of an additional document parsing pass.
If the <code>_routing</code> mapping is defined and set to be required, the index operation will fail if no routing value is provided or extracted.
</p>
<p>
NOTE: Data streams do not support custom routing unless they were created with the <code>allow_custom_routing</code> setting enabled in the template.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The index operation is directed to the primary shard based on its route and performed on the actual node containing this shard.
After the primary shard completes the operation, if needed, the update is distributed to applicable replicas.
</p>
<p>
<strong>Active shards</strong>
</p>
<p>
To improve the resiliency of writes to the system, indexing operations can be configured to wait for a certain number of active shard copies before proceeding with the operation.
If the requisite number of active shard copies are not available, then the write operation must wait and retry, until either the requisite shard copies have started or a timeout occurs.
By default, write operations only wait for the primary shards to be active before proceeding (that is to say <code>wait_for_active_shards</code> is <code>1</code>).
This default can be overridden in the index settings dynamically by setting <code>index.write.wait_for_active_shards</code>.
To alter this behavior per operation, use the <code>wait_for_active_shards request</code> parameter.
</p>
<p>
Valid values are all or any positive integer up to the total number of configured copies per shard in the index (which is <code>number_of_replicas</code>+1).
Specifying a negative value or a number greater than the number of shard copies will throw an error.
</p>
<p>
For example, suppose you have a cluster of three nodes, A, B, and C and you create an index index with the number of replicas set to 3 (resulting in 4 shard copies, one more copy than there are nodes).
If you attempt an indexing operation, by default the operation will only ensure the primary copy of each shard is available before proceeding.
This means that even if B and C went down and A hosted the primary shard copies, the indexing operation would still proceed with only one copy of the data.
If <code>wait_for_active_shards</code> is set on the request to <code>3</code> (and all three nodes are up), the indexing operation will require 3 active shard copies before proceeding.
This requirement should be met because there are 3 active nodes in the cluster, each one holding a copy of the shard.
However, if you set <code>wait_for_active_shards</code> to <code>all</code> (or to <code>4</code>, which is the same in this situation), the indexing operation will not proceed as you do not have all 4 copies of each shard active in the index.
The operation will timeout unless a new node is brought up in the cluster to host the fourth copy of the shard.
</p>
<p>
It is important to note that this setting greatly reduces the chances of the write operation not writing to the requisite number of shard copies, but it does not completely eliminate the possibility, because this check occurs before the write operation starts.
After the write operation is underway, it is still possible for replication to fail on any number of shard copies but still succeed on the primary.
The <code>_shards</code> section of the API response reveals the number of shard copies on which replication succeeded and failed.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-index_.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual CreateResponse Create&lt;TDocument&gt;(CreateRequestDescriptor&lt;TDocument&gt; descriptor)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.CreateRequestDescriptor-1.html">CreateRequestDescriptor</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.CreateResponse.html">CreateResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Create_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Create*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Create__1_Elastic_Clients_Elasticsearch_CreateRequest___0__" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Create``1(Elastic.Clients.Elasticsearch.CreateRequest{``0})">
  Create&lt;TDocument&gt;(CreateRequest&lt;TDocument&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L5437"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Create a new document in the index.
</p>
<p>
You can index a new JSON document with the <code>/&lt;target&gt;/_doc/</code> or <code>/&lt;target&gt;/_create/&lt;_id&gt;</code> APIs
Using <code>_create</code> guarantees that the document is indexed only if it does not already exist.
It returns a 409 response when a document with a same ID already exists in the index.
To update an existing document, you must use the <code>/&lt;target&gt;/_doc/</code> API.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or index alias:
</p>
<ul><li>
<p>
To add a document using the <code>PUT /&lt;target&gt;/_create/&lt;_id&gt;</code> or <code>POST /&lt;target&gt;/_create/&lt;_id&gt;</code> request formats, you must have the <code>create_doc</code>, <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To automatically create a data stream or index with this API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege.
</p>
</li></ul>
<p>
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
<strong>Automatically create data streams and indices</strong>
</p>
<p>
If the request's target doesn't exist and matches an index template with a <code>data_stream</code> definition, the index operation automatically creates the data stream.
</p>
<p>
If the target doesn't exist and doesn't match a data stream template, the operation automatically creates the index and applies any matching index templates.
</p>
<p>
NOTE: Elasticsearch includes several built-in index templates. To avoid naming collisions with these templates, refer to index pattern documentation.
</p>
<p>
If no mapping exists, the index operation creates a dynamic mapping.
By default, new fields and objects are automatically added to the mapping if needed.
</p>
<p>
Automatic index creation is controlled by the <code>action.auto_create_index</code> setting.
If it is <code>true</code>, any index can be created automatically.
You can modify this setting to explicitly allow or block automatic creation of indices that match specified patterns or set it to <code>false</code> to turn off automatic index creation entirely.
Specify a comma-separated list of patterns you want to allow or prefix each pattern with <code>+</code> or <code>-</code> to indicate whether it should be allowed or blocked.
When a list is specified, the default behaviour is to disallow.
</p>
<p>
NOTE: The <code>action.auto_create_index</code> setting affects the automatic creation of indices only.
It does not affect the creation of data streams.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
By default, shard placement — or routing — is controlled by using a hash of the document's ID value.
For more explicit control, the value fed into the hash function used by the router can be directly specified on a per-operation basis using the <code>routing</code> parameter.
</p>
<p>
When setting up explicit mapping, you can also use the <code>_routing</code> field to direct the index operation to extract the routing value from the document itself.
This does come at the (very minimal) cost of an additional document parsing pass.
If the <code>_routing</code> mapping is defined and set to be required, the index operation will fail if no routing value is provided or extracted.
</p>
<p>
NOTE: Data streams do not support custom routing unless they were created with the <code>allow_custom_routing</code> setting enabled in the template.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The index operation is directed to the primary shard based on its route and performed on the actual node containing this shard.
After the primary shard completes the operation, if needed, the update is distributed to applicable replicas.
</p>
<p>
<strong>Active shards</strong>
</p>
<p>
To improve the resiliency of writes to the system, indexing operations can be configured to wait for a certain number of active shard copies before proceeding with the operation.
If the requisite number of active shard copies are not available, then the write operation must wait and retry, until either the requisite shard copies have started or a timeout occurs.
By default, write operations only wait for the primary shards to be active before proceeding (that is to say <code>wait_for_active_shards</code> is <code>1</code>).
This default can be overridden in the index settings dynamically by setting <code>index.write.wait_for_active_shards</code>.
To alter this behavior per operation, use the <code>wait_for_active_shards request</code> parameter.
</p>
<p>
Valid values are all or any positive integer up to the total number of configured copies per shard in the index (which is <code>number_of_replicas</code>+1).
Specifying a negative value or a number greater than the number of shard copies will throw an error.
</p>
<p>
For example, suppose you have a cluster of three nodes, A, B, and C and you create an index index with the number of replicas set to 3 (resulting in 4 shard copies, one more copy than there are nodes).
If you attempt an indexing operation, by default the operation will only ensure the primary copy of each shard is available before proceeding.
This means that even if B and C went down and A hosted the primary shard copies, the indexing operation would still proceed with only one copy of the data.
If <code>wait_for_active_shards</code> is set on the request to <code>3</code> (and all three nodes are up), the indexing operation will require 3 active shard copies before proceeding.
This requirement should be met because there are 3 active nodes in the cluster, each one holding a copy of the shard.
However, if you set <code>wait_for_active_shards</code> to <code>all</code> (or to <code>4</code>, which is the same in this situation), the indexing operation will not proceed as you do not have all 4 copies of each shard active in the index.
The operation will timeout unless a new node is brought up in the cluster to host the fourth copy of the shard.
</p>
<p>
It is important to note that this setting greatly reduces the chances of the write operation not writing to the requisite number of shard copies, but it does not completely eliminate the possibility, because this check occurs before the write operation starts.
After the write operation is underway, it is still possible for replication to fail on any number of shard copies but still succeed on the primary.
The <code>_shards</code> section of the API response reveals the number of shard copies on which replication succeeded and failed.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-index_.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual CreateResponse Create&lt;TDocument&gt;(CreateRequest&lt;TDocument&gt; request)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.CreateRequest-1.html">CreateRequest</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.CreateResponse.html">CreateResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Create_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Create*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Create__1___0_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Create``1(``0)">
  Create&lt;TDocument&gt;(TDocument)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L6009"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Create a new document in the index.
</p>
<p>
You can index a new JSON document with the <code>/&lt;target&gt;/_doc/</code> or <code>/&lt;target&gt;/_create/&lt;_id&gt;</code> APIs
Using <code>_create</code> guarantees that the document is indexed only if it does not already exist.
It returns a 409 response when a document with a same ID already exists in the index.
To update an existing document, you must use the <code>/&lt;target&gt;/_doc/</code> API.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or index alias:
</p>
<ul><li>
<p>
To add a document using the <code>PUT /&lt;target&gt;/_create/&lt;_id&gt;</code> or <code>POST /&lt;target&gt;/_create/&lt;_id&gt;</code> request formats, you must have the <code>create_doc</code>, <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To automatically create a data stream or index with this API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege.
</p>
</li></ul>
<p>
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
<strong>Automatically create data streams and indices</strong>
</p>
<p>
If the request's target doesn't exist and matches an index template with a <code>data_stream</code> definition, the index operation automatically creates the data stream.
</p>
<p>
If the target doesn't exist and doesn't match a data stream template, the operation automatically creates the index and applies any matching index templates.
</p>
<p>
NOTE: Elasticsearch includes several built-in index templates. To avoid naming collisions with these templates, refer to index pattern documentation.
</p>
<p>
If no mapping exists, the index operation creates a dynamic mapping.
By default, new fields and objects are automatically added to the mapping if needed.
</p>
<p>
Automatic index creation is controlled by the <code>action.auto_create_index</code> setting.
If it is <code>true</code>, any index can be created automatically.
You can modify this setting to explicitly allow or block automatic creation of indices that match specified patterns or set it to <code>false</code> to turn off automatic index creation entirely.
Specify a comma-separated list of patterns you want to allow or prefix each pattern with <code>+</code> or <code>-</code> to indicate whether it should be allowed or blocked.
When a list is specified, the default behaviour is to disallow.
</p>
<p>
NOTE: The <code>action.auto_create_index</code> setting affects the automatic creation of indices only.
It does not affect the creation of data streams.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
By default, shard placement — or routing — is controlled by using a hash of the document's ID value.
For more explicit control, the value fed into the hash function used by the router can be directly specified on a per-operation basis using the <code>routing</code> parameter.
</p>
<p>
When setting up explicit mapping, you can also use the <code>_routing</code> field to direct the index operation to extract the routing value from the document itself.
This does come at the (very minimal) cost of an additional document parsing pass.
If the <code>_routing</code> mapping is defined and set to be required, the index operation will fail if no routing value is provided or extracted.
</p>
<p>
NOTE: Data streams do not support custom routing unless they were created with the <code>allow_custom_routing</code> setting enabled in the template.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The index operation is directed to the primary shard based on its route and performed on the actual node containing this shard.
After the primary shard completes the operation, if needed, the update is distributed to applicable replicas.
</p>
<p>
<strong>Active shards</strong>
</p>
<p>
To improve the resiliency of writes to the system, indexing operations can be configured to wait for a certain number of active shard copies before proceeding with the operation.
If the requisite number of active shard copies are not available, then the write operation must wait and retry, until either the requisite shard copies have started or a timeout occurs.
By default, write operations only wait for the primary shards to be active before proceeding (that is to say <code>wait_for_active_shards</code> is <code>1</code>).
This default can be overridden in the index settings dynamically by setting <code>index.write.wait_for_active_shards</code>.
To alter this behavior per operation, use the <code>wait_for_active_shards request</code> parameter.
</p>
<p>
Valid values are all or any positive integer up to the total number of configured copies per shard in the index (which is <code>number_of_replicas</code>+1).
Specifying a negative value or a number greater than the number of shard copies will throw an error.
</p>
<p>
For example, suppose you have a cluster of three nodes, A, B, and C and you create an index index with the number of replicas set to 3 (resulting in 4 shard copies, one more copy than there are nodes).
If you attempt an indexing operation, by default the operation will only ensure the primary copy of each shard is available before proceeding.
This means that even if B and C went down and A hosted the primary shard copies, the indexing operation would still proceed with only one copy of the data.
If <code>wait_for_active_shards</code> is set on the request to <code>3</code> (and all three nodes are up), the indexing operation will require 3 active shard copies before proceeding.
This requirement should be met because there are 3 active nodes in the cluster, each one holding a copy of the shard.
However, if you set <code>wait_for_active_shards</code> to <code>all</code> (or to <code>4</code>, which is the same in this situation), the indexing operation will not proceed as you do not have all 4 copies of each shard active in the index.
The operation will timeout unless a new node is brought up in the cluster to host the fourth copy of the shard.
</p>
<p>
It is important to note that this setting greatly reduces the chances of the write operation not writing to the requisite number of shard copies, but it does not completely eliminate the possibility, because this check occurs before the write operation starts.
After the write operation is underway, it is still possible for replication to fail on any number of shard copies but still succeed on the primary.
The <code>_shards</code> section of the API response reveals the number of shard copies on which replication succeeded and failed.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-index_.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual CreateResponse Create&lt;TDocument&gt;(TDocument document)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.CreateResponse.html">CreateResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Create_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Create*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Create__1___0_Elastic_Clients_Elasticsearch_Id_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Create``1(``0,Elastic.Clients.Elasticsearch.Id)">
  Create&lt;TDocument&gt;(TDocument, Id)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L6471"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Create a new document in the index.
</p>
<p>
You can index a new JSON document with the <code>/&lt;target&gt;/_doc/</code> or <code>/&lt;target&gt;/_create/&lt;_id&gt;</code> APIs
Using <code>_create</code> guarantees that the document is indexed only if it does not already exist.
It returns a 409 response when a document with a same ID already exists in the index.
To update an existing document, you must use the <code>/&lt;target&gt;/_doc/</code> API.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or index alias:
</p>
<ul><li>
<p>
To add a document using the <code>PUT /&lt;target&gt;/_create/&lt;_id&gt;</code> or <code>POST /&lt;target&gt;/_create/&lt;_id&gt;</code> request formats, you must have the <code>create_doc</code>, <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To automatically create a data stream or index with this API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege.
</p>
</li></ul>
<p>
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
<strong>Automatically create data streams and indices</strong>
</p>
<p>
If the request's target doesn't exist and matches an index template with a <code>data_stream</code> definition, the index operation automatically creates the data stream.
</p>
<p>
If the target doesn't exist and doesn't match a data stream template, the operation automatically creates the index and applies any matching index templates.
</p>
<p>
NOTE: Elasticsearch includes several built-in index templates. To avoid naming collisions with these templates, refer to index pattern documentation.
</p>
<p>
If no mapping exists, the index operation creates a dynamic mapping.
By default, new fields and objects are automatically added to the mapping if needed.
</p>
<p>
Automatic index creation is controlled by the <code>action.auto_create_index</code> setting.
If it is <code>true</code>, any index can be created automatically.
You can modify this setting to explicitly allow or block automatic creation of indices that match specified patterns or set it to <code>false</code> to turn off automatic index creation entirely.
Specify a comma-separated list of patterns you want to allow or prefix each pattern with <code>+</code> or <code>-</code> to indicate whether it should be allowed or blocked.
When a list is specified, the default behaviour is to disallow.
</p>
<p>
NOTE: The <code>action.auto_create_index</code> setting affects the automatic creation of indices only.
It does not affect the creation of data streams.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
By default, shard placement — or routing — is controlled by using a hash of the document's ID value.
For more explicit control, the value fed into the hash function used by the router can be directly specified on a per-operation basis using the <code>routing</code> parameter.
</p>
<p>
When setting up explicit mapping, you can also use the <code>_routing</code> field to direct the index operation to extract the routing value from the document itself.
This does come at the (very minimal) cost of an additional document parsing pass.
If the <code>_routing</code> mapping is defined and set to be required, the index operation will fail if no routing value is provided or extracted.
</p>
<p>
NOTE: Data streams do not support custom routing unless they were created with the <code>allow_custom_routing</code> setting enabled in the template.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The index operation is directed to the primary shard based on its route and performed on the actual node containing this shard.
After the primary shard completes the operation, if needed, the update is distributed to applicable replicas.
</p>
<p>
<strong>Active shards</strong>
</p>
<p>
To improve the resiliency of writes to the system, indexing operations can be configured to wait for a certain number of active shard copies before proceeding with the operation.
If the requisite number of active shard copies are not available, then the write operation must wait and retry, until either the requisite shard copies have started or a timeout occurs.
By default, write operations only wait for the primary shards to be active before proceeding (that is to say <code>wait_for_active_shards</code> is <code>1</code>).
This default can be overridden in the index settings dynamically by setting <code>index.write.wait_for_active_shards</code>.
To alter this behavior per operation, use the <code>wait_for_active_shards request</code> parameter.
</p>
<p>
Valid values are all or any positive integer up to the total number of configured copies per shard in the index (which is <code>number_of_replicas</code>+1).
Specifying a negative value or a number greater than the number of shard copies will throw an error.
</p>
<p>
For example, suppose you have a cluster of three nodes, A, B, and C and you create an index index with the number of replicas set to 3 (resulting in 4 shard copies, one more copy than there are nodes).
If you attempt an indexing operation, by default the operation will only ensure the primary copy of each shard is available before proceeding.
This means that even if B and C went down and A hosted the primary shard copies, the indexing operation would still proceed with only one copy of the data.
If <code>wait_for_active_shards</code> is set on the request to <code>3</code> (and all three nodes are up), the indexing operation will require 3 active shard copies before proceeding.
This requirement should be met because there are 3 active nodes in the cluster, each one holding a copy of the shard.
However, if you set <code>wait_for_active_shards</code> to <code>all</code> (or to <code>4</code>, which is the same in this situation), the indexing operation will not proceed as you do not have all 4 copies of each shard active in the index.
The operation will timeout unless a new node is brought up in the cluster to host the fourth copy of the shard.
</p>
<p>
It is important to note that this setting greatly reduces the chances of the write operation not writing to the requisite number of shard copies, but it does not completely eliminate the possibility, because this check occurs before the write operation starts.
After the write operation is underway, it is still possible for replication to fail on any number of shard copies but still succeed on the primary.
The <code>_shards</code> section of the API response reveals the number of shard copies on which replication succeeded and failed.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-index_.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual CreateResponse Create&lt;TDocument&gt;(TDocument document, Id id)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.CreateResponse.html">CreateResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Create_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Create*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Create__1___0_Elastic_Clients_Elasticsearch_Id_System_Action_Elastic_Clients_Elasticsearch_CreateRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Create``1(``0,Elastic.Clients.Elasticsearch.Id,System.Action{Elastic.Clients.Elasticsearch.CreateRequestDescriptor{``0}})">
  Create&lt;TDocument&gt;(TDocument, Id, Action&lt;CreateRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L6586"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Create a new document in the index.
</p>
<p>
You can index a new JSON document with the <code>/&lt;target&gt;/_doc/</code> or <code>/&lt;target&gt;/_create/&lt;_id&gt;</code> APIs
Using <code>_create</code> guarantees that the document is indexed only if it does not already exist.
It returns a 409 response when a document with a same ID already exists in the index.
To update an existing document, you must use the <code>/&lt;target&gt;/_doc/</code> API.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or index alias:
</p>
<ul><li>
<p>
To add a document using the <code>PUT /&lt;target&gt;/_create/&lt;_id&gt;</code> or <code>POST /&lt;target&gt;/_create/&lt;_id&gt;</code> request formats, you must have the <code>create_doc</code>, <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To automatically create a data stream or index with this API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege.
</p>
</li></ul>
<p>
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
<strong>Automatically create data streams and indices</strong>
</p>
<p>
If the request's target doesn't exist and matches an index template with a <code>data_stream</code> definition, the index operation automatically creates the data stream.
</p>
<p>
If the target doesn't exist and doesn't match a data stream template, the operation automatically creates the index and applies any matching index templates.
</p>
<p>
NOTE: Elasticsearch includes several built-in index templates. To avoid naming collisions with these templates, refer to index pattern documentation.
</p>
<p>
If no mapping exists, the index operation creates a dynamic mapping.
By default, new fields and objects are automatically added to the mapping if needed.
</p>
<p>
Automatic index creation is controlled by the <code>action.auto_create_index</code> setting.
If it is <code>true</code>, any index can be created automatically.
You can modify this setting to explicitly allow or block automatic creation of indices that match specified patterns or set it to <code>false</code> to turn off automatic index creation entirely.
Specify a comma-separated list of patterns you want to allow or prefix each pattern with <code>+</code> or <code>-</code> to indicate whether it should be allowed or blocked.
When a list is specified, the default behaviour is to disallow.
</p>
<p>
NOTE: The <code>action.auto_create_index</code> setting affects the automatic creation of indices only.
It does not affect the creation of data streams.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
By default, shard placement — or routing — is controlled by using a hash of the document's ID value.
For more explicit control, the value fed into the hash function used by the router can be directly specified on a per-operation basis using the <code>routing</code> parameter.
</p>
<p>
When setting up explicit mapping, you can also use the <code>_routing</code> field to direct the index operation to extract the routing value from the document itself.
This does come at the (very minimal) cost of an additional document parsing pass.
If the <code>_routing</code> mapping is defined and set to be required, the index operation will fail if no routing value is provided or extracted.
</p>
<p>
NOTE: Data streams do not support custom routing unless they were created with the <code>allow_custom_routing</code> setting enabled in the template.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The index operation is directed to the primary shard based on its route and performed on the actual node containing this shard.
After the primary shard completes the operation, if needed, the update is distributed to applicable replicas.
</p>
<p>
<strong>Active shards</strong>
</p>
<p>
To improve the resiliency of writes to the system, indexing operations can be configured to wait for a certain number of active shard copies before proceeding with the operation.
If the requisite number of active shard copies are not available, then the write operation must wait and retry, until either the requisite shard copies have started or a timeout occurs.
By default, write operations only wait for the primary shards to be active before proceeding (that is to say <code>wait_for_active_shards</code> is <code>1</code>).
This default can be overridden in the index settings dynamically by setting <code>index.write.wait_for_active_shards</code>.
To alter this behavior per operation, use the <code>wait_for_active_shards request</code> parameter.
</p>
<p>
Valid values are all or any positive integer up to the total number of configured copies per shard in the index (which is <code>number_of_replicas</code>+1).
Specifying a negative value or a number greater than the number of shard copies will throw an error.
</p>
<p>
For example, suppose you have a cluster of three nodes, A, B, and C and you create an index index with the number of replicas set to 3 (resulting in 4 shard copies, one more copy than there are nodes).
If you attempt an indexing operation, by default the operation will only ensure the primary copy of each shard is available before proceeding.
This means that even if B and C went down and A hosted the primary shard copies, the indexing operation would still proceed with only one copy of the data.
If <code>wait_for_active_shards</code> is set on the request to <code>3</code> (and all three nodes are up), the indexing operation will require 3 active shard copies before proceeding.
This requirement should be met because there are 3 active nodes in the cluster, each one holding a copy of the shard.
However, if you set <code>wait_for_active_shards</code> to <code>all</code> (or to <code>4</code>, which is the same in this situation), the indexing operation will not proceed as you do not have all 4 copies of each shard active in the index.
The operation will timeout unless a new node is brought up in the cluster to host the fourth copy of the shard.
</p>
<p>
It is important to note that this setting greatly reduces the chances of the write operation not writing to the requisite number of shard copies, but it does not completely eliminate the possibility, because this check occurs before the write operation starts.
After the write operation is underway, it is still possible for replication to fail on any number of shard copies but still succeed on the primary.
The <code>_shards</code> section of the API response reveals the number of shard copies on which replication succeeded and failed.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-index_.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual CreateResponse Create&lt;TDocument&gt;(TDocument document, Id id, Action&lt;CreateRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.CreateRequestDescriptor-1.html">CreateRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.CreateResponse.html">CreateResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Create_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Create*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Create__1___0_Elastic_Clients_Elasticsearch_IndexName_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Create``1(``0,Elastic.Clients.Elasticsearch.IndexName)">
  Create&lt;TDocument&gt;(TDocument, IndexName)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L6240"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Create a new document in the index.
</p>
<p>
You can index a new JSON document with the <code>/&lt;target&gt;/_doc/</code> or <code>/&lt;target&gt;/_create/&lt;_id&gt;</code> APIs
Using <code>_create</code> guarantees that the document is indexed only if it does not already exist.
It returns a 409 response when a document with a same ID already exists in the index.
To update an existing document, you must use the <code>/&lt;target&gt;/_doc/</code> API.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or index alias:
</p>
<ul><li>
<p>
To add a document using the <code>PUT /&lt;target&gt;/_create/&lt;_id&gt;</code> or <code>POST /&lt;target&gt;/_create/&lt;_id&gt;</code> request formats, you must have the <code>create_doc</code>, <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To automatically create a data stream or index with this API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege.
</p>
</li></ul>
<p>
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
<strong>Automatically create data streams and indices</strong>
</p>
<p>
If the request's target doesn't exist and matches an index template with a <code>data_stream</code> definition, the index operation automatically creates the data stream.
</p>
<p>
If the target doesn't exist and doesn't match a data stream template, the operation automatically creates the index and applies any matching index templates.
</p>
<p>
NOTE: Elasticsearch includes several built-in index templates. To avoid naming collisions with these templates, refer to index pattern documentation.
</p>
<p>
If no mapping exists, the index operation creates a dynamic mapping.
By default, new fields and objects are automatically added to the mapping if needed.
</p>
<p>
Automatic index creation is controlled by the <code>action.auto_create_index</code> setting.
If it is <code>true</code>, any index can be created automatically.
You can modify this setting to explicitly allow or block automatic creation of indices that match specified patterns or set it to <code>false</code> to turn off automatic index creation entirely.
Specify a comma-separated list of patterns you want to allow or prefix each pattern with <code>+</code> or <code>-</code> to indicate whether it should be allowed or blocked.
When a list is specified, the default behaviour is to disallow.
</p>
<p>
NOTE: The <code>action.auto_create_index</code> setting affects the automatic creation of indices only.
It does not affect the creation of data streams.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
By default, shard placement — or routing — is controlled by using a hash of the document's ID value.
For more explicit control, the value fed into the hash function used by the router can be directly specified on a per-operation basis using the <code>routing</code> parameter.
</p>
<p>
When setting up explicit mapping, you can also use the <code>_routing</code> field to direct the index operation to extract the routing value from the document itself.
This does come at the (very minimal) cost of an additional document parsing pass.
If the <code>_routing</code> mapping is defined and set to be required, the index operation will fail if no routing value is provided or extracted.
</p>
<p>
NOTE: Data streams do not support custom routing unless they were created with the <code>allow_custom_routing</code> setting enabled in the template.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The index operation is directed to the primary shard based on its route and performed on the actual node containing this shard.
After the primary shard completes the operation, if needed, the update is distributed to applicable replicas.
</p>
<p>
<strong>Active shards</strong>
</p>
<p>
To improve the resiliency of writes to the system, indexing operations can be configured to wait for a certain number of active shard copies before proceeding with the operation.
If the requisite number of active shard copies are not available, then the write operation must wait and retry, until either the requisite shard copies have started or a timeout occurs.
By default, write operations only wait for the primary shards to be active before proceeding (that is to say <code>wait_for_active_shards</code> is <code>1</code>).
This default can be overridden in the index settings dynamically by setting <code>index.write.wait_for_active_shards</code>.
To alter this behavior per operation, use the <code>wait_for_active_shards request</code> parameter.
</p>
<p>
Valid values are all or any positive integer up to the total number of configured copies per shard in the index (which is <code>number_of_replicas</code>+1).
Specifying a negative value or a number greater than the number of shard copies will throw an error.
</p>
<p>
For example, suppose you have a cluster of three nodes, A, B, and C and you create an index index with the number of replicas set to 3 (resulting in 4 shard copies, one more copy than there are nodes).
If you attempt an indexing operation, by default the operation will only ensure the primary copy of each shard is available before proceeding.
This means that even if B and C went down and A hosted the primary shard copies, the indexing operation would still proceed with only one copy of the data.
If <code>wait_for_active_shards</code> is set on the request to <code>3</code> (and all three nodes are up), the indexing operation will require 3 active shard copies before proceeding.
This requirement should be met because there are 3 active nodes in the cluster, each one holding a copy of the shard.
However, if you set <code>wait_for_active_shards</code> to <code>all</code> (or to <code>4</code>, which is the same in this situation), the indexing operation will not proceed as you do not have all 4 copies of each shard active in the index.
The operation will timeout unless a new node is brought up in the cluster to host the fourth copy of the shard.
</p>
<p>
It is important to note that this setting greatly reduces the chances of the write operation not writing to the requisite number of shard copies, but it does not completely eliminate the possibility, because this check occurs before the write operation starts.
After the write operation is underway, it is still possible for replication to fail on any number of shard copies but still succeed on the primary.
The <code>_shards</code> section of the API response reveals the number of shard copies on which replication succeeded and failed.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-index_.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual CreateResponse Create&lt;TDocument&gt;(TDocument document, IndexName index)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.CreateResponse.html">CreateResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Create_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Create*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Create__1___0_Elastic_Clients_Elasticsearch_IndexName_Elastic_Clients_Elasticsearch_Id_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Create``1(``0,Elastic.Clients.Elasticsearch.IndexName,Elastic.Clients.Elasticsearch.Id)">
  Create&lt;TDocument&gt;(TDocument, IndexName, Id)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L5778"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Create a new document in the index.
</p>
<p>
You can index a new JSON document with the <code>/&lt;target&gt;/_doc/</code> or <code>/&lt;target&gt;/_create/&lt;_id&gt;</code> APIs
Using <code>_create</code> guarantees that the document is indexed only if it does not already exist.
It returns a 409 response when a document with a same ID already exists in the index.
To update an existing document, you must use the <code>/&lt;target&gt;/_doc/</code> API.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or index alias:
</p>
<ul><li>
<p>
To add a document using the <code>PUT /&lt;target&gt;/_create/&lt;_id&gt;</code> or <code>POST /&lt;target&gt;/_create/&lt;_id&gt;</code> request formats, you must have the <code>create_doc</code>, <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To automatically create a data stream or index with this API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege.
</p>
</li></ul>
<p>
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
<strong>Automatically create data streams and indices</strong>
</p>
<p>
If the request's target doesn't exist and matches an index template with a <code>data_stream</code> definition, the index operation automatically creates the data stream.
</p>
<p>
If the target doesn't exist and doesn't match a data stream template, the operation automatically creates the index and applies any matching index templates.
</p>
<p>
NOTE: Elasticsearch includes several built-in index templates. To avoid naming collisions with these templates, refer to index pattern documentation.
</p>
<p>
If no mapping exists, the index operation creates a dynamic mapping.
By default, new fields and objects are automatically added to the mapping if needed.
</p>
<p>
Automatic index creation is controlled by the <code>action.auto_create_index</code> setting.
If it is <code>true</code>, any index can be created automatically.
You can modify this setting to explicitly allow or block automatic creation of indices that match specified patterns or set it to <code>false</code> to turn off automatic index creation entirely.
Specify a comma-separated list of patterns you want to allow or prefix each pattern with <code>+</code> or <code>-</code> to indicate whether it should be allowed or blocked.
When a list is specified, the default behaviour is to disallow.
</p>
<p>
NOTE: The <code>action.auto_create_index</code> setting affects the automatic creation of indices only.
It does not affect the creation of data streams.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
By default, shard placement — or routing — is controlled by using a hash of the document's ID value.
For more explicit control, the value fed into the hash function used by the router can be directly specified on a per-operation basis using the <code>routing</code> parameter.
</p>
<p>
When setting up explicit mapping, you can also use the <code>_routing</code> field to direct the index operation to extract the routing value from the document itself.
This does come at the (very minimal) cost of an additional document parsing pass.
If the <code>_routing</code> mapping is defined and set to be required, the index operation will fail if no routing value is provided or extracted.
</p>
<p>
NOTE: Data streams do not support custom routing unless they were created with the <code>allow_custom_routing</code> setting enabled in the template.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The index operation is directed to the primary shard based on its route and performed on the actual node containing this shard.
After the primary shard completes the operation, if needed, the update is distributed to applicable replicas.
</p>
<p>
<strong>Active shards</strong>
</p>
<p>
To improve the resiliency of writes to the system, indexing operations can be configured to wait for a certain number of active shard copies before proceeding with the operation.
If the requisite number of active shard copies are not available, then the write operation must wait and retry, until either the requisite shard copies have started or a timeout occurs.
By default, write operations only wait for the primary shards to be active before proceeding (that is to say <code>wait_for_active_shards</code> is <code>1</code>).
This default can be overridden in the index settings dynamically by setting <code>index.write.wait_for_active_shards</code>.
To alter this behavior per operation, use the <code>wait_for_active_shards request</code> parameter.
</p>
<p>
Valid values are all or any positive integer up to the total number of configured copies per shard in the index (which is <code>number_of_replicas</code>+1).
Specifying a negative value or a number greater than the number of shard copies will throw an error.
</p>
<p>
For example, suppose you have a cluster of three nodes, A, B, and C and you create an index index with the number of replicas set to 3 (resulting in 4 shard copies, one more copy than there are nodes).
If you attempt an indexing operation, by default the operation will only ensure the primary copy of each shard is available before proceeding.
This means that even if B and C went down and A hosted the primary shard copies, the indexing operation would still proceed with only one copy of the data.
If <code>wait_for_active_shards</code> is set on the request to <code>3</code> (and all three nodes are up), the indexing operation will require 3 active shard copies before proceeding.
This requirement should be met because there are 3 active nodes in the cluster, each one holding a copy of the shard.
However, if you set <code>wait_for_active_shards</code> to <code>all</code> (or to <code>4</code>, which is the same in this situation), the indexing operation will not proceed as you do not have all 4 copies of each shard active in the index.
The operation will timeout unless a new node is brought up in the cluster to host the fourth copy of the shard.
</p>
<p>
It is important to note that this setting greatly reduces the chances of the write operation not writing to the requisite number of shard copies, but it does not completely eliminate the possibility, because this check occurs before the write operation starts.
After the write operation is underway, it is still possible for replication to fail on any number of shard copies but still succeed on the primary.
The <code>_shards</code> section of the API response reveals the number of shard copies on which replication succeeded and failed.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-index_.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual CreateResponse Create&lt;TDocument&gt;(TDocument document, IndexName index, Id id)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.CreateResponse.html">CreateResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Create_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Create*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Create__1___0_Elastic_Clients_Elasticsearch_IndexName_Elastic_Clients_Elasticsearch_Id_System_Action_Elastic_Clients_Elasticsearch_CreateRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Create``1(``0,Elastic.Clients.Elasticsearch.IndexName,Elastic.Clients.Elasticsearch.Id,System.Action{Elastic.Clients.Elasticsearch.CreateRequestDescriptor{``0}})">
  Create&lt;TDocument&gt;(TDocument, IndexName, Id, Action&lt;CreateRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L5893"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Create a new document in the index.
</p>
<p>
You can index a new JSON document with the <code>/&lt;target&gt;/_doc/</code> or <code>/&lt;target&gt;/_create/&lt;_id&gt;</code> APIs
Using <code>_create</code> guarantees that the document is indexed only if it does not already exist.
It returns a 409 response when a document with a same ID already exists in the index.
To update an existing document, you must use the <code>/&lt;target&gt;/_doc/</code> API.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or index alias:
</p>
<ul><li>
<p>
To add a document using the <code>PUT /&lt;target&gt;/_create/&lt;_id&gt;</code> or <code>POST /&lt;target&gt;/_create/&lt;_id&gt;</code> request formats, you must have the <code>create_doc</code>, <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To automatically create a data stream or index with this API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege.
</p>
</li></ul>
<p>
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
<strong>Automatically create data streams and indices</strong>
</p>
<p>
If the request's target doesn't exist and matches an index template with a <code>data_stream</code> definition, the index operation automatically creates the data stream.
</p>
<p>
If the target doesn't exist and doesn't match a data stream template, the operation automatically creates the index and applies any matching index templates.
</p>
<p>
NOTE: Elasticsearch includes several built-in index templates. To avoid naming collisions with these templates, refer to index pattern documentation.
</p>
<p>
If no mapping exists, the index operation creates a dynamic mapping.
By default, new fields and objects are automatically added to the mapping if needed.
</p>
<p>
Automatic index creation is controlled by the <code>action.auto_create_index</code> setting.
If it is <code>true</code>, any index can be created automatically.
You can modify this setting to explicitly allow or block automatic creation of indices that match specified patterns or set it to <code>false</code> to turn off automatic index creation entirely.
Specify a comma-separated list of patterns you want to allow or prefix each pattern with <code>+</code> or <code>-</code> to indicate whether it should be allowed or blocked.
When a list is specified, the default behaviour is to disallow.
</p>
<p>
NOTE: The <code>action.auto_create_index</code> setting affects the automatic creation of indices only.
It does not affect the creation of data streams.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
By default, shard placement — or routing — is controlled by using a hash of the document's ID value.
For more explicit control, the value fed into the hash function used by the router can be directly specified on a per-operation basis using the <code>routing</code> parameter.
</p>
<p>
When setting up explicit mapping, you can also use the <code>_routing</code> field to direct the index operation to extract the routing value from the document itself.
This does come at the (very minimal) cost of an additional document parsing pass.
If the <code>_routing</code> mapping is defined and set to be required, the index operation will fail if no routing value is provided or extracted.
</p>
<p>
NOTE: Data streams do not support custom routing unless they were created with the <code>allow_custom_routing</code> setting enabled in the template.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The index operation is directed to the primary shard based on its route and performed on the actual node containing this shard.
After the primary shard completes the operation, if needed, the update is distributed to applicable replicas.
</p>
<p>
<strong>Active shards</strong>
</p>
<p>
To improve the resiliency of writes to the system, indexing operations can be configured to wait for a certain number of active shard copies before proceeding with the operation.
If the requisite number of active shard copies are not available, then the write operation must wait and retry, until either the requisite shard copies have started or a timeout occurs.
By default, write operations only wait for the primary shards to be active before proceeding (that is to say <code>wait_for_active_shards</code> is <code>1</code>).
This default can be overridden in the index settings dynamically by setting <code>index.write.wait_for_active_shards</code>.
To alter this behavior per operation, use the <code>wait_for_active_shards request</code> parameter.
</p>
<p>
Valid values are all or any positive integer up to the total number of configured copies per shard in the index (which is <code>number_of_replicas</code>+1).
Specifying a negative value or a number greater than the number of shard copies will throw an error.
</p>
<p>
For example, suppose you have a cluster of three nodes, A, B, and C and you create an index index with the number of replicas set to 3 (resulting in 4 shard copies, one more copy than there are nodes).
If you attempt an indexing operation, by default the operation will only ensure the primary copy of each shard is available before proceeding.
This means that even if B and C went down and A hosted the primary shard copies, the indexing operation would still proceed with only one copy of the data.
If <code>wait_for_active_shards</code> is set on the request to <code>3</code> (and all three nodes are up), the indexing operation will require 3 active shard copies before proceeding.
This requirement should be met because there are 3 active nodes in the cluster, each one holding a copy of the shard.
However, if you set <code>wait_for_active_shards</code> to <code>all</code> (or to <code>4</code>, which is the same in this situation), the indexing operation will not proceed as you do not have all 4 copies of each shard active in the index.
The operation will timeout unless a new node is brought up in the cluster to host the fourth copy of the shard.
</p>
<p>
It is important to note that this setting greatly reduces the chances of the write operation not writing to the requisite number of shard copies, but it does not completely eliminate the possibility, because this check occurs before the write operation starts.
After the write operation is underway, it is still possible for replication to fail on any number of shard copies but still succeed on the primary.
The <code>_shards</code> section of the API response reveals the number of shard copies on which replication succeeded and failed.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-index_.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual CreateResponse Create&lt;TDocument&gt;(TDocument document, IndexName index, Id id, Action&lt;CreateRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.CreateRequestDescriptor-1.html">CreateRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.CreateResponse.html">CreateResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Create_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Create*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Create__1___0_Elastic_Clients_Elasticsearch_IndexName_System_Action_Elastic_Clients_Elasticsearch_CreateRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Create``1(``0,Elastic.Clients.Elasticsearch.IndexName,System.Action{Elastic.Clients.Elasticsearch.CreateRequestDescriptor{``0}})">
  Create&lt;TDocument&gt;(TDocument, IndexName, Action&lt;CreateRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L6355"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Create a new document in the index.
</p>
<p>
You can index a new JSON document with the <code>/&lt;target&gt;/_doc/</code> or <code>/&lt;target&gt;/_create/&lt;_id&gt;</code> APIs
Using <code>_create</code> guarantees that the document is indexed only if it does not already exist.
It returns a 409 response when a document with a same ID already exists in the index.
To update an existing document, you must use the <code>/&lt;target&gt;/_doc/</code> API.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or index alias:
</p>
<ul><li>
<p>
To add a document using the <code>PUT /&lt;target&gt;/_create/&lt;_id&gt;</code> or <code>POST /&lt;target&gt;/_create/&lt;_id&gt;</code> request formats, you must have the <code>create_doc</code>, <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To automatically create a data stream or index with this API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege.
</p>
</li></ul>
<p>
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
<strong>Automatically create data streams and indices</strong>
</p>
<p>
If the request's target doesn't exist and matches an index template with a <code>data_stream</code> definition, the index operation automatically creates the data stream.
</p>
<p>
If the target doesn't exist and doesn't match a data stream template, the operation automatically creates the index and applies any matching index templates.
</p>
<p>
NOTE: Elasticsearch includes several built-in index templates. To avoid naming collisions with these templates, refer to index pattern documentation.
</p>
<p>
If no mapping exists, the index operation creates a dynamic mapping.
By default, new fields and objects are automatically added to the mapping if needed.
</p>
<p>
Automatic index creation is controlled by the <code>action.auto_create_index</code> setting.
If it is <code>true</code>, any index can be created automatically.
You can modify this setting to explicitly allow or block automatic creation of indices that match specified patterns or set it to <code>false</code> to turn off automatic index creation entirely.
Specify a comma-separated list of patterns you want to allow or prefix each pattern with <code>+</code> or <code>-</code> to indicate whether it should be allowed or blocked.
When a list is specified, the default behaviour is to disallow.
</p>
<p>
NOTE: The <code>action.auto_create_index</code> setting affects the automatic creation of indices only.
It does not affect the creation of data streams.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
By default, shard placement — or routing — is controlled by using a hash of the document's ID value.
For more explicit control, the value fed into the hash function used by the router can be directly specified on a per-operation basis using the <code>routing</code> parameter.
</p>
<p>
When setting up explicit mapping, you can also use the <code>_routing</code> field to direct the index operation to extract the routing value from the document itself.
This does come at the (very minimal) cost of an additional document parsing pass.
If the <code>_routing</code> mapping is defined and set to be required, the index operation will fail if no routing value is provided or extracted.
</p>
<p>
NOTE: Data streams do not support custom routing unless they were created with the <code>allow_custom_routing</code> setting enabled in the template.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The index operation is directed to the primary shard based on its route and performed on the actual node containing this shard.
After the primary shard completes the operation, if needed, the update is distributed to applicable replicas.
</p>
<p>
<strong>Active shards</strong>
</p>
<p>
To improve the resiliency of writes to the system, indexing operations can be configured to wait for a certain number of active shard copies before proceeding with the operation.
If the requisite number of active shard copies are not available, then the write operation must wait and retry, until either the requisite shard copies have started or a timeout occurs.
By default, write operations only wait for the primary shards to be active before proceeding (that is to say <code>wait_for_active_shards</code> is <code>1</code>).
This default can be overridden in the index settings dynamically by setting <code>index.write.wait_for_active_shards</code>.
To alter this behavior per operation, use the <code>wait_for_active_shards request</code> parameter.
</p>
<p>
Valid values are all or any positive integer up to the total number of configured copies per shard in the index (which is <code>number_of_replicas</code>+1).
Specifying a negative value or a number greater than the number of shard copies will throw an error.
</p>
<p>
For example, suppose you have a cluster of three nodes, A, B, and C and you create an index index with the number of replicas set to 3 (resulting in 4 shard copies, one more copy than there are nodes).
If you attempt an indexing operation, by default the operation will only ensure the primary copy of each shard is available before proceeding.
This means that even if B and C went down and A hosted the primary shard copies, the indexing operation would still proceed with only one copy of the data.
If <code>wait_for_active_shards</code> is set on the request to <code>3</code> (and all three nodes are up), the indexing operation will require 3 active shard copies before proceeding.
This requirement should be met because there are 3 active nodes in the cluster, each one holding a copy of the shard.
However, if you set <code>wait_for_active_shards</code> to <code>all</code> (or to <code>4</code>, which is the same in this situation), the indexing operation will not proceed as you do not have all 4 copies of each shard active in the index.
The operation will timeout unless a new node is brought up in the cluster to host the fourth copy of the shard.
</p>
<p>
It is important to note that this setting greatly reduces the chances of the write operation not writing to the requisite number of shard copies, but it does not completely eliminate the possibility, because this check occurs before the write operation starts.
After the write operation is underway, it is still possible for replication to fail on any number of shard copies but still succeed on the primary.
The <code>_shards</code> section of the API response reveals the number of shard copies on which replication succeeded and failed.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-index_.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual CreateResponse Create&lt;TDocument&gt;(TDocument document, IndexName index, Action&lt;CreateRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.CreateRequestDescriptor-1.html">CreateRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.CreateResponse.html">CreateResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Create_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Create*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Create__1___0_System_Action_Elastic_Clients_Elasticsearch_CreateRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Create``1(``0,System.Action{Elastic.Clients.Elasticsearch.CreateRequestDescriptor{``0}})">
  Create&lt;TDocument&gt;(TDocument, Action&lt;CreateRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L6124"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Create a new document in the index.
</p>
<p>
You can index a new JSON document with the <code>/&lt;target&gt;/_doc/</code> or <code>/&lt;target&gt;/_create/&lt;_id&gt;</code> APIs
Using <code>_create</code> guarantees that the document is indexed only if it does not already exist.
It returns a 409 response when a document with a same ID already exists in the index.
To update an existing document, you must use the <code>/&lt;target&gt;/_doc/</code> API.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or index alias:
</p>
<ul><li>
<p>
To add a document using the <code>PUT /&lt;target&gt;/_create/&lt;_id&gt;</code> or <code>POST /&lt;target&gt;/_create/&lt;_id&gt;</code> request formats, you must have the <code>create_doc</code>, <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To automatically create a data stream or index with this API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege.
</p>
</li></ul>
<p>
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
<strong>Automatically create data streams and indices</strong>
</p>
<p>
If the request's target doesn't exist and matches an index template with a <code>data_stream</code> definition, the index operation automatically creates the data stream.
</p>
<p>
If the target doesn't exist and doesn't match a data stream template, the operation automatically creates the index and applies any matching index templates.
</p>
<p>
NOTE: Elasticsearch includes several built-in index templates. To avoid naming collisions with these templates, refer to index pattern documentation.
</p>
<p>
If no mapping exists, the index operation creates a dynamic mapping.
By default, new fields and objects are automatically added to the mapping if needed.
</p>
<p>
Automatic index creation is controlled by the <code>action.auto_create_index</code> setting.
If it is <code>true</code>, any index can be created automatically.
You can modify this setting to explicitly allow or block automatic creation of indices that match specified patterns or set it to <code>false</code> to turn off automatic index creation entirely.
Specify a comma-separated list of patterns you want to allow or prefix each pattern with <code>+</code> or <code>-</code> to indicate whether it should be allowed or blocked.
When a list is specified, the default behaviour is to disallow.
</p>
<p>
NOTE: The <code>action.auto_create_index</code> setting affects the automatic creation of indices only.
It does not affect the creation of data streams.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
By default, shard placement — or routing — is controlled by using a hash of the document's ID value.
For more explicit control, the value fed into the hash function used by the router can be directly specified on a per-operation basis using the <code>routing</code> parameter.
</p>
<p>
When setting up explicit mapping, you can also use the <code>_routing</code> field to direct the index operation to extract the routing value from the document itself.
This does come at the (very minimal) cost of an additional document parsing pass.
If the <code>_routing</code> mapping is defined and set to be required, the index operation will fail if no routing value is provided or extracted.
</p>
<p>
NOTE: Data streams do not support custom routing unless they were created with the <code>allow_custom_routing</code> setting enabled in the template.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The index operation is directed to the primary shard based on its route and performed on the actual node containing this shard.
After the primary shard completes the operation, if needed, the update is distributed to applicable replicas.
</p>
<p>
<strong>Active shards</strong>
</p>
<p>
To improve the resiliency of writes to the system, indexing operations can be configured to wait for a certain number of active shard copies before proceeding with the operation.
If the requisite number of active shard copies are not available, then the write operation must wait and retry, until either the requisite shard copies have started or a timeout occurs.
By default, write operations only wait for the primary shards to be active before proceeding (that is to say <code>wait_for_active_shards</code> is <code>1</code>).
This default can be overridden in the index settings dynamically by setting <code>index.write.wait_for_active_shards</code>.
To alter this behavior per operation, use the <code>wait_for_active_shards request</code> parameter.
</p>
<p>
Valid values are all or any positive integer up to the total number of configured copies per shard in the index (which is <code>number_of_replicas</code>+1).
Specifying a negative value or a number greater than the number of shard copies will throw an error.
</p>
<p>
For example, suppose you have a cluster of three nodes, A, B, and C and you create an index index with the number of replicas set to 3 (resulting in 4 shard copies, one more copy than there are nodes).
If you attempt an indexing operation, by default the operation will only ensure the primary copy of each shard is available before proceeding.
This means that even if B and C went down and A hosted the primary shard copies, the indexing operation would still proceed with only one copy of the data.
If <code>wait_for_active_shards</code> is set on the request to <code>3</code> (and all three nodes are up), the indexing operation will require 3 active shard copies before proceeding.
This requirement should be met because there are 3 active nodes in the cluster, each one holding a copy of the shard.
However, if you set <code>wait_for_active_shards</code> to <code>all</code> (or to <code>4</code>, which is the same in this situation), the indexing operation will not proceed as you do not have all 4 copies of each shard active in the index.
The operation will timeout unless a new node is brought up in the cluster to host the fourth copy of the shard.
</p>
<p>
It is important to note that this setting greatly reduces the chances of the write operation not writing to the requisite number of shard copies, but it does not completely eliminate the possibility, because this check occurs before the write operation starts.
After the write operation is underway, it is still possible for replication to fail on any number of shard copies but still succeed on the primary.
The <code>_shards</code> section of the API response reveals the number of shard copies on which replication succeeded and failed.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-index_.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual CreateResponse Create&lt;TDocument&gt;(TDocument document, Action&lt;CreateRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.CreateRequestDescriptor-1.html">CreateRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.CreateResponse.html">CreateResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Delete_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Delete*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Delete_Elastic_Clients_Elasticsearch_DeleteRequest_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Delete(Elastic.Clients.Elasticsearch.DeleteRequest)">
  Delete(DeleteRequest)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L7680"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Delete a document.
</p>
<p>
Remove a JSON document from the specified index.
</p>
<p>
NOTE: You cannot send deletion requests directly to a data stream.
To delete a document in a data stream, you must target the backing index containing the document.
</p>
<p>
<strong>Optimistic concurrency control</strong>
</p>
<p>
Delete operations can be made conditional and only be performed if the last modification to the document was assigned the sequence number and primary term specified by the <code>if_seq_no</code> and <code>if_primary_term</code> parameters.
If a mismatch is detected, the operation will result in a <code>VersionConflictException</code> and a status code of <code>409</code>.
</p>
<p>
<strong>Versioning</strong>
</p>
<p>
Each document indexed is versioned.
When deleting a document, the version can be specified to make sure the relevant document you are trying to delete is actually being deleted and it has not changed in the meantime.
Every write operation run on a document, deletes included, causes its version to be incremented.
The version number of a deleted document remains available for a short time after deletion to allow for control of concurrent operations.
The length of time for which a deleted document's version remains available is determined by the <code>index.gc_deletes</code> index setting.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
If routing is used during indexing, the routing value also needs to be specified to delete a document.
</p>
<p>
If the <code>_routing</code> mapping is set to <code>required</code> and no routing value is specified, the delete API throws a <code>RoutingMissingException</code> and rejects the request.
</p>
<p>
For example:
</p>
<pre><code class="lang-csharp">DELETE /my-index-000001/_doc/1?routing=shard-1</code></pre>
<p>
This request deletes the document with ID 1, but it is routed based on the user.
The document is not deleted if the correct routing is not specified.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The delete operation gets hashed into a specific shard ID.
It then gets redirected into the primary shard within that ID group and replicated (if needed) to shard replicas within that ID group.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-delete.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual DeleteResponse Delete(DeleteRequest request)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.DeleteRequest.html">DeleteRequest</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.DeleteResponse.html">DeleteResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Delete_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Delete*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Delete_Elastic_Clients_Elasticsearch_DeleteRequestDescriptor_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Delete(Elastic.Clients.Elasticsearch.DeleteRequestDescriptor)">
  Delete(DeleteRequestDescriptor)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L8513"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Delete a document.
</p>
<p>
Remove a JSON document from the specified index.
</p>
<p>
NOTE: You cannot send deletion requests directly to a data stream.
To delete a document in a data stream, you must target the backing index containing the document.
</p>
<p>
<strong>Optimistic concurrency control</strong>
</p>
<p>
Delete operations can be made conditional and only be performed if the last modification to the document was assigned the sequence number and primary term specified by the <code>if_seq_no</code> and <code>if_primary_term</code> parameters.
If a mismatch is detected, the operation will result in a <code>VersionConflictException</code> and a status code of <code>409</code>.
</p>
<p>
<strong>Versioning</strong>
</p>
<p>
Each document indexed is versioned.
When deleting a document, the version can be specified to make sure the relevant document you are trying to delete is actually being deleted and it has not changed in the meantime.
Every write operation run on a document, deletes included, causes its version to be incremented.
The version number of a deleted document remains available for a short time after deletion to allow for control of concurrent operations.
The length of time for which a deleted document's version remains available is determined by the <code>index.gc_deletes</code> index setting.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
If routing is used during indexing, the routing value also needs to be specified to delete a document.
</p>
<p>
If the <code>_routing</code> mapping is set to <code>required</code> and no routing value is specified, the delete API throws a <code>RoutingMissingException</code> and rejects the request.
</p>
<p>
For example:
</p>
<pre><code class="lang-csharp">DELETE /my-index-000001/_doc/1?routing=shard-1</code></pre>
<p>
This request deletes the document with ID 1, but it is routed based on the user.
The document is not deleted if the correct routing is not specified.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The delete operation gets hashed into a specific shard ID.
It then gets redirected into the primary shard within that ID group and replicated (if needed) to shard replicas within that ID group.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-delete.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual DeleteResponse Delete(DeleteRequestDescriptor descriptor)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.DeleteRequestDescriptor.html">DeleteRequestDescriptor</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.DeleteResponse.html">DeleteResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Delete_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Delete*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Delete_Elastic_Clients_Elasticsearch_IndexName_Elastic_Clients_Elasticsearch_Id_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Delete(Elastic.Clients.Elasticsearch.IndexName,Elastic.Clients.Elasticsearch.Id)">
  Delete(IndexName, Id)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L8576"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Delete a document.
</p>
<p>
Remove a JSON document from the specified index.
</p>
<p>
NOTE: You cannot send deletion requests directly to a data stream.
To delete a document in a data stream, you must target the backing index containing the document.
</p>
<p>
<strong>Optimistic concurrency control</strong>
</p>
<p>
Delete operations can be made conditional and only be performed if the last modification to the document was assigned the sequence number and primary term specified by the <code>if_seq_no</code> and <code>if_primary_term</code> parameters.
If a mismatch is detected, the operation will result in a <code>VersionConflictException</code> and a status code of <code>409</code>.
</p>
<p>
<strong>Versioning</strong>
</p>
<p>
Each document indexed is versioned.
When deleting a document, the version can be specified to make sure the relevant document you are trying to delete is actually being deleted and it has not changed in the meantime.
Every write operation run on a document, deletes included, causes its version to be incremented.
The version number of a deleted document remains available for a short time after deletion to allow for control of concurrent operations.
The length of time for which a deleted document's version remains available is determined by the <code>index.gc_deletes</code> index setting.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
If routing is used during indexing, the routing value also needs to be specified to delete a document.
</p>
<p>
If the <code>_routing</code> mapping is set to <code>required</code> and no routing value is specified, the delete API throws a <code>RoutingMissingException</code> and rejects the request.
</p>
<p>
For example:
</p>
<pre><code class="lang-csharp">DELETE /my-index-000001/_doc/1?routing=shard-1</code></pre>
<p>
This request deletes the document with ID 1, but it is routed based on the user.
The document is not deleted if the correct routing is not specified.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The delete operation gets hashed into a specific shard ID.
It then gets redirected into the primary shard within that ID group and replicated (if needed) to shard replicas within that ID group.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-delete.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual DeleteResponse Delete(IndexName index, Id id)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.DeleteResponse.html">DeleteResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Delete_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Delete*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Delete_Elastic_Clients_Elasticsearch_IndexName_Elastic_Clients_Elasticsearch_Id_System_Action_Elastic_Clients_Elasticsearch_DeleteRequestDescriptor__" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Delete(Elastic.Clients.Elasticsearch.IndexName,Elastic.Clients.Elasticsearch.Id,System.Action{Elastic.Clients.Elasticsearch.DeleteRequestDescriptor})">
  Delete(IndexName, Id, Action&lt;DeleteRequestDescriptor&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L8640"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Delete a document.
</p>
<p>
Remove a JSON document from the specified index.
</p>
<p>
NOTE: You cannot send deletion requests directly to a data stream.
To delete a document in a data stream, you must target the backing index containing the document.
</p>
<p>
<strong>Optimistic concurrency control</strong>
</p>
<p>
Delete operations can be made conditional and only be performed if the last modification to the document was assigned the sequence number and primary term specified by the <code>if_seq_no</code> and <code>if_primary_term</code> parameters.
If a mismatch is detected, the operation will result in a <code>VersionConflictException</code> and a status code of <code>409</code>.
</p>
<p>
<strong>Versioning</strong>
</p>
<p>
Each document indexed is versioned.
When deleting a document, the version can be specified to make sure the relevant document you are trying to delete is actually being deleted and it has not changed in the meantime.
Every write operation run on a document, deletes included, causes its version to be incremented.
The version number of a deleted document remains available for a short time after deletion to allow for control of concurrent operations.
The length of time for which a deleted document's version remains available is determined by the <code>index.gc_deletes</code> index setting.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
If routing is used during indexing, the routing value also needs to be specified to delete a document.
</p>
<p>
If the <code>_routing</code> mapping is set to <code>required</code> and no routing value is specified, the delete API throws a <code>RoutingMissingException</code> and rejects the request.
</p>
<p>
For example:
</p>
<pre><code class="lang-csharp">DELETE /my-index-000001/_doc/1?routing=shard-1</code></pre>
<p>
This request deletes the document with ID 1, but it is routed based on the user.
The document is not deleted if the correct routing is not specified.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The delete operation gets hashed into a specific shard ID.
It then gets redirected into the primary shard within that ID group and replicated (if needed) to shard replicas within that ID group.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-delete.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual DeleteResponse Delete(IndexName index, Id id, Action&lt;DeleteRequestDescriptor&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.DeleteRequestDescriptor.html">DeleteRequestDescriptor</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.DeleteResponse.html">DeleteResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteAsync_Elastic_Clients_Elasticsearch_DeleteRequest_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteAsync(Elastic.Clients.Elasticsearch.DeleteRequest,System.Threading.CancellationToken)">
  DeleteAsync(DeleteRequest, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L7743"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Delete a document.
</p>
<p>
Remove a JSON document from the specified index.
</p>
<p>
NOTE: You cannot send deletion requests directly to a data stream.
To delete a document in a data stream, you must target the backing index containing the document.
</p>
<p>
<strong>Optimistic concurrency control</strong>
</p>
<p>
Delete operations can be made conditional and only be performed if the last modification to the document was assigned the sequence number and primary term specified by the <code>if_seq_no</code> and <code>if_primary_term</code> parameters.
If a mismatch is detected, the operation will result in a <code>VersionConflictException</code> and a status code of <code>409</code>.
</p>
<p>
<strong>Versioning</strong>
</p>
<p>
Each document indexed is versioned.
When deleting a document, the version can be specified to make sure the relevant document you are trying to delete is actually being deleted and it has not changed in the meantime.
Every write operation run on a document, deletes included, causes its version to be incremented.
The version number of a deleted document remains available for a short time after deletion to allow for control of concurrent operations.
The length of time for which a deleted document's version remains available is determined by the <code>index.gc_deletes</code> index setting.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
If routing is used during indexing, the routing value also needs to be specified to delete a document.
</p>
<p>
If the <code>_routing</code> mapping is set to <code>required</code> and no routing value is specified, the delete API throws a <code>RoutingMissingException</code> and rejects the request.
</p>
<p>
For example:
</p>
<pre><code class="lang-csharp">DELETE /my-index-000001/_doc/1?routing=shard-1</code></pre>
<p>
This request deletes the document with ID 1, but it is routed based on the user.
The document is not deleted if the correct routing is not specified.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The delete operation gets hashed into a specific shard ID.
It then gets redirected into the primary shard within that ID group and replicated (if needed) to shard replicas within that ID group.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-delete.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;DeleteResponse&gt; DeleteAsync(DeleteRequest request, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.DeleteRequest.html">DeleteRequest</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.DeleteResponse.html">DeleteResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteAsync_Elastic_Clients_Elasticsearch_DeleteRequestDescriptor_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteAsync(Elastic.Clients.Elasticsearch.DeleteRequestDescriptor,System.Threading.CancellationToken)">
  DeleteAsync(DeleteRequestDescriptor, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L9402"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Delete a document.
</p>
<p>
Remove a JSON document from the specified index.
</p>
<p>
NOTE: You cannot send deletion requests directly to a data stream.
To delete a document in a data stream, you must target the backing index containing the document.
</p>
<p>
<strong>Optimistic concurrency control</strong>
</p>
<p>
Delete operations can be made conditional and only be performed if the last modification to the document was assigned the sequence number and primary term specified by the <code>if_seq_no</code> and <code>if_primary_term</code> parameters.
If a mismatch is detected, the operation will result in a <code>VersionConflictException</code> and a status code of <code>409</code>.
</p>
<p>
<strong>Versioning</strong>
</p>
<p>
Each document indexed is versioned.
When deleting a document, the version can be specified to make sure the relevant document you are trying to delete is actually being deleted and it has not changed in the meantime.
Every write operation run on a document, deletes included, causes its version to be incremented.
The version number of a deleted document remains available for a short time after deletion to allow for control of concurrent operations.
The length of time for which a deleted document's version remains available is determined by the <code>index.gc_deletes</code> index setting.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
If routing is used during indexing, the routing value also needs to be specified to delete a document.
</p>
<p>
If the <code>_routing</code> mapping is set to <code>required</code> and no routing value is specified, the delete API throws a <code>RoutingMissingException</code> and rejects the request.
</p>
<p>
For example:
</p>
<pre><code class="lang-csharp">DELETE /my-index-000001/_doc/1?routing=shard-1</code></pre>
<p>
This request deletes the document with ID 1, but it is routed based on the user.
The document is not deleted if the correct routing is not specified.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The delete operation gets hashed into a specific shard ID.
It then gets redirected into the primary shard within that ID group and replicated (if needed) to shard replicas within that ID group.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-delete.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;DeleteResponse&gt; DeleteAsync(DeleteRequestDescriptor descriptor, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.DeleteRequestDescriptor.html">DeleteRequestDescriptor</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.DeleteResponse.html">DeleteResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteAsync_Elastic_Clients_Elasticsearch_IndexName_Elastic_Clients_Elasticsearch_Id_System_Action_Elastic_Clients_Elasticsearch_DeleteRequestDescriptor__System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteAsync(Elastic.Clients.Elasticsearch.IndexName,Elastic.Clients.Elasticsearch.Id,System.Action{Elastic.Clients.Elasticsearch.DeleteRequestDescriptor},System.Threading.CancellationToken)">
  DeleteAsync(IndexName, Id, Action&lt;DeleteRequestDescriptor&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L9527"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Delete a document.
</p>
<p>
Remove a JSON document from the specified index.
</p>
<p>
NOTE: You cannot send deletion requests directly to a data stream.
To delete a document in a data stream, you must target the backing index containing the document.
</p>
<p>
<strong>Optimistic concurrency control</strong>
</p>
<p>
Delete operations can be made conditional and only be performed if the last modification to the document was assigned the sequence number and primary term specified by the <code>if_seq_no</code> and <code>if_primary_term</code> parameters.
If a mismatch is detected, the operation will result in a <code>VersionConflictException</code> and a status code of <code>409</code>.
</p>
<p>
<strong>Versioning</strong>
</p>
<p>
Each document indexed is versioned.
When deleting a document, the version can be specified to make sure the relevant document you are trying to delete is actually being deleted and it has not changed in the meantime.
Every write operation run on a document, deletes included, causes its version to be incremented.
The version number of a deleted document remains available for a short time after deletion to allow for control of concurrent operations.
The length of time for which a deleted document's version remains available is determined by the <code>index.gc_deletes</code> index setting.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
If routing is used during indexing, the routing value also needs to be specified to delete a document.
</p>
<p>
If the <code>_routing</code> mapping is set to <code>required</code> and no routing value is specified, the delete API throws a <code>RoutingMissingException</code> and rejects the request.
</p>
<p>
For example:
</p>
<pre><code class="lang-csharp">DELETE /my-index-000001/_doc/1?routing=shard-1</code></pre>
<p>
This request deletes the document with ID 1, but it is routed based on the user.
The document is not deleted if the correct routing is not specified.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The delete operation gets hashed into a specific shard ID.
It then gets redirected into the primary shard within that ID group and replicated (if needed) to shard replicas within that ID group.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-delete.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;DeleteResponse&gt; DeleteAsync(IndexName index, Id id, Action&lt;DeleteRequestDescriptor&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.DeleteRequestDescriptor.html">DeleteRequestDescriptor</a>&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.DeleteResponse.html">DeleteResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteAsync_Elastic_Clients_Elasticsearch_IndexName_Elastic_Clients_Elasticsearch_Id_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteAsync(Elastic.Clients.Elasticsearch.IndexName,Elastic.Clients.Elasticsearch.Id,System.Threading.CancellationToken)">
  DeleteAsync(IndexName, Id, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L9464"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Delete a document.
</p>
<p>
Remove a JSON document from the specified index.
</p>
<p>
NOTE: You cannot send deletion requests directly to a data stream.
To delete a document in a data stream, you must target the backing index containing the document.
</p>
<p>
<strong>Optimistic concurrency control</strong>
</p>
<p>
Delete operations can be made conditional and only be performed if the last modification to the document was assigned the sequence number and primary term specified by the <code>if_seq_no</code> and <code>if_primary_term</code> parameters.
If a mismatch is detected, the operation will result in a <code>VersionConflictException</code> and a status code of <code>409</code>.
</p>
<p>
<strong>Versioning</strong>
</p>
<p>
Each document indexed is versioned.
When deleting a document, the version can be specified to make sure the relevant document you are trying to delete is actually being deleted and it has not changed in the meantime.
Every write operation run on a document, deletes included, causes its version to be incremented.
The version number of a deleted document remains available for a short time after deletion to allow for control of concurrent operations.
The length of time for which a deleted document's version remains available is determined by the <code>index.gc_deletes</code> index setting.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
If routing is used during indexing, the routing value also needs to be specified to delete a document.
</p>
<p>
If the <code>_routing</code> mapping is set to <code>required</code> and no routing value is specified, the delete API throws a <code>RoutingMissingException</code> and rejects the request.
</p>
<p>
For example:
</p>
<pre><code class="lang-csharp">DELETE /my-index-000001/_doc/1?routing=shard-1</code></pre>
<p>
This request deletes the document with ID 1, but it is routed based on the user.
The document is not deleted if the correct routing is not specified.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The delete operation gets hashed into a specific shard ID.
It then gets redirected into the primary shard within that ID group and replicated (if needed) to shard replicas within that ID group.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-delete.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;DeleteResponse&gt; DeleteAsync(IndexName index, Id id, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.DeleteResponse.html">DeleteResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteAsync__1_Elastic_Clients_Elasticsearch_DeleteRequestDescriptor___0__System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteAsync``1(Elastic.Clients.Elasticsearch.DeleteRequestDescriptor{``0},System.Threading.CancellationToken)">
  DeleteAsync&lt;TDocument&gt;(DeleteRequestDescriptor&lt;TDocument&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L8705"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Delete a document.
</p>
<p>
Remove a JSON document from the specified index.
</p>
<p>
NOTE: You cannot send deletion requests directly to a data stream.
To delete a document in a data stream, you must target the backing index containing the document.
</p>
<p>
<strong>Optimistic concurrency control</strong>
</p>
<p>
Delete operations can be made conditional and only be performed if the last modification to the document was assigned the sequence number and primary term specified by the <code>if_seq_no</code> and <code>if_primary_term</code> parameters.
If a mismatch is detected, the operation will result in a <code>VersionConflictException</code> and a status code of <code>409</code>.
</p>
<p>
<strong>Versioning</strong>
</p>
<p>
Each document indexed is versioned.
When deleting a document, the version can be specified to make sure the relevant document you are trying to delete is actually being deleted and it has not changed in the meantime.
Every write operation run on a document, deletes included, causes its version to be incremented.
The version number of a deleted document remains available for a short time after deletion to allow for control of concurrent operations.
The length of time for which a deleted document's version remains available is determined by the <code>index.gc_deletes</code> index setting.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
If routing is used during indexing, the routing value also needs to be specified to delete a document.
</p>
<p>
If the <code>_routing</code> mapping is set to <code>required</code> and no routing value is specified, the delete API throws a <code>RoutingMissingException</code> and rejects the request.
</p>
<p>
For example:
</p>
<pre><code class="lang-csharp">DELETE /my-index-000001/_doc/1?routing=shard-1</code></pre>
<p>
This request deletes the document with ID 1, but it is routed based on the user.
The document is not deleted if the correct routing is not specified.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The delete operation gets hashed into a specific shard ID.
It then gets redirected into the primary shard within that ID group and replicated (if needed) to shard replicas within that ID group.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-delete.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;DeleteResponse&gt; DeleteAsync&lt;TDocument&gt;(DeleteRequestDescriptor&lt;TDocument&gt; descriptor, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.DeleteRequestDescriptor-1.html">DeleteRequestDescriptor</a>&lt;TDocument&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.DeleteResponse.html">DeleteResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteAsync__1_Elastic_Clients_Elasticsearch_Id_System_Action_Elastic_Clients_Elasticsearch_DeleteRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteAsync``1(Elastic.Clients.Elasticsearch.Id,System.Action{Elastic.Clients.Elasticsearch.DeleteRequestDescriptor{``0}},System.Threading.CancellationToken)">
  DeleteAsync&lt;TDocument&gt;(Id, Action&lt;DeleteRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L9338"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Delete a document.
</p>
<p>
Remove a JSON document from the specified index.
</p>
<p>
NOTE: You cannot send deletion requests directly to a data stream.
To delete a document in a data stream, you must target the backing index containing the document.
</p>
<p>
<strong>Optimistic concurrency control</strong>
</p>
<p>
Delete operations can be made conditional and only be performed if the last modification to the document was assigned the sequence number and primary term specified by the <code>if_seq_no</code> and <code>if_primary_term</code> parameters.
If a mismatch is detected, the operation will result in a <code>VersionConflictException</code> and a status code of <code>409</code>.
</p>
<p>
<strong>Versioning</strong>
</p>
<p>
Each document indexed is versioned.
When deleting a document, the version can be specified to make sure the relevant document you are trying to delete is actually being deleted and it has not changed in the meantime.
Every write operation run on a document, deletes included, causes its version to be incremented.
The version number of a deleted document remains available for a short time after deletion to allow for control of concurrent operations.
The length of time for which a deleted document's version remains available is determined by the <code>index.gc_deletes</code> index setting.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
If routing is used during indexing, the routing value also needs to be specified to delete a document.
</p>
<p>
If the <code>_routing</code> mapping is set to <code>required</code> and no routing value is specified, the delete API throws a <code>RoutingMissingException</code> and rejects the request.
</p>
<p>
For example:
</p>
<pre><code class="lang-csharp">DELETE /my-index-000001/_doc/1?routing=shard-1</code></pre>
<p>
This request deletes the document with ID 1, but it is routed based on the user.
The document is not deleted if the correct routing is not specified.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The delete operation gets hashed into a specific shard ID.
It then gets redirected into the primary shard within that ID group and replicated (if needed) to shard replicas within that ID group.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-delete.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;DeleteResponse&gt; DeleteAsync&lt;TDocument&gt;(Id id, Action&lt;DeleteRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.DeleteRequestDescriptor-1.html">DeleteRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.DeleteResponse.html">DeleteResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteAsync__1_Elastic_Clients_Elasticsearch_Id_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteAsync``1(Elastic.Clients.Elasticsearch.Id,System.Threading.CancellationToken)">
  DeleteAsync&lt;TDocument&gt;(Id, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L9275"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Delete a document.
</p>
<p>
Remove a JSON document from the specified index.
</p>
<p>
NOTE: You cannot send deletion requests directly to a data stream.
To delete a document in a data stream, you must target the backing index containing the document.
</p>
<p>
<strong>Optimistic concurrency control</strong>
</p>
<p>
Delete operations can be made conditional and only be performed if the last modification to the document was assigned the sequence number and primary term specified by the <code>if_seq_no</code> and <code>if_primary_term</code> parameters.
If a mismatch is detected, the operation will result in a <code>VersionConflictException</code> and a status code of <code>409</code>.
</p>
<p>
<strong>Versioning</strong>
</p>
<p>
Each document indexed is versioned.
When deleting a document, the version can be specified to make sure the relevant document you are trying to delete is actually being deleted and it has not changed in the meantime.
Every write operation run on a document, deletes included, causes its version to be incremented.
The version number of a deleted document remains available for a short time after deletion to allow for control of concurrent operations.
The length of time for which a deleted document's version remains available is determined by the <code>index.gc_deletes</code> index setting.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
If routing is used during indexing, the routing value also needs to be specified to delete a document.
</p>
<p>
If the <code>_routing</code> mapping is set to <code>required</code> and no routing value is specified, the delete API throws a <code>RoutingMissingException</code> and rejects the request.
</p>
<p>
For example:
</p>
<pre><code class="lang-csharp">DELETE /my-index-000001/_doc/1?routing=shard-1</code></pre>
<p>
This request deletes the document with ID 1, but it is routed based on the user.
The document is not deleted if the correct routing is not specified.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The delete operation gets hashed into a specific shard ID.
It then gets redirected into the primary shard within that ID group and replicated (if needed) to shard replicas within that ID group.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-delete.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;DeleteResponse&gt; DeleteAsync&lt;TDocument&gt;(Id id, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.DeleteResponse.html">DeleteResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteAsync__1_Elastic_Clients_Elasticsearch_IndexName_Elastic_Clients_Elasticsearch_Id_System_Action_Elastic_Clients_Elasticsearch_DeleteRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteAsync``1(Elastic.Clients.Elasticsearch.IndexName,Elastic.Clients.Elasticsearch.Id,System.Action{Elastic.Clients.Elasticsearch.DeleteRequestDescriptor{``0}},System.Threading.CancellationToken)">
  DeleteAsync&lt;TDocument&gt;(IndexName, Id, Action&lt;DeleteRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L8830"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Delete a document.
</p>
<p>
Remove a JSON document from the specified index.
</p>
<p>
NOTE: You cannot send deletion requests directly to a data stream.
To delete a document in a data stream, you must target the backing index containing the document.
</p>
<p>
<strong>Optimistic concurrency control</strong>
</p>
<p>
Delete operations can be made conditional and only be performed if the last modification to the document was assigned the sequence number and primary term specified by the <code>if_seq_no</code> and <code>if_primary_term</code> parameters.
If a mismatch is detected, the operation will result in a <code>VersionConflictException</code> and a status code of <code>409</code>.
</p>
<p>
<strong>Versioning</strong>
</p>
<p>
Each document indexed is versioned.
When deleting a document, the version can be specified to make sure the relevant document you are trying to delete is actually being deleted and it has not changed in the meantime.
Every write operation run on a document, deletes included, causes its version to be incremented.
The version number of a deleted document remains available for a short time after deletion to allow for control of concurrent operations.
The length of time for which a deleted document's version remains available is determined by the <code>index.gc_deletes</code> index setting.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
If routing is used during indexing, the routing value also needs to be specified to delete a document.
</p>
<p>
If the <code>_routing</code> mapping is set to <code>required</code> and no routing value is specified, the delete API throws a <code>RoutingMissingException</code> and rejects the request.
</p>
<p>
For example:
</p>
<pre><code class="lang-csharp">DELETE /my-index-000001/_doc/1?routing=shard-1</code></pre>
<p>
This request deletes the document with ID 1, but it is routed based on the user.
The document is not deleted if the correct routing is not specified.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The delete operation gets hashed into a specific shard ID.
It then gets redirected into the primary shard within that ID group and replicated (if needed) to shard replicas within that ID group.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-delete.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;DeleteResponse&gt; DeleteAsync&lt;TDocument&gt;(IndexName index, Id id, Action&lt;DeleteRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.DeleteRequestDescriptor-1.html">DeleteRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.DeleteResponse.html">DeleteResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteAsync__1_Elastic_Clients_Elasticsearch_IndexName_Elastic_Clients_Elasticsearch_Id_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteAsync``1(Elastic.Clients.Elasticsearch.IndexName,Elastic.Clients.Elasticsearch.Id,System.Threading.CancellationToken)">
  DeleteAsync&lt;TDocument&gt;(IndexName, Id, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L8767"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Delete a document.
</p>
<p>
Remove a JSON document from the specified index.
</p>
<p>
NOTE: You cannot send deletion requests directly to a data stream.
To delete a document in a data stream, you must target the backing index containing the document.
</p>
<p>
<strong>Optimistic concurrency control</strong>
</p>
<p>
Delete operations can be made conditional and only be performed if the last modification to the document was assigned the sequence number and primary term specified by the <code>if_seq_no</code> and <code>if_primary_term</code> parameters.
If a mismatch is detected, the operation will result in a <code>VersionConflictException</code> and a status code of <code>409</code>.
</p>
<p>
<strong>Versioning</strong>
</p>
<p>
Each document indexed is versioned.
When deleting a document, the version can be specified to make sure the relevant document you are trying to delete is actually being deleted and it has not changed in the meantime.
Every write operation run on a document, deletes included, causes its version to be incremented.
The version number of a deleted document remains available for a short time after deletion to allow for control of concurrent operations.
The length of time for which a deleted document's version remains available is determined by the <code>index.gc_deletes</code> index setting.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
If routing is used during indexing, the routing value also needs to be specified to delete a document.
</p>
<p>
If the <code>_routing</code> mapping is set to <code>required</code> and no routing value is specified, the delete API throws a <code>RoutingMissingException</code> and rejects the request.
</p>
<p>
For example:
</p>
<pre><code class="lang-csharp">DELETE /my-index-000001/_doc/1?routing=shard-1</code></pre>
<p>
This request deletes the document with ID 1, but it is routed based on the user.
The document is not deleted if the correct routing is not specified.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The delete operation gets hashed into a specific shard ID.
It then gets redirected into the primary shard within that ID group and replicated (if needed) to shard replicas within that ID group.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-delete.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;DeleteResponse&gt; DeleteAsync&lt;TDocument&gt;(IndexName index, Id id, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.DeleteResponse.html">DeleteResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteAsync__1___0_Elastic_Clients_Elasticsearch_Id_System_Action_Elastic_Clients_Elasticsearch_DeleteRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteAsync``1(``0,Elastic.Clients.Elasticsearch.Id,System.Action{Elastic.Clients.Elasticsearch.DeleteRequestDescriptor{``0}},System.Threading.CancellationToken)">
  DeleteAsync&lt;TDocument&gt;(TDocument, Id, Action&lt;DeleteRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L9211"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Delete a document.
</p>
<p>
Remove a JSON document from the specified index.
</p>
<p>
NOTE: You cannot send deletion requests directly to a data stream.
To delete a document in a data stream, you must target the backing index containing the document.
</p>
<p>
<strong>Optimistic concurrency control</strong>
</p>
<p>
Delete operations can be made conditional and only be performed if the last modification to the document was assigned the sequence number and primary term specified by the <code>if_seq_no</code> and <code>if_primary_term</code> parameters.
If a mismatch is detected, the operation will result in a <code>VersionConflictException</code> and a status code of <code>409</code>.
</p>
<p>
<strong>Versioning</strong>
</p>
<p>
Each document indexed is versioned.
When deleting a document, the version can be specified to make sure the relevant document you are trying to delete is actually being deleted and it has not changed in the meantime.
Every write operation run on a document, deletes included, causes its version to be incremented.
The version number of a deleted document remains available for a short time after deletion to allow for control of concurrent operations.
The length of time for which a deleted document's version remains available is determined by the <code>index.gc_deletes</code> index setting.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
If routing is used during indexing, the routing value also needs to be specified to delete a document.
</p>
<p>
If the <code>_routing</code> mapping is set to <code>required</code> and no routing value is specified, the delete API throws a <code>RoutingMissingException</code> and rejects the request.
</p>
<p>
For example:
</p>
<pre><code class="lang-csharp">DELETE /my-index-000001/_doc/1?routing=shard-1</code></pre>
<p>
This request deletes the document with ID 1, but it is routed based on the user.
The document is not deleted if the correct routing is not specified.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The delete operation gets hashed into a specific shard ID.
It then gets redirected into the primary shard within that ID group and replicated (if needed) to shard replicas within that ID group.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-delete.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;DeleteResponse&gt; DeleteAsync&lt;TDocument&gt;(TDocument document, Id id, Action&lt;DeleteRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.DeleteRequestDescriptor-1.html">DeleteRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.DeleteResponse.html">DeleteResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteAsync__1___0_Elastic_Clients_Elasticsearch_Id_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteAsync``1(``0,Elastic.Clients.Elasticsearch.Id,System.Threading.CancellationToken)">
  DeleteAsync&lt;TDocument&gt;(TDocument, Id, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L9148"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Delete a document.
</p>
<p>
Remove a JSON document from the specified index.
</p>
<p>
NOTE: You cannot send deletion requests directly to a data stream.
To delete a document in a data stream, you must target the backing index containing the document.
</p>
<p>
<strong>Optimistic concurrency control</strong>
</p>
<p>
Delete operations can be made conditional and only be performed if the last modification to the document was assigned the sequence number and primary term specified by the <code>if_seq_no</code> and <code>if_primary_term</code> parameters.
If a mismatch is detected, the operation will result in a <code>VersionConflictException</code> and a status code of <code>409</code>.
</p>
<p>
<strong>Versioning</strong>
</p>
<p>
Each document indexed is versioned.
When deleting a document, the version can be specified to make sure the relevant document you are trying to delete is actually being deleted and it has not changed in the meantime.
Every write operation run on a document, deletes included, causes its version to be incremented.
The version number of a deleted document remains available for a short time after deletion to allow for control of concurrent operations.
The length of time for which a deleted document's version remains available is determined by the <code>index.gc_deletes</code> index setting.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
If routing is used during indexing, the routing value also needs to be specified to delete a document.
</p>
<p>
If the <code>_routing</code> mapping is set to <code>required</code> and no routing value is specified, the delete API throws a <code>RoutingMissingException</code> and rejects the request.
</p>
<p>
For example:
</p>
<pre><code class="lang-csharp">DELETE /my-index-000001/_doc/1?routing=shard-1</code></pre>
<p>
This request deletes the document with ID 1, but it is routed based on the user.
The document is not deleted if the correct routing is not specified.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The delete operation gets hashed into a specific shard ID.
It then gets redirected into the primary shard within that ID group and replicated (if needed) to shard replicas within that ID group.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-delete.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;DeleteResponse&gt; DeleteAsync&lt;TDocument&gt;(TDocument document, Id id, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.DeleteResponse.html">DeleteResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteAsync__1___0_Elastic_Clients_Elasticsearch_IndexName_System_Action_Elastic_Clients_Elasticsearch_DeleteRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteAsync``1(``0,Elastic.Clients.Elasticsearch.IndexName,System.Action{Elastic.Clients.Elasticsearch.DeleteRequestDescriptor{``0}},System.Threading.CancellationToken)">
  DeleteAsync&lt;TDocument&gt;(TDocument, IndexName, Action&lt;DeleteRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L9084"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Delete a document.
</p>
<p>
Remove a JSON document from the specified index.
</p>
<p>
NOTE: You cannot send deletion requests directly to a data stream.
To delete a document in a data stream, you must target the backing index containing the document.
</p>
<p>
<strong>Optimistic concurrency control</strong>
</p>
<p>
Delete operations can be made conditional and only be performed if the last modification to the document was assigned the sequence number and primary term specified by the <code>if_seq_no</code> and <code>if_primary_term</code> parameters.
If a mismatch is detected, the operation will result in a <code>VersionConflictException</code> and a status code of <code>409</code>.
</p>
<p>
<strong>Versioning</strong>
</p>
<p>
Each document indexed is versioned.
When deleting a document, the version can be specified to make sure the relevant document you are trying to delete is actually being deleted and it has not changed in the meantime.
Every write operation run on a document, deletes included, causes its version to be incremented.
The version number of a deleted document remains available for a short time after deletion to allow for control of concurrent operations.
The length of time for which a deleted document's version remains available is determined by the <code>index.gc_deletes</code> index setting.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
If routing is used during indexing, the routing value also needs to be specified to delete a document.
</p>
<p>
If the <code>_routing</code> mapping is set to <code>required</code> and no routing value is specified, the delete API throws a <code>RoutingMissingException</code> and rejects the request.
</p>
<p>
For example:
</p>
<pre><code class="lang-csharp">DELETE /my-index-000001/_doc/1?routing=shard-1</code></pre>
<p>
This request deletes the document with ID 1, but it is routed based on the user.
The document is not deleted if the correct routing is not specified.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The delete operation gets hashed into a specific shard ID.
It then gets redirected into the primary shard within that ID group and replicated (if needed) to shard replicas within that ID group.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-delete.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;DeleteResponse&gt; DeleteAsync&lt;TDocument&gt;(TDocument document, IndexName index, Action&lt;DeleteRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.DeleteRequestDescriptor-1.html">DeleteRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.DeleteResponse.html">DeleteResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteAsync__1___0_Elastic_Clients_Elasticsearch_IndexName_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteAsync``1(``0,Elastic.Clients.Elasticsearch.IndexName,System.Threading.CancellationToken)">
  DeleteAsync&lt;TDocument&gt;(TDocument, IndexName, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L9021"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Delete a document.
</p>
<p>
Remove a JSON document from the specified index.
</p>
<p>
NOTE: You cannot send deletion requests directly to a data stream.
To delete a document in a data stream, you must target the backing index containing the document.
</p>
<p>
<strong>Optimistic concurrency control</strong>
</p>
<p>
Delete operations can be made conditional and only be performed if the last modification to the document was assigned the sequence number and primary term specified by the <code>if_seq_no</code> and <code>if_primary_term</code> parameters.
If a mismatch is detected, the operation will result in a <code>VersionConflictException</code> and a status code of <code>409</code>.
</p>
<p>
<strong>Versioning</strong>
</p>
<p>
Each document indexed is versioned.
When deleting a document, the version can be specified to make sure the relevant document you are trying to delete is actually being deleted and it has not changed in the meantime.
Every write operation run on a document, deletes included, causes its version to be incremented.
The version number of a deleted document remains available for a short time after deletion to allow for control of concurrent operations.
The length of time for which a deleted document's version remains available is determined by the <code>index.gc_deletes</code> index setting.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
If routing is used during indexing, the routing value also needs to be specified to delete a document.
</p>
<p>
If the <code>_routing</code> mapping is set to <code>required</code> and no routing value is specified, the delete API throws a <code>RoutingMissingException</code> and rejects the request.
</p>
<p>
For example:
</p>
<pre><code class="lang-csharp">DELETE /my-index-000001/_doc/1?routing=shard-1</code></pre>
<p>
This request deletes the document with ID 1, but it is routed based on the user.
The document is not deleted if the correct routing is not specified.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The delete operation gets hashed into a specific shard ID.
It then gets redirected into the primary shard within that ID group and replicated (if needed) to shard replicas within that ID group.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-delete.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;DeleteResponse&gt; DeleteAsync&lt;TDocument&gt;(TDocument document, IndexName index, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.DeleteResponse.html">DeleteResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteAsync__1___0_System_Action_Elastic_Clients_Elasticsearch_DeleteRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteAsync``1(``0,System.Action{Elastic.Clients.Elasticsearch.DeleteRequestDescriptor{``0}},System.Threading.CancellationToken)">
  DeleteAsync&lt;TDocument&gt;(TDocument, Action&lt;DeleteRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L8957"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Delete a document.
</p>
<p>
Remove a JSON document from the specified index.
</p>
<p>
NOTE: You cannot send deletion requests directly to a data stream.
To delete a document in a data stream, you must target the backing index containing the document.
</p>
<p>
<strong>Optimistic concurrency control</strong>
</p>
<p>
Delete operations can be made conditional and only be performed if the last modification to the document was assigned the sequence number and primary term specified by the <code>if_seq_no</code> and <code>if_primary_term</code> parameters.
If a mismatch is detected, the operation will result in a <code>VersionConflictException</code> and a status code of <code>409</code>.
</p>
<p>
<strong>Versioning</strong>
</p>
<p>
Each document indexed is versioned.
When deleting a document, the version can be specified to make sure the relevant document you are trying to delete is actually being deleted and it has not changed in the meantime.
Every write operation run on a document, deletes included, causes its version to be incremented.
The version number of a deleted document remains available for a short time after deletion to allow for control of concurrent operations.
The length of time for which a deleted document's version remains available is determined by the <code>index.gc_deletes</code> index setting.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
If routing is used during indexing, the routing value also needs to be specified to delete a document.
</p>
<p>
If the <code>_routing</code> mapping is set to <code>required</code> and no routing value is specified, the delete API throws a <code>RoutingMissingException</code> and rejects the request.
</p>
<p>
For example:
</p>
<pre><code class="lang-csharp">DELETE /my-index-000001/_doc/1?routing=shard-1</code></pre>
<p>
This request deletes the document with ID 1, but it is routed based on the user.
The document is not deleted if the correct routing is not specified.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The delete operation gets hashed into a specific shard ID.
It then gets redirected into the primary shard within that ID group and replicated (if needed) to shard replicas within that ID group.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-delete.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;DeleteResponse&gt; DeleteAsync&lt;TDocument&gt;(TDocument document, Action&lt;DeleteRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.DeleteRequestDescriptor-1.html">DeleteRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.DeleteResponse.html">DeleteResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteAsync__1___0_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteAsync``1(``0,System.Threading.CancellationToken)">
  DeleteAsync&lt;TDocument&gt;(TDocument, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L8894"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Delete a document.
</p>
<p>
Remove a JSON document from the specified index.
</p>
<p>
NOTE: You cannot send deletion requests directly to a data stream.
To delete a document in a data stream, you must target the backing index containing the document.
</p>
<p>
<strong>Optimistic concurrency control</strong>
</p>
<p>
Delete operations can be made conditional and only be performed if the last modification to the document was assigned the sequence number and primary term specified by the <code>if_seq_no</code> and <code>if_primary_term</code> parameters.
If a mismatch is detected, the operation will result in a <code>VersionConflictException</code> and a status code of <code>409</code>.
</p>
<p>
<strong>Versioning</strong>
</p>
<p>
Each document indexed is versioned.
When deleting a document, the version can be specified to make sure the relevant document you are trying to delete is actually being deleted and it has not changed in the meantime.
Every write operation run on a document, deletes included, causes its version to be incremented.
The version number of a deleted document remains available for a short time after deletion to allow for control of concurrent operations.
The length of time for which a deleted document's version remains available is determined by the <code>index.gc_deletes</code> index setting.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
If routing is used during indexing, the routing value also needs to be specified to delete a document.
</p>
<p>
If the <code>_routing</code> mapping is set to <code>required</code> and no routing value is specified, the delete API throws a <code>RoutingMissingException</code> and rejects the request.
</p>
<p>
For example:
</p>
<pre><code class="lang-csharp">DELETE /my-index-000001/_doc/1?routing=shard-1</code></pre>
<p>
This request deletes the document with ID 1, but it is routed based on the user.
The document is not deleted if the correct routing is not specified.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The delete operation gets hashed into a specific shard ID.
It then gets redirected into the primary shard within that ID group and replicated (if needed) to shard replicas within that ID group.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-delete.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;DeleteResponse&gt; DeleteAsync&lt;TDocument&gt;(TDocument document, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.DeleteResponse.html">DeleteResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteByQuery_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteByQuery*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteByQuery_Elastic_Clients_Elasticsearch_DeleteByQueryRequest_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteByQuery(Elastic.Clients.Elasticsearch.DeleteByQueryRequest)">
  DeleteByQuery(DeleteByQueryRequest)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L9688"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Delete documents.
</p>
<p>
Deletes documents that match the specified query.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or alias:
</p>
<ul><li>
<p>
<code>read</code>
</p>
</li><li>
<p>
<code>delete</code> or <code>write</code>
</p>
</li></ul>
<p>
You can specify the query criteria in the request URI or the request body using the same syntax as the search API.
When you submit a delete by query request, Elasticsearch gets a snapshot of the data stream or index when it begins processing the request and deletes matching documents using internal versioning.
If a document changes between the time that the snapshot is taken and the delete operation is processed, it results in a version conflict and the delete operation fails.
</p>
<p>
NOTE: Documents with a version equal to 0 cannot be deleted using delete by query because internal versioning does not support 0 as a valid version number.
</p>
<p>
While processing a delete by query request, Elasticsearch performs multiple search requests sequentially to find all of the matching documents to delete.
A bulk delete request is performed for each batch of matching documents.
If a search or bulk request is rejected, the requests are retried up to 10 times, with exponential back off.
If the maximum retry limit is reached, processing halts and all failed requests are returned in the response.
Any delete requests that completed successfully still stick, they are not rolled back.
</p>
<p>
You can opt to count version conflicts instead of halting and returning by setting <code>conflicts</code> to <code>proceed</code>.
Note that if you opt to count version conflicts the operation could attempt to delete more documents from the source than <code>max_docs</code> until it has successfully deleted <code>max_docs documents</code>, or it has gone through every document in the source query.
</p>
<p>
<strong>Throttling delete requests</strong>
</p>
<p>
To control the rate at which delete by query issues batches of delete operations, you can set <code>requests_per_second</code> to any positive decimal number.
This pads each batch with a wait time to throttle the rate.
Set <code>requests_per_second</code> to <code>-1</code> to disable throttling.
</p>
<p>
Throttling uses a wait time between batches so that the internal scroll requests can be given a timeout that takes the request padding into account.
The padding time is the difference between the batch size divided by the <code>requests_per_second</code> and the time spent writing.
By default the batch size is <code>1000</code>, so if <code>requests_per_second</code> is set to <code>500</code>:
</p>
<pre><code class="lang-csharp">target_time = 1000 / 500 per second = 2 seconds
wait_time = target_time - write_time = 2 seconds - .5 seconds = 1.5 seconds</code></pre>
<p>
Since the batch is issued as a single <code>_bulk</code> request, large batch sizes cause Elasticsearch to create many requests and wait before starting the next set.
This is "bursty" instead of "smooth".
</p>
<p>
<strong>Slicing</strong>
</p>
<p>
Delete by query supports sliced scroll to parallelize the delete process.
This can improve efficiency and provide a convenient way to break the request down into smaller parts.
</p>
<p>
Setting <code>slices</code> to <code>auto</code> lets Elasticsearch choose the number of slices to use.
This setting will use one slice per shard, up to a certain limit.
If there are multiple source data streams or indices, it will choose the number of slices based on the index or backing index with the smallest number of shards.
Adding slices to the delete by query operation creates sub-requests which means it has some quirks:
</p>
<ul><li>
<p>
You can see these requests in the tasks APIs. These sub-requests are "child" tasks of the task for the request with slices.
</p>
</li><li>
<p>
Fetching the status of the task for the request with slices only contains the status of completed slices.
</p>
</li><li>
<p>
These sub-requests are individually addressable for things like cancellation and rethrottling.
</p>
</li><li>
<p>
Rethrottling the request with <code>slices</code> will rethrottle the unfinished sub-request proportionally.
</p>
</li><li>
<p>
Canceling the request with <code>slices</code> will cancel each sub-request.
</p>
</li><li>
<p>
Due to the nature of <code>slices</code> each sub-request won't get a perfectly even portion of the documents. All documents will be addressed, but some slices may be larger than others. Expect larger slices to have a more even distribution.
</p>
</li><li>
<p>
Parameters like <code>requests_per_second</code> and <code>max_docs</code> on a request with <code>slices</code> are distributed proportionally to each sub-request. Combine that with the earlier point about distribution being uneven and you should conclude that using <code>max_docs</code> with <code>slices</code> might not result in exactly <code>max_docs</code> documents being deleted.
</p>
</li><li>
<p>
Each sub-request gets a slightly different snapshot of the source data stream or index though these are all taken at approximately the same time.
</p>
</li></ul>
<p>
If you're slicing manually or otherwise tuning automatic slicing, keep in mind that:
</p>
<ul><li>
<p>
Query performance is most efficient when the number of slices is equal to the number of shards in the index or backing index. If that number is large (for example, 500), choose a lower number as too many <code>slices</code> hurts performance. Setting <code>slices</code> higher than the number of shards generally does not improve efficiency and adds overhead.
</p>
</li><li>
<p>
Delete performance scales linearly across available resources with the number of slices.
</p>
</li></ul>
<p>
Whether query or delete performance dominates the runtime depends on the documents being reindexed and cluster resources.
</p>
<p>
<strong>Cancel a delete by query operation</strong>
</p>
<p>
Any delete by query can be canceled using the task cancel API. For example:
</p>
<pre><code class="lang-csharp">POST _tasks/r1A2WoRbTwKZ516z6NEs5A:36619/_cancel</code></pre>
<p>
The task ID can be found by using the get tasks API.
</p>
<p>
Cancellation should happen quickly but might take a few seconds.
The get task status API will continue to list the delete by query task until this task checks that it has been cancelled and terminates itself.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-delete-by-query.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual DeleteByQueryResponse DeleteByQuery(DeleteByQueryRequest request)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.DeleteByQueryRequest.html">DeleteByQueryRequest</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.DeleteByQueryResponse.html">DeleteByQueryResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteByQuery_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteByQuery*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteByQuery_Elastic_Clients_Elasticsearch_DeleteByQueryRequestDescriptor_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteByQuery(Elastic.Clients.Elasticsearch.DeleteByQueryRequestDescriptor)">
  DeleteByQuery(DeleteByQueryRequestDescriptor)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L10813"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Delete documents.
</p>
<p>
Deletes documents that match the specified query.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or alias:
</p>
<ul><li>
<p>
<code>read</code>
</p>
</li><li>
<p>
<code>delete</code> or <code>write</code>
</p>
</li></ul>
<p>
You can specify the query criteria in the request URI or the request body using the same syntax as the search API.
When you submit a delete by query request, Elasticsearch gets a snapshot of the data stream or index when it begins processing the request and deletes matching documents using internal versioning.
If a document changes between the time that the snapshot is taken and the delete operation is processed, it results in a version conflict and the delete operation fails.
</p>
<p>
NOTE: Documents with a version equal to 0 cannot be deleted using delete by query because internal versioning does not support 0 as a valid version number.
</p>
<p>
While processing a delete by query request, Elasticsearch performs multiple search requests sequentially to find all of the matching documents to delete.
A bulk delete request is performed for each batch of matching documents.
If a search or bulk request is rejected, the requests are retried up to 10 times, with exponential back off.
If the maximum retry limit is reached, processing halts and all failed requests are returned in the response.
Any delete requests that completed successfully still stick, they are not rolled back.
</p>
<p>
You can opt to count version conflicts instead of halting and returning by setting <code>conflicts</code> to <code>proceed</code>.
Note that if you opt to count version conflicts the operation could attempt to delete more documents from the source than <code>max_docs</code> until it has successfully deleted <code>max_docs documents</code>, or it has gone through every document in the source query.
</p>
<p>
<strong>Throttling delete requests</strong>
</p>
<p>
To control the rate at which delete by query issues batches of delete operations, you can set <code>requests_per_second</code> to any positive decimal number.
This pads each batch with a wait time to throttle the rate.
Set <code>requests_per_second</code> to <code>-1</code> to disable throttling.
</p>
<p>
Throttling uses a wait time between batches so that the internal scroll requests can be given a timeout that takes the request padding into account.
The padding time is the difference between the batch size divided by the <code>requests_per_second</code> and the time spent writing.
By default the batch size is <code>1000</code>, so if <code>requests_per_second</code> is set to <code>500</code>:
</p>
<pre><code class="lang-csharp">target_time = 1000 / 500 per second = 2 seconds
wait_time = target_time - write_time = 2 seconds - .5 seconds = 1.5 seconds</code></pre>
<p>
Since the batch is issued as a single <code>_bulk</code> request, large batch sizes cause Elasticsearch to create many requests and wait before starting the next set.
This is "bursty" instead of "smooth".
</p>
<p>
<strong>Slicing</strong>
</p>
<p>
Delete by query supports sliced scroll to parallelize the delete process.
This can improve efficiency and provide a convenient way to break the request down into smaller parts.
</p>
<p>
Setting <code>slices</code> to <code>auto</code> lets Elasticsearch choose the number of slices to use.
This setting will use one slice per shard, up to a certain limit.
If there are multiple source data streams or indices, it will choose the number of slices based on the index or backing index with the smallest number of shards.
Adding slices to the delete by query operation creates sub-requests which means it has some quirks:
</p>
<ul><li>
<p>
You can see these requests in the tasks APIs. These sub-requests are "child" tasks of the task for the request with slices.
</p>
</li><li>
<p>
Fetching the status of the task for the request with slices only contains the status of completed slices.
</p>
</li><li>
<p>
These sub-requests are individually addressable for things like cancellation and rethrottling.
</p>
</li><li>
<p>
Rethrottling the request with <code>slices</code> will rethrottle the unfinished sub-request proportionally.
</p>
</li><li>
<p>
Canceling the request with <code>slices</code> will cancel each sub-request.
</p>
</li><li>
<p>
Due to the nature of <code>slices</code> each sub-request won't get a perfectly even portion of the documents. All documents will be addressed, but some slices may be larger than others. Expect larger slices to have a more even distribution.
</p>
</li><li>
<p>
Parameters like <code>requests_per_second</code> and <code>max_docs</code> on a request with <code>slices</code> are distributed proportionally to each sub-request. Combine that with the earlier point about distribution being uneven and you should conclude that using <code>max_docs</code> with <code>slices</code> might not result in exactly <code>max_docs</code> documents being deleted.
</p>
</li><li>
<p>
Each sub-request gets a slightly different snapshot of the source data stream or index though these are all taken at approximately the same time.
</p>
</li></ul>
<p>
If you're slicing manually or otherwise tuning automatic slicing, keep in mind that:
</p>
<ul><li>
<p>
Query performance is most efficient when the number of slices is equal to the number of shards in the index or backing index. If that number is large (for example, 500), choose a lower number as too many <code>slices</code> hurts performance. Setting <code>slices</code> higher than the number of shards generally does not improve efficiency and adds overhead.
</p>
</li><li>
<p>
Delete performance scales linearly across available resources with the number of slices.
</p>
</li></ul>
<p>
Whether query or delete performance dominates the runtime depends on the documents being reindexed and cluster resources.
</p>
<p>
<strong>Cancel a delete by query operation</strong>
</p>
<p>
Any delete by query can be canceled using the task cancel API. For example:
</p>
<pre><code class="lang-csharp">POST _tasks/r1A2WoRbTwKZ516z6NEs5A:36619/_cancel</code></pre>
<p>
The task ID can be found by using the get tasks API.
</p>
<p>
Cancellation should happen quickly but might take a few seconds.
The get task status API will continue to list the delete by query task until this task checks that it has been cancelled and terminates itself.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-delete-by-query.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual DeleteByQueryResponse DeleteByQuery(DeleteByQueryRequestDescriptor descriptor)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.DeleteByQueryRequestDescriptor.html">DeleteByQueryRequestDescriptor</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.DeleteByQueryResponse.html">DeleteByQueryResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteByQuery_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteByQuery*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteByQuery_Elastic_Clients_Elasticsearch_Indices_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteByQuery(Elastic.Clients.Elasticsearch.Indices)">
  DeleteByQuery(Indices)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L10973"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Delete documents.
</p>
<p>
Deletes documents that match the specified query.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or alias:
</p>
<ul><li>
<p>
<code>read</code>
</p>
</li><li>
<p>
<code>delete</code> or <code>write</code>
</p>
</li></ul>
<p>
You can specify the query criteria in the request URI or the request body using the same syntax as the search API.
When you submit a delete by query request, Elasticsearch gets a snapshot of the data stream or index when it begins processing the request and deletes matching documents using internal versioning.
If a document changes between the time that the snapshot is taken and the delete operation is processed, it results in a version conflict and the delete operation fails.
</p>
<p>
NOTE: Documents with a version equal to 0 cannot be deleted using delete by query because internal versioning does not support 0 as a valid version number.
</p>
<p>
While processing a delete by query request, Elasticsearch performs multiple search requests sequentially to find all of the matching documents to delete.
A bulk delete request is performed for each batch of matching documents.
If a search or bulk request is rejected, the requests are retried up to 10 times, with exponential back off.
If the maximum retry limit is reached, processing halts and all failed requests are returned in the response.
Any delete requests that completed successfully still stick, they are not rolled back.
</p>
<p>
You can opt to count version conflicts instead of halting and returning by setting <code>conflicts</code> to <code>proceed</code>.
Note that if you opt to count version conflicts the operation could attempt to delete more documents from the source than <code>max_docs</code> until it has successfully deleted <code>max_docs documents</code>, or it has gone through every document in the source query.
</p>
<p>
<strong>Throttling delete requests</strong>
</p>
<p>
To control the rate at which delete by query issues batches of delete operations, you can set <code>requests_per_second</code> to any positive decimal number.
This pads each batch with a wait time to throttle the rate.
Set <code>requests_per_second</code> to <code>-1</code> to disable throttling.
</p>
<p>
Throttling uses a wait time between batches so that the internal scroll requests can be given a timeout that takes the request padding into account.
The padding time is the difference between the batch size divided by the <code>requests_per_second</code> and the time spent writing.
By default the batch size is <code>1000</code>, so if <code>requests_per_second</code> is set to <code>500</code>:
</p>
<pre><code class="lang-csharp">target_time = 1000 / 500 per second = 2 seconds
wait_time = target_time - write_time = 2 seconds - .5 seconds = 1.5 seconds</code></pre>
<p>
Since the batch is issued as a single <code>_bulk</code> request, large batch sizes cause Elasticsearch to create many requests and wait before starting the next set.
This is "bursty" instead of "smooth".
</p>
<p>
<strong>Slicing</strong>
</p>
<p>
Delete by query supports sliced scroll to parallelize the delete process.
This can improve efficiency and provide a convenient way to break the request down into smaller parts.
</p>
<p>
Setting <code>slices</code> to <code>auto</code> lets Elasticsearch choose the number of slices to use.
This setting will use one slice per shard, up to a certain limit.
If there are multiple source data streams or indices, it will choose the number of slices based on the index or backing index with the smallest number of shards.
Adding slices to the delete by query operation creates sub-requests which means it has some quirks:
</p>
<ul><li>
<p>
You can see these requests in the tasks APIs. These sub-requests are "child" tasks of the task for the request with slices.
</p>
</li><li>
<p>
Fetching the status of the task for the request with slices only contains the status of completed slices.
</p>
</li><li>
<p>
These sub-requests are individually addressable for things like cancellation and rethrottling.
</p>
</li><li>
<p>
Rethrottling the request with <code>slices</code> will rethrottle the unfinished sub-request proportionally.
</p>
</li><li>
<p>
Canceling the request with <code>slices</code> will cancel each sub-request.
</p>
</li><li>
<p>
Due to the nature of <code>slices</code> each sub-request won't get a perfectly even portion of the documents. All documents will be addressed, but some slices may be larger than others. Expect larger slices to have a more even distribution.
</p>
</li><li>
<p>
Parameters like <code>requests_per_second</code> and <code>max_docs</code> on a request with <code>slices</code> are distributed proportionally to each sub-request. Combine that with the earlier point about distribution being uneven and you should conclude that using <code>max_docs</code> with <code>slices</code> might not result in exactly <code>max_docs</code> documents being deleted.
</p>
</li><li>
<p>
Each sub-request gets a slightly different snapshot of the source data stream or index though these are all taken at approximately the same time.
</p>
</li></ul>
<p>
If you're slicing manually or otherwise tuning automatic slicing, keep in mind that:
</p>
<ul><li>
<p>
Query performance is most efficient when the number of slices is equal to the number of shards in the index or backing index. If that number is large (for example, 500), choose a lower number as too many <code>slices</code> hurts performance. Setting <code>slices</code> higher than the number of shards generally does not improve efficiency and adds overhead.
</p>
</li><li>
<p>
Delete performance scales linearly across available resources with the number of slices.
</p>
</li></ul>
<p>
Whether query or delete performance dominates the runtime depends on the documents being reindexed and cluster resources.
</p>
<p>
<strong>Cancel a delete by query operation</strong>
</p>
<p>
Any delete by query can be canceled using the task cancel API. For example:
</p>
<pre><code class="lang-csharp">POST _tasks/r1A2WoRbTwKZ516z6NEs5A:36619/_cancel</code></pre>
<p>
The task ID can be found by using the get tasks API.
</p>
<p>
Cancellation should happen quickly but might take a few seconds.
The get task status API will continue to list the delete by query task until this task checks that it has been cancelled and terminates itself.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-delete-by-query.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual DeleteByQueryResponse DeleteByQuery(Indices indices)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>indices</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Indices.html">Indices</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.DeleteByQueryResponse.html">DeleteByQueryResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteByQuery_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteByQuery*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteByQuery_Elastic_Clients_Elasticsearch_Indices_System_Action_Elastic_Clients_Elasticsearch_DeleteByQueryRequestDescriptor__" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteByQuery(Elastic.Clients.Elasticsearch.Indices,System.Action{Elastic.Clients.Elasticsearch.DeleteByQueryRequestDescriptor})">
  DeleteByQuery(Indices, Action&lt;DeleteByQueryRequestDescriptor&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L11134"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Delete documents.
</p>
<p>
Deletes documents that match the specified query.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or alias:
</p>
<ul><li>
<p>
<code>read</code>
</p>
</li><li>
<p>
<code>delete</code> or <code>write</code>
</p>
</li></ul>
<p>
You can specify the query criteria in the request URI or the request body using the same syntax as the search API.
When you submit a delete by query request, Elasticsearch gets a snapshot of the data stream or index when it begins processing the request and deletes matching documents using internal versioning.
If a document changes between the time that the snapshot is taken and the delete operation is processed, it results in a version conflict and the delete operation fails.
</p>
<p>
NOTE: Documents with a version equal to 0 cannot be deleted using delete by query because internal versioning does not support 0 as a valid version number.
</p>
<p>
While processing a delete by query request, Elasticsearch performs multiple search requests sequentially to find all of the matching documents to delete.
A bulk delete request is performed for each batch of matching documents.
If a search or bulk request is rejected, the requests are retried up to 10 times, with exponential back off.
If the maximum retry limit is reached, processing halts and all failed requests are returned in the response.
Any delete requests that completed successfully still stick, they are not rolled back.
</p>
<p>
You can opt to count version conflicts instead of halting and returning by setting <code>conflicts</code> to <code>proceed</code>.
Note that if you opt to count version conflicts the operation could attempt to delete more documents from the source than <code>max_docs</code> until it has successfully deleted <code>max_docs documents</code>, or it has gone through every document in the source query.
</p>
<p>
<strong>Throttling delete requests</strong>
</p>
<p>
To control the rate at which delete by query issues batches of delete operations, you can set <code>requests_per_second</code> to any positive decimal number.
This pads each batch with a wait time to throttle the rate.
Set <code>requests_per_second</code> to <code>-1</code> to disable throttling.
</p>
<p>
Throttling uses a wait time between batches so that the internal scroll requests can be given a timeout that takes the request padding into account.
The padding time is the difference between the batch size divided by the <code>requests_per_second</code> and the time spent writing.
By default the batch size is <code>1000</code>, so if <code>requests_per_second</code> is set to <code>500</code>:
</p>
<pre><code class="lang-csharp">target_time = 1000 / 500 per second = 2 seconds
wait_time = target_time - write_time = 2 seconds - .5 seconds = 1.5 seconds</code></pre>
<p>
Since the batch is issued as a single <code>_bulk</code> request, large batch sizes cause Elasticsearch to create many requests and wait before starting the next set.
This is "bursty" instead of "smooth".
</p>
<p>
<strong>Slicing</strong>
</p>
<p>
Delete by query supports sliced scroll to parallelize the delete process.
This can improve efficiency and provide a convenient way to break the request down into smaller parts.
</p>
<p>
Setting <code>slices</code> to <code>auto</code> lets Elasticsearch choose the number of slices to use.
This setting will use one slice per shard, up to a certain limit.
If there are multiple source data streams or indices, it will choose the number of slices based on the index or backing index with the smallest number of shards.
Adding slices to the delete by query operation creates sub-requests which means it has some quirks:
</p>
<ul><li>
<p>
You can see these requests in the tasks APIs. These sub-requests are "child" tasks of the task for the request with slices.
</p>
</li><li>
<p>
Fetching the status of the task for the request with slices only contains the status of completed slices.
</p>
</li><li>
<p>
These sub-requests are individually addressable for things like cancellation and rethrottling.
</p>
</li><li>
<p>
Rethrottling the request with <code>slices</code> will rethrottle the unfinished sub-request proportionally.
</p>
</li><li>
<p>
Canceling the request with <code>slices</code> will cancel each sub-request.
</p>
</li><li>
<p>
Due to the nature of <code>slices</code> each sub-request won't get a perfectly even portion of the documents. All documents will be addressed, but some slices may be larger than others. Expect larger slices to have a more even distribution.
</p>
</li><li>
<p>
Parameters like <code>requests_per_second</code> and <code>max_docs</code> on a request with <code>slices</code> are distributed proportionally to each sub-request. Combine that with the earlier point about distribution being uneven and you should conclude that using <code>max_docs</code> with <code>slices</code> might not result in exactly <code>max_docs</code> documents being deleted.
</p>
</li><li>
<p>
Each sub-request gets a slightly different snapshot of the source data stream or index though these are all taken at approximately the same time.
</p>
</li></ul>
<p>
If you're slicing manually or otherwise tuning automatic slicing, keep in mind that:
</p>
<ul><li>
<p>
Query performance is most efficient when the number of slices is equal to the number of shards in the index or backing index. If that number is large (for example, 500), choose a lower number as too many <code>slices</code> hurts performance. Setting <code>slices</code> higher than the number of shards generally does not improve efficiency and adds overhead.
</p>
</li><li>
<p>
Delete performance scales linearly across available resources with the number of slices.
</p>
</li></ul>
<p>
Whether query or delete performance dominates the runtime depends on the documents being reindexed and cluster resources.
</p>
<p>
<strong>Cancel a delete by query operation</strong>
</p>
<p>
Any delete by query can be canceled using the task cancel API. For example:
</p>
<pre><code class="lang-csharp">POST _tasks/r1A2WoRbTwKZ516z6NEs5A:36619/_cancel</code></pre>
<p>
The task ID can be found by using the get tasks API.
</p>
<p>
Cancellation should happen quickly but might take a few seconds.
The get task status API will continue to list the delete by query task until this task checks that it has been cancelled and terminates itself.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-delete-by-query.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual DeleteByQueryResponse DeleteByQuery(Indices indices, Action&lt;DeleteByQueryRequestDescriptor&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>indices</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Indices.html">Indices</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.DeleteByQueryRequestDescriptor.html">DeleteByQueryRequestDescriptor</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.DeleteByQueryResponse.html">DeleteByQueryResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteByQueryAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteByQueryAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteByQueryAsync_Elastic_Clients_Elasticsearch_DeleteByQueryRequest_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteByQueryAsync(Elastic.Clients.Elasticsearch.DeleteByQueryRequest,System.Threading.CancellationToken)">
  DeleteByQueryAsync(DeleteByQueryRequest, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L9848"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Delete documents.
</p>
<p>
Deletes documents that match the specified query.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or alias:
</p>
<ul><li>
<p>
<code>read</code>
</p>
</li><li>
<p>
<code>delete</code> or <code>write</code>
</p>
</li></ul>
<p>
You can specify the query criteria in the request URI or the request body using the same syntax as the search API.
When you submit a delete by query request, Elasticsearch gets a snapshot of the data stream or index when it begins processing the request and deletes matching documents using internal versioning.
If a document changes between the time that the snapshot is taken and the delete operation is processed, it results in a version conflict and the delete operation fails.
</p>
<p>
NOTE: Documents with a version equal to 0 cannot be deleted using delete by query because internal versioning does not support 0 as a valid version number.
</p>
<p>
While processing a delete by query request, Elasticsearch performs multiple search requests sequentially to find all of the matching documents to delete.
A bulk delete request is performed for each batch of matching documents.
If a search or bulk request is rejected, the requests are retried up to 10 times, with exponential back off.
If the maximum retry limit is reached, processing halts and all failed requests are returned in the response.
Any delete requests that completed successfully still stick, they are not rolled back.
</p>
<p>
You can opt to count version conflicts instead of halting and returning by setting <code>conflicts</code> to <code>proceed</code>.
Note that if you opt to count version conflicts the operation could attempt to delete more documents from the source than <code>max_docs</code> until it has successfully deleted <code>max_docs documents</code>, or it has gone through every document in the source query.
</p>
<p>
<strong>Throttling delete requests</strong>
</p>
<p>
To control the rate at which delete by query issues batches of delete operations, you can set <code>requests_per_second</code> to any positive decimal number.
This pads each batch with a wait time to throttle the rate.
Set <code>requests_per_second</code> to <code>-1</code> to disable throttling.
</p>
<p>
Throttling uses a wait time between batches so that the internal scroll requests can be given a timeout that takes the request padding into account.
The padding time is the difference between the batch size divided by the <code>requests_per_second</code> and the time spent writing.
By default the batch size is <code>1000</code>, so if <code>requests_per_second</code> is set to <code>500</code>:
</p>
<pre><code class="lang-csharp">target_time = 1000 / 500 per second = 2 seconds
wait_time = target_time - write_time = 2 seconds - .5 seconds = 1.5 seconds</code></pre>
<p>
Since the batch is issued as a single <code>_bulk</code> request, large batch sizes cause Elasticsearch to create many requests and wait before starting the next set.
This is "bursty" instead of "smooth".
</p>
<p>
<strong>Slicing</strong>
</p>
<p>
Delete by query supports sliced scroll to parallelize the delete process.
This can improve efficiency and provide a convenient way to break the request down into smaller parts.
</p>
<p>
Setting <code>slices</code> to <code>auto</code> lets Elasticsearch choose the number of slices to use.
This setting will use one slice per shard, up to a certain limit.
If there are multiple source data streams or indices, it will choose the number of slices based on the index or backing index with the smallest number of shards.
Adding slices to the delete by query operation creates sub-requests which means it has some quirks:
</p>
<ul><li>
<p>
You can see these requests in the tasks APIs. These sub-requests are "child" tasks of the task for the request with slices.
</p>
</li><li>
<p>
Fetching the status of the task for the request with slices only contains the status of completed slices.
</p>
</li><li>
<p>
These sub-requests are individually addressable for things like cancellation and rethrottling.
</p>
</li><li>
<p>
Rethrottling the request with <code>slices</code> will rethrottle the unfinished sub-request proportionally.
</p>
</li><li>
<p>
Canceling the request with <code>slices</code> will cancel each sub-request.
</p>
</li><li>
<p>
Due to the nature of <code>slices</code> each sub-request won't get a perfectly even portion of the documents. All documents will be addressed, but some slices may be larger than others. Expect larger slices to have a more even distribution.
</p>
</li><li>
<p>
Parameters like <code>requests_per_second</code> and <code>max_docs</code> on a request with <code>slices</code> are distributed proportionally to each sub-request. Combine that with the earlier point about distribution being uneven and you should conclude that using <code>max_docs</code> with <code>slices</code> might not result in exactly <code>max_docs</code> documents being deleted.
</p>
</li><li>
<p>
Each sub-request gets a slightly different snapshot of the source data stream or index though these are all taken at approximately the same time.
</p>
</li></ul>
<p>
If you're slicing manually or otherwise tuning automatic slicing, keep in mind that:
</p>
<ul><li>
<p>
Query performance is most efficient when the number of slices is equal to the number of shards in the index or backing index. If that number is large (for example, 500), choose a lower number as too many <code>slices</code> hurts performance. Setting <code>slices</code> higher than the number of shards generally does not improve efficiency and adds overhead.
</p>
</li><li>
<p>
Delete performance scales linearly across available resources with the number of slices.
</p>
</li></ul>
<p>
Whether query or delete performance dominates the runtime depends on the documents being reindexed and cluster resources.
</p>
<p>
<strong>Cancel a delete by query operation</strong>
</p>
<p>
Any delete by query can be canceled using the task cancel API. For example:
</p>
<pre><code class="lang-csharp">POST _tasks/r1A2WoRbTwKZ516z6NEs5A:36619/_cancel</code></pre>
<p>
The task ID can be found by using the get tasks API.
</p>
<p>
Cancellation should happen quickly but might take a few seconds.
The get task status API will continue to list the delete by query task until this task checks that it has been cancelled and terminates itself.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-delete-by-query.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;DeleteByQueryResponse&gt; DeleteByQueryAsync(DeleteByQueryRequest request, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.DeleteByQueryRequest.html">DeleteByQueryRequest</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.DeleteByQueryResponse.html">DeleteByQueryResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteByQueryAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteByQueryAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteByQueryAsync_Elastic_Clients_Elasticsearch_DeleteByQueryRequestDescriptor_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteByQueryAsync(Elastic.Clients.Elasticsearch.DeleteByQueryRequestDescriptor,System.Threading.CancellationToken)">
  DeleteByQueryAsync(DeleteByQueryRequestDescriptor, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L12097"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Delete documents.
</p>
<p>
Deletes documents that match the specified query.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or alias:
</p>
<ul><li>
<p>
<code>read</code>
</p>
</li><li>
<p>
<code>delete</code> or <code>write</code>
</p>
</li></ul>
<p>
You can specify the query criteria in the request URI or the request body using the same syntax as the search API.
When you submit a delete by query request, Elasticsearch gets a snapshot of the data stream or index when it begins processing the request and deletes matching documents using internal versioning.
If a document changes between the time that the snapshot is taken and the delete operation is processed, it results in a version conflict and the delete operation fails.
</p>
<p>
NOTE: Documents with a version equal to 0 cannot be deleted using delete by query because internal versioning does not support 0 as a valid version number.
</p>
<p>
While processing a delete by query request, Elasticsearch performs multiple search requests sequentially to find all of the matching documents to delete.
A bulk delete request is performed for each batch of matching documents.
If a search or bulk request is rejected, the requests are retried up to 10 times, with exponential back off.
If the maximum retry limit is reached, processing halts and all failed requests are returned in the response.
Any delete requests that completed successfully still stick, they are not rolled back.
</p>
<p>
You can opt to count version conflicts instead of halting and returning by setting <code>conflicts</code> to <code>proceed</code>.
Note that if you opt to count version conflicts the operation could attempt to delete more documents from the source than <code>max_docs</code> until it has successfully deleted <code>max_docs documents</code>, or it has gone through every document in the source query.
</p>
<p>
<strong>Throttling delete requests</strong>
</p>
<p>
To control the rate at which delete by query issues batches of delete operations, you can set <code>requests_per_second</code> to any positive decimal number.
This pads each batch with a wait time to throttle the rate.
Set <code>requests_per_second</code> to <code>-1</code> to disable throttling.
</p>
<p>
Throttling uses a wait time between batches so that the internal scroll requests can be given a timeout that takes the request padding into account.
The padding time is the difference between the batch size divided by the <code>requests_per_second</code> and the time spent writing.
By default the batch size is <code>1000</code>, so if <code>requests_per_second</code> is set to <code>500</code>:
</p>
<pre><code class="lang-csharp">target_time = 1000 / 500 per second = 2 seconds
wait_time = target_time - write_time = 2 seconds - .5 seconds = 1.5 seconds</code></pre>
<p>
Since the batch is issued as a single <code>_bulk</code> request, large batch sizes cause Elasticsearch to create many requests and wait before starting the next set.
This is "bursty" instead of "smooth".
</p>
<p>
<strong>Slicing</strong>
</p>
<p>
Delete by query supports sliced scroll to parallelize the delete process.
This can improve efficiency and provide a convenient way to break the request down into smaller parts.
</p>
<p>
Setting <code>slices</code> to <code>auto</code> lets Elasticsearch choose the number of slices to use.
This setting will use one slice per shard, up to a certain limit.
If there are multiple source data streams or indices, it will choose the number of slices based on the index or backing index with the smallest number of shards.
Adding slices to the delete by query operation creates sub-requests which means it has some quirks:
</p>
<ul><li>
<p>
You can see these requests in the tasks APIs. These sub-requests are "child" tasks of the task for the request with slices.
</p>
</li><li>
<p>
Fetching the status of the task for the request with slices only contains the status of completed slices.
</p>
</li><li>
<p>
These sub-requests are individually addressable for things like cancellation and rethrottling.
</p>
</li><li>
<p>
Rethrottling the request with <code>slices</code> will rethrottle the unfinished sub-request proportionally.
</p>
</li><li>
<p>
Canceling the request with <code>slices</code> will cancel each sub-request.
</p>
</li><li>
<p>
Due to the nature of <code>slices</code> each sub-request won't get a perfectly even portion of the documents. All documents will be addressed, but some slices may be larger than others. Expect larger slices to have a more even distribution.
</p>
</li><li>
<p>
Parameters like <code>requests_per_second</code> and <code>max_docs</code> on a request with <code>slices</code> are distributed proportionally to each sub-request. Combine that with the earlier point about distribution being uneven and you should conclude that using <code>max_docs</code> with <code>slices</code> might not result in exactly <code>max_docs</code> documents being deleted.
</p>
</li><li>
<p>
Each sub-request gets a slightly different snapshot of the source data stream or index though these are all taken at approximately the same time.
</p>
</li></ul>
<p>
If you're slicing manually or otherwise tuning automatic slicing, keep in mind that:
</p>
<ul><li>
<p>
Query performance is most efficient when the number of slices is equal to the number of shards in the index or backing index. If that number is large (for example, 500), choose a lower number as too many <code>slices</code> hurts performance. Setting <code>slices</code> higher than the number of shards generally does not improve efficiency and adds overhead.
</p>
</li><li>
<p>
Delete performance scales linearly across available resources with the number of slices.
</p>
</li></ul>
<p>
Whether query or delete performance dominates the runtime depends on the documents being reindexed and cluster resources.
</p>
<p>
<strong>Cancel a delete by query operation</strong>
</p>
<p>
Any delete by query can be canceled using the task cancel API. For example:
</p>
<pre><code class="lang-csharp">POST _tasks/r1A2WoRbTwKZ516z6NEs5A:36619/_cancel</code></pre>
<p>
The task ID can be found by using the get tasks API.
</p>
<p>
Cancellation should happen quickly but might take a few seconds.
The get task status API will continue to list the delete by query task until this task checks that it has been cancelled and terminates itself.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-delete-by-query.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;DeleteByQueryResponse&gt; DeleteByQueryAsync(DeleteByQueryRequestDescriptor descriptor, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.DeleteByQueryRequestDescriptor.html">DeleteByQueryRequestDescriptor</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.DeleteByQueryResponse.html">DeleteByQueryResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteByQueryAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteByQueryAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteByQueryAsync_Elastic_Clients_Elasticsearch_Indices_System_Action_Elastic_Clients_Elasticsearch_DeleteByQueryRequestDescriptor__System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteByQueryAsync(Elastic.Clients.Elasticsearch.Indices,System.Action{Elastic.Clients.Elasticsearch.DeleteByQueryRequestDescriptor},System.Threading.CancellationToken)">
  DeleteByQueryAsync(Indices, Action&lt;DeleteByQueryRequestDescriptor&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L12416"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Delete documents.
</p>
<p>
Deletes documents that match the specified query.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or alias:
</p>
<ul><li>
<p>
<code>read</code>
</p>
</li><li>
<p>
<code>delete</code> or <code>write</code>
</p>
</li></ul>
<p>
You can specify the query criteria in the request URI or the request body using the same syntax as the search API.
When you submit a delete by query request, Elasticsearch gets a snapshot of the data stream or index when it begins processing the request and deletes matching documents using internal versioning.
If a document changes between the time that the snapshot is taken and the delete operation is processed, it results in a version conflict and the delete operation fails.
</p>
<p>
NOTE: Documents with a version equal to 0 cannot be deleted using delete by query because internal versioning does not support 0 as a valid version number.
</p>
<p>
While processing a delete by query request, Elasticsearch performs multiple search requests sequentially to find all of the matching documents to delete.
A bulk delete request is performed for each batch of matching documents.
If a search or bulk request is rejected, the requests are retried up to 10 times, with exponential back off.
If the maximum retry limit is reached, processing halts and all failed requests are returned in the response.
Any delete requests that completed successfully still stick, they are not rolled back.
</p>
<p>
You can opt to count version conflicts instead of halting and returning by setting <code>conflicts</code> to <code>proceed</code>.
Note that if you opt to count version conflicts the operation could attempt to delete more documents from the source than <code>max_docs</code> until it has successfully deleted <code>max_docs documents</code>, or it has gone through every document in the source query.
</p>
<p>
<strong>Throttling delete requests</strong>
</p>
<p>
To control the rate at which delete by query issues batches of delete operations, you can set <code>requests_per_second</code> to any positive decimal number.
This pads each batch with a wait time to throttle the rate.
Set <code>requests_per_second</code> to <code>-1</code> to disable throttling.
</p>
<p>
Throttling uses a wait time between batches so that the internal scroll requests can be given a timeout that takes the request padding into account.
The padding time is the difference between the batch size divided by the <code>requests_per_second</code> and the time spent writing.
By default the batch size is <code>1000</code>, so if <code>requests_per_second</code> is set to <code>500</code>:
</p>
<pre><code class="lang-csharp">target_time = 1000 / 500 per second = 2 seconds
wait_time = target_time - write_time = 2 seconds - .5 seconds = 1.5 seconds</code></pre>
<p>
Since the batch is issued as a single <code>_bulk</code> request, large batch sizes cause Elasticsearch to create many requests and wait before starting the next set.
This is "bursty" instead of "smooth".
</p>
<p>
<strong>Slicing</strong>
</p>
<p>
Delete by query supports sliced scroll to parallelize the delete process.
This can improve efficiency and provide a convenient way to break the request down into smaller parts.
</p>
<p>
Setting <code>slices</code> to <code>auto</code> lets Elasticsearch choose the number of slices to use.
This setting will use one slice per shard, up to a certain limit.
If there are multiple source data streams or indices, it will choose the number of slices based on the index or backing index with the smallest number of shards.
Adding slices to the delete by query operation creates sub-requests which means it has some quirks:
</p>
<ul><li>
<p>
You can see these requests in the tasks APIs. These sub-requests are "child" tasks of the task for the request with slices.
</p>
</li><li>
<p>
Fetching the status of the task for the request with slices only contains the status of completed slices.
</p>
</li><li>
<p>
These sub-requests are individually addressable for things like cancellation and rethrottling.
</p>
</li><li>
<p>
Rethrottling the request with <code>slices</code> will rethrottle the unfinished sub-request proportionally.
</p>
</li><li>
<p>
Canceling the request with <code>slices</code> will cancel each sub-request.
</p>
</li><li>
<p>
Due to the nature of <code>slices</code> each sub-request won't get a perfectly even portion of the documents. All documents will be addressed, but some slices may be larger than others. Expect larger slices to have a more even distribution.
</p>
</li><li>
<p>
Parameters like <code>requests_per_second</code> and <code>max_docs</code> on a request with <code>slices</code> are distributed proportionally to each sub-request. Combine that with the earlier point about distribution being uneven and you should conclude that using <code>max_docs</code> with <code>slices</code> might not result in exactly <code>max_docs</code> documents being deleted.
</p>
</li><li>
<p>
Each sub-request gets a slightly different snapshot of the source data stream or index though these are all taken at approximately the same time.
</p>
</li></ul>
<p>
If you're slicing manually or otherwise tuning automatic slicing, keep in mind that:
</p>
<ul><li>
<p>
Query performance is most efficient when the number of slices is equal to the number of shards in the index or backing index. If that number is large (for example, 500), choose a lower number as too many <code>slices</code> hurts performance. Setting <code>slices</code> higher than the number of shards generally does not improve efficiency and adds overhead.
</p>
</li><li>
<p>
Delete performance scales linearly across available resources with the number of slices.
</p>
</li></ul>
<p>
Whether query or delete performance dominates the runtime depends on the documents being reindexed and cluster resources.
</p>
<p>
<strong>Cancel a delete by query operation</strong>
</p>
<p>
Any delete by query can be canceled using the task cancel API. For example:
</p>
<pre><code class="lang-csharp">POST _tasks/r1A2WoRbTwKZ516z6NEs5A:36619/_cancel</code></pre>
<p>
The task ID can be found by using the get tasks API.
</p>
<p>
Cancellation should happen quickly but might take a few seconds.
The get task status API will continue to list the delete by query task until this task checks that it has been cancelled and terminates itself.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-delete-by-query.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;DeleteByQueryResponse&gt; DeleteByQueryAsync(Indices indices, Action&lt;DeleteByQueryRequestDescriptor&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>indices</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Indices.html">Indices</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.DeleteByQueryRequestDescriptor.html">DeleteByQueryRequestDescriptor</a>&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.DeleteByQueryResponse.html">DeleteByQueryResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteByQueryAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteByQueryAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteByQueryAsync_Elastic_Clients_Elasticsearch_Indices_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteByQueryAsync(Elastic.Clients.Elasticsearch.Indices,System.Threading.CancellationToken)">
  DeleteByQueryAsync(Indices, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L12256"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Delete documents.
</p>
<p>
Deletes documents that match the specified query.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or alias:
</p>
<ul><li>
<p>
<code>read</code>
</p>
</li><li>
<p>
<code>delete</code> or <code>write</code>
</p>
</li></ul>
<p>
You can specify the query criteria in the request URI or the request body using the same syntax as the search API.
When you submit a delete by query request, Elasticsearch gets a snapshot of the data stream or index when it begins processing the request and deletes matching documents using internal versioning.
If a document changes between the time that the snapshot is taken and the delete operation is processed, it results in a version conflict and the delete operation fails.
</p>
<p>
NOTE: Documents with a version equal to 0 cannot be deleted using delete by query because internal versioning does not support 0 as a valid version number.
</p>
<p>
While processing a delete by query request, Elasticsearch performs multiple search requests sequentially to find all of the matching documents to delete.
A bulk delete request is performed for each batch of matching documents.
If a search or bulk request is rejected, the requests are retried up to 10 times, with exponential back off.
If the maximum retry limit is reached, processing halts and all failed requests are returned in the response.
Any delete requests that completed successfully still stick, they are not rolled back.
</p>
<p>
You can opt to count version conflicts instead of halting and returning by setting <code>conflicts</code> to <code>proceed</code>.
Note that if you opt to count version conflicts the operation could attempt to delete more documents from the source than <code>max_docs</code> until it has successfully deleted <code>max_docs documents</code>, or it has gone through every document in the source query.
</p>
<p>
<strong>Throttling delete requests</strong>
</p>
<p>
To control the rate at which delete by query issues batches of delete operations, you can set <code>requests_per_second</code> to any positive decimal number.
This pads each batch with a wait time to throttle the rate.
Set <code>requests_per_second</code> to <code>-1</code> to disable throttling.
</p>
<p>
Throttling uses a wait time between batches so that the internal scroll requests can be given a timeout that takes the request padding into account.
The padding time is the difference between the batch size divided by the <code>requests_per_second</code> and the time spent writing.
By default the batch size is <code>1000</code>, so if <code>requests_per_second</code> is set to <code>500</code>:
</p>
<pre><code class="lang-csharp">target_time = 1000 / 500 per second = 2 seconds
wait_time = target_time - write_time = 2 seconds - .5 seconds = 1.5 seconds</code></pre>
<p>
Since the batch is issued as a single <code>_bulk</code> request, large batch sizes cause Elasticsearch to create many requests and wait before starting the next set.
This is "bursty" instead of "smooth".
</p>
<p>
<strong>Slicing</strong>
</p>
<p>
Delete by query supports sliced scroll to parallelize the delete process.
This can improve efficiency and provide a convenient way to break the request down into smaller parts.
</p>
<p>
Setting <code>slices</code> to <code>auto</code> lets Elasticsearch choose the number of slices to use.
This setting will use one slice per shard, up to a certain limit.
If there are multiple source data streams or indices, it will choose the number of slices based on the index or backing index with the smallest number of shards.
Adding slices to the delete by query operation creates sub-requests which means it has some quirks:
</p>
<ul><li>
<p>
You can see these requests in the tasks APIs. These sub-requests are "child" tasks of the task for the request with slices.
</p>
</li><li>
<p>
Fetching the status of the task for the request with slices only contains the status of completed slices.
</p>
</li><li>
<p>
These sub-requests are individually addressable for things like cancellation and rethrottling.
</p>
</li><li>
<p>
Rethrottling the request with <code>slices</code> will rethrottle the unfinished sub-request proportionally.
</p>
</li><li>
<p>
Canceling the request with <code>slices</code> will cancel each sub-request.
</p>
</li><li>
<p>
Due to the nature of <code>slices</code> each sub-request won't get a perfectly even portion of the documents. All documents will be addressed, but some slices may be larger than others. Expect larger slices to have a more even distribution.
</p>
</li><li>
<p>
Parameters like <code>requests_per_second</code> and <code>max_docs</code> on a request with <code>slices</code> are distributed proportionally to each sub-request. Combine that with the earlier point about distribution being uneven and you should conclude that using <code>max_docs</code> with <code>slices</code> might not result in exactly <code>max_docs</code> documents being deleted.
</p>
</li><li>
<p>
Each sub-request gets a slightly different snapshot of the source data stream or index though these are all taken at approximately the same time.
</p>
</li></ul>
<p>
If you're slicing manually or otherwise tuning automatic slicing, keep in mind that:
</p>
<ul><li>
<p>
Query performance is most efficient when the number of slices is equal to the number of shards in the index or backing index. If that number is large (for example, 500), choose a lower number as too many <code>slices</code> hurts performance. Setting <code>slices</code> higher than the number of shards generally does not improve efficiency and adds overhead.
</p>
</li><li>
<p>
Delete performance scales linearly across available resources with the number of slices.
</p>
</li></ul>
<p>
Whether query or delete performance dominates the runtime depends on the documents being reindexed and cluster resources.
</p>
<p>
<strong>Cancel a delete by query operation</strong>
</p>
<p>
Any delete by query can be canceled using the task cancel API. For example:
</p>
<pre><code class="lang-csharp">POST _tasks/r1A2WoRbTwKZ516z6NEs5A:36619/_cancel</code></pre>
<p>
The task ID can be found by using the get tasks API.
</p>
<p>
Cancellation should happen quickly but might take a few seconds.
The get task status API will continue to list the delete by query task until this task checks that it has been cancelled and terminates itself.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-delete-by-query.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;DeleteByQueryResponse&gt; DeleteByQueryAsync(Indices indices, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>indices</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Indices.html">Indices</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.DeleteByQueryResponse.html">DeleteByQueryResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteByQueryAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteByQueryAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteByQueryAsync__1_Elastic_Clients_Elasticsearch_DeleteByQueryRequestDescriptor___0__System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteByQueryAsync``1(Elastic.Clients.Elasticsearch.DeleteByQueryRequestDescriptor{``0},System.Threading.CancellationToken)">
  DeleteByQueryAsync&lt;TDocument&gt;(DeleteByQueryRequestDescriptor&lt;TDocument&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L11296"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Delete documents.
</p>
<p>
Deletes documents that match the specified query.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or alias:
</p>
<ul><li>
<p>
<code>read</code>
</p>
</li><li>
<p>
<code>delete</code> or <code>write</code>
</p>
</li></ul>
<p>
You can specify the query criteria in the request URI or the request body using the same syntax as the search API.
When you submit a delete by query request, Elasticsearch gets a snapshot of the data stream or index when it begins processing the request and deletes matching documents using internal versioning.
If a document changes between the time that the snapshot is taken and the delete operation is processed, it results in a version conflict and the delete operation fails.
</p>
<p>
NOTE: Documents with a version equal to 0 cannot be deleted using delete by query because internal versioning does not support 0 as a valid version number.
</p>
<p>
While processing a delete by query request, Elasticsearch performs multiple search requests sequentially to find all of the matching documents to delete.
A bulk delete request is performed for each batch of matching documents.
If a search or bulk request is rejected, the requests are retried up to 10 times, with exponential back off.
If the maximum retry limit is reached, processing halts and all failed requests are returned in the response.
Any delete requests that completed successfully still stick, they are not rolled back.
</p>
<p>
You can opt to count version conflicts instead of halting and returning by setting <code>conflicts</code> to <code>proceed</code>.
Note that if you opt to count version conflicts the operation could attempt to delete more documents from the source than <code>max_docs</code> until it has successfully deleted <code>max_docs documents</code>, or it has gone through every document in the source query.
</p>
<p>
<strong>Throttling delete requests</strong>
</p>
<p>
To control the rate at which delete by query issues batches of delete operations, you can set <code>requests_per_second</code> to any positive decimal number.
This pads each batch with a wait time to throttle the rate.
Set <code>requests_per_second</code> to <code>-1</code> to disable throttling.
</p>
<p>
Throttling uses a wait time between batches so that the internal scroll requests can be given a timeout that takes the request padding into account.
The padding time is the difference between the batch size divided by the <code>requests_per_second</code> and the time spent writing.
By default the batch size is <code>1000</code>, so if <code>requests_per_second</code> is set to <code>500</code>:
</p>
<pre><code class="lang-csharp">target_time = 1000 / 500 per second = 2 seconds
wait_time = target_time - write_time = 2 seconds - .5 seconds = 1.5 seconds</code></pre>
<p>
Since the batch is issued as a single <code>_bulk</code> request, large batch sizes cause Elasticsearch to create many requests and wait before starting the next set.
This is "bursty" instead of "smooth".
</p>
<p>
<strong>Slicing</strong>
</p>
<p>
Delete by query supports sliced scroll to parallelize the delete process.
This can improve efficiency and provide a convenient way to break the request down into smaller parts.
</p>
<p>
Setting <code>slices</code> to <code>auto</code> lets Elasticsearch choose the number of slices to use.
This setting will use one slice per shard, up to a certain limit.
If there are multiple source data streams or indices, it will choose the number of slices based on the index or backing index with the smallest number of shards.
Adding slices to the delete by query operation creates sub-requests which means it has some quirks:
</p>
<ul><li>
<p>
You can see these requests in the tasks APIs. These sub-requests are "child" tasks of the task for the request with slices.
</p>
</li><li>
<p>
Fetching the status of the task for the request with slices only contains the status of completed slices.
</p>
</li><li>
<p>
These sub-requests are individually addressable for things like cancellation and rethrottling.
</p>
</li><li>
<p>
Rethrottling the request with <code>slices</code> will rethrottle the unfinished sub-request proportionally.
</p>
</li><li>
<p>
Canceling the request with <code>slices</code> will cancel each sub-request.
</p>
</li><li>
<p>
Due to the nature of <code>slices</code> each sub-request won't get a perfectly even portion of the documents. All documents will be addressed, but some slices may be larger than others. Expect larger slices to have a more even distribution.
</p>
</li><li>
<p>
Parameters like <code>requests_per_second</code> and <code>max_docs</code> on a request with <code>slices</code> are distributed proportionally to each sub-request. Combine that with the earlier point about distribution being uneven and you should conclude that using <code>max_docs</code> with <code>slices</code> might not result in exactly <code>max_docs</code> documents being deleted.
</p>
</li><li>
<p>
Each sub-request gets a slightly different snapshot of the source data stream or index though these are all taken at approximately the same time.
</p>
</li></ul>
<p>
If you're slicing manually or otherwise tuning automatic slicing, keep in mind that:
</p>
<ul><li>
<p>
Query performance is most efficient when the number of slices is equal to the number of shards in the index or backing index. If that number is large (for example, 500), choose a lower number as too many <code>slices</code> hurts performance. Setting <code>slices</code> higher than the number of shards generally does not improve efficiency and adds overhead.
</p>
</li><li>
<p>
Delete performance scales linearly across available resources with the number of slices.
</p>
</li></ul>
<p>
Whether query or delete performance dominates the runtime depends on the documents being reindexed and cluster resources.
</p>
<p>
<strong>Cancel a delete by query operation</strong>
</p>
<p>
Any delete by query can be canceled using the task cancel API. For example:
</p>
<pre><code class="lang-csharp">POST _tasks/r1A2WoRbTwKZ516z6NEs5A:36619/_cancel</code></pre>
<p>
The task ID can be found by using the get tasks API.
</p>
<p>
Cancellation should happen quickly but might take a few seconds.
The get task status API will continue to list the delete by query task until this task checks that it has been cancelled and terminates itself.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-delete-by-query.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;DeleteByQueryResponse&gt; DeleteByQueryAsync&lt;TDocument&gt;(DeleteByQueryRequestDescriptor&lt;TDocument&gt; descriptor, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.DeleteByQueryRequestDescriptor-1.html">DeleteByQueryRequestDescriptor</a>&lt;TDocument&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.DeleteByQueryResponse.html">DeleteByQueryResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteByQueryAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteByQueryAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteByQueryAsync__1_Elastic_Clients_Elasticsearch_Indices_System_Action_Elastic_Clients_Elasticsearch_DeleteByQueryRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteByQueryAsync``1(Elastic.Clients.Elasticsearch.Indices,System.Action{Elastic.Clients.Elasticsearch.DeleteByQueryRequestDescriptor{``0}},System.Threading.CancellationToken)">
  DeleteByQueryAsync&lt;TDocument&gt;(Indices, Action&lt;DeleteByQueryRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L11615"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Delete documents.
</p>
<p>
Deletes documents that match the specified query.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or alias:
</p>
<ul><li>
<p>
<code>read</code>
</p>
</li><li>
<p>
<code>delete</code> or <code>write</code>
</p>
</li></ul>
<p>
You can specify the query criteria in the request URI or the request body using the same syntax as the search API.
When you submit a delete by query request, Elasticsearch gets a snapshot of the data stream or index when it begins processing the request and deletes matching documents using internal versioning.
If a document changes between the time that the snapshot is taken and the delete operation is processed, it results in a version conflict and the delete operation fails.
</p>
<p>
NOTE: Documents with a version equal to 0 cannot be deleted using delete by query because internal versioning does not support 0 as a valid version number.
</p>
<p>
While processing a delete by query request, Elasticsearch performs multiple search requests sequentially to find all of the matching documents to delete.
A bulk delete request is performed for each batch of matching documents.
If a search or bulk request is rejected, the requests are retried up to 10 times, with exponential back off.
If the maximum retry limit is reached, processing halts and all failed requests are returned in the response.
Any delete requests that completed successfully still stick, they are not rolled back.
</p>
<p>
You can opt to count version conflicts instead of halting and returning by setting <code>conflicts</code> to <code>proceed</code>.
Note that if you opt to count version conflicts the operation could attempt to delete more documents from the source than <code>max_docs</code> until it has successfully deleted <code>max_docs documents</code>, or it has gone through every document in the source query.
</p>
<p>
<strong>Throttling delete requests</strong>
</p>
<p>
To control the rate at which delete by query issues batches of delete operations, you can set <code>requests_per_second</code> to any positive decimal number.
This pads each batch with a wait time to throttle the rate.
Set <code>requests_per_second</code> to <code>-1</code> to disable throttling.
</p>
<p>
Throttling uses a wait time between batches so that the internal scroll requests can be given a timeout that takes the request padding into account.
The padding time is the difference between the batch size divided by the <code>requests_per_second</code> and the time spent writing.
By default the batch size is <code>1000</code>, so if <code>requests_per_second</code> is set to <code>500</code>:
</p>
<pre><code class="lang-csharp">target_time = 1000 / 500 per second = 2 seconds
wait_time = target_time - write_time = 2 seconds - .5 seconds = 1.5 seconds</code></pre>
<p>
Since the batch is issued as a single <code>_bulk</code> request, large batch sizes cause Elasticsearch to create many requests and wait before starting the next set.
This is "bursty" instead of "smooth".
</p>
<p>
<strong>Slicing</strong>
</p>
<p>
Delete by query supports sliced scroll to parallelize the delete process.
This can improve efficiency and provide a convenient way to break the request down into smaller parts.
</p>
<p>
Setting <code>slices</code> to <code>auto</code> lets Elasticsearch choose the number of slices to use.
This setting will use one slice per shard, up to a certain limit.
If there are multiple source data streams or indices, it will choose the number of slices based on the index or backing index with the smallest number of shards.
Adding slices to the delete by query operation creates sub-requests which means it has some quirks:
</p>
<ul><li>
<p>
You can see these requests in the tasks APIs. These sub-requests are "child" tasks of the task for the request with slices.
</p>
</li><li>
<p>
Fetching the status of the task for the request with slices only contains the status of completed slices.
</p>
</li><li>
<p>
These sub-requests are individually addressable for things like cancellation and rethrottling.
</p>
</li><li>
<p>
Rethrottling the request with <code>slices</code> will rethrottle the unfinished sub-request proportionally.
</p>
</li><li>
<p>
Canceling the request with <code>slices</code> will cancel each sub-request.
</p>
</li><li>
<p>
Due to the nature of <code>slices</code> each sub-request won't get a perfectly even portion of the documents. All documents will be addressed, but some slices may be larger than others. Expect larger slices to have a more even distribution.
</p>
</li><li>
<p>
Parameters like <code>requests_per_second</code> and <code>max_docs</code> on a request with <code>slices</code> are distributed proportionally to each sub-request. Combine that with the earlier point about distribution being uneven and you should conclude that using <code>max_docs</code> with <code>slices</code> might not result in exactly <code>max_docs</code> documents being deleted.
</p>
</li><li>
<p>
Each sub-request gets a slightly different snapshot of the source data stream or index though these are all taken at approximately the same time.
</p>
</li></ul>
<p>
If you're slicing manually or otherwise tuning automatic slicing, keep in mind that:
</p>
<ul><li>
<p>
Query performance is most efficient when the number of slices is equal to the number of shards in the index or backing index. If that number is large (for example, 500), choose a lower number as too many <code>slices</code> hurts performance. Setting <code>slices</code> higher than the number of shards generally does not improve efficiency and adds overhead.
</p>
</li><li>
<p>
Delete performance scales linearly across available resources with the number of slices.
</p>
</li></ul>
<p>
Whether query or delete performance dominates the runtime depends on the documents being reindexed and cluster resources.
</p>
<p>
<strong>Cancel a delete by query operation</strong>
</p>
<p>
Any delete by query can be canceled using the task cancel API. For example:
</p>
<pre><code class="lang-csharp">POST _tasks/r1A2WoRbTwKZ516z6NEs5A:36619/_cancel</code></pre>
<p>
The task ID can be found by using the get tasks API.
</p>
<p>
Cancellation should happen quickly but might take a few seconds.
The get task status API will continue to list the delete by query task until this task checks that it has been cancelled and terminates itself.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-delete-by-query.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;DeleteByQueryResponse&gt; DeleteByQueryAsync&lt;TDocument&gt;(Indices indices, Action&lt;DeleteByQueryRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>indices</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Indices.html">Indices</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.DeleteByQueryRequestDescriptor-1.html">DeleteByQueryRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.DeleteByQueryResponse.html">DeleteByQueryResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteByQueryAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteByQueryAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteByQueryAsync__1_Elastic_Clients_Elasticsearch_Indices_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteByQueryAsync``1(Elastic.Clients.Elasticsearch.Indices,System.Threading.CancellationToken)">
  DeleteByQueryAsync&lt;TDocument&gt;(Indices, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L11455"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Delete documents.
</p>
<p>
Deletes documents that match the specified query.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or alias:
</p>
<ul><li>
<p>
<code>read</code>
</p>
</li><li>
<p>
<code>delete</code> or <code>write</code>
</p>
</li></ul>
<p>
You can specify the query criteria in the request URI or the request body using the same syntax as the search API.
When you submit a delete by query request, Elasticsearch gets a snapshot of the data stream or index when it begins processing the request and deletes matching documents using internal versioning.
If a document changes between the time that the snapshot is taken and the delete operation is processed, it results in a version conflict and the delete operation fails.
</p>
<p>
NOTE: Documents with a version equal to 0 cannot be deleted using delete by query because internal versioning does not support 0 as a valid version number.
</p>
<p>
While processing a delete by query request, Elasticsearch performs multiple search requests sequentially to find all of the matching documents to delete.
A bulk delete request is performed for each batch of matching documents.
If a search or bulk request is rejected, the requests are retried up to 10 times, with exponential back off.
If the maximum retry limit is reached, processing halts and all failed requests are returned in the response.
Any delete requests that completed successfully still stick, they are not rolled back.
</p>
<p>
You can opt to count version conflicts instead of halting and returning by setting <code>conflicts</code> to <code>proceed</code>.
Note that if you opt to count version conflicts the operation could attempt to delete more documents from the source than <code>max_docs</code> until it has successfully deleted <code>max_docs documents</code>, or it has gone through every document in the source query.
</p>
<p>
<strong>Throttling delete requests</strong>
</p>
<p>
To control the rate at which delete by query issues batches of delete operations, you can set <code>requests_per_second</code> to any positive decimal number.
This pads each batch with a wait time to throttle the rate.
Set <code>requests_per_second</code> to <code>-1</code> to disable throttling.
</p>
<p>
Throttling uses a wait time between batches so that the internal scroll requests can be given a timeout that takes the request padding into account.
The padding time is the difference between the batch size divided by the <code>requests_per_second</code> and the time spent writing.
By default the batch size is <code>1000</code>, so if <code>requests_per_second</code> is set to <code>500</code>:
</p>
<pre><code class="lang-csharp">target_time = 1000 / 500 per second = 2 seconds
wait_time = target_time - write_time = 2 seconds - .5 seconds = 1.5 seconds</code></pre>
<p>
Since the batch is issued as a single <code>_bulk</code> request, large batch sizes cause Elasticsearch to create many requests and wait before starting the next set.
This is "bursty" instead of "smooth".
</p>
<p>
<strong>Slicing</strong>
</p>
<p>
Delete by query supports sliced scroll to parallelize the delete process.
This can improve efficiency and provide a convenient way to break the request down into smaller parts.
</p>
<p>
Setting <code>slices</code> to <code>auto</code> lets Elasticsearch choose the number of slices to use.
This setting will use one slice per shard, up to a certain limit.
If there are multiple source data streams or indices, it will choose the number of slices based on the index or backing index with the smallest number of shards.
Adding slices to the delete by query operation creates sub-requests which means it has some quirks:
</p>
<ul><li>
<p>
You can see these requests in the tasks APIs. These sub-requests are "child" tasks of the task for the request with slices.
</p>
</li><li>
<p>
Fetching the status of the task for the request with slices only contains the status of completed slices.
</p>
</li><li>
<p>
These sub-requests are individually addressable for things like cancellation and rethrottling.
</p>
</li><li>
<p>
Rethrottling the request with <code>slices</code> will rethrottle the unfinished sub-request proportionally.
</p>
</li><li>
<p>
Canceling the request with <code>slices</code> will cancel each sub-request.
</p>
</li><li>
<p>
Due to the nature of <code>slices</code> each sub-request won't get a perfectly even portion of the documents. All documents will be addressed, but some slices may be larger than others. Expect larger slices to have a more even distribution.
</p>
</li><li>
<p>
Parameters like <code>requests_per_second</code> and <code>max_docs</code> on a request with <code>slices</code> are distributed proportionally to each sub-request. Combine that with the earlier point about distribution being uneven and you should conclude that using <code>max_docs</code> with <code>slices</code> might not result in exactly <code>max_docs</code> documents being deleted.
</p>
</li><li>
<p>
Each sub-request gets a slightly different snapshot of the source data stream or index though these are all taken at approximately the same time.
</p>
</li></ul>
<p>
If you're slicing manually or otherwise tuning automatic slicing, keep in mind that:
</p>
<ul><li>
<p>
Query performance is most efficient when the number of slices is equal to the number of shards in the index or backing index. If that number is large (for example, 500), choose a lower number as too many <code>slices</code> hurts performance. Setting <code>slices</code> higher than the number of shards generally does not improve efficiency and adds overhead.
</p>
</li><li>
<p>
Delete performance scales linearly across available resources with the number of slices.
</p>
</li></ul>
<p>
Whether query or delete performance dominates the runtime depends on the documents being reindexed and cluster resources.
</p>
<p>
<strong>Cancel a delete by query operation</strong>
</p>
<p>
Any delete by query can be canceled using the task cancel API. For example:
</p>
<pre><code class="lang-csharp">POST _tasks/r1A2WoRbTwKZ516z6NEs5A:36619/_cancel</code></pre>
<p>
The task ID can be found by using the get tasks API.
</p>
<p>
Cancellation should happen quickly but might take a few seconds.
The get task status API will continue to list the delete by query task until this task checks that it has been cancelled and terminates itself.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-delete-by-query.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;DeleteByQueryResponse&gt; DeleteByQueryAsync&lt;TDocument&gt;(Indices indices, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>indices</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Indices.html">Indices</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.DeleteByQueryResponse.html">DeleteByQueryResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteByQueryAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteByQueryAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteByQueryAsync__1_System_Action_Elastic_Clients_Elasticsearch_DeleteByQueryRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteByQueryAsync``1(System.Action{Elastic.Clients.Elasticsearch.DeleteByQueryRequestDescriptor{``0}},System.Threading.CancellationToken)">
  DeleteByQueryAsync&lt;TDocument&gt;(Action&lt;DeleteByQueryRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L11936"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Delete documents.
</p>
<p>
Deletes documents that match the specified query.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or alias:
</p>
<ul><li>
<p>
<code>read</code>
</p>
</li><li>
<p>
<code>delete</code> or <code>write</code>
</p>
</li></ul>
<p>
You can specify the query criteria in the request URI or the request body using the same syntax as the search API.
When you submit a delete by query request, Elasticsearch gets a snapshot of the data stream or index when it begins processing the request and deletes matching documents using internal versioning.
If a document changes between the time that the snapshot is taken and the delete operation is processed, it results in a version conflict and the delete operation fails.
</p>
<p>
NOTE: Documents with a version equal to 0 cannot be deleted using delete by query because internal versioning does not support 0 as a valid version number.
</p>
<p>
While processing a delete by query request, Elasticsearch performs multiple search requests sequentially to find all of the matching documents to delete.
A bulk delete request is performed for each batch of matching documents.
If a search or bulk request is rejected, the requests are retried up to 10 times, with exponential back off.
If the maximum retry limit is reached, processing halts and all failed requests are returned in the response.
Any delete requests that completed successfully still stick, they are not rolled back.
</p>
<p>
You can opt to count version conflicts instead of halting and returning by setting <code>conflicts</code> to <code>proceed</code>.
Note that if you opt to count version conflicts the operation could attempt to delete more documents from the source than <code>max_docs</code> until it has successfully deleted <code>max_docs documents</code>, or it has gone through every document in the source query.
</p>
<p>
<strong>Throttling delete requests</strong>
</p>
<p>
To control the rate at which delete by query issues batches of delete operations, you can set <code>requests_per_second</code> to any positive decimal number.
This pads each batch with a wait time to throttle the rate.
Set <code>requests_per_second</code> to <code>-1</code> to disable throttling.
</p>
<p>
Throttling uses a wait time between batches so that the internal scroll requests can be given a timeout that takes the request padding into account.
The padding time is the difference between the batch size divided by the <code>requests_per_second</code> and the time spent writing.
By default the batch size is <code>1000</code>, so if <code>requests_per_second</code> is set to <code>500</code>:
</p>
<pre><code class="lang-csharp">target_time = 1000 / 500 per second = 2 seconds
wait_time = target_time - write_time = 2 seconds - .5 seconds = 1.5 seconds</code></pre>
<p>
Since the batch is issued as a single <code>_bulk</code> request, large batch sizes cause Elasticsearch to create many requests and wait before starting the next set.
This is "bursty" instead of "smooth".
</p>
<p>
<strong>Slicing</strong>
</p>
<p>
Delete by query supports sliced scroll to parallelize the delete process.
This can improve efficiency and provide a convenient way to break the request down into smaller parts.
</p>
<p>
Setting <code>slices</code> to <code>auto</code> lets Elasticsearch choose the number of slices to use.
This setting will use one slice per shard, up to a certain limit.
If there are multiple source data streams or indices, it will choose the number of slices based on the index or backing index with the smallest number of shards.
Adding slices to the delete by query operation creates sub-requests which means it has some quirks:
</p>
<ul><li>
<p>
You can see these requests in the tasks APIs. These sub-requests are "child" tasks of the task for the request with slices.
</p>
</li><li>
<p>
Fetching the status of the task for the request with slices only contains the status of completed slices.
</p>
</li><li>
<p>
These sub-requests are individually addressable for things like cancellation and rethrottling.
</p>
</li><li>
<p>
Rethrottling the request with <code>slices</code> will rethrottle the unfinished sub-request proportionally.
</p>
</li><li>
<p>
Canceling the request with <code>slices</code> will cancel each sub-request.
</p>
</li><li>
<p>
Due to the nature of <code>slices</code> each sub-request won't get a perfectly even portion of the documents. All documents will be addressed, but some slices may be larger than others. Expect larger slices to have a more even distribution.
</p>
</li><li>
<p>
Parameters like <code>requests_per_second</code> and <code>max_docs</code> on a request with <code>slices</code> are distributed proportionally to each sub-request. Combine that with the earlier point about distribution being uneven and you should conclude that using <code>max_docs</code> with <code>slices</code> might not result in exactly <code>max_docs</code> documents being deleted.
</p>
</li><li>
<p>
Each sub-request gets a slightly different snapshot of the source data stream or index though these are all taken at approximately the same time.
</p>
</li></ul>
<p>
If you're slicing manually or otherwise tuning automatic slicing, keep in mind that:
</p>
<ul><li>
<p>
Query performance is most efficient when the number of slices is equal to the number of shards in the index or backing index. If that number is large (for example, 500), choose a lower number as too many <code>slices</code> hurts performance. Setting <code>slices</code> higher than the number of shards generally does not improve efficiency and adds overhead.
</p>
</li><li>
<p>
Delete performance scales linearly across available resources with the number of slices.
</p>
</li></ul>
<p>
Whether query or delete performance dominates the runtime depends on the documents being reindexed and cluster resources.
</p>
<p>
<strong>Cancel a delete by query operation</strong>
</p>
<p>
Any delete by query can be canceled using the task cancel API. For example:
</p>
<pre><code class="lang-csharp">POST _tasks/r1A2WoRbTwKZ516z6NEs5A:36619/_cancel</code></pre>
<p>
The task ID can be found by using the get tasks API.
</p>
<p>
Cancellation should happen quickly but might take a few seconds.
The get task status API will continue to list the delete by query task until this task checks that it has been cancelled and terminates itself.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-delete-by-query.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;DeleteByQueryResponse&gt; DeleteByQueryAsync&lt;TDocument&gt;(Action&lt;DeleteByQueryRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.DeleteByQueryRequestDescriptor-1.html">DeleteByQueryRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.DeleteByQueryResponse.html">DeleteByQueryResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteByQueryAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteByQueryAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteByQueryAsync__1_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteByQueryAsync``1(System.Threading.CancellationToken)">
  DeleteByQueryAsync&lt;TDocument&gt;(CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L11776"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Delete documents.
</p>
<p>
Deletes documents that match the specified query.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or alias:
</p>
<ul><li>
<p>
<code>read</code>
</p>
</li><li>
<p>
<code>delete</code> or <code>write</code>
</p>
</li></ul>
<p>
You can specify the query criteria in the request URI or the request body using the same syntax as the search API.
When you submit a delete by query request, Elasticsearch gets a snapshot of the data stream or index when it begins processing the request and deletes matching documents using internal versioning.
If a document changes between the time that the snapshot is taken and the delete operation is processed, it results in a version conflict and the delete operation fails.
</p>
<p>
NOTE: Documents with a version equal to 0 cannot be deleted using delete by query because internal versioning does not support 0 as a valid version number.
</p>
<p>
While processing a delete by query request, Elasticsearch performs multiple search requests sequentially to find all of the matching documents to delete.
A bulk delete request is performed for each batch of matching documents.
If a search or bulk request is rejected, the requests are retried up to 10 times, with exponential back off.
If the maximum retry limit is reached, processing halts and all failed requests are returned in the response.
Any delete requests that completed successfully still stick, they are not rolled back.
</p>
<p>
You can opt to count version conflicts instead of halting and returning by setting <code>conflicts</code> to <code>proceed</code>.
Note that if you opt to count version conflicts the operation could attempt to delete more documents from the source than <code>max_docs</code> until it has successfully deleted <code>max_docs documents</code>, or it has gone through every document in the source query.
</p>
<p>
<strong>Throttling delete requests</strong>
</p>
<p>
To control the rate at which delete by query issues batches of delete operations, you can set <code>requests_per_second</code> to any positive decimal number.
This pads each batch with a wait time to throttle the rate.
Set <code>requests_per_second</code> to <code>-1</code> to disable throttling.
</p>
<p>
Throttling uses a wait time between batches so that the internal scroll requests can be given a timeout that takes the request padding into account.
The padding time is the difference between the batch size divided by the <code>requests_per_second</code> and the time spent writing.
By default the batch size is <code>1000</code>, so if <code>requests_per_second</code> is set to <code>500</code>:
</p>
<pre><code class="lang-csharp">target_time = 1000 / 500 per second = 2 seconds
wait_time = target_time - write_time = 2 seconds - .5 seconds = 1.5 seconds</code></pre>
<p>
Since the batch is issued as a single <code>_bulk</code> request, large batch sizes cause Elasticsearch to create many requests and wait before starting the next set.
This is "bursty" instead of "smooth".
</p>
<p>
<strong>Slicing</strong>
</p>
<p>
Delete by query supports sliced scroll to parallelize the delete process.
This can improve efficiency and provide a convenient way to break the request down into smaller parts.
</p>
<p>
Setting <code>slices</code> to <code>auto</code> lets Elasticsearch choose the number of slices to use.
This setting will use one slice per shard, up to a certain limit.
If there are multiple source data streams or indices, it will choose the number of slices based on the index or backing index with the smallest number of shards.
Adding slices to the delete by query operation creates sub-requests which means it has some quirks:
</p>
<ul><li>
<p>
You can see these requests in the tasks APIs. These sub-requests are "child" tasks of the task for the request with slices.
</p>
</li><li>
<p>
Fetching the status of the task for the request with slices only contains the status of completed slices.
</p>
</li><li>
<p>
These sub-requests are individually addressable for things like cancellation and rethrottling.
</p>
</li><li>
<p>
Rethrottling the request with <code>slices</code> will rethrottle the unfinished sub-request proportionally.
</p>
</li><li>
<p>
Canceling the request with <code>slices</code> will cancel each sub-request.
</p>
</li><li>
<p>
Due to the nature of <code>slices</code> each sub-request won't get a perfectly even portion of the documents. All documents will be addressed, but some slices may be larger than others. Expect larger slices to have a more even distribution.
</p>
</li><li>
<p>
Parameters like <code>requests_per_second</code> and <code>max_docs</code> on a request with <code>slices</code> are distributed proportionally to each sub-request. Combine that with the earlier point about distribution being uneven and you should conclude that using <code>max_docs</code> with <code>slices</code> might not result in exactly <code>max_docs</code> documents being deleted.
</p>
</li><li>
<p>
Each sub-request gets a slightly different snapshot of the source data stream or index though these are all taken at approximately the same time.
</p>
</li></ul>
<p>
If you're slicing manually or otherwise tuning automatic slicing, keep in mind that:
</p>
<ul><li>
<p>
Query performance is most efficient when the number of slices is equal to the number of shards in the index or backing index. If that number is large (for example, 500), choose a lower number as too many <code>slices</code> hurts performance. Setting <code>slices</code> higher than the number of shards generally does not improve efficiency and adds overhead.
</p>
</li><li>
<p>
Delete performance scales linearly across available resources with the number of slices.
</p>
</li></ul>
<p>
Whether query or delete performance dominates the runtime depends on the documents being reindexed and cluster resources.
</p>
<p>
<strong>Cancel a delete by query operation</strong>
</p>
<p>
Any delete by query can be canceled using the task cancel API. For example:
</p>
<pre><code class="lang-csharp">POST _tasks/r1A2WoRbTwKZ516z6NEs5A:36619/_cancel</code></pre>
<p>
The task ID can be found by using the get tasks API.
</p>
<p>
Cancellation should happen quickly but might take a few seconds.
The get task status API will continue to list the delete by query task until this task checks that it has been cancelled and terminates itself.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-delete-by-query.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;DeleteByQueryResponse&gt; DeleteByQueryAsync&lt;TDocument&gt;(CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.DeleteByQueryResponse.html">DeleteByQueryResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteByQueryRethrottle_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteByQueryRethrottle*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteByQueryRethrottle_Elastic_Clients_Elasticsearch_DeleteByQueryRethrottleRequest_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteByQueryRethrottle(Elastic.Clients.Elasticsearch.DeleteByQueryRethrottleRequest)">
  DeleteByQueryRethrottle(DeleteByQueryRethrottleRequest)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L12434"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Throttle a delete by query operation.
</p>
<p>
Change the number of requests per second for a particular delete by query operation.
Rethrottling that speeds up the query takes effect immediately but rethrotting that slows down the query takes effect after completing the current batch to prevent scroll timeouts.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-delete-by-query.html#docs-delete-by-query-rethrottle">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual DeleteByQueryRethrottleResponse DeleteByQueryRethrottle(DeleteByQueryRethrottleRequest request)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.DeleteByQueryRethrottleRequest.html">DeleteByQueryRethrottleRequest</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.DeleteByQueryRethrottleResponse.html">DeleteByQueryRethrottleResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteByQueryRethrottle_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteByQueryRethrottle*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteByQueryRethrottle_Elastic_Clients_Elasticsearch_DeleteByQueryRethrottleRequestDescriptor_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteByQueryRethrottle(Elastic.Clients.Elasticsearch.DeleteByQueryRethrottleRequestDescriptor)">
  DeleteByQueryRethrottle(DeleteByQueryRethrottleRequestDescriptor)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L12467"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Throttle a delete by query operation.
</p>
<p>
Change the number of requests per second for a particular delete by query operation.
Rethrottling that speeds up the query takes effect immediately but rethrotting that slows down the query takes effect after completing the current batch to prevent scroll timeouts.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-delete-by-query.html#docs-delete-by-query-rethrottle">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual DeleteByQueryRethrottleResponse DeleteByQueryRethrottle(DeleteByQueryRethrottleRequestDescriptor descriptor)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.DeleteByQueryRethrottleRequestDescriptor.html">DeleteByQueryRethrottleRequestDescriptor</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.DeleteByQueryRethrottleResponse.html">DeleteByQueryRethrottleResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteByQueryRethrottle_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteByQueryRethrottle*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteByQueryRethrottle_Elastic_Clients_Elasticsearch_TaskId_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteByQueryRethrottle(Elastic.Clients.Elasticsearch.TaskId)">
  DeleteByQueryRethrottle(TaskId)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L12484"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Throttle a delete by query operation.
</p>
<p>
Change the number of requests per second for a particular delete by query operation.
Rethrottling that speeds up the query takes effect immediately but rethrotting that slows down the query takes effect after completing the current batch to prevent scroll timeouts.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-delete-by-query.html#docs-delete-by-query-rethrottle">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual DeleteByQueryRethrottleResponse DeleteByQueryRethrottle(TaskId taskId)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>taskId</code> <a class="xref" href="Elastic.Clients.Elasticsearch.TaskId.html">TaskId</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.DeleteByQueryRethrottleResponse.html">DeleteByQueryRethrottleResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteByQueryRethrottle_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteByQueryRethrottle*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteByQueryRethrottle_Elastic_Clients_Elasticsearch_TaskId_System_Action_Elastic_Clients_Elasticsearch_DeleteByQueryRethrottleRequestDescriptor__" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteByQueryRethrottle(Elastic.Clients.Elasticsearch.TaskId,System.Action{Elastic.Clients.Elasticsearch.DeleteByQueryRethrottleRequestDescriptor})">
  DeleteByQueryRethrottle(TaskId, Action&lt;DeleteByQueryRethrottleRequestDescriptor&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L12502"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Throttle a delete by query operation.
</p>
<p>
Change the number of requests per second for a particular delete by query operation.
Rethrottling that speeds up the query takes effect immediately but rethrotting that slows down the query takes effect after completing the current batch to prevent scroll timeouts.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-delete-by-query.html#docs-delete-by-query-rethrottle">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual DeleteByQueryRethrottleResponse DeleteByQueryRethrottle(TaskId taskId, Action&lt;DeleteByQueryRethrottleRequestDescriptor&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>taskId</code> <a class="xref" href="Elastic.Clients.Elasticsearch.TaskId.html">TaskId</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.DeleteByQueryRethrottleRequestDescriptor.html">DeleteByQueryRethrottleRequestDescriptor</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.DeleteByQueryRethrottleResponse.html">DeleteByQueryRethrottleResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteByQueryRethrottleAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteByQueryRethrottleAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteByQueryRethrottleAsync_Elastic_Clients_Elasticsearch_DeleteByQueryRethrottleRequest_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteByQueryRethrottleAsync(Elastic.Clients.Elasticsearch.DeleteByQueryRethrottleRequest,System.Threading.CancellationToken)">
  DeleteByQueryRethrottleAsync(DeleteByQueryRethrottleRequest, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L12451"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Throttle a delete by query operation.
</p>
<p>
Change the number of requests per second for a particular delete by query operation.
Rethrottling that speeds up the query takes effect immediately but rethrotting that slows down the query takes effect after completing the current batch to prevent scroll timeouts.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-delete-by-query.html#docs-delete-by-query-rethrottle">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;DeleteByQueryRethrottleResponse&gt; DeleteByQueryRethrottleAsync(DeleteByQueryRethrottleRequest request, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.DeleteByQueryRethrottleRequest.html">DeleteByQueryRethrottleRequest</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.DeleteByQueryRethrottleResponse.html">DeleteByQueryRethrottleResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteByQueryRethrottleAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteByQueryRethrottleAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteByQueryRethrottleAsync_Elastic_Clients_Elasticsearch_DeleteByQueryRethrottleRequestDescriptor_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteByQueryRethrottleAsync(Elastic.Clients.Elasticsearch.DeleteByQueryRethrottleRequestDescriptor,System.Threading.CancellationToken)">
  DeleteByQueryRethrottleAsync(DeleteByQueryRethrottleRequestDescriptor, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L12521"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Throttle a delete by query operation.
</p>
<p>
Change the number of requests per second for a particular delete by query operation.
Rethrottling that speeds up the query takes effect immediately but rethrotting that slows down the query takes effect after completing the current batch to prevent scroll timeouts.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-delete-by-query.html#docs-delete-by-query-rethrottle">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;DeleteByQueryRethrottleResponse&gt; DeleteByQueryRethrottleAsync(DeleteByQueryRethrottleRequestDescriptor descriptor, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.DeleteByQueryRethrottleRequestDescriptor.html">DeleteByQueryRethrottleRequestDescriptor</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.DeleteByQueryRethrottleResponse.html">DeleteByQueryRethrottleResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteByQueryRethrottleAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteByQueryRethrottleAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteByQueryRethrottleAsync_Elastic_Clients_Elasticsearch_TaskId_System_Action_Elastic_Clients_Elasticsearch_DeleteByQueryRethrottleRequestDescriptor__System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteByQueryRethrottleAsync(Elastic.Clients.Elasticsearch.TaskId,System.Action{Elastic.Clients.Elasticsearch.DeleteByQueryRethrottleRequestDescriptor},System.Threading.CancellationToken)">
  DeleteByQueryRethrottleAsync(TaskId, Action&lt;DeleteByQueryRethrottleRequestDescriptor&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L12554"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Throttle a delete by query operation.
</p>
<p>
Change the number of requests per second for a particular delete by query operation.
Rethrottling that speeds up the query takes effect immediately but rethrotting that slows down the query takes effect after completing the current batch to prevent scroll timeouts.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-delete-by-query.html#docs-delete-by-query-rethrottle">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;DeleteByQueryRethrottleResponse&gt; DeleteByQueryRethrottleAsync(TaskId taskId, Action&lt;DeleteByQueryRethrottleRequestDescriptor&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>taskId</code> <a class="xref" href="Elastic.Clients.Elasticsearch.TaskId.html">TaskId</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.DeleteByQueryRethrottleRequestDescriptor.html">DeleteByQueryRethrottleRequestDescriptor</a>&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.DeleteByQueryRethrottleResponse.html">DeleteByQueryRethrottleResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteByQueryRethrottleAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteByQueryRethrottleAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteByQueryRethrottleAsync_Elastic_Clients_Elasticsearch_TaskId_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteByQueryRethrottleAsync(Elastic.Clients.Elasticsearch.TaskId,System.Threading.CancellationToken)">
  DeleteByQueryRethrottleAsync(TaskId, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L12537"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Throttle a delete by query operation.
</p>
<p>
Change the number of requests per second for a particular delete by query operation.
Rethrottling that speeds up the query takes effect immediately but rethrotting that slows down the query takes effect after completing the current batch to prevent scroll timeouts.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-delete-by-query.html#docs-delete-by-query-rethrottle">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;DeleteByQueryRethrottleResponse&gt; DeleteByQueryRethrottleAsync(TaskId taskId, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>taskId</code> <a class="xref" href="Elastic.Clients.Elasticsearch.TaskId.html">TaskId</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.DeleteByQueryRethrottleResponse.html">DeleteByQueryRethrottleResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteByQuery_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteByQuery*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteByQuery__1" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteByQuery``1">
  DeleteByQuery&lt;TDocument&gt;()
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L10490"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Delete documents.
</p>
<p>
Deletes documents that match the specified query.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or alias:
</p>
<ul><li>
<p>
<code>read</code>
</p>
</li><li>
<p>
<code>delete</code> or <code>write</code>
</p>
</li></ul>
<p>
You can specify the query criteria in the request URI or the request body using the same syntax as the search API.
When you submit a delete by query request, Elasticsearch gets a snapshot of the data stream or index when it begins processing the request and deletes matching documents using internal versioning.
If a document changes between the time that the snapshot is taken and the delete operation is processed, it results in a version conflict and the delete operation fails.
</p>
<p>
NOTE: Documents with a version equal to 0 cannot be deleted using delete by query because internal versioning does not support 0 as a valid version number.
</p>
<p>
While processing a delete by query request, Elasticsearch performs multiple search requests sequentially to find all of the matching documents to delete.
A bulk delete request is performed for each batch of matching documents.
If a search or bulk request is rejected, the requests are retried up to 10 times, with exponential back off.
If the maximum retry limit is reached, processing halts and all failed requests are returned in the response.
Any delete requests that completed successfully still stick, they are not rolled back.
</p>
<p>
You can opt to count version conflicts instead of halting and returning by setting <code>conflicts</code> to <code>proceed</code>.
Note that if you opt to count version conflicts the operation could attempt to delete more documents from the source than <code>max_docs</code> until it has successfully deleted <code>max_docs documents</code>, or it has gone through every document in the source query.
</p>
<p>
<strong>Throttling delete requests</strong>
</p>
<p>
To control the rate at which delete by query issues batches of delete operations, you can set <code>requests_per_second</code> to any positive decimal number.
This pads each batch with a wait time to throttle the rate.
Set <code>requests_per_second</code> to <code>-1</code> to disable throttling.
</p>
<p>
Throttling uses a wait time between batches so that the internal scroll requests can be given a timeout that takes the request padding into account.
The padding time is the difference between the batch size divided by the <code>requests_per_second</code> and the time spent writing.
By default the batch size is <code>1000</code>, so if <code>requests_per_second</code> is set to <code>500</code>:
</p>
<pre><code class="lang-csharp">target_time = 1000 / 500 per second = 2 seconds
wait_time = target_time - write_time = 2 seconds - .5 seconds = 1.5 seconds</code></pre>
<p>
Since the batch is issued as a single <code>_bulk</code> request, large batch sizes cause Elasticsearch to create many requests and wait before starting the next set.
This is "bursty" instead of "smooth".
</p>
<p>
<strong>Slicing</strong>
</p>
<p>
Delete by query supports sliced scroll to parallelize the delete process.
This can improve efficiency and provide a convenient way to break the request down into smaller parts.
</p>
<p>
Setting <code>slices</code> to <code>auto</code> lets Elasticsearch choose the number of slices to use.
This setting will use one slice per shard, up to a certain limit.
If there are multiple source data streams or indices, it will choose the number of slices based on the index or backing index with the smallest number of shards.
Adding slices to the delete by query operation creates sub-requests which means it has some quirks:
</p>
<ul><li>
<p>
You can see these requests in the tasks APIs. These sub-requests are "child" tasks of the task for the request with slices.
</p>
</li><li>
<p>
Fetching the status of the task for the request with slices only contains the status of completed slices.
</p>
</li><li>
<p>
These sub-requests are individually addressable for things like cancellation and rethrottling.
</p>
</li><li>
<p>
Rethrottling the request with <code>slices</code> will rethrottle the unfinished sub-request proportionally.
</p>
</li><li>
<p>
Canceling the request with <code>slices</code> will cancel each sub-request.
</p>
</li><li>
<p>
Due to the nature of <code>slices</code> each sub-request won't get a perfectly even portion of the documents. All documents will be addressed, but some slices may be larger than others. Expect larger slices to have a more even distribution.
</p>
</li><li>
<p>
Parameters like <code>requests_per_second</code> and <code>max_docs</code> on a request with <code>slices</code> are distributed proportionally to each sub-request. Combine that with the earlier point about distribution being uneven and you should conclude that using <code>max_docs</code> with <code>slices</code> might not result in exactly <code>max_docs</code> documents being deleted.
</p>
</li><li>
<p>
Each sub-request gets a slightly different snapshot of the source data stream or index though these are all taken at approximately the same time.
</p>
</li></ul>
<p>
If you're slicing manually or otherwise tuning automatic slicing, keep in mind that:
</p>
<ul><li>
<p>
Query performance is most efficient when the number of slices is equal to the number of shards in the index or backing index. If that number is large (for example, 500), choose a lower number as too many <code>slices</code> hurts performance. Setting <code>slices</code> higher than the number of shards generally does not improve efficiency and adds overhead.
</p>
</li><li>
<p>
Delete performance scales linearly across available resources with the number of slices.
</p>
</li></ul>
<p>
Whether query or delete performance dominates the runtime depends on the documents being reindexed and cluster resources.
</p>
<p>
<strong>Cancel a delete by query operation</strong>
</p>
<p>
Any delete by query can be canceled using the task cancel API. For example:
</p>
<pre><code class="lang-csharp">POST _tasks/r1A2WoRbTwKZ516z6NEs5A:36619/_cancel</code></pre>
<p>
The task ID can be found by using the get tasks API.
</p>
<p>
Cancellation should happen quickly but might take a few seconds.
The get task status API will continue to list the delete by query task until this task checks that it has been cancelled and terminates itself.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-delete-by-query.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual DeleteByQueryResponse DeleteByQuery&lt;TDocument&gt;()</code></pre>
  </div>


  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.DeleteByQueryResponse.html">DeleteByQueryResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteByQuery_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteByQuery*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteByQuery__1_Elastic_Clients_Elasticsearch_DeleteByQueryRequestDescriptor___0__" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteByQuery``1(Elastic.Clients.Elasticsearch.DeleteByQueryRequestDescriptor{``0})">
  DeleteByQuery&lt;TDocument&gt;(DeleteByQueryRequestDescriptor&lt;TDocument&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L10007"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Delete documents.
</p>
<p>
Deletes documents that match the specified query.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or alias:
</p>
<ul><li>
<p>
<code>read</code>
</p>
</li><li>
<p>
<code>delete</code> or <code>write</code>
</p>
</li></ul>
<p>
You can specify the query criteria in the request URI or the request body using the same syntax as the search API.
When you submit a delete by query request, Elasticsearch gets a snapshot of the data stream or index when it begins processing the request and deletes matching documents using internal versioning.
If a document changes between the time that the snapshot is taken and the delete operation is processed, it results in a version conflict and the delete operation fails.
</p>
<p>
NOTE: Documents with a version equal to 0 cannot be deleted using delete by query because internal versioning does not support 0 as a valid version number.
</p>
<p>
While processing a delete by query request, Elasticsearch performs multiple search requests sequentially to find all of the matching documents to delete.
A bulk delete request is performed for each batch of matching documents.
If a search or bulk request is rejected, the requests are retried up to 10 times, with exponential back off.
If the maximum retry limit is reached, processing halts and all failed requests are returned in the response.
Any delete requests that completed successfully still stick, they are not rolled back.
</p>
<p>
You can opt to count version conflicts instead of halting and returning by setting <code>conflicts</code> to <code>proceed</code>.
Note that if you opt to count version conflicts the operation could attempt to delete more documents from the source than <code>max_docs</code> until it has successfully deleted <code>max_docs documents</code>, or it has gone through every document in the source query.
</p>
<p>
<strong>Throttling delete requests</strong>
</p>
<p>
To control the rate at which delete by query issues batches of delete operations, you can set <code>requests_per_second</code> to any positive decimal number.
This pads each batch with a wait time to throttle the rate.
Set <code>requests_per_second</code> to <code>-1</code> to disable throttling.
</p>
<p>
Throttling uses a wait time between batches so that the internal scroll requests can be given a timeout that takes the request padding into account.
The padding time is the difference between the batch size divided by the <code>requests_per_second</code> and the time spent writing.
By default the batch size is <code>1000</code>, so if <code>requests_per_second</code> is set to <code>500</code>:
</p>
<pre><code class="lang-csharp">target_time = 1000 / 500 per second = 2 seconds
wait_time = target_time - write_time = 2 seconds - .5 seconds = 1.5 seconds</code></pre>
<p>
Since the batch is issued as a single <code>_bulk</code> request, large batch sizes cause Elasticsearch to create many requests and wait before starting the next set.
This is "bursty" instead of "smooth".
</p>
<p>
<strong>Slicing</strong>
</p>
<p>
Delete by query supports sliced scroll to parallelize the delete process.
This can improve efficiency and provide a convenient way to break the request down into smaller parts.
</p>
<p>
Setting <code>slices</code> to <code>auto</code> lets Elasticsearch choose the number of slices to use.
This setting will use one slice per shard, up to a certain limit.
If there are multiple source data streams or indices, it will choose the number of slices based on the index or backing index with the smallest number of shards.
Adding slices to the delete by query operation creates sub-requests which means it has some quirks:
</p>
<ul><li>
<p>
You can see these requests in the tasks APIs. These sub-requests are "child" tasks of the task for the request with slices.
</p>
</li><li>
<p>
Fetching the status of the task for the request with slices only contains the status of completed slices.
</p>
</li><li>
<p>
These sub-requests are individually addressable for things like cancellation and rethrottling.
</p>
</li><li>
<p>
Rethrottling the request with <code>slices</code> will rethrottle the unfinished sub-request proportionally.
</p>
</li><li>
<p>
Canceling the request with <code>slices</code> will cancel each sub-request.
</p>
</li><li>
<p>
Due to the nature of <code>slices</code> each sub-request won't get a perfectly even portion of the documents. All documents will be addressed, but some slices may be larger than others. Expect larger slices to have a more even distribution.
</p>
</li><li>
<p>
Parameters like <code>requests_per_second</code> and <code>max_docs</code> on a request with <code>slices</code> are distributed proportionally to each sub-request. Combine that with the earlier point about distribution being uneven and you should conclude that using <code>max_docs</code> with <code>slices</code> might not result in exactly <code>max_docs</code> documents being deleted.
</p>
</li><li>
<p>
Each sub-request gets a slightly different snapshot of the source data stream or index though these are all taken at approximately the same time.
</p>
</li></ul>
<p>
If you're slicing manually or otherwise tuning automatic slicing, keep in mind that:
</p>
<ul><li>
<p>
Query performance is most efficient when the number of slices is equal to the number of shards in the index or backing index. If that number is large (for example, 500), choose a lower number as too many <code>slices</code> hurts performance. Setting <code>slices</code> higher than the number of shards generally does not improve efficiency and adds overhead.
</p>
</li><li>
<p>
Delete performance scales linearly across available resources with the number of slices.
</p>
</li></ul>
<p>
Whether query or delete performance dominates the runtime depends on the documents being reindexed and cluster resources.
</p>
<p>
<strong>Cancel a delete by query operation</strong>
</p>
<p>
Any delete by query can be canceled using the task cancel API. For example:
</p>
<pre><code class="lang-csharp">POST _tasks/r1A2WoRbTwKZ516z6NEs5A:36619/_cancel</code></pre>
<p>
The task ID can be found by using the get tasks API.
</p>
<p>
Cancellation should happen quickly but might take a few seconds.
The get task status API will continue to list the delete by query task until this task checks that it has been cancelled and terminates itself.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-delete-by-query.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual DeleteByQueryResponse DeleteByQuery&lt;TDocument&gt;(DeleteByQueryRequestDescriptor&lt;TDocument&gt; descriptor)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.DeleteByQueryRequestDescriptor-1.html">DeleteByQueryRequestDescriptor</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.DeleteByQueryResponse.html">DeleteByQueryResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteByQuery_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteByQuery*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteByQuery__1_Elastic_Clients_Elasticsearch_Indices_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteByQuery``1(Elastic.Clients.Elasticsearch.Indices)">
  DeleteByQuery&lt;TDocument&gt;(Indices)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L10167"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Delete documents.
</p>
<p>
Deletes documents that match the specified query.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or alias:
</p>
<ul><li>
<p>
<code>read</code>
</p>
</li><li>
<p>
<code>delete</code> or <code>write</code>
</p>
</li></ul>
<p>
You can specify the query criteria in the request URI or the request body using the same syntax as the search API.
When you submit a delete by query request, Elasticsearch gets a snapshot of the data stream or index when it begins processing the request and deletes matching documents using internal versioning.
If a document changes between the time that the snapshot is taken and the delete operation is processed, it results in a version conflict and the delete operation fails.
</p>
<p>
NOTE: Documents with a version equal to 0 cannot be deleted using delete by query because internal versioning does not support 0 as a valid version number.
</p>
<p>
While processing a delete by query request, Elasticsearch performs multiple search requests sequentially to find all of the matching documents to delete.
A bulk delete request is performed for each batch of matching documents.
If a search or bulk request is rejected, the requests are retried up to 10 times, with exponential back off.
If the maximum retry limit is reached, processing halts and all failed requests are returned in the response.
Any delete requests that completed successfully still stick, they are not rolled back.
</p>
<p>
You can opt to count version conflicts instead of halting and returning by setting <code>conflicts</code> to <code>proceed</code>.
Note that if you opt to count version conflicts the operation could attempt to delete more documents from the source than <code>max_docs</code> until it has successfully deleted <code>max_docs documents</code>, or it has gone through every document in the source query.
</p>
<p>
<strong>Throttling delete requests</strong>
</p>
<p>
To control the rate at which delete by query issues batches of delete operations, you can set <code>requests_per_second</code> to any positive decimal number.
This pads each batch with a wait time to throttle the rate.
Set <code>requests_per_second</code> to <code>-1</code> to disable throttling.
</p>
<p>
Throttling uses a wait time between batches so that the internal scroll requests can be given a timeout that takes the request padding into account.
The padding time is the difference between the batch size divided by the <code>requests_per_second</code> and the time spent writing.
By default the batch size is <code>1000</code>, so if <code>requests_per_second</code> is set to <code>500</code>:
</p>
<pre><code class="lang-csharp">target_time = 1000 / 500 per second = 2 seconds
wait_time = target_time - write_time = 2 seconds - .5 seconds = 1.5 seconds</code></pre>
<p>
Since the batch is issued as a single <code>_bulk</code> request, large batch sizes cause Elasticsearch to create many requests and wait before starting the next set.
This is "bursty" instead of "smooth".
</p>
<p>
<strong>Slicing</strong>
</p>
<p>
Delete by query supports sliced scroll to parallelize the delete process.
This can improve efficiency and provide a convenient way to break the request down into smaller parts.
</p>
<p>
Setting <code>slices</code> to <code>auto</code> lets Elasticsearch choose the number of slices to use.
This setting will use one slice per shard, up to a certain limit.
If there are multiple source data streams or indices, it will choose the number of slices based on the index or backing index with the smallest number of shards.
Adding slices to the delete by query operation creates sub-requests which means it has some quirks:
</p>
<ul><li>
<p>
You can see these requests in the tasks APIs. These sub-requests are "child" tasks of the task for the request with slices.
</p>
</li><li>
<p>
Fetching the status of the task for the request with slices only contains the status of completed slices.
</p>
</li><li>
<p>
These sub-requests are individually addressable for things like cancellation and rethrottling.
</p>
</li><li>
<p>
Rethrottling the request with <code>slices</code> will rethrottle the unfinished sub-request proportionally.
</p>
</li><li>
<p>
Canceling the request with <code>slices</code> will cancel each sub-request.
</p>
</li><li>
<p>
Due to the nature of <code>slices</code> each sub-request won't get a perfectly even portion of the documents. All documents will be addressed, but some slices may be larger than others. Expect larger slices to have a more even distribution.
</p>
</li><li>
<p>
Parameters like <code>requests_per_second</code> and <code>max_docs</code> on a request with <code>slices</code> are distributed proportionally to each sub-request. Combine that with the earlier point about distribution being uneven and you should conclude that using <code>max_docs</code> with <code>slices</code> might not result in exactly <code>max_docs</code> documents being deleted.
</p>
</li><li>
<p>
Each sub-request gets a slightly different snapshot of the source data stream or index though these are all taken at approximately the same time.
</p>
</li></ul>
<p>
If you're slicing manually or otherwise tuning automatic slicing, keep in mind that:
</p>
<ul><li>
<p>
Query performance is most efficient when the number of slices is equal to the number of shards in the index or backing index. If that number is large (for example, 500), choose a lower number as too many <code>slices</code> hurts performance. Setting <code>slices</code> higher than the number of shards generally does not improve efficiency and adds overhead.
</p>
</li><li>
<p>
Delete performance scales linearly across available resources with the number of slices.
</p>
</li></ul>
<p>
Whether query or delete performance dominates the runtime depends on the documents being reindexed and cluster resources.
</p>
<p>
<strong>Cancel a delete by query operation</strong>
</p>
<p>
Any delete by query can be canceled using the task cancel API. For example:
</p>
<pre><code class="lang-csharp">POST _tasks/r1A2WoRbTwKZ516z6NEs5A:36619/_cancel</code></pre>
<p>
The task ID can be found by using the get tasks API.
</p>
<p>
Cancellation should happen quickly but might take a few seconds.
The get task status API will continue to list the delete by query task until this task checks that it has been cancelled and terminates itself.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-delete-by-query.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual DeleteByQueryResponse DeleteByQuery&lt;TDocument&gt;(Indices indices)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>indices</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Indices.html">Indices</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.DeleteByQueryResponse.html">DeleteByQueryResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteByQuery_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteByQuery*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteByQuery__1_Elastic_Clients_Elasticsearch_Indices_System_Action_Elastic_Clients_Elasticsearch_DeleteByQueryRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteByQuery``1(Elastic.Clients.Elasticsearch.Indices,System.Action{Elastic.Clients.Elasticsearch.DeleteByQueryRequestDescriptor{``0}})">
  DeleteByQuery&lt;TDocument&gt;(Indices, Action&lt;DeleteByQueryRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L10328"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Delete documents.
</p>
<p>
Deletes documents that match the specified query.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or alias:
</p>
<ul><li>
<p>
<code>read</code>
</p>
</li><li>
<p>
<code>delete</code> or <code>write</code>
</p>
</li></ul>
<p>
You can specify the query criteria in the request URI or the request body using the same syntax as the search API.
When you submit a delete by query request, Elasticsearch gets a snapshot of the data stream or index when it begins processing the request and deletes matching documents using internal versioning.
If a document changes between the time that the snapshot is taken and the delete operation is processed, it results in a version conflict and the delete operation fails.
</p>
<p>
NOTE: Documents with a version equal to 0 cannot be deleted using delete by query because internal versioning does not support 0 as a valid version number.
</p>
<p>
While processing a delete by query request, Elasticsearch performs multiple search requests sequentially to find all of the matching documents to delete.
A bulk delete request is performed for each batch of matching documents.
If a search or bulk request is rejected, the requests are retried up to 10 times, with exponential back off.
If the maximum retry limit is reached, processing halts and all failed requests are returned in the response.
Any delete requests that completed successfully still stick, they are not rolled back.
</p>
<p>
You can opt to count version conflicts instead of halting and returning by setting <code>conflicts</code> to <code>proceed</code>.
Note that if you opt to count version conflicts the operation could attempt to delete more documents from the source than <code>max_docs</code> until it has successfully deleted <code>max_docs documents</code>, or it has gone through every document in the source query.
</p>
<p>
<strong>Throttling delete requests</strong>
</p>
<p>
To control the rate at which delete by query issues batches of delete operations, you can set <code>requests_per_second</code> to any positive decimal number.
This pads each batch with a wait time to throttle the rate.
Set <code>requests_per_second</code> to <code>-1</code> to disable throttling.
</p>
<p>
Throttling uses a wait time between batches so that the internal scroll requests can be given a timeout that takes the request padding into account.
The padding time is the difference between the batch size divided by the <code>requests_per_second</code> and the time spent writing.
By default the batch size is <code>1000</code>, so if <code>requests_per_second</code> is set to <code>500</code>:
</p>
<pre><code class="lang-csharp">target_time = 1000 / 500 per second = 2 seconds
wait_time = target_time - write_time = 2 seconds - .5 seconds = 1.5 seconds</code></pre>
<p>
Since the batch is issued as a single <code>_bulk</code> request, large batch sizes cause Elasticsearch to create many requests and wait before starting the next set.
This is "bursty" instead of "smooth".
</p>
<p>
<strong>Slicing</strong>
</p>
<p>
Delete by query supports sliced scroll to parallelize the delete process.
This can improve efficiency and provide a convenient way to break the request down into smaller parts.
</p>
<p>
Setting <code>slices</code> to <code>auto</code> lets Elasticsearch choose the number of slices to use.
This setting will use one slice per shard, up to a certain limit.
If there are multiple source data streams or indices, it will choose the number of slices based on the index or backing index with the smallest number of shards.
Adding slices to the delete by query operation creates sub-requests which means it has some quirks:
</p>
<ul><li>
<p>
You can see these requests in the tasks APIs. These sub-requests are "child" tasks of the task for the request with slices.
</p>
</li><li>
<p>
Fetching the status of the task for the request with slices only contains the status of completed slices.
</p>
</li><li>
<p>
These sub-requests are individually addressable for things like cancellation and rethrottling.
</p>
</li><li>
<p>
Rethrottling the request with <code>slices</code> will rethrottle the unfinished sub-request proportionally.
</p>
</li><li>
<p>
Canceling the request with <code>slices</code> will cancel each sub-request.
</p>
</li><li>
<p>
Due to the nature of <code>slices</code> each sub-request won't get a perfectly even portion of the documents. All documents will be addressed, but some slices may be larger than others. Expect larger slices to have a more even distribution.
</p>
</li><li>
<p>
Parameters like <code>requests_per_second</code> and <code>max_docs</code> on a request with <code>slices</code> are distributed proportionally to each sub-request. Combine that with the earlier point about distribution being uneven and you should conclude that using <code>max_docs</code> with <code>slices</code> might not result in exactly <code>max_docs</code> documents being deleted.
</p>
</li><li>
<p>
Each sub-request gets a slightly different snapshot of the source data stream or index though these are all taken at approximately the same time.
</p>
</li></ul>
<p>
If you're slicing manually or otherwise tuning automatic slicing, keep in mind that:
</p>
<ul><li>
<p>
Query performance is most efficient when the number of slices is equal to the number of shards in the index or backing index. If that number is large (for example, 500), choose a lower number as too many <code>slices</code> hurts performance. Setting <code>slices</code> higher than the number of shards generally does not improve efficiency and adds overhead.
</p>
</li><li>
<p>
Delete performance scales linearly across available resources with the number of slices.
</p>
</li></ul>
<p>
Whether query or delete performance dominates the runtime depends on the documents being reindexed and cluster resources.
</p>
<p>
<strong>Cancel a delete by query operation</strong>
</p>
<p>
Any delete by query can be canceled using the task cancel API. For example:
</p>
<pre><code class="lang-csharp">POST _tasks/r1A2WoRbTwKZ516z6NEs5A:36619/_cancel</code></pre>
<p>
The task ID can be found by using the get tasks API.
</p>
<p>
Cancellation should happen quickly but might take a few seconds.
The get task status API will continue to list the delete by query task until this task checks that it has been cancelled and terminates itself.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-delete-by-query.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual DeleteByQueryResponse DeleteByQuery&lt;TDocument&gt;(Indices indices, Action&lt;DeleteByQueryRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>indices</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Indices.html">Indices</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.DeleteByQueryRequestDescriptor-1.html">DeleteByQueryRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.DeleteByQueryResponse.html">DeleteByQueryResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteByQuery_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteByQuery*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteByQuery__1_System_Action_Elastic_Clients_Elasticsearch_DeleteByQueryRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteByQuery``1(System.Action{Elastic.Clients.Elasticsearch.DeleteByQueryRequestDescriptor{``0}})">
  DeleteByQuery&lt;TDocument&gt;(Action&lt;DeleteByQueryRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L10651"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Delete documents.
</p>
<p>
Deletes documents that match the specified query.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or alias:
</p>
<ul><li>
<p>
<code>read</code>
</p>
</li><li>
<p>
<code>delete</code> or <code>write</code>
</p>
</li></ul>
<p>
You can specify the query criteria in the request URI or the request body using the same syntax as the search API.
When you submit a delete by query request, Elasticsearch gets a snapshot of the data stream or index when it begins processing the request and deletes matching documents using internal versioning.
If a document changes between the time that the snapshot is taken and the delete operation is processed, it results in a version conflict and the delete operation fails.
</p>
<p>
NOTE: Documents with a version equal to 0 cannot be deleted using delete by query because internal versioning does not support 0 as a valid version number.
</p>
<p>
While processing a delete by query request, Elasticsearch performs multiple search requests sequentially to find all of the matching documents to delete.
A bulk delete request is performed for each batch of matching documents.
If a search or bulk request is rejected, the requests are retried up to 10 times, with exponential back off.
If the maximum retry limit is reached, processing halts and all failed requests are returned in the response.
Any delete requests that completed successfully still stick, they are not rolled back.
</p>
<p>
You can opt to count version conflicts instead of halting and returning by setting <code>conflicts</code> to <code>proceed</code>.
Note that if you opt to count version conflicts the operation could attempt to delete more documents from the source than <code>max_docs</code> until it has successfully deleted <code>max_docs documents</code>, or it has gone through every document in the source query.
</p>
<p>
<strong>Throttling delete requests</strong>
</p>
<p>
To control the rate at which delete by query issues batches of delete operations, you can set <code>requests_per_second</code> to any positive decimal number.
This pads each batch with a wait time to throttle the rate.
Set <code>requests_per_second</code> to <code>-1</code> to disable throttling.
</p>
<p>
Throttling uses a wait time between batches so that the internal scroll requests can be given a timeout that takes the request padding into account.
The padding time is the difference between the batch size divided by the <code>requests_per_second</code> and the time spent writing.
By default the batch size is <code>1000</code>, so if <code>requests_per_second</code> is set to <code>500</code>:
</p>
<pre><code class="lang-csharp">target_time = 1000 / 500 per second = 2 seconds
wait_time = target_time - write_time = 2 seconds - .5 seconds = 1.5 seconds</code></pre>
<p>
Since the batch is issued as a single <code>_bulk</code> request, large batch sizes cause Elasticsearch to create many requests and wait before starting the next set.
This is "bursty" instead of "smooth".
</p>
<p>
<strong>Slicing</strong>
</p>
<p>
Delete by query supports sliced scroll to parallelize the delete process.
This can improve efficiency and provide a convenient way to break the request down into smaller parts.
</p>
<p>
Setting <code>slices</code> to <code>auto</code> lets Elasticsearch choose the number of slices to use.
This setting will use one slice per shard, up to a certain limit.
If there are multiple source data streams or indices, it will choose the number of slices based on the index or backing index with the smallest number of shards.
Adding slices to the delete by query operation creates sub-requests which means it has some quirks:
</p>
<ul><li>
<p>
You can see these requests in the tasks APIs. These sub-requests are "child" tasks of the task for the request with slices.
</p>
</li><li>
<p>
Fetching the status of the task for the request with slices only contains the status of completed slices.
</p>
</li><li>
<p>
These sub-requests are individually addressable for things like cancellation and rethrottling.
</p>
</li><li>
<p>
Rethrottling the request with <code>slices</code> will rethrottle the unfinished sub-request proportionally.
</p>
</li><li>
<p>
Canceling the request with <code>slices</code> will cancel each sub-request.
</p>
</li><li>
<p>
Due to the nature of <code>slices</code> each sub-request won't get a perfectly even portion of the documents. All documents will be addressed, but some slices may be larger than others. Expect larger slices to have a more even distribution.
</p>
</li><li>
<p>
Parameters like <code>requests_per_second</code> and <code>max_docs</code> on a request with <code>slices</code> are distributed proportionally to each sub-request. Combine that with the earlier point about distribution being uneven and you should conclude that using <code>max_docs</code> with <code>slices</code> might not result in exactly <code>max_docs</code> documents being deleted.
</p>
</li><li>
<p>
Each sub-request gets a slightly different snapshot of the source data stream or index though these are all taken at approximately the same time.
</p>
</li></ul>
<p>
If you're slicing manually or otherwise tuning automatic slicing, keep in mind that:
</p>
<ul><li>
<p>
Query performance is most efficient when the number of slices is equal to the number of shards in the index or backing index. If that number is large (for example, 500), choose a lower number as too many <code>slices</code> hurts performance. Setting <code>slices</code> higher than the number of shards generally does not improve efficiency and adds overhead.
</p>
</li><li>
<p>
Delete performance scales linearly across available resources with the number of slices.
</p>
</li></ul>
<p>
Whether query or delete performance dominates the runtime depends on the documents being reindexed and cluster resources.
</p>
<p>
<strong>Cancel a delete by query operation</strong>
</p>
<p>
Any delete by query can be canceled using the task cancel API. For example:
</p>
<pre><code class="lang-csharp">POST _tasks/r1A2WoRbTwKZ516z6NEs5A:36619/_cancel</code></pre>
<p>
The task ID can be found by using the get tasks API.
</p>
<p>
Cancellation should happen quickly but might take a few seconds.
The get task status API will continue to list the delete by query task until this task checks that it has been cancelled and terminates itself.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-delete-by-query.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual DeleteByQueryResponse DeleteByQuery&lt;TDocument&gt;(Action&lt;DeleteByQueryRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.DeleteByQueryRequestDescriptor-1.html">DeleteByQueryRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.DeleteByQueryResponse.html">DeleteByQueryResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteScript_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteScript*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteScript_Elastic_Clients_Elasticsearch_DeleteScriptRequest_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteScript(Elastic.Clients.Elasticsearch.DeleteScriptRequest)">
  DeleteScript(DeleteScriptRequest)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L12569"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Delete a script or search template.
Deletes a stored script or search template.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/delete-stored-script-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual DeleteScriptResponse DeleteScript(DeleteScriptRequest request)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.DeleteScriptRequest.html">DeleteScriptRequest</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.DeleteScriptResponse.html">DeleteScriptResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteScript_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteScript*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteScript_Elastic_Clients_Elasticsearch_DeleteScriptRequestDescriptor_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteScript(Elastic.Clients.Elasticsearch.DeleteScriptRequestDescriptor)">
  DeleteScript(DeleteScriptRequestDescriptor)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L12641"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Delete a script or search template.
Deletes a stored script or search template.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/delete-stored-script-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual DeleteScriptResponse DeleteScript(DeleteScriptRequestDescriptor descriptor)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.DeleteScriptRequestDescriptor.html">DeleteScriptRequestDescriptor</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.DeleteScriptResponse.html">DeleteScriptResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteScript_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteScript*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteScript_Elastic_Clients_Elasticsearch_Id_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteScript(Elastic.Clients.Elasticsearch.Id)">
  DeleteScript(Id)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L12655"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Delete a script or search template.
Deletes a stored script or search template.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/delete-stored-script-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual DeleteScriptResponse DeleteScript(Id id)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.DeleteScriptResponse.html">DeleteScriptResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteScript_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteScript*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteScript_Elastic_Clients_Elasticsearch_Id_System_Action_Elastic_Clients_Elasticsearch_DeleteScriptRequestDescriptor__" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteScript(Elastic.Clients.Elasticsearch.Id,System.Action{Elastic.Clients.Elasticsearch.DeleteScriptRequestDescriptor})">
  DeleteScript(Id, Action&lt;DeleteScriptRequestDescriptor&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L12670"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Delete a script or search template.
Deletes a stored script or search template.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/delete-stored-script-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual DeleteScriptResponse DeleteScript(Id id, Action&lt;DeleteScriptRequestDescriptor&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.DeleteScriptRequestDescriptor.html">DeleteScriptRequestDescriptor</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.DeleteScriptResponse.html">DeleteScriptResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteScriptAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteScriptAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteScriptAsync_Elastic_Clients_Elasticsearch_DeleteScriptRequest_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteScriptAsync(Elastic.Clients.Elasticsearch.DeleteScriptRequest,System.Threading.CancellationToken)">
  DeleteScriptAsync(DeleteScriptRequest, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L12583"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Delete a script or search template.
Deletes a stored script or search template.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/delete-stored-script-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;DeleteScriptResponse&gt; DeleteScriptAsync(DeleteScriptRequest request, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.DeleteScriptRequest.html">DeleteScriptRequest</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.DeleteScriptResponse.html">DeleteScriptResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteScriptAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteScriptAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteScriptAsync_Elastic_Clients_Elasticsearch_DeleteScriptRequestDescriptor_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteScriptAsync(Elastic.Clients.Elasticsearch.DeleteScriptRequestDescriptor,System.Threading.CancellationToken)">
  DeleteScriptAsync(DeleteScriptRequestDescriptor, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L12728"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Delete a script or search template.
Deletes a stored script or search template.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/delete-stored-script-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;DeleteScriptResponse&gt; DeleteScriptAsync(DeleteScriptRequestDescriptor descriptor, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.DeleteScriptRequestDescriptor.html">DeleteScriptRequestDescriptor</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.DeleteScriptResponse.html">DeleteScriptResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteScriptAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteScriptAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteScriptAsync_Elastic_Clients_Elasticsearch_Id_System_Action_Elastic_Clients_Elasticsearch_DeleteScriptRequestDescriptor__System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteScriptAsync(Elastic.Clients.Elasticsearch.Id,System.Action{Elastic.Clients.Elasticsearch.DeleteScriptRequestDescriptor},System.Threading.CancellationToken)">
  DeleteScriptAsync(Id, Action&lt;DeleteScriptRequestDescriptor&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L12755"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Delete a script or search template.
Deletes a stored script or search template.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/delete-stored-script-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;DeleteScriptResponse&gt; DeleteScriptAsync(Id id, Action&lt;DeleteScriptRequestDescriptor&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.DeleteScriptRequestDescriptor.html">DeleteScriptRequestDescriptor</a>&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.DeleteScriptResponse.html">DeleteScriptResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteScriptAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteScriptAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteScriptAsync_Elastic_Clients_Elasticsearch_Id_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteScriptAsync(Elastic.Clients.Elasticsearch.Id,System.Threading.CancellationToken)">
  DeleteScriptAsync(Id, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L12741"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Delete a script or search template.
Deletes a stored script or search template.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/delete-stored-script-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;DeleteScriptResponse&gt; DeleteScriptAsync(Id id, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.DeleteScriptResponse.html">DeleteScriptResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteScriptAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteScriptAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteScriptAsync__1_Elastic_Clients_Elasticsearch_DeleteScriptRequestDescriptor___0__System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteScriptAsync``1(Elastic.Clients.Elasticsearch.DeleteScriptRequestDescriptor{``0},System.Threading.CancellationToken)">
  DeleteScriptAsync&lt;TDocument&gt;(DeleteScriptRequestDescriptor&lt;TDocument&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L12686"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Delete a script or search template.
Deletes a stored script or search template.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/delete-stored-script-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;DeleteScriptResponse&gt; DeleteScriptAsync&lt;TDocument&gt;(DeleteScriptRequestDescriptor&lt;TDocument&gt; descriptor, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.DeleteScriptRequestDescriptor-1.html">DeleteScriptRequestDescriptor</a>&lt;TDocument&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.DeleteScriptResponse.html">DeleteScriptResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteScriptAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteScriptAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteScriptAsync__1_Elastic_Clients_Elasticsearch_Id_System_Action_Elastic_Clients_Elasticsearch_DeleteScriptRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteScriptAsync``1(Elastic.Clients.Elasticsearch.Id,System.Action{Elastic.Clients.Elasticsearch.DeleteScriptRequestDescriptor{``0}},System.Threading.CancellationToken)">
  DeleteScriptAsync&lt;TDocument&gt;(Id, Action&lt;DeleteScriptRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L12713"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Delete a script or search template.
Deletes a stored script or search template.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/delete-stored-script-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;DeleteScriptResponse&gt; DeleteScriptAsync&lt;TDocument&gt;(Id id, Action&lt;DeleteScriptRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.DeleteScriptRequestDescriptor-1.html">DeleteScriptRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.DeleteScriptResponse.html">DeleteScriptResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteScriptAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteScriptAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteScriptAsync__1_Elastic_Clients_Elasticsearch_Id_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteScriptAsync``1(Elastic.Clients.Elasticsearch.Id,System.Threading.CancellationToken)">
  DeleteScriptAsync&lt;TDocument&gt;(Id, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L12699"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Delete a script or search template.
Deletes a stored script or search template.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/delete-stored-script-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;DeleteScriptResponse&gt; DeleteScriptAsync&lt;TDocument&gt;(Id id, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.DeleteScriptResponse.html">DeleteScriptResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteScript_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteScript*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteScript__1_Elastic_Clients_Elasticsearch_DeleteScriptRequestDescriptor___0__" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteScript``1(Elastic.Clients.Elasticsearch.DeleteScriptRequestDescriptor{``0})">
  DeleteScript&lt;TDocument&gt;(DeleteScriptRequestDescriptor&lt;TDocument&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L12596"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Delete a script or search template.
Deletes a stored script or search template.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/delete-stored-script-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual DeleteScriptResponse DeleteScript&lt;TDocument&gt;(DeleteScriptRequestDescriptor&lt;TDocument&gt; descriptor)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.DeleteScriptRequestDescriptor-1.html">DeleteScriptRequestDescriptor</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.DeleteScriptResponse.html">DeleteScriptResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteScript_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteScript*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteScript__1_Elastic_Clients_Elasticsearch_Id_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteScript``1(Elastic.Clients.Elasticsearch.Id)">
  DeleteScript&lt;TDocument&gt;(Id)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L12610"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Delete a script or search template.
Deletes a stored script or search template.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/delete-stored-script-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual DeleteScriptResponse DeleteScript&lt;TDocument&gt;(Id id)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.DeleteScriptResponse.html">DeleteScriptResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteScript_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteScript*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_DeleteScript__1_Elastic_Clients_Elasticsearch_Id_System_Action_Elastic_Clients_Elasticsearch_DeleteScriptRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.DeleteScript``1(Elastic.Clients.Elasticsearch.Id,System.Action{Elastic.Clients.Elasticsearch.DeleteScriptRequestDescriptor{``0}})">
  DeleteScript&lt;TDocument&gt;(Id, Action&lt;DeleteScriptRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L12625"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Delete a script or search template.
Deletes a stored script or search template.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/delete-stored-script-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual DeleteScriptResponse DeleteScript&lt;TDocument&gt;(Id id, Action&lt;DeleteScriptRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.DeleteScriptRequestDescriptor-1.html">DeleteScriptRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.DeleteScriptResponse.html">DeleteScriptResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Delete_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Delete*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Delete__1_Elastic_Clients_Elasticsearch_DeleteRequestDescriptor___0__" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Delete``1(Elastic.Clients.Elasticsearch.DeleteRequestDescriptor{``0})">
  Delete&lt;TDocument&gt;(DeleteRequestDescriptor&lt;TDocument&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L7805"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Delete a document.
</p>
<p>
Remove a JSON document from the specified index.
</p>
<p>
NOTE: You cannot send deletion requests directly to a data stream.
To delete a document in a data stream, you must target the backing index containing the document.
</p>
<p>
<strong>Optimistic concurrency control</strong>
</p>
<p>
Delete operations can be made conditional and only be performed if the last modification to the document was assigned the sequence number and primary term specified by the <code>if_seq_no</code> and <code>if_primary_term</code> parameters.
If a mismatch is detected, the operation will result in a <code>VersionConflictException</code> and a status code of <code>409</code>.
</p>
<p>
<strong>Versioning</strong>
</p>
<p>
Each document indexed is versioned.
When deleting a document, the version can be specified to make sure the relevant document you are trying to delete is actually being deleted and it has not changed in the meantime.
Every write operation run on a document, deletes included, causes its version to be incremented.
The version number of a deleted document remains available for a short time after deletion to allow for control of concurrent operations.
The length of time for which a deleted document's version remains available is determined by the <code>index.gc_deletes</code> index setting.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
If routing is used during indexing, the routing value also needs to be specified to delete a document.
</p>
<p>
If the <code>_routing</code> mapping is set to <code>required</code> and no routing value is specified, the delete API throws a <code>RoutingMissingException</code> and rejects the request.
</p>
<p>
For example:
</p>
<pre><code class="lang-csharp">DELETE /my-index-000001/_doc/1?routing=shard-1</code></pre>
<p>
This request deletes the document with ID 1, but it is routed based on the user.
The document is not deleted if the correct routing is not specified.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The delete operation gets hashed into a specific shard ID.
It then gets redirected into the primary shard within that ID group and replicated (if needed) to shard replicas within that ID group.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-delete.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual DeleteResponse Delete&lt;TDocument&gt;(DeleteRequestDescriptor&lt;TDocument&gt; descriptor)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.DeleteRequestDescriptor-1.html">DeleteRequestDescriptor</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.DeleteResponse.html">DeleteResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Delete_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Delete*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Delete__1_Elastic_Clients_Elasticsearch_Id_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Delete``1(Elastic.Clients.Elasticsearch.Id)">
  Delete&lt;TDocument&gt;(Id)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L8384"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Delete a document.
</p>
<p>
Remove a JSON document from the specified index.
</p>
<p>
NOTE: You cannot send deletion requests directly to a data stream.
To delete a document in a data stream, you must target the backing index containing the document.
</p>
<p>
<strong>Optimistic concurrency control</strong>
</p>
<p>
Delete operations can be made conditional and only be performed if the last modification to the document was assigned the sequence number and primary term specified by the <code>if_seq_no</code> and <code>if_primary_term</code> parameters.
If a mismatch is detected, the operation will result in a <code>VersionConflictException</code> and a status code of <code>409</code>.
</p>
<p>
<strong>Versioning</strong>
</p>
<p>
Each document indexed is versioned.
When deleting a document, the version can be specified to make sure the relevant document you are trying to delete is actually being deleted and it has not changed in the meantime.
Every write operation run on a document, deletes included, causes its version to be incremented.
The version number of a deleted document remains available for a short time after deletion to allow for control of concurrent operations.
The length of time for which a deleted document's version remains available is determined by the <code>index.gc_deletes</code> index setting.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
If routing is used during indexing, the routing value also needs to be specified to delete a document.
</p>
<p>
If the <code>_routing</code> mapping is set to <code>required</code> and no routing value is specified, the delete API throws a <code>RoutingMissingException</code> and rejects the request.
</p>
<p>
For example:
</p>
<pre><code class="lang-csharp">DELETE /my-index-000001/_doc/1?routing=shard-1</code></pre>
<p>
This request deletes the document with ID 1, but it is routed based on the user.
The document is not deleted if the correct routing is not specified.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The delete operation gets hashed into a specific shard ID.
It then gets redirected into the primary shard within that ID group and replicated (if needed) to shard replicas within that ID group.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-delete.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual DeleteResponse Delete&lt;TDocument&gt;(Id id)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.DeleteResponse.html">DeleteResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Delete_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Delete*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Delete__1_Elastic_Clients_Elasticsearch_Id_System_Action_Elastic_Clients_Elasticsearch_DeleteRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Delete``1(Elastic.Clients.Elasticsearch.Id,System.Action{Elastic.Clients.Elasticsearch.DeleteRequestDescriptor{``0}})">
  Delete&lt;TDocument&gt;(Id, Action&lt;DeleteRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L8448"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Delete a document.
</p>
<p>
Remove a JSON document from the specified index.
</p>
<p>
NOTE: You cannot send deletion requests directly to a data stream.
To delete a document in a data stream, you must target the backing index containing the document.
</p>
<p>
<strong>Optimistic concurrency control</strong>
</p>
<p>
Delete operations can be made conditional and only be performed if the last modification to the document was assigned the sequence number and primary term specified by the <code>if_seq_no</code> and <code>if_primary_term</code> parameters.
If a mismatch is detected, the operation will result in a <code>VersionConflictException</code> and a status code of <code>409</code>.
</p>
<p>
<strong>Versioning</strong>
</p>
<p>
Each document indexed is versioned.
When deleting a document, the version can be specified to make sure the relevant document you are trying to delete is actually being deleted and it has not changed in the meantime.
Every write operation run on a document, deletes included, causes its version to be incremented.
The version number of a deleted document remains available for a short time after deletion to allow for control of concurrent operations.
The length of time for which a deleted document's version remains available is determined by the <code>index.gc_deletes</code> index setting.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
If routing is used during indexing, the routing value also needs to be specified to delete a document.
</p>
<p>
If the <code>_routing</code> mapping is set to <code>required</code> and no routing value is specified, the delete API throws a <code>RoutingMissingException</code> and rejects the request.
</p>
<p>
For example:
</p>
<pre><code class="lang-csharp">DELETE /my-index-000001/_doc/1?routing=shard-1</code></pre>
<p>
This request deletes the document with ID 1, but it is routed based on the user.
The document is not deleted if the correct routing is not specified.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The delete operation gets hashed into a specific shard ID.
It then gets redirected into the primary shard within that ID group and replicated (if needed) to shard replicas within that ID group.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-delete.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual DeleteResponse Delete&lt;TDocument&gt;(Id id, Action&lt;DeleteRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.DeleteRequestDescriptor-1.html">DeleteRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.DeleteResponse.html">DeleteResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Delete_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Delete*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Delete__1_Elastic_Clients_Elasticsearch_IndexName_Elastic_Clients_Elasticsearch_Id_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Delete``1(Elastic.Clients.Elasticsearch.IndexName,Elastic.Clients.Elasticsearch.Id)">
  Delete&lt;TDocument&gt;(IndexName, Id)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L7868"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Delete a document.
</p>
<p>
Remove a JSON document from the specified index.
</p>
<p>
NOTE: You cannot send deletion requests directly to a data stream.
To delete a document in a data stream, you must target the backing index containing the document.
</p>
<p>
<strong>Optimistic concurrency control</strong>
</p>
<p>
Delete operations can be made conditional and only be performed if the last modification to the document was assigned the sequence number and primary term specified by the <code>if_seq_no</code> and <code>if_primary_term</code> parameters.
If a mismatch is detected, the operation will result in a <code>VersionConflictException</code> and a status code of <code>409</code>.
</p>
<p>
<strong>Versioning</strong>
</p>
<p>
Each document indexed is versioned.
When deleting a document, the version can be specified to make sure the relevant document you are trying to delete is actually being deleted and it has not changed in the meantime.
Every write operation run on a document, deletes included, causes its version to be incremented.
The version number of a deleted document remains available for a short time after deletion to allow for control of concurrent operations.
The length of time for which a deleted document's version remains available is determined by the <code>index.gc_deletes</code> index setting.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
If routing is used during indexing, the routing value also needs to be specified to delete a document.
</p>
<p>
If the <code>_routing</code> mapping is set to <code>required</code> and no routing value is specified, the delete API throws a <code>RoutingMissingException</code> and rejects the request.
</p>
<p>
For example:
</p>
<pre><code class="lang-csharp">DELETE /my-index-000001/_doc/1?routing=shard-1</code></pre>
<p>
This request deletes the document with ID 1, but it is routed based on the user.
The document is not deleted if the correct routing is not specified.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The delete operation gets hashed into a specific shard ID.
It then gets redirected into the primary shard within that ID group and replicated (if needed) to shard replicas within that ID group.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-delete.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual DeleteResponse Delete&lt;TDocument&gt;(IndexName index, Id id)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.DeleteResponse.html">DeleteResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Delete_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Delete*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Delete__1_Elastic_Clients_Elasticsearch_IndexName_Elastic_Clients_Elasticsearch_Id_System_Action_Elastic_Clients_Elasticsearch_DeleteRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Delete``1(Elastic.Clients.Elasticsearch.IndexName,Elastic.Clients.Elasticsearch.Id,System.Action{Elastic.Clients.Elasticsearch.DeleteRequestDescriptor{``0}})">
  Delete&lt;TDocument&gt;(IndexName, Id, Action&lt;DeleteRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L7932"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Delete a document.
</p>
<p>
Remove a JSON document from the specified index.
</p>
<p>
NOTE: You cannot send deletion requests directly to a data stream.
To delete a document in a data stream, you must target the backing index containing the document.
</p>
<p>
<strong>Optimistic concurrency control</strong>
</p>
<p>
Delete operations can be made conditional and only be performed if the last modification to the document was assigned the sequence number and primary term specified by the <code>if_seq_no</code> and <code>if_primary_term</code> parameters.
If a mismatch is detected, the operation will result in a <code>VersionConflictException</code> and a status code of <code>409</code>.
</p>
<p>
<strong>Versioning</strong>
</p>
<p>
Each document indexed is versioned.
When deleting a document, the version can be specified to make sure the relevant document you are trying to delete is actually being deleted and it has not changed in the meantime.
Every write operation run on a document, deletes included, causes its version to be incremented.
The version number of a deleted document remains available for a short time after deletion to allow for control of concurrent operations.
The length of time for which a deleted document's version remains available is determined by the <code>index.gc_deletes</code> index setting.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
If routing is used during indexing, the routing value also needs to be specified to delete a document.
</p>
<p>
If the <code>_routing</code> mapping is set to <code>required</code> and no routing value is specified, the delete API throws a <code>RoutingMissingException</code> and rejects the request.
</p>
<p>
For example:
</p>
<pre><code class="lang-csharp">DELETE /my-index-000001/_doc/1?routing=shard-1</code></pre>
<p>
This request deletes the document with ID 1, but it is routed based on the user.
The document is not deleted if the correct routing is not specified.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The delete operation gets hashed into a specific shard ID.
It then gets redirected into the primary shard within that ID group and replicated (if needed) to shard replicas within that ID group.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-delete.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual DeleteResponse Delete&lt;TDocument&gt;(IndexName index, Id id, Action&lt;DeleteRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.DeleteRequestDescriptor-1.html">DeleteRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.DeleteResponse.html">DeleteResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Delete_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Delete*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Delete__1___0_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Delete``1(``0)">
  Delete&lt;TDocument&gt;(TDocument)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L7997"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Delete a document.
</p>
<p>
Remove a JSON document from the specified index.
</p>
<p>
NOTE: You cannot send deletion requests directly to a data stream.
To delete a document in a data stream, you must target the backing index containing the document.
</p>
<p>
<strong>Optimistic concurrency control</strong>
</p>
<p>
Delete operations can be made conditional and only be performed if the last modification to the document was assigned the sequence number and primary term specified by the <code>if_seq_no</code> and <code>if_primary_term</code> parameters.
If a mismatch is detected, the operation will result in a <code>VersionConflictException</code> and a status code of <code>409</code>.
</p>
<p>
<strong>Versioning</strong>
</p>
<p>
Each document indexed is versioned.
When deleting a document, the version can be specified to make sure the relevant document you are trying to delete is actually being deleted and it has not changed in the meantime.
Every write operation run on a document, deletes included, causes its version to be incremented.
The version number of a deleted document remains available for a short time after deletion to allow for control of concurrent operations.
The length of time for which a deleted document's version remains available is determined by the <code>index.gc_deletes</code> index setting.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
If routing is used during indexing, the routing value also needs to be specified to delete a document.
</p>
<p>
If the <code>_routing</code> mapping is set to <code>required</code> and no routing value is specified, the delete API throws a <code>RoutingMissingException</code> and rejects the request.
</p>
<p>
For example:
</p>
<pre><code class="lang-csharp">DELETE /my-index-000001/_doc/1?routing=shard-1</code></pre>
<p>
This request deletes the document with ID 1, but it is routed based on the user.
The document is not deleted if the correct routing is not specified.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The delete operation gets hashed into a specific shard ID.
It then gets redirected into the primary shard within that ID group and replicated (if needed) to shard replicas within that ID group.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-delete.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual DeleteResponse Delete&lt;TDocument&gt;(TDocument document)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.DeleteResponse.html">DeleteResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Delete_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Delete*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Delete__1___0_Elastic_Clients_Elasticsearch_Id_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Delete``1(``0,Elastic.Clients.Elasticsearch.Id)">
  Delete&lt;TDocument&gt;(TDocument, Id)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L8255"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Delete a document.
</p>
<p>
Remove a JSON document from the specified index.
</p>
<p>
NOTE: You cannot send deletion requests directly to a data stream.
To delete a document in a data stream, you must target the backing index containing the document.
</p>
<p>
<strong>Optimistic concurrency control</strong>
</p>
<p>
Delete operations can be made conditional and only be performed if the last modification to the document was assigned the sequence number and primary term specified by the <code>if_seq_no</code> and <code>if_primary_term</code> parameters.
If a mismatch is detected, the operation will result in a <code>VersionConflictException</code> and a status code of <code>409</code>.
</p>
<p>
<strong>Versioning</strong>
</p>
<p>
Each document indexed is versioned.
When deleting a document, the version can be specified to make sure the relevant document you are trying to delete is actually being deleted and it has not changed in the meantime.
Every write operation run on a document, deletes included, causes its version to be incremented.
The version number of a deleted document remains available for a short time after deletion to allow for control of concurrent operations.
The length of time for which a deleted document's version remains available is determined by the <code>index.gc_deletes</code> index setting.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
If routing is used during indexing, the routing value also needs to be specified to delete a document.
</p>
<p>
If the <code>_routing</code> mapping is set to <code>required</code> and no routing value is specified, the delete API throws a <code>RoutingMissingException</code> and rejects the request.
</p>
<p>
For example:
</p>
<pre><code class="lang-csharp">DELETE /my-index-000001/_doc/1?routing=shard-1</code></pre>
<p>
This request deletes the document with ID 1, but it is routed based on the user.
The document is not deleted if the correct routing is not specified.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The delete operation gets hashed into a specific shard ID.
It then gets redirected into the primary shard within that ID group and replicated (if needed) to shard replicas within that ID group.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-delete.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual DeleteResponse Delete&lt;TDocument&gt;(TDocument document, Id id)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.DeleteResponse.html">DeleteResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Delete_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Delete*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Delete__1___0_Elastic_Clients_Elasticsearch_Id_System_Action_Elastic_Clients_Elasticsearch_DeleteRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Delete``1(``0,Elastic.Clients.Elasticsearch.Id,System.Action{Elastic.Clients.Elasticsearch.DeleteRequestDescriptor{``0}})">
  Delete&lt;TDocument&gt;(TDocument, Id, Action&lt;DeleteRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L8319"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Delete a document.
</p>
<p>
Remove a JSON document from the specified index.
</p>
<p>
NOTE: You cannot send deletion requests directly to a data stream.
To delete a document in a data stream, you must target the backing index containing the document.
</p>
<p>
<strong>Optimistic concurrency control</strong>
</p>
<p>
Delete operations can be made conditional and only be performed if the last modification to the document was assigned the sequence number and primary term specified by the <code>if_seq_no</code> and <code>if_primary_term</code> parameters.
If a mismatch is detected, the operation will result in a <code>VersionConflictException</code> and a status code of <code>409</code>.
</p>
<p>
<strong>Versioning</strong>
</p>
<p>
Each document indexed is versioned.
When deleting a document, the version can be specified to make sure the relevant document you are trying to delete is actually being deleted and it has not changed in the meantime.
Every write operation run on a document, deletes included, causes its version to be incremented.
The version number of a deleted document remains available for a short time after deletion to allow for control of concurrent operations.
The length of time for which a deleted document's version remains available is determined by the <code>index.gc_deletes</code> index setting.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
If routing is used during indexing, the routing value also needs to be specified to delete a document.
</p>
<p>
If the <code>_routing</code> mapping is set to <code>required</code> and no routing value is specified, the delete API throws a <code>RoutingMissingException</code> and rejects the request.
</p>
<p>
For example:
</p>
<pre><code class="lang-csharp">DELETE /my-index-000001/_doc/1?routing=shard-1</code></pre>
<p>
This request deletes the document with ID 1, but it is routed based on the user.
The document is not deleted if the correct routing is not specified.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The delete operation gets hashed into a specific shard ID.
It then gets redirected into the primary shard within that ID group and replicated (if needed) to shard replicas within that ID group.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-delete.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual DeleteResponse Delete&lt;TDocument&gt;(TDocument document, Id id, Action&lt;DeleteRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.DeleteRequestDescriptor-1.html">DeleteRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.DeleteResponse.html">DeleteResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Delete_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Delete*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Delete__1___0_Elastic_Clients_Elasticsearch_IndexName_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Delete``1(``0,Elastic.Clients.Elasticsearch.IndexName)">
  Delete&lt;TDocument&gt;(TDocument, IndexName)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L8126"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Delete a document.
</p>
<p>
Remove a JSON document from the specified index.
</p>
<p>
NOTE: You cannot send deletion requests directly to a data stream.
To delete a document in a data stream, you must target the backing index containing the document.
</p>
<p>
<strong>Optimistic concurrency control</strong>
</p>
<p>
Delete operations can be made conditional and only be performed if the last modification to the document was assigned the sequence number and primary term specified by the <code>if_seq_no</code> and <code>if_primary_term</code> parameters.
If a mismatch is detected, the operation will result in a <code>VersionConflictException</code> and a status code of <code>409</code>.
</p>
<p>
<strong>Versioning</strong>
</p>
<p>
Each document indexed is versioned.
When deleting a document, the version can be specified to make sure the relevant document you are trying to delete is actually being deleted and it has not changed in the meantime.
Every write operation run on a document, deletes included, causes its version to be incremented.
The version number of a deleted document remains available for a short time after deletion to allow for control of concurrent operations.
The length of time for which a deleted document's version remains available is determined by the <code>index.gc_deletes</code> index setting.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
If routing is used during indexing, the routing value also needs to be specified to delete a document.
</p>
<p>
If the <code>_routing</code> mapping is set to <code>required</code> and no routing value is specified, the delete API throws a <code>RoutingMissingException</code> and rejects the request.
</p>
<p>
For example:
</p>
<pre><code class="lang-csharp">DELETE /my-index-000001/_doc/1?routing=shard-1</code></pre>
<p>
This request deletes the document with ID 1, but it is routed based on the user.
The document is not deleted if the correct routing is not specified.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The delete operation gets hashed into a specific shard ID.
It then gets redirected into the primary shard within that ID group and replicated (if needed) to shard replicas within that ID group.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-delete.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual DeleteResponse Delete&lt;TDocument&gt;(TDocument document, IndexName index)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.DeleteResponse.html">DeleteResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Delete_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Delete*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Delete__1___0_Elastic_Clients_Elasticsearch_IndexName_System_Action_Elastic_Clients_Elasticsearch_DeleteRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Delete``1(``0,Elastic.Clients.Elasticsearch.IndexName,System.Action{Elastic.Clients.Elasticsearch.DeleteRequestDescriptor{``0}})">
  Delete&lt;TDocument&gt;(TDocument, IndexName, Action&lt;DeleteRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L8190"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Delete a document.
</p>
<p>
Remove a JSON document from the specified index.
</p>
<p>
NOTE: You cannot send deletion requests directly to a data stream.
To delete a document in a data stream, you must target the backing index containing the document.
</p>
<p>
<strong>Optimistic concurrency control</strong>
</p>
<p>
Delete operations can be made conditional and only be performed if the last modification to the document was assigned the sequence number and primary term specified by the <code>if_seq_no</code> and <code>if_primary_term</code> parameters.
If a mismatch is detected, the operation will result in a <code>VersionConflictException</code> and a status code of <code>409</code>.
</p>
<p>
<strong>Versioning</strong>
</p>
<p>
Each document indexed is versioned.
When deleting a document, the version can be specified to make sure the relevant document you are trying to delete is actually being deleted and it has not changed in the meantime.
Every write operation run on a document, deletes included, causes its version to be incremented.
The version number of a deleted document remains available for a short time after deletion to allow for control of concurrent operations.
The length of time for which a deleted document's version remains available is determined by the <code>index.gc_deletes</code> index setting.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
If routing is used during indexing, the routing value also needs to be specified to delete a document.
</p>
<p>
If the <code>_routing</code> mapping is set to <code>required</code> and no routing value is specified, the delete API throws a <code>RoutingMissingException</code> and rejects the request.
</p>
<p>
For example:
</p>
<pre><code class="lang-csharp">DELETE /my-index-000001/_doc/1?routing=shard-1</code></pre>
<p>
This request deletes the document with ID 1, but it is routed based on the user.
The document is not deleted if the correct routing is not specified.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The delete operation gets hashed into a specific shard ID.
It then gets redirected into the primary shard within that ID group and replicated (if needed) to shard replicas within that ID group.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-delete.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual DeleteResponse Delete&lt;TDocument&gt;(TDocument document, IndexName index, Action&lt;DeleteRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.DeleteRequestDescriptor-1.html">DeleteRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.DeleteResponse.html">DeleteResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Delete_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Delete*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Delete__1___0_System_Action_Elastic_Clients_Elasticsearch_DeleteRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Delete``1(``0,System.Action{Elastic.Clients.Elasticsearch.DeleteRequestDescriptor{``0}})">
  Delete&lt;TDocument&gt;(TDocument, Action&lt;DeleteRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L8061"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Delete a document.
</p>
<p>
Remove a JSON document from the specified index.
</p>
<p>
NOTE: You cannot send deletion requests directly to a data stream.
To delete a document in a data stream, you must target the backing index containing the document.
</p>
<p>
<strong>Optimistic concurrency control</strong>
</p>
<p>
Delete operations can be made conditional and only be performed if the last modification to the document was assigned the sequence number and primary term specified by the <code>if_seq_no</code> and <code>if_primary_term</code> parameters.
If a mismatch is detected, the operation will result in a <code>VersionConflictException</code> and a status code of <code>409</code>.
</p>
<p>
<strong>Versioning</strong>
</p>
<p>
Each document indexed is versioned.
When deleting a document, the version can be specified to make sure the relevant document you are trying to delete is actually being deleted and it has not changed in the meantime.
Every write operation run on a document, deletes included, causes its version to be incremented.
The version number of a deleted document remains available for a short time after deletion to allow for control of concurrent operations.
The length of time for which a deleted document's version remains available is determined by the <code>index.gc_deletes</code> index setting.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
If routing is used during indexing, the routing value also needs to be specified to delete a document.
</p>
<p>
If the <code>_routing</code> mapping is set to <code>required</code> and no routing value is specified, the delete API throws a <code>RoutingMissingException</code> and rejects the request.
</p>
<p>
For example:
</p>
<pre><code class="lang-csharp">DELETE /my-index-000001/_doc/1?routing=shard-1</code></pre>
<p>
This request deletes the document with ID 1, but it is routed based on the user.
The document is not deleted if the correct routing is not specified.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The delete operation gets hashed into a specific shard ID.
It then gets redirected into the primary shard within that ID group and replicated (if needed) to shard replicas within that ID group.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-delete.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual DeleteResponse Delete&lt;TDocument&gt;(TDocument document, Action&lt;DeleteRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.DeleteRequestDescriptor-1.html">DeleteRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.DeleteResponse.html">DeleteResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Exists_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Exists*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Exists_Elastic_Clients_Elasticsearch_ExistsRequest_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Exists(Elastic.Clients.Elasticsearch.ExistsRequest)">
  Exists(ExistsRequest)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L12791"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Check a document.
</p>
<p>
Verify that a document exists.
For example, check to see if a document with the <code>_id</code> 0 exists:
</p>
<pre><code class="lang-csharp">HEAD my-index-000001/_doc/0</code></pre>
<p>
If the document exists, the API returns a status code of <code>200 - OK</code>.
If the document doesn’t exist, the API returns <code>404 - Not Found</code>.
</p>
<p>
<strong>Versioning support</strong>
</p>
<p>
You can use the <code>version</code> parameter to check the document only if its current version is equal to the specified one.
</p>
<p>
Internally, Elasticsearch has marked the old document as deleted and added an entirely new document.
The old version of the document doesn't disappear immediately, although you won't be able to access it.
Elasticsearch cleans up deleted documents in the background as you continue to index more data.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual ExistsResponse Exists(ExistsRequest request)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.ExistsRequest.html">ExistsRequest</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ExistsResponse.html">ExistsResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Exists_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Exists*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Exists_Elastic_Clients_Elasticsearch_ExistsRequestDescriptor_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Exists(Elastic.Clients.Elasticsearch.ExistsRequestDescriptor)">
  Exists(ExistsRequestDescriptor)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L13260"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Check a document.
</p>
<p>
Verify that a document exists.
For example, check to see if a document with the <code>_id</code> 0 exists:
</p>
<pre><code class="lang-csharp">HEAD my-index-000001/_doc/0</code></pre>
<p>
If the document exists, the API returns a status code of <code>200 - OK</code>.
If the document doesn’t exist, the API returns <code>404 - Not Found</code>.
</p>
<p>
<strong>Versioning support</strong>
</p>
<p>
You can use the <code>version</code> parameter to check the document only if its current version is equal to the specified one.
</p>
<p>
Internally, Elasticsearch has marked the old document as deleted and added an entirely new document.
The old version of the document doesn't disappear immediately, although you won't be able to access it.
Elasticsearch cleans up deleted documents in the background as you continue to index more data.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual ExistsResponse Exists(ExistsRequestDescriptor descriptor)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.ExistsRequestDescriptor.html">ExistsRequestDescriptor</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ExistsResponse.html">ExistsResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Exists_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Exists*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Exists_Elastic_Clients_Elasticsearch_IndexName_Elastic_Clients_Elasticsearch_Id_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Exists(Elastic.Clients.Elasticsearch.IndexName,Elastic.Clients.Elasticsearch.Id)">
  Exists(IndexName, Id)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L13295"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Check a document.
</p>
<p>
Verify that a document exists.
For example, check to see if a document with the <code>_id</code> 0 exists:
</p>
<pre><code class="lang-csharp">HEAD my-index-000001/_doc/0</code></pre>
<p>
If the document exists, the API returns a status code of <code>200 - OK</code>.
If the document doesn’t exist, the API returns <code>404 - Not Found</code>.
</p>
<p>
<strong>Versioning support</strong>
</p>
<p>
You can use the <code>version</code> parameter to check the document only if its current version is equal to the specified one.
</p>
<p>
Internally, Elasticsearch has marked the old document as deleted and added an entirely new document.
The old version of the document doesn't disappear immediately, although you won't be able to access it.
Elasticsearch cleans up deleted documents in the background as you continue to index more data.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual ExistsResponse Exists(IndexName index, Id id)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ExistsResponse.html">ExistsResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Exists_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Exists*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Exists_Elastic_Clients_Elasticsearch_IndexName_Elastic_Clients_Elasticsearch_Id_System_Action_Elastic_Clients_Elasticsearch_ExistsRequestDescriptor__" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Exists(Elastic.Clients.Elasticsearch.IndexName,Elastic.Clients.Elasticsearch.Id,System.Action{Elastic.Clients.Elasticsearch.ExistsRequestDescriptor})">
  Exists(IndexName, Id, Action&lt;ExistsRequestDescriptor&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L13331"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Check a document.
</p>
<p>
Verify that a document exists.
For example, check to see if a document with the <code>_id</code> 0 exists:
</p>
<pre><code class="lang-csharp">HEAD my-index-000001/_doc/0</code></pre>
<p>
If the document exists, the API returns a status code of <code>200 - OK</code>.
If the document doesn’t exist, the API returns <code>404 - Not Found</code>.
</p>
<p>
<strong>Versioning support</strong>
</p>
<p>
You can use the <code>version</code> parameter to check the document only if its current version is equal to the specified one.
</p>
<p>
Internally, Elasticsearch has marked the old document as deleted and added an entirely new document.
The old version of the document doesn't disappear immediately, although you won't be able to access it.
Elasticsearch cleans up deleted documents in the background as you continue to index more data.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual ExistsResponse Exists(IndexName index, Id id, Action&lt;ExistsRequestDescriptor&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ExistsRequestDescriptor.html">ExistsRequestDescriptor</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ExistsResponse.html">ExistsResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsAsync_Elastic_Clients_Elasticsearch_ExistsRequest_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsAsync(Elastic.Clients.Elasticsearch.ExistsRequest,System.Threading.CancellationToken)">
  ExistsAsync(ExistsRequest, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L12826"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Check a document.
</p>
<p>
Verify that a document exists.
For example, check to see if a document with the <code>_id</code> 0 exists:
</p>
<pre><code class="lang-csharp">HEAD my-index-000001/_doc/0</code></pre>
<p>
If the document exists, the API returns a status code of <code>200 - OK</code>.
If the document doesn’t exist, the API returns <code>404 - Not Found</code>.
</p>
<p>
<strong>Versioning support</strong>
</p>
<p>
You can use the <code>version</code> parameter to check the document only if its current version is equal to the specified one.
</p>
<p>
Internally, Elasticsearch has marked the old document as deleted and added an entirely new document.
The old version of the document doesn't disappear immediately, although you won't be able to access it.
Elasticsearch cleans up deleted documents in the background as you continue to index more data.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;ExistsResponse&gt; ExistsAsync(ExistsRequest request, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.ExistsRequest.html">ExistsRequest</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ExistsResponse.html">ExistsResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsAsync_Elastic_Clients_Elasticsearch_ExistsRequestDescriptor_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsAsync(Elastic.Clients.Elasticsearch.ExistsRequestDescriptor,System.Threading.CancellationToken)">
  ExistsAsync(ExistsRequestDescriptor, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L13757"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Check a document.
</p>
<p>
Verify that a document exists.
For example, check to see if a document with the <code>_id</code> 0 exists:
</p>
<pre><code class="lang-csharp">HEAD my-index-000001/_doc/0</code></pre>
<p>
If the document exists, the API returns a status code of <code>200 - OK</code>.
If the document doesn’t exist, the API returns <code>404 - Not Found</code>.
</p>
<p>
<strong>Versioning support</strong>
</p>
<p>
You can use the <code>version</code> parameter to check the document only if its current version is equal to the specified one.
</p>
<p>
Internally, Elasticsearch has marked the old document as deleted and added an entirely new document.
The old version of the document doesn't disappear immediately, although you won't be able to access it.
Elasticsearch cleans up deleted documents in the background as you continue to index more data.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;ExistsResponse&gt; ExistsAsync(ExistsRequestDescriptor descriptor, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.ExistsRequestDescriptor.html">ExistsRequestDescriptor</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ExistsResponse.html">ExistsResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsAsync_Elastic_Clients_Elasticsearch_IndexName_Elastic_Clients_Elasticsearch_Id_System_Action_Elastic_Clients_Elasticsearch_ExistsRequestDescriptor__System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsAsync(Elastic.Clients.Elasticsearch.IndexName,Elastic.Clients.Elasticsearch.Id,System.Action{Elastic.Clients.Elasticsearch.ExistsRequestDescriptor},System.Threading.CancellationToken)">
  ExistsAsync(IndexName, Id, Action&lt;ExistsRequestDescriptor&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L13826"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Check a document.
</p>
<p>
Verify that a document exists.
For example, check to see if a document with the <code>_id</code> 0 exists:
</p>
<pre><code class="lang-csharp">HEAD my-index-000001/_doc/0</code></pre>
<p>
If the document exists, the API returns a status code of <code>200 - OK</code>.
If the document doesn’t exist, the API returns <code>404 - Not Found</code>.
</p>
<p>
<strong>Versioning support</strong>
</p>
<p>
You can use the <code>version</code> parameter to check the document only if its current version is equal to the specified one.
</p>
<p>
Internally, Elasticsearch has marked the old document as deleted and added an entirely new document.
The old version of the document doesn't disappear immediately, although you won't be able to access it.
Elasticsearch cleans up deleted documents in the background as you continue to index more data.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;ExistsResponse&gt; ExistsAsync(IndexName index, Id id, Action&lt;ExistsRequestDescriptor&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ExistsRequestDescriptor.html">ExistsRequestDescriptor</a>&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ExistsResponse.html">ExistsResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsAsync_Elastic_Clients_Elasticsearch_IndexName_Elastic_Clients_Elasticsearch_Id_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsAsync(Elastic.Clients.Elasticsearch.IndexName,Elastic.Clients.Elasticsearch.Id,System.Threading.CancellationToken)">
  ExistsAsync(IndexName, Id, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L13791"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Check a document.
</p>
<p>
Verify that a document exists.
For example, check to see if a document with the <code>_id</code> 0 exists:
</p>
<pre><code class="lang-csharp">HEAD my-index-000001/_doc/0</code></pre>
<p>
If the document exists, the API returns a status code of <code>200 - OK</code>.
If the document doesn’t exist, the API returns <code>404 - Not Found</code>.
</p>
<p>
<strong>Versioning support</strong>
</p>
<p>
You can use the <code>version</code> parameter to check the document only if its current version is equal to the specified one.
</p>
<p>
Internally, Elasticsearch has marked the old document as deleted and added an entirely new document.
The old version of the document doesn't disappear immediately, although you won't be able to access it.
Elasticsearch cleans up deleted documents in the background as you continue to index more data.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;ExistsResponse&gt; ExistsAsync(IndexName index, Id id, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ExistsResponse.html">ExistsResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsAsync__1_Elastic_Clients_Elasticsearch_ExistsRequestDescriptor___0__System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsAsync``1(Elastic.Clients.Elasticsearch.ExistsRequestDescriptor{``0},System.Threading.CancellationToken)">
  ExistsAsync&lt;TDocument&gt;(ExistsRequestDescriptor&lt;TDocument&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L13368"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Check a document.
</p>
<p>
Verify that a document exists.
For example, check to see if a document with the <code>_id</code> 0 exists:
</p>
<pre><code class="lang-csharp">HEAD my-index-000001/_doc/0</code></pre>
<p>
If the document exists, the API returns a status code of <code>200 - OK</code>.
If the document doesn’t exist, the API returns <code>404 - Not Found</code>.
</p>
<p>
<strong>Versioning support</strong>
</p>
<p>
You can use the <code>version</code> parameter to check the document only if its current version is equal to the specified one.
</p>
<p>
Internally, Elasticsearch has marked the old document as deleted and added an entirely new document.
The old version of the document doesn't disappear immediately, although you won't be able to access it.
Elasticsearch cleans up deleted documents in the background as you continue to index more data.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;ExistsResponse&gt; ExistsAsync&lt;TDocument&gt;(ExistsRequestDescriptor&lt;TDocument&gt; descriptor, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.ExistsRequestDescriptor-1.html">ExistsRequestDescriptor</a>&lt;TDocument&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ExistsResponse.html">ExistsResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsAsync__1_Elastic_Clients_Elasticsearch_Id_System_Action_Elastic_Clients_Elasticsearch_ExistsRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsAsync``1(Elastic.Clients.Elasticsearch.Id,System.Action{Elastic.Clients.Elasticsearch.ExistsRequestDescriptor{``0}},System.Threading.CancellationToken)">
  ExistsAsync&lt;TDocument&gt;(Id, Action&lt;ExistsRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L13721"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Check a document.
</p>
<p>
Verify that a document exists.
For example, check to see if a document with the <code>_id</code> 0 exists:
</p>
<pre><code class="lang-csharp">HEAD my-index-000001/_doc/0</code></pre>
<p>
If the document exists, the API returns a status code of <code>200 - OK</code>.
If the document doesn’t exist, the API returns <code>404 - Not Found</code>.
</p>
<p>
<strong>Versioning support</strong>
</p>
<p>
You can use the <code>version</code> parameter to check the document only if its current version is equal to the specified one.
</p>
<p>
Internally, Elasticsearch has marked the old document as deleted and added an entirely new document.
The old version of the document doesn't disappear immediately, although you won't be able to access it.
Elasticsearch cleans up deleted documents in the background as you continue to index more data.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;ExistsResponse&gt; ExistsAsync&lt;TDocument&gt;(Id id, Action&lt;ExistsRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ExistsRequestDescriptor-1.html">ExistsRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ExistsResponse.html">ExistsResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsAsync__1_Elastic_Clients_Elasticsearch_Id_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsAsync``1(Elastic.Clients.Elasticsearch.Id,System.Threading.CancellationToken)">
  ExistsAsync&lt;TDocument&gt;(Id, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L13686"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Check a document.
</p>
<p>
Verify that a document exists.
For example, check to see if a document with the <code>_id</code> 0 exists:
</p>
<pre><code class="lang-csharp">HEAD my-index-000001/_doc/0</code></pre>
<p>
If the document exists, the API returns a status code of <code>200 - OK</code>.
If the document doesn’t exist, the API returns <code>404 - Not Found</code>.
</p>
<p>
<strong>Versioning support</strong>
</p>
<p>
You can use the <code>version</code> parameter to check the document only if its current version is equal to the specified one.
</p>
<p>
Internally, Elasticsearch has marked the old document as deleted and added an entirely new document.
The old version of the document doesn't disappear immediately, although you won't be able to access it.
Elasticsearch cleans up deleted documents in the background as you continue to index more data.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;ExistsResponse&gt; ExistsAsync&lt;TDocument&gt;(Id id, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ExistsResponse.html">ExistsResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsAsync__1_Elastic_Clients_Elasticsearch_IndexName_Elastic_Clients_Elasticsearch_Id_System_Action_Elastic_Clients_Elasticsearch_ExistsRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsAsync``1(Elastic.Clients.Elasticsearch.IndexName,Elastic.Clients.Elasticsearch.Id,System.Action{Elastic.Clients.Elasticsearch.ExistsRequestDescriptor{``0}},System.Threading.CancellationToken)">
  ExistsAsync&lt;TDocument&gt;(IndexName, Id, Action&lt;ExistsRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L13437"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Check a document.
</p>
<p>
Verify that a document exists.
For example, check to see if a document with the <code>_id</code> 0 exists:
</p>
<pre><code class="lang-csharp">HEAD my-index-000001/_doc/0</code></pre>
<p>
If the document exists, the API returns a status code of <code>200 - OK</code>.
If the document doesn’t exist, the API returns <code>404 - Not Found</code>.
</p>
<p>
<strong>Versioning support</strong>
</p>
<p>
You can use the <code>version</code> parameter to check the document only if its current version is equal to the specified one.
</p>
<p>
Internally, Elasticsearch has marked the old document as deleted and added an entirely new document.
The old version of the document doesn't disappear immediately, although you won't be able to access it.
Elasticsearch cleans up deleted documents in the background as you continue to index more data.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;ExistsResponse&gt; ExistsAsync&lt;TDocument&gt;(IndexName index, Id id, Action&lt;ExistsRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ExistsRequestDescriptor-1.html">ExistsRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ExistsResponse.html">ExistsResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsAsync__1_Elastic_Clients_Elasticsearch_IndexName_Elastic_Clients_Elasticsearch_Id_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsAsync``1(Elastic.Clients.Elasticsearch.IndexName,Elastic.Clients.Elasticsearch.Id,System.Threading.CancellationToken)">
  ExistsAsync&lt;TDocument&gt;(IndexName, Id, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L13402"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Check a document.
</p>
<p>
Verify that a document exists.
For example, check to see if a document with the <code>_id</code> 0 exists:
</p>
<pre><code class="lang-csharp">HEAD my-index-000001/_doc/0</code></pre>
<p>
If the document exists, the API returns a status code of <code>200 - OK</code>.
If the document doesn’t exist, the API returns <code>404 - Not Found</code>.
</p>
<p>
<strong>Versioning support</strong>
</p>
<p>
You can use the <code>version</code> parameter to check the document only if its current version is equal to the specified one.
</p>
<p>
Internally, Elasticsearch has marked the old document as deleted and added an entirely new document.
The old version of the document doesn't disappear immediately, although you won't be able to access it.
Elasticsearch cleans up deleted documents in the background as you continue to index more data.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;ExistsResponse&gt; ExistsAsync&lt;TDocument&gt;(IndexName index, Id id, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ExistsResponse.html">ExistsResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsAsync__1___0_Elastic_Clients_Elasticsearch_Id_System_Action_Elastic_Clients_Elasticsearch_ExistsRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsAsync``1(``0,Elastic.Clients.Elasticsearch.Id,System.Action{Elastic.Clients.Elasticsearch.ExistsRequestDescriptor{``0}},System.Threading.CancellationToken)">
  ExistsAsync&lt;TDocument&gt;(TDocument, Id, Action&lt;ExistsRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L13650"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Check a document.
</p>
<p>
Verify that a document exists.
For example, check to see if a document with the <code>_id</code> 0 exists:
</p>
<pre><code class="lang-csharp">HEAD my-index-000001/_doc/0</code></pre>
<p>
If the document exists, the API returns a status code of <code>200 - OK</code>.
If the document doesn’t exist, the API returns <code>404 - Not Found</code>.
</p>
<p>
<strong>Versioning support</strong>
</p>
<p>
You can use the <code>version</code> parameter to check the document only if its current version is equal to the specified one.
</p>
<p>
Internally, Elasticsearch has marked the old document as deleted and added an entirely new document.
The old version of the document doesn't disappear immediately, although you won't be able to access it.
Elasticsearch cleans up deleted documents in the background as you continue to index more data.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;ExistsResponse&gt; ExistsAsync&lt;TDocument&gt;(TDocument document, Id id, Action&lt;ExistsRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ExistsRequestDescriptor-1.html">ExistsRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ExistsResponse.html">ExistsResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsAsync__1___0_Elastic_Clients_Elasticsearch_Id_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsAsync``1(``0,Elastic.Clients.Elasticsearch.Id,System.Threading.CancellationToken)">
  ExistsAsync&lt;TDocument&gt;(TDocument, Id, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L13615"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Check a document.
</p>
<p>
Verify that a document exists.
For example, check to see if a document with the <code>_id</code> 0 exists:
</p>
<pre><code class="lang-csharp">HEAD my-index-000001/_doc/0</code></pre>
<p>
If the document exists, the API returns a status code of <code>200 - OK</code>.
If the document doesn’t exist, the API returns <code>404 - Not Found</code>.
</p>
<p>
<strong>Versioning support</strong>
</p>
<p>
You can use the <code>version</code> parameter to check the document only if its current version is equal to the specified one.
</p>
<p>
Internally, Elasticsearch has marked the old document as deleted and added an entirely new document.
The old version of the document doesn't disappear immediately, although you won't be able to access it.
Elasticsearch cleans up deleted documents in the background as you continue to index more data.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;ExistsResponse&gt; ExistsAsync&lt;TDocument&gt;(TDocument document, Id id, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ExistsResponse.html">ExistsResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsAsync__1___0_Elastic_Clients_Elasticsearch_IndexName_System_Action_Elastic_Clients_Elasticsearch_ExistsRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsAsync``1(``0,Elastic.Clients.Elasticsearch.IndexName,System.Action{Elastic.Clients.Elasticsearch.ExistsRequestDescriptor{``0}},System.Threading.CancellationToken)">
  ExistsAsync&lt;TDocument&gt;(TDocument, IndexName, Action&lt;ExistsRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L13579"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Check a document.
</p>
<p>
Verify that a document exists.
For example, check to see if a document with the <code>_id</code> 0 exists:
</p>
<pre><code class="lang-csharp">HEAD my-index-000001/_doc/0</code></pre>
<p>
If the document exists, the API returns a status code of <code>200 - OK</code>.
If the document doesn’t exist, the API returns <code>404 - Not Found</code>.
</p>
<p>
<strong>Versioning support</strong>
</p>
<p>
You can use the <code>version</code> parameter to check the document only if its current version is equal to the specified one.
</p>
<p>
Internally, Elasticsearch has marked the old document as deleted and added an entirely new document.
The old version of the document doesn't disappear immediately, although you won't be able to access it.
Elasticsearch cleans up deleted documents in the background as you continue to index more data.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;ExistsResponse&gt; ExistsAsync&lt;TDocument&gt;(TDocument document, IndexName index, Action&lt;ExistsRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ExistsRequestDescriptor-1.html">ExistsRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ExistsResponse.html">ExistsResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsAsync__1___0_Elastic_Clients_Elasticsearch_IndexName_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsAsync``1(``0,Elastic.Clients.Elasticsearch.IndexName,System.Threading.CancellationToken)">
  ExistsAsync&lt;TDocument&gt;(TDocument, IndexName, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L13544"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Check a document.
</p>
<p>
Verify that a document exists.
For example, check to see if a document with the <code>_id</code> 0 exists:
</p>
<pre><code class="lang-csharp">HEAD my-index-000001/_doc/0</code></pre>
<p>
If the document exists, the API returns a status code of <code>200 - OK</code>.
If the document doesn’t exist, the API returns <code>404 - Not Found</code>.
</p>
<p>
<strong>Versioning support</strong>
</p>
<p>
You can use the <code>version</code> parameter to check the document only if its current version is equal to the specified one.
</p>
<p>
Internally, Elasticsearch has marked the old document as deleted and added an entirely new document.
The old version of the document doesn't disappear immediately, although you won't be able to access it.
Elasticsearch cleans up deleted documents in the background as you continue to index more data.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;ExistsResponse&gt; ExistsAsync&lt;TDocument&gt;(TDocument document, IndexName index, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ExistsResponse.html">ExistsResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsAsync__1___0_System_Action_Elastic_Clients_Elasticsearch_ExistsRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsAsync``1(``0,System.Action{Elastic.Clients.Elasticsearch.ExistsRequestDescriptor{``0}},System.Threading.CancellationToken)">
  ExistsAsync&lt;TDocument&gt;(TDocument, Action&lt;ExistsRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L13508"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Check a document.
</p>
<p>
Verify that a document exists.
For example, check to see if a document with the <code>_id</code> 0 exists:
</p>
<pre><code class="lang-csharp">HEAD my-index-000001/_doc/0</code></pre>
<p>
If the document exists, the API returns a status code of <code>200 - OK</code>.
If the document doesn’t exist, the API returns <code>404 - Not Found</code>.
</p>
<p>
<strong>Versioning support</strong>
</p>
<p>
You can use the <code>version</code> parameter to check the document only if its current version is equal to the specified one.
</p>
<p>
Internally, Elasticsearch has marked the old document as deleted and added an entirely new document.
The old version of the document doesn't disappear immediately, although you won't be able to access it.
Elasticsearch cleans up deleted documents in the background as you continue to index more data.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;ExistsResponse&gt; ExistsAsync&lt;TDocument&gt;(TDocument document, Action&lt;ExistsRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ExistsRequestDescriptor-1.html">ExistsRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ExistsResponse.html">ExistsResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsAsync__1___0_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsAsync``1(``0,System.Threading.CancellationToken)">
  ExistsAsync&lt;TDocument&gt;(TDocument, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L13473"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Check a document.
</p>
<p>
Verify that a document exists.
For example, check to see if a document with the <code>_id</code> 0 exists:
</p>
<pre><code class="lang-csharp">HEAD my-index-000001/_doc/0</code></pre>
<p>
If the document exists, the API returns a status code of <code>200 - OK</code>.
If the document doesn’t exist, the API returns <code>404 - Not Found</code>.
</p>
<p>
<strong>Versioning support</strong>
</p>
<p>
You can use the <code>version</code> parameter to check the document only if its current version is equal to the specified one.
</p>
<p>
Internally, Elasticsearch has marked the old document as deleted and added an entirely new document.
The old version of the document doesn't disappear immediately, although you won't be able to access it.
Elasticsearch cleans up deleted documents in the background as you continue to index more data.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;ExistsResponse&gt; ExistsAsync&lt;TDocument&gt;(TDocument document, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ExistsResponse.html">ExistsResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsSource_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsSource*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsSource_Elastic_Clients_Elasticsearch_ExistsSourceRequest_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsSource(Elastic.Clients.Elasticsearch.ExistsSourceRequest)">
  ExistsSource(ExistsSourceRequest)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L13850"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Check for a document source.
</p>
<p>
Check whether a document source exists in an index.
For example:
</p>
<pre><code class="lang-csharp">HEAD my-index-000001/_source/1</code></pre>
<p>
A document's source is not available if it is disabled in the mapping.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual ExistsSourceResponse ExistsSource(ExistsSourceRequest request)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.ExistsSourceRequest.html">ExistsSourceRequest</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ExistsSourceResponse.html">ExistsSourceResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsSource_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsSource*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsSource_Elastic_Clients_Elasticsearch_ExistsSourceRequestDescriptor_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsSource(Elastic.Clients.Elasticsearch.ExistsSourceRequestDescriptor)">
  ExistsSource(ExistsSourceRequestDescriptor)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L14163"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Check for a document source.
</p>
<p>
Check whether a document source exists in an index.
For example:
</p>
<pre><code class="lang-csharp">HEAD my-index-000001/_source/1</code></pre>
<p>
A document's source is not available if it is disabled in the mapping.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual ExistsSourceResponse ExistsSource(ExistsSourceRequestDescriptor descriptor)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.ExistsSourceRequestDescriptor.html">ExistsSourceRequestDescriptor</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ExistsSourceResponse.html">ExistsSourceResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsSource_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsSource*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsSource_Elastic_Clients_Elasticsearch_IndexName_Elastic_Clients_Elasticsearch_Id_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsSource(Elastic.Clients.Elasticsearch.IndexName,Elastic.Clients.Elasticsearch.Id)">
  ExistsSource(IndexName, Id)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L14186"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Check for a document source.
</p>
<p>
Check whether a document source exists in an index.
For example:
</p>
<pre><code class="lang-csharp">HEAD my-index-000001/_source/1</code></pre>
<p>
A document's source is not available if it is disabled in the mapping.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual ExistsSourceResponse ExistsSource(IndexName index, Id id)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ExistsSourceResponse.html">ExistsSourceResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsSource_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsSource*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsSource_Elastic_Clients_Elasticsearch_IndexName_Elastic_Clients_Elasticsearch_Id_System_Action_Elastic_Clients_Elasticsearch_ExistsSourceRequestDescriptor__" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsSource(Elastic.Clients.Elasticsearch.IndexName,Elastic.Clients.Elasticsearch.Id,System.Action{Elastic.Clients.Elasticsearch.ExistsSourceRequestDescriptor})">
  ExistsSource(IndexName, Id, Action&lt;ExistsSourceRequestDescriptor&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L14210"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Check for a document source.
</p>
<p>
Check whether a document source exists in an index.
For example:
</p>
<pre><code class="lang-csharp">HEAD my-index-000001/_source/1</code></pre>
<p>
A document's source is not available if it is disabled in the mapping.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual ExistsSourceResponse ExistsSource(IndexName index, Id id, Action&lt;ExistsSourceRequestDescriptor&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ExistsSourceRequestDescriptor.html">ExistsSourceRequestDescriptor</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ExistsSourceResponse.html">ExistsSourceResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsSourceAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsSourceAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsSourceAsync_Elastic_Clients_Elasticsearch_ExistsSourceRequest_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsSourceAsync(Elastic.Clients.Elasticsearch.ExistsSourceRequest,System.Threading.CancellationToken)">
  ExistsSourceAsync(ExistsSourceRequest, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L13873"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Check for a document source.
</p>
<p>
Check whether a document source exists in an index.
For example:
</p>
<pre><code class="lang-csharp">HEAD my-index-000001/_source/1</code></pre>
<p>
A document's source is not available if it is disabled in the mapping.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;ExistsSourceResponse&gt; ExistsSourceAsync(ExistsSourceRequest request, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.ExistsSourceRequest.html">ExistsSourceRequest</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ExistsSourceResponse.html">ExistsSourceResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsSourceAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsSourceAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsSourceAsync_Elastic_Clients_Elasticsearch_ExistsSourceRequestDescriptor_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsSourceAsync(Elastic.Clients.Elasticsearch.ExistsSourceRequestDescriptor,System.Threading.CancellationToken)">
  ExistsSourceAsync(ExistsSourceRequestDescriptor, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L14492"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Check for a document source.
</p>
<p>
Check whether a document source exists in an index.
For example:
</p>
<pre><code class="lang-csharp">HEAD my-index-000001/_source/1</code></pre>
<p>
A document's source is not available if it is disabled in the mapping.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;ExistsSourceResponse&gt; ExistsSourceAsync(ExistsSourceRequestDescriptor descriptor, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.ExistsSourceRequestDescriptor.html">ExistsSourceRequestDescriptor</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ExistsSourceResponse.html">ExistsSourceResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsSourceAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsSourceAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsSourceAsync_Elastic_Clients_Elasticsearch_IndexName_Elastic_Clients_Elasticsearch_Id_System_Action_Elastic_Clients_Elasticsearch_ExistsSourceRequestDescriptor__System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsSourceAsync(Elastic.Clients.Elasticsearch.IndexName,Elastic.Clients.Elasticsearch.Id,System.Action{Elastic.Clients.Elasticsearch.ExistsSourceRequestDescriptor},System.Threading.CancellationToken)">
  ExistsSourceAsync(IndexName, Id, Action&lt;ExistsSourceRequestDescriptor&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L14537"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Check for a document source.
</p>
<p>
Check whether a document source exists in an index.
For example:
</p>
<pre><code class="lang-csharp">HEAD my-index-000001/_source/1</code></pre>
<p>
A document's source is not available if it is disabled in the mapping.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;ExistsSourceResponse&gt; ExistsSourceAsync(IndexName index, Id id, Action&lt;ExistsSourceRequestDescriptor&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ExistsSourceRequestDescriptor.html">ExistsSourceRequestDescriptor</a>&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ExistsSourceResponse.html">ExistsSourceResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsSourceAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsSourceAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsSourceAsync_Elastic_Clients_Elasticsearch_IndexName_Elastic_Clients_Elasticsearch_Id_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsSourceAsync(Elastic.Clients.Elasticsearch.IndexName,Elastic.Clients.Elasticsearch.Id,System.Threading.CancellationToken)">
  ExistsSourceAsync(IndexName, Id, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L14514"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Check for a document source.
</p>
<p>
Check whether a document source exists in an index.
For example:
</p>
<pre><code class="lang-csharp">HEAD my-index-000001/_source/1</code></pre>
<p>
A document's source is not available if it is disabled in the mapping.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;ExistsSourceResponse&gt; ExistsSourceAsync(IndexName index, Id id, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ExistsSourceResponse.html">ExistsSourceResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsSourceAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsSourceAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsSourceAsync__1_Elastic_Clients_Elasticsearch_ExistsSourceRequestDescriptor___0__System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsSourceAsync``1(Elastic.Clients.Elasticsearch.ExistsSourceRequestDescriptor{``0},System.Threading.CancellationToken)">
  ExistsSourceAsync&lt;TDocument&gt;(ExistsSourceRequestDescriptor&lt;TDocument&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L14235"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Check for a document source.
</p>
<p>
Check whether a document source exists in an index.
For example:
</p>
<pre><code class="lang-csharp">HEAD my-index-000001/_source/1</code></pre>
<p>
A document's source is not available if it is disabled in the mapping.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;ExistsSourceResponse&gt; ExistsSourceAsync&lt;TDocument&gt;(ExistsSourceRequestDescriptor&lt;TDocument&gt; descriptor, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.ExistsSourceRequestDescriptor-1.html">ExistsSourceRequestDescriptor</a>&lt;TDocument&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ExistsSourceResponse.html">ExistsSourceResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsSourceAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsSourceAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsSourceAsync__1_Elastic_Clients_Elasticsearch_Id_System_Action_Elastic_Clients_Elasticsearch_ExistsSourceRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsSourceAsync``1(Elastic.Clients.Elasticsearch.Id,System.Action{Elastic.Clients.Elasticsearch.ExistsSourceRequestDescriptor{``0}},System.Threading.CancellationToken)">
  ExistsSourceAsync&lt;TDocument&gt;(Id, Action&lt;ExistsSourceRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L14468"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Check for a document source.
</p>
<p>
Check whether a document source exists in an index.
For example:
</p>
<pre><code class="lang-csharp">HEAD my-index-000001/_source/1</code></pre>
<p>
A document's source is not available if it is disabled in the mapping.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;ExistsSourceResponse&gt; ExistsSourceAsync&lt;TDocument&gt;(Id id, Action&lt;ExistsSourceRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ExistsSourceRequestDescriptor-1.html">ExistsSourceRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ExistsSourceResponse.html">ExistsSourceResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsSourceAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsSourceAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsSourceAsync__1_Elastic_Clients_Elasticsearch_Id_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsSourceAsync``1(Elastic.Clients.Elasticsearch.Id,System.Threading.CancellationToken)">
  ExistsSourceAsync&lt;TDocument&gt;(Id, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L14445"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Check for a document source.
</p>
<p>
Check whether a document source exists in an index.
For example:
</p>
<pre><code class="lang-csharp">HEAD my-index-000001/_source/1</code></pre>
<p>
A document's source is not available if it is disabled in the mapping.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;ExistsSourceResponse&gt; ExistsSourceAsync&lt;TDocument&gt;(Id id, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ExistsSourceResponse.html">ExistsSourceResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsSourceAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsSourceAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsSourceAsync__1_Elastic_Clients_Elasticsearch_IndexName_Elastic_Clients_Elasticsearch_Id_System_Action_Elastic_Clients_Elasticsearch_ExistsSourceRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsSourceAsync``1(Elastic.Clients.Elasticsearch.IndexName,Elastic.Clients.Elasticsearch.Id,System.Action{Elastic.Clients.Elasticsearch.ExistsSourceRequestDescriptor{``0}},System.Threading.CancellationToken)">
  ExistsSourceAsync&lt;TDocument&gt;(IndexName, Id, Action&lt;ExistsSourceRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L14280"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Check for a document source.
</p>
<p>
Check whether a document source exists in an index.
For example:
</p>
<pre><code class="lang-csharp">HEAD my-index-000001/_source/1</code></pre>
<p>
A document's source is not available if it is disabled in the mapping.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;ExistsSourceResponse&gt; ExistsSourceAsync&lt;TDocument&gt;(IndexName index, Id id, Action&lt;ExistsSourceRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ExistsSourceRequestDescriptor-1.html">ExistsSourceRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ExistsSourceResponse.html">ExistsSourceResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsSourceAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsSourceAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsSourceAsync__1_Elastic_Clients_Elasticsearch_IndexName_Elastic_Clients_Elasticsearch_Id_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsSourceAsync``1(Elastic.Clients.Elasticsearch.IndexName,Elastic.Clients.Elasticsearch.Id,System.Threading.CancellationToken)">
  ExistsSourceAsync&lt;TDocument&gt;(IndexName, Id, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L14257"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Check for a document source.
</p>
<p>
Check whether a document source exists in an index.
For example:
</p>
<pre><code class="lang-csharp">HEAD my-index-000001/_source/1</code></pre>
<p>
A document's source is not available if it is disabled in the mapping.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;ExistsSourceResponse&gt; ExistsSourceAsync&lt;TDocument&gt;(IndexName index, Id id, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ExistsSourceResponse.html">ExistsSourceResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsSourceAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsSourceAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsSourceAsync__1___0_Elastic_Clients_Elasticsearch_Id_System_Action_Elastic_Clients_Elasticsearch_ExistsSourceRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsSourceAsync``1(``0,Elastic.Clients.Elasticsearch.Id,System.Action{Elastic.Clients.Elasticsearch.ExistsSourceRequestDescriptor{``0}},System.Threading.CancellationToken)">
  ExistsSourceAsync&lt;TDocument&gt;(TDocument, Id, Action&lt;ExistsSourceRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L14421"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Check for a document source.
</p>
<p>
Check whether a document source exists in an index.
For example:
</p>
<pre><code class="lang-csharp">HEAD my-index-000001/_source/1</code></pre>
<p>
A document's source is not available if it is disabled in the mapping.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;ExistsSourceResponse&gt; ExistsSourceAsync&lt;TDocument&gt;(TDocument document, Id id, Action&lt;ExistsSourceRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ExistsSourceRequestDescriptor-1.html">ExistsSourceRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ExistsSourceResponse.html">ExistsSourceResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsSourceAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsSourceAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsSourceAsync__1___0_Elastic_Clients_Elasticsearch_Id_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsSourceAsync``1(``0,Elastic.Clients.Elasticsearch.Id,System.Threading.CancellationToken)">
  ExistsSourceAsync&lt;TDocument&gt;(TDocument, Id, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L14398"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Check for a document source.
</p>
<p>
Check whether a document source exists in an index.
For example:
</p>
<pre><code class="lang-csharp">HEAD my-index-000001/_source/1</code></pre>
<p>
A document's source is not available if it is disabled in the mapping.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;ExistsSourceResponse&gt; ExistsSourceAsync&lt;TDocument&gt;(TDocument document, Id id, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ExistsSourceResponse.html">ExistsSourceResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsSourceAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsSourceAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsSourceAsync__1___0_Elastic_Clients_Elasticsearch_IndexName_System_Action_Elastic_Clients_Elasticsearch_ExistsSourceRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsSourceAsync``1(``0,Elastic.Clients.Elasticsearch.IndexName,System.Action{Elastic.Clients.Elasticsearch.ExistsSourceRequestDescriptor{``0}},System.Threading.CancellationToken)">
  ExistsSourceAsync&lt;TDocument&gt;(TDocument, IndexName, Action&lt;ExistsSourceRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L14374"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Check for a document source.
</p>
<p>
Check whether a document source exists in an index.
For example:
</p>
<pre><code class="lang-csharp">HEAD my-index-000001/_source/1</code></pre>
<p>
A document's source is not available if it is disabled in the mapping.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;ExistsSourceResponse&gt; ExistsSourceAsync&lt;TDocument&gt;(TDocument document, IndexName index, Action&lt;ExistsSourceRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ExistsSourceRequestDescriptor-1.html">ExistsSourceRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ExistsSourceResponse.html">ExistsSourceResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsSourceAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsSourceAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsSourceAsync__1___0_Elastic_Clients_Elasticsearch_IndexName_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsSourceAsync``1(``0,Elastic.Clients.Elasticsearch.IndexName,System.Threading.CancellationToken)">
  ExistsSourceAsync&lt;TDocument&gt;(TDocument, IndexName, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L14351"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Check for a document source.
</p>
<p>
Check whether a document source exists in an index.
For example:
</p>
<pre><code class="lang-csharp">HEAD my-index-000001/_source/1</code></pre>
<p>
A document's source is not available if it is disabled in the mapping.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;ExistsSourceResponse&gt; ExistsSourceAsync&lt;TDocument&gt;(TDocument document, IndexName index, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ExistsSourceResponse.html">ExistsSourceResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsSourceAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsSourceAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsSourceAsync__1___0_System_Action_Elastic_Clients_Elasticsearch_ExistsSourceRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsSourceAsync``1(``0,System.Action{Elastic.Clients.Elasticsearch.ExistsSourceRequestDescriptor{``0}},System.Threading.CancellationToken)">
  ExistsSourceAsync&lt;TDocument&gt;(TDocument, Action&lt;ExistsSourceRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L14327"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Check for a document source.
</p>
<p>
Check whether a document source exists in an index.
For example:
</p>
<pre><code class="lang-csharp">HEAD my-index-000001/_source/1</code></pre>
<p>
A document's source is not available if it is disabled in the mapping.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;ExistsSourceResponse&gt; ExistsSourceAsync&lt;TDocument&gt;(TDocument document, Action&lt;ExistsSourceRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ExistsSourceRequestDescriptor-1.html">ExistsSourceRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ExistsSourceResponse.html">ExistsSourceResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsSourceAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsSourceAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsSourceAsync__1___0_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsSourceAsync``1(``0,System.Threading.CancellationToken)">
  ExistsSourceAsync&lt;TDocument&gt;(TDocument, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L14304"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Check for a document source.
</p>
<p>
Check whether a document source exists in an index.
For example:
</p>
<pre><code class="lang-csharp">HEAD my-index-000001/_source/1</code></pre>
<p>
A document's source is not available if it is disabled in the mapping.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;ExistsSourceResponse&gt; ExistsSourceAsync&lt;TDocument&gt;(TDocument document, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ExistsSourceResponse.html">ExistsSourceResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsSource_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsSource*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsSource__1_Elastic_Clients_Elasticsearch_ExistsSourceRequestDescriptor___0__" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsSource``1(Elastic.Clients.Elasticsearch.ExistsSourceRequestDescriptor{``0})">
  ExistsSource&lt;TDocument&gt;(ExistsSourceRequestDescriptor&lt;TDocument&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L13895"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Check for a document source.
</p>
<p>
Check whether a document source exists in an index.
For example:
</p>
<pre><code class="lang-csharp">HEAD my-index-000001/_source/1</code></pre>
<p>
A document's source is not available if it is disabled in the mapping.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual ExistsSourceResponse ExistsSource&lt;TDocument&gt;(ExistsSourceRequestDescriptor&lt;TDocument&gt; descriptor)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.ExistsSourceRequestDescriptor-1.html">ExistsSourceRequestDescriptor</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ExistsSourceResponse.html">ExistsSourceResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsSource_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsSource*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsSource__1_Elastic_Clients_Elasticsearch_Id_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsSource``1(Elastic.Clients.Elasticsearch.Id)">
  ExistsSource&lt;TDocument&gt;(Id)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L14114"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Check for a document source.
</p>
<p>
Check whether a document source exists in an index.
For example:
</p>
<pre><code class="lang-csharp">HEAD my-index-000001/_source/1</code></pre>
<p>
A document's source is not available if it is disabled in the mapping.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual ExistsSourceResponse ExistsSource&lt;TDocument&gt;(Id id)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ExistsSourceResponse.html">ExistsSourceResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsSource_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsSource*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsSource__1_Elastic_Clients_Elasticsearch_Id_System_Action_Elastic_Clients_Elasticsearch_ExistsSourceRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsSource``1(Elastic.Clients.Elasticsearch.Id,System.Action{Elastic.Clients.Elasticsearch.ExistsSourceRequestDescriptor{``0}})">
  ExistsSource&lt;TDocument&gt;(Id, Action&lt;ExistsSourceRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L14138"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Check for a document source.
</p>
<p>
Check whether a document source exists in an index.
For example:
</p>
<pre><code class="lang-csharp">HEAD my-index-000001/_source/1</code></pre>
<p>
A document's source is not available if it is disabled in the mapping.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual ExistsSourceResponse ExistsSource&lt;TDocument&gt;(Id id, Action&lt;ExistsSourceRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ExistsSourceRequestDescriptor-1.html">ExistsSourceRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ExistsSourceResponse.html">ExistsSourceResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsSource_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsSource*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsSource__1_Elastic_Clients_Elasticsearch_IndexName_Elastic_Clients_Elasticsearch_Id_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsSource``1(Elastic.Clients.Elasticsearch.IndexName,Elastic.Clients.Elasticsearch.Id)">
  ExistsSource&lt;TDocument&gt;(IndexName, Id)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L13918"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Check for a document source.
</p>
<p>
Check whether a document source exists in an index.
For example:
</p>
<pre><code class="lang-csharp">HEAD my-index-000001/_source/1</code></pre>
<p>
A document's source is not available if it is disabled in the mapping.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual ExistsSourceResponse ExistsSource&lt;TDocument&gt;(IndexName index, Id id)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ExistsSourceResponse.html">ExistsSourceResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsSource_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsSource*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsSource__1_Elastic_Clients_Elasticsearch_IndexName_Elastic_Clients_Elasticsearch_Id_System_Action_Elastic_Clients_Elasticsearch_ExistsSourceRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsSource``1(Elastic.Clients.Elasticsearch.IndexName,Elastic.Clients.Elasticsearch.Id,System.Action{Elastic.Clients.Elasticsearch.ExistsSourceRequestDescriptor{``0}})">
  ExistsSource&lt;TDocument&gt;(IndexName, Id, Action&lt;ExistsSourceRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L13942"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Check for a document source.
</p>
<p>
Check whether a document source exists in an index.
For example:
</p>
<pre><code class="lang-csharp">HEAD my-index-000001/_source/1</code></pre>
<p>
A document's source is not available if it is disabled in the mapping.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual ExistsSourceResponse ExistsSource&lt;TDocument&gt;(IndexName index, Id id, Action&lt;ExistsSourceRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ExistsSourceRequestDescriptor-1.html">ExistsSourceRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ExistsSourceResponse.html">ExistsSourceResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsSource_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsSource*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsSource__1___0_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsSource``1(``0)">
  ExistsSource&lt;TDocument&gt;(TDocument)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L13967"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Check for a document source.
</p>
<p>
Check whether a document source exists in an index.
For example:
</p>
<pre><code class="lang-csharp">HEAD my-index-000001/_source/1</code></pre>
<p>
A document's source is not available if it is disabled in the mapping.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual ExistsSourceResponse ExistsSource&lt;TDocument&gt;(TDocument document)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ExistsSourceResponse.html">ExistsSourceResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsSource_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsSource*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsSource__1___0_Elastic_Clients_Elasticsearch_Id_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsSource``1(``0,Elastic.Clients.Elasticsearch.Id)">
  ExistsSource&lt;TDocument&gt;(TDocument, Id)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L14065"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Check for a document source.
</p>
<p>
Check whether a document source exists in an index.
For example:
</p>
<pre><code class="lang-csharp">HEAD my-index-000001/_source/1</code></pre>
<p>
A document's source is not available if it is disabled in the mapping.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual ExistsSourceResponse ExistsSource&lt;TDocument&gt;(TDocument document, Id id)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ExistsSourceResponse.html">ExistsSourceResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsSource_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsSource*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsSource__1___0_Elastic_Clients_Elasticsearch_Id_System_Action_Elastic_Clients_Elasticsearch_ExistsSourceRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsSource``1(``0,Elastic.Clients.Elasticsearch.Id,System.Action{Elastic.Clients.Elasticsearch.ExistsSourceRequestDescriptor{``0}})">
  ExistsSource&lt;TDocument&gt;(TDocument, Id, Action&lt;ExistsSourceRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L14089"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Check for a document source.
</p>
<p>
Check whether a document source exists in an index.
For example:
</p>
<pre><code class="lang-csharp">HEAD my-index-000001/_source/1</code></pre>
<p>
A document's source is not available if it is disabled in the mapping.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual ExistsSourceResponse ExistsSource&lt;TDocument&gt;(TDocument document, Id id, Action&lt;ExistsSourceRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ExistsSourceRequestDescriptor-1.html">ExistsSourceRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ExistsSourceResponse.html">ExistsSourceResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsSource_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsSource*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsSource__1___0_Elastic_Clients_Elasticsearch_IndexName_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsSource``1(``0,Elastic.Clients.Elasticsearch.IndexName)">
  ExistsSource&lt;TDocument&gt;(TDocument, IndexName)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L14016"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Check for a document source.
</p>
<p>
Check whether a document source exists in an index.
For example:
</p>
<pre><code class="lang-csharp">HEAD my-index-000001/_source/1</code></pre>
<p>
A document's source is not available if it is disabled in the mapping.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual ExistsSourceResponse ExistsSource&lt;TDocument&gt;(TDocument document, IndexName index)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ExistsSourceResponse.html">ExistsSourceResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsSource_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsSource*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsSource__1___0_Elastic_Clients_Elasticsearch_IndexName_System_Action_Elastic_Clients_Elasticsearch_ExistsSourceRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsSource``1(``0,Elastic.Clients.Elasticsearch.IndexName,System.Action{Elastic.Clients.Elasticsearch.ExistsSourceRequestDescriptor{``0}})">
  ExistsSource&lt;TDocument&gt;(TDocument, IndexName, Action&lt;ExistsSourceRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L14040"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Check for a document source.
</p>
<p>
Check whether a document source exists in an index.
For example:
</p>
<pre><code class="lang-csharp">HEAD my-index-000001/_source/1</code></pre>
<p>
A document's source is not available if it is disabled in the mapping.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual ExistsSourceResponse ExistsSource&lt;TDocument&gt;(TDocument document, IndexName index, Action&lt;ExistsSourceRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ExistsSourceRequestDescriptor-1.html">ExistsSourceRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ExistsSourceResponse.html">ExistsSourceResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsSource_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsSource*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExistsSource__1___0_System_Action_Elastic_Clients_Elasticsearch_ExistsSourceRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExistsSource``1(``0,System.Action{Elastic.Clients.Elasticsearch.ExistsSourceRequestDescriptor{``0}})">
  ExistsSource&lt;TDocument&gt;(TDocument, Action&lt;ExistsSourceRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L13991"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Check for a document source.
</p>
<p>
Check whether a document source exists in an index.
For example:
</p>
<pre><code class="lang-csharp">HEAD my-index-000001/_source/1</code></pre>
<p>
A document's source is not available if it is disabled in the mapping.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual ExistsSourceResponse ExistsSource&lt;TDocument&gt;(TDocument document, Action&lt;ExistsSourceRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ExistsSourceRequestDescriptor-1.html">ExistsSourceRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ExistsSourceResponse.html">ExistsSourceResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Exists_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Exists*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Exists__1_Elastic_Clients_Elasticsearch_ExistsRequestDescriptor___0__" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Exists``1(Elastic.Clients.Elasticsearch.ExistsRequestDescriptor{``0})">
  Exists&lt;TDocument&gt;(ExistsRequestDescriptor&lt;TDocument&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L12860"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Check a document.
</p>
<p>
Verify that a document exists.
For example, check to see if a document with the <code>_id</code> 0 exists:
</p>
<pre><code class="lang-csharp">HEAD my-index-000001/_doc/0</code></pre>
<p>
If the document exists, the API returns a status code of <code>200 - OK</code>.
If the document doesn’t exist, the API returns <code>404 - Not Found</code>.
</p>
<p>
<strong>Versioning support</strong>
</p>
<p>
You can use the <code>version</code> parameter to check the document only if its current version is equal to the specified one.
</p>
<p>
Internally, Elasticsearch has marked the old document as deleted and added an entirely new document.
The old version of the document doesn't disappear immediately, although you won't be able to access it.
Elasticsearch cleans up deleted documents in the background as you continue to index more data.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual ExistsResponse Exists&lt;TDocument&gt;(ExistsRequestDescriptor&lt;TDocument&gt; descriptor)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.ExistsRequestDescriptor-1.html">ExistsRequestDescriptor</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ExistsResponse.html">ExistsResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Exists_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Exists*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Exists__1_Elastic_Clients_Elasticsearch_Id_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Exists``1(Elastic.Clients.Elasticsearch.Id)">
  Exists&lt;TDocument&gt;(Id)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L13187"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Check a document.
</p>
<p>
Verify that a document exists.
For example, check to see if a document with the <code>_id</code> 0 exists:
</p>
<pre><code class="lang-csharp">HEAD my-index-000001/_doc/0</code></pre>
<p>
If the document exists, the API returns a status code of <code>200 - OK</code>.
If the document doesn’t exist, the API returns <code>404 - Not Found</code>.
</p>
<p>
<strong>Versioning support</strong>
</p>
<p>
You can use the <code>version</code> parameter to check the document only if its current version is equal to the specified one.
</p>
<p>
Internally, Elasticsearch has marked the old document as deleted and added an entirely new document.
The old version of the document doesn't disappear immediately, although you won't be able to access it.
Elasticsearch cleans up deleted documents in the background as you continue to index more data.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual ExistsResponse Exists&lt;TDocument&gt;(Id id)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ExistsResponse.html">ExistsResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Exists_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Exists*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Exists__1_Elastic_Clients_Elasticsearch_Id_System_Action_Elastic_Clients_Elasticsearch_ExistsRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Exists``1(Elastic.Clients.Elasticsearch.Id,System.Action{Elastic.Clients.Elasticsearch.ExistsRequestDescriptor{``0}})">
  Exists&lt;TDocument&gt;(Id, Action&lt;ExistsRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L13223"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Check a document.
</p>
<p>
Verify that a document exists.
For example, check to see if a document with the <code>_id</code> 0 exists:
</p>
<pre><code class="lang-csharp">HEAD my-index-000001/_doc/0</code></pre>
<p>
If the document exists, the API returns a status code of <code>200 - OK</code>.
If the document doesn’t exist, the API returns <code>404 - Not Found</code>.
</p>
<p>
<strong>Versioning support</strong>
</p>
<p>
You can use the <code>version</code> parameter to check the document only if its current version is equal to the specified one.
</p>
<p>
Internally, Elasticsearch has marked the old document as deleted and added an entirely new document.
The old version of the document doesn't disappear immediately, although you won't be able to access it.
Elasticsearch cleans up deleted documents in the background as you continue to index more data.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual ExistsResponse Exists&lt;TDocument&gt;(Id id, Action&lt;ExistsRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ExistsRequestDescriptor-1.html">ExistsRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ExistsResponse.html">ExistsResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Exists_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Exists*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Exists__1_Elastic_Clients_Elasticsearch_IndexName_Elastic_Clients_Elasticsearch_Id_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Exists``1(Elastic.Clients.Elasticsearch.IndexName,Elastic.Clients.Elasticsearch.Id)">
  Exists&lt;TDocument&gt;(IndexName, Id)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L12895"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Check a document.
</p>
<p>
Verify that a document exists.
For example, check to see if a document with the <code>_id</code> 0 exists:
</p>
<pre><code class="lang-csharp">HEAD my-index-000001/_doc/0</code></pre>
<p>
If the document exists, the API returns a status code of <code>200 - OK</code>.
If the document doesn’t exist, the API returns <code>404 - Not Found</code>.
</p>
<p>
<strong>Versioning support</strong>
</p>
<p>
You can use the <code>version</code> parameter to check the document only if its current version is equal to the specified one.
</p>
<p>
Internally, Elasticsearch has marked the old document as deleted and added an entirely new document.
The old version of the document doesn't disappear immediately, although you won't be able to access it.
Elasticsearch cleans up deleted documents in the background as you continue to index more data.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual ExistsResponse Exists&lt;TDocument&gt;(IndexName index, Id id)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ExistsResponse.html">ExistsResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Exists_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Exists*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Exists__1_Elastic_Clients_Elasticsearch_IndexName_Elastic_Clients_Elasticsearch_Id_System_Action_Elastic_Clients_Elasticsearch_ExistsRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Exists``1(Elastic.Clients.Elasticsearch.IndexName,Elastic.Clients.Elasticsearch.Id,System.Action{Elastic.Clients.Elasticsearch.ExistsRequestDescriptor{``0}})">
  Exists&lt;TDocument&gt;(IndexName, Id, Action&lt;ExistsRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L12931"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Check a document.
</p>
<p>
Verify that a document exists.
For example, check to see if a document with the <code>_id</code> 0 exists:
</p>
<pre><code class="lang-csharp">HEAD my-index-000001/_doc/0</code></pre>
<p>
If the document exists, the API returns a status code of <code>200 - OK</code>.
If the document doesn’t exist, the API returns <code>404 - Not Found</code>.
</p>
<p>
<strong>Versioning support</strong>
</p>
<p>
You can use the <code>version</code> parameter to check the document only if its current version is equal to the specified one.
</p>
<p>
Internally, Elasticsearch has marked the old document as deleted and added an entirely new document.
The old version of the document doesn't disappear immediately, although you won't be able to access it.
Elasticsearch cleans up deleted documents in the background as you continue to index more data.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual ExistsResponse Exists&lt;TDocument&gt;(IndexName index, Id id, Action&lt;ExistsRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ExistsRequestDescriptor-1.html">ExistsRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ExistsResponse.html">ExistsResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Exists_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Exists*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Exists__1___0_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Exists``1(``0)">
  Exists&lt;TDocument&gt;(TDocument)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L12968"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Check a document.
</p>
<p>
Verify that a document exists.
For example, check to see if a document with the <code>_id</code> 0 exists:
</p>
<pre><code class="lang-csharp">HEAD my-index-000001/_doc/0</code></pre>
<p>
If the document exists, the API returns a status code of <code>200 - OK</code>.
If the document doesn’t exist, the API returns <code>404 - Not Found</code>.
</p>
<p>
<strong>Versioning support</strong>
</p>
<p>
You can use the <code>version</code> parameter to check the document only if its current version is equal to the specified one.
</p>
<p>
Internally, Elasticsearch has marked the old document as deleted and added an entirely new document.
The old version of the document doesn't disappear immediately, although you won't be able to access it.
Elasticsearch cleans up deleted documents in the background as you continue to index more data.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual ExistsResponse Exists&lt;TDocument&gt;(TDocument document)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ExistsResponse.html">ExistsResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Exists_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Exists*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Exists__1___0_Elastic_Clients_Elasticsearch_Id_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Exists``1(``0,Elastic.Clients.Elasticsearch.Id)">
  Exists&lt;TDocument&gt;(TDocument, Id)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L13114"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Check a document.
</p>
<p>
Verify that a document exists.
For example, check to see if a document with the <code>_id</code> 0 exists:
</p>
<pre><code class="lang-csharp">HEAD my-index-000001/_doc/0</code></pre>
<p>
If the document exists, the API returns a status code of <code>200 - OK</code>.
If the document doesn’t exist, the API returns <code>404 - Not Found</code>.
</p>
<p>
<strong>Versioning support</strong>
</p>
<p>
You can use the <code>version</code> parameter to check the document only if its current version is equal to the specified one.
</p>
<p>
Internally, Elasticsearch has marked the old document as deleted and added an entirely new document.
The old version of the document doesn't disappear immediately, although you won't be able to access it.
Elasticsearch cleans up deleted documents in the background as you continue to index more data.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual ExistsResponse Exists&lt;TDocument&gt;(TDocument document, Id id)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ExistsResponse.html">ExistsResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Exists_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Exists*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Exists__1___0_Elastic_Clients_Elasticsearch_Id_System_Action_Elastic_Clients_Elasticsearch_ExistsRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Exists``1(``0,Elastic.Clients.Elasticsearch.Id,System.Action{Elastic.Clients.Elasticsearch.ExistsRequestDescriptor{``0}})">
  Exists&lt;TDocument&gt;(TDocument, Id, Action&lt;ExistsRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L13150"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Check a document.
</p>
<p>
Verify that a document exists.
For example, check to see if a document with the <code>_id</code> 0 exists:
</p>
<pre><code class="lang-csharp">HEAD my-index-000001/_doc/0</code></pre>
<p>
If the document exists, the API returns a status code of <code>200 - OK</code>.
If the document doesn’t exist, the API returns <code>404 - Not Found</code>.
</p>
<p>
<strong>Versioning support</strong>
</p>
<p>
You can use the <code>version</code> parameter to check the document only if its current version is equal to the specified one.
</p>
<p>
Internally, Elasticsearch has marked the old document as deleted and added an entirely new document.
The old version of the document doesn't disappear immediately, although you won't be able to access it.
Elasticsearch cleans up deleted documents in the background as you continue to index more data.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual ExistsResponse Exists&lt;TDocument&gt;(TDocument document, Id id, Action&lt;ExistsRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ExistsRequestDescriptor-1.html">ExistsRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ExistsResponse.html">ExistsResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Exists_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Exists*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Exists__1___0_Elastic_Clients_Elasticsearch_IndexName_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Exists``1(``0,Elastic.Clients.Elasticsearch.IndexName)">
  Exists&lt;TDocument&gt;(TDocument, IndexName)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L13041"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Check a document.
</p>
<p>
Verify that a document exists.
For example, check to see if a document with the <code>_id</code> 0 exists:
</p>
<pre><code class="lang-csharp">HEAD my-index-000001/_doc/0</code></pre>
<p>
If the document exists, the API returns a status code of <code>200 - OK</code>.
If the document doesn’t exist, the API returns <code>404 - Not Found</code>.
</p>
<p>
<strong>Versioning support</strong>
</p>
<p>
You can use the <code>version</code> parameter to check the document only if its current version is equal to the specified one.
</p>
<p>
Internally, Elasticsearch has marked the old document as deleted and added an entirely new document.
The old version of the document doesn't disappear immediately, although you won't be able to access it.
Elasticsearch cleans up deleted documents in the background as you continue to index more data.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual ExistsResponse Exists&lt;TDocument&gt;(TDocument document, IndexName index)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ExistsResponse.html">ExistsResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Exists_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Exists*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Exists__1___0_Elastic_Clients_Elasticsearch_IndexName_System_Action_Elastic_Clients_Elasticsearch_ExistsRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Exists``1(``0,Elastic.Clients.Elasticsearch.IndexName,System.Action{Elastic.Clients.Elasticsearch.ExistsRequestDescriptor{``0}})">
  Exists&lt;TDocument&gt;(TDocument, IndexName, Action&lt;ExistsRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L13077"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Check a document.
</p>
<p>
Verify that a document exists.
For example, check to see if a document with the <code>_id</code> 0 exists:
</p>
<pre><code class="lang-csharp">HEAD my-index-000001/_doc/0</code></pre>
<p>
If the document exists, the API returns a status code of <code>200 - OK</code>.
If the document doesn’t exist, the API returns <code>404 - Not Found</code>.
</p>
<p>
<strong>Versioning support</strong>
</p>
<p>
You can use the <code>version</code> parameter to check the document only if its current version is equal to the specified one.
</p>
<p>
Internally, Elasticsearch has marked the old document as deleted and added an entirely new document.
The old version of the document doesn't disappear immediately, although you won't be able to access it.
Elasticsearch cleans up deleted documents in the background as you continue to index more data.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual ExistsResponse Exists&lt;TDocument&gt;(TDocument document, IndexName index, Action&lt;ExistsRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ExistsRequestDescriptor-1.html">ExistsRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ExistsResponse.html">ExistsResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Exists_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Exists*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Exists__1___0_System_Action_Elastic_Clients_Elasticsearch_ExistsRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Exists``1(``0,System.Action{Elastic.Clients.Elasticsearch.ExistsRequestDescriptor{``0}})">
  Exists&lt;TDocument&gt;(TDocument, Action&lt;ExistsRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L13004"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Check a document.
</p>
<p>
Verify that a document exists.
For example, check to see if a document with the <code>_id</code> 0 exists:
</p>
<pre><code class="lang-csharp">HEAD my-index-000001/_doc/0</code></pre>
<p>
If the document exists, the API returns a status code of <code>200 - OK</code>.
If the document doesn’t exist, the API returns <code>404 - Not Found</code>.
</p>
<p>
<strong>Versioning support</strong>
</p>
<p>
You can use the <code>version</code> parameter to check the document only if its current version is equal to the specified one.
</p>
<p>
Internally, Elasticsearch has marked the old document as deleted and added an entirely new document.
The old version of the document doesn't disappear immediately, although you won't be able to access it.
Elasticsearch cleans up deleted documents in the background as you continue to index more data.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual ExistsResponse Exists&lt;TDocument&gt;(TDocument document, Action&lt;ExistsRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ExistsRequestDescriptor-1.html">ExistsRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ExistsResponse.html">ExistsResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExplainAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExplainAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExplainAsync__1_Elastic_Clients_Elasticsearch_ExplainRequest_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExplainAsync``1(Elastic.Clients.Elasticsearch.ExplainRequest,System.Threading.CancellationToken)">
  ExplainAsync&lt;TDocument&gt;(ExplainRequest, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L14568"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Explain a document match result.
Get information about why a specific document matches, or doesn't match, a query.
It computes a score explanation for a query and a specific document.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-explain.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;ExplainResponse&lt;TDocument&gt;&gt; ExplainAsync&lt;TDocument&gt;(ExplainRequest request, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.ExplainRequest.html">ExplainRequest</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ExplainResponse-1.html">ExplainResponse</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExplainAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExplainAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExplainAsync__1_Elastic_Clients_Elasticsearch_ExplainRequestDescriptor___0__System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExplainAsync``1(Elastic.Clients.Elasticsearch.ExplainRequestDescriptor{``0},System.Threading.CancellationToken)">
  ExplainAsync&lt;TDocument&gt;(ExplainRequestDescriptor&lt;TDocument&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L14762"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Explain a document match result.
Get information about why a specific document matches, or doesn't match, a query.
It computes a score explanation for a query and a specific document.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-explain.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;ExplainResponse&lt;TDocument&gt;&gt; ExplainAsync&lt;TDocument&gt;(ExplainRequestDescriptor&lt;TDocument&gt; descriptor, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.ExplainRequestDescriptor-1.html">ExplainRequestDescriptor</a>&lt;TDocument&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ExplainResponse-1.html">ExplainResponse</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExplainAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExplainAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExplainAsync__1_Elastic_Clients_Elasticsearch_Id_System_Action_Elastic_Clients_Elasticsearch_ExplainRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExplainAsync``1(Elastic.Clients.Elasticsearch.Id,System.Action{Elastic.Clients.Elasticsearch.ExplainRequestDescriptor{``0}},System.Threading.CancellationToken)">
  ExplainAsync&lt;TDocument&gt;(Id, Action&lt;ExplainRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L14915"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Explain a document match result.
Get information about why a specific document matches, or doesn't match, a query.
It computes a score explanation for a query and a specific document.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-explain.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;ExplainResponse&lt;TDocument&gt;&gt; ExplainAsync&lt;TDocument&gt;(Id id, Action&lt;ExplainRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ExplainRequestDescriptor-1.html">ExplainRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ExplainResponse-1.html">ExplainResponse</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExplainAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExplainAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExplainAsync__1_Elastic_Clients_Elasticsearch_Id_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExplainAsync``1(Elastic.Clients.Elasticsearch.Id,System.Threading.CancellationToken)">
  ExplainAsync&lt;TDocument&gt;(Id, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L14900"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Explain a document match result.
Get information about why a specific document matches, or doesn't match, a query.
It computes a score explanation for a query and a specific document.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-explain.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;ExplainResponse&lt;TDocument&gt;&gt; ExplainAsync&lt;TDocument&gt;(Id id, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ExplainResponse-1.html">ExplainResponse</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExplainAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExplainAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExplainAsync__1_Elastic_Clients_Elasticsearch_IndexName_Elastic_Clients_Elasticsearch_Id_System_Action_Elastic_Clients_Elasticsearch_ExplainRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExplainAsync``1(Elastic.Clients.Elasticsearch.IndexName,Elastic.Clients.Elasticsearch.Id,System.Action{Elastic.Clients.Elasticsearch.ExplainRequestDescriptor{``0}},System.Threading.CancellationToken)">
  ExplainAsync&lt;TDocument&gt;(IndexName, Id, Action&lt;ExplainRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L14791"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Explain a document match result.
Get information about why a specific document matches, or doesn't match, a query.
It computes a score explanation for a query and a specific document.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-explain.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;ExplainResponse&lt;TDocument&gt;&gt; ExplainAsync&lt;TDocument&gt;(IndexName index, Id id, Action&lt;ExplainRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ExplainRequestDescriptor-1.html">ExplainRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ExplainResponse-1.html">ExplainResponse</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExplainAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExplainAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExplainAsync__1_Elastic_Clients_Elasticsearch_IndexName_Elastic_Clients_Elasticsearch_Id_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExplainAsync``1(Elastic.Clients.Elasticsearch.IndexName,Elastic.Clients.Elasticsearch.Id,System.Threading.CancellationToken)">
  ExplainAsync&lt;TDocument&gt;(IndexName, Id, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L14776"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Explain a document match result.
Get information about why a specific document matches, or doesn't match, a query.
It computes a score explanation for a query and a specific document.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-explain.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;ExplainResponse&lt;TDocument&gt;&gt; ExplainAsync&lt;TDocument&gt;(IndexName index, Id id, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ExplainResponse-1.html">ExplainResponse</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExplainAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExplainAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExplainAsync__1___0_Elastic_Clients_Elasticsearch_Id_System_Action_Elastic_Clients_Elasticsearch_ExplainRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExplainAsync``1(``0,Elastic.Clients.Elasticsearch.Id,System.Action{Elastic.Clients.Elasticsearch.ExplainRequestDescriptor{``0}},System.Threading.CancellationToken)">
  ExplainAsync&lt;TDocument&gt;(TDocument, Id, Action&lt;ExplainRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L14884"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Explain a document match result.
Get information about why a specific document matches, or doesn't match, a query.
It computes a score explanation for a query and a specific document.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-explain.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;ExplainResponse&lt;TDocument&gt;&gt; ExplainAsync&lt;TDocument&gt;(TDocument document, Id id, Action&lt;ExplainRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ExplainRequestDescriptor-1.html">ExplainRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ExplainResponse-1.html">ExplainResponse</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExplainAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExplainAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExplainAsync__1___0_Elastic_Clients_Elasticsearch_Id_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExplainAsync``1(``0,Elastic.Clients.Elasticsearch.Id,System.Threading.CancellationToken)">
  ExplainAsync&lt;TDocument&gt;(TDocument, Id, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L14869"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Explain a document match result.
Get information about why a specific document matches, or doesn't match, a query.
It computes a score explanation for a query and a specific document.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-explain.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;ExplainResponse&lt;TDocument&gt;&gt; ExplainAsync&lt;TDocument&gt;(TDocument document, Id id, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ExplainResponse-1.html">ExplainResponse</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExplainAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExplainAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExplainAsync__1___0_Elastic_Clients_Elasticsearch_IndexName_System_Action_Elastic_Clients_Elasticsearch_ExplainRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExplainAsync``1(``0,Elastic.Clients.Elasticsearch.IndexName,System.Action{Elastic.Clients.Elasticsearch.ExplainRequestDescriptor{``0}},System.Threading.CancellationToken)">
  ExplainAsync&lt;TDocument&gt;(TDocument, IndexName, Action&lt;ExplainRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L14853"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Explain a document match result.
Get information about why a specific document matches, or doesn't match, a query.
It computes a score explanation for a query and a specific document.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-explain.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;ExplainResponse&lt;TDocument&gt;&gt; ExplainAsync&lt;TDocument&gt;(TDocument document, IndexName index, Action&lt;ExplainRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ExplainRequestDescriptor-1.html">ExplainRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ExplainResponse-1.html">ExplainResponse</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExplainAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExplainAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExplainAsync__1___0_Elastic_Clients_Elasticsearch_IndexName_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExplainAsync``1(``0,Elastic.Clients.Elasticsearch.IndexName,System.Threading.CancellationToken)">
  ExplainAsync&lt;TDocument&gt;(TDocument, IndexName, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L14838"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Explain a document match result.
Get information about why a specific document matches, or doesn't match, a query.
It computes a score explanation for a query and a specific document.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-explain.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;ExplainResponse&lt;TDocument&gt;&gt; ExplainAsync&lt;TDocument&gt;(TDocument document, IndexName index, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ExplainResponse-1.html">ExplainResponse</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExplainAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExplainAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExplainAsync__1___0_System_Action_Elastic_Clients_Elasticsearch_ExplainRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExplainAsync``1(``0,System.Action{Elastic.Clients.Elasticsearch.ExplainRequestDescriptor{``0}},System.Threading.CancellationToken)">
  ExplainAsync&lt;TDocument&gt;(TDocument, Action&lt;ExplainRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L14822"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Explain a document match result.
Get information about why a specific document matches, or doesn't match, a query.
It computes a score explanation for a query and a specific document.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-explain.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;ExplainResponse&lt;TDocument&gt;&gt; ExplainAsync&lt;TDocument&gt;(TDocument document, Action&lt;ExplainRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ExplainRequestDescriptor-1.html">ExplainRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ExplainResponse-1.html">ExplainResponse</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExplainAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExplainAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ExplainAsync__1___0_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ExplainAsync``1(``0,System.Threading.CancellationToken)">
  ExplainAsync&lt;TDocument&gt;(TDocument, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L14807"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Explain a document match result.
Get information about why a specific document matches, or doesn't match, a query.
It computes a score explanation for a query and a specific document.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-explain.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;ExplainResponse&lt;TDocument&gt;&gt; ExplainAsync&lt;TDocument&gt;(TDocument document, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ExplainResponse-1.html">ExplainResponse</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Explain_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Explain*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Explain__1_Elastic_Clients_Elasticsearch_ExplainRequest_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Explain``1(Elastic.Clients.Elasticsearch.ExplainRequest)">
  Explain&lt;TDocument&gt;(ExplainRequest)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L14553"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Explain a document match result.
Get information about why a specific document matches, or doesn't match, a query.
It computes a score explanation for a query and a specific document.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-explain.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual ExplainResponse&lt;TDocument&gt; Explain&lt;TDocument&gt;(ExplainRequest request)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.ExplainRequest.html">ExplainRequest</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ExplainResponse-1.html">ExplainResponse</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Explain_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Explain*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Explain__1_Elastic_Clients_Elasticsearch_ExplainRequestDescriptor___0__" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Explain``1(Elastic.Clients.Elasticsearch.ExplainRequestDescriptor{``0})">
  Explain&lt;TDocument&gt;(ExplainRequestDescriptor&lt;TDocument&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L14582"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Explain a document match result.
Get information about why a specific document matches, or doesn't match, a query.
It computes a score explanation for a query and a specific document.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-explain.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual ExplainResponse&lt;TDocument&gt; Explain&lt;TDocument&gt;(ExplainRequestDescriptor&lt;TDocument&gt; descriptor)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.ExplainRequestDescriptor-1.html">ExplainRequestDescriptor</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ExplainResponse-1.html">ExplainResponse</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Explain_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Explain*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Explain__1_Elastic_Clients_Elasticsearch_Id_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Explain``1(Elastic.Clients.Elasticsearch.Id)">
  Explain&lt;TDocument&gt;(Id)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L14729"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Explain a document match result.
Get information about why a specific document matches, or doesn't match, a query.
It computes a score explanation for a query and a specific document.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-explain.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual ExplainResponse&lt;TDocument&gt; Explain&lt;TDocument&gt;(Id id)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ExplainResponse-1.html">ExplainResponse</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Explain_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Explain*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Explain__1_Elastic_Clients_Elasticsearch_Id_System_Action_Elastic_Clients_Elasticsearch_ExplainRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Explain``1(Elastic.Clients.Elasticsearch.Id,System.Action{Elastic.Clients.Elasticsearch.ExplainRequestDescriptor{``0}})">
  Explain&lt;TDocument&gt;(Id, Action&lt;ExplainRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L14745"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Explain a document match result.
Get information about why a specific document matches, or doesn't match, a query.
It computes a score explanation for a query and a specific document.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-explain.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual ExplainResponse&lt;TDocument&gt; Explain&lt;TDocument&gt;(Id id, Action&lt;ExplainRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ExplainRequestDescriptor-1.html">ExplainRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ExplainResponse-1.html">ExplainResponse</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Explain_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Explain*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Explain__1_Elastic_Clients_Elasticsearch_IndexName_Elastic_Clients_Elasticsearch_Id_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Explain``1(Elastic.Clients.Elasticsearch.IndexName,Elastic.Clients.Elasticsearch.Id)">
  Explain&lt;TDocument&gt;(IndexName, Id)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L14597"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Explain a document match result.
Get information about why a specific document matches, or doesn't match, a query.
It computes a score explanation for a query and a specific document.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-explain.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual ExplainResponse&lt;TDocument&gt; Explain&lt;TDocument&gt;(IndexName index, Id id)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ExplainResponse-1.html">ExplainResponse</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Explain_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Explain*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Explain__1_Elastic_Clients_Elasticsearch_IndexName_Elastic_Clients_Elasticsearch_Id_System_Action_Elastic_Clients_Elasticsearch_ExplainRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Explain``1(Elastic.Clients.Elasticsearch.IndexName,Elastic.Clients.Elasticsearch.Id,System.Action{Elastic.Clients.Elasticsearch.ExplainRequestDescriptor{``0}})">
  Explain&lt;TDocument&gt;(IndexName, Id, Action&lt;ExplainRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L14613"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Explain a document match result.
Get information about why a specific document matches, or doesn't match, a query.
It computes a score explanation for a query and a specific document.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-explain.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual ExplainResponse&lt;TDocument&gt; Explain&lt;TDocument&gt;(IndexName index, Id id, Action&lt;ExplainRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ExplainRequestDescriptor-1.html">ExplainRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ExplainResponse-1.html">ExplainResponse</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Explain_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Explain*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Explain__1___0_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Explain``1(``0)">
  Explain&lt;TDocument&gt;(TDocument)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L14630"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Explain a document match result.
Get information about why a specific document matches, or doesn't match, a query.
It computes a score explanation for a query and a specific document.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-explain.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual ExplainResponse&lt;TDocument&gt; Explain&lt;TDocument&gt;(TDocument document)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ExplainResponse-1.html">ExplainResponse</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Explain_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Explain*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Explain__1___0_Elastic_Clients_Elasticsearch_Id_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Explain``1(``0,Elastic.Clients.Elasticsearch.Id)">
  Explain&lt;TDocument&gt;(TDocument, Id)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L14696"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Explain a document match result.
Get information about why a specific document matches, or doesn't match, a query.
It computes a score explanation for a query and a specific document.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-explain.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual ExplainResponse&lt;TDocument&gt; Explain&lt;TDocument&gt;(TDocument document, Id id)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ExplainResponse-1.html">ExplainResponse</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Explain_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Explain*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Explain__1___0_Elastic_Clients_Elasticsearch_Id_System_Action_Elastic_Clients_Elasticsearch_ExplainRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Explain``1(``0,Elastic.Clients.Elasticsearch.Id,System.Action{Elastic.Clients.Elasticsearch.ExplainRequestDescriptor{``0}})">
  Explain&lt;TDocument&gt;(TDocument, Id, Action&lt;ExplainRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L14712"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Explain a document match result.
Get information about why a specific document matches, or doesn't match, a query.
It computes a score explanation for a query and a specific document.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-explain.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual ExplainResponse&lt;TDocument&gt; Explain&lt;TDocument&gt;(TDocument document, Id id, Action&lt;ExplainRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ExplainRequestDescriptor-1.html">ExplainRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ExplainResponse-1.html">ExplainResponse</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Explain_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Explain*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Explain__1___0_Elastic_Clients_Elasticsearch_IndexName_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Explain``1(``0,Elastic.Clients.Elasticsearch.IndexName)">
  Explain&lt;TDocument&gt;(TDocument, IndexName)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L14663"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Explain a document match result.
Get information about why a specific document matches, or doesn't match, a query.
It computes a score explanation for a query and a specific document.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-explain.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual ExplainResponse&lt;TDocument&gt; Explain&lt;TDocument&gt;(TDocument document, IndexName index)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ExplainResponse-1.html">ExplainResponse</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Explain_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Explain*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Explain__1___0_Elastic_Clients_Elasticsearch_IndexName_System_Action_Elastic_Clients_Elasticsearch_ExplainRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Explain``1(``0,Elastic.Clients.Elasticsearch.IndexName,System.Action{Elastic.Clients.Elasticsearch.ExplainRequestDescriptor{``0}})">
  Explain&lt;TDocument&gt;(TDocument, IndexName, Action&lt;ExplainRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L14679"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Explain a document match result.
Get information about why a specific document matches, or doesn't match, a query.
It computes a score explanation for a query and a specific document.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-explain.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual ExplainResponse&lt;TDocument&gt; Explain&lt;TDocument&gt;(TDocument document, IndexName index, Action&lt;ExplainRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ExplainRequestDescriptor-1.html">ExplainRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ExplainResponse-1.html">ExplainResponse</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Explain_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Explain*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Explain__1___0_System_Action_Elastic_Clients_Elasticsearch_ExplainRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Explain``1(``0,System.Action{Elastic.Clients.Elasticsearch.ExplainRequestDescriptor{``0}})">
  Explain&lt;TDocument&gt;(TDocument, Action&lt;ExplainRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L14646"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Explain a document match result.
Get information about why a specific document matches, or doesn't match, a query.
It computes a score explanation for a query and a specific document.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-explain.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual ExplainResponse&lt;TDocument&gt; Explain&lt;TDocument&gt;(TDocument document, Action&lt;ExplainRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ExplainRequestDescriptor-1.html">ExplainRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ExplainResponse-1.html">ExplainResponse</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_FieldCaps_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.FieldCaps*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_FieldCaps" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.FieldCaps">
  FieldCaps()
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L15155"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get the field capabilities.
</p>
<p>
Get information about the capabilities of fields among multiple indices.
</p>
<p>
For data streams, the API returns field capabilities among the stream’s backing indices.
It returns runtime fields like any other field.
For example, a runtime field with a type of keyword is returned the same as any other field that belongs to the <code>keyword</code> family.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-field-caps.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual FieldCapsResponse FieldCaps()</code></pre>
  </div>


  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.FieldCapsResponse.html">FieldCapsResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_FieldCaps_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.FieldCaps*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_FieldCaps_Elastic_Clients_Elasticsearch_FieldCapsRequest_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.FieldCaps(Elastic.Clients.Elasticsearch.FieldCapsRequest)">
  FieldCaps(FieldCapsRequest)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L14937"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get the field capabilities.
</p>
<p>
Get information about the capabilities of fields among multiple indices.
</p>
<p>
For data streams, the API returns field capabilities among the stream’s backing indices.
It returns runtime fields like any other field.
For example, a runtime field with a type of keyword is returned the same as any other field that belongs to the <code>keyword</code> family.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-field-caps.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual FieldCapsResponse FieldCaps(FieldCapsRequest request)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.FieldCapsRequest.html">FieldCapsRequest</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.FieldCapsResponse.html">FieldCapsResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_FieldCaps_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.FieldCaps*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_FieldCaps_Elastic_Clients_Elasticsearch_FieldCapsRequestDescriptor_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.FieldCaps(Elastic.Clients.Elasticsearch.FieldCapsRequestDescriptor)">
  FieldCaps(FieldCapsRequestDescriptor)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L15089"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get the field capabilities.
</p>
<p>
Get information about the capabilities of fields among multiple indices.
</p>
<p>
For data streams, the API returns field capabilities among the stream’s backing indices.
It returns runtime fields like any other field.
For example, a runtime field with a type of keyword is returned the same as any other field that belongs to the <code>keyword</code> family.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-field-caps.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual FieldCapsResponse FieldCaps(FieldCapsRequestDescriptor descriptor)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.FieldCapsRequestDescriptor.html">FieldCapsRequestDescriptor</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.FieldCapsResponse.html">FieldCapsResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_FieldCaps_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.FieldCaps*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_FieldCaps_Elastic_Clients_Elasticsearch_Indices_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.FieldCaps(Elastic.Clients.Elasticsearch.Indices)">
  FieldCaps(Indices?)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L15110"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get the field capabilities.
</p>
<p>
Get information about the capabilities of fields among multiple indices.
</p>
<p>
For data streams, the API returns field capabilities among the stream’s backing indices.
It returns runtime fields like any other field.
For example, a runtime field with a type of keyword is returned the same as any other field that belongs to the <code>keyword</code> family.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-field-caps.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual FieldCapsResponse FieldCaps(Indices? indices)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>indices</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Indices.html">Indices</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.FieldCapsResponse.html">FieldCapsResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_FieldCaps_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.FieldCaps*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_FieldCaps_Elastic_Clients_Elasticsearch_Indices_System_Action_Elastic_Clients_Elasticsearch_FieldCapsRequestDescriptor__" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.FieldCaps(Elastic.Clients.Elasticsearch.Indices,System.Action{Elastic.Clients.Elasticsearch.FieldCapsRequestDescriptor})">
  FieldCaps(Indices?, Action&lt;FieldCapsRequestDescriptor&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L15132"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get the field capabilities.
</p>
<p>
Get information about the capabilities of fields among multiple indices.
</p>
<p>
For data streams, the API returns field capabilities among the stream’s backing indices.
It returns runtime fields like any other field.
For example, a runtime field with a type of keyword is returned the same as any other field that belongs to the <code>keyword</code> family.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-field-caps.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual FieldCapsResponse FieldCaps(Indices? indices, Action&lt;FieldCapsRequestDescriptor&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>indices</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Indices.html">Indices</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.FieldCapsRequestDescriptor.html">FieldCapsRequestDescriptor</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.FieldCapsResponse.html">FieldCapsResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_FieldCaps_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.FieldCaps*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_FieldCaps_System_Action_Elastic_Clients_Elasticsearch_FieldCapsRequestDescriptor__" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.FieldCaps(System.Action{Elastic.Clients.Elasticsearch.FieldCapsRequestDescriptor})">
  FieldCaps(Action&lt;FieldCapsRequestDescriptor&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L15177"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get the field capabilities.
</p>
<p>
Get information about the capabilities of fields among multiple indices.
</p>
<p>
For data streams, the API returns field capabilities among the stream’s backing indices.
It returns runtime fields like any other field.
For example, a runtime field with a type of keyword is returned the same as any other field that belongs to the <code>keyword</code> family.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-field-caps.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual FieldCapsResponse FieldCaps(Action&lt;FieldCapsRequestDescriptor&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.FieldCapsRequestDescriptor.html">FieldCapsRequestDescriptor</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.FieldCapsResponse.html">FieldCapsResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_FieldCapsAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.FieldCapsAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_FieldCapsAsync_Elastic_Clients_Elasticsearch_FieldCapsRequest_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.FieldCapsAsync(Elastic.Clients.Elasticsearch.FieldCapsRequest,System.Threading.CancellationToken)">
  FieldCapsAsync(FieldCapsRequest, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L14958"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get the field capabilities.
</p>
<p>
Get information about the capabilities of fields among multiple indices.
</p>
<p>
For data streams, the API returns field capabilities among the stream’s backing indices.
It returns runtime fields like any other field.
For example, a runtime field with a type of keyword is returned the same as any other field that belongs to the <code>keyword</code> family.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-field-caps.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;FieldCapsResponse&gt; FieldCapsAsync(FieldCapsRequest request, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.FieldCapsRequest.html">FieldCapsRequest</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.FieldCapsResponse.html">FieldCapsResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_FieldCapsAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.FieldCapsAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_FieldCapsAsync_Elastic_Clients_Elasticsearch_FieldCapsRequestDescriptor_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.FieldCapsAsync(Elastic.Clients.Elasticsearch.FieldCapsRequestDescriptor,System.Threading.CancellationToken)">
  FieldCapsAsync(FieldCapsRequestDescriptor, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L15306"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get the field capabilities.
</p>
<p>
Get information about the capabilities of fields among multiple indices.
</p>
<p>
For data streams, the API returns field capabilities among the stream’s backing indices.
It returns runtime fields like any other field.
For example, a runtime field with a type of keyword is returned the same as any other field that belongs to the <code>keyword</code> family.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-field-caps.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;FieldCapsResponse&gt; FieldCapsAsync(FieldCapsRequestDescriptor descriptor, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.FieldCapsRequestDescriptor.html">FieldCapsRequestDescriptor</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.FieldCapsResponse.html">FieldCapsResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_FieldCapsAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.FieldCapsAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_FieldCapsAsync_Elastic_Clients_Elasticsearch_Indices_System_Action_Elastic_Clients_Elasticsearch_FieldCapsRequestDescriptor__System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.FieldCapsAsync(Elastic.Clients.Elasticsearch.Indices,System.Action{Elastic.Clients.Elasticsearch.FieldCapsRequestDescriptor},System.Threading.CancellationToken)">
  FieldCapsAsync(Indices?, Action&lt;FieldCapsRequestDescriptor&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L15347"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get the field capabilities.
</p>
<p>
Get information about the capabilities of fields among multiple indices.
</p>
<p>
For data streams, the API returns field capabilities among the stream’s backing indices.
It returns runtime fields like any other field.
For example, a runtime field with a type of keyword is returned the same as any other field that belongs to the <code>keyword</code> family.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-field-caps.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;FieldCapsResponse&gt; FieldCapsAsync(Indices? indices, Action&lt;FieldCapsRequestDescriptor&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>indices</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Indices.html">Indices</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.FieldCapsRequestDescriptor.html">FieldCapsRequestDescriptor</a>&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.FieldCapsResponse.html">FieldCapsResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_FieldCapsAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.FieldCapsAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_FieldCapsAsync_Elastic_Clients_Elasticsearch_Indices_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.FieldCapsAsync(Elastic.Clients.Elasticsearch.Indices,System.Threading.CancellationToken)">
  FieldCapsAsync(Indices?, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L15326"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get the field capabilities.
</p>
<p>
Get information about the capabilities of fields among multiple indices.
</p>
<p>
For data streams, the API returns field capabilities among the stream’s backing indices.
It returns runtime fields like any other field.
For example, a runtime field with a type of keyword is returned the same as any other field that belongs to the <code>keyword</code> family.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-field-caps.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;FieldCapsResponse&gt; FieldCapsAsync(Indices? indices, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>indices</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Indices.html">Indices</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.FieldCapsResponse.html">FieldCapsResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_FieldCapsAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.FieldCapsAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_FieldCapsAsync_System_Action_Elastic_Clients_Elasticsearch_FieldCapsRequestDescriptor__System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.FieldCapsAsync(System.Action{Elastic.Clients.Elasticsearch.FieldCapsRequestDescriptor},System.Threading.CancellationToken)">
  FieldCapsAsync(Action&lt;FieldCapsRequestDescriptor&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L15390"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get the field capabilities.
</p>
<p>
Get information about the capabilities of fields among multiple indices.
</p>
<p>
For data streams, the API returns field capabilities among the stream’s backing indices.
It returns runtime fields like any other field.
For example, a runtime field with a type of keyword is returned the same as any other field that belongs to the <code>keyword</code> family.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-field-caps.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;FieldCapsResponse&gt; FieldCapsAsync(Action&lt;FieldCapsRequestDescriptor&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.FieldCapsRequestDescriptor.html">FieldCapsRequestDescriptor</a>&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.FieldCapsResponse.html">FieldCapsResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_FieldCapsAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.FieldCapsAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_FieldCapsAsync_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.FieldCapsAsync(System.Threading.CancellationToken)">
  FieldCapsAsync(CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L15369"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get the field capabilities.
</p>
<p>
Get information about the capabilities of fields among multiple indices.
</p>
<p>
For data streams, the API returns field capabilities among the stream’s backing indices.
It returns runtime fields like any other field.
For example, a runtime field with a type of keyword is returned the same as any other field that belongs to the <code>keyword</code> family.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-field-caps.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;FieldCapsResponse&gt; FieldCapsAsync(CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.FieldCapsResponse.html">FieldCapsResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_FieldCapsAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.FieldCapsAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_FieldCapsAsync__1_Elastic_Clients_Elasticsearch_FieldCapsRequestDescriptor___0__System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.FieldCapsAsync``1(Elastic.Clients.Elasticsearch.FieldCapsRequestDescriptor{``0},System.Threading.CancellationToken)">
  FieldCapsAsync&lt;TDocument&gt;(FieldCapsRequestDescriptor&lt;TDocument&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L15200"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get the field capabilities.
</p>
<p>
Get information about the capabilities of fields among multiple indices.
</p>
<p>
For data streams, the API returns field capabilities among the stream’s backing indices.
It returns runtime fields like any other field.
For example, a runtime field with a type of keyword is returned the same as any other field that belongs to the <code>keyword</code> family.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-field-caps.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;FieldCapsResponse&gt; FieldCapsAsync&lt;TDocument&gt;(FieldCapsRequestDescriptor&lt;TDocument&gt; descriptor, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.FieldCapsRequestDescriptor-1.html">FieldCapsRequestDescriptor</a>&lt;TDocument&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.FieldCapsResponse.html">FieldCapsResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_FieldCapsAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.FieldCapsAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_FieldCapsAsync__1_Elastic_Clients_Elasticsearch_Indices_System_Action_Elastic_Clients_Elasticsearch_FieldCapsRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.FieldCapsAsync``1(Elastic.Clients.Elasticsearch.Indices,System.Action{Elastic.Clients.Elasticsearch.FieldCapsRequestDescriptor{``0}},System.Threading.CancellationToken)">
  FieldCapsAsync&lt;TDocument&gt;(Indices?, Action&lt;FieldCapsRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L15241"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get the field capabilities.
</p>
<p>
Get information about the capabilities of fields among multiple indices.
</p>
<p>
For data streams, the API returns field capabilities among the stream’s backing indices.
It returns runtime fields like any other field.
For example, a runtime field with a type of keyword is returned the same as any other field that belongs to the <code>keyword</code> family.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-field-caps.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;FieldCapsResponse&gt; FieldCapsAsync&lt;TDocument&gt;(Indices? indices, Action&lt;FieldCapsRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>indices</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Indices.html">Indices</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.FieldCapsRequestDescriptor-1.html">FieldCapsRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.FieldCapsResponse.html">FieldCapsResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_FieldCapsAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.FieldCapsAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_FieldCapsAsync__1_Elastic_Clients_Elasticsearch_Indices_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.FieldCapsAsync``1(Elastic.Clients.Elasticsearch.Indices,System.Threading.CancellationToken)">
  FieldCapsAsync&lt;TDocument&gt;(Indices?, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L15220"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get the field capabilities.
</p>
<p>
Get information about the capabilities of fields among multiple indices.
</p>
<p>
For data streams, the API returns field capabilities among the stream’s backing indices.
It returns runtime fields like any other field.
For example, a runtime field with a type of keyword is returned the same as any other field that belongs to the <code>keyword</code> family.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-field-caps.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;FieldCapsResponse&gt; FieldCapsAsync&lt;TDocument&gt;(Indices? indices, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>indices</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Indices.html">Indices</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.FieldCapsResponse.html">FieldCapsResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_FieldCapsAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.FieldCapsAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_FieldCapsAsync__1_System_Action_Elastic_Clients_Elasticsearch_FieldCapsRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.FieldCapsAsync``1(System.Action{Elastic.Clients.Elasticsearch.FieldCapsRequestDescriptor{``0}},System.Threading.CancellationToken)">
  FieldCapsAsync&lt;TDocument&gt;(Action&lt;FieldCapsRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L15284"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get the field capabilities.
</p>
<p>
Get information about the capabilities of fields among multiple indices.
</p>
<p>
For data streams, the API returns field capabilities among the stream’s backing indices.
It returns runtime fields like any other field.
For example, a runtime field with a type of keyword is returned the same as any other field that belongs to the <code>keyword</code> family.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-field-caps.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;FieldCapsResponse&gt; FieldCapsAsync&lt;TDocument&gt;(Action&lt;FieldCapsRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.FieldCapsRequestDescriptor-1.html">FieldCapsRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.FieldCapsResponse.html">FieldCapsResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_FieldCapsAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.FieldCapsAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_FieldCapsAsync__1_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.FieldCapsAsync``1(System.Threading.CancellationToken)">
  FieldCapsAsync&lt;TDocument&gt;(CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L15263"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get the field capabilities.
</p>
<p>
Get information about the capabilities of fields among multiple indices.
</p>
<p>
For data streams, the API returns field capabilities among the stream’s backing indices.
It returns runtime fields like any other field.
For example, a runtime field with a type of keyword is returned the same as any other field that belongs to the <code>keyword</code> family.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-field-caps.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;FieldCapsResponse&gt; FieldCapsAsync&lt;TDocument&gt;(CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.FieldCapsResponse.html">FieldCapsResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_FieldCaps_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.FieldCaps*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_FieldCaps__1" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.FieldCaps``1">
  FieldCaps&lt;TDocument&gt;()
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L15044"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get the field capabilities.
</p>
<p>
Get information about the capabilities of fields among multiple indices.
</p>
<p>
For data streams, the API returns field capabilities among the stream’s backing indices.
It returns runtime fields like any other field.
For example, a runtime field with a type of keyword is returned the same as any other field that belongs to the <code>keyword</code> family.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-field-caps.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual FieldCapsResponse FieldCaps&lt;TDocument&gt;()</code></pre>
  </div>


  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.FieldCapsResponse.html">FieldCapsResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_FieldCaps_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.FieldCaps*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_FieldCaps__1_Elastic_Clients_Elasticsearch_FieldCapsRequestDescriptor___0__" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.FieldCaps``1(Elastic.Clients.Elasticsearch.FieldCapsRequestDescriptor{``0})">
  FieldCaps&lt;TDocument&gt;(FieldCapsRequestDescriptor&lt;TDocument&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L14978"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get the field capabilities.
</p>
<p>
Get information about the capabilities of fields among multiple indices.
</p>
<p>
For data streams, the API returns field capabilities among the stream’s backing indices.
It returns runtime fields like any other field.
For example, a runtime field with a type of keyword is returned the same as any other field that belongs to the <code>keyword</code> family.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-field-caps.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual FieldCapsResponse FieldCaps&lt;TDocument&gt;(FieldCapsRequestDescriptor&lt;TDocument&gt; descriptor)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.FieldCapsRequestDescriptor-1.html">FieldCapsRequestDescriptor</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.FieldCapsResponse.html">FieldCapsResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_FieldCaps_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.FieldCaps*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_FieldCaps__1_Elastic_Clients_Elasticsearch_Indices_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.FieldCaps``1(Elastic.Clients.Elasticsearch.Indices)">
  FieldCaps&lt;TDocument&gt;(Indices?)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L14999"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get the field capabilities.
</p>
<p>
Get information about the capabilities of fields among multiple indices.
</p>
<p>
For data streams, the API returns field capabilities among the stream’s backing indices.
It returns runtime fields like any other field.
For example, a runtime field with a type of keyword is returned the same as any other field that belongs to the <code>keyword</code> family.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-field-caps.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual FieldCapsResponse FieldCaps&lt;TDocument&gt;(Indices? indices)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>indices</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Indices.html">Indices</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.FieldCapsResponse.html">FieldCapsResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_FieldCaps_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.FieldCaps*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_FieldCaps__1_Elastic_Clients_Elasticsearch_Indices_System_Action_Elastic_Clients_Elasticsearch_FieldCapsRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.FieldCaps``1(Elastic.Clients.Elasticsearch.Indices,System.Action{Elastic.Clients.Elasticsearch.FieldCapsRequestDescriptor{``0}})">
  FieldCaps&lt;TDocument&gt;(Indices?, Action&lt;FieldCapsRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L15021"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get the field capabilities.
</p>
<p>
Get information about the capabilities of fields among multiple indices.
</p>
<p>
For data streams, the API returns field capabilities among the stream’s backing indices.
It returns runtime fields like any other field.
For example, a runtime field with a type of keyword is returned the same as any other field that belongs to the <code>keyword</code> family.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-field-caps.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual FieldCapsResponse FieldCaps&lt;TDocument&gt;(Indices? indices, Action&lt;FieldCapsRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>indices</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Indices.html">Indices</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.FieldCapsRequestDescriptor-1.html">FieldCapsRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.FieldCapsResponse.html">FieldCapsResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_FieldCaps_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.FieldCaps*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_FieldCaps__1_System_Action_Elastic_Clients_Elasticsearch_FieldCapsRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.FieldCaps``1(System.Action{Elastic.Clients.Elasticsearch.FieldCapsRequestDescriptor{``0}})">
  FieldCaps&lt;TDocument&gt;(Action&lt;FieldCapsRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L15066"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get the field capabilities.
</p>
<p>
Get information about the capabilities of fields among multiple indices.
</p>
<p>
For data streams, the API returns field capabilities among the stream’s backing indices.
It returns runtime fields like any other field.
For example, a runtime field with a type of keyword is returned the same as any other field that belongs to the <code>keyword</code> family.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-field-caps.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual FieldCapsResponse FieldCaps&lt;TDocument&gt;(Action&lt;FieldCapsRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.FieldCapsRequestDescriptor-1.html">FieldCapsRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.FieldCapsResponse.html">FieldCapsResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetAsync__1_Elastic_Clients_Elasticsearch_GetRequest_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetAsync``1(Elastic.Clients.Elasticsearch.GetRequest,System.Threading.CancellationToken)">
  GetAsync&lt;TDocument&gt;(GetRequest, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L15551"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get a document by its ID.
</p>
<p>
Get a document and its source or stored fields from an index.
</p>
<p>
By default, this API is realtime and is not affected by the refresh rate of the index (when data will become visible for search).
In the case where stored fields are requested with the <code>stored_fields</code> parameter and the document has been updated but is not yet refreshed, the API will have to parse and analyze the source to extract the stored fields.
To turn off realtime behavior, set the <code>realtime</code> parameter to false.
</p>
<p>
<strong>Source filtering</strong>
</p>
<p>
By default, the API returns the contents of the <code>_source</code> field unless you have used the <code>stored_fields</code> parameter or the <code>_source</code> field is turned off.
You can turn off <code>_source</code> retrieval by using the <code>_source</code> parameter:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/0?_source=false</code></pre>
<p>
If you only need one or two fields from the <code>_source</code>, use the <code>_source_includes</code> or <code>_source_excludes</code> parameters to include or filter out particular fields.
This can be helpful with large documents where partial retrieval can save on network overhead
Both parameters take a comma separated list of fields or wildcard expressions.
For example:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/0?_source_includes=*.id&amp;_source_excludes=entities</code></pre>
<p>
If you only want to specify includes, you can use a shorter notation:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/0?_source=*.id</code></pre>
<p>
<strong>Routing</strong>
</p>
<p>
If routing is used during indexing, the routing value also needs to be specified to retrieve a document.
For example:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/2?routing=user1</code></pre>
<p>
This request gets the document with ID 2, but it is routed based on the user.
The document is not fetched if the correct routing is not specified.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The GET operation is hashed into a specific shard ID.
It is then redirected to one of the replicas within that shard ID and returns the result.
The replicas are the primary shard and its replicas within that shard ID group.
This means that the more replicas you have, the better your GET scaling will be.
</p>
<p>
<strong>Versioning support</strong>
</p>
<p>
You can use the <code>version</code> parameter to retrieve the document only if its current version is equal to the specified one.
</p>
<p>
Internally, Elasticsearch has marked the old document as deleted and added an entirely new document.
The old version of the document doesn't disappear immediately, although you won't be able to access it.
Elasticsearch cleans up deleted documents in the background as you continue to index more data.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;GetResponse&lt;TDocument&gt;&gt; GetAsync&lt;TDocument&gt;(GetRequest request, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.GetRequest.html">GetRequest</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.GetResponse-1.html">GetResponse</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetAsync__1_Elastic_Clients_Elasticsearch_GetRequestDescriptor___0__System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetAsync``1(Elastic.Clients.Elasticsearch.GetRequestDescriptor{``0},System.Threading.CancellationToken)">
  GetAsync&lt;TDocument&gt;(GetRequestDescriptor&lt;TDocument&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L16525"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get a document by its ID.
</p>
<p>
Get a document and its source or stored fields from an index.
</p>
<p>
By default, this API is realtime and is not affected by the refresh rate of the index (when data will become visible for search).
In the case where stored fields are requested with the <code>stored_fields</code> parameter and the document has been updated but is not yet refreshed, the API will have to parse and analyze the source to extract the stored fields.
To turn off realtime behavior, set the <code>realtime</code> parameter to false.
</p>
<p>
<strong>Source filtering</strong>
</p>
<p>
By default, the API returns the contents of the <code>_source</code> field unless you have used the <code>stored_fields</code> parameter or the <code>_source</code> field is turned off.
You can turn off <code>_source</code> retrieval by using the <code>_source</code> parameter:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/0?_source=false</code></pre>
<p>
If you only need one or two fields from the <code>_source</code>, use the <code>_source_includes</code> or <code>_source_excludes</code> parameters to include or filter out particular fields.
This can be helpful with large documents where partial retrieval can save on network overhead
Both parameters take a comma separated list of fields or wildcard expressions.
For example:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/0?_source_includes=*.id&amp;_source_excludes=entities</code></pre>
<p>
If you only want to specify includes, you can use a shorter notation:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/0?_source=*.id</code></pre>
<p>
<strong>Routing</strong>
</p>
<p>
If routing is used during indexing, the routing value also needs to be specified to retrieve a document.
For example:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/2?routing=user1</code></pre>
<p>
This request gets the document with ID 2, but it is routed based on the user.
The document is not fetched if the correct routing is not specified.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The GET operation is hashed into a specific shard ID.
It is then redirected to one of the replicas within that shard ID and returns the result.
The replicas are the primary shard and its replicas within that shard ID group.
This means that the more replicas you have, the better your GET scaling will be.
</p>
<p>
<strong>Versioning support</strong>
</p>
<p>
You can use the <code>version</code> parameter to retrieve the document only if its current version is equal to the specified one.
</p>
<p>
Internally, Elasticsearch has marked the old document as deleted and added an entirely new document.
The old version of the document doesn't disappear immediately, although you won't be able to access it.
Elasticsearch cleans up deleted documents in the background as you continue to index more data.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;GetResponse&lt;TDocument&gt;&gt; GetAsync&lt;TDocument&gt;(GetRequestDescriptor&lt;TDocument&gt; descriptor, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.GetRequestDescriptor-1.html">GetRequestDescriptor</a>&lt;TDocument&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.GetResponse-1.html">GetResponse</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetAsync__1_Elastic_Clients_Elasticsearch_Id_System_Action_Elastic_Clients_Elasticsearch_GetRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetAsync``1(Elastic.Clients.Elasticsearch.Id,System.Action{Elastic.Clients.Elasticsearch.GetRequestDescriptor{``0}},System.Threading.CancellationToken)">
  GetAsync&lt;TDocument&gt;(Id, Action&lt;GetRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L17328"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get a document by its ID.
</p>
<p>
Get a document and its source or stored fields from an index.
</p>
<p>
By default, this API is realtime and is not affected by the refresh rate of the index (when data will become visible for search).
In the case where stored fields are requested with the <code>stored_fields</code> parameter and the document has been updated but is not yet refreshed, the API will have to parse and analyze the source to extract the stored fields.
To turn off realtime behavior, set the <code>realtime</code> parameter to false.
</p>
<p>
<strong>Source filtering</strong>
</p>
<p>
By default, the API returns the contents of the <code>_source</code> field unless you have used the <code>stored_fields</code> parameter or the <code>_source</code> field is turned off.
You can turn off <code>_source</code> retrieval by using the <code>_source</code> parameter:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/0?_source=false</code></pre>
<p>
If you only need one or two fields from the <code>_source</code>, use the <code>_source_includes</code> or <code>_source_excludes</code> parameters to include or filter out particular fields.
This can be helpful with large documents where partial retrieval can save on network overhead
Both parameters take a comma separated list of fields or wildcard expressions.
For example:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/0?_source_includes=*.id&amp;_source_excludes=entities</code></pre>
<p>
If you only want to specify includes, you can use a shorter notation:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/0?_source=*.id</code></pre>
<p>
<strong>Routing</strong>
</p>
<p>
If routing is used during indexing, the routing value also needs to be specified to retrieve a document.
For example:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/2?routing=user1</code></pre>
<p>
This request gets the document with ID 2, but it is routed based on the user.
The document is not fetched if the correct routing is not specified.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The GET operation is hashed into a specific shard ID.
It is then redirected to one of the replicas within that shard ID and returns the result.
The replicas are the primary shard and its replicas within that shard ID group.
This means that the more replicas you have, the better your GET scaling will be.
</p>
<p>
<strong>Versioning support</strong>
</p>
<p>
You can use the <code>version</code> parameter to retrieve the document only if its current version is equal to the specified one.
</p>
<p>
Internally, Elasticsearch has marked the old document as deleted and added an entirely new document.
The old version of the document doesn't disappear immediately, although you won't be able to access it.
Elasticsearch cleans up deleted documents in the background as you continue to index more data.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;GetResponse&lt;TDocument&gt;&gt; GetAsync&lt;TDocument&gt;(Id id, Action&lt;GetRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.GetRequestDescriptor-1.html">GetRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.GetResponse-1.html">GetResponse</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetAsync__1_Elastic_Clients_Elasticsearch_Id_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetAsync``1(Elastic.Clients.Elasticsearch.Id,System.Threading.CancellationToken)">
  GetAsync&lt;TDocument&gt;(Id, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L17248"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get a document by its ID.
</p>
<p>
Get a document and its source or stored fields from an index.
</p>
<p>
By default, this API is realtime and is not affected by the refresh rate of the index (when data will become visible for search).
In the case where stored fields are requested with the <code>stored_fields</code> parameter and the document has been updated but is not yet refreshed, the API will have to parse and analyze the source to extract the stored fields.
To turn off realtime behavior, set the <code>realtime</code> parameter to false.
</p>
<p>
<strong>Source filtering</strong>
</p>
<p>
By default, the API returns the contents of the <code>_source</code> field unless you have used the <code>stored_fields</code> parameter or the <code>_source</code> field is turned off.
You can turn off <code>_source</code> retrieval by using the <code>_source</code> parameter:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/0?_source=false</code></pre>
<p>
If you only need one or two fields from the <code>_source</code>, use the <code>_source_includes</code> or <code>_source_excludes</code> parameters to include or filter out particular fields.
This can be helpful with large documents where partial retrieval can save on network overhead
Both parameters take a comma separated list of fields or wildcard expressions.
For example:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/0?_source_includes=*.id&amp;_source_excludes=entities</code></pre>
<p>
If you only want to specify includes, you can use a shorter notation:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/0?_source=*.id</code></pre>
<p>
<strong>Routing</strong>
</p>
<p>
If routing is used during indexing, the routing value also needs to be specified to retrieve a document.
For example:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/2?routing=user1</code></pre>
<p>
This request gets the document with ID 2, but it is routed based on the user.
The document is not fetched if the correct routing is not specified.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The GET operation is hashed into a specific shard ID.
It is then redirected to one of the replicas within that shard ID and returns the result.
The replicas are the primary shard and its replicas within that shard ID group.
This means that the more replicas you have, the better your GET scaling will be.
</p>
<p>
<strong>Versioning support</strong>
</p>
<p>
You can use the <code>version</code> parameter to retrieve the document only if its current version is equal to the specified one.
</p>
<p>
Internally, Elasticsearch has marked the old document as deleted and added an entirely new document.
The old version of the document doesn't disappear immediately, although you won't be able to access it.
Elasticsearch cleans up deleted documents in the background as you continue to index more data.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;GetResponse&lt;TDocument&gt;&gt; GetAsync&lt;TDocument&gt;(Id id, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.GetResponse-1.html">GetResponse</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetAsync__1_Elastic_Clients_Elasticsearch_IndexName_Elastic_Clients_Elasticsearch_Id_System_Action_Elastic_Clients_Elasticsearch_GetRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetAsync``1(Elastic.Clients.Elasticsearch.IndexName,Elastic.Clients.Elasticsearch.Id,System.Action{Elastic.Clients.Elasticsearch.GetRequestDescriptor{``0}},System.Threading.CancellationToken)">
  GetAsync&lt;TDocument&gt;(IndexName, Id, Action&lt;GetRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L16684"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get a document by its ID.
</p>
<p>
Get a document and its source or stored fields from an index.
</p>
<p>
By default, this API is realtime and is not affected by the refresh rate of the index (when data will become visible for search).
In the case where stored fields are requested with the <code>stored_fields</code> parameter and the document has been updated but is not yet refreshed, the API will have to parse and analyze the source to extract the stored fields.
To turn off realtime behavior, set the <code>realtime</code> parameter to false.
</p>
<p>
<strong>Source filtering</strong>
</p>
<p>
By default, the API returns the contents of the <code>_source</code> field unless you have used the <code>stored_fields</code> parameter or the <code>_source</code> field is turned off.
You can turn off <code>_source</code> retrieval by using the <code>_source</code> parameter:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/0?_source=false</code></pre>
<p>
If you only need one or two fields from the <code>_source</code>, use the <code>_source_includes</code> or <code>_source_excludes</code> parameters to include or filter out particular fields.
This can be helpful with large documents where partial retrieval can save on network overhead
Both parameters take a comma separated list of fields or wildcard expressions.
For example:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/0?_source_includes=*.id&amp;_source_excludes=entities</code></pre>
<p>
If you only want to specify includes, you can use a shorter notation:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/0?_source=*.id</code></pre>
<p>
<strong>Routing</strong>
</p>
<p>
If routing is used during indexing, the routing value also needs to be specified to retrieve a document.
For example:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/2?routing=user1</code></pre>
<p>
This request gets the document with ID 2, but it is routed based on the user.
The document is not fetched if the correct routing is not specified.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The GET operation is hashed into a specific shard ID.
It is then redirected to one of the replicas within that shard ID and returns the result.
The replicas are the primary shard and its replicas within that shard ID group.
This means that the more replicas you have, the better your GET scaling will be.
</p>
<p>
<strong>Versioning support</strong>
</p>
<p>
You can use the <code>version</code> parameter to retrieve the document only if its current version is equal to the specified one.
</p>
<p>
Internally, Elasticsearch has marked the old document as deleted and added an entirely new document.
The old version of the document doesn't disappear immediately, although you won't be able to access it.
Elasticsearch cleans up deleted documents in the background as you continue to index more data.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;GetResponse&lt;TDocument&gt;&gt; GetAsync&lt;TDocument&gt;(IndexName index, Id id, Action&lt;GetRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.GetRequestDescriptor-1.html">GetRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.GetResponse-1.html">GetResponse</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetAsync__1_Elastic_Clients_Elasticsearch_IndexName_Elastic_Clients_Elasticsearch_Id_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetAsync``1(Elastic.Clients.Elasticsearch.IndexName,Elastic.Clients.Elasticsearch.Id,System.Threading.CancellationToken)">
  GetAsync&lt;TDocument&gt;(IndexName, Id, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L16604"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get a document by its ID.
</p>
<p>
Get a document and its source or stored fields from an index.
</p>
<p>
By default, this API is realtime and is not affected by the refresh rate of the index (when data will become visible for search).
In the case where stored fields are requested with the <code>stored_fields</code> parameter and the document has been updated but is not yet refreshed, the API will have to parse and analyze the source to extract the stored fields.
To turn off realtime behavior, set the <code>realtime</code> parameter to false.
</p>
<p>
<strong>Source filtering</strong>
</p>
<p>
By default, the API returns the contents of the <code>_source</code> field unless you have used the <code>stored_fields</code> parameter or the <code>_source</code> field is turned off.
You can turn off <code>_source</code> retrieval by using the <code>_source</code> parameter:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/0?_source=false</code></pre>
<p>
If you only need one or two fields from the <code>_source</code>, use the <code>_source_includes</code> or <code>_source_excludes</code> parameters to include or filter out particular fields.
This can be helpful with large documents where partial retrieval can save on network overhead
Both parameters take a comma separated list of fields or wildcard expressions.
For example:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/0?_source_includes=*.id&amp;_source_excludes=entities</code></pre>
<p>
If you only want to specify includes, you can use a shorter notation:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/0?_source=*.id</code></pre>
<p>
<strong>Routing</strong>
</p>
<p>
If routing is used during indexing, the routing value also needs to be specified to retrieve a document.
For example:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/2?routing=user1</code></pre>
<p>
This request gets the document with ID 2, but it is routed based on the user.
The document is not fetched if the correct routing is not specified.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The GET operation is hashed into a specific shard ID.
It is then redirected to one of the replicas within that shard ID and returns the result.
The replicas are the primary shard and its replicas within that shard ID group.
This means that the more replicas you have, the better your GET scaling will be.
</p>
<p>
<strong>Versioning support</strong>
</p>
<p>
You can use the <code>version</code> parameter to retrieve the document only if its current version is equal to the specified one.
</p>
<p>
Internally, Elasticsearch has marked the old document as deleted and added an entirely new document.
The old version of the document doesn't disappear immediately, although you won't be able to access it.
Elasticsearch cleans up deleted documents in the background as you continue to index more data.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;GetResponse&lt;TDocument&gt;&gt; GetAsync&lt;TDocument&gt;(IndexName index, Id id, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.GetResponse-1.html">GetResponse</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetAsync__1___0_Elastic_Clients_Elasticsearch_Id_System_Action_Elastic_Clients_Elasticsearch_GetRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetAsync``1(``0,Elastic.Clients.Elasticsearch.Id,System.Action{Elastic.Clients.Elasticsearch.GetRequestDescriptor{``0}},System.Threading.CancellationToken)">
  GetAsync&lt;TDocument&gt;(TDocument, Id, Action&lt;GetRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L17167"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get a document by its ID.
</p>
<p>
Get a document and its source or stored fields from an index.
</p>
<p>
By default, this API is realtime and is not affected by the refresh rate of the index (when data will become visible for search).
In the case where stored fields are requested with the <code>stored_fields</code> parameter and the document has been updated but is not yet refreshed, the API will have to parse and analyze the source to extract the stored fields.
To turn off realtime behavior, set the <code>realtime</code> parameter to false.
</p>
<p>
<strong>Source filtering</strong>
</p>
<p>
By default, the API returns the contents of the <code>_source</code> field unless you have used the <code>stored_fields</code> parameter or the <code>_source</code> field is turned off.
You can turn off <code>_source</code> retrieval by using the <code>_source</code> parameter:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/0?_source=false</code></pre>
<p>
If you only need one or two fields from the <code>_source</code>, use the <code>_source_includes</code> or <code>_source_excludes</code> parameters to include or filter out particular fields.
This can be helpful with large documents where partial retrieval can save on network overhead
Both parameters take a comma separated list of fields or wildcard expressions.
For example:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/0?_source_includes=*.id&amp;_source_excludes=entities</code></pre>
<p>
If you only want to specify includes, you can use a shorter notation:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/0?_source=*.id</code></pre>
<p>
<strong>Routing</strong>
</p>
<p>
If routing is used during indexing, the routing value also needs to be specified to retrieve a document.
For example:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/2?routing=user1</code></pre>
<p>
This request gets the document with ID 2, but it is routed based on the user.
The document is not fetched if the correct routing is not specified.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The GET operation is hashed into a specific shard ID.
It is then redirected to one of the replicas within that shard ID and returns the result.
The replicas are the primary shard and its replicas within that shard ID group.
This means that the more replicas you have, the better your GET scaling will be.
</p>
<p>
<strong>Versioning support</strong>
</p>
<p>
You can use the <code>version</code> parameter to retrieve the document only if its current version is equal to the specified one.
</p>
<p>
Internally, Elasticsearch has marked the old document as deleted and added an entirely new document.
The old version of the document doesn't disappear immediately, although you won't be able to access it.
Elasticsearch cleans up deleted documents in the background as you continue to index more data.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;GetResponse&lt;TDocument&gt;&gt; GetAsync&lt;TDocument&gt;(TDocument document, Id id, Action&lt;GetRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.GetRequestDescriptor-1.html">GetRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.GetResponse-1.html">GetResponse</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetAsync__1___0_Elastic_Clients_Elasticsearch_Id_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetAsync``1(``0,Elastic.Clients.Elasticsearch.Id,System.Threading.CancellationToken)">
  GetAsync&lt;TDocument&gt;(TDocument, Id, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L17087"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get a document by its ID.
</p>
<p>
Get a document and its source or stored fields from an index.
</p>
<p>
By default, this API is realtime and is not affected by the refresh rate of the index (when data will become visible for search).
In the case where stored fields are requested with the <code>stored_fields</code> parameter and the document has been updated but is not yet refreshed, the API will have to parse and analyze the source to extract the stored fields.
To turn off realtime behavior, set the <code>realtime</code> parameter to false.
</p>
<p>
<strong>Source filtering</strong>
</p>
<p>
By default, the API returns the contents of the <code>_source</code> field unless you have used the <code>stored_fields</code> parameter or the <code>_source</code> field is turned off.
You can turn off <code>_source</code> retrieval by using the <code>_source</code> parameter:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/0?_source=false</code></pre>
<p>
If you only need one or two fields from the <code>_source</code>, use the <code>_source_includes</code> or <code>_source_excludes</code> parameters to include or filter out particular fields.
This can be helpful with large documents where partial retrieval can save on network overhead
Both parameters take a comma separated list of fields or wildcard expressions.
For example:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/0?_source_includes=*.id&amp;_source_excludes=entities</code></pre>
<p>
If you only want to specify includes, you can use a shorter notation:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/0?_source=*.id</code></pre>
<p>
<strong>Routing</strong>
</p>
<p>
If routing is used during indexing, the routing value also needs to be specified to retrieve a document.
For example:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/2?routing=user1</code></pre>
<p>
This request gets the document with ID 2, but it is routed based on the user.
The document is not fetched if the correct routing is not specified.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The GET operation is hashed into a specific shard ID.
It is then redirected to one of the replicas within that shard ID and returns the result.
The replicas are the primary shard and its replicas within that shard ID group.
This means that the more replicas you have, the better your GET scaling will be.
</p>
<p>
<strong>Versioning support</strong>
</p>
<p>
You can use the <code>version</code> parameter to retrieve the document only if its current version is equal to the specified one.
</p>
<p>
Internally, Elasticsearch has marked the old document as deleted and added an entirely new document.
The old version of the document doesn't disappear immediately, although you won't be able to access it.
Elasticsearch cleans up deleted documents in the background as you continue to index more data.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;GetResponse&lt;TDocument&gt;&gt; GetAsync&lt;TDocument&gt;(TDocument document, Id id, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.GetResponse-1.html">GetResponse</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetAsync__1___0_Elastic_Clients_Elasticsearch_IndexName_System_Action_Elastic_Clients_Elasticsearch_GetRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetAsync``1(``0,Elastic.Clients.Elasticsearch.IndexName,System.Action{Elastic.Clients.Elasticsearch.GetRequestDescriptor{``0}},System.Threading.CancellationToken)">
  GetAsync&lt;TDocument&gt;(TDocument, IndexName, Action&lt;GetRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L17006"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get a document by its ID.
</p>
<p>
Get a document and its source or stored fields from an index.
</p>
<p>
By default, this API is realtime and is not affected by the refresh rate of the index (when data will become visible for search).
In the case where stored fields are requested with the <code>stored_fields</code> parameter and the document has been updated but is not yet refreshed, the API will have to parse and analyze the source to extract the stored fields.
To turn off realtime behavior, set the <code>realtime</code> parameter to false.
</p>
<p>
<strong>Source filtering</strong>
</p>
<p>
By default, the API returns the contents of the <code>_source</code> field unless you have used the <code>stored_fields</code> parameter or the <code>_source</code> field is turned off.
You can turn off <code>_source</code> retrieval by using the <code>_source</code> parameter:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/0?_source=false</code></pre>
<p>
If you only need one or two fields from the <code>_source</code>, use the <code>_source_includes</code> or <code>_source_excludes</code> parameters to include or filter out particular fields.
This can be helpful with large documents where partial retrieval can save on network overhead
Both parameters take a comma separated list of fields or wildcard expressions.
For example:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/0?_source_includes=*.id&amp;_source_excludes=entities</code></pre>
<p>
If you only want to specify includes, you can use a shorter notation:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/0?_source=*.id</code></pre>
<p>
<strong>Routing</strong>
</p>
<p>
If routing is used during indexing, the routing value also needs to be specified to retrieve a document.
For example:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/2?routing=user1</code></pre>
<p>
This request gets the document with ID 2, but it is routed based on the user.
The document is not fetched if the correct routing is not specified.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The GET operation is hashed into a specific shard ID.
It is then redirected to one of the replicas within that shard ID and returns the result.
The replicas are the primary shard and its replicas within that shard ID group.
This means that the more replicas you have, the better your GET scaling will be.
</p>
<p>
<strong>Versioning support</strong>
</p>
<p>
You can use the <code>version</code> parameter to retrieve the document only if its current version is equal to the specified one.
</p>
<p>
Internally, Elasticsearch has marked the old document as deleted and added an entirely new document.
The old version of the document doesn't disappear immediately, although you won't be able to access it.
Elasticsearch cleans up deleted documents in the background as you continue to index more data.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;GetResponse&lt;TDocument&gt;&gt; GetAsync&lt;TDocument&gt;(TDocument document, IndexName index, Action&lt;GetRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.GetRequestDescriptor-1.html">GetRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.GetResponse-1.html">GetResponse</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetAsync__1___0_Elastic_Clients_Elasticsearch_IndexName_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetAsync``1(``0,Elastic.Clients.Elasticsearch.IndexName,System.Threading.CancellationToken)">
  GetAsync&lt;TDocument&gt;(TDocument, IndexName, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L16926"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get a document by its ID.
</p>
<p>
Get a document and its source or stored fields from an index.
</p>
<p>
By default, this API is realtime and is not affected by the refresh rate of the index (when data will become visible for search).
In the case where stored fields are requested with the <code>stored_fields</code> parameter and the document has been updated but is not yet refreshed, the API will have to parse and analyze the source to extract the stored fields.
To turn off realtime behavior, set the <code>realtime</code> parameter to false.
</p>
<p>
<strong>Source filtering</strong>
</p>
<p>
By default, the API returns the contents of the <code>_source</code> field unless you have used the <code>stored_fields</code> parameter or the <code>_source</code> field is turned off.
You can turn off <code>_source</code> retrieval by using the <code>_source</code> parameter:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/0?_source=false</code></pre>
<p>
If you only need one or two fields from the <code>_source</code>, use the <code>_source_includes</code> or <code>_source_excludes</code> parameters to include or filter out particular fields.
This can be helpful with large documents where partial retrieval can save on network overhead
Both parameters take a comma separated list of fields or wildcard expressions.
For example:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/0?_source_includes=*.id&amp;_source_excludes=entities</code></pre>
<p>
If you only want to specify includes, you can use a shorter notation:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/0?_source=*.id</code></pre>
<p>
<strong>Routing</strong>
</p>
<p>
If routing is used during indexing, the routing value also needs to be specified to retrieve a document.
For example:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/2?routing=user1</code></pre>
<p>
This request gets the document with ID 2, but it is routed based on the user.
The document is not fetched if the correct routing is not specified.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The GET operation is hashed into a specific shard ID.
It is then redirected to one of the replicas within that shard ID and returns the result.
The replicas are the primary shard and its replicas within that shard ID group.
This means that the more replicas you have, the better your GET scaling will be.
</p>
<p>
<strong>Versioning support</strong>
</p>
<p>
You can use the <code>version</code> parameter to retrieve the document only if its current version is equal to the specified one.
</p>
<p>
Internally, Elasticsearch has marked the old document as deleted and added an entirely new document.
The old version of the document doesn't disappear immediately, although you won't be able to access it.
Elasticsearch cleans up deleted documents in the background as you continue to index more data.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;GetResponse&lt;TDocument&gt;&gt; GetAsync&lt;TDocument&gt;(TDocument document, IndexName index, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.GetResponse-1.html">GetResponse</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetAsync__1___0_System_Action_Elastic_Clients_Elasticsearch_GetRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetAsync``1(``0,System.Action{Elastic.Clients.Elasticsearch.GetRequestDescriptor{``0}},System.Threading.CancellationToken)">
  GetAsync&lt;TDocument&gt;(TDocument, Action&lt;GetRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L16845"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get a document by its ID.
</p>
<p>
Get a document and its source or stored fields from an index.
</p>
<p>
By default, this API is realtime and is not affected by the refresh rate of the index (when data will become visible for search).
In the case where stored fields are requested with the <code>stored_fields</code> parameter and the document has been updated but is not yet refreshed, the API will have to parse and analyze the source to extract the stored fields.
To turn off realtime behavior, set the <code>realtime</code> parameter to false.
</p>
<p>
<strong>Source filtering</strong>
</p>
<p>
By default, the API returns the contents of the <code>_source</code> field unless you have used the <code>stored_fields</code> parameter or the <code>_source</code> field is turned off.
You can turn off <code>_source</code> retrieval by using the <code>_source</code> parameter:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/0?_source=false</code></pre>
<p>
If you only need one or two fields from the <code>_source</code>, use the <code>_source_includes</code> or <code>_source_excludes</code> parameters to include or filter out particular fields.
This can be helpful with large documents where partial retrieval can save on network overhead
Both parameters take a comma separated list of fields or wildcard expressions.
For example:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/0?_source_includes=*.id&amp;_source_excludes=entities</code></pre>
<p>
If you only want to specify includes, you can use a shorter notation:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/0?_source=*.id</code></pre>
<p>
<strong>Routing</strong>
</p>
<p>
If routing is used during indexing, the routing value also needs to be specified to retrieve a document.
For example:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/2?routing=user1</code></pre>
<p>
This request gets the document with ID 2, but it is routed based on the user.
The document is not fetched if the correct routing is not specified.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The GET operation is hashed into a specific shard ID.
It is then redirected to one of the replicas within that shard ID and returns the result.
The replicas are the primary shard and its replicas within that shard ID group.
This means that the more replicas you have, the better your GET scaling will be.
</p>
<p>
<strong>Versioning support</strong>
</p>
<p>
You can use the <code>version</code> parameter to retrieve the document only if its current version is equal to the specified one.
</p>
<p>
Internally, Elasticsearch has marked the old document as deleted and added an entirely new document.
The old version of the document doesn't disappear immediately, although you won't be able to access it.
Elasticsearch cleans up deleted documents in the background as you continue to index more data.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;GetResponse&lt;TDocument&gt;&gt; GetAsync&lt;TDocument&gt;(TDocument document, Action&lt;GetRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.GetRequestDescriptor-1.html">GetRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.GetResponse-1.html">GetResponse</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetAsync__1___0_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetAsync``1(``0,System.Threading.CancellationToken)">
  GetAsync&lt;TDocument&gt;(TDocument, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L16765"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get a document by its ID.
</p>
<p>
Get a document and its source or stored fields from an index.
</p>
<p>
By default, this API is realtime and is not affected by the refresh rate of the index (when data will become visible for search).
In the case where stored fields are requested with the <code>stored_fields</code> parameter and the document has been updated but is not yet refreshed, the API will have to parse and analyze the source to extract the stored fields.
To turn off realtime behavior, set the <code>realtime</code> parameter to false.
</p>
<p>
<strong>Source filtering</strong>
</p>
<p>
By default, the API returns the contents of the <code>_source</code> field unless you have used the <code>stored_fields</code> parameter or the <code>_source</code> field is turned off.
You can turn off <code>_source</code> retrieval by using the <code>_source</code> parameter:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/0?_source=false</code></pre>
<p>
If you only need one or two fields from the <code>_source</code>, use the <code>_source_includes</code> or <code>_source_excludes</code> parameters to include or filter out particular fields.
This can be helpful with large documents where partial retrieval can save on network overhead
Both parameters take a comma separated list of fields or wildcard expressions.
For example:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/0?_source_includes=*.id&amp;_source_excludes=entities</code></pre>
<p>
If you only want to specify includes, you can use a shorter notation:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/0?_source=*.id</code></pre>
<p>
<strong>Routing</strong>
</p>
<p>
If routing is used during indexing, the routing value also needs to be specified to retrieve a document.
For example:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/2?routing=user1</code></pre>
<p>
This request gets the document with ID 2, but it is routed based on the user.
The document is not fetched if the correct routing is not specified.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The GET operation is hashed into a specific shard ID.
It is then redirected to one of the replicas within that shard ID and returns the result.
The replicas are the primary shard and its replicas within that shard ID group.
This means that the more replicas you have, the better your GET scaling will be.
</p>
<p>
<strong>Versioning support</strong>
</p>
<p>
You can use the <code>version</code> parameter to retrieve the document only if its current version is equal to the specified one.
</p>
<p>
Internally, Elasticsearch has marked the old document as deleted and added an entirely new document.
The old version of the document doesn't disappear immediately, although you won't be able to access it.
Elasticsearch cleans up deleted documents in the background as you continue to index more data.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;GetResponse&lt;TDocument&gt;&gt; GetAsync&lt;TDocument&gt;(TDocument document, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.GetResponse-1.html">GetResponse</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetScript_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetScript*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetScript_Elastic_Clients_Elasticsearch_GetScriptRequest_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetScript(Elastic.Clients.Elasticsearch.GetScriptRequest)">
  GetScript(GetScriptRequest)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L17343"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get a script or search template.
Retrieves a stored script or search template.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/get-stored-script-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual GetScriptResponse GetScript(GetScriptRequest request)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.GetScriptRequest.html">GetScriptRequest</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.GetScriptResponse.html">GetScriptResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetScript_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetScript*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetScript_Elastic_Clients_Elasticsearch_GetScriptRequestDescriptor_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetScript(Elastic.Clients.Elasticsearch.GetScriptRequestDescriptor)">
  GetScript(GetScriptRequestDescriptor)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L17415"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get a script or search template.
Retrieves a stored script or search template.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/get-stored-script-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual GetScriptResponse GetScript(GetScriptRequestDescriptor descriptor)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.GetScriptRequestDescriptor.html">GetScriptRequestDescriptor</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.GetScriptResponse.html">GetScriptResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetScript_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetScript*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetScript_Elastic_Clients_Elasticsearch_Id_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetScript(Elastic.Clients.Elasticsearch.Id)">
  GetScript(Id)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L17429"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get a script or search template.
Retrieves a stored script or search template.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/get-stored-script-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual GetScriptResponse GetScript(Id id)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.GetScriptResponse.html">GetScriptResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetScript_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetScript*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetScript_Elastic_Clients_Elasticsearch_Id_System_Action_Elastic_Clients_Elasticsearch_GetScriptRequestDescriptor__" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetScript(Elastic.Clients.Elasticsearch.Id,System.Action{Elastic.Clients.Elasticsearch.GetScriptRequestDescriptor})">
  GetScript(Id, Action&lt;GetScriptRequestDescriptor&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L17444"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get a script or search template.
Retrieves a stored script or search template.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/get-stored-script-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual GetScriptResponse GetScript(Id id, Action&lt;GetScriptRequestDescriptor&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.GetScriptRequestDescriptor.html">GetScriptRequestDescriptor</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.GetScriptResponse.html">GetScriptResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetScriptAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetScriptAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetScriptAsync_Elastic_Clients_Elasticsearch_GetScriptRequest_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetScriptAsync(Elastic.Clients.Elasticsearch.GetScriptRequest,System.Threading.CancellationToken)">
  GetScriptAsync(GetScriptRequest, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L17357"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get a script or search template.
Retrieves a stored script or search template.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/get-stored-script-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;GetScriptResponse&gt; GetScriptAsync(GetScriptRequest request, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.GetScriptRequest.html">GetScriptRequest</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.GetScriptResponse.html">GetScriptResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetScriptAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetScriptAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetScriptAsync_Elastic_Clients_Elasticsearch_GetScriptRequestDescriptor_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetScriptAsync(Elastic.Clients.Elasticsearch.GetScriptRequestDescriptor,System.Threading.CancellationToken)">
  GetScriptAsync(GetScriptRequestDescriptor, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L17502"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get a script or search template.
Retrieves a stored script or search template.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/get-stored-script-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;GetScriptResponse&gt; GetScriptAsync(GetScriptRequestDescriptor descriptor, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.GetScriptRequestDescriptor.html">GetScriptRequestDescriptor</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.GetScriptResponse.html">GetScriptResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetScriptAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetScriptAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetScriptAsync_Elastic_Clients_Elasticsearch_Id_System_Action_Elastic_Clients_Elasticsearch_GetScriptRequestDescriptor__System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetScriptAsync(Elastic.Clients.Elasticsearch.Id,System.Action{Elastic.Clients.Elasticsearch.GetScriptRequestDescriptor},System.Threading.CancellationToken)">
  GetScriptAsync(Id, Action&lt;GetScriptRequestDescriptor&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L17529"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get a script or search template.
Retrieves a stored script or search template.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/get-stored-script-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;GetScriptResponse&gt; GetScriptAsync(Id id, Action&lt;GetScriptRequestDescriptor&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.GetScriptRequestDescriptor.html">GetScriptRequestDescriptor</a>&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.GetScriptResponse.html">GetScriptResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetScriptAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetScriptAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetScriptAsync_Elastic_Clients_Elasticsearch_Id_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetScriptAsync(Elastic.Clients.Elasticsearch.Id,System.Threading.CancellationToken)">
  GetScriptAsync(Id, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L17515"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get a script or search template.
Retrieves a stored script or search template.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/get-stored-script-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;GetScriptResponse&gt; GetScriptAsync(Id id, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.GetScriptResponse.html">GetScriptResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetScriptAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetScriptAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetScriptAsync__1_Elastic_Clients_Elasticsearch_GetScriptRequestDescriptor___0__System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetScriptAsync``1(Elastic.Clients.Elasticsearch.GetScriptRequestDescriptor{``0},System.Threading.CancellationToken)">
  GetScriptAsync&lt;TDocument&gt;(GetScriptRequestDescriptor&lt;TDocument&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L17460"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get a script or search template.
Retrieves a stored script or search template.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/get-stored-script-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;GetScriptResponse&gt; GetScriptAsync&lt;TDocument&gt;(GetScriptRequestDescriptor&lt;TDocument&gt; descriptor, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.GetScriptRequestDescriptor-1.html">GetScriptRequestDescriptor</a>&lt;TDocument&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.GetScriptResponse.html">GetScriptResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetScriptAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetScriptAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetScriptAsync__1_Elastic_Clients_Elasticsearch_Id_System_Action_Elastic_Clients_Elasticsearch_GetScriptRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetScriptAsync``1(Elastic.Clients.Elasticsearch.Id,System.Action{Elastic.Clients.Elasticsearch.GetScriptRequestDescriptor{``0}},System.Threading.CancellationToken)">
  GetScriptAsync&lt;TDocument&gt;(Id, Action&lt;GetScriptRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L17487"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get a script or search template.
Retrieves a stored script or search template.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/get-stored-script-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;GetScriptResponse&gt; GetScriptAsync&lt;TDocument&gt;(Id id, Action&lt;GetScriptRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.GetScriptRequestDescriptor-1.html">GetScriptRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.GetScriptResponse.html">GetScriptResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetScriptAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetScriptAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetScriptAsync__1_Elastic_Clients_Elasticsearch_Id_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetScriptAsync``1(Elastic.Clients.Elasticsearch.Id,System.Threading.CancellationToken)">
  GetScriptAsync&lt;TDocument&gt;(Id, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L17473"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get a script or search template.
Retrieves a stored script or search template.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/get-stored-script-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;GetScriptResponse&gt; GetScriptAsync&lt;TDocument&gt;(Id id, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.GetScriptResponse.html">GetScriptResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetScriptContext_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetScriptContext*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetScriptContext" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetScriptContext">
  GetScriptContext()
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L17593"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get script contexts.
</p>
<p>
Get a list of supported script contexts and their methods.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/get-script-contexts-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual GetScriptContextResponse GetScriptContext()</code></pre>
  </div>


  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.GetScriptContextResponse.html">GetScriptContextResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetScriptContext_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetScriptContext*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetScriptContext_Elastic_Clients_Elasticsearch_GetScriptContextRequest_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetScriptContext(Elastic.Clients.Elasticsearch.GetScriptContextRequest)">
  GetScriptContext(GetScriptContextRequest)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L17546"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get script contexts.
</p>
<p>
Get a list of supported script contexts and their methods.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/get-script-contexts-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual GetScriptContextResponse GetScriptContext(GetScriptContextRequest request)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.GetScriptContextRequest.html">GetScriptContextRequest</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.GetScriptContextResponse.html">GetScriptContextResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetScriptContext_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetScriptContext*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetScriptContext_Elastic_Clients_Elasticsearch_GetScriptContextRequestDescriptor_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetScriptContext(Elastic.Clients.Elasticsearch.GetScriptContextRequestDescriptor)">
  GetScriptContext(GetScriptContextRequestDescriptor)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L17577"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get script contexts.
</p>
<p>
Get a list of supported script contexts and their methods.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/get-script-contexts-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual GetScriptContextResponse GetScriptContext(GetScriptContextRequestDescriptor descriptor)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.GetScriptContextRequestDescriptor.html">GetScriptContextRequestDescriptor</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.GetScriptContextResponse.html">GetScriptContextResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetScriptContext_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetScriptContext*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetScriptContext_System_Action_Elastic_Clients_Elasticsearch_GetScriptContextRequestDescriptor__" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetScriptContext(System.Action{Elastic.Clients.Elasticsearch.GetScriptContextRequestDescriptor})">
  GetScriptContext(Action&lt;GetScriptContextRequestDescriptor&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L17610"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get script contexts.
</p>
<p>
Get a list of supported script contexts and their methods.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/get-script-contexts-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual GetScriptContextResponse GetScriptContext(Action&lt;GetScriptContextRequestDescriptor&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.GetScriptContextRequestDescriptor.html">GetScriptContextRequestDescriptor</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.GetScriptContextResponse.html">GetScriptContextResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetScriptContextAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetScriptContextAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetScriptContextAsync_Elastic_Clients_Elasticsearch_GetScriptContextRequest_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetScriptContextAsync(Elastic.Clients.Elasticsearch.GetScriptContextRequest,System.Threading.CancellationToken)">
  GetScriptContextAsync(GetScriptContextRequest, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L17562"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get script contexts.
</p>
<p>
Get a list of supported script contexts and their methods.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/get-script-contexts-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;GetScriptContextResponse&gt; GetScriptContextAsync(GetScriptContextRequest request, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.GetScriptContextRequest.html">GetScriptContextRequest</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.GetScriptContextResponse.html">GetScriptContextResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetScriptContextAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetScriptContextAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetScriptContextAsync_Elastic_Clients_Elasticsearch_GetScriptContextRequestDescriptor_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetScriptContextAsync(Elastic.Clients.Elasticsearch.GetScriptContextRequestDescriptor,System.Threading.CancellationToken)">
  GetScriptContextAsync(GetScriptContextRequestDescriptor, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L17628"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get script contexts.
</p>
<p>
Get a list of supported script contexts and their methods.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/get-script-contexts-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;GetScriptContextResponse&gt; GetScriptContextAsync(GetScriptContextRequestDescriptor descriptor, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.GetScriptContextRequestDescriptor.html">GetScriptContextRequestDescriptor</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.GetScriptContextResponse.html">GetScriptContextResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetScriptContextAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetScriptContextAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetScriptContextAsync_System_Action_Elastic_Clients_Elasticsearch_GetScriptContextRequestDescriptor__System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetScriptContextAsync(System.Action{Elastic.Clients.Elasticsearch.GetScriptContextRequestDescriptor},System.Threading.CancellationToken)">
  GetScriptContextAsync(Action&lt;GetScriptContextRequestDescriptor&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L17659"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get script contexts.
</p>
<p>
Get a list of supported script contexts and their methods.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/get-script-contexts-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;GetScriptContextResponse&gt; GetScriptContextAsync(Action&lt;GetScriptContextRequestDescriptor&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.GetScriptContextRequestDescriptor.html">GetScriptContextRequestDescriptor</a>&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.GetScriptContextResponse.html">GetScriptContextResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetScriptContextAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetScriptContextAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetScriptContextAsync_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetScriptContextAsync(System.Threading.CancellationToken)">
  GetScriptContextAsync(CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L17643"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get script contexts.
</p>
<p>
Get a list of supported script contexts and their methods.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/get-script-contexts-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;GetScriptContextResponse&gt; GetScriptContextAsync(CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.GetScriptContextResponse.html">GetScriptContextResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetScriptLanguages_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetScriptLanguages*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetScriptLanguages" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetScriptLanguages">
  GetScriptLanguages()
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L17723"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get script languages.
</p>
<p>
Get a list of available script types, languages, and contexts.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/get-script-languages-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual GetScriptLanguagesResponse GetScriptLanguages()</code></pre>
  </div>


  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.GetScriptLanguagesResponse.html">GetScriptLanguagesResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetScriptLanguages_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetScriptLanguages*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetScriptLanguages_Elastic_Clients_Elasticsearch_GetScriptLanguagesRequest_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetScriptLanguages(Elastic.Clients.Elasticsearch.GetScriptLanguagesRequest)">
  GetScriptLanguages(GetScriptLanguagesRequest)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L17676"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get script languages.
</p>
<p>
Get a list of available script types, languages, and contexts.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/get-script-languages-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual GetScriptLanguagesResponse GetScriptLanguages(GetScriptLanguagesRequest request)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.GetScriptLanguagesRequest.html">GetScriptLanguagesRequest</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.GetScriptLanguagesResponse.html">GetScriptLanguagesResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetScriptLanguages_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetScriptLanguages*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetScriptLanguages_Elastic_Clients_Elasticsearch_GetScriptLanguagesRequestDescriptor_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetScriptLanguages(Elastic.Clients.Elasticsearch.GetScriptLanguagesRequestDescriptor)">
  GetScriptLanguages(GetScriptLanguagesRequestDescriptor)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L17707"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get script languages.
</p>
<p>
Get a list of available script types, languages, and contexts.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/get-script-languages-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual GetScriptLanguagesResponse GetScriptLanguages(GetScriptLanguagesRequestDescriptor descriptor)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.GetScriptLanguagesRequestDescriptor.html">GetScriptLanguagesRequestDescriptor</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.GetScriptLanguagesResponse.html">GetScriptLanguagesResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetScriptLanguages_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetScriptLanguages*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetScriptLanguages_System_Action_Elastic_Clients_Elasticsearch_GetScriptLanguagesRequestDescriptor__" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetScriptLanguages(System.Action{Elastic.Clients.Elasticsearch.GetScriptLanguagesRequestDescriptor})">
  GetScriptLanguages(Action&lt;GetScriptLanguagesRequestDescriptor&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L17740"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get script languages.
</p>
<p>
Get a list of available script types, languages, and contexts.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/get-script-languages-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual GetScriptLanguagesResponse GetScriptLanguages(Action&lt;GetScriptLanguagesRequestDescriptor&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.GetScriptLanguagesRequestDescriptor.html">GetScriptLanguagesRequestDescriptor</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.GetScriptLanguagesResponse.html">GetScriptLanguagesResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetScriptLanguagesAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetScriptLanguagesAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetScriptLanguagesAsync_Elastic_Clients_Elasticsearch_GetScriptLanguagesRequest_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetScriptLanguagesAsync(Elastic.Clients.Elasticsearch.GetScriptLanguagesRequest,System.Threading.CancellationToken)">
  GetScriptLanguagesAsync(GetScriptLanguagesRequest, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L17692"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get script languages.
</p>
<p>
Get a list of available script types, languages, and contexts.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/get-script-languages-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;GetScriptLanguagesResponse&gt; GetScriptLanguagesAsync(GetScriptLanguagesRequest request, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.GetScriptLanguagesRequest.html">GetScriptLanguagesRequest</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.GetScriptLanguagesResponse.html">GetScriptLanguagesResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetScriptLanguagesAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetScriptLanguagesAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetScriptLanguagesAsync_Elastic_Clients_Elasticsearch_GetScriptLanguagesRequestDescriptor_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetScriptLanguagesAsync(Elastic.Clients.Elasticsearch.GetScriptLanguagesRequestDescriptor,System.Threading.CancellationToken)">
  GetScriptLanguagesAsync(GetScriptLanguagesRequestDescriptor, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L17758"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get script languages.
</p>
<p>
Get a list of available script types, languages, and contexts.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/get-script-languages-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;GetScriptLanguagesResponse&gt; GetScriptLanguagesAsync(GetScriptLanguagesRequestDescriptor descriptor, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.GetScriptLanguagesRequestDescriptor.html">GetScriptLanguagesRequestDescriptor</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.GetScriptLanguagesResponse.html">GetScriptLanguagesResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetScriptLanguagesAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetScriptLanguagesAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetScriptLanguagesAsync_System_Action_Elastic_Clients_Elasticsearch_GetScriptLanguagesRequestDescriptor__System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetScriptLanguagesAsync(System.Action{Elastic.Clients.Elasticsearch.GetScriptLanguagesRequestDescriptor},System.Threading.CancellationToken)">
  GetScriptLanguagesAsync(Action&lt;GetScriptLanguagesRequestDescriptor&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L17789"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get script languages.
</p>
<p>
Get a list of available script types, languages, and contexts.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/get-script-languages-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;GetScriptLanguagesResponse&gt; GetScriptLanguagesAsync(Action&lt;GetScriptLanguagesRequestDescriptor&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.GetScriptLanguagesRequestDescriptor.html">GetScriptLanguagesRequestDescriptor</a>&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.GetScriptLanguagesResponse.html">GetScriptLanguagesResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetScriptLanguagesAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetScriptLanguagesAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetScriptLanguagesAsync_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetScriptLanguagesAsync(System.Threading.CancellationToken)">
  GetScriptLanguagesAsync(CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L17773"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get script languages.
</p>
<p>
Get a list of available script types, languages, and contexts.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/get-script-languages-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;GetScriptLanguagesResponse&gt; GetScriptLanguagesAsync(CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.GetScriptLanguagesResponse.html">GetScriptLanguagesResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetScript_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetScript*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetScript__1_Elastic_Clients_Elasticsearch_GetScriptRequestDescriptor___0__" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetScript``1(Elastic.Clients.Elasticsearch.GetScriptRequestDescriptor{``0})">
  GetScript&lt;TDocument&gt;(GetScriptRequestDescriptor&lt;TDocument&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L17370"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get a script or search template.
Retrieves a stored script or search template.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/get-stored-script-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual GetScriptResponse GetScript&lt;TDocument&gt;(GetScriptRequestDescriptor&lt;TDocument&gt; descriptor)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.GetScriptRequestDescriptor-1.html">GetScriptRequestDescriptor</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.GetScriptResponse.html">GetScriptResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetScript_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetScript*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetScript__1_Elastic_Clients_Elasticsearch_Id_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetScript``1(Elastic.Clients.Elasticsearch.Id)">
  GetScript&lt;TDocument&gt;(Id)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L17384"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get a script or search template.
Retrieves a stored script or search template.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/get-stored-script-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual GetScriptResponse GetScript&lt;TDocument&gt;(Id id)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.GetScriptResponse.html">GetScriptResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetScript_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetScript*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetScript__1_Elastic_Clients_Elasticsearch_Id_System_Action_Elastic_Clients_Elasticsearch_GetScriptRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetScript``1(Elastic.Clients.Elasticsearch.Id,System.Action{Elastic.Clients.Elasticsearch.GetScriptRequestDescriptor{``0}})">
  GetScript&lt;TDocument&gt;(Id, Action&lt;GetScriptRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L17399"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get a script or search template.
Retrieves a stored script or search template.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/get-stored-script-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual GetScriptResponse GetScript&lt;TDocument&gt;(Id id, Action&lt;GetScriptRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.GetScriptRequestDescriptor-1.html">GetScriptRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.GetScriptResponse.html">GetScriptResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetSourceAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetSourceAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetSourceAsync__1_Elastic_Clients_Elasticsearch_GetSourceRequest_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetSourceAsync``1(Elastic.Clients.Elasticsearch.GetSourceRequest,System.Threading.CancellationToken)">
  GetSourceAsync&lt;TDocument&gt;(GetSourceRequest, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L17842"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get a document's source.
</p>
<p>
Get the source of a document.
For example:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_source/1</code></pre>
<p>
You can use the source filtering parameters to control which parts of the <code>_source</code> are returned:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_source/1/?_source_includes=*.id&amp;_source_excludes=entities</code></pre>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;GetSourceResponse&lt;TDocument&gt;&gt; GetSourceAsync&lt;TDocument&gt;(GetSourceRequest request, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.GetSourceRequest.html">GetSourceRequest</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.GetSourceResponse-1.html">GetSourceResponse</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetSourceAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetSourceAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetSourceAsync__1_Elastic_Clients_Elasticsearch_GetSourceRequestDescriptor___0__System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetSourceAsync``1(Elastic.Clients.Elasticsearch.GetSourceRequestDescriptor{``0},System.Threading.CancellationToken)">
  GetSourceAsync&lt;TDocument&gt;(GetSourceRequestDescriptor&lt;TDocument&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L18168"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get a document's source.
</p>
<p>
Get the source of a document.
For example:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_source/1</code></pre>
<p>
You can use the source filtering parameters to control which parts of the <code>_source</code> are returned:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_source/1/?_source_includes=*.id&amp;_source_excludes=entities</code></pre>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;GetSourceResponse&lt;TDocument&gt;&gt; GetSourceAsync&lt;TDocument&gt;(GetSourceRequestDescriptor&lt;TDocument&gt; descriptor, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.GetSourceRequestDescriptor-1.html">GetSourceRequestDescriptor</a>&lt;TDocument&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.GetSourceResponse-1.html">GetSourceResponse</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetSourceAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetSourceAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetSourceAsync__1_Elastic_Clients_Elasticsearch_Id_System_Action_Elastic_Clients_Elasticsearch_GetSourceRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetSourceAsync``1(Elastic.Clients.Elasticsearch.Id,System.Action{Elastic.Clients.Elasticsearch.GetSourceRequestDescriptor{``0}},System.Threading.CancellationToken)">
  GetSourceAsync&lt;TDocument&gt;(Id, Action&lt;GetSourceRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L18431"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get a document's source.
</p>
<p>
Get the source of a document.
For example:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_source/1</code></pre>
<p>
You can use the source filtering parameters to control which parts of the <code>_source</code> are returned:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_source/1/?_source_includes=*.id&amp;_source_excludes=entities</code></pre>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;GetSourceResponse&lt;TDocument&gt;&gt; GetSourceAsync&lt;TDocument&gt;(Id id, Action&lt;GetSourceRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.GetSourceRequestDescriptor-1.html">GetSourceRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.GetSourceResponse-1.html">GetSourceResponse</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetSourceAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetSourceAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetSourceAsync__1_Elastic_Clients_Elasticsearch_Id_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetSourceAsync``1(Elastic.Clients.Elasticsearch.Id,System.Threading.CancellationToken)">
  GetSourceAsync&lt;TDocument&gt;(Id, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L18405"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get a document's source.
</p>
<p>
Get the source of a document.
For example:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_source/1</code></pre>
<p>
You can use the source filtering parameters to control which parts of the <code>_source</code> are returned:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_source/1/?_source_includes=*.id&amp;_source_excludes=entities</code></pre>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;GetSourceResponse&lt;TDocument&gt;&gt; GetSourceAsync&lt;TDocument&gt;(Id id, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.GetSourceResponse-1.html">GetSourceResponse</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetSourceAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetSourceAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetSourceAsync__1_Elastic_Clients_Elasticsearch_IndexName_Elastic_Clients_Elasticsearch_Id_System_Action_Elastic_Clients_Elasticsearch_GetSourceRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetSourceAsync``1(Elastic.Clients.Elasticsearch.IndexName,Elastic.Clients.Elasticsearch.Id,System.Action{Elastic.Clients.Elasticsearch.GetSourceRequestDescriptor{``0}},System.Threading.CancellationToken)">
  GetSourceAsync&lt;TDocument&gt;(IndexName, Id, Action&lt;GetSourceRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L18219"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get a document's source.
</p>
<p>
Get the source of a document.
For example:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_source/1</code></pre>
<p>
You can use the source filtering parameters to control which parts of the <code>_source</code> are returned:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_source/1/?_source_includes=*.id&amp;_source_excludes=entities</code></pre>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;GetSourceResponse&lt;TDocument&gt;&gt; GetSourceAsync&lt;TDocument&gt;(IndexName index, Id id, Action&lt;GetSourceRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.GetSourceRequestDescriptor-1.html">GetSourceRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.GetSourceResponse-1.html">GetSourceResponse</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetSourceAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetSourceAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetSourceAsync__1_Elastic_Clients_Elasticsearch_IndexName_Elastic_Clients_Elasticsearch_Id_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetSourceAsync``1(Elastic.Clients.Elasticsearch.IndexName,Elastic.Clients.Elasticsearch.Id,System.Threading.CancellationToken)">
  GetSourceAsync&lt;TDocument&gt;(IndexName, Id, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L18193"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get a document's source.
</p>
<p>
Get the source of a document.
For example:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_source/1</code></pre>
<p>
You can use the source filtering parameters to control which parts of the <code>_source</code> are returned:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_source/1/?_source_includes=*.id&amp;_source_excludes=entities</code></pre>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;GetSourceResponse&lt;TDocument&gt;&gt; GetSourceAsync&lt;TDocument&gt;(IndexName index, Id id, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.GetSourceResponse-1.html">GetSourceResponse</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetSourceAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetSourceAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetSourceAsync__1___0_Elastic_Clients_Elasticsearch_Id_System_Action_Elastic_Clients_Elasticsearch_GetSourceRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetSourceAsync``1(``0,Elastic.Clients.Elasticsearch.Id,System.Action{Elastic.Clients.Elasticsearch.GetSourceRequestDescriptor{``0}},System.Threading.CancellationToken)">
  GetSourceAsync&lt;TDocument&gt;(TDocument, Id, Action&lt;GetSourceRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L18378"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get a document's source.
</p>
<p>
Get the source of a document.
For example:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_source/1</code></pre>
<p>
You can use the source filtering parameters to control which parts of the <code>_source</code> are returned:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_source/1/?_source_includes=*.id&amp;_source_excludes=entities</code></pre>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;GetSourceResponse&lt;TDocument&gt;&gt; GetSourceAsync&lt;TDocument&gt;(TDocument document, Id id, Action&lt;GetSourceRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.GetSourceRequestDescriptor-1.html">GetSourceRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.GetSourceResponse-1.html">GetSourceResponse</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetSourceAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetSourceAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetSourceAsync__1___0_Elastic_Clients_Elasticsearch_Id_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetSourceAsync``1(``0,Elastic.Clients.Elasticsearch.Id,System.Threading.CancellationToken)">
  GetSourceAsync&lt;TDocument&gt;(TDocument, Id, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L18352"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get a document's source.
</p>
<p>
Get the source of a document.
For example:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_source/1</code></pre>
<p>
You can use the source filtering parameters to control which parts of the <code>_source</code> are returned:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_source/1/?_source_includes=*.id&amp;_source_excludes=entities</code></pre>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;GetSourceResponse&lt;TDocument&gt;&gt; GetSourceAsync&lt;TDocument&gt;(TDocument document, Id id, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.GetSourceResponse-1.html">GetSourceResponse</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetSourceAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetSourceAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetSourceAsync__1___0_Elastic_Clients_Elasticsearch_IndexName_System_Action_Elastic_Clients_Elasticsearch_GetSourceRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetSourceAsync``1(``0,Elastic.Clients.Elasticsearch.IndexName,System.Action{Elastic.Clients.Elasticsearch.GetSourceRequestDescriptor{``0}},System.Threading.CancellationToken)">
  GetSourceAsync&lt;TDocument&gt;(TDocument, IndexName, Action&lt;GetSourceRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L18325"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get a document's source.
</p>
<p>
Get the source of a document.
For example:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_source/1</code></pre>
<p>
You can use the source filtering parameters to control which parts of the <code>_source</code> are returned:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_source/1/?_source_includes=*.id&amp;_source_excludes=entities</code></pre>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;GetSourceResponse&lt;TDocument&gt;&gt; GetSourceAsync&lt;TDocument&gt;(TDocument document, IndexName index, Action&lt;GetSourceRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.GetSourceRequestDescriptor-1.html">GetSourceRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.GetSourceResponse-1.html">GetSourceResponse</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetSourceAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetSourceAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetSourceAsync__1___0_Elastic_Clients_Elasticsearch_IndexName_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetSourceAsync``1(``0,Elastic.Clients.Elasticsearch.IndexName,System.Threading.CancellationToken)">
  GetSourceAsync&lt;TDocument&gt;(TDocument, IndexName, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L18299"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get a document's source.
</p>
<p>
Get the source of a document.
For example:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_source/1</code></pre>
<p>
You can use the source filtering parameters to control which parts of the <code>_source</code> are returned:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_source/1/?_source_includes=*.id&amp;_source_excludes=entities</code></pre>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;GetSourceResponse&lt;TDocument&gt;&gt; GetSourceAsync&lt;TDocument&gt;(TDocument document, IndexName index, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.GetSourceResponse-1.html">GetSourceResponse</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetSourceAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetSourceAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetSourceAsync__1___0_System_Action_Elastic_Clients_Elasticsearch_GetSourceRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetSourceAsync``1(``0,System.Action{Elastic.Clients.Elasticsearch.GetSourceRequestDescriptor{``0}},System.Threading.CancellationToken)">
  GetSourceAsync&lt;TDocument&gt;(TDocument, Action&lt;GetSourceRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L18272"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get a document's source.
</p>
<p>
Get the source of a document.
For example:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_source/1</code></pre>
<p>
You can use the source filtering parameters to control which parts of the <code>_source</code> are returned:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_source/1/?_source_includes=*.id&amp;_source_excludes=entities</code></pre>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;GetSourceResponse&lt;TDocument&gt;&gt; GetSourceAsync&lt;TDocument&gt;(TDocument document, Action&lt;GetSourceRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.GetSourceRequestDescriptor-1.html">GetSourceRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.GetSourceResponse-1.html">GetSourceResponse</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetSourceAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetSourceAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetSourceAsync__1___0_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetSourceAsync``1(``0,System.Threading.CancellationToken)">
  GetSourceAsync&lt;TDocument&gt;(TDocument, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L18246"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get a document's source.
</p>
<p>
Get the source of a document.
For example:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_source/1</code></pre>
<p>
You can use the source filtering parameters to control which parts of the <code>_source</code> are returned:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_source/1/?_source_includes=*.id&amp;_source_excludes=entities</code></pre>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;GetSourceResponse&lt;TDocument&gt;&gt; GetSourceAsync&lt;TDocument&gt;(TDocument document, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.GetSourceResponse-1.html">GetSourceResponse</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetSource_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetSource*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetSource__1_Elastic_Clients_Elasticsearch_GetSourceRequest_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetSource``1(Elastic.Clients.Elasticsearch.GetSourceRequest)">
  GetSource&lt;TDocument&gt;(GetSourceRequest)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L17816"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get a document's source.
</p>
<p>
Get the source of a document.
For example:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_source/1</code></pre>
<p>
You can use the source filtering parameters to control which parts of the <code>_source</code> are returned:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_source/1/?_source_includes=*.id&amp;_source_excludes=entities</code></pre>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual GetSourceResponse&lt;TDocument&gt; GetSource&lt;TDocument&gt;(GetSourceRequest request)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.GetSourceRequest.html">GetSourceRequest</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.GetSourceResponse-1.html">GetSourceResponse</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetSource_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetSource*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetSource__1_Elastic_Clients_Elasticsearch_GetSourceRequestDescriptor___0__" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetSource``1(Elastic.Clients.Elasticsearch.GetSourceRequestDescriptor{``0})">
  GetSource&lt;TDocument&gt;(GetSourceRequestDescriptor&lt;TDocument&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L17867"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get a document's source.
</p>
<p>
Get the source of a document.
For example:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_source/1</code></pre>
<p>
You can use the source filtering parameters to control which parts of the <code>_source</code> are returned:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_source/1/?_source_includes=*.id&amp;_source_excludes=entities</code></pre>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual GetSourceResponse&lt;TDocument&gt; GetSource&lt;TDocument&gt;(GetSourceRequestDescriptor&lt;TDocument&gt; descriptor)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.GetSourceRequestDescriptor-1.html">GetSourceRequestDescriptor</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.GetSourceResponse-1.html">GetSourceResponse</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetSource_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetSource*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetSource__1_Elastic_Clients_Elasticsearch_Id_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetSource``1(Elastic.Clients.Elasticsearch.Id)">
  GetSource&lt;TDocument&gt;(Id)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L18113"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get a document's source.
</p>
<p>
Get the source of a document.
For example:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_source/1</code></pre>
<p>
You can use the source filtering parameters to control which parts of the <code>_source</code> are returned:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_source/1/?_source_includes=*.id&amp;_source_excludes=entities</code></pre>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual GetSourceResponse&lt;TDocument&gt; GetSource&lt;TDocument&gt;(Id id)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.GetSourceResponse-1.html">GetSourceResponse</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetSource_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetSource*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetSource__1_Elastic_Clients_Elasticsearch_Id_System_Action_Elastic_Clients_Elasticsearch_GetSourceRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetSource``1(Elastic.Clients.Elasticsearch.Id,System.Action{Elastic.Clients.Elasticsearch.GetSourceRequestDescriptor{``0}})">
  GetSource&lt;TDocument&gt;(Id, Action&lt;GetSourceRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L18140"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get a document's source.
</p>
<p>
Get the source of a document.
For example:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_source/1</code></pre>
<p>
You can use the source filtering parameters to control which parts of the <code>_source</code> are returned:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_source/1/?_source_includes=*.id&amp;_source_excludes=entities</code></pre>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual GetSourceResponse&lt;TDocument&gt; GetSource&lt;TDocument&gt;(Id id, Action&lt;GetSourceRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.GetSourceRequestDescriptor-1.html">GetSourceRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.GetSourceResponse-1.html">GetSourceResponse</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetSource_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetSource*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetSource__1_Elastic_Clients_Elasticsearch_IndexName_Elastic_Clients_Elasticsearch_Id_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetSource``1(Elastic.Clients.Elasticsearch.IndexName,Elastic.Clients.Elasticsearch.Id)">
  GetSource&lt;TDocument&gt;(IndexName, Id)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L17893"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get a document's source.
</p>
<p>
Get the source of a document.
For example:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_source/1</code></pre>
<p>
You can use the source filtering parameters to control which parts of the <code>_source</code> are returned:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_source/1/?_source_includes=*.id&amp;_source_excludes=entities</code></pre>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual GetSourceResponse&lt;TDocument&gt; GetSource&lt;TDocument&gt;(IndexName index, Id id)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.GetSourceResponse-1.html">GetSourceResponse</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetSource_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetSource*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetSource__1_Elastic_Clients_Elasticsearch_IndexName_Elastic_Clients_Elasticsearch_Id_System_Action_Elastic_Clients_Elasticsearch_GetSourceRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetSource``1(Elastic.Clients.Elasticsearch.IndexName,Elastic.Clients.Elasticsearch.Id,System.Action{Elastic.Clients.Elasticsearch.GetSourceRequestDescriptor{``0}})">
  GetSource&lt;TDocument&gt;(IndexName, Id, Action&lt;GetSourceRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L17920"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get a document's source.
</p>
<p>
Get the source of a document.
For example:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_source/1</code></pre>
<p>
You can use the source filtering parameters to control which parts of the <code>_source</code> are returned:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_source/1/?_source_includes=*.id&amp;_source_excludes=entities</code></pre>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual GetSourceResponse&lt;TDocument&gt; GetSource&lt;TDocument&gt;(IndexName index, Id id, Action&lt;GetSourceRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.GetSourceRequestDescriptor-1.html">GetSourceRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.GetSourceResponse-1.html">GetSourceResponse</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetSource_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetSource*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetSource__1___0_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetSource``1(``0)">
  GetSource&lt;TDocument&gt;(TDocument)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L17948"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get a document's source.
</p>
<p>
Get the source of a document.
For example:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_source/1</code></pre>
<p>
You can use the source filtering parameters to control which parts of the <code>_source</code> are returned:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_source/1/?_source_includes=*.id&amp;_source_excludes=entities</code></pre>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual GetSourceResponse&lt;TDocument&gt; GetSource&lt;TDocument&gt;(TDocument document)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.GetSourceResponse-1.html">GetSourceResponse</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetSource_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetSource*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetSource__1___0_Elastic_Clients_Elasticsearch_Id_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetSource``1(``0,Elastic.Clients.Elasticsearch.Id)">
  GetSource&lt;TDocument&gt;(TDocument, Id)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L18058"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get a document's source.
</p>
<p>
Get the source of a document.
For example:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_source/1</code></pre>
<p>
You can use the source filtering parameters to control which parts of the <code>_source</code> are returned:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_source/1/?_source_includes=*.id&amp;_source_excludes=entities</code></pre>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual GetSourceResponse&lt;TDocument&gt; GetSource&lt;TDocument&gt;(TDocument document, Id id)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.GetSourceResponse-1.html">GetSourceResponse</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetSource_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetSource*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetSource__1___0_Elastic_Clients_Elasticsearch_Id_System_Action_Elastic_Clients_Elasticsearch_GetSourceRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetSource``1(``0,Elastic.Clients.Elasticsearch.Id,System.Action{Elastic.Clients.Elasticsearch.GetSourceRequestDescriptor{``0}})">
  GetSource&lt;TDocument&gt;(TDocument, Id, Action&lt;GetSourceRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L18085"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get a document's source.
</p>
<p>
Get the source of a document.
For example:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_source/1</code></pre>
<p>
You can use the source filtering parameters to control which parts of the <code>_source</code> are returned:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_source/1/?_source_includes=*.id&amp;_source_excludes=entities</code></pre>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual GetSourceResponse&lt;TDocument&gt; GetSource&lt;TDocument&gt;(TDocument document, Id id, Action&lt;GetSourceRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.GetSourceRequestDescriptor-1.html">GetSourceRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.GetSourceResponse-1.html">GetSourceResponse</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetSource_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetSource*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetSource__1___0_Elastic_Clients_Elasticsearch_IndexName_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetSource``1(``0,Elastic.Clients.Elasticsearch.IndexName)">
  GetSource&lt;TDocument&gt;(TDocument, IndexName)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L18003"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get a document's source.
</p>
<p>
Get the source of a document.
For example:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_source/1</code></pre>
<p>
You can use the source filtering parameters to control which parts of the <code>_source</code> are returned:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_source/1/?_source_includes=*.id&amp;_source_excludes=entities</code></pre>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual GetSourceResponse&lt;TDocument&gt; GetSource&lt;TDocument&gt;(TDocument document, IndexName index)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.GetSourceResponse-1.html">GetSourceResponse</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetSource_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetSource*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetSource__1___0_Elastic_Clients_Elasticsearch_IndexName_System_Action_Elastic_Clients_Elasticsearch_GetSourceRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetSource``1(``0,Elastic.Clients.Elasticsearch.IndexName,System.Action{Elastic.Clients.Elasticsearch.GetSourceRequestDescriptor{``0}})">
  GetSource&lt;TDocument&gt;(TDocument, IndexName, Action&lt;GetSourceRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L18030"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get a document's source.
</p>
<p>
Get the source of a document.
For example:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_source/1</code></pre>
<p>
You can use the source filtering parameters to control which parts of the <code>_source</code> are returned:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_source/1/?_source_includes=*.id&amp;_source_excludes=entities</code></pre>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual GetSourceResponse&lt;TDocument&gt; GetSource&lt;TDocument&gt;(TDocument document, IndexName index, Action&lt;GetSourceRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.GetSourceRequestDescriptor-1.html">GetSourceRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.GetSourceResponse-1.html">GetSourceResponse</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetSource_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetSource*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_GetSource__1___0_System_Action_Elastic_Clients_Elasticsearch_GetSourceRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.GetSource``1(``0,System.Action{Elastic.Clients.Elasticsearch.GetSourceRequestDescriptor{``0}})">
  GetSource&lt;TDocument&gt;(TDocument, Action&lt;GetSourceRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L17975"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get a document's source.
</p>
<p>
Get the source of a document.
For example:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_source/1</code></pre>
<p>
You can use the source filtering parameters to control which parts of the <code>_source</code> are returned:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_source/1/?_source_includes=*.id&amp;_source_excludes=entities</code></pre>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual GetSourceResponse&lt;TDocument&gt; GetSource&lt;TDocument&gt;(TDocument document, Action&lt;GetSourceRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.GetSourceRequestDescriptor-1.html">GetSourceRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.GetSourceResponse-1.html">GetSourceResponse</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Get_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Get*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Get__1_Elastic_Clients_Elasticsearch_GetRequest_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Get``1(Elastic.Clients.Elasticsearch.GetRequest)">
  Get&lt;TDocument&gt;(GetRequest)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L15471"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get a document by its ID.
</p>
<p>
Get a document and its source or stored fields from an index.
</p>
<p>
By default, this API is realtime and is not affected by the refresh rate of the index (when data will become visible for search).
In the case where stored fields are requested with the <code>stored_fields</code> parameter and the document has been updated but is not yet refreshed, the API will have to parse and analyze the source to extract the stored fields.
To turn off realtime behavior, set the <code>realtime</code> parameter to false.
</p>
<p>
<strong>Source filtering</strong>
</p>
<p>
By default, the API returns the contents of the <code>_source</code> field unless you have used the <code>stored_fields</code> parameter or the <code>_source</code> field is turned off.
You can turn off <code>_source</code> retrieval by using the <code>_source</code> parameter:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/0?_source=false</code></pre>
<p>
If you only need one or two fields from the <code>_source</code>, use the <code>_source_includes</code> or <code>_source_excludes</code> parameters to include or filter out particular fields.
This can be helpful with large documents where partial retrieval can save on network overhead
Both parameters take a comma separated list of fields or wildcard expressions.
For example:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/0?_source_includes=*.id&amp;_source_excludes=entities</code></pre>
<p>
If you only want to specify includes, you can use a shorter notation:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/0?_source=*.id</code></pre>
<p>
<strong>Routing</strong>
</p>
<p>
If routing is used during indexing, the routing value also needs to be specified to retrieve a document.
For example:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/2?routing=user1</code></pre>
<p>
This request gets the document with ID 2, but it is routed based on the user.
The document is not fetched if the correct routing is not specified.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The GET operation is hashed into a specific shard ID.
It is then redirected to one of the replicas within that shard ID and returns the result.
The replicas are the primary shard and its replicas within that shard ID group.
This means that the more replicas you have, the better your GET scaling will be.
</p>
<p>
<strong>Versioning support</strong>
</p>
<p>
You can use the <code>version</code> parameter to retrieve the document only if its current version is equal to the specified one.
</p>
<p>
Internally, Elasticsearch has marked the old document as deleted and added an entirely new document.
The old version of the document doesn't disappear immediately, although you won't be able to access it.
Elasticsearch cleans up deleted documents in the background as you continue to index more data.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual GetResponse&lt;TDocument&gt; Get&lt;TDocument&gt;(GetRequest request)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.GetRequest.html">GetRequest</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.GetResponse-1.html">GetResponse</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Get_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Get*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Get__1_Elastic_Clients_Elasticsearch_GetRequestDescriptor___0__" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Get``1(Elastic.Clients.Elasticsearch.GetRequestDescriptor{``0})">
  Get&lt;TDocument&gt;(GetRequestDescriptor&lt;TDocument&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L15630"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get a document by its ID.
</p>
<p>
Get a document and its source or stored fields from an index.
</p>
<p>
By default, this API is realtime and is not affected by the refresh rate of the index (when data will become visible for search).
In the case where stored fields are requested with the <code>stored_fields</code> parameter and the document has been updated but is not yet refreshed, the API will have to parse and analyze the source to extract the stored fields.
To turn off realtime behavior, set the <code>realtime</code> parameter to false.
</p>
<p>
<strong>Source filtering</strong>
</p>
<p>
By default, the API returns the contents of the <code>_source</code> field unless you have used the <code>stored_fields</code> parameter or the <code>_source</code> field is turned off.
You can turn off <code>_source</code> retrieval by using the <code>_source</code> parameter:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/0?_source=false</code></pre>
<p>
If you only need one or two fields from the <code>_source</code>, use the <code>_source_includes</code> or <code>_source_excludes</code> parameters to include or filter out particular fields.
This can be helpful with large documents where partial retrieval can save on network overhead
Both parameters take a comma separated list of fields or wildcard expressions.
For example:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/0?_source_includes=*.id&amp;_source_excludes=entities</code></pre>
<p>
If you only want to specify includes, you can use a shorter notation:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/0?_source=*.id</code></pre>
<p>
<strong>Routing</strong>
</p>
<p>
If routing is used during indexing, the routing value also needs to be specified to retrieve a document.
For example:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/2?routing=user1</code></pre>
<p>
This request gets the document with ID 2, but it is routed based on the user.
The document is not fetched if the correct routing is not specified.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The GET operation is hashed into a specific shard ID.
It is then redirected to one of the replicas within that shard ID and returns the result.
The replicas are the primary shard and its replicas within that shard ID group.
This means that the more replicas you have, the better your GET scaling will be.
</p>
<p>
<strong>Versioning support</strong>
</p>
<p>
You can use the <code>version</code> parameter to retrieve the document only if its current version is equal to the specified one.
</p>
<p>
Internally, Elasticsearch has marked the old document as deleted and added an entirely new document.
The old version of the document doesn't disappear immediately, although you won't be able to access it.
Elasticsearch cleans up deleted documents in the background as you continue to index more data.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual GetResponse&lt;TDocument&gt; Get&lt;TDocument&gt;(GetRequestDescriptor&lt;TDocument&gt; descriptor)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.GetRequestDescriptor-1.html">GetRequestDescriptor</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.GetResponse-1.html">GetResponse</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Get_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Get*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Get__1_Elastic_Clients_Elasticsearch_Id_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Get``1(Elastic.Clients.Elasticsearch.Id)">
  Get&lt;TDocument&gt;(Id)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L16362"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get a document by its ID.
</p>
<p>
Get a document and its source or stored fields from an index.
</p>
<p>
By default, this API is realtime and is not affected by the refresh rate of the index (when data will become visible for search).
In the case where stored fields are requested with the <code>stored_fields</code> parameter and the document has been updated but is not yet refreshed, the API will have to parse and analyze the source to extract the stored fields.
To turn off realtime behavior, set the <code>realtime</code> parameter to false.
</p>
<p>
<strong>Source filtering</strong>
</p>
<p>
By default, the API returns the contents of the <code>_source</code> field unless you have used the <code>stored_fields</code> parameter or the <code>_source</code> field is turned off.
You can turn off <code>_source</code> retrieval by using the <code>_source</code> parameter:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/0?_source=false</code></pre>
<p>
If you only need one or two fields from the <code>_source</code>, use the <code>_source_includes</code> or <code>_source_excludes</code> parameters to include or filter out particular fields.
This can be helpful with large documents where partial retrieval can save on network overhead
Both parameters take a comma separated list of fields or wildcard expressions.
For example:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/0?_source_includes=*.id&amp;_source_excludes=entities</code></pre>
<p>
If you only want to specify includes, you can use a shorter notation:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/0?_source=*.id</code></pre>
<p>
<strong>Routing</strong>
</p>
<p>
If routing is used during indexing, the routing value also needs to be specified to retrieve a document.
For example:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/2?routing=user1</code></pre>
<p>
This request gets the document with ID 2, but it is routed based on the user.
The document is not fetched if the correct routing is not specified.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The GET operation is hashed into a specific shard ID.
It is then redirected to one of the replicas within that shard ID and returns the result.
The replicas are the primary shard and its replicas within that shard ID group.
This means that the more replicas you have, the better your GET scaling will be.
</p>
<p>
<strong>Versioning support</strong>
</p>
<p>
You can use the <code>version</code> parameter to retrieve the document only if its current version is equal to the specified one.
</p>
<p>
Internally, Elasticsearch has marked the old document as deleted and added an entirely new document.
The old version of the document doesn't disappear immediately, although you won't be able to access it.
Elasticsearch cleans up deleted documents in the background as you continue to index more data.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual GetResponse&lt;TDocument&gt; Get&lt;TDocument&gt;(Id id)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.GetResponse-1.html">GetResponse</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Get_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Get*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Get__1_Elastic_Clients_Elasticsearch_Id_System_Action_Elastic_Clients_Elasticsearch_GetRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Get``1(Elastic.Clients.Elasticsearch.Id,System.Action{Elastic.Clients.Elasticsearch.GetRequestDescriptor{``0}})">
  Get&lt;TDocument&gt;(Id, Action&lt;GetRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L16443"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get a document by its ID.
</p>
<p>
Get a document and its source or stored fields from an index.
</p>
<p>
By default, this API is realtime and is not affected by the refresh rate of the index (when data will become visible for search).
In the case where stored fields are requested with the <code>stored_fields</code> parameter and the document has been updated but is not yet refreshed, the API will have to parse and analyze the source to extract the stored fields.
To turn off realtime behavior, set the <code>realtime</code> parameter to false.
</p>
<p>
<strong>Source filtering</strong>
</p>
<p>
By default, the API returns the contents of the <code>_source</code> field unless you have used the <code>stored_fields</code> parameter or the <code>_source</code> field is turned off.
You can turn off <code>_source</code> retrieval by using the <code>_source</code> parameter:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/0?_source=false</code></pre>
<p>
If you only need one or two fields from the <code>_source</code>, use the <code>_source_includes</code> or <code>_source_excludes</code> parameters to include or filter out particular fields.
This can be helpful with large documents where partial retrieval can save on network overhead
Both parameters take a comma separated list of fields or wildcard expressions.
For example:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/0?_source_includes=*.id&amp;_source_excludes=entities</code></pre>
<p>
If you only want to specify includes, you can use a shorter notation:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/0?_source=*.id</code></pre>
<p>
<strong>Routing</strong>
</p>
<p>
If routing is used during indexing, the routing value also needs to be specified to retrieve a document.
For example:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/2?routing=user1</code></pre>
<p>
This request gets the document with ID 2, but it is routed based on the user.
The document is not fetched if the correct routing is not specified.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The GET operation is hashed into a specific shard ID.
It is then redirected to one of the replicas within that shard ID and returns the result.
The replicas are the primary shard and its replicas within that shard ID group.
This means that the more replicas you have, the better your GET scaling will be.
</p>
<p>
<strong>Versioning support</strong>
</p>
<p>
You can use the <code>version</code> parameter to retrieve the document only if its current version is equal to the specified one.
</p>
<p>
Internally, Elasticsearch has marked the old document as deleted and added an entirely new document.
The old version of the document doesn't disappear immediately, although you won't be able to access it.
Elasticsearch cleans up deleted documents in the background as you continue to index more data.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual GetResponse&lt;TDocument&gt; Get&lt;TDocument&gt;(Id id, Action&lt;GetRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.GetRequestDescriptor-1.html">GetRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.GetResponse-1.html">GetResponse</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Get_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Get*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Get__1_Elastic_Clients_Elasticsearch_IndexName_Elastic_Clients_Elasticsearch_Id_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Get``1(Elastic.Clients.Elasticsearch.IndexName,Elastic.Clients.Elasticsearch.Id)">
  Get&lt;TDocument&gt;(IndexName, Id)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L15710"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get a document by its ID.
</p>
<p>
Get a document and its source or stored fields from an index.
</p>
<p>
By default, this API is realtime and is not affected by the refresh rate of the index (when data will become visible for search).
In the case where stored fields are requested with the <code>stored_fields</code> parameter and the document has been updated but is not yet refreshed, the API will have to parse and analyze the source to extract the stored fields.
To turn off realtime behavior, set the <code>realtime</code> parameter to false.
</p>
<p>
<strong>Source filtering</strong>
</p>
<p>
By default, the API returns the contents of the <code>_source</code> field unless you have used the <code>stored_fields</code> parameter or the <code>_source</code> field is turned off.
You can turn off <code>_source</code> retrieval by using the <code>_source</code> parameter:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/0?_source=false</code></pre>
<p>
If you only need one or two fields from the <code>_source</code>, use the <code>_source_includes</code> or <code>_source_excludes</code> parameters to include or filter out particular fields.
This can be helpful with large documents where partial retrieval can save on network overhead
Both parameters take a comma separated list of fields or wildcard expressions.
For example:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/0?_source_includes=*.id&amp;_source_excludes=entities</code></pre>
<p>
If you only want to specify includes, you can use a shorter notation:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/0?_source=*.id</code></pre>
<p>
<strong>Routing</strong>
</p>
<p>
If routing is used during indexing, the routing value also needs to be specified to retrieve a document.
For example:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/2?routing=user1</code></pre>
<p>
This request gets the document with ID 2, but it is routed based on the user.
The document is not fetched if the correct routing is not specified.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The GET operation is hashed into a specific shard ID.
It is then redirected to one of the replicas within that shard ID and returns the result.
The replicas are the primary shard and its replicas within that shard ID group.
This means that the more replicas you have, the better your GET scaling will be.
</p>
<p>
<strong>Versioning support</strong>
</p>
<p>
You can use the <code>version</code> parameter to retrieve the document only if its current version is equal to the specified one.
</p>
<p>
Internally, Elasticsearch has marked the old document as deleted and added an entirely new document.
The old version of the document doesn't disappear immediately, although you won't be able to access it.
Elasticsearch cleans up deleted documents in the background as you continue to index more data.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual GetResponse&lt;TDocument&gt; Get&lt;TDocument&gt;(IndexName index, Id id)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.GetResponse-1.html">GetResponse</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Get_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Get*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Get__1_Elastic_Clients_Elasticsearch_IndexName_Elastic_Clients_Elasticsearch_Id_System_Action_Elastic_Clients_Elasticsearch_GetRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Get``1(Elastic.Clients.Elasticsearch.IndexName,Elastic.Clients.Elasticsearch.Id,System.Action{Elastic.Clients.Elasticsearch.GetRequestDescriptor{``0}})">
  Get&lt;TDocument&gt;(IndexName, Id, Action&lt;GetRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L15791"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get a document by its ID.
</p>
<p>
Get a document and its source or stored fields from an index.
</p>
<p>
By default, this API is realtime and is not affected by the refresh rate of the index (when data will become visible for search).
In the case where stored fields are requested with the <code>stored_fields</code> parameter and the document has been updated but is not yet refreshed, the API will have to parse and analyze the source to extract the stored fields.
To turn off realtime behavior, set the <code>realtime</code> parameter to false.
</p>
<p>
<strong>Source filtering</strong>
</p>
<p>
By default, the API returns the contents of the <code>_source</code> field unless you have used the <code>stored_fields</code> parameter or the <code>_source</code> field is turned off.
You can turn off <code>_source</code> retrieval by using the <code>_source</code> parameter:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/0?_source=false</code></pre>
<p>
If you only need one or two fields from the <code>_source</code>, use the <code>_source_includes</code> or <code>_source_excludes</code> parameters to include or filter out particular fields.
This can be helpful with large documents where partial retrieval can save on network overhead
Both parameters take a comma separated list of fields or wildcard expressions.
For example:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/0?_source_includes=*.id&amp;_source_excludes=entities</code></pre>
<p>
If you only want to specify includes, you can use a shorter notation:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/0?_source=*.id</code></pre>
<p>
<strong>Routing</strong>
</p>
<p>
If routing is used during indexing, the routing value also needs to be specified to retrieve a document.
For example:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/2?routing=user1</code></pre>
<p>
This request gets the document with ID 2, but it is routed based on the user.
The document is not fetched if the correct routing is not specified.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The GET operation is hashed into a specific shard ID.
It is then redirected to one of the replicas within that shard ID and returns the result.
The replicas are the primary shard and its replicas within that shard ID group.
This means that the more replicas you have, the better your GET scaling will be.
</p>
<p>
<strong>Versioning support</strong>
</p>
<p>
You can use the <code>version</code> parameter to retrieve the document only if its current version is equal to the specified one.
</p>
<p>
Internally, Elasticsearch has marked the old document as deleted and added an entirely new document.
The old version of the document doesn't disappear immediately, although you won't be able to access it.
Elasticsearch cleans up deleted documents in the background as you continue to index more data.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual GetResponse&lt;TDocument&gt; Get&lt;TDocument&gt;(IndexName index, Id id, Action&lt;GetRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.GetRequestDescriptor-1.html">GetRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.GetResponse-1.html">GetResponse</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Get_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Get*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Get__1___0_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Get``1(``0)">
  Get&lt;TDocument&gt;(TDocument)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L15873"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get a document by its ID.
</p>
<p>
Get a document and its source or stored fields from an index.
</p>
<p>
By default, this API is realtime and is not affected by the refresh rate of the index (when data will become visible for search).
In the case where stored fields are requested with the <code>stored_fields</code> parameter and the document has been updated but is not yet refreshed, the API will have to parse and analyze the source to extract the stored fields.
To turn off realtime behavior, set the <code>realtime</code> parameter to false.
</p>
<p>
<strong>Source filtering</strong>
</p>
<p>
By default, the API returns the contents of the <code>_source</code> field unless you have used the <code>stored_fields</code> parameter or the <code>_source</code> field is turned off.
You can turn off <code>_source</code> retrieval by using the <code>_source</code> parameter:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/0?_source=false</code></pre>
<p>
If you only need one or two fields from the <code>_source</code>, use the <code>_source_includes</code> or <code>_source_excludes</code> parameters to include or filter out particular fields.
This can be helpful with large documents where partial retrieval can save on network overhead
Both parameters take a comma separated list of fields or wildcard expressions.
For example:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/0?_source_includes=*.id&amp;_source_excludes=entities</code></pre>
<p>
If you only want to specify includes, you can use a shorter notation:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/0?_source=*.id</code></pre>
<p>
<strong>Routing</strong>
</p>
<p>
If routing is used during indexing, the routing value also needs to be specified to retrieve a document.
For example:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/2?routing=user1</code></pre>
<p>
This request gets the document with ID 2, but it is routed based on the user.
The document is not fetched if the correct routing is not specified.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The GET operation is hashed into a specific shard ID.
It is then redirected to one of the replicas within that shard ID and returns the result.
The replicas are the primary shard and its replicas within that shard ID group.
This means that the more replicas you have, the better your GET scaling will be.
</p>
<p>
<strong>Versioning support</strong>
</p>
<p>
You can use the <code>version</code> parameter to retrieve the document only if its current version is equal to the specified one.
</p>
<p>
Internally, Elasticsearch has marked the old document as deleted and added an entirely new document.
The old version of the document doesn't disappear immediately, although you won't be able to access it.
Elasticsearch cleans up deleted documents in the background as you continue to index more data.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual GetResponse&lt;TDocument&gt; Get&lt;TDocument&gt;(TDocument document)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.GetResponse-1.html">GetResponse</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Get_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Get*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Get__1___0_Elastic_Clients_Elasticsearch_Id_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Get``1(``0,Elastic.Clients.Elasticsearch.Id)">
  Get&lt;TDocument&gt;(TDocument, Id)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L16199"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get a document by its ID.
</p>
<p>
Get a document and its source or stored fields from an index.
</p>
<p>
By default, this API is realtime and is not affected by the refresh rate of the index (when data will become visible for search).
In the case where stored fields are requested with the <code>stored_fields</code> parameter and the document has been updated but is not yet refreshed, the API will have to parse and analyze the source to extract the stored fields.
To turn off realtime behavior, set the <code>realtime</code> parameter to false.
</p>
<p>
<strong>Source filtering</strong>
</p>
<p>
By default, the API returns the contents of the <code>_source</code> field unless you have used the <code>stored_fields</code> parameter or the <code>_source</code> field is turned off.
You can turn off <code>_source</code> retrieval by using the <code>_source</code> parameter:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/0?_source=false</code></pre>
<p>
If you only need one or two fields from the <code>_source</code>, use the <code>_source_includes</code> or <code>_source_excludes</code> parameters to include or filter out particular fields.
This can be helpful with large documents where partial retrieval can save on network overhead
Both parameters take a comma separated list of fields or wildcard expressions.
For example:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/0?_source_includes=*.id&amp;_source_excludes=entities</code></pre>
<p>
If you only want to specify includes, you can use a shorter notation:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/0?_source=*.id</code></pre>
<p>
<strong>Routing</strong>
</p>
<p>
If routing is used during indexing, the routing value also needs to be specified to retrieve a document.
For example:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/2?routing=user1</code></pre>
<p>
This request gets the document with ID 2, but it is routed based on the user.
The document is not fetched if the correct routing is not specified.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The GET operation is hashed into a specific shard ID.
It is then redirected to one of the replicas within that shard ID and returns the result.
The replicas are the primary shard and its replicas within that shard ID group.
This means that the more replicas you have, the better your GET scaling will be.
</p>
<p>
<strong>Versioning support</strong>
</p>
<p>
You can use the <code>version</code> parameter to retrieve the document only if its current version is equal to the specified one.
</p>
<p>
Internally, Elasticsearch has marked the old document as deleted and added an entirely new document.
The old version of the document doesn't disappear immediately, although you won't be able to access it.
Elasticsearch cleans up deleted documents in the background as you continue to index more data.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual GetResponse&lt;TDocument&gt; Get&lt;TDocument&gt;(TDocument document, Id id)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.GetResponse-1.html">GetResponse</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Get_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Get*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Get__1___0_Elastic_Clients_Elasticsearch_Id_System_Action_Elastic_Clients_Elasticsearch_GetRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Get``1(``0,Elastic.Clients.Elasticsearch.Id,System.Action{Elastic.Clients.Elasticsearch.GetRequestDescriptor{``0}})">
  Get&lt;TDocument&gt;(TDocument, Id, Action&lt;GetRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L16280"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get a document by its ID.
</p>
<p>
Get a document and its source or stored fields from an index.
</p>
<p>
By default, this API is realtime and is not affected by the refresh rate of the index (when data will become visible for search).
In the case where stored fields are requested with the <code>stored_fields</code> parameter and the document has been updated but is not yet refreshed, the API will have to parse and analyze the source to extract the stored fields.
To turn off realtime behavior, set the <code>realtime</code> parameter to false.
</p>
<p>
<strong>Source filtering</strong>
</p>
<p>
By default, the API returns the contents of the <code>_source</code> field unless you have used the <code>stored_fields</code> parameter or the <code>_source</code> field is turned off.
You can turn off <code>_source</code> retrieval by using the <code>_source</code> parameter:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/0?_source=false</code></pre>
<p>
If you only need one or two fields from the <code>_source</code>, use the <code>_source_includes</code> or <code>_source_excludes</code> parameters to include or filter out particular fields.
This can be helpful with large documents where partial retrieval can save on network overhead
Both parameters take a comma separated list of fields or wildcard expressions.
For example:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/0?_source_includes=*.id&amp;_source_excludes=entities</code></pre>
<p>
If you only want to specify includes, you can use a shorter notation:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/0?_source=*.id</code></pre>
<p>
<strong>Routing</strong>
</p>
<p>
If routing is used during indexing, the routing value also needs to be specified to retrieve a document.
For example:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/2?routing=user1</code></pre>
<p>
This request gets the document with ID 2, but it is routed based on the user.
The document is not fetched if the correct routing is not specified.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The GET operation is hashed into a specific shard ID.
It is then redirected to one of the replicas within that shard ID and returns the result.
The replicas are the primary shard and its replicas within that shard ID group.
This means that the more replicas you have, the better your GET scaling will be.
</p>
<p>
<strong>Versioning support</strong>
</p>
<p>
You can use the <code>version</code> parameter to retrieve the document only if its current version is equal to the specified one.
</p>
<p>
Internally, Elasticsearch has marked the old document as deleted and added an entirely new document.
The old version of the document doesn't disappear immediately, although you won't be able to access it.
Elasticsearch cleans up deleted documents in the background as you continue to index more data.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual GetResponse&lt;TDocument&gt; Get&lt;TDocument&gt;(TDocument document, Id id, Action&lt;GetRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.GetRequestDescriptor-1.html">GetRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.GetResponse-1.html">GetResponse</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Get_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Get*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Get__1___0_Elastic_Clients_Elasticsearch_IndexName_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Get``1(``0,Elastic.Clients.Elasticsearch.IndexName)">
  Get&lt;TDocument&gt;(TDocument, IndexName)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L16036"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get a document by its ID.
</p>
<p>
Get a document and its source or stored fields from an index.
</p>
<p>
By default, this API is realtime and is not affected by the refresh rate of the index (when data will become visible for search).
In the case where stored fields are requested with the <code>stored_fields</code> parameter and the document has been updated but is not yet refreshed, the API will have to parse and analyze the source to extract the stored fields.
To turn off realtime behavior, set the <code>realtime</code> parameter to false.
</p>
<p>
<strong>Source filtering</strong>
</p>
<p>
By default, the API returns the contents of the <code>_source</code> field unless you have used the <code>stored_fields</code> parameter or the <code>_source</code> field is turned off.
You can turn off <code>_source</code> retrieval by using the <code>_source</code> parameter:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/0?_source=false</code></pre>
<p>
If you only need one or two fields from the <code>_source</code>, use the <code>_source_includes</code> or <code>_source_excludes</code> parameters to include or filter out particular fields.
This can be helpful with large documents where partial retrieval can save on network overhead
Both parameters take a comma separated list of fields or wildcard expressions.
For example:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/0?_source_includes=*.id&amp;_source_excludes=entities</code></pre>
<p>
If you only want to specify includes, you can use a shorter notation:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/0?_source=*.id</code></pre>
<p>
<strong>Routing</strong>
</p>
<p>
If routing is used during indexing, the routing value also needs to be specified to retrieve a document.
For example:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/2?routing=user1</code></pre>
<p>
This request gets the document with ID 2, but it is routed based on the user.
The document is not fetched if the correct routing is not specified.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The GET operation is hashed into a specific shard ID.
It is then redirected to one of the replicas within that shard ID and returns the result.
The replicas are the primary shard and its replicas within that shard ID group.
This means that the more replicas you have, the better your GET scaling will be.
</p>
<p>
<strong>Versioning support</strong>
</p>
<p>
You can use the <code>version</code> parameter to retrieve the document only if its current version is equal to the specified one.
</p>
<p>
Internally, Elasticsearch has marked the old document as deleted and added an entirely new document.
The old version of the document doesn't disappear immediately, although you won't be able to access it.
Elasticsearch cleans up deleted documents in the background as you continue to index more data.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual GetResponse&lt;TDocument&gt; Get&lt;TDocument&gt;(TDocument document, IndexName index)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.GetResponse-1.html">GetResponse</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Get_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Get*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Get__1___0_Elastic_Clients_Elasticsearch_IndexName_System_Action_Elastic_Clients_Elasticsearch_GetRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Get``1(``0,Elastic.Clients.Elasticsearch.IndexName,System.Action{Elastic.Clients.Elasticsearch.GetRequestDescriptor{``0}})">
  Get&lt;TDocument&gt;(TDocument, IndexName, Action&lt;GetRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L16117"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get a document by its ID.
</p>
<p>
Get a document and its source or stored fields from an index.
</p>
<p>
By default, this API is realtime and is not affected by the refresh rate of the index (when data will become visible for search).
In the case where stored fields are requested with the <code>stored_fields</code> parameter and the document has been updated but is not yet refreshed, the API will have to parse and analyze the source to extract the stored fields.
To turn off realtime behavior, set the <code>realtime</code> parameter to false.
</p>
<p>
<strong>Source filtering</strong>
</p>
<p>
By default, the API returns the contents of the <code>_source</code> field unless you have used the <code>stored_fields</code> parameter or the <code>_source</code> field is turned off.
You can turn off <code>_source</code> retrieval by using the <code>_source</code> parameter:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/0?_source=false</code></pre>
<p>
If you only need one or two fields from the <code>_source</code>, use the <code>_source_includes</code> or <code>_source_excludes</code> parameters to include or filter out particular fields.
This can be helpful with large documents where partial retrieval can save on network overhead
Both parameters take a comma separated list of fields or wildcard expressions.
For example:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/0?_source_includes=*.id&amp;_source_excludes=entities</code></pre>
<p>
If you only want to specify includes, you can use a shorter notation:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/0?_source=*.id</code></pre>
<p>
<strong>Routing</strong>
</p>
<p>
If routing is used during indexing, the routing value also needs to be specified to retrieve a document.
For example:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/2?routing=user1</code></pre>
<p>
This request gets the document with ID 2, but it is routed based on the user.
The document is not fetched if the correct routing is not specified.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The GET operation is hashed into a specific shard ID.
It is then redirected to one of the replicas within that shard ID and returns the result.
The replicas are the primary shard and its replicas within that shard ID group.
This means that the more replicas you have, the better your GET scaling will be.
</p>
<p>
<strong>Versioning support</strong>
</p>
<p>
You can use the <code>version</code> parameter to retrieve the document only if its current version is equal to the specified one.
</p>
<p>
Internally, Elasticsearch has marked the old document as deleted and added an entirely new document.
The old version of the document doesn't disappear immediately, although you won't be able to access it.
Elasticsearch cleans up deleted documents in the background as you continue to index more data.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual GetResponse&lt;TDocument&gt; Get&lt;TDocument&gt;(TDocument document, IndexName index, Action&lt;GetRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.GetRequestDescriptor-1.html">GetRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.GetResponse-1.html">GetResponse</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Get_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Get*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Get__1___0_System_Action_Elastic_Clients_Elasticsearch_GetRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Get``1(``0,System.Action{Elastic.Clients.Elasticsearch.GetRequestDescriptor{``0}})">
  Get&lt;TDocument&gt;(TDocument, Action&lt;GetRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L15954"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get a document by its ID.
</p>
<p>
Get a document and its source or stored fields from an index.
</p>
<p>
By default, this API is realtime and is not affected by the refresh rate of the index (when data will become visible for search).
In the case where stored fields are requested with the <code>stored_fields</code> parameter and the document has been updated but is not yet refreshed, the API will have to parse and analyze the source to extract the stored fields.
To turn off realtime behavior, set the <code>realtime</code> parameter to false.
</p>
<p>
<strong>Source filtering</strong>
</p>
<p>
By default, the API returns the contents of the <code>_source</code> field unless you have used the <code>stored_fields</code> parameter or the <code>_source</code> field is turned off.
You can turn off <code>_source</code> retrieval by using the <code>_source</code> parameter:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/0?_source=false</code></pre>
<p>
If you only need one or two fields from the <code>_source</code>, use the <code>_source_includes</code> or <code>_source_excludes</code> parameters to include or filter out particular fields.
This can be helpful with large documents where partial retrieval can save on network overhead
Both parameters take a comma separated list of fields or wildcard expressions.
For example:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/0?_source_includes=*.id&amp;_source_excludes=entities</code></pre>
<p>
If you only want to specify includes, you can use a shorter notation:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/0?_source=*.id</code></pre>
<p>
<strong>Routing</strong>
</p>
<p>
If routing is used during indexing, the routing value also needs to be specified to retrieve a document.
For example:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/2?routing=user1</code></pre>
<p>
This request gets the document with ID 2, but it is routed based on the user.
The document is not fetched if the correct routing is not specified.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The GET operation is hashed into a specific shard ID.
It is then redirected to one of the replicas within that shard ID and returns the result.
The replicas are the primary shard and its replicas within that shard ID group.
This means that the more replicas you have, the better your GET scaling will be.
</p>
<p>
<strong>Versioning support</strong>
</p>
<p>
You can use the <code>version</code> parameter to retrieve the document only if its current version is equal to the specified one.
</p>
<p>
Internally, Elasticsearch has marked the old document as deleted and added an entirely new document.
The old version of the document doesn't disappear immediately, although you won't be able to access it.
Elasticsearch cleans up deleted documents in the background as you continue to index more data.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual GetResponse&lt;TDocument&gt; Get&lt;TDocument&gt;(TDocument document, Action&lt;GetRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.GetRequestDescriptor-1.html">GetRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.GetResponse-1.html">GetResponse</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_HealthReport_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.HealthReport*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_HealthReport" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.HealthReport">
  HealthReport()
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L18644"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get the cluster health.
Get a report with the health status of an Elasticsearch cluster.
The report contains a list of indicators that compose Elasticsearch functionality.
</p>
<p>
Each indicator has a health status of: green, unknown, yellow or red.
The indicator will provide an explanation and metadata describing the reason for its current health status.
</p>
<p>
The cluster’s status is controlled by the worst indicator status.
</p>
<p>
In the event that an indicator’s status is non-green, a list of impacts may be present in the indicator result which detail the functionalities that are negatively affected by the health issue.
Each impact carries with it a severity level, an area of the system that is affected, and a simple description of the impact on the system.
</p>
<p>
Some health indicators can determine the root cause of a health problem and prescribe a set of steps that can be performed in order to improve the health of the system.
The root cause and remediation steps are encapsulated in a diagnosis.
A diagnosis contains a cause detailing a root cause analysis, an action containing a brief description of the steps to take to fix the problem, the list of affected resources (if applicable), and a detailed step-by-step troubleshooting guide to fix the diagnosed problem.
</p>
<p>
NOTE: The health indicators perform root cause analysis of non-green health statuses. This can be computationally expensive when called frequently.
When setting up automated polling of the API for health status, set verbose to false to disable the more expensive analysis logic.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/health-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual HealthReportResponse HealthReport()</code></pre>
  </div>


  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.HealthReportResponse.html">HealthReportResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_HealthReport_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.HealthReport*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_HealthReport_Elastic_Clients_Elasticsearch_HealthReportRequest_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.HealthReport(Elastic.Clients.Elasticsearch.HealthReportRequest)">
  HealthReport(HealthReportRequest)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L18467"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get the cluster health.
Get a report with the health status of an Elasticsearch cluster.
The report contains a list of indicators that compose Elasticsearch functionality.
</p>
<p>
Each indicator has a health status of: green, unknown, yellow or red.
The indicator will provide an explanation and metadata describing the reason for its current health status.
</p>
<p>
The cluster’s status is controlled by the worst indicator status.
</p>
<p>
In the event that an indicator’s status is non-green, a list of impacts may be present in the indicator result which detail the functionalities that are negatively affected by the health issue.
Each impact carries with it a severity level, an area of the system that is affected, and a simple description of the impact on the system.
</p>
<p>
Some health indicators can determine the root cause of a health problem and prescribe a set of steps that can be performed in order to improve the health of the system.
The root cause and remediation steps are encapsulated in a diagnosis.
A diagnosis contains a cause detailing a root cause analysis, an action containing a brief description of the steps to take to fix the problem, the list of affected resources (if applicable), and a detailed step-by-step troubleshooting guide to fix the diagnosed problem.
</p>
<p>
NOTE: The health indicators perform root cause analysis of non-green health statuses. This can be computationally expensive when called frequently.
When setting up automated polling of the API for health status, set verbose to false to disable the more expensive analysis logic.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/health-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual HealthReportResponse HealthReport(HealthReportRequest request)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.HealthReportRequest.html">HealthReportRequest</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.HealthReportResponse.html">HealthReportResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_HealthReport_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.HealthReport*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_HealthReport_Elastic_Clients_Elasticsearch_HealthReportRequestDescriptor_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.HealthReport(Elastic.Clients.Elasticsearch.HealthReportRequestDescriptor)">
  HealthReport(HealthReportRequestDescriptor)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L18536"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get the cluster health.
Get a report with the health status of an Elasticsearch cluster.
The report contains a list of indicators that compose Elasticsearch functionality.
</p>
<p>
Each indicator has a health status of: green, unknown, yellow or red.
The indicator will provide an explanation and metadata describing the reason for its current health status.
</p>
<p>
The cluster’s status is controlled by the worst indicator status.
</p>
<p>
In the event that an indicator’s status is non-green, a list of impacts may be present in the indicator result which detail the functionalities that are negatively affected by the health issue.
Each impact carries with it a severity level, an area of the system that is affected, and a simple description of the impact on the system.
</p>
<p>
Some health indicators can determine the root cause of a health problem and prescribe a set of steps that can be performed in order to improve the health of the system.
The root cause and remediation steps are encapsulated in a diagnosis.
A diagnosis contains a cause detailing a root cause analysis, an action containing a brief description of the steps to take to fix the problem, the list of affected resources (if applicable), and a detailed step-by-step troubleshooting guide to fix the diagnosed problem.
</p>
<p>
NOTE: The health indicators perform root cause analysis of non-green health statuses. This can be computationally expensive when called frequently.
When setting up automated polling of the API for health status, set verbose to false to disable the more expensive analysis logic.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/health-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual HealthReportResponse HealthReport(HealthReportRequestDescriptor descriptor)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.HealthReportRequestDescriptor.html">HealthReportRequestDescriptor</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.HealthReportResponse.html">HealthReportResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_HealthReport_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.HealthReport*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_HealthReport_System_Action_Elastic_Clients_Elasticsearch_HealthReportRequestDescriptor__" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.HealthReport(System.Action{Elastic.Clients.Elasticsearch.HealthReportRequestDescriptor})">
  HealthReport(Action&lt;HealthReportRequestDescriptor&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L18680"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get the cluster health.
Get a report with the health status of an Elasticsearch cluster.
The report contains a list of indicators that compose Elasticsearch functionality.
</p>
<p>
Each indicator has a health status of: green, unknown, yellow or red.
The indicator will provide an explanation and metadata describing the reason for its current health status.
</p>
<p>
The cluster’s status is controlled by the worst indicator status.
</p>
<p>
In the event that an indicator’s status is non-green, a list of impacts may be present in the indicator result which detail the functionalities that are negatively affected by the health issue.
Each impact carries with it a severity level, an area of the system that is affected, and a simple description of the impact on the system.
</p>
<p>
Some health indicators can determine the root cause of a health problem and prescribe a set of steps that can be performed in order to improve the health of the system.
The root cause and remediation steps are encapsulated in a diagnosis.
A diagnosis contains a cause detailing a root cause analysis, an action containing a brief description of the steps to take to fix the problem, the list of affected resources (if applicable), and a detailed step-by-step troubleshooting guide to fix the diagnosed problem.
</p>
<p>
NOTE: The health indicators perform root cause analysis of non-green health statuses. This can be computationally expensive when called frequently.
When setting up automated polling of the API for health status, set verbose to false to disable the more expensive analysis logic.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/health-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual HealthReportResponse HealthReport(Action&lt;HealthReportRequestDescriptor&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.HealthReportRequestDescriptor.html">HealthReportRequestDescriptor</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.HealthReportResponse.html">HealthReportResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_HealthReport_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.HealthReport*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_HealthReport_System_Collections_Generic_IReadOnlyCollection_System_String__" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.HealthReport(System.Collections.Generic.IReadOnlyCollection{System.String})">
  HealthReport(IReadOnlyCollection&lt;string&gt;?)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L18571"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get the cluster health.
Get a report with the health status of an Elasticsearch cluster.
The report contains a list of indicators that compose Elasticsearch functionality.
</p>
<p>
Each indicator has a health status of: green, unknown, yellow or red.
The indicator will provide an explanation and metadata describing the reason for its current health status.
</p>
<p>
The cluster’s status is controlled by the worst indicator status.
</p>
<p>
In the event that an indicator’s status is non-green, a list of impacts may be present in the indicator result which detail the functionalities that are negatively affected by the health issue.
Each impact carries with it a severity level, an area of the system that is affected, and a simple description of the impact on the system.
</p>
<p>
Some health indicators can determine the root cause of a health problem and prescribe a set of steps that can be performed in order to improve the health of the system.
The root cause and remediation steps are encapsulated in a diagnosis.
A diagnosis contains a cause detailing a root cause analysis, an action containing a brief description of the steps to take to fix the problem, the list of affected resources (if applicable), and a detailed step-by-step troubleshooting guide to fix the diagnosed problem.
</p>
<p>
NOTE: The health indicators perform root cause analysis of non-green health statuses. This can be computationally expensive when called frequently.
When setting up automated polling of the API for health status, set verbose to false to disable the more expensive analysis logic.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/health-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual HealthReportResponse HealthReport(IReadOnlyCollection&lt;string&gt;? feature)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>feature</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.collections.generic.ireadonlycollection-1">IReadOnlyCollection</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.HealthReportResponse.html">HealthReportResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_HealthReport_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.HealthReport*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_HealthReport_System_Collections_Generic_IReadOnlyCollection_System_String__System_Action_Elastic_Clients_Elasticsearch_HealthReportRequestDescriptor__" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.HealthReport(System.Collections.Generic.IReadOnlyCollection{System.String},System.Action{Elastic.Clients.Elasticsearch.HealthReportRequestDescriptor})">
  HealthReport(IReadOnlyCollection&lt;string&gt;?, Action&lt;HealthReportRequestDescriptor&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L18607"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get the cluster health.
Get a report with the health status of an Elasticsearch cluster.
The report contains a list of indicators that compose Elasticsearch functionality.
</p>
<p>
Each indicator has a health status of: green, unknown, yellow or red.
The indicator will provide an explanation and metadata describing the reason for its current health status.
</p>
<p>
The cluster’s status is controlled by the worst indicator status.
</p>
<p>
In the event that an indicator’s status is non-green, a list of impacts may be present in the indicator result which detail the functionalities that are negatively affected by the health issue.
Each impact carries with it a severity level, an area of the system that is affected, and a simple description of the impact on the system.
</p>
<p>
Some health indicators can determine the root cause of a health problem and prescribe a set of steps that can be performed in order to improve the health of the system.
The root cause and remediation steps are encapsulated in a diagnosis.
A diagnosis contains a cause detailing a root cause analysis, an action containing a brief description of the steps to take to fix the problem, the list of affected resources (if applicable), and a detailed step-by-step troubleshooting guide to fix the diagnosed problem.
</p>
<p>
NOTE: The health indicators perform root cause analysis of non-green health statuses. This can be computationally expensive when called frequently.
When setting up automated polling of the API for health status, set verbose to false to disable the more expensive analysis logic.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/health-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual HealthReportResponse HealthReport(IReadOnlyCollection&lt;string&gt;? feature, Action&lt;HealthReportRequestDescriptor&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>feature</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.collections.generic.ireadonlycollection-1">IReadOnlyCollection</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a>&gt;</dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.HealthReportRequestDescriptor.html">HealthReportRequestDescriptor</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.HealthReportResponse.html">HealthReportResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_HealthReportAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.HealthReportAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_HealthReportAsync_Elastic_Clients_Elasticsearch_HealthReportRequest_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.HealthReportAsync(Elastic.Clients.Elasticsearch.HealthReportRequest,System.Threading.CancellationToken)">
  HealthReportAsync(HealthReportRequest, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L18502"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get the cluster health.
Get a report with the health status of an Elasticsearch cluster.
The report contains a list of indicators that compose Elasticsearch functionality.
</p>
<p>
Each indicator has a health status of: green, unknown, yellow or red.
The indicator will provide an explanation and metadata describing the reason for its current health status.
</p>
<p>
The cluster’s status is controlled by the worst indicator status.
</p>
<p>
In the event that an indicator’s status is non-green, a list of impacts may be present in the indicator result which detail the functionalities that are negatively affected by the health issue.
Each impact carries with it a severity level, an area of the system that is affected, and a simple description of the impact on the system.
</p>
<p>
Some health indicators can determine the root cause of a health problem and prescribe a set of steps that can be performed in order to improve the health of the system.
The root cause and remediation steps are encapsulated in a diagnosis.
A diagnosis contains a cause detailing a root cause analysis, an action containing a brief description of the steps to take to fix the problem, the list of affected resources (if applicable), and a detailed step-by-step troubleshooting guide to fix the diagnosed problem.
</p>
<p>
NOTE: The health indicators perform root cause analysis of non-green health statuses. This can be computationally expensive when called frequently.
When setting up automated polling of the API for health status, set verbose to false to disable the more expensive analysis logic.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/health-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;HealthReportResponse&gt; HealthReportAsync(HealthReportRequest request, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.HealthReportRequest.html">HealthReportRequest</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.HealthReportResponse.html">HealthReportResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_HealthReportAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.HealthReportAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_HealthReportAsync_Elastic_Clients_Elasticsearch_HealthReportRequestDescriptor_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.HealthReportAsync(Elastic.Clients.Elasticsearch.HealthReportRequestDescriptor,System.Threading.CancellationToken)">
  HealthReportAsync(HealthReportRequestDescriptor, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L18717"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get the cluster health.
Get a report with the health status of an Elasticsearch cluster.
The report contains a list of indicators that compose Elasticsearch functionality.
</p>
<p>
Each indicator has a health status of: green, unknown, yellow or red.
The indicator will provide an explanation and metadata describing the reason for its current health status.
</p>
<p>
The cluster’s status is controlled by the worst indicator status.
</p>
<p>
In the event that an indicator’s status is non-green, a list of impacts may be present in the indicator result which detail the functionalities that are negatively affected by the health issue.
Each impact carries with it a severity level, an area of the system that is affected, and a simple description of the impact on the system.
</p>
<p>
Some health indicators can determine the root cause of a health problem and prescribe a set of steps that can be performed in order to improve the health of the system.
The root cause and remediation steps are encapsulated in a diagnosis.
A diagnosis contains a cause detailing a root cause analysis, an action containing a brief description of the steps to take to fix the problem, the list of affected resources (if applicable), and a detailed step-by-step troubleshooting guide to fix the diagnosed problem.
</p>
<p>
NOTE: The health indicators perform root cause analysis of non-green health statuses. This can be computationally expensive when called frequently.
When setting up automated polling of the API for health status, set verbose to false to disable the more expensive analysis logic.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/health-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;HealthReportResponse&gt; HealthReportAsync(HealthReportRequestDescriptor descriptor, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.HealthReportRequestDescriptor.html">HealthReportRequestDescriptor</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.HealthReportResponse.html">HealthReportResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_HealthReportAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.HealthReportAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_HealthReportAsync_System_Action_Elastic_Clients_Elasticsearch_HealthReportRequestDescriptor__System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.HealthReportAsync(System.Action{Elastic.Clients.Elasticsearch.HealthReportRequestDescriptor},System.Threading.CancellationToken)">
  HealthReportAsync(Action&lt;HealthReportRequestDescriptor&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L18857"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get the cluster health.
Get a report with the health status of an Elasticsearch cluster.
The report contains a list of indicators that compose Elasticsearch functionality.
</p>
<p>
Each indicator has a health status of: green, unknown, yellow or red.
The indicator will provide an explanation and metadata describing the reason for its current health status.
</p>
<p>
The cluster’s status is controlled by the worst indicator status.
</p>
<p>
In the event that an indicator’s status is non-green, a list of impacts may be present in the indicator result which detail the functionalities that are negatively affected by the health issue.
Each impact carries with it a severity level, an area of the system that is affected, and a simple description of the impact on the system.
</p>
<p>
Some health indicators can determine the root cause of a health problem and prescribe a set of steps that can be performed in order to improve the health of the system.
The root cause and remediation steps are encapsulated in a diagnosis.
A diagnosis contains a cause detailing a root cause analysis, an action containing a brief description of the steps to take to fix the problem, the list of affected resources (if applicable), and a detailed step-by-step troubleshooting guide to fix the diagnosed problem.
</p>
<p>
NOTE: The health indicators perform root cause analysis of non-green health statuses. This can be computationally expensive when called frequently.
When setting up automated polling of the API for health status, set verbose to false to disable the more expensive analysis logic.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/health-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;HealthReportResponse&gt; HealthReportAsync(Action&lt;HealthReportRequestDescriptor&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.HealthReportRequestDescriptor.html">HealthReportRequestDescriptor</a>&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.HealthReportResponse.html">HealthReportResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_HealthReportAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.HealthReportAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_HealthReportAsync_System_Collections_Generic_IReadOnlyCollection_System_String__System_Action_Elastic_Clients_Elasticsearch_HealthReportRequestDescriptor__System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.HealthReportAsync(System.Collections.Generic.IReadOnlyCollection{System.String},System.Action{Elastic.Clients.Elasticsearch.HealthReportRequestDescriptor},System.Threading.CancellationToken)">
  HealthReportAsync(IReadOnlyCollection&lt;string&gt;?, Action&lt;HealthReportRequestDescriptor&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L18786"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get the cluster health.
Get a report with the health status of an Elasticsearch cluster.
The report contains a list of indicators that compose Elasticsearch functionality.
</p>
<p>
Each indicator has a health status of: green, unknown, yellow or red.
The indicator will provide an explanation and metadata describing the reason for its current health status.
</p>
<p>
The cluster’s status is controlled by the worst indicator status.
</p>
<p>
In the event that an indicator’s status is non-green, a list of impacts may be present in the indicator result which detail the functionalities that are negatively affected by the health issue.
Each impact carries with it a severity level, an area of the system that is affected, and a simple description of the impact on the system.
</p>
<p>
Some health indicators can determine the root cause of a health problem and prescribe a set of steps that can be performed in order to improve the health of the system.
The root cause and remediation steps are encapsulated in a diagnosis.
A diagnosis contains a cause detailing a root cause analysis, an action containing a brief description of the steps to take to fix the problem, the list of affected resources (if applicable), and a detailed step-by-step troubleshooting guide to fix the diagnosed problem.
</p>
<p>
NOTE: The health indicators perform root cause analysis of non-green health statuses. This can be computationally expensive when called frequently.
When setting up automated polling of the API for health status, set verbose to false to disable the more expensive analysis logic.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/health-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;HealthReportResponse&gt; HealthReportAsync(IReadOnlyCollection&lt;string&gt;? feature, Action&lt;HealthReportRequestDescriptor&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>feature</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.collections.generic.ireadonlycollection-1">IReadOnlyCollection</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a>&gt;</dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.HealthReportRequestDescriptor.html">HealthReportRequestDescriptor</a>&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.HealthReportResponse.html">HealthReportResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_HealthReportAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.HealthReportAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_HealthReportAsync_System_Collections_Generic_IReadOnlyCollection_System_String__System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.HealthReportAsync(System.Collections.Generic.IReadOnlyCollection{System.String},System.Threading.CancellationToken)">
  HealthReportAsync(IReadOnlyCollection&lt;string&gt;?, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L18751"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get the cluster health.
Get a report with the health status of an Elasticsearch cluster.
The report contains a list of indicators that compose Elasticsearch functionality.
</p>
<p>
Each indicator has a health status of: green, unknown, yellow or red.
The indicator will provide an explanation and metadata describing the reason for its current health status.
</p>
<p>
The cluster’s status is controlled by the worst indicator status.
</p>
<p>
In the event that an indicator’s status is non-green, a list of impacts may be present in the indicator result which detail the functionalities that are negatively affected by the health issue.
Each impact carries with it a severity level, an area of the system that is affected, and a simple description of the impact on the system.
</p>
<p>
Some health indicators can determine the root cause of a health problem and prescribe a set of steps that can be performed in order to improve the health of the system.
The root cause and remediation steps are encapsulated in a diagnosis.
A diagnosis contains a cause detailing a root cause analysis, an action containing a brief description of the steps to take to fix the problem, the list of affected resources (if applicable), and a detailed step-by-step troubleshooting guide to fix the diagnosed problem.
</p>
<p>
NOTE: The health indicators perform root cause analysis of non-green health statuses. This can be computationally expensive when called frequently.
When setting up automated polling of the API for health status, set verbose to false to disable the more expensive analysis logic.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/health-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;HealthReportResponse&gt; HealthReportAsync(IReadOnlyCollection&lt;string&gt;? feature, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>feature</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.collections.generic.ireadonlycollection-1">IReadOnlyCollection</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a>&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.HealthReportResponse.html">HealthReportResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_HealthReportAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.HealthReportAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_HealthReportAsync_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.HealthReportAsync(System.Threading.CancellationToken)">
  HealthReportAsync(CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L18822"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get the cluster health.
Get a report with the health status of an Elasticsearch cluster.
The report contains a list of indicators that compose Elasticsearch functionality.
</p>
<p>
Each indicator has a health status of: green, unknown, yellow or red.
The indicator will provide an explanation and metadata describing the reason for its current health status.
</p>
<p>
The cluster’s status is controlled by the worst indicator status.
</p>
<p>
In the event that an indicator’s status is non-green, a list of impacts may be present in the indicator result which detail the functionalities that are negatively affected by the health issue.
Each impact carries with it a severity level, an area of the system that is affected, and a simple description of the impact on the system.
</p>
<p>
Some health indicators can determine the root cause of a health problem and prescribe a set of steps that can be performed in order to improve the health of the system.
The root cause and remediation steps are encapsulated in a diagnosis.
A diagnosis contains a cause detailing a root cause analysis, an action containing a brief description of the steps to take to fix the problem, the list of affected resources (if applicable), and a detailed step-by-step troubleshooting guide to fix the diagnosed problem.
</p>
<p>
NOTE: The health indicators perform root cause analysis of non-green health statuses. This can be computationally expensive when called frequently.
When setting up automated polling of the API for health status, set verbose to false to disable the more expensive analysis logic.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/health-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;HealthReportResponse&gt; HealthReportAsync(CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.HealthReportResponse.html">HealthReportResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_IndexAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.IndexAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_IndexAsync__1_Elastic_Clients_Elasticsearch_IndexRequestDescriptor___0__System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.IndexAsync``1(Elastic.Clients.Elasticsearch.IndexRequestDescriptor{``0},System.Threading.CancellationToken)">
  IndexAsync&lt;TDocument&gt;(IndexRequestDescriptor&lt;TDocument&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L20981"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Create or update a document in an index.
</p>
<p>
Add a JSON document to the specified data stream or index and make it searchable.
If the target is an index and the document already exists, the request updates the document and increments its version.
</p>
<p>
NOTE: You cannot use this API to send update requests for existing documents in a data stream.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or index alias:
</p>
<ul><li>
<p>
To add or overwrite a document using the <code>PUT /&lt;target&gt;/_doc/&lt;_id&gt;</code> request format, you must have the <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To add a document using the <code>POST /&lt;target&gt;/_doc/</code> request format, you must have the <code>create_doc</code>, <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To automatically create a data stream or index with this API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege.
</p>
</li></ul>
<p>
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
NOTE: Replica shards might not all be started when an indexing operation returns successfully.
By default, only the primary is required. Set <code>wait_for_active_shards</code> to change this default behavior.
</p>
<p>
<strong>Automatically create data streams and indices</strong>
</p>
<p>
If the request's target doesn't exist and matches an index template with a <code>data_stream</code> definition, the index operation automatically creates the data stream.
</p>
<p>
If the target doesn't exist and doesn't match a data stream template, the operation automatically creates the index and applies any matching index templates.
</p>
<p>
NOTE: Elasticsearch includes several built-in index templates. To avoid naming collisions with these templates, refer to index pattern documentation.
</p>
<p>
If no mapping exists, the index operation creates a dynamic mapping.
By default, new fields and objects are automatically added to the mapping if needed.
</p>
<p>
Automatic index creation is controlled by the <code>action.auto_create_index</code> setting.
If it is <code>true</code>, any index can be created automatically.
You can modify this setting to explicitly allow or block automatic creation of indices that match specified patterns or set it to <code>false</code> to turn off automatic index creation entirely.
Specify a comma-separated list of patterns you want to allow or prefix each pattern with <code>+</code> or <code>-</code> to indicate whether it should be allowed or blocked.
When a list is specified, the default behaviour is to disallow.
</p>
<p>
NOTE: The <code>action.auto_create_index</code> setting affects the automatic creation of indices only.
It does not affect the creation of data streams.
</p>
<p>
<strong>Optimistic concurrency control</strong>
</p>
<p>
Index operations can be made conditional and only be performed if the last modification to the document was assigned the sequence number and primary term specified by the <code>if_seq_no</code> and <code>if_primary_term</code> parameters.
If a mismatch is detected, the operation will result in a <code>VersionConflictException</code> and a status code of <code>409</code>.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
By default, shard placement — or routing — is controlled by using a hash of the document's ID value.
For more explicit control, the value fed into the hash function used by the router can be directly specified on a per-operation basis using the <code>routing</code> parameter.
</p>
<p>
When setting up explicit mapping, you can also use the <code>_routing</code> field to direct the index operation to extract the routing value from the document itself.
This does come at the (very minimal) cost of an additional document parsing pass.
If the <code>_routing</code> mapping is defined and set to be required, the index operation will fail if no routing value is provided or extracted.
</p>
<p>
NOTE: Data streams do not support custom routing unless they were created with the <code>allow_custom_routing</code> setting enabled in the template.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The index operation is directed to the primary shard based on its route and performed on the actual node containing this shard.
After the primary shard completes the operation, if needed, the update is distributed to applicable replicas.
</p>
<p>
<strong>Active shards</strong>
</p>
<p>
To improve the resiliency of writes to the system, indexing operations can be configured to wait for a certain number of active shard copies before proceeding with the operation.
If the requisite number of active shard copies are not available, then the write operation must wait and retry, until either the requisite shard copies have started or a timeout occurs.
By default, write operations only wait for the primary shards to be active before proceeding (that is to say <code>wait_for_active_shards</code> is <code>1</code>).
This default can be overridden in the index settings dynamically by setting <code>index.write.wait_for_active_shards</code>.
To alter this behavior per operation, use the <code>wait_for_active_shards request</code> parameter.
</p>
<p>
Valid values are all or any positive integer up to the total number of configured copies per shard in the index (which is <code>number_of_replicas</code>+1).
Specifying a negative value or a number greater than the number of shard copies will throw an error.
</p>
<p>
For example, suppose you have a cluster of three nodes, A, B, and C and you create an index index with the number of replicas set to 3 (resulting in 4 shard copies, one more copy than there are nodes).
If you attempt an indexing operation, by default the operation will only ensure the primary copy of each shard is available before proceeding.
This means that even if B and C went down and A hosted the primary shard copies, the indexing operation would still proceed with only one copy of the data.
If <code>wait_for_active_shards</code> is set on the request to <code>3</code> (and all three nodes are up), the indexing operation will require 3 active shard copies before proceeding.
This requirement should be met because there are 3 active nodes in the cluster, each one holding a copy of the shard.
However, if you set <code>wait_for_active_shards</code> to <code>all</code> (or to <code>4</code>, which is the same in this situation), the indexing operation will not proceed as you do not have all 4 copies of each shard active in the index.
The operation will timeout unless a new node is brought up in the cluster to host the fourth copy of the shard.
</p>
<p>
It is important to note that this setting greatly reduces the chances of the write operation not writing to the requisite number of shard copies, but it does not completely eliminate the possibility, because this check occurs before the write operation starts.
After the write operation is underway, it is still possible for replication to fail on any number of shard copies but still succeed on the primary.
The <code>_shards</code> section of the API response reveals the number of shard copies on which replication succeeded and failed.
</p>
<p>
<strong>No operation (noop) updates</strong>
</p>
<p>
When updating a document by using this API, a new version of the document is always created even if the document hasn't changed.
If this isn't acceptable use the <code>_update</code> API with <code>detect_noop</code> set to <code>true</code>.
The <code>detect_noop</code> option isn't available on this API because it doesn’t fetch the old source and isn't able to compare it against the new source.
</p>
<p>
There isn't a definitive rule for when noop updates aren't acceptable.
It's a combination of lots of factors like how frequently your data source sends updates that are actually noops and how many queries per second Elasticsearch runs on the shard receiving the updates.
</p>
<p>
<strong>Versioning</strong>
</p>
<p>
Each indexed document is given a version number.
By default, internal versioning is used that starts at 1 and increments with each update, deletes included.
Optionally, the version number can be set to an external value (for example, if maintained in a database).
To enable this functionality, <code>version_type</code> should be set to <code>external</code>.
The value provided must be a numeric, long value greater than or equal to 0, and less than around <code>9.2e+18</code>.
</p>
<p>
NOTE: Versioning is completely real time, and is not affected by the near real time aspects of search operations.
If no version is provided, the operation runs without any version checks.
</p>
<p>
When using the external version type, the system checks to see if the version number passed to the index request is greater than the version of the currently stored document.
If true, the document will be indexed and the new version number used.
If the value provided is less than or equal to the stored document's version number, a version conflict will occur and the index operation will fail. For example:
</p>
<pre><code class="lang-csharp">PUT my-index-000001/_doc/1?version=2&amp;version_type=external
{
  "user": {
    "id": "elkbee"
  }
}

In this example, the operation will succeed since the supplied version of 2 is higher than the current document version of 1.
If the document was already updated and its version was set to 2 or higher, the indexing command will fail and result in a conflict (409 HTTP status code).

A nice side effect is that there is no need to maintain strict ordering of async indexing operations run as a result of changes to a source database, as long as version numbers from the source database are used.
Even the simple case of updating the Elasticsearch index using data from a database is simplified if external versioning is used, as only the latest version will be used if the index operations arrive out of order.</code></pre>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-index_.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;IndexResponse&gt; IndexAsync&lt;TDocument&gt;(IndexRequestDescriptor&lt;TDocument&gt; descriptor, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexRequestDescriptor-1.html">IndexRequestDescriptor</a>&lt;TDocument&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.IndexResponse.html">IndexResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_IndexAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.IndexAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_IndexAsync__1_Elastic_Clients_Elasticsearch_IndexRequest___0__System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.IndexAsync``1(Elastic.Clients.Elasticsearch.IndexRequest{``0},System.Threading.CancellationToken)">
  IndexAsync&lt;TDocument&gt;(IndexRequest&lt;TDocument&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L19210"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Create or update a document in an index.
</p>
<p>
Add a JSON document to the specified data stream or index and make it searchable.
If the target is an index and the document already exists, the request updates the document and increments its version.
</p>
<p>
NOTE: You cannot use this API to send update requests for existing documents in a data stream.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or index alias:
</p>
<ul><li>
<p>
To add or overwrite a document using the <code>PUT /&lt;target&gt;/_doc/&lt;_id&gt;</code> request format, you must have the <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To add a document using the <code>POST /&lt;target&gt;/_doc/</code> request format, you must have the <code>create_doc</code>, <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To automatically create a data stream or index with this API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege.
</p>
</li></ul>
<p>
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
NOTE: Replica shards might not all be started when an indexing operation returns successfully.
By default, only the primary is required. Set <code>wait_for_active_shards</code> to change this default behavior.
</p>
<p>
<strong>Automatically create data streams and indices</strong>
</p>
<p>
If the request's target doesn't exist and matches an index template with a <code>data_stream</code> definition, the index operation automatically creates the data stream.
</p>
<p>
If the target doesn't exist and doesn't match a data stream template, the operation automatically creates the index and applies any matching index templates.
</p>
<p>
NOTE: Elasticsearch includes several built-in index templates. To avoid naming collisions with these templates, refer to index pattern documentation.
</p>
<p>
If no mapping exists, the index operation creates a dynamic mapping.
By default, new fields and objects are automatically added to the mapping if needed.
</p>
<p>
Automatic index creation is controlled by the <code>action.auto_create_index</code> setting.
If it is <code>true</code>, any index can be created automatically.
You can modify this setting to explicitly allow or block automatic creation of indices that match specified patterns or set it to <code>false</code> to turn off automatic index creation entirely.
Specify a comma-separated list of patterns you want to allow or prefix each pattern with <code>+</code> or <code>-</code> to indicate whether it should be allowed or blocked.
When a list is specified, the default behaviour is to disallow.
</p>
<p>
NOTE: The <code>action.auto_create_index</code> setting affects the automatic creation of indices only.
It does not affect the creation of data streams.
</p>
<p>
<strong>Optimistic concurrency control</strong>
</p>
<p>
Index operations can be made conditional and only be performed if the last modification to the document was assigned the sequence number and primary term specified by the <code>if_seq_no</code> and <code>if_primary_term</code> parameters.
If a mismatch is detected, the operation will result in a <code>VersionConflictException</code> and a status code of <code>409</code>.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
By default, shard placement — or routing — is controlled by using a hash of the document's ID value.
For more explicit control, the value fed into the hash function used by the router can be directly specified on a per-operation basis using the <code>routing</code> parameter.
</p>
<p>
When setting up explicit mapping, you can also use the <code>_routing</code> field to direct the index operation to extract the routing value from the document itself.
This does come at the (very minimal) cost of an additional document parsing pass.
If the <code>_routing</code> mapping is defined and set to be required, the index operation will fail if no routing value is provided or extracted.
</p>
<p>
NOTE: Data streams do not support custom routing unless they were created with the <code>allow_custom_routing</code> setting enabled in the template.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The index operation is directed to the primary shard based on its route and performed on the actual node containing this shard.
After the primary shard completes the operation, if needed, the update is distributed to applicable replicas.
</p>
<p>
<strong>Active shards</strong>
</p>
<p>
To improve the resiliency of writes to the system, indexing operations can be configured to wait for a certain number of active shard copies before proceeding with the operation.
If the requisite number of active shard copies are not available, then the write operation must wait and retry, until either the requisite shard copies have started or a timeout occurs.
By default, write operations only wait for the primary shards to be active before proceeding (that is to say <code>wait_for_active_shards</code> is <code>1</code>).
This default can be overridden in the index settings dynamically by setting <code>index.write.wait_for_active_shards</code>.
To alter this behavior per operation, use the <code>wait_for_active_shards request</code> parameter.
</p>
<p>
Valid values are all or any positive integer up to the total number of configured copies per shard in the index (which is <code>number_of_replicas</code>+1).
Specifying a negative value or a number greater than the number of shard copies will throw an error.
</p>
<p>
For example, suppose you have a cluster of three nodes, A, B, and C and you create an index index with the number of replicas set to 3 (resulting in 4 shard copies, one more copy than there are nodes).
If you attempt an indexing operation, by default the operation will only ensure the primary copy of each shard is available before proceeding.
This means that even if B and C went down and A hosted the primary shard copies, the indexing operation would still proceed with only one copy of the data.
If <code>wait_for_active_shards</code> is set on the request to <code>3</code> (and all three nodes are up), the indexing operation will require 3 active shard copies before proceeding.
This requirement should be met because there are 3 active nodes in the cluster, each one holding a copy of the shard.
However, if you set <code>wait_for_active_shards</code> to <code>all</code> (or to <code>4</code>, which is the same in this situation), the indexing operation will not proceed as you do not have all 4 copies of each shard active in the index.
The operation will timeout unless a new node is brought up in the cluster to host the fourth copy of the shard.
</p>
<p>
It is important to note that this setting greatly reduces the chances of the write operation not writing to the requisite number of shard copies, but it does not completely eliminate the possibility, because this check occurs before the write operation starts.
After the write operation is underway, it is still possible for replication to fail on any number of shard copies but still succeed on the primary.
The <code>_shards</code> section of the API response reveals the number of shard copies on which replication succeeded and failed.
</p>
<p>
<strong>No operation (noop) updates</strong>
</p>
<p>
When updating a document by using this API, a new version of the document is always created even if the document hasn't changed.
If this isn't acceptable use the <code>_update</code> API with <code>detect_noop</code> set to <code>true</code>.
The <code>detect_noop</code> option isn't available on this API because it doesn’t fetch the old source and isn't able to compare it against the new source.
</p>
<p>
There isn't a definitive rule for when noop updates aren't acceptable.
It's a combination of lots of factors like how frequently your data source sends updates that are actually noops and how many queries per second Elasticsearch runs on the shard receiving the updates.
</p>
<p>
<strong>Versioning</strong>
</p>
<p>
Each indexed document is given a version number.
By default, internal versioning is used that starts at 1 and increments with each update, deletes included.
Optionally, the version number can be set to an external value (for example, if maintained in a database).
To enable this functionality, <code>version_type</code> should be set to <code>external</code>.
The value provided must be a numeric, long value greater than or equal to 0, and less than around <code>9.2e+18</code>.
</p>
<p>
NOTE: Versioning is completely real time, and is not affected by the near real time aspects of search operations.
If no version is provided, the operation runs without any version checks.
</p>
<p>
When using the external version type, the system checks to see if the version number passed to the index request is greater than the version of the currently stored document.
If true, the document will be indexed and the new version number used.
If the value provided is less than or equal to the stored document's version number, a version conflict will occur and the index operation will fail. For example:
</p>
<pre><code class="lang-csharp">PUT my-index-000001/_doc/1?version=2&amp;version_type=external
{
  "user": {
    "id": "elkbee"
  }
}

In this example, the operation will succeed since the supplied version of 2 is higher than the current document version of 1.
If the document was already updated and its version was set to 2 or higher, the indexing command will fail and result in a conflict (409 HTTP status code).

A nice side effect is that there is no need to maintain strict ordering of async indexing operations run as a result of changes to a source database, as long as version numbers from the source database are used.
Even the simple case of updating the Elasticsearch index using data from a database is simplified if external versioning is used, as only the latest version will be used if the index operations arrive out of order.</code></pre>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-index_.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;IndexResponse&gt; IndexAsync&lt;TDocument&gt;(IndexRequest&lt;TDocument&gt; request, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexRequest-1.html">IndexRequest</a>&lt;TDocument&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.IndexResponse.html">IndexResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_IndexAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.IndexAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_IndexAsync__1___0_Elastic_Clients_Elasticsearch_Id_System_Action_Elastic_Clients_Elasticsearch_IndexRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.IndexAsync``1(``0,Elastic.Clients.Elasticsearch.Id,System.Action{Elastic.Clients.Elasticsearch.IndexRequestDescriptor{``0}},System.Threading.CancellationToken)">
  IndexAsync&lt;TDocument&gt;(TDocument, Id?, Action&lt;IndexRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L22391"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Create or update a document in an index.
</p>
<p>
Add a JSON document to the specified data stream or index and make it searchable.
If the target is an index and the document already exists, the request updates the document and increments its version.
</p>
<p>
NOTE: You cannot use this API to send update requests for existing documents in a data stream.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or index alias:
</p>
<ul><li>
<p>
To add or overwrite a document using the <code>PUT /&lt;target&gt;/_doc/&lt;_id&gt;</code> request format, you must have the <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To add a document using the <code>POST /&lt;target&gt;/_doc/</code> request format, you must have the <code>create_doc</code>, <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To automatically create a data stream or index with this API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege.
</p>
</li></ul>
<p>
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
NOTE: Replica shards might not all be started when an indexing operation returns successfully.
By default, only the primary is required. Set <code>wait_for_active_shards</code> to change this default behavior.
</p>
<p>
<strong>Automatically create data streams and indices</strong>
</p>
<p>
If the request's target doesn't exist and matches an index template with a <code>data_stream</code> definition, the index operation automatically creates the data stream.
</p>
<p>
If the target doesn't exist and doesn't match a data stream template, the operation automatically creates the index and applies any matching index templates.
</p>
<p>
NOTE: Elasticsearch includes several built-in index templates. To avoid naming collisions with these templates, refer to index pattern documentation.
</p>
<p>
If no mapping exists, the index operation creates a dynamic mapping.
By default, new fields and objects are automatically added to the mapping if needed.
</p>
<p>
Automatic index creation is controlled by the <code>action.auto_create_index</code> setting.
If it is <code>true</code>, any index can be created automatically.
You can modify this setting to explicitly allow or block automatic creation of indices that match specified patterns or set it to <code>false</code> to turn off automatic index creation entirely.
Specify a comma-separated list of patterns you want to allow or prefix each pattern with <code>+</code> or <code>-</code> to indicate whether it should be allowed or blocked.
When a list is specified, the default behaviour is to disallow.
</p>
<p>
NOTE: The <code>action.auto_create_index</code> setting affects the automatic creation of indices only.
It does not affect the creation of data streams.
</p>
<p>
<strong>Optimistic concurrency control</strong>
</p>
<p>
Index operations can be made conditional and only be performed if the last modification to the document was assigned the sequence number and primary term specified by the <code>if_seq_no</code> and <code>if_primary_term</code> parameters.
If a mismatch is detected, the operation will result in a <code>VersionConflictException</code> and a status code of <code>409</code>.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
By default, shard placement — or routing — is controlled by using a hash of the document's ID value.
For more explicit control, the value fed into the hash function used by the router can be directly specified on a per-operation basis using the <code>routing</code> parameter.
</p>
<p>
When setting up explicit mapping, you can also use the <code>_routing</code> field to direct the index operation to extract the routing value from the document itself.
This does come at the (very minimal) cost of an additional document parsing pass.
If the <code>_routing</code> mapping is defined and set to be required, the index operation will fail if no routing value is provided or extracted.
</p>
<p>
NOTE: Data streams do not support custom routing unless they were created with the <code>allow_custom_routing</code> setting enabled in the template.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The index operation is directed to the primary shard based on its route and performed on the actual node containing this shard.
After the primary shard completes the operation, if needed, the update is distributed to applicable replicas.
</p>
<p>
<strong>Active shards</strong>
</p>
<p>
To improve the resiliency of writes to the system, indexing operations can be configured to wait for a certain number of active shard copies before proceeding with the operation.
If the requisite number of active shard copies are not available, then the write operation must wait and retry, until either the requisite shard copies have started or a timeout occurs.
By default, write operations only wait for the primary shards to be active before proceeding (that is to say <code>wait_for_active_shards</code> is <code>1</code>).
This default can be overridden in the index settings dynamically by setting <code>index.write.wait_for_active_shards</code>.
To alter this behavior per operation, use the <code>wait_for_active_shards request</code> parameter.
</p>
<p>
Valid values are all or any positive integer up to the total number of configured copies per shard in the index (which is <code>number_of_replicas</code>+1).
Specifying a negative value or a number greater than the number of shard copies will throw an error.
</p>
<p>
For example, suppose you have a cluster of three nodes, A, B, and C and you create an index index with the number of replicas set to 3 (resulting in 4 shard copies, one more copy than there are nodes).
If you attempt an indexing operation, by default the operation will only ensure the primary copy of each shard is available before proceeding.
This means that even if B and C went down and A hosted the primary shard copies, the indexing operation would still proceed with only one copy of the data.
If <code>wait_for_active_shards</code> is set on the request to <code>3</code> (and all three nodes are up), the indexing operation will require 3 active shard copies before proceeding.
This requirement should be met because there are 3 active nodes in the cluster, each one holding a copy of the shard.
However, if you set <code>wait_for_active_shards</code> to <code>all</code> (or to <code>4</code>, which is the same in this situation), the indexing operation will not proceed as you do not have all 4 copies of each shard active in the index.
The operation will timeout unless a new node is brought up in the cluster to host the fourth copy of the shard.
</p>
<p>
It is important to note that this setting greatly reduces the chances of the write operation not writing to the requisite number of shard copies, but it does not completely eliminate the possibility, because this check occurs before the write operation starts.
After the write operation is underway, it is still possible for replication to fail on any number of shard copies but still succeed on the primary.
The <code>_shards</code> section of the API response reveals the number of shard copies on which replication succeeded and failed.
</p>
<p>
<strong>No operation (noop) updates</strong>
</p>
<p>
When updating a document by using this API, a new version of the document is always created even if the document hasn't changed.
If this isn't acceptable use the <code>_update</code> API with <code>detect_noop</code> set to <code>true</code>.
The <code>detect_noop</code> option isn't available on this API because it doesn’t fetch the old source and isn't able to compare it against the new source.
</p>
<p>
There isn't a definitive rule for when noop updates aren't acceptable.
It's a combination of lots of factors like how frequently your data source sends updates that are actually noops and how many queries per second Elasticsearch runs on the shard receiving the updates.
</p>
<p>
<strong>Versioning</strong>
</p>
<p>
Each indexed document is given a version number.
By default, internal versioning is used that starts at 1 and increments with each update, deletes included.
Optionally, the version number can be set to an external value (for example, if maintained in a database).
To enable this functionality, <code>version_type</code> should be set to <code>external</code>.
The value provided must be a numeric, long value greater than or equal to 0, and less than around <code>9.2e+18</code>.
</p>
<p>
NOTE: Versioning is completely real time, and is not affected by the near real time aspects of search operations.
If no version is provided, the operation runs without any version checks.
</p>
<p>
When using the external version type, the system checks to see if the version number passed to the index request is greater than the version of the currently stored document.
If true, the document will be indexed and the new version number used.
If the value provided is less than or equal to the stored document's version number, a version conflict will occur and the index operation will fail. For example:
</p>
<pre><code class="lang-csharp">PUT my-index-000001/_doc/1?version=2&amp;version_type=external
{
  "user": {
    "id": "elkbee"
  }
}

In this example, the operation will succeed since the supplied version of 2 is higher than the current document version of 1.
If the document was already updated and its version was set to 2 or higher, the indexing command will fail and result in a conflict (409 HTTP status code).

A nice side effect is that there is no need to maintain strict ordering of async indexing operations run as a result of changes to a source database, as long as version numbers from the source database are used.
Even the simple case of updating the Elasticsearch index using data from a database is simplified if external versioning is used, as only the latest version will be used if the index operations arrive out of order.</code></pre>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-index_.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;IndexResponse&gt; IndexAsync&lt;TDocument&gt;(TDocument document, Id? id, Action&lt;IndexRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.IndexRequestDescriptor-1.html">IndexRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.IndexResponse.html">IndexResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_IndexAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.IndexAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_IndexAsync__1___0_Elastic_Clients_Elasticsearch_Id_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.IndexAsync``1(``0,Elastic.Clients.Elasticsearch.Id,System.Threading.CancellationToken)">
  IndexAsync&lt;TDocument&gt;(TDocument, Id?, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L22215"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Create or update a document in an index.
</p>
<p>
Add a JSON document to the specified data stream or index and make it searchable.
If the target is an index and the document already exists, the request updates the document and increments its version.
</p>
<p>
NOTE: You cannot use this API to send update requests for existing documents in a data stream.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or index alias:
</p>
<ul><li>
<p>
To add or overwrite a document using the <code>PUT /&lt;target&gt;/_doc/&lt;_id&gt;</code> request format, you must have the <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To add a document using the <code>POST /&lt;target&gt;/_doc/</code> request format, you must have the <code>create_doc</code>, <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To automatically create a data stream or index with this API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege.
</p>
</li></ul>
<p>
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
NOTE: Replica shards might not all be started when an indexing operation returns successfully.
By default, only the primary is required. Set <code>wait_for_active_shards</code> to change this default behavior.
</p>
<p>
<strong>Automatically create data streams and indices</strong>
</p>
<p>
If the request's target doesn't exist and matches an index template with a <code>data_stream</code> definition, the index operation automatically creates the data stream.
</p>
<p>
If the target doesn't exist and doesn't match a data stream template, the operation automatically creates the index and applies any matching index templates.
</p>
<p>
NOTE: Elasticsearch includes several built-in index templates. To avoid naming collisions with these templates, refer to index pattern documentation.
</p>
<p>
If no mapping exists, the index operation creates a dynamic mapping.
By default, new fields and objects are automatically added to the mapping if needed.
</p>
<p>
Automatic index creation is controlled by the <code>action.auto_create_index</code> setting.
If it is <code>true</code>, any index can be created automatically.
You can modify this setting to explicitly allow or block automatic creation of indices that match specified patterns or set it to <code>false</code> to turn off automatic index creation entirely.
Specify a comma-separated list of patterns you want to allow or prefix each pattern with <code>+</code> or <code>-</code> to indicate whether it should be allowed or blocked.
When a list is specified, the default behaviour is to disallow.
</p>
<p>
NOTE: The <code>action.auto_create_index</code> setting affects the automatic creation of indices only.
It does not affect the creation of data streams.
</p>
<p>
<strong>Optimistic concurrency control</strong>
</p>
<p>
Index operations can be made conditional and only be performed if the last modification to the document was assigned the sequence number and primary term specified by the <code>if_seq_no</code> and <code>if_primary_term</code> parameters.
If a mismatch is detected, the operation will result in a <code>VersionConflictException</code> and a status code of <code>409</code>.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
By default, shard placement — or routing — is controlled by using a hash of the document's ID value.
For more explicit control, the value fed into the hash function used by the router can be directly specified on a per-operation basis using the <code>routing</code> parameter.
</p>
<p>
When setting up explicit mapping, you can also use the <code>_routing</code> field to direct the index operation to extract the routing value from the document itself.
This does come at the (very minimal) cost of an additional document parsing pass.
If the <code>_routing</code> mapping is defined and set to be required, the index operation will fail if no routing value is provided or extracted.
</p>
<p>
NOTE: Data streams do not support custom routing unless they were created with the <code>allow_custom_routing</code> setting enabled in the template.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The index operation is directed to the primary shard based on its route and performed on the actual node containing this shard.
After the primary shard completes the operation, if needed, the update is distributed to applicable replicas.
</p>
<p>
<strong>Active shards</strong>
</p>
<p>
To improve the resiliency of writes to the system, indexing operations can be configured to wait for a certain number of active shard copies before proceeding with the operation.
If the requisite number of active shard copies are not available, then the write operation must wait and retry, until either the requisite shard copies have started or a timeout occurs.
By default, write operations only wait for the primary shards to be active before proceeding (that is to say <code>wait_for_active_shards</code> is <code>1</code>).
This default can be overridden in the index settings dynamically by setting <code>index.write.wait_for_active_shards</code>.
To alter this behavior per operation, use the <code>wait_for_active_shards request</code> parameter.
</p>
<p>
Valid values are all or any positive integer up to the total number of configured copies per shard in the index (which is <code>number_of_replicas</code>+1).
Specifying a negative value or a number greater than the number of shard copies will throw an error.
</p>
<p>
For example, suppose you have a cluster of three nodes, A, B, and C and you create an index index with the number of replicas set to 3 (resulting in 4 shard copies, one more copy than there are nodes).
If you attempt an indexing operation, by default the operation will only ensure the primary copy of each shard is available before proceeding.
This means that even if B and C went down and A hosted the primary shard copies, the indexing operation would still proceed with only one copy of the data.
If <code>wait_for_active_shards</code> is set on the request to <code>3</code> (and all three nodes are up), the indexing operation will require 3 active shard copies before proceeding.
This requirement should be met because there are 3 active nodes in the cluster, each one holding a copy of the shard.
However, if you set <code>wait_for_active_shards</code> to <code>all</code> (or to <code>4</code>, which is the same in this situation), the indexing operation will not proceed as you do not have all 4 copies of each shard active in the index.
The operation will timeout unless a new node is brought up in the cluster to host the fourth copy of the shard.
</p>
<p>
It is important to note that this setting greatly reduces the chances of the write operation not writing to the requisite number of shard copies, but it does not completely eliminate the possibility, because this check occurs before the write operation starts.
After the write operation is underway, it is still possible for replication to fail on any number of shard copies but still succeed on the primary.
The <code>_shards</code> section of the API response reveals the number of shard copies on which replication succeeded and failed.
</p>
<p>
<strong>No operation (noop) updates</strong>
</p>
<p>
When updating a document by using this API, a new version of the document is always created even if the document hasn't changed.
If this isn't acceptable use the <code>_update</code> API with <code>detect_noop</code> set to <code>true</code>.
The <code>detect_noop</code> option isn't available on this API because it doesn’t fetch the old source and isn't able to compare it against the new source.
</p>
<p>
There isn't a definitive rule for when noop updates aren't acceptable.
It's a combination of lots of factors like how frequently your data source sends updates that are actually noops and how many queries per second Elasticsearch runs on the shard receiving the updates.
</p>
<p>
<strong>Versioning</strong>
</p>
<p>
Each indexed document is given a version number.
By default, internal versioning is used that starts at 1 and increments with each update, deletes included.
Optionally, the version number can be set to an external value (for example, if maintained in a database).
To enable this functionality, <code>version_type</code> should be set to <code>external</code>.
The value provided must be a numeric, long value greater than or equal to 0, and less than around <code>9.2e+18</code>.
</p>
<p>
NOTE: Versioning is completely real time, and is not affected by the near real time aspects of search operations.
If no version is provided, the operation runs without any version checks.
</p>
<p>
When using the external version type, the system checks to see if the version number passed to the index request is greater than the version of the currently stored document.
If true, the document will be indexed and the new version number used.
If the value provided is less than or equal to the stored document's version number, a version conflict will occur and the index operation will fail. For example:
</p>
<pre><code class="lang-csharp">PUT my-index-000001/_doc/1?version=2&amp;version_type=external
{
  "user": {
    "id": "elkbee"
  }
}

In this example, the operation will succeed since the supplied version of 2 is higher than the current document version of 1.
If the document was already updated and its version was set to 2 or higher, the indexing command will fail and result in a conflict (409 HTTP status code).

A nice side effect is that there is no need to maintain strict ordering of async indexing operations run as a result of changes to a source database, as long as version numbers from the source database are used.
Even the simple case of updating the Elasticsearch index using data from a database is simplified if external versioning is used, as only the latest version will be used if the index operations arrive out of order.</code></pre>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-index_.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;IndexResponse&gt; IndexAsync&lt;TDocument&gt;(TDocument document, Id? id, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.IndexResponse.html">IndexResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_IndexAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.IndexAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_IndexAsync__1___0_Elastic_Clients_Elasticsearch_IndexName_Elastic_Clients_Elasticsearch_Id_System_Action_Elastic_Clients_Elasticsearch_IndexRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.IndexAsync``1(``0,Elastic.Clients.Elasticsearch.IndexName,Elastic.Clients.Elasticsearch.Id,System.Action{Elastic.Clients.Elasticsearch.IndexRequestDescriptor{``0}},System.Threading.CancellationToken)">
  IndexAsync&lt;TDocument&gt;(TDocument, IndexName, Id?, Action&lt;IndexRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L21332"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Create or update a document in an index.
</p>
<p>
Add a JSON document to the specified data stream or index and make it searchable.
If the target is an index and the document already exists, the request updates the document and increments its version.
</p>
<p>
NOTE: You cannot use this API to send update requests for existing documents in a data stream.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or index alias:
</p>
<ul><li>
<p>
To add or overwrite a document using the <code>PUT /&lt;target&gt;/_doc/&lt;_id&gt;</code> request format, you must have the <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To add a document using the <code>POST /&lt;target&gt;/_doc/</code> request format, you must have the <code>create_doc</code>, <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To automatically create a data stream or index with this API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege.
</p>
</li></ul>
<p>
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
NOTE: Replica shards might not all be started when an indexing operation returns successfully.
By default, only the primary is required. Set <code>wait_for_active_shards</code> to change this default behavior.
</p>
<p>
<strong>Automatically create data streams and indices</strong>
</p>
<p>
If the request's target doesn't exist and matches an index template with a <code>data_stream</code> definition, the index operation automatically creates the data stream.
</p>
<p>
If the target doesn't exist and doesn't match a data stream template, the operation automatically creates the index and applies any matching index templates.
</p>
<p>
NOTE: Elasticsearch includes several built-in index templates. To avoid naming collisions with these templates, refer to index pattern documentation.
</p>
<p>
If no mapping exists, the index operation creates a dynamic mapping.
By default, new fields and objects are automatically added to the mapping if needed.
</p>
<p>
Automatic index creation is controlled by the <code>action.auto_create_index</code> setting.
If it is <code>true</code>, any index can be created automatically.
You can modify this setting to explicitly allow or block automatic creation of indices that match specified patterns or set it to <code>false</code> to turn off automatic index creation entirely.
Specify a comma-separated list of patterns you want to allow or prefix each pattern with <code>+</code> or <code>-</code> to indicate whether it should be allowed or blocked.
When a list is specified, the default behaviour is to disallow.
</p>
<p>
NOTE: The <code>action.auto_create_index</code> setting affects the automatic creation of indices only.
It does not affect the creation of data streams.
</p>
<p>
<strong>Optimistic concurrency control</strong>
</p>
<p>
Index operations can be made conditional and only be performed if the last modification to the document was assigned the sequence number and primary term specified by the <code>if_seq_no</code> and <code>if_primary_term</code> parameters.
If a mismatch is detected, the operation will result in a <code>VersionConflictException</code> and a status code of <code>409</code>.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
By default, shard placement — or routing — is controlled by using a hash of the document's ID value.
For more explicit control, the value fed into the hash function used by the router can be directly specified on a per-operation basis using the <code>routing</code> parameter.
</p>
<p>
When setting up explicit mapping, you can also use the <code>_routing</code> field to direct the index operation to extract the routing value from the document itself.
This does come at the (very minimal) cost of an additional document parsing pass.
If the <code>_routing</code> mapping is defined and set to be required, the index operation will fail if no routing value is provided or extracted.
</p>
<p>
NOTE: Data streams do not support custom routing unless they were created with the <code>allow_custom_routing</code> setting enabled in the template.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The index operation is directed to the primary shard based on its route and performed on the actual node containing this shard.
After the primary shard completes the operation, if needed, the update is distributed to applicable replicas.
</p>
<p>
<strong>Active shards</strong>
</p>
<p>
To improve the resiliency of writes to the system, indexing operations can be configured to wait for a certain number of active shard copies before proceeding with the operation.
If the requisite number of active shard copies are not available, then the write operation must wait and retry, until either the requisite shard copies have started or a timeout occurs.
By default, write operations only wait for the primary shards to be active before proceeding (that is to say <code>wait_for_active_shards</code> is <code>1</code>).
This default can be overridden in the index settings dynamically by setting <code>index.write.wait_for_active_shards</code>.
To alter this behavior per operation, use the <code>wait_for_active_shards request</code> parameter.
</p>
<p>
Valid values are all or any positive integer up to the total number of configured copies per shard in the index (which is <code>number_of_replicas</code>+1).
Specifying a negative value or a number greater than the number of shard copies will throw an error.
</p>
<p>
For example, suppose you have a cluster of three nodes, A, B, and C and you create an index index with the number of replicas set to 3 (resulting in 4 shard copies, one more copy than there are nodes).
If you attempt an indexing operation, by default the operation will only ensure the primary copy of each shard is available before proceeding.
This means that even if B and C went down and A hosted the primary shard copies, the indexing operation would still proceed with only one copy of the data.
If <code>wait_for_active_shards</code> is set on the request to <code>3</code> (and all three nodes are up), the indexing operation will require 3 active shard copies before proceeding.
This requirement should be met because there are 3 active nodes in the cluster, each one holding a copy of the shard.
However, if you set <code>wait_for_active_shards</code> to <code>all</code> (or to <code>4</code>, which is the same in this situation), the indexing operation will not proceed as you do not have all 4 copies of each shard active in the index.
The operation will timeout unless a new node is brought up in the cluster to host the fourth copy of the shard.
</p>
<p>
It is important to note that this setting greatly reduces the chances of the write operation not writing to the requisite number of shard copies, but it does not completely eliminate the possibility, because this check occurs before the write operation starts.
After the write operation is underway, it is still possible for replication to fail on any number of shard copies but still succeed on the primary.
The <code>_shards</code> section of the API response reveals the number of shard copies on which replication succeeded and failed.
</p>
<p>
<strong>No operation (noop) updates</strong>
</p>
<p>
When updating a document by using this API, a new version of the document is always created even if the document hasn't changed.
If this isn't acceptable use the <code>_update</code> API with <code>detect_noop</code> set to <code>true</code>.
The <code>detect_noop</code> option isn't available on this API because it doesn’t fetch the old source and isn't able to compare it against the new source.
</p>
<p>
There isn't a definitive rule for when noop updates aren't acceptable.
It's a combination of lots of factors like how frequently your data source sends updates that are actually noops and how many queries per second Elasticsearch runs on the shard receiving the updates.
</p>
<p>
<strong>Versioning</strong>
</p>
<p>
Each indexed document is given a version number.
By default, internal versioning is used that starts at 1 and increments with each update, deletes included.
Optionally, the version number can be set to an external value (for example, if maintained in a database).
To enable this functionality, <code>version_type</code> should be set to <code>external</code>.
The value provided must be a numeric, long value greater than or equal to 0, and less than around <code>9.2e+18</code>.
</p>
<p>
NOTE: Versioning is completely real time, and is not affected by the near real time aspects of search operations.
If no version is provided, the operation runs without any version checks.
</p>
<p>
When using the external version type, the system checks to see if the version number passed to the index request is greater than the version of the currently stored document.
If true, the document will be indexed and the new version number used.
If the value provided is less than or equal to the stored document's version number, a version conflict will occur and the index operation will fail. For example:
</p>
<pre><code class="lang-csharp">PUT my-index-000001/_doc/1?version=2&amp;version_type=external
{
  "user": {
    "id": "elkbee"
  }
}

In this example, the operation will succeed since the supplied version of 2 is higher than the current document version of 1.
If the document was already updated and its version was set to 2 or higher, the indexing command will fail and result in a conflict (409 HTTP status code).

A nice side effect is that there is no need to maintain strict ordering of async indexing operations run as a result of changes to a source database, as long as version numbers from the source database are used.
Even the simple case of updating the Elasticsearch index using data from a database is simplified if external versioning is used, as only the latest version will be used if the index operations arrive out of order.</code></pre>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-index_.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;IndexResponse&gt; IndexAsync&lt;TDocument&gt;(TDocument document, IndexName index, Id? id, Action&lt;IndexRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.IndexRequestDescriptor-1.html">IndexRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.IndexResponse.html">IndexResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_IndexAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.IndexAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_IndexAsync__1___0_Elastic_Clients_Elasticsearch_IndexName_Elastic_Clients_Elasticsearch_Id_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.IndexAsync``1(``0,Elastic.Clients.Elasticsearch.IndexName,Elastic.Clients.Elasticsearch.Id,System.Threading.CancellationToken)">
  IndexAsync&lt;TDocument&gt;(TDocument, IndexName, Id?, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L21156"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Create or update a document in an index.
</p>
<p>
Add a JSON document to the specified data stream or index and make it searchable.
If the target is an index and the document already exists, the request updates the document and increments its version.
</p>
<p>
NOTE: You cannot use this API to send update requests for existing documents in a data stream.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or index alias:
</p>
<ul><li>
<p>
To add or overwrite a document using the <code>PUT /&lt;target&gt;/_doc/&lt;_id&gt;</code> request format, you must have the <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To add a document using the <code>POST /&lt;target&gt;/_doc/</code> request format, you must have the <code>create_doc</code>, <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To automatically create a data stream or index with this API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege.
</p>
</li></ul>
<p>
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
NOTE: Replica shards might not all be started when an indexing operation returns successfully.
By default, only the primary is required. Set <code>wait_for_active_shards</code> to change this default behavior.
</p>
<p>
<strong>Automatically create data streams and indices</strong>
</p>
<p>
If the request's target doesn't exist and matches an index template with a <code>data_stream</code> definition, the index operation automatically creates the data stream.
</p>
<p>
If the target doesn't exist and doesn't match a data stream template, the operation automatically creates the index and applies any matching index templates.
</p>
<p>
NOTE: Elasticsearch includes several built-in index templates. To avoid naming collisions with these templates, refer to index pattern documentation.
</p>
<p>
If no mapping exists, the index operation creates a dynamic mapping.
By default, new fields and objects are automatically added to the mapping if needed.
</p>
<p>
Automatic index creation is controlled by the <code>action.auto_create_index</code> setting.
If it is <code>true</code>, any index can be created automatically.
You can modify this setting to explicitly allow or block automatic creation of indices that match specified patterns or set it to <code>false</code> to turn off automatic index creation entirely.
Specify a comma-separated list of patterns you want to allow or prefix each pattern with <code>+</code> or <code>-</code> to indicate whether it should be allowed or blocked.
When a list is specified, the default behaviour is to disallow.
</p>
<p>
NOTE: The <code>action.auto_create_index</code> setting affects the automatic creation of indices only.
It does not affect the creation of data streams.
</p>
<p>
<strong>Optimistic concurrency control</strong>
</p>
<p>
Index operations can be made conditional and only be performed if the last modification to the document was assigned the sequence number and primary term specified by the <code>if_seq_no</code> and <code>if_primary_term</code> parameters.
If a mismatch is detected, the operation will result in a <code>VersionConflictException</code> and a status code of <code>409</code>.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
By default, shard placement — or routing — is controlled by using a hash of the document's ID value.
For more explicit control, the value fed into the hash function used by the router can be directly specified on a per-operation basis using the <code>routing</code> parameter.
</p>
<p>
When setting up explicit mapping, you can also use the <code>_routing</code> field to direct the index operation to extract the routing value from the document itself.
This does come at the (very minimal) cost of an additional document parsing pass.
If the <code>_routing</code> mapping is defined and set to be required, the index operation will fail if no routing value is provided or extracted.
</p>
<p>
NOTE: Data streams do not support custom routing unless they were created with the <code>allow_custom_routing</code> setting enabled in the template.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The index operation is directed to the primary shard based on its route and performed on the actual node containing this shard.
After the primary shard completes the operation, if needed, the update is distributed to applicable replicas.
</p>
<p>
<strong>Active shards</strong>
</p>
<p>
To improve the resiliency of writes to the system, indexing operations can be configured to wait for a certain number of active shard copies before proceeding with the operation.
If the requisite number of active shard copies are not available, then the write operation must wait and retry, until either the requisite shard copies have started or a timeout occurs.
By default, write operations only wait for the primary shards to be active before proceeding (that is to say <code>wait_for_active_shards</code> is <code>1</code>).
This default can be overridden in the index settings dynamically by setting <code>index.write.wait_for_active_shards</code>.
To alter this behavior per operation, use the <code>wait_for_active_shards request</code> parameter.
</p>
<p>
Valid values are all or any positive integer up to the total number of configured copies per shard in the index (which is <code>number_of_replicas</code>+1).
Specifying a negative value or a number greater than the number of shard copies will throw an error.
</p>
<p>
For example, suppose you have a cluster of three nodes, A, B, and C and you create an index index with the number of replicas set to 3 (resulting in 4 shard copies, one more copy than there are nodes).
If you attempt an indexing operation, by default the operation will only ensure the primary copy of each shard is available before proceeding.
This means that even if B and C went down and A hosted the primary shard copies, the indexing operation would still proceed with only one copy of the data.
If <code>wait_for_active_shards</code> is set on the request to <code>3</code> (and all three nodes are up), the indexing operation will require 3 active shard copies before proceeding.
This requirement should be met because there are 3 active nodes in the cluster, each one holding a copy of the shard.
However, if you set <code>wait_for_active_shards</code> to <code>all</code> (or to <code>4</code>, which is the same in this situation), the indexing operation will not proceed as you do not have all 4 copies of each shard active in the index.
The operation will timeout unless a new node is brought up in the cluster to host the fourth copy of the shard.
</p>
<p>
It is important to note that this setting greatly reduces the chances of the write operation not writing to the requisite number of shard copies, but it does not completely eliminate the possibility, because this check occurs before the write operation starts.
After the write operation is underway, it is still possible for replication to fail on any number of shard copies but still succeed on the primary.
The <code>_shards</code> section of the API response reveals the number of shard copies on which replication succeeded and failed.
</p>
<p>
<strong>No operation (noop) updates</strong>
</p>
<p>
When updating a document by using this API, a new version of the document is always created even if the document hasn't changed.
If this isn't acceptable use the <code>_update</code> API with <code>detect_noop</code> set to <code>true</code>.
The <code>detect_noop</code> option isn't available on this API because it doesn’t fetch the old source and isn't able to compare it against the new source.
</p>
<p>
There isn't a definitive rule for when noop updates aren't acceptable.
It's a combination of lots of factors like how frequently your data source sends updates that are actually noops and how many queries per second Elasticsearch runs on the shard receiving the updates.
</p>
<p>
<strong>Versioning</strong>
</p>
<p>
Each indexed document is given a version number.
By default, internal versioning is used that starts at 1 and increments with each update, deletes included.
Optionally, the version number can be set to an external value (for example, if maintained in a database).
To enable this functionality, <code>version_type</code> should be set to <code>external</code>.
The value provided must be a numeric, long value greater than or equal to 0, and less than around <code>9.2e+18</code>.
</p>
<p>
NOTE: Versioning is completely real time, and is not affected by the near real time aspects of search operations.
If no version is provided, the operation runs without any version checks.
</p>
<p>
When using the external version type, the system checks to see if the version number passed to the index request is greater than the version of the currently stored document.
If true, the document will be indexed and the new version number used.
If the value provided is less than or equal to the stored document's version number, a version conflict will occur and the index operation will fail. For example:
</p>
<pre><code class="lang-csharp">PUT my-index-000001/_doc/1?version=2&amp;version_type=external
{
  "user": {
    "id": "elkbee"
  }
}

In this example, the operation will succeed since the supplied version of 2 is higher than the current document version of 1.
If the document was already updated and its version was set to 2 or higher, the indexing command will fail and result in a conflict (409 HTTP status code).

A nice side effect is that there is no need to maintain strict ordering of async indexing operations run as a result of changes to a source database, as long as version numbers from the source database are used.
Even the simple case of updating the Elasticsearch index using data from a database is simplified if external versioning is used, as only the latest version will be used if the index operations arrive out of order.</code></pre>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-index_.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;IndexResponse&gt; IndexAsync&lt;TDocument&gt;(TDocument document, IndexName index, Id? id, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.IndexResponse.html">IndexResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_IndexAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.IndexAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_IndexAsync__1___0_Elastic_Clients_Elasticsearch_IndexName_System_Action_Elastic_Clients_Elasticsearch_IndexRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.IndexAsync``1(``0,Elastic.Clients.Elasticsearch.IndexName,System.Action{Elastic.Clients.Elasticsearch.IndexRequestDescriptor{``0}},System.Threading.CancellationToken)">
  IndexAsync&lt;TDocument&gt;(TDocument, IndexName, Action&lt;IndexRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L22038"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Create or update a document in an index.
</p>
<p>
Add a JSON document to the specified data stream or index and make it searchable.
If the target is an index and the document already exists, the request updates the document and increments its version.
</p>
<p>
NOTE: You cannot use this API to send update requests for existing documents in a data stream.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or index alias:
</p>
<ul><li>
<p>
To add or overwrite a document using the <code>PUT /&lt;target&gt;/_doc/&lt;_id&gt;</code> request format, you must have the <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To add a document using the <code>POST /&lt;target&gt;/_doc/</code> request format, you must have the <code>create_doc</code>, <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To automatically create a data stream or index with this API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege.
</p>
</li></ul>
<p>
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
NOTE: Replica shards might not all be started when an indexing operation returns successfully.
By default, only the primary is required. Set <code>wait_for_active_shards</code> to change this default behavior.
</p>
<p>
<strong>Automatically create data streams and indices</strong>
</p>
<p>
If the request's target doesn't exist and matches an index template with a <code>data_stream</code> definition, the index operation automatically creates the data stream.
</p>
<p>
If the target doesn't exist and doesn't match a data stream template, the operation automatically creates the index and applies any matching index templates.
</p>
<p>
NOTE: Elasticsearch includes several built-in index templates. To avoid naming collisions with these templates, refer to index pattern documentation.
</p>
<p>
If no mapping exists, the index operation creates a dynamic mapping.
By default, new fields and objects are automatically added to the mapping if needed.
</p>
<p>
Automatic index creation is controlled by the <code>action.auto_create_index</code> setting.
If it is <code>true</code>, any index can be created automatically.
You can modify this setting to explicitly allow or block automatic creation of indices that match specified patterns or set it to <code>false</code> to turn off automatic index creation entirely.
Specify a comma-separated list of patterns you want to allow or prefix each pattern with <code>+</code> or <code>-</code> to indicate whether it should be allowed or blocked.
When a list is specified, the default behaviour is to disallow.
</p>
<p>
NOTE: The <code>action.auto_create_index</code> setting affects the automatic creation of indices only.
It does not affect the creation of data streams.
</p>
<p>
<strong>Optimistic concurrency control</strong>
</p>
<p>
Index operations can be made conditional and only be performed if the last modification to the document was assigned the sequence number and primary term specified by the <code>if_seq_no</code> and <code>if_primary_term</code> parameters.
If a mismatch is detected, the operation will result in a <code>VersionConflictException</code> and a status code of <code>409</code>.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
By default, shard placement — or routing — is controlled by using a hash of the document's ID value.
For more explicit control, the value fed into the hash function used by the router can be directly specified on a per-operation basis using the <code>routing</code> parameter.
</p>
<p>
When setting up explicit mapping, you can also use the <code>_routing</code> field to direct the index operation to extract the routing value from the document itself.
This does come at the (very minimal) cost of an additional document parsing pass.
If the <code>_routing</code> mapping is defined and set to be required, the index operation will fail if no routing value is provided or extracted.
</p>
<p>
NOTE: Data streams do not support custom routing unless they were created with the <code>allow_custom_routing</code> setting enabled in the template.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The index operation is directed to the primary shard based on its route and performed on the actual node containing this shard.
After the primary shard completes the operation, if needed, the update is distributed to applicable replicas.
</p>
<p>
<strong>Active shards</strong>
</p>
<p>
To improve the resiliency of writes to the system, indexing operations can be configured to wait for a certain number of active shard copies before proceeding with the operation.
If the requisite number of active shard copies are not available, then the write operation must wait and retry, until either the requisite shard copies have started or a timeout occurs.
By default, write operations only wait for the primary shards to be active before proceeding (that is to say <code>wait_for_active_shards</code> is <code>1</code>).
This default can be overridden in the index settings dynamically by setting <code>index.write.wait_for_active_shards</code>.
To alter this behavior per operation, use the <code>wait_for_active_shards request</code> parameter.
</p>
<p>
Valid values are all or any positive integer up to the total number of configured copies per shard in the index (which is <code>number_of_replicas</code>+1).
Specifying a negative value or a number greater than the number of shard copies will throw an error.
</p>
<p>
For example, suppose you have a cluster of three nodes, A, B, and C and you create an index index with the number of replicas set to 3 (resulting in 4 shard copies, one more copy than there are nodes).
If you attempt an indexing operation, by default the operation will only ensure the primary copy of each shard is available before proceeding.
This means that even if B and C went down and A hosted the primary shard copies, the indexing operation would still proceed with only one copy of the data.
If <code>wait_for_active_shards</code> is set on the request to <code>3</code> (and all three nodes are up), the indexing operation will require 3 active shard copies before proceeding.
This requirement should be met because there are 3 active nodes in the cluster, each one holding a copy of the shard.
However, if you set <code>wait_for_active_shards</code> to <code>all</code> (or to <code>4</code>, which is the same in this situation), the indexing operation will not proceed as you do not have all 4 copies of each shard active in the index.
The operation will timeout unless a new node is brought up in the cluster to host the fourth copy of the shard.
</p>
<p>
It is important to note that this setting greatly reduces the chances of the write operation not writing to the requisite number of shard copies, but it does not completely eliminate the possibility, because this check occurs before the write operation starts.
After the write operation is underway, it is still possible for replication to fail on any number of shard copies but still succeed on the primary.
The <code>_shards</code> section of the API response reveals the number of shard copies on which replication succeeded and failed.
</p>
<p>
<strong>No operation (noop) updates</strong>
</p>
<p>
When updating a document by using this API, a new version of the document is always created even if the document hasn't changed.
If this isn't acceptable use the <code>_update</code> API with <code>detect_noop</code> set to <code>true</code>.
The <code>detect_noop</code> option isn't available on this API because it doesn’t fetch the old source and isn't able to compare it against the new source.
</p>
<p>
There isn't a definitive rule for when noop updates aren't acceptable.
It's a combination of lots of factors like how frequently your data source sends updates that are actually noops and how many queries per second Elasticsearch runs on the shard receiving the updates.
</p>
<p>
<strong>Versioning</strong>
</p>
<p>
Each indexed document is given a version number.
By default, internal versioning is used that starts at 1 and increments with each update, deletes included.
Optionally, the version number can be set to an external value (for example, if maintained in a database).
To enable this functionality, <code>version_type</code> should be set to <code>external</code>.
The value provided must be a numeric, long value greater than or equal to 0, and less than around <code>9.2e+18</code>.
</p>
<p>
NOTE: Versioning is completely real time, and is not affected by the near real time aspects of search operations.
If no version is provided, the operation runs without any version checks.
</p>
<p>
When using the external version type, the system checks to see if the version number passed to the index request is greater than the version of the currently stored document.
If true, the document will be indexed and the new version number used.
If the value provided is less than or equal to the stored document's version number, a version conflict will occur and the index operation will fail. For example:
</p>
<pre><code class="lang-csharp">PUT my-index-000001/_doc/1?version=2&amp;version_type=external
{
  "user": {
    "id": "elkbee"
  }
}

In this example, the operation will succeed since the supplied version of 2 is higher than the current document version of 1.
If the document was already updated and its version was set to 2 or higher, the indexing command will fail and result in a conflict (409 HTTP status code).

A nice side effect is that there is no need to maintain strict ordering of async indexing operations run as a result of changes to a source database, as long as version numbers from the source database are used.
Even the simple case of updating the Elasticsearch index using data from a database is simplified if external versioning is used, as only the latest version will be used if the index operations arrive out of order.</code></pre>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-index_.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;IndexResponse&gt; IndexAsync&lt;TDocument&gt;(TDocument document, IndexName index, Action&lt;IndexRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.IndexRequestDescriptor-1.html">IndexRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.IndexResponse.html">IndexResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_IndexAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.IndexAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_IndexAsync__1___0_Elastic_Clients_Elasticsearch_IndexName_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.IndexAsync``1(``0,Elastic.Clients.Elasticsearch.IndexName,System.Threading.CancellationToken)">
  IndexAsync&lt;TDocument&gt;(TDocument, IndexName, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L21862"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Create or update a document in an index.
</p>
<p>
Add a JSON document to the specified data stream or index and make it searchable.
If the target is an index and the document already exists, the request updates the document and increments its version.
</p>
<p>
NOTE: You cannot use this API to send update requests for existing documents in a data stream.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or index alias:
</p>
<ul><li>
<p>
To add or overwrite a document using the <code>PUT /&lt;target&gt;/_doc/&lt;_id&gt;</code> request format, you must have the <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To add a document using the <code>POST /&lt;target&gt;/_doc/</code> request format, you must have the <code>create_doc</code>, <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To automatically create a data stream or index with this API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege.
</p>
</li></ul>
<p>
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
NOTE: Replica shards might not all be started when an indexing operation returns successfully.
By default, only the primary is required. Set <code>wait_for_active_shards</code> to change this default behavior.
</p>
<p>
<strong>Automatically create data streams and indices</strong>
</p>
<p>
If the request's target doesn't exist and matches an index template with a <code>data_stream</code> definition, the index operation automatically creates the data stream.
</p>
<p>
If the target doesn't exist and doesn't match a data stream template, the operation automatically creates the index and applies any matching index templates.
</p>
<p>
NOTE: Elasticsearch includes several built-in index templates. To avoid naming collisions with these templates, refer to index pattern documentation.
</p>
<p>
If no mapping exists, the index operation creates a dynamic mapping.
By default, new fields and objects are automatically added to the mapping if needed.
</p>
<p>
Automatic index creation is controlled by the <code>action.auto_create_index</code> setting.
If it is <code>true</code>, any index can be created automatically.
You can modify this setting to explicitly allow or block automatic creation of indices that match specified patterns or set it to <code>false</code> to turn off automatic index creation entirely.
Specify a comma-separated list of patterns you want to allow or prefix each pattern with <code>+</code> or <code>-</code> to indicate whether it should be allowed or blocked.
When a list is specified, the default behaviour is to disallow.
</p>
<p>
NOTE: The <code>action.auto_create_index</code> setting affects the automatic creation of indices only.
It does not affect the creation of data streams.
</p>
<p>
<strong>Optimistic concurrency control</strong>
</p>
<p>
Index operations can be made conditional and only be performed if the last modification to the document was assigned the sequence number and primary term specified by the <code>if_seq_no</code> and <code>if_primary_term</code> parameters.
If a mismatch is detected, the operation will result in a <code>VersionConflictException</code> and a status code of <code>409</code>.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
By default, shard placement — or routing — is controlled by using a hash of the document's ID value.
For more explicit control, the value fed into the hash function used by the router can be directly specified on a per-operation basis using the <code>routing</code> parameter.
</p>
<p>
When setting up explicit mapping, you can also use the <code>_routing</code> field to direct the index operation to extract the routing value from the document itself.
This does come at the (very minimal) cost of an additional document parsing pass.
If the <code>_routing</code> mapping is defined and set to be required, the index operation will fail if no routing value is provided or extracted.
</p>
<p>
NOTE: Data streams do not support custom routing unless they were created with the <code>allow_custom_routing</code> setting enabled in the template.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The index operation is directed to the primary shard based on its route and performed on the actual node containing this shard.
After the primary shard completes the operation, if needed, the update is distributed to applicable replicas.
</p>
<p>
<strong>Active shards</strong>
</p>
<p>
To improve the resiliency of writes to the system, indexing operations can be configured to wait for a certain number of active shard copies before proceeding with the operation.
If the requisite number of active shard copies are not available, then the write operation must wait and retry, until either the requisite shard copies have started or a timeout occurs.
By default, write operations only wait for the primary shards to be active before proceeding (that is to say <code>wait_for_active_shards</code> is <code>1</code>).
This default can be overridden in the index settings dynamically by setting <code>index.write.wait_for_active_shards</code>.
To alter this behavior per operation, use the <code>wait_for_active_shards request</code> parameter.
</p>
<p>
Valid values are all or any positive integer up to the total number of configured copies per shard in the index (which is <code>number_of_replicas</code>+1).
Specifying a negative value or a number greater than the number of shard copies will throw an error.
</p>
<p>
For example, suppose you have a cluster of three nodes, A, B, and C and you create an index index with the number of replicas set to 3 (resulting in 4 shard copies, one more copy than there are nodes).
If you attempt an indexing operation, by default the operation will only ensure the primary copy of each shard is available before proceeding.
This means that even if B and C went down and A hosted the primary shard copies, the indexing operation would still proceed with only one copy of the data.
If <code>wait_for_active_shards</code> is set on the request to <code>3</code> (and all three nodes are up), the indexing operation will require 3 active shard copies before proceeding.
This requirement should be met because there are 3 active nodes in the cluster, each one holding a copy of the shard.
However, if you set <code>wait_for_active_shards</code> to <code>all</code> (or to <code>4</code>, which is the same in this situation), the indexing operation will not proceed as you do not have all 4 copies of each shard active in the index.
The operation will timeout unless a new node is brought up in the cluster to host the fourth copy of the shard.
</p>
<p>
It is important to note that this setting greatly reduces the chances of the write operation not writing to the requisite number of shard copies, but it does not completely eliminate the possibility, because this check occurs before the write operation starts.
After the write operation is underway, it is still possible for replication to fail on any number of shard copies but still succeed on the primary.
The <code>_shards</code> section of the API response reveals the number of shard copies on which replication succeeded and failed.
</p>
<p>
<strong>No operation (noop) updates</strong>
</p>
<p>
When updating a document by using this API, a new version of the document is always created even if the document hasn't changed.
If this isn't acceptable use the <code>_update</code> API with <code>detect_noop</code> set to <code>true</code>.
The <code>detect_noop</code> option isn't available on this API because it doesn’t fetch the old source and isn't able to compare it against the new source.
</p>
<p>
There isn't a definitive rule for when noop updates aren't acceptable.
It's a combination of lots of factors like how frequently your data source sends updates that are actually noops and how many queries per second Elasticsearch runs on the shard receiving the updates.
</p>
<p>
<strong>Versioning</strong>
</p>
<p>
Each indexed document is given a version number.
By default, internal versioning is used that starts at 1 and increments with each update, deletes included.
Optionally, the version number can be set to an external value (for example, if maintained in a database).
To enable this functionality, <code>version_type</code> should be set to <code>external</code>.
The value provided must be a numeric, long value greater than or equal to 0, and less than around <code>9.2e+18</code>.
</p>
<p>
NOTE: Versioning is completely real time, and is not affected by the near real time aspects of search operations.
If no version is provided, the operation runs without any version checks.
</p>
<p>
When using the external version type, the system checks to see if the version number passed to the index request is greater than the version of the currently stored document.
If true, the document will be indexed and the new version number used.
If the value provided is less than or equal to the stored document's version number, a version conflict will occur and the index operation will fail. For example:
</p>
<pre><code class="lang-csharp">PUT my-index-000001/_doc/1?version=2&amp;version_type=external
{
  "user": {
    "id": "elkbee"
  }
}

In this example, the operation will succeed since the supplied version of 2 is higher than the current document version of 1.
If the document was already updated and its version was set to 2 or higher, the indexing command will fail and result in a conflict (409 HTTP status code).

A nice side effect is that there is no need to maintain strict ordering of async indexing operations run as a result of changes to a source database, as long as version numbers from the source database are used.
Even the simple case of updating the Elasticsearch index using data from a database is simplified if external versioning is used, as only the latest version will be used if the index operations arrive out of order.</code></pre>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-index_.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;IndexResponse&gt; IndexAsync&lt;TDocument&gt;(TDocument document, IndexName index, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.IndexResponse.html">IndexResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_IndexAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.IndexAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_IndexAsync__1___0_System_Action_Elastic_Clients_Elasticsearch_IndexRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.IndexAsync``1(``0,System.Action{Elastic.Clients.Elasticsearch.IndexRequestDescriptor{``0}},System.Threading.CancellationToken)">
  IndexAsync&lt;TDocument&gt;(TDocument, Action&lt;IndexRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L21685"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Create or update a document in an index.
</p>
<p>
Add a JSON document to the specified data stream or index and make it searchable.
If the target is an index and the document already exists, the request updates the document and increments its version.
</p>
<p>
NOTE: You cannot use this API to send update requests for existing documents in a data stream.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or index alias:
</p>
<ul><li>
<p>
To add or overwrite a document using the <code>PUT /&lt;target&gt;/_doc/&lt;_id&gt;</code> request format, you must have the <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To add a document using the <code>POST /&lt;target&gt;/_doc/</code> request format, you must have the <code>create_doc</code>, <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To automatically create a data stream or index with this API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege.
</p>
</li></ul>
<p>
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
NOTE: Replica shards might not all be started when an indexing operation returns successfully.
By default, only the primary is required. Set <code>wait_for_active_shards</code> to change this default behavior.
</p>
<p>
<strong>Automatically create data streams and indices</strong>
</p>
<p>
If the request's target doesn't exist and matches an index template with a <code>data_stream</code> definition, the index operation automatically creates the data stream.
</p>
<p>
If the target doesn't exist and doesn't match a data stream template, the operation automatically creates the index and applies any matching index templates.
</p>
<p>
NOTE: Elasticsearch includes several built-in index templates. To avoid naming collisions with these templates, refer to index pattern documentation.
</p>
<p>
If no mapping exists, the index operation creates a dynamic mapping.
By default, new fields and objects are automatically added to the mapping if needed.
</p>
<p>
Automatic index creation is controlled by the <code>action.auto_create_index</code> setting.
If it is <code>true</code>, any index can be created automatically.
You can modify this setting to explicitly allow or block automatic creation of indices that match specified patterns or set it to <code>false</code> to turn off automatic index creation entirely.
Specify a comma-separated list of patterns you want to allow or prefix each pattern with <code>+</code> or <code>-</code> to indicate whether it should be allowed or blocked.
When a list is specified, the default behaviour is to disallow.
</p>
<p>
NOTE: The <code>action.auto_create_index</code> setting affects the automatic creation of indices only.
It does not affect the creation of data streams.
</p>
<p>
<strong>Optimistic concurrency control</strong>
</p>
<p>
Index operations can be made conditional and only be performed if the last modification to the document was assigned the sequence number and primary term specified by the <code>if_seq_no</code> and <code>if_primary_term</code> parameters.
If a mismatch is detected, the operation will result in a <code>VersionConflictException</code> and a status code of <code>409</code>.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
By default, shard placement — or routing — is controlled by using a hash of the document's ID value.
For more explicit control, the value fed into the hash function used by the router can be directly specified on a per-operation basis using the <code>routing</code> parameter.
</p>
<p>
When setting up explicit mapping, you can also use the <code>_routing</code> field to direct the index operation to extract the routing value from the document itself.
This does come at the (very minimal) cost of an additional document parsing pass.
If the <code>_routing</code> mapping is defined and set to be required, the index operation will fail if no routing value is provided or extracted.
</p>
<p>
NOTE: Data streams do not support custom routing unless they were created with the <code>allow_custom_routing</code> setting enabled in the template.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The index operation is directed to the primary shard based on its route and performed on the actual node containing this shard.
After the primary shard completes the operation, if needed, the update is distributed to applicable replicas.
</p>
<p>
<strong>Active shards</strong>
</p>
<p>
To improve the resiliency of writes to the system, indexing operations can be configured to wait for a certain number of active shard copies before proceeding with the operation.
If the requisite number of active shard copies are not available, then the write operation must wait and retry, until either the requisite shard copies have started or a timeout occurs.
By default, write operations only wait for the primary shards to be active before proceeding (that is to say <code>wait_for_active_shards</code> is <code>1</code>).
This default can be overridden in the index settings dynamically by setting <code>index.write.wait_for_active_shards</code>.
To alter this behavior per operation, use the <code>wait_for_active_shards request</code> parameter.
</p>
<p>
Valid values are all or any positive integer up to the total number of configured copies per shard in the index (which is <code>number_of_replicas</code>+1).
Specifying a negative value or a number greater than the number of shard copies will throw an error.
</p>
<p>
For example, suppose you have a cluster of three nodes, A, B, and C and you create an index index with the number of replicas set to 3 (resulting in 4 shard copies, one more copy than there are nodes).
If you attempt an indexing operation, by default the operation will only ensure the primary copy of each shard is available before proceeding.
This means that even if B and C went down and A hosted the primary shard copies, the indexing operation would still proceed with only one copy of the data.
If <code>wait_for_active_shards</code> is set on the request to <code>3</code> (and all three nodes are up), the indexing operation will require 3 active shard copies before proceeding.
This requirement should be met because there are 3 active nodes in the cluster, each one holding a copy of the shard.
However, if you set <code>wait_for_active_shards</code> to <code>all</code> (or to <code>4</code>, which is the same in this situation), the indexing operation will not proceed as you do not have all 4 copies of each shard active in the index.
The operation will timeout unless a new node is brought up in the cluster to host the fourth copy of the shard.
</p>
<p>
It is important to note that this setting greatly reduces the chances of the write operation not writing to the requisite number of shard copies, but it does not completely eliminate the possibility, because this check occurs before the write operation starts.
After the write operation is underway, it is still possible for replication to fail on any number of shard copies but still succeed on the primary.
The <code>_shards</code> section of the API response reveals the number of shard copies on which replication succeeded and failed.
</p>
<p>
<strong>No operation (noop) updates</strong>
</p>
<p>
When updating a document by using this API, a new version of the document is always created even if the document hasn't changed.
If this isn't acceptable use the <code>_update</code> API with <code>detect_noop</code> set to <code>true</code>.
The <code>detect_noop</code> option isn't available on this API because it doesn’t fetch the old source and isn't able to compare it against the new source.
</p>
<p>
There isn't a definitive rule for when noop updates aren't acceptable.
It's a combination of lots of factors like how frequently your data source sends updates that are actually noops and how many queries per second Elasticsearch runs on the shard receiving the updates.
</p>
<p>
<strong>Versioning</strong>
</p>
<p>
Each indexed document is given a version number.
By default, internal versioning is used that starts at 1 and increments with each update, deletes included.
Optionally, the version number can be set to an external value (for example, if maintained in a database).
To enable this functionality, <code>version_type</code> should be set to <code>external</code>.
The value provided must be a numeric, long value greater than or equal to 0, and less than around <code>9.2e+18</code>.
</p>
<p>
NOTE: Versioning is completely real time, and is not affected by the near real time aspects of search operations.
If no version is provided, the operation runs without any version checks.
</p>
<p>
When using the external version type, the system checks to see if the version number passed to the index request is greater than the version of the currently stored document.
If true, the document will be indexed and the new version number used.
If the value provided is less than or equal to the stored document's version number, a version conflict will occur and the index operation will fail. For example:
</p>
<pre><code class="lang-csharp">PUT my-index-000001/_doc/1?version=2&amp;version_type=external
{
  "user": {
    "id": "elkbee"
  }
}

In this example, the operation will succeed since the supplied version of 2 is higher than the current document version of 1.
If the document was already updated and its version was set to 2 or higher, the indexing command will fail and result in a conflict (409 HTTP status code).

A nice side effect is that there is no need to maintain strict ordering of async indexing operations run as a result of changes to a source database, as long as version numbers from the source database are used.
Even the simple case of updating the Elasticsearch index using data from a database is simplified if external versioning is used, as only the latest version will be used if the index operations arrive out of order.</code></pre>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-index_.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;IndexResponse&gt; IndexAsync&lt;TDocument&gt;(TDocument document, Action&lt;IndexRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.IndexRequestDescriptor-1.html">IndexRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.IndexResponse.html">IndexResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_IndexAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.IndexAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_IndexAsync__1___0_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.IndexAsync``1(``0,System.Threading.CancellationToken)">
  IndexAsync&lt;TDocument&gt;(TDocument, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L21509"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Create or update a document in an index.
</p>
<p>
Add a JSON document to the specified data stream or index and make it searchable.
If the target is an index and the document already exists, the request updates the document and increments its version.
</p>
<p>
NOTE: You cannot use this API to send update requests for existing documents in a data stream.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or index alias:
</p>
<ul><li>
<p>
To add or overwrite a document using the <code>PUT /&lt;target&gt;/_doc/&lt;_id&gt;</code> request format, you must have the <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To add a document using the <code>POST /&lt;target&gt;/_doc/</code> request format, you must have the <code>create_doc</code>, <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To automatically create a data stream or index with this API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege.
</p>
</li></ul>
<p>
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
NOTE: Replica shards might not all be started when an indexing operation returns successfully.
By default, only the primary is required. Set <code>wait_for_active_shards</code> to change this default behavior.
</p>
<p>
<strong>Automatically create data streams and indices</strong>
</p>
<p>
If the request's target doesn't exist and matches an index template with a <code>data_stream</code> definition, the index operation automatically creates the data stream.
</p>
<p>
If the target doesn't exist and doesn't match a data stream template, the operation automatically creates the index and applies any matching index templates.
</p>
<p>
NOTE: Elasticsearch includes several built-in index templates. To avoid naming collisions with these templates, refer to index pattern documentation.
</p>
<p>
If no mapping exists, the index operation creates a dynamic mapping.
By default, new fields and objects are automatically added to the mapping if needed.
</p>
<p>
Automatic index creation is controlled by the <code>action.auto_create_index</code> setting.
If it is <code>true</code>, any index can be created automatically.
You can modify this setting to explicitly allow or block automatic creation of indices that match specified patterns or set it to <code>false</code> to turn off automatic index creation entirely.
Specify a comma-separated list of patterns you want to allow or prefix each pattern with <code>+</code> or <code>-</code> to indicate whether it should be allowed or blocked.
When a list is specified, the default behaviour is to disallow.
</p>
<p>
NOTE: The <code>action.auto_create_index</code> setting affects the automatic creation of indices only.
It does not affect the creation of data streams.
</p>
<p>
<strong>Optimistic concurrency control</strong>
</p>
<p>
Index operations can be made conditional and only be performed if the last modification to the document was assigned the sequence number and primary term specified by the <code>if_seq_no</code> and <code>if_primary_term</code> parameters.
If a mismatch is detected, the operation will result in a <code>VersionConflictException</code> and a status code of <code>409</code>.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
By default, shard placement — or routing — is controlled by using a hash of the document's ID value.
For more explicit control, the value fed into the hash function used by the router can be directly specified on a per-operation basis using the <code>routing</code> parameter.
</p>
<p>
When setting up explicit mapping, you can also use the <code>_routing</code> field to direct the index operation to extract the routing value from the document itself.
This does come at the (very minimal) cost of an additional document parsing pass.
If the <code>_routing</code> mapping is defined and set to be required, the index operation will fail if no routing value is provided or extracted.
</p>
<p>
NOTE: Data streams do not support custom routing unless they were created with the <code>allow_custom_routing</code> setting enabled in the template.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The index operation is directed to the primary shard based on its route and performed on the actual node containing this shard.
After the primary shard completes the operation, if needed, the update is distributed to applicable replicas.
</p>
<p>
<strong>Active shards</strong>
</p>
<p>
To improve the resiliency of writes to the system, indexing operations can be configured to wait for a certain number of active shard copies before proceeding with the operation.
If the requisite number of active shard copies are not available, then the write operation must wait and retry, until either the requisite shard copies have started or a timeout occurs.
By default, write operations only wait for the primary shards to be active before proceeding (that is to say <code>wait_for_active_shards</code> is <code>1</code>).
This default can be overridden in the index settings dynamically by setting <code>index.write.wait_for_active_shards</code>.
To alter this behavior per operation, use the <code>wait_for_active_shards request</code> parameter.
</p>
<p>
Valid values are all or any positive integer up to the total number of configured copies per shard in the index (which is <code>number_of_replicas</code>+1).
Specifying a negative value or a number greater than the number of shard copies will throw an error.
</p>
<p>
For example, suppose you have a cluster of three nodes, A, B, and C and you create an index index with the number of replicas set to 3 (resulting in 4 shard copies, one more copy than there are nodes).
If you attempt an indexing operation, by default the operation will only ensure the primary copy of each shard is available before proceeding.
This means that even if B and C went down and A hosted the primary shard copies, the indexing operation would still proceed with only one copy of the data.
If <code>wait_for_active_shards</code> is set on the request to <code>3</code> (and all three nodes are up), the indexing operation will require 3 active shard copies before proceeding.
This requirement should be met because there are 3 active nodes in the cluster, each one holding a copy of the shard.
However, if you set <code>wait_for_active_shards</code> to <code>all</code> (or to <code>4</code>, which is the same in this situation), the indexing operation will not proceed as you do not have all 4 copies of each shard active in the index.
The operation will timeout unless a new node is brought up in the cluster to host the fourth copy of the shard.
</p>
<p>
It is important to note that this setting greatly reduces the chances of the write operation not writing to the requisite number of shard copies, but it does not completely eliminate the possibility, because this check occurs before the write operation starts.
After the write operation is underway, it is still possible for replication to fail on any number of shard copies but still succeed on the primary.
The <code>_shards</code> section of the API response reveals the number of shard copies on which replication succeeded and failed.
</p>
<p>
<strong>No operation (noop) updates</strong>
</p>
<p>
When updating a document by using this API, a new version of the document is always created even if the document hasn't changed.
If this isn't acceptable use the <code>_update</code> API with <code>detect_noop</code> set to <code>true</code>.
The <code>detect_noop</code> option isn't available on this API because it doesn’t fetch the old source and isn't able to compare it against the new source.
</p>
<p>
There isn't a definitive rule for when noop updates aren't acceptable.
It's a combination of lots of factors like how frequently your data source sends updates that are actually noops and how many queries per second Elasticsearch runs on the shard receiving the updates.
</p>
<p>
<strong>Versioning</strong>
</p>
<p>
Each indexed document is given a version number.
By default, internal versioning is used that starts at 1 and increments with each update, deletes included.
Optionally, the version number can be set to an external value (for example, if maintained in a database).
To enable this functionality, <code>version_type</code> should be set to <code>external</code>.
The value provided must be a numeric, long value greater than or equal to 0, and less than around <code>9.2e+18</code>.
</p>
<p>
NOTE: Versioning is completely real time, and is not affected by the near real time aspects of search operations.
If no version is provided, the operation runs without any version checks.
</p>
<p>
When using the external version type, the system checks to see if the version number passed to the index request is greater than the version of the currently stored document.
If true, the document will be indexed and the new version number used.
If the value provided is less than or equal to the stored document's version number, a version conflict will occur and the index operation will fail. For example:
</p>
<pre><code class="lang-csharp">PUT my-index-000001/_doc/1?version=2&amp;version_type=external
{
  "user": {
    "id": "elkbee"
  }
}

In this example, the operation will succeed since the supplied version of 2 is higher than the current document version of 1.
If the document was already updated and its version was set to 2 or higher, the indexing command will fail and result in a conflict (409 HTTP status code).

A nice side effect is that there is no need to maintain strict ordering of async indexing operations run as a result of changes to a source database, as long as version numbers from the source database are used.
Even the simple case of updating the Elasticsearch index using data from a database is simplified if external versioning is used, as only the latest version will be used if the index operations arrive out of order.</code></pre>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-index_.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;IndexResponse&gt; IndexAsync&lt;TDocument&gt;(TDocument document, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.IndexResponse.html">IndexResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Index_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Index*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Index__1_Elastic_Clients_Elasticsearch_IndexRequestDescriptor___0__" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Index``1(Elastic.Clients.Elasticsearch.IndexRequestDescriptor{``0})">
  Index&lt;TDocument&gt;(IndexRequestDescriptor&lt;TDocument&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L19385"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Create or update a document in an index.
</p>
<p>
Add a JSON document to the specified data stream or index and make it searchable.
If the target is an index and the document already exists, the request updates the document and increments its version.
</p>
<p>
NOTE: You cannot use this API to send update requests for existing documents in a data stream.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or index alias:
</p>
<ul><li>
<p>
To add or overwrite a document using the <code>PUT /&lt;target&gt;/_doc/&lt;_id&gt;</code> request format, you must have the <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To add a document using the <code>POST /&lt;target&gt;/_doc/</code> request format, you must have the <code>create_doc</code>, <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To automatically create a data stream or index with this API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege.
</p>
</li></ul>
<p>
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
NOTE: Replica shards might not all be started when an indexing operation returns successfully.
By default, only the primary is required. Set <code>wait_for_active_shards</code> to change this default behavior.
</p>
<p>
<strong>Automatically create data streams and indices</strong>
</p>
<p>
If the request's target doesn't exist and matches an index template with a <code>data_stream</code> definition, the index operation automatically creates the data stream.
</p>
<p>
If the target doesn't exist and doesn't match a data stream template, the operation automatically creates the index and applies any matching index templates.
</p>
<p>
NOTE: Elasticsearch includes several built-in index templates. To avoid naming collisions with these templates, refer to index pattern documentation.
</p>
<p>
If no mapping exists, the index operation creates a dynamic mapping.
By default, new fields and objects are automatically added to the mapping if needed.
</p>
<p>
Automatic index creation is controlled by the <code>action.auto_create_index</code> setting.
If it is <code>true</code>, any index can be created automatically.
You can modify this setting to explicitly allow or block automatic creation of indices that match specified patterns or set it to <code>false</code> to turn off automatic index creation entirely.
Specify a comma-separated list of patterns you want to allow or prefix each pattern with <code>+</code> or <code>-</code> to indicate whether it should be allowed or blocked.
When a list is specified, the default behaviour is to disallow.
</p>
<p>
NOTE: The <code>action.auto_create_index</code> setting affects the automatic creation of indices only.
It does not affect the creation of data streams.
</p>
<p>
<strong>Optimistic concurrency control</strong>
</p>
<p>
Index operations can be made conditional and only be performed if the last modification to the document was assigned the sequence number and primary term specified by the <code>if_seq_no</code> and <code>if_primary_term</code> parameters.
If a mismatch is detected, the operation will result in a <code>VersionConflictException</code> and a status code of <code>409</code>.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
By default, shard placement — or routing — is controlled by using a hash of the document's ID value.
For more explicit control, the value fed into the hash function used by the router can be directly specified on a per-operation basis using the <code>routing</code> parameter.
</p>
<p>
When setting up explicit mapping, you can also use the <code>_routing</code> field to direct the index operation to extract the routing value from the document itself.
This does come at the (very minimal) cost of an additional document parsing pass.
If the <code>_routing</code> mapping is defined and set to be required, the index operation will fail if no routing value is provided or extracted.
</p>
<p>
NOTE: Data streams do not support custom routing unless they were created with the <code>allow_custom_routing</code> setting enabled in the template.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The index operation is directed to the primary shard based on its route and performed on the actual node containing this shard.
After the primary shard completes the operation, if needed, the update is distributed to applicable replicas.
</p>
<p>
<strong>Active shards</strong>
</p>
<p>
To improve the resiliency of writes to the system, indexing operations can be configured to wait for a certain number of active shard copies before proceeding with the operation.
If the requisite number of active shard copies are not available, then the write operation must wait and retry, until either the requisite shard copies have started or a timeout occurs.
By default, write operations only wait for the primary shards to be active before proceeding (that is to say <code>wait_for_active_shards</code> is <code>1</code>).
This default can be overridden in the index settings dynamically by setting <code>index.write.wait_for_active_shards</code>.
To alter this behavior per operation, use the <code>wait_for_active_shards request</code> parameter.
</p>
<p>
Valid values are all or any positive integer up to the total number of configured copies per shard in the index (which is <code>number_of_replicas</code>+1).
Specifying a negative value or a number greater than the number of shard copies will throw an error.
</p>
<p>
For example, suppose you have a cluster of three nodes, A, B, and C and you create an index index with the number of replicas set to 3 (resulting in 4 shard copies, one more copy than there are nodes).
If you attempt an indexing operation, by default the operation will only ensure the primary copy of each shard is available before proceeding.
This means that even if B and C went down and A hosted the primary shard copies, the indexing operation would still proceed with only one copy of the data.
If <code>wait_for_active_shards</code> is set on the request to <code>3</code> (and all three nodes are up), the indexing operation will require 3 active shard copies before proceeding.
This requirement should be met because there are 3 active nodes in the cluster, each one holding a copy of the shard.
However, if you set <code>wait_for_active_shards</code> to <code>all</code> (or to <code>4</code>, which is the same in this situation), the indexing operation will not proceed as you do not have all 4 copies of each shard active in the index.
The operation will timeout unless a new node is brought up in the cluster to host the fourth copy of the shard.
</p>
<p>
It is important to note that this setting greatly reduces the chances of the write operation not writing to the requisite number of shard copies, but it does not completely eliminate the possibility, because this check occurs before the write operation starts.
After the write operation is underway, it is still possible for replication to fail on any number of shard copies but still succeed on the primary.
The <code>_shards</code> section of the API response reveals the number of shard copies on which replication succeeded and failed.
</p>
<p>
<strong>No operation (noop) updates</strong>
</p>
<p>
When updating a document by using this API, a new version of the document is always created even if the document hasn't changed.
If this isn't acceptable use the <code>_update</code> API with <code>detect_noop</code> set to <code>true</code>.
The <code>detect_noop</code> option isn't available on this API because it doesn’t fetch the old source and isn't able to compare it against the new source.
</p>
<p>
There isn't a definitive rule for when noop updates aren't acceptable.
It's a combination of lots of factors like how frequently your data source sends updates that are actually noops and how many queries per second Elasticsearch runs on the shard receiving the updates.
</p>
<p>
<strong>Versioning</strong>
</p>
<p>
Each indexed document is given a version number.
By default, internal versioning is used that starts at 1 and increments with each update, deletes included.
Optionally, the version number can be set to an external value (for example, if maintained in a database).
To enable this functionality, <code>version_type</code> should be set to <code>external</code>.
The value provided must be a numeric, long value greater than or equal to 0, and less than around <code>9.2e+18</code>.
</p>
<p>
NOTE: Versioning is completely real time, and is not affected by the near real time aspects of search operations.
If no version is provided, the operation runs without any version checks.
</p>
<p>
When using the external version type, the system checks to see if the version number passed to the index request is greater than the version of the currently stored document.
If true, the document will be indexed and the new version number used.
If the value provided is less than or equal to the stored document's version number, a version conflict will occur and the index operation will fail. For example:
</p>
<pre><code class="lang-csharp">PUT my-index-000001/_doc/1?version=2&amp;version_type=external
{
  "user": {
    "id": "elkbee"
  }
}

In this example, the operation will succeed since the supplied version of 2 is higher than the current document version of 1.
If the document was already updated and its version was set to 2 or higher, the indexing command will fail and result in a conflict (409 HTTP status code).

A nice side effect is that there is no need to maintain strict ordering of async indexing operations run as a result of changes to a source database, as long as version numbers from the source database are used.
Even the simple case of updating the Elasticsearch index using data from a database is simplified if external versioning is used, as only the latest version will be used if the index operations arrive out of order.</code></pre>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-index_.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual IndexResponse Index&lt;TDocument&gt;(IndexRequestDescriptor&lt;TDocument&gt; descriptor)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexRequestDescriptor-1.html">IndexRequestDescriptor</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.IndexResponse.html">IndexResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Index_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Index*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Index__1_Elastic_Clients_Elasticsearch_IndexRequest___0__" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Index``1(Elastic.Clients.Elasticsearch.IndexRequest{``0})">
  Index&lt;TDocument&gt;(IndexRequest&lt;TDocument&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L19034"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Create or update a document in an index.
</p>
<p>
Add a JSON document to the specified data stream or index and make it searchable.
If the target is an index and the document already exists, the request updates the document and increments its version.
</p>
<p>
NOTE: You cannot use this API to send update requests for existing documents in a data stream.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or index alias:
</p>
<ul><li>
<p>
To add or overwrite a document using the <code>PUT /&lt;target&gt;/_doc/&lt;_id&gt;</code> request format, you must have the <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To add a document using the <code>POST /&lt;target&gt;/_doc/</code> request format, you must have the <code>create_doc</code>, <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To automatically create a data stream or index with this API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege.
</p>
</li></ul>
<p>
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
NOTE: Replica shards might not all be started when an indexing operation returns successfully.
By default, only the primary is required. Set <code>wait_for_active_shards</code> to change this default behavior.
</p>
<p>
<strong>Automatically create data streams and indices</strong>
</p>
<p>
If the request's target doesn't exist and matches an index template with a <code>data_stream</code> definition, the index operation automatically creates the data stream.
</p>
<p>
If the target doesn't exist and doesn't match a data stream template, the operation automatically creates the index and applies any matching index templates.
</p>
<p>
NOTE: Elasticsearch includes several built-in index templates. To avoid naming collisions with these templates, refer to index pattern documentation.
</p>
<p>
If no mapping exists, the index operation creates a dynamic mapping.
By default, new fields and objects are automatically added to the mapping if needed.
</p>
<p>
Automatic index creation is controlled by the <code>action.auto_create_index</code> setting.
If it is <code>true</code>, any index can be created automatically.
You can modify this setting to explicitly allow or block automatic creation of indices that match specified patterns or set it to <code>false</code> to turn off automatic index creation entirely.
Specify a comma-separated list of patterns you want to allow or prefix each pattern with <code>+</code> or <code>-</code> to indicate whether it should be allowed or blocked.
When a list is specified, the default behaviour is to disallow.
</p>
<p>
NOTE: The <code>action.auto_create_index</code> setting affects the automatic creation of indices only.
It does not affect the creation of data streams.
</p>
<p>
<strong>Optimistic concurrency control</strong>
</p>
<p>
Index operations can be made conditional and only be performed if the last modification to the document was assigned the sequence number and primary term specified by the <code>if_seq_no</code> and <code>if_primary_term</code> parameters.
If a mismatch is detected, the operation will result in a <code>VersionConflictException</code> and a status code of <code>409</code>.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
By default, shard placement — or routing — is controlled by using a hash of the document's ID value.
For more explicit control, the value fed into the hash function used by the router can be directly specified on a per-operation basis using the <code>routing</code> parameter.
</p>
<p>
When setting up explicit mapping, you can also use the <code>_routing</code> field to direct the index operation to extract the routing value from the document itself.
This does come at the (very minimal) cost of an additional document parsing pass.
If the <code>_routing</code> mapping is defined and set to be required, the index operation will fail if no routing value is provided or extracted.
</p>
<p>
NOTE: Data streams do not support custom routing unless they were created with the <code>allow_custom_routing</code> setting enabled in the template.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The index operation is directed to the primary shard based on its route and performed on the actual node containing this shard.
After the primary shard completes the operation, if needed, the update is distributed to applicable replicas.
</p>
<p>
<strong>Active shards</strong>
</p>
<p>
To improve the resiliency of writes to the system, indexing operations can be configured to wait for a certain number of active shard copies before proceeding with the operation.
If the requisite number of active shard copies are not available, then the write operation must wait and retry, until either the requisite shard copies have started or a timeout occurs.
By default, write operations only wait for the primary shards to be active before proceeding (that is to say <code>wait_for_active_shards</code> is <code>1</code>).
This default can be overridden in the index settings dynamically by setting <code>index.write.wait_for_active_shards</code>.
To alter this behavior per operation, use the <code>wait_for_active_shards request</code> parameter.
</p>
<p>
Valid values are all or any positive integer up to the total number of configured copies per shard in the index (which is <code>number_of_replicas</code>+1).
Specifying a negative value or a number greater than the number of shard copies will throw an error.
</p>
<p>
For example, suppose you have a cluster of three nodes, A, B, and C and you create an index index with the number of replicas set to 3 (resulting in 4 shard copies, one more copy than there are nodes).
If you attempt an indexing operation, by default the operation will only ensure the primary copy of each shard is available before proceeding.
This means that even if B and C went down and A hosted the primary shard copies, the indexing operation would still proceed with only one copy of the data.
If <code>wait_for_active_shards</code> is set on the request to <code>3</code> (and all three nodes are up), the indexing operation will require 3 active shard copies before proceeding.
This requirement should be met because there are 3 active nodes in the cluster, each one holding a copy of the shard.
However, if you set <code>wait_for_active_shards</code> to <code>all</code> (or to <code>4</code>, which is the same in this situation), the indexing operation will not proceed as you do not have all 4 copies of each shard active in the index.
The operation will timeout unless a new node is brought up in the cluster to host the fourth copy of the shard.
</p>
<p>
It is important to note that this setting greatly reduces the chances of the write operation not writing to the requisite number of shard copies, but it does not completely eliminate the possibility, because this check occurs before the write operation starts.
After the write operation is underway, it is still possible for replication to fail on any number of shard copies but still succeed on the primary.
The <code>_shards</code> section of the API response reveals the number of shard copies on which replication succeeded and failed.
</p>
<p>
<strong>No operation (noop) updates</strong>
</p>
<p>
When updating a document by using this API, a new version of the document is always created even if the document hasn't changed.
If this isn't acceptable use the <code>_update</code> API with <code>detect_noop</code> set to <code>true</code>.
The <code>detect_noop</code> option isn't available on this API because it doesn’t fetch the old source and isn't able to compare it against the new source.
</p>
<p>
There isn't a definitive rule for when noop updates aren't acceptable.
It's a combination of lots of factors like how frequently your data source sends updates that are actually noops and how many queries per second Elasticsearch runs on the shard receiving the updates.
</p>
<p>
<strong>Versioning</strong>
</p>
<p>
Each indexed document is given a version number.
By default, internal versioning is used that starts at 1 and increments with each update, deletes included.
Optionally, the version number can be set to an external value (for example, if maintained in a database).
To enable this functionality, <code>version_type</code> should be set to <code>external</code>.
The value provided must be a numeric, long value greater than or equal to 0, and less than around <code>9.2e+18</code>.
</p>
<p>
NOTE: Versioning is completely real time, and is not affected by the near real time aspects of search operations.
If no version is provided, the operation runs without any version checks.
</p>
<p>
When using the external version type, the system checks to see if the version number passed to the index request is greater than the version of the currently stored document.
If true, the document will be indexed and the new version number used.
If the value provided is less than or equal to the stored document's version number, a version conflict will occur and the index operation will fail. For example:
</p>
<pre><code class="lang-csharp">PUT my-index-000001/_doc/1?version=2&amp;version_type=external
{
  "user": {
    "id": "elkbee"
  }
}

In this example, the operation will succeed since the supplied version of 2 is higher than the current document version of 1.
If the document was already updated and its version was set to 2 or higher, the indexing command will fail and result in a conflict (409 HTTP status code).

A nice side effect is that there is no need to maintain strict ordering of async indexing operations run as a result of changes to a source database, as long as version numbers from the source database are used.
Even the simple case of updating the Elasticsearch index using data from a database is simplified if external versioning is used, as only the latest version will be used if the index operations arrive out of order.</code></pre>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-index_.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual IndexResponse Index&lt;TDocument&gt;(IndexRequest&lt;TDocument&gt; request)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexRequest-1.html">IndexRequest</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.IndexResponse.html">IndexResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Index_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Index*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Index__1___0_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Index``1(``0)">
  Index&lt;TDocument&gt;(TDocument)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L19916"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Create or update a document in an index.
</p>
<p>
Add a JSON document to the specified data stream or index and make it searchable.
If the target is an index and the document already exists, the request updates the document and increments its version.
</p>
<p>
NOTE: You cannot use this API to send update requests for existing documents in a data stream.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or index alias:
</p>
<ul><li>
<p>
To add or overwrite a document using the <code>PUT /&lt;target&gt;/_doc/&lt;_id&gt;</code> request format, you must have the <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To add a document using the <code>POST /&lt;target&gt;/_doc/</code> request format, you must have the <code>create_doc</code>, <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To automatically create a data stream or index with this API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege.
</p>
</li></ul>
<p>
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
NOTE: Replica shards might not all be started when an indexing operation returns successfully.
By default, only the primary is required. Set <code>wait_for_active_shards</code> to change this default behavior.
</p>
<p>
<strong>Automatically create data streams and indices</strong>
</p>
<p>
If the request's target doesn't exist and matches an index template with a <code>data_stream</code> definition, the index operation automatically creates the data stream.
</p>
<p>
If the target doesn't exist and doesn't match a data stream template, the operation automatically creates the index and applies any matching index templates.
</p>
<p>
NOTE: Elasticsearch includes several built-in index templates. To avoid naming collisions with these templates, refer to index pattern documentation.
</p>
<p>
If no mapping exists, the index operation creates a dynamic mapping.
By default, new fields and objects are automatically added to the mapping if needed.
</p>
<p>
Automatic index creation is controlled by the <code>action.auto_create_index</code> setting.
If it is <code>true</code>, any index can be created automatically.
You can modify this setting to explicitly allow or block automatic creation of indices that match specified patterns or set it to <code>false</code> to turn off automatic index creation entirely.
Specify a comma-separated list of patterns you want to allow or prefix each pattern with <code>+</code> or <code>-</code> to indicate whether it should be allowed or blocked.
When a list is specified, the default behaviour is to disallow.
</p>
<p>
NOTE: The <code>action.auto_create_index</code> setting affects the automatic creation of indices only.
It does not affect the creation of data streams.
</p>
<p>
<strong>Optimistic concurrency control</strong>
</p>
<p>
Index operations can be made conditional and only be performed if the last modification to the document was assigned the sequence number and primary term specified by the <code>if_seq_no</code> and <code>if_primary_term</code> parameters.
If a mismatch is detected, the operation will result in a <code>VersionConflictException</code> and a status code of <code>409</code>.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
By default, shard placement — or routing — is controlled by using a hash of the document's ID value.
For more explicit control, the value fed into the hash function used by the router can be directly specified on a per-operation basis using the <code>routing</code> parameter.
</p>
<p>
When setting up explicit mapping, you can also use the <code>_routing</code> field to direct the index operation to extract the routing value from the document itself.
This does come at the (very minimal) cost of an additional document parsing pass.
If the <code>_routing</code> mapping is defined and set to be required, the index operation will fail if no routing value is provided or extracted.
</p>
<p>
NOTE: Data streams do not support custom routing unless they were created with the <code>allow_custom_routing</code> setting enabled in the template.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The index operation is directed to the primary shard based on its route and performed on the actual node containing this shard.
After the primary shard completes the operation, if needed, the update is distributed to applicable replicas.
</p>
<p>
<strong>Active shards</strong>
</p>
<p>
To improve the resiliency of writes to the system, indexing operations can be configured to wait for a certain number of active shard copies before proceeding with the operation.
If the requisite number of active shard copies are not available, then the write operation must wait and retry, until either the requisite shard copies have started or a timeout occurs.
By default, write operations only wait for the primary shards to be active before proceeding (that is to say <code>wait_for_active_shards</code> is <code>1</code>).
This default can be overridden in the index settings dynamically by setting <code>index.write.wait_for_active_shards</code>.
To alter this behavior per operation, use the <code>wait_for_active_shards request</code> parameter.
</p>
<p>
Valid values are all or any positive integer up to the total number of configured copies per shard in the index (which is <code>number_of_replicas</code>+1).
Specifying a negative value or a number greater than the number of shard copies will throw an error.
</p>
<p>
For example, suppose you have a cluster of three nodes, A, B, and C and you create an index index with the number of replicas set to 3 (resulting in 4 shard copies, one more copy than there are nodes).
If you attempt an indexing operation, by default the operation will only ensure the primary copy of each shard is available before proceeding.
This means that even if B and C went down and A hosted the primary shard copies, the indexing operation would still proceed with only one copy of the data.
If <code>wait_for_active_shards</code> is set on the request to <code>3</code> (and all three nodes are up), the indexing operation will require 3 active shard copies before proceeding.
This requirement should be met because there are 3 active nodes in the cluster, each one holding a copy of the shard.
However, if you set <code>wait_for_active_shards</code> to <code>all</code> (or to <code>4</code>, which is the same in this situation), the indexing operation will not proceed as you do not have all 4 copies of each shard active in the index.
The operation will timeout unless a new node is brought up in the cluster to host the fourth copy of the shard.
</p>
<p>
It is important to note that this setting greatly reduces the chances of the write operation not writing to the requisite number of shard copies, but it does not completely eliminate the possibility, because this check occurs before the write operation starts.
After the write operation is underway, it is still possible for replication to fail on any number of shard copies but still succeed on the primary.
The <code>_shards</code> section of the API response reveals the number of shard copies on which replication succeeded and failed.
</p>
<p>
<strong>No operation (noop) updates</strong>
</p>
<p>
When updating a document by using this API, a new version of the document is always created even if the document hasn't changed.
If this isn't acceptable use the <code>_update</code> API with <code>detect_noop</code> set to <code>true</code>.
The <code>detect_noop</code> option isn't available on this API because it doesn’t fetch the old source and isn't able to compare it against the new source.
</p>
<p>
There isn't a definitive rule for when noop updates aren't acceptable.
It's a combination of lots of factors like how frequently your data source sends updates that are actually noops and how many queries per second Elasticsearch runs on the shard receiving the updates.
</p>
<p>
<strong>Versioning</strong>
</p>
<p>
Each indexed document is given a version number.
By default, internal versioning is used that starts at 1 and increments with each update, deletes included.
Optionally, the version number can be set to an external value (for example, if maintained in a database).
To enable this functionality, <code>version_type</code> should be set to <code>external</code>.
The value provided must be a numeric, long value greater than or equal to 0, and less than around <code>9.2e+18</code>.
</p>
<p>
NOTE: Versioning is completely real time, and is not affected by the near real time aspects of search operations.
If no version is provided, the operation runs without any version checks.
</p>
<p>
When using the external version type, the system checks to see if the version number passed to the index request is greater than the version of the currently stored document.
If true, the document will be indexed and the new version number used.
If the value provided is less than or equal to the stored document's version number, a version conflict will occur and the index operation will fail. For example:
</p>
<pre><code class="lang-csharp">PUT my-index-000001/_doc/1?version=2&amp;version_type=external
{
  "user": {
    "id": "elkbee"
  }
}

In this example, the operation will succeed since the supplied version of 2 is higher than the current document version of 1.
If the document was already updated and its version was set to 2 or higher, the indexing command will fail and result in a conflict (409 HTTP status code).

A nice side effect is that there is no need to maintain strict ordering of async indexing operations run as a result of changes to a source database, as long as version numbers from the source database are used.
Even the simple case of updating the Elasticsearch index using data from a database is simplified if external versioning is used, as only the latest version will be used if the index operations arrive out of order.</code></pre>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-index_.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual IndexResponse Index&lt;TDocument&gt;(TDocument document)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.IndexResponse.html">IndexResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Index_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Index*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Index__1___0_Elastic_Clients_Elasticsearch_Id_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Index``1(``0,Elastic.Clients.Elasticsearch.Id)">
  Index&lt;TDocument&gt;(TDocument, Id?)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L20626"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Create or update a document in an index.
</p>
<p>
Add a JSON document to the specified data stream or index and make it searchable.
If the target is an index and the document already exists, the request updates the document and increments its version.
</p>
<p>
NOTE: You cannot use this API to send update requests for existing documents in a data stream.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or index alias:
</p>
<ul><li>
<p>
To add or overwrite a document using the <code>PUT /&lt;target&gt;/_doc/&lt;_id&gt;</code> request format, you must have the <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To add a document using the <code>POST /&lt;target&gt;/_doc/</code> request format, you must have the <code>create_doc</code>, <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To automatically create a data stream or index with this API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege.
</p>
</li></ul>
<p>
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
NOTE: Replica shards might not all be started when an indexing operation returns successfully.
By default, only the primary is required. Set <code>wait_for_active_shards</code> to change this default behavior.
</p>
<p>
<strong>Automatically create data streams and indices</strong>
</p>
<p>
If the request's target doesn't exist and matches an index template with a <code>data_stream</code> definition, the index operation automatically creates the data stream.
</p>
<p>
If the target doesn't exist and doesn't match a data stream template, the operation automatically creates the index and applies any matching index templates.
</p>
<p>
NOTE: Elasticsearch includes several built-in index templates. To avoid naming collisions with these templates, refer to index pattern documentation.
</p>
<p>
If no mapping exists, the index operation creates a dynamic mapping.
By default, new fields and objects are automatically added to the mapping if needed.
</p>
<p>
Automatic index creation is controlled by the <code>action.auto_create_index</code> setting.
If it is <code>true</code>, any index can be created automatically.
You can modify this setting to explicitly allow or block automatic creation of indices that match specified patterns or set it to <code>false</code> to turn off automatic index creation entirely.
Specify a comma-separated list of patterns you want to allow or prefix each pattern with <code>+</code> or <code>-</code> to indicate whether it should be allowed or blocked.
When a list is specified, the default behaviour is to disallow.
</p>
<p>
NOTE: The <code>action.auto_create_index</code> setting affects the automatic creation of indices only.
It does not affect the creation of data streams.
</p>
<p>
<strong>Optimistic concurrency control</strong>
</p>
<p>
Index operations can be made conditional and only be performed if the last modification to the document was assigned the sequence number and primary term specified by the <code>if_seq_no</code> and <code>if_primary_term</code> parameters.
If a mismatch is detected, the operation will result in a <code>VersionConflictException</code> and a status code of <code>409</code>.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
By default, shard placement — or routing — is controlled by using a hash of the document's ID value.
For more explicit control, the value fed into the hash function used by the router can be directly specified on a per-operation basis using the <code>routing</code> parameter.
</p>
<p>
When setting up explicit mapping, you can also use the <code>_routing</code> field to direct the index operation to extract the routing value from the document itself.
This does come at the (very minimal) cost of an additional document parsing pass.
If the <code>_routing</code> mapping is defined and set to be required, the index operation will fail if no routing value is provided or extracted.
</p>
<p>
NOTE: Data streams do not support custom routing unless they were created with the <code>allow_custom_routing</code> setting enabled in the template.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The index operation is directed to the primary shard based on its route and performed on the actual node containing this shard.
After the primary shard completes the operation, if needed, the update is distributed to applicable replicas.
</p>
<p>
<strong>Active shards</strong>
</p>
<p>
To improve the resiliency of writes to the system, indexing operations can be configured to wait for a certain number of active shard copies before proceeding with the operation.
If the requisite number of active shard copies are not available, then the write operation must wait and retry, until either the requisite shard copies have started or a timeout occurs.
By default, write operations only wait for the primary shards to be active before proceeding (that is to say <code>wait_for_active_shards</code> is <code>1</code>).
This default can be overridden in the index settings dynamically by setting <code>index.write.wait_for_active_shards</code>.
To alter this behavior per operation, use the <code>wait_for_active_shards request</code> parameter.
</p>
<p>
Valid values are all or any positive integer up to the total number of configured copies per shard in the index (which is <code>number_of_replicas</code>+1).
Specifying a negative value or a number greater than the number of shard copies will throw an error.
</p>
<p>
For example, suppose you have a cluster of three nodes, A, B, and C and you create an index index with the number of replicas set to 3 (resulting in 4 shard copies, one more copy than there are nodes).
If you attempt an indexing operation, by default the operation will only ensure the primary copy of each shard is available before proceeding.
This means that even if B and C went down and A hosted the primary shard copies, the indexing operation would still proceed with only one copy of the data.
If <code>wait_for_active_shards</code> is set on the request to <code>3</code> (and all three nodes are up), the indexing operation will require 3 active shard copies before proceeding.
This requirement should be met because there are 3 active nodes in the cluster, each one holding a copy of the shard.
However, if you set <code>wait_for_active_shards</code> to <code>all</code> (or to <code>4</code>, which is the same in this situation), the indexing operation will not proceed as you do not have all 4 copies of each shard active in the index.
The operation will timeout unless a new node is brought up in the cluster to host the fourth copy of the shard.
</p>
<p>
It is important to note that this setting greatly reduces the chances of the write operation not writing to the requisite number of shard copies, but it does not completely eliminate the possibility, because this check occurs before the write operation starts.
After the write operation is underway, it is still possible for replication to fail on any number of shard copies but still succeed on the primary.
The <code>_shards</code> section of the API response reveals the number of shard copies on which replication succeeded and failed.
</p>
<p>
<strong>No operation (noop) updates</strong>
</p>
<p>
When updating a document by using this API, a new version of the document is always created even if the document hasn't changed.
If this isn't acceptable use the <code>_update</code> API with <code>detect_noop</code> set to <code>true</code>.
The <code>detect_noop</code> option isn't available on this API because it doesn’t fetch the old source and isn't able to compare it against the new source.
</p>
<p>
There isn't a definitive rule for when noop updates aren't acceptable.
It's a combination of lots of factors like how frequently your data source sends updates that are actually noops and how many queries per second Elasticsearch runs on the shard receiving the updates.
</p>
<p>
<strong>Versioning</strong>
</p>
<p>
Each indexed document is given a version number.
By default, internal versioning is used that starts at 1 and increments with each update, deletes included.
Optionally, the version number can be set to an external value (for example, if maintained in a database).
To enable this functionality, <code>version_type</code> should be set to <code>external</code>.
The value provided must be a numeric, long value greater than or equal to 0, and less than around <code>9.2e+18</code>.
</p>
<p>
NOTE: Versioning is completely real time, and is not affected by the near real time aspects of search operations.
If no version is provided, the operation runs without any version checks.
</p>
<p>
When using the external version type, the system checks to see if the version number passed to the index request is greater than the version of the currently stored document.
If true, the document will be indexed and the new version number used.
If the value provided is less than or equal to the stored document's version number, a version conflict will occur and the index operation will fail. For example:
</p>
<pre><code class="lang-csharp">PUT my-index-000001/_doc/1?version=2&amp;version_type=external
{
  "user": {
    "id": "elkbee"
  }
}

In this example, the operation will succeed since the supplied version of 2 is higher than the current document version of 1.
If the document was already updated and its version was set to 2 or higher, the indexing command will fail and result in a conflict (409 HTTP status code).

A nice side effect is that there is no need to maintain strict ordering of async indexing operations run as a result of changes to a source database, as long as version numbers from the source database are used.
Even the simple case of updating the Elasticsearch index using data from a database is simplified if external versioning is used, as only the latest version will be used if the index operations arrive out of order.</code></pre>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-index_.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual IndexResponse Index&lt;TDocument&gt;(TDocument document, Id? id)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.IndexResponse.html">IndexResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Index_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Index*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Index__1___0_Elastic_Clients_Elasticsearch_Id_System_Action_Elastic_Clients_Elasticsearch_IndexRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Index``1(``0,Elastic.Clients.Elasticsearch.Id,System.Action{Elastic.Clients.Elasticsearch.IndexRequestDescriptor{``0}})">
  Index&lt;TDocument&gt;(TDocument, Id?, Action&lt;IndexRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L20803"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Create or update a document in an index.
</p>
<p>
Add a JSON document to the specified data stream or index and make it searchable.
If the target is an index and the document already exists, the request updates the document and increments its version.
</p>
<p>
NOTE: You cannot use this API to send update requests for existing documents in a data stream.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or index alias:
</p>
<ul><li>
<p>
To add or overwrite a document using the <code>PUT /&lt;target&gt;/_doc/&lt;_id&gt;</code> request format, you must have the <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To add a document using the <code>POST /&lt;target&gt;/_doc/</code> request format, you must have the <code>create_doc</code>, <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To automatically create a data stream or index with this API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege.
</p>
</li></ul>
<p>
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
NOTE: Replica shards might not all be started when an indexing operation returns successfully.
By default, only the primary is required. Set <code>wait_for_active_shards</code> to change this default behavior.
</p>
<p>
<strong>Automatically create data streams and indices</strong>
</p>
<p>
If the request's target doesn't exist and matches an index template with a <code>data_stream</code> definition, the index operation automatically creates the data stream.
</p>
<p>
If the target doesn't exist and doesn't match a data stream template, the operation automatically creates the index and applies any matching index templates.
</p>
<p>
NOTE: Elasticsearch includes several built-in index templates. To avoid naming collisions with these templates, refer to index pattern documentation.
</p>
<p>
If no mapping exists, the index operation creates a dynamic mapping.
By default, new fields and objects are automatically added to the mapping if needed.
</p>
<p>
Automatic index creation is controlled by the <code>action.auto_create_index</code> setting.
If it is <code>true</code>, any index can be created automatically.
You can modify this setting to explicitly allow or block automatic creation of indices that match specified patterns or set it to <code>false</code> to turn off automatic index creation entirely.
Specify a comma-separated list of patterns you want to allow or prefix each pattern with <code>+</code> or <code>-</code> to indicate whether it should be allowed or blocked.
When a list is specified, the default behaviour is to disallow.
</p>
<p>
NOTE: The <code>action.auto_create_index</code> setting affects the automatic creation of indices only.
It does not affect the creation of data streams.
</p>
<p>
<strong>Optimistic concurrency control</strong>
</p>
<p>
Index operations can be made conditional and only be performed if the last modification to the document was assigned the sequence number and primary term specified by the <code>if_seq_no</code> and <code>if_primary_term</code> parameters.
If a mismatch is detected, the operation will result in a <code>VersionConflictException</code> and a status code of <code>409</code>.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
By default, shard placement — or routing — is controlled by using a hash of the document's ID value.
For more explicit control, the value fed into the hash function used by the router can be directly specified on a per-operation basis using the <code>routing</code> parameter.
</p>
<p>
When setting up explicit mapping, you can also use the <code>_routing</code> field to direct the index operation to extract the routing value from the document itself.
This does come at the (very minimal) cost of an additional document parsing pass.
If the <code>_routing</code> mapping is defined and set to be required, the index operation will fail if no routing value is provided or extracted.
</p>
<p>
NOTE: Data streams do not support custom routing unless they were created with the <code>allow_custom_routing</code> setting enabled in the template.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The index operation is directed to the primary shard based on its route and performed on the actual node containing this shard.
After the primary shard completes the operation, if needed, the update is distributed to applicable replicas.
</p>
<p>
<strong>Active shards</strong>
</p>
<p>
To improve the resiliency of writes to the system, indexing operations can be configured to wait for a certain number of active shard copies before proceeding with the operation.
If the requisite number of active shard copies are not available, then the write operation must wait and retry, until either the requisite shard copies have started or a timeout occurs.
By default, write operations only wait for the primary shards to be active before proceeding (that is to say <code>wait_for_active_shards</code> is <code>1</code>).
This default can be overridden in the index settings dynamically by setting <code>index.write.wait_for_active_shards</code>.
To alter this behavior per operation, use the <code>wait_for_active_shards request</code> parameter.
</p>
<p>
Valid values are all or any positive integer up to the total number of configured copies per shard in the index (which is <code>number_of_replicas</code>+1).
Specifying a negative value or a number greater than the number of shard copies will throw an error.
</p>
<p>
For example, suppose you have a cluster of three nodes, A, B, and C and you create an index index with the number of replicas set to 3 (resulting in 4 shard copies, one more copy than there are nodes).
If you attempt an indexing operation, by default the operation will only ensure the primary copy of each shard is available before proceeding.
This means that even if B and C went down and A hosted the primary shard copies, the indexing operation would still proceed with only one copy of the data.
If <code>wait_for_active_shards</code> is set on the request to <code>3</code> (and all three nodes are up), the indexing operation will require 3 active shard copies before proceeding.
This requirement should be met because there are 3 active nodes in the cluster, each one holding a copy of the shard.
However, if you set <code>wait_for_active_shards</code> to <code>all</code> (or to <code>4</code>, which is the same in this situation), the indexing operation will not proceed as you do not have all 4 copies of each shard active in the index.
The operation will timeout unless a new node is brought up in the cluster to host the fourth copy of the shard.
</p>
<p>
It is important to note that this setting greatly reduces the chances of the write operation not writing to the requisite number of shard copies, but it does not completely eliminate the possibility, because this check occurs before the write operation starts.
After the write operation is underway, it is still possible for replication to fail on any number of shard copies but still succeed on the primary.
The <code>_shards</code> section of the API response reveals the number of shard copies on which replication succeeded and failed.
</p>
<p>
<strong>No operation (noop) updates</strong>
</p>
<p>
When updating a document by using this API, a new version of the document is always created even if the document hasn't changed.
If this isn't acceptable use the <code>_update</code> API with <code>detect_noop</code> set to <code>true</code>.
The <code>detect_noop</code> option isn't available on this API because it doesn’t fetch the old source and isn't able to compare it against the new source.
</p>
<p>
There isn't a definitive rule for when noop updates aren't acceptable.
It's a combination of lots of factors like how frequently your data source sends updates that are actually noops and how many queries per second Elasticsearch runs on the shard receiving the updates.
</p>
<p>
<strong>Versioning</strong>
</p>
<p>
Each indexed document is given a version number.
By default, internal versioning is used that starts at 1 and increments with each update, deletes included.
Optionally, the version number can be set to an external value (for example, if maintained in a database).
To enable this functionality, <code>version_type</code> should be set to <code>external</code>.
The value provided must be a numeric, long value greater than or equal to 0, and less than around <code>9.2e+18</code>.
</p>
<p>
NOTE: Versioning is completely real time, and is not affected by the near real time aspects of search operations.
If no version is provided, the operation runs without any version checks.
</p>
<p>
When using the external version type, the system checks to see if the version number passed to the index request is greater than the version of the currently stored document.
If true, the document will be indexed and the new version number used.
If the value provided is less than or equal to the stored document's version number, a version conflict will occur and the index operation will fail. For example:
</p>
<pre><code class="lang-csharp">PUT my-index-000001/_doc/1?version=2&amp;version_type=external
{
  "user": {
    "id": "elkbee"
  }
}

In this example, the operation will succeed since the supplied version of 2 is higher than the current document version of 1.
If the document was already updated and its version was set to 2 or higher, the indexing command will fail and result in a conflict (409 HTTP status code).

A nice side effect is that there is no need to maintain strict ordering of async indexing operations run as a result of changes to a source database, as long as version numbers from the source database are used.
Even the simple case of updating the Elasticsearch index using data from a database is simplified if external versioning is used, as only the latest version will be used if the index operations arrive out of order.</code></pre>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-index_.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual IndexResponse Index&lt;TDocument&gt;(TDocument document, Id? id, Action&lt;IndexRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.IndexRequestDescriptor-1.html">IndexRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.IndexResponse.html">IndexResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Index_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Index*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Index__1___0_Elastic_Clients_Elasticsearch_IndexName_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Index``1(``0,Elastic.Clients.Elasticsearch.IndexName)">
  Index&lt;TDocument&gt;(TDocument, IndexName)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L20271"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Create or update a document in an index.
</p>
<p>
Add a JSON document to the specified data stream or index and make it searchable.
If the target is an index and the document already exists, the request updates the document and increments its version.
</p>
<p>
NOTE: You cannot use this API to send update requests for existing documents in a data stream.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or index alias:
</p>
<ul><li>
<p>
To add or overwrite a document using the <code>PUT /&lt;target&gt;/_doc/&lt;_id&gt;</code> request format, you must have the <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To add a document using the <code>POST /&lt;target&gt;/_doc/</code> request format, you must have the <code>create_doc</code>, <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To automatically create a data stream or index with this API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege.
</p>
</li></ul>
<p>
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
NOTE: Replica shards might not all be started when an indexing operation returns successfully.
By default, only the primary is required. Set <code>wait_for_active_shards</code> to change this default behavior.
</p>
<p>
<strong>Automatically create data streams and indices</strong>
</p>
<p>
If the request's target doesn't exist and matches an index template with a <code>data_stream</code> definition, the index operation automatically creates the data stream.
</p>
<p>
If the target doesn't exist and doesn't match a data stream template, the operation automatically creates the index and applies any matching index templates.
</p>
<p>
NOTE: Elasticsearch includes several built-in index templates. To avoid naming collisions with these templates, refer to index pattern documentation.
</p>
<p>
If no mapping exists, the index operation creates a dynamic mapping.
By default, new fields and objects are automatically added to the mapping if needed.
</p>
<p>
Automatic index creation is controlled by the <code>action.auto_create_index</code> setting.
If it is <code>true</code>, any index can be created automatically.
You can modify this setting to explicitly allow or block automatic creation of indices that match specified patterns or set it to <code>false</code> to turn off automatic index creation entirely.
Specify a comma-separated list of patterns you want to allow or prefix each pattern with <code>+</code> or <code>-</code> to indicate whether it should be allowed or blocked.
When a list is specified, the default behaviour is to disallow.
</p>
<p>
NOTE: The <code>action.auto_create_index</code> setting affects the automatic creation of indices only.
It does not affect the creation of data streams.
</p>
<p>
<strong>Optimistic concurrency control</strong>
</p>
<p>
Index operations can be made conditional and only be performed if the last modification to the document was assigned the sequence number and primary term specified by the <code>if_seq_no</code> and <code>if_primary_term</code> parameters.
If a mismatch is detected, the operation will result in a <code>VersionConflictException</code> and a status code of <code>409</code>.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
By default, shard placement — or routing — is controlled by using a hash of the document's ID value.
For more explicit control, the value fed into the hash function used by the router can be directly specified on a per-operation basis using the <code>routing</code> parameter.
</p>
<p>
When setting up explicit mapping, you can also use the <code>_routing</code> field to direct the index operation to extract the routing value from the document itself.
This does come at the (very minimal) cost of an additional document parsing pass.
If the <code>_routing</code> mapping is defined and set to be required, the index operation will fail if no routing value is provided or extracted.
</p>
<p>
NOTE: Data streams do not support custom routing unless they were created with the <code>allow_custom_routing</code> setting enabled in the template.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The index operation is directed to the primary shard based on its route and performed on the actual node containing this shard.
After the primary shard completes the operation, if needed, the update is distributed to applicable replicas.
</p>
<p>
<strong>Active shards</strong>
</p>
<p>
To improve the resiliency of writes to the system, indexing operations can be configured to wait for a certain number of active shard copies before proceeding with the operation.
If the requisite number of active shard copies are not available, then the write operation must wait and retry, until either the requisite shard copies have started or a timeout occurs.
By default, write operations only wait for the primary shards to be active before proceeding (that is to say <code>wait_for_active_shards</code> is <code>1</code>).
This default can be overridden in the index settings dynamically by setting <code>index.write.wait_for_active_shards</code>.
To alter this behavior per operation, use the <code>wait_for_active_shards request</code> parameter.
</p>
<p>
Valid values are all or any positive integer up to the total number of configured copies per shard in the index (which is <code>number_of_replicas</code>+1).
Specifying a negative value or a number greater than the number of shard copies will throw an error.
</p>
<p>
For example, suppose you have a cluster of three nodes, A, B, and C and you create an index index with the number of replicas set to 3 (resulting in 4 shard copies, one more copy than there are nodes).
If you attempt an indexing operation, by default the operation will only ensure the primary copy of each shard is available before proceeding.
This means that even if B and C went down and A hosted the primary shard copies, the indexing operation would still proceed with only one copy of the data.
If <code>wait_for_active_shards</code> is set on the request to <code>3</code> (and all three nodes are up), the indexing operation will require 3 active shard copies before proceeding.
This requirement should be met because there are 3 active nodes in the cluster, each one holding a copy of the shard.
However, if you set <code>wait_for_active_shards</code> to <code>all</code> (or to <code>4</code>, which is the same in this situation), the indexing operation will not proceed as you do not have all 4 copies of each shard active in the index.
The operation will timeout unless a new node is brought up in the cluster to host the fourth copy of the shard.
</p>
<p>
It is important to note that this setting greatly reduces the chances of the write operation not writing to the requisite number of shard copies, but it does not completely eliminate the possibility, because this check occurs before the write operation starts.
After the write operation is underway, it is still possible for replication to fail on any number of shard copies but still succeed on the primary.
The <code>_shards</code> section of the API response reveals the number of shard copies on which replication succeeded and failed.
</p>
<p>
<strong>No operation (noop) updates</strong>
</p>
<p>
When updating a document by using this API, a new version of the document is always created even if the document hasn't changed.
If this isn't acceptable use the <code>_update</code> API with <code>detect_noop</code> set to <code>true</code>.
The <code>detect_noop</code> option isn't available on this API because it doesn’t fetch the old source and isn't able to compare it against the new source.
</p>
<p>
There isn't a definitive rule for when noop updates aren't acceptable.
It's a combination of lots of factors like how frequently your data source sends updates that are actually noops and how many queries per second Elasticsearch runs on the shard receiving the updates.
</p>
<p>
<strong>Versioning</strong>
</p>
<p>
Each indexed document is given a version number.
By default, internal versioning is used that starts at 1 and increments with each update, deletes included.
Optionally, the version number can be set to an external value (for example, if maintained in a database).
To enable this functionality, <code>version_type</code> should be set to <code>external</code>.
The value provided must be a numeric, long value greater than or equal to 0, and less than around <code>9.2e+18</code>.
</p>
<p>
NOTE: Versioning is completely real time, and is not affected by the near real time aspects of search operations.
If no version is provided, the operation runs without any version checks.
</p>
<p>
When using the external version type, the system checks to see if the version number passed to the index request is greater than the version of the currently stored document.
If true, the document will be indexed and the new version number used.
If the value provided is less than or equal to the stored document's version number, a version conflict will occur and the index operation will fail. For example:
</p>
<pre><code class="lang-csharp">PUT my-index-000001/_doc/1?version=2&amp;version_type=external
{
  "user": {
    "id": "elkbee"
  }
}

In this example, the operation will succeed since the supplied version of 2 is higher than the current document version of 1.
If the document was already updated and its version was set to 2 or higher, the indexing command will fail and result in a conflict (409 HTTP status code).

A nice side effect is that there is no need to maintain strict ordering of async indexing operations run as a result of changes to a source database, as long as version numbers from the source database are used.
Even the simple case of updating the Elasticsearch index using data from a database is simplified if external versioning is used, as only the latest version will be used if the index operations arrive out of order.</code></pre>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-index_.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual IndexResponse Index&lt;TDocument&gt;(TDocument document, IndexName index)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.IndexResponse.html">IndexResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Index_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Index*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Index__1___0_Elastic_Clients_Elasticsearch_IndexName_Elastic_Clients_Elasticsearch_Id_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Index``1(``0,Elastic.Clients.Elasticsearch.IndexName,Elastic.Clients.Elasticsearch.Id)">
  Index&lt;TDocument&gt;(TDocument, IndexName, Id?)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L19561"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Create or update a document in an index.
</p>
<p>
Add a JSON document to the specified data stream or index and make it searchable.
If the target is an index and the document already exists, the request updates the document and increments its version.
</p>
<p>
NOTE: You cannot use this API to send update requests for existing documents in a data stream.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or index alias:
</p>
<ul><li>
<p>
To add or overwrite a document using the <code>PUT /&lt;target&gt;/_doc/&lt;_id&gt;</code> request format, you must have the <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To add a document using the <code>POST /&lt;target&gt;/_doc/</code> request format, you must have the <code>create_doc</code>, <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To automatically create a data stream or index with this API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege.
</p>
</li></ul>
<p>
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
NOTE: Replica shards might not all be started when an indexing operation returns successfully.
By default, only the primary is required. Set <code>wait_for_active_shards</code> to change this default behavior.
</p>
<p>
<strong>Automatically create data streams and indices</strong>
</p>
<p>
If the request's target doesn't exist and matches an index template with a <code>data_stream</code> definition, the index operation automatically creates the data stream.
</p>
<p>
If the target doesn't exist and doesn't match a data stream template, the operation automatically creates the index and applies any matching index templates.
</p>
<p>
NOTE: Elasticsearch includes several built-in index templates. To avoid naming collisions with these templates, refer to index pattern documentation.
</p>
<p>
If no mapping exists, the index operation creates a dynamic mapping.
By default, new fields and objects are automatically added to the mapping if needed.
</p>
<p>
Automatic index creation is controlled by the <code>action.auto_create_index</code> setting.
If it is <code>true</code>, any index can be created automatically.
You can modify this setting to explicitly allow or block automatic creation of indices that match specified patterns or set it to <code>false</code> to turn off automatic index creation entirely.
Specify a comma-separated list of patterns you want to allow or prefix each pattern with <code>+</code> or <code>-</code> to indicate whether it should be allowed or blocked.
When a list is specified, the default behaviour is to disallow.
</p>
<p>
NOTE: The <code>action.auto_create_index</code> setting affects the automatic creation of indices only.
It does not affect the creation of data streams.
</p>
<p>
<strong>Optimistic concurrency control</strong>
</p>
<p>
Index operations can be made conditional and only be performed if the last modification to the document was assigned the sequence number and primary term specified by the <code>if_seq_no</code> and <code>if_primary_term</code> parameters.
If a mismatch is detected, the operation will result in a <code>VersionConflictException</code> and a status code of <code>409</code>.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
By default, shard placement — or routing — is controlled by using a hash of the document's ID value.
For more explicit control, the value fed into the hash function used by the router can be directly specified on a per-operation basis using the <code>routing</code> parameter.
</p>
<p>
When setting up explicit mapping, you can also use the <code>_routing</code> field to direct the index operation to extract the routing value from the document itself.
This does come at the (very minimal) cost of an additional document parsing pass.
If the <code>_routing</code> mapping is defined and set to be required, the index operation will fail if no routing value is provided or extracted.
</p>
<p>
NOTE: Data streams do not support custom routing unless they were created with the <code>allow_custom_routing</code> setting enabled in the template.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The index operation is directed to the primary shard based on its route and performed on the actual node containing this shard.
After the primary shard completes the operation, if needed, the update is distributed to applicable replicas.
</p>
<p>
<strong>Active shards</strong>
</p>
<p>
To improve the resiliency of writes to the system, indexing operations can be configured to wait for a certain number of active shard copies before proceeding with the operation.
If the requisite number of active shard copies are not available, then the write operation must wait and retry, until either the requisite shard copies have started or a timeout occurs.
By default, write operations only wait for the primary shards to be active before proceeding (that is to say <code>wait_for_active_shards</code> is <code>1</code>).
This default can be overridden in the index settings dynamically by setting <code>index.write.wait_for_active_shards</code>.
To alter this behavior per operation, use the <code>wait_for_active_shards request</code> parameter.
</p>
<p>
Valid values are all or any positive integer up to the total number of configured copies per shard in the index (which is <code>number_of_replicas</code>+1).
Specifying a negative value or a number greater than the number of shard copies will throw an error.
</p>
<p>
For example, suppose you have a cluster of three nodes, A, B, and C and you create an index index with the number of replicas set to 3 (resulting in 4 shard copies, one more copy than there are nodes).
If you attempt an indexing operation, by default the operation will only ensure the primary copy of each shard is available before proceeding.
This means that even if B and C went down and A hosted the primary shard copies, the indexing operation would still proceed with only one copy of the data.
If <code>wait_for_active_shards</code> is set on the request to <code>3</code> (and all three nodes are up), the indexing operation will require 3 active shard copies before proceeding.
This requirement should be met because there are 3 active nodes in the cluster, each one holding a copy of the shard.
However, if you set <code>wait_for_active_shards</code> to <code>all</code> (or to <code>4</code>, which is the same in this situation), the indexing operation will not proceed as you do not have all 4 copies of each shard active in the index.
The operation will timeout unless a new node is brought up in the cluster to host the fourth copy of the shard.
</p>
<p>
It is important to note that this setting greatly reduces the chances of the write operation not writing to the requisite number of shard copies, but it does not completely eliminate the possibility, because this check occurs before the write operation starts.
After the write operation is underway, it is still possible for replication to fail on any number of shard copies but still succeed on the primary.
The <code>_shards</code> section of the API response reveals the number of shard copies on which replication succeeded and failed.
</p>
<p>
<strong>No operation (noop) updates</strong>
</p>
<p>
When updating a document by using this API, a new version of the document is always created even if the document hasn't changed.
If this isn't acceptable use the <code>_update</code> API with <code>detect_noop</code> set to <code>true</code>.
The <code>detect_noop</code> option isn't available on this API because it doesn’t fetch the old source and isn't able to compare it against the new source.
</p>
<p>
There isn't a definitive rule for when noop updates aren't acceptable.
It's a combination of lots of factors like how frequently your data source sends updates that are actually noops and how many queries per second Elasticsearch runs on the shard receiving the updates.
</p>
<p>
<strong>Versioning</strong>
</p>
<p>
Each indexed document is given a version number.
By default, internal versioning is used that starts at 1 and increments with each update, deletes included.
Optionally, the version number can be set to an external value (for example, if maintained in a database).
To enable this functionality, <code>version_type</code> should be set to <code>external</code>.
The value provided must be a numeric, long value greater than or equal to 0, and less than around <code>9.2e+18</code>.
</p>
<p>
NOTE: Versioning is completely real time, and is not affected by the near real time aspects of search operations.
If no version is provided, the operation runs without any version checks.
</p>
<p>
When using the external version type, the system checks to see if the version number passed to the index request is greater than the version of the currently stored document.
If true, the document will be indexed and the new version number used.
If the value provided is less than or equal to the stored document's version number, a version conflict will occur and the index operation will fail. For example:
</p>
<pre><code class="lang-csharp">PUT my-index-000001/_doc/1?version=2&amp;version_type=external
{
  "user": {
    "id": "elkbee"
  }
}

In this example, the operation will succeed since the supplied version of 2 is higher than the current document version of 1.
If the document was already updated and its version was set to 2 or higher, the indexing command will fail and result in a conflict (409 HTTP status code).

A nice side effect is that there is no need to maintain strict ordering of async indexing operations run as a result of changes to a source database, as long as version numbers from the source database are used.
Even the simple case of updating the Elasticsearch index using data from a database is simplified if external versioning is used, as only the latest version will be used if the index operations arrive out of order.</code></pre>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-index_.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual IndexResponse Index&lt;TDocument&gt;(TDocument document, IndexName index, Id? id)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.IndexResponse.html">IndexResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Index_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Index*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Index__1___0_Elastic_Clients_Elasticsearch_IndexName_Elastic_Clients_Elasticsearch_Id_System_Action_Elastic_Clients_Elasticsearch_IndexRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Index``1(``0,Elastic.Clients.Elasticsearch.IndexName,Elastic.Clients.Elasticsearch.Id,System.Action{Elastic.Clients.Elasticsearch.IndexRequestDescriptor{``0}})">
  Index&lt;TDocument&gt;(TDocument, IndexName, Id?, Action&lt;IndexRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L19738"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Create or update a document in an index.
</p>
<p>
Add a JSON document to the specified data stream or index and make it searchable.
If the target is an index and the document already exists, the request updates the document and increments its version.
</p>
<p>
NOTE: You cannot use this API to send update requests for existing documents in a data stream.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or index alias:
</p>
<ul><li>
<p>
To add or overwrite a document using the <code>PUT /&lt;target&gt;/_doc/&lt;_id&gt;</code> request format, you must have the <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To add a document using the <code>POST /&lt;target&gt;/_doc/</code> request format, you must have the <code>create_doc</code>, <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To automatically create a data stream or index with this API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege.
</p>
</li></ul>
<p>
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
NOTE: Replica shards might not all be started when an indexing operation returns successfully.
By default, only the primary is required. Set <code>wait_for_active_shards</code> to change this default behavior.
</p>
<p>
<strong>Automatically create data streams and indices</strong>
</p>
<p>
If the request's target doesn't exist and matches an index template with a <code>data_stream</code> definition, the index operation automatically creates the data stream.
</p>
<p>
If the target doesn't exist and doesn't match a data stream template, the operation automatically creates the index and applies any matching index templates.
</p>
<p>
NOTE: Elasticsearch includes several built-in index templates. To avoid naming collisions with these templates, refer to index pattern documentation.
</p>
<p>
If no mapping exists, the index operation creates a dynamic mapping.
By default, new fields and objects are automatically added to the mapping if needed.
</p>
<p>
Automatic index creation is controlled by the <code>action.auto_create_index</code> setting.
If it is <code>true</code>, any index can be created automatically.
You can modify this setting to explicitly allow or block automatic creation of indices that match specified patterns or set it to <code>false</code> to turn off automatic index creation entirely.
Specify a comma-separated list of patterns you want to allow or prefix each pattern with <code>+</code> or <code>-</code> to indicate whether it should be allowed or blocked.
When a list is specified, the default behaviour is to disallow.
</p>
<p>
NOTE: The <code>action.auto_create_index</code> setting affects the automatic creation of indices only.
It does not affect the creation of data streams.
</p>
<p>
<strong>Optimistic concurrency control</strong>
</p>
<p>
Index operations can be made conditional and only be performed if the last modification to the document was assigned the sequence number and primary term specified by the <code>if_seq_no</code> and <code>if_primary_term</code> parameters.
If a mismatch is detected, the operation will result in a <code>VersionConflictException</code> and a status code of <code>409</code>.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
By default, shard placement — or routing — is controlled by using a hash of the document's ID value.
For more explicit control, the value fed into the hash function used by the router can be directly specified on a per-operation basis using the <code>routing</code> parameter.
</p>
<p>
When setting up explicit mapping, you can also use the <code>_routing</code> field to direct the index operation to extract the routing value from the document itself.
This does come at the (very minimal) cost of an additional document parsing pass.
If the <code>_routing</code> mapping is defined and set to be required, the index operation will fail if no routing value is provided or extracted.
</p>
<p>
NOTE: Data streams do not support custom routing unless they were created with the <code>allow_custom_routing</code> setting enabled in the template.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The index operation is directed to the primary shard based on its route and performed on the actual node containing this shard.
After the primary shard completes the operation, if needed, the update is distributed to applicable replicas.
</p>
<p>
<strong>Active shards</strong>
</p>
<p>
To improve the resiliency of writes to the system, indexing operations can be configured to wait for a certain number of active shard copies before proceeding with the operation.
If the requisite number of active shard copies are not available, then the write operation must wait and retry, until either the requisite shard copies have started or a timeout occurs.
By default, write operations only wait for the primary shards to be active before proceeding (that is to say <code>wait_for_active_shards</code> is <code>1</code>).
This default can be overridden in the index settings dynamically by setting <code>index.write.wait_for_active_shards</code>.
To alter this behavior per operation, use the <code>wait_for_active_shards request</code> parameter.
</p>
<p>
Valid values are all or any positive integer up to the total number of configured copies per shard in the index (which is <code>number_of_replicas</code>+1).
Specifying a negative value or a number greater than the number of shard copies will throw an error.
</p>
<p>
For example, suppose you have a cluster of three nodes, A, B, and C and you create an index index with the number of replicas set to 3 (resulting in 4 shard copies, one more copy than there are nodes).
If you attempt an indexing operation, by default the operation will only ensure the primary copy of each shard is available before proceeding.
This means that even if B and C went down and A hosted the primary shard copies, the indexing operation would still proceed with only one copy of the data.
If <code>wait_for_active_shards</code> is set on the request to <code>3</code> (and all three nodes are up), the indexing operation will require 3 active shard copies before proceeding.
This requirement should be met because there are 3 active nodes in the cluster, each one holding a copy of the shard.
However, if you set <code>wait_for_active_shards</code> to <code>all</code> (or to <code>4</code>, which is the same in this situation), the indexing operation will not proceed as you do not have all 4 copies of each shard active in the index.
The operation will timeout unless a new node is brought up in the cluster to host the fourth copy of the shard.
</p>
<p>
It is important to note that this setting greatly reduces the chances of the write operation not writing to the requisite number of shard copies, but it does not completely eliminate the possibility, because this check occurs before the write operation starts.
After the write operation is underway, it is still possible for replication to fail on any number of shard copies but still succeed on the primary.
The <code>_shards</code> section of the API response reveals the number of shard copies on which replication succeeded and failed.
</p>
<p>
<strong>No operation (noop) updates</strong>
</p>
<p>
When updating a document by using this API, a new version of the document is always created even if the document hasn't changed.
If this isn't acceptable use the <code>_update</code> API with <code>detect_noop</code> set to <code>true</code>.
The <code>detect_noop</code> option isn't available on this API because it doesn’t fetch the old source and isn't able to compare it against the new source.
</p>
<p>
There isn't a definitive rule for when noop updates aren't acceptable.
It's a combination of lots of factors like how frequently your data source sends updates that are actually noops and how many queries per second Elasticsearch runs on the shard receiving the updates.
</p>
<p>
<strong>Versioning</strong>
</p>
<p>
Each indexed document is given a version number.
By default, internal versioning is used that starts at 1 and increments with each update, deletes included.
Optionally, the version number can be set to an external value (for example, if maintained in a database).
To enable this functionality, <code>version_type</code> should be set to <code>external</code>.
The value provided must be a numeric, long value greater than or equal to 0, and less than around <code>9.2e+18</code>.
</p>
<p>
NOTE: Versioning is completely real time, and is not affected by the near real time aspects of search operations.
If no version is provided, the operation runs without any version checks.
</p>
<p>
When using the external version type, the system checks to see if the version number passed to the index request is greater than the version of the currently stored document.
If true, the document will be indexed and the new version number used.
If the value provided is less than or equal to the stored document's version number, a version conflict will occur and the index operation will fail. For example:
</p>
<pre><code class="lang-csharp">PUT my-index-000001/_doc/1?version=2&amp;version_type=external
{
  "user": {
    "id": "elkbee"
  }
}

In this example, the operation will succeed since the supplied version of 2 is higher than the current document version of 1.
If the document was already updated and its version was set to 2 or higher, the indexing command will fail and result in a conflict (409 HTTP status code).

A nice side effect is that there is no need to maintain strict ordering of async indexing operations run as a result of changes to a source database, as long as version numbers from the source database are used.
Even the simple case of updating the Elasticsearch index using data from a database is simplified if external versioning is used, as only the latest version will be used if the index operations arrive out of order.</code></pre>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-index_.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual IndexResponse Index&lt;TDocument&gt;(TDocument document, IndexName index, Id? id, Action&lt;IndexRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.IndexRequestDescriptor-1.html">IndexRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.IndexResponse.html">IndexResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Index_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Index*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Index__1___0_Elastic_Clients_Elasticsearch_IndexName_System_Action_Elastic_Clients_Elasticsearch_IndexRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Index``1(``0,Elastic.Clients.Elasticsearch.IndexName,System.Action{Elastic.Clients.Elasticsearch.IndexRequestDescriptor{``0}})">
  Index&lt;TDocument&gt;(TDocument, IndexName, Action&lt;IndexRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L20448"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Create or update a document in an index.
</p>
<p>
Add a JSON document to the specified data stream or index and make it searchable.
If the target is an index and the document already exists, the request updates the document and increments its version.
</p>
<p>
NOTE: You cannot use this API to send update requests for existing documents in a data stream.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or index alias:
</p>
<ul><li>
<p>
To add or overwrite a document using the <code>PUT /&lt;target&gt;/_doc/&lt;_id&gt;</code> request format, you must have the <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To add a document using the <code>POST /&lt;target&gt;/_doc/</code> request format, you must have the <code>create_doc</code>, <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To automatically create a data stream or index with this API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege.
</p>
</li></ul>
<p>
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
NOTE: Replica shards might not all be started when an indexing operation returns successfully.
By default, only the primary is required. Set <code>wait_for_active_shards</code> to change this default behavior.
</p>
<p>
<strong>Automatically create data streams and indices</strong>
</p>
<p>
If the request's target doesn't exist and matches an index template with a <code>data_stream</code> definition, the index operation automatically creates the data stream.
</p>
<p>
If the target doesn't exist and doesn't match a data stream template, the operation automatically creates the index and applies any matching index templates.
</p>
<p>
NOTE: Elasticsearch includes several built-in index templates. To avoid naming collisions with these templates, refer to index pattern documentation.
</p>
<p>
If no mapping exists, the index operation creates a dynamic mapping.
By default, new fields and objects are automatically added to the mapping if needed.
</p>
<p>
Automatic index creation is controlled by the <code>action.auto_create_index</code> setting.
If it is <code>true</code>, any index can be created automatically.
You can modify this setting to explicitly allow or block automatic creation of indices that match specified patterns or set it to <code>false</code> to turn off automatic index creation entirely.
Specify a comma-separated list of patterns you want to allow or prefix each pattern with <code>+</code> or <code>-</code> to indicate whether it should be allowed or blocked.
When a list is specified, the default behaviour is to disallow.
</p>
<p>
NOTE: The <code>action.auto_create_index</code> setting affects the automatic creation of indices only.
It does not affect the creation of data streams.
</p>
<p>
<strong>Optimistic concurrency control</strong>
</p>
<p>
Index operations can be made conditional and only be performed if the last modification to the document was assigned the sequence number and primary term specified by the <code>if_seq_no</code> and <code>if_primary_term</code> parameters.
If a mismatch is detected, the operation will result in a <code>VersionConflictException</code> and a status code of <code>409</code>.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
By default, shard placement — or routing — is controlled by using a hash of the document's ID value.
For more explicit control, the value fed into the hash function used by the router can be directly specified on a per-operation basis using the <code>routing</code> parameter.
</p>
<p>
When setting up explicit mapping, you can also use the <code>_routing</code> field to direct the index operation to extract the routing value from the document itself.
This does come at the (very minimal) cost of an additional document parsing pass.
If the <code>_routing</code> mapping is defined and set to be required, the index operation will fail if no routing value is provided or extracted.
</p>
<p>
NOTE: Data streams do not support custom routing unless they were created with the <code>allow_custom_routing</code> setting enabled in the template.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The index operation is directed to the primary shard based on its route and performed on the actual node containing this shard.
After the primary shard completes the operation, if needed, the update is distributed to applicable replicas.
</p>
<p>
<strong>Active shards</strong>
</p>
<p>
To improve the resiliency of writes to the system, indexing operations can be configured to wait for a certain number of active shard copies before proceeding with the operation.
If the requisite number of active shard copies are not available, then the write operation must wait and retry, until either the requisite shard copies have started or a timeout occurs.
By default, write operations only wait for the primary shards to be active before proceeding (that is to say <code>wait_for_active_shards</code> is <code>1</code>).
This default can be overridden in the index settings dynamically by setting <code>index.write.wait_for_active_shards</code>.
To alter this behavior per operation, use the <code>wait_for_active_shards request</code> parameter.
</p>
<p>
Valid values are all or any positive integer up to the total number of configured copies per shard in the index (which is <code>number_of_replicas</code>+1).
Specifying a negative value or a number greater than the number of shard copies will throw an error.
</p>
<p>
For example, suppose you have a cluster of three nodes, A, B, and C and you create an index index with the number of replicas set to 3 (resulting in 4 shard copies, one more copy than there are nodes).
If you attempt an indexing operation, by default the operation will only ensure the primary copy of each shard is available before proceeding.
This means that even if B and C went down and A hosted the primary shard copies, the indexing operation would still proceed with only one copy of the data.
If <code>wait_for_active_shards</code> is set on the request to <code>3</code> (and all three nodes are up), the indexing operation will require 3 active shard copies before proceeding.
This requirement should be met because there are 3 active nodes in the cluster, each one holding a copy of the shard.
However, if you set <code>wait_for_active_shards</code> to <code>all</code> (or to <code>4</code>, which is the same in this situation), the indexing operation will not proceed as you do not have all 4 copies of each shard active in the index.
The operation will timeout unless a new node is brought up in the cluster to host the fourth copy of the shard.
</p>
<p>
It is important to note that this setting greatly reduces the chances of the write operation not writing to the requisite number of shard copies, but it does not completely eliminate the possibility, because this check occurs before the write operation starts.
After the write operation is underway, it is still possible for replication to fail on any number of shard copies but still succeed on the primary.
The <code>_shards</code> section of the API response reveals the number of shard copies on which replication succeeded and failed.
</p>
<p>
<strong>No operation (noop) updates</strong>
</p>
<p>
When updating a document by using this API, a new version of the document is always created even if the document hasn't changed.
If this isn't acceptable use the <code>_update</code> API with <code>detect_noop</code> set to <code>true</code>.
The <code>detect_noop</code> option isn't available on this API because it doesn’t fetch the old source and isn't able to compare it against the new source.
</p>
<p>
There isn't a definitive rule for when noop updates aren't acceptable.
It's a combination of lots of factors like how frequently your data source sends updates that are actually noops and how many queries per second Elasticsearch runs on the shard receiving the updates.
</p>
<p>
<strong>Versioning</strong>
</p>
<p>
Each indexed document is given a version number.
By default, internal versioning is used that starts at 1 and increments with each update, deletes included.
Optionally, the version number can be set to an external value (for example, if maintained in a database).
To enable this functionality, <code>version_type</code> should be set to <code>external</code>.
The value provided must be a numeric, long value greater than or equal to 0, and less than around <code>9.2e+18</code>.
</p>
<p>
NOTE: Versioning is completely real time, and is not affected by the near real time aspects of search operations.
If no version is provided, the operation runs without any version checks.
</p>
<p>
When using the external version type, the system checks to see if the version number passed to the index request is greater than the version of the currently stored document.
If true, the document will be indexed and the new version number used.
If the value provided is less than or equal to the stored document's version number, a version conflict will occur and the index operation will fail. For example:
</p>
<pre><code class="lang-csharp">PUT my-index-000001/_doc/1?version=2&amp;version_type=external
{
  "user": {
    "id": "elkbee"
  }
}

In this example, the operation will succeed since the supplied version of 2 is higher than the current document version of 1.
If the document was already updated and its version was set to 2 or higher, the indexing command will fail and result in a conflict (409 HTTP status code).

A nice side effect is that there is no need to maintain strict ordering of async indexing operations run as a result of changes to a source database, as long as version numbers from the source database are used.
Even the simple case of updating the Elasticsearch index using data from a database is simplified if external versioning is used, as only the latest version will be used if the index operations arrive out of order.</code></pre>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-index_.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual IndexResponse Index&lt;TDocument&gt;(TDocument document, IndexName index, Action&lt;IndexRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.IndexRequestDescriptor-1.html">IndexRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.IndexResponse.html">IndexResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Index_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Index*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Index__1___0_System_Action_Elastic_Clients_Elasticsearch_IndexRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Index``1(``0,System.Action{Elastic.Clients.Elasticsearch.IndexRequestDescriptor{``0}})">
  Index&lt;TDocument&gt;(TDocument, Action&lt;IndexRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L20093"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Create or update a document in an index.
</p>
<p>
Add a JSON document to the specified data stream or index and make it searchable.
If the target is an index and the document already exists, the request updates the document and increments its version.
</p>
<p>
NOTE: You cannot use this API to send update requests for existing documents in a data stream.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or index alias:
</p>
<ul><li>
<p>
To add or overwrite a document using the <code>PUT /&lt;target&gt;/_doc/&lt;_id&gt;</code> request format, you must have the <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To add a document using the <code>POST /&lt;target&gt;/_doc/</code> request format, you must have the <code>create_doc</code>, <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To automatically create a data stream or index with this API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege.
</p>
</li></ul>
<p>
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
NOTE: Replica shards might not all be started when an indexing operation returns successfully.
By default, only the primary is required. Set <code>wait_for_active_shards</code> to change this default behavior.
</p>
<p>
<strong>Automatically create data streams and indices</strong>
</p>
<p>
If the request's target doesn't exist and matches an index template with a <code>data_stream</code> definition, the index operation automatically creates the data stream.
</p>
<p>
If the target doesn't exist and doesn't match a data stream template, the operation automatically creates the index and applies any matching index templates.
</p>
<p>
NOTE: Elasticsearch includes several built-in index templates. To avoid naming collisions with these templates, refer to index pattern documentation.
</p>
<p>
If no mapping exists, the index operation creates a dynamic mapping.
By default, new fields and objects are automatically added to the mapping if needed.
</p>
<p>
Automatic index creation is controlled by the <code>action.auto_create_index</code> setting.
If it is <code>true</code>, any index can be created automatically.
You can modify this setting to explicitly allow or block automatic creation of indices that match specified patterns or set it to <code>false</code> to turn off automatic index creation entirely.
Specify a comma-separated list of patterns you want to allow or prefix each pattern with <code>+</code> or <code>-</code> to indicate whether it should be allowed or blocked.
When a list is specified, the default behaviour is to disallow.
</p>
<p>
NOTE: The <code>action.auto_create_index</code> setting affects the automatic creation of indices only.
It does not affect the creation of data streams.
</p>
<p>
<strong>Optimistic concurrency control</strong>
</p>
<p>
Index operations can be made conditional and only be performed if the last modification to the document was assigned the sequence number and primary term specified by the <code>if_seq_no</code> and <code>if_primary_term</code> parameters.
If a mismatch is detected, the operation will result in a <code>VersionConflictException</code> and a status code of <code>409</code>.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
By default, shard placement — or routing — is controlled by using a hash of the document's ID value.
For more explicit control, the value fed into the hash function used by the router can be directly specified on a per-operation basis using the <code>routing</code> parameter.
</p>
<p>
When setting up explicit mapping, you can also use the <code>_routing</code> field to direct the index operation to extract the routing value from the document itself.
This does come at the (very minimal) cost of an additional document parsing pass.
If the <code>_routing</code> mapping is defined and set to be required, the index operation will fail if no routing value is provided or extracted.
</p>
<p>
NOTE: Data streams do not support custom routing unless they were created with the <code>allow_custom_routing</code> setting enabled in the template.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The index operation is directed to the primary shard based on its route and performed on the actual node containing this shard.
After the primary shard completes the operation, if needed, the update is distributed to applicable replicas.
</p>
<p>
<strong>Active shards</strong>
</p>
<p>
To improve the resiliency of writes to the system, indexing operations can be configured to wait for a certain number of active shard copies before proceeding with the operation.
If the requisite number of active shard copies are not available, then the write operation must wait and retry, until either the requisite shard copies have started or a timeout occurs.
By default, write operations only wait for the primary shards to be active before proceeding (that is to say <code>wait_for_active_shards</code> is <code>1</code>).
This default can be overridden in the index settings dynamically by setting <code>index.write.wait_for_active_shards</code>.
To alter this behavior per operation, use the <code>wait_for_active_shards request</code> parameter.
</p>
<p>
Valid values are all or any positive integer up to the total number of configured copies per shard in the index (which is <code>number_of_replicas</code>+1).
Specifying a negative value or a number greater than the number of shard copies will throw an error.
</p>
<p>
For example, suppose you have a cluster of three nodes, A, B, and C and you create an index index with the number of replicas set to 3 (resulting in 4 shard copies, one more copy than there are nodes).
If you attempt an indexing operation, by default the operation will only ensure the primary copy of each shard is available before proceeding.
This means that even if B and C went down and A hosted the primary shard copies, the indexing operation would still proceed with only one copy of the data.
If <code>wait_for_active_shards</code> is set on the request to <code>3</code> (and all three nodes are up), the indexing operation will require 3 active shard copies before proceeding.
This requirement should be met because there are 3 active nodes in the cluster, each one holding a copy of the shard.
However, if you set <code>wait_for_active_shards</code> to <code>all</code> (or to <code>4</code>, which is the same in this situation), the indexing operation will not proceed as you do not have all 4 copies of each shard active in the index.
The operation will timeout unless a new node is brought up in the cluster to host the fourth copy of the shard.
</p>
<p>
It is important to note that this setting greatly reduces the chances of the write operation not writing to the requisite number of shard copies, but it does not completely eliminate the possibility, because this check occurs before the write operation starts.
After the write operation is underway, it is still possible for replication to fail on any number of shard copies but still succeed on the primary.
The <code>_shards</code> section of the API response reveals the number of shard copies on which replication succeeded and failed.
</p>
<p>
<strong>No operation (noop) updates</strong>
</p>
<p>
When updating a document by using this API, a new version of the document is always created even if the document hasn't changed.
If this isn't acceptable use the <code>_update</code> API with <code>detect_noop</code> set to <code>true</code>.
The <code>detect_noop</code> option isn't available on this API because it doesn’t fetch the old source and isn't able to compare it against the new source.
</p>
<p>
There isn't a definitive rule for when noop updates aren't acceptable.
It's a combination of lots of factors like how frequently your data source sends updates that are actually noops and how many queries per second Elasticsearch runs on the shard receiving the updates.
</p>
<p>
<strong>Versioning</strong>
</p>
<p>
Each indexed document is given a version number.
By default, internal versioning is used that starts at 1 and increments with each update, deletes included.
Optionally, the version number can be set to an external value (for example, if maintained in a database).
To enable this functionality, <code>version_type</code> should be set to <code>external</code>.
The value provided must be a numeric, long value greater than or equal to 0, and less than around <code>9.2e+18</code>.
</p>
<p>
NOTE: Versioning is completely real time, and is not affected by the near real time aspects of search operations.
If no version is provided, the operation runs without any version checks.
</p>
<p>
When using the external version type, the system checks to see if the version number passed to the index request is greater than the version of the currently stored document.
If true, the document will be indexed and the new version number used.
If the value provided is less than or equal to the stored document's version number, a version conflict will occur and the index operation will fail. For example:
</p>
<pre><code class="lang-csharp">PUT my-index-000001/_doc/1?version=2&amp;version_type=external
{
  "user": {
    "id": "elkbee"
  }
}

In this example, the operation will succeed since the supplied version of 2 is higher than the current document version of 1.
If the document was already updated and its version was set to 2 or higher, the indexing command will fail and result in a conflict (409 HTTP status code).

A nice side effect is that there is no need to maintain strict ordering of async indexing operations run as a result of changes to a source database, as long as version numbers from the source database are used.
Even the simple case of updating the Elasticsearch index using data from a database is simplified if external versioning is used, as only the latest version will be used if the index operations arrive out of order.</code></pre>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-index_.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual IndexResponse Index&lt;TDocument&gt;(TDocument document, Action&lt;IndexRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.IndexRequestDescriptor-1.html">IndexRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.IndexResponse.html">IndexResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Info_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Info*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Info" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Info">
  Info()
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L22447"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get cluster info.
Get basic build, version, and cluster information.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/rest-api-root.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual InfoResponse Info()</code></pre>
  </div>


  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.InfoResponse.html">InfoResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Info_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Info*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Info_Elastic_Clients_Elasticsearch_InfoRequest_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Info(Elastic.Clients.Elasticsearch.InfoRequest)">
  Info(InfoRequest)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L22406"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get cluster info.
Get basic build, version, and cluster information.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/rest-api-root.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual InfoResponse Info(InfoRequest request)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.InfoRequest.html">InfoRequest</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.InfoResponse.html">InfoResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Info_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Info*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Info_Elastic_Clients_Elasticsearch_InfoRequestDescriptor_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Info(Elastic.Clients.Elasticsearch.InfoRequestDescriptor)">
  Info(InfoRequestDescriptor)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L22433"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get cluster info.
Get basic build, version, and cluster information.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/rest-api-root.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual InfoResponse Info(InfoRequestDescriptor descriptor)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.InfoRequestDescriptor.html">InfoRequestDescriptor</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.InfoResponse.html">InfoResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Info_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Info*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Info_System_Action_Elastic_Clients_Elasticsearch_InfoRequestDescriptor__" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Info(System.Action{Elastic.Clients.Elasticsearch.InfoRequestDescriptor})">
  Info(Action&lt;InfoRequestDescriptor&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L22462"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get cluster info.
Get basic build, version, and cluster information.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/rest-api-root.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual InfoResponse Info(Action&lt;InfoRequestDescriptor&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.InfoRequestDescriptor.html">InfoRequestDescriptor</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.InfoResponse.html">InfoResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_InfoAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.InfoAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_InfoAsync_Elastic_Clients_Elasticsearch_InfoRequest_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.InfoAsync(Elastic.Clients.Elasticsearch.InfoRequest,System.Threading.CancellationToken)">
  InfoAsync(InfoRequest, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L22420"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get cluster info.
Get basic build, version, and cluster information.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/rest-api-root.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;InfoResponse&gt; InfoAsync(InfoRequest request, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.InfoRequest.html">InfoRequest</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.InfoResponse.html">InfoResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_InfoAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.InfoAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_InfoAsync_Elastic_Clients_Elasticsearch_InfoRequestDescriptor_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.InfoAsync(Elastic.Clients.Elasticsearch.InfoRequestDescriptor,System.Threading.CancellationToken)">
  InfoAsync(InfoRequestDescriptor, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L22478"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get cluster info.
Get basic build, version, and cluster information.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/rest-api-root.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;InfoResponse&gt; InfoAsync(InfoRequestDescriptor descriptor, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.InfoRequestDescriptor.html">InfoRequestDescriptor</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.InfoResponse.html">InfoResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_InfoAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.InfoAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_InfoAsync_System_Action_Elastic_Clients_Elasticsearch_InfoRequestDescriptor__System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.InfoAsync(System.Action{Elastic.Clients.Elasticsearch.InfoRequestDescriptor},System.Threading.CancellationToken)">
  InfoAsync(Action&lt;InfoRequestDescriptor&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L22505"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get cluster info.
Get basic build, version, and cluster information.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/rest-api-root.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;InfoResponse&gt; InfoAsync(Action&lt;InfoRequestDescriptor&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.InfoRequestDescriptor.html">InfoRequestDescriptor</a>&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.InfoResponse.html">InfoResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_InfoAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.InfoAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_InfoAsync_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.InfoAsync(System.Threading.CancellationToken)">
  InfoAsync(CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L22491"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get cluster info.
Get basic build, version, and cluster information.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/rest-api-root.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;InfoResponse&gt; InfoAsync(CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.InfoResponse.html">InfoResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Mtermvectors_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Mtermvectors*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Mtermvectors" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Mtermvectors">
  Mtermvectors()
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L22811"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get multiple term vectors.
</p>
<p>
Get multiple term vectors with a single request.
You can specify existing documents by index and ID or provide artificial documents in the body of the request.
You can specify the index in the request body or request URI.
The response contains a <code>docs</code> array with all the fetched termvectors.
Each element has the structure provided by the termvectors API.
</p>
<p>
<strong>Artificial documents</strong>
</p>
<p>
You can also use <code>mtermvectors</code> to generate term vectors for artificial documents provided in the body of the request.
The mapping used is determined by the specified <code>_index</code>.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-multi-termvectors.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual MultiTermVectorsResponse Mtermvectors()</code></pre>
  </div>


  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.MultiTermVectorsResponse.html">MultiTermVectorsResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Mtermvectors_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Mtermvectors*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Mtermvectors_Elastic_Clients_Elasticsearch_IndexName_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Mtermvectors(Elastic.Clients.Elasticsearch.IndexName)">
  Mtermvectors(IndexName?)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L22754"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get multiple term vectors.
</p>
<p>
Get multiple term vectors with a single request.
You can specify existing documents by index and ID or provide artificial documents in the body of the request.
You can specify the index in the request body or request URI.
The response contains a <code>docs</code> array with all the fetched termvectors.
Each element has the structure provided by the termvectors API.
</p>
<p>
<strong>Artificial documents</strong>
</p>
<p>
You can also use <code>mtermvectors</code> to generate term vectors for artificial documents provided in the body of the request.
The mapping used is determined by the specified <code>_index</code>.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-multi-termvectors.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual MultiTermVectorsResponse Mtermvectors(IndexName? index)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.MultiTermVectorsResponse.html">MultiTermVectorsResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Mtermvectors_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Mtermvectors*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Mtermvectors_Elastic_Clients_Elasticsearch_IndexName_System_Action_Elastic_Clients_Elasticsearch_MultiTermVectorsRequestDescriptor__" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Mtermvectors(Elastic.Clients.Elasticsearch.IndexName,System.Action{Elastic.Clients.Elasticsearch.MultiTermVectorsRequestDescriptor})">
  Mtermvectors(IndexName?, Action&lt;MultiTermVectorsRequestDescriptor&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L22782"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get multiple term vectors.
</p>
<p>
Get multiple term vectors with a single request.
You can specify existing documents by index and ID or provide artificial documents in the body of the request.
You can specify the index in the request body or request URI.
The response contains a <code>docs</code> array with all the fetched termvectors.
Each element has the structure provided by the termvectors API.
</p>
<p>
<strong>Artificial documents</strong>
</p>
<p>
You can also use <code>mtermvectors</code> to generate term vectors for artificial documents provided in the body of the request.
The mapping used is determined by the specified <code>_index</code>.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-multi-termvectors.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual MultiTermVectorsResponse Mtermvectors(IndexName? index, Action&lt;MultiTermVectorsRequestDescriptor&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.MultiTermVectorsRequestDescriptor.html">MultiTermVectorsRequestDescriptor</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.MultiTermVectorsResponse.html">MultiTermVectorsResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Mtermvectors_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Mtermvectors*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Mtermvectors_Elastic_Clients_Elasticsearch_MultiTermVectorsRequest_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Mtermvectors(Elastic.Clients.Elasticsearch.MultiTermVectorsRequest)">
  Mtermvectors(MultiTermVectorsRequest)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L22533"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get multiple term vectors.
</p>
<p>
Get multiple term vectors with a single request.
You can specify existing documents by index and ID or provide artificial documents in the body of the request.
You can specify the index in the request body or request URI.
The response contains a <code>docs</code> array with all the fetched termvectors.
Each element has the structure provided by the termvectors API.
</p>
<p>
<strong>Artificial documents</strong>
</p>
<p>
You can also use <code>mtermvectors</code> to generate term vectors for artificial documents provided in the body of the request.
The mapping used is determined by the specified <code>_index</code>.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-multi-termvectors.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual MultiTermVectorsResponse Mtermvectors(MultiTermVectorsRequest request)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.MultiTermVectorsRequest.html">MultiTermVectorsRequest</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.MultiTermVectorsResponse.html">MultiTermVectorsResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Mtermvectors_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Mtermvectors*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Mtermvectors_Elastic_Clients_Elasticsearch_MultiTermVectorsRequestDescriptor_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Mtermvectors(Elastic.Clients.Elasticsearch.MultiTermVectorsRequestDescriptor)">
  Mtermvectors(MultiTermVectorsRequestDescriptor)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L22727"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get multiple term vectors.
</p>
<p>
Get multiple term vectors with a single request.
You can specify existing documents by index and ID or provide artificial documents in the body of the request.
You can specify the index in the request body or request URI.
The response contains a <code>docs</code> array with all the fetched termvectors.
Each element has the structure provided by the termvectors API.
</p>
<p>
<strong>Artificial documents</strong>
</p>
<p>
You can also use <code>mtermvectors</code> to generate term vectors for artificial documents provided in the body of the request.
The mapping used is determined by the specified <code>_index</code>.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-multi-termvectors.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual MultiTermVectorsResponse Mtermvectors(MultiTermVectorsRequestDescriptor descriptor)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.MultiTermVectorsRequestDescriptor.html">MultiTermVectorsRequestDescriptor</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.MultiTermVectorsResponse.html">MultiTermVectorsResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Mtermvectors_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Mtermvectors*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Mtermvectors_System_Action_Elastic_Clients_Elasticsearch_MultiTermVectorsRequestDescriptor__" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Mtermvectors(System.Action{Elastic.Clients.Elasticsearch.MultiTermVectorsRequestDescriptor})">
  Mtermvectors(Action&lt;MultiTermVectorsRequestDescriptor&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L22839"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get multiple term vectors.
</p>
<p>
Get multiple term vectors with a single request.
You can specify existing documents by index and ID or provide artificial documents in the body of the request.
You can specify the index in the request body or request URI.
The response contains a <code>docs</code> array with all the fetched termvectors.
Each element has the structure provided by the termvectors API.
</p>
<p>
<strong>Artificial documents</strong>
</p>
<p>
You can also use <code>mtermvectors</code> to generate term vectors for artificial documents provided in the body of the request.
The mapping used is determined by the specified <code>_index</code>.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-multi-termvectors.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual MultiTermVectorsResponse Mtermvectors(Action&lt;MultiTermVectorsRequestDescriptor&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.MultiTermVectorsRequestDescriptor.html">MultiTermVectorsRequestDescriptor</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.MultiTermVectorsResponse.html">MultiTermVectorsResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MtermvectorsAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MtermvectorsAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MtermvectorsAsync_Elastic_Clients_Elasticsearch_IndexName_System_Action_Elastic_Clients_Elasticsearch_MultiTermVectorsRequestDescriptor__System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MtermvectorsAsync(Elastic.Clients.Elasticsearch.IndexName,System.Action{Elastic.Clients.Elasticsearch.MultiTermVectorsRequestDescriptor},System.Threading.CancellationToken)">
  MtermvectorsAsync(IndexName?, Action&lt;MultiTermVectorsRequestDescriptor&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L23057"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get multiple term vectors.
</p>
<p>
Get multiple term vectors with a single request.
You can specify existing documents by index and ID or provide artificial documents in the body of the request.
You can specify the index in the request body or request URI.
The response contains a <code>docs</code> array with all the fetched termvectors.
Each element has the structure provided by the termvectors API.
</p>
<p>
<strong>Artificial documents</strong>
</p>
<p>
You can also use <code>mtermvectors</code> to generate term vectors for artificial documents provided in the body of the request.
The mapping used is determined by the specified <code>_index</code>.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-multi-termvectors.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;MultiTermVectorsResponse&gt; MtermvectorsAsync(IndexName? index, Action&lt;MultiTermVectorsRequestDescriptor&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.MultiTermVectorsRequestDescriptor.html">MultiTermVectorsRequestDescriptor</a>&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.MultiTermVectorsResponse.html">MultiTermVectorsResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MtermvectorsAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MtermvectorsAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MtermvectorsAsync_Elastic_Clients_Elasticsearch_IndexName_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MtermvectorsAsync(Elastic.Clients.Elasticsearch.IndexName,System.Threading.CancellationToken)">
  MtermvectorsAsync(IndexName?, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L23030"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get multiple term vectors.
</p>
<p>
Get multiple term vectors with a single request.
You can specify existing documents by index and ID or provide artificial documents in the body of the request.
You can specify the index in the request body or request URI.
The response contains a <code>docs</code> array with all the fetched termvectors.
Each element has the structure provided by the termvectors API.
</p>
<p>
<strong>Artificial documents</strong>
</p>
<p>
You can also use <code>mtermvectors</code> to generate term vectors for artificial documents provided in the body of the request.
The mapping used is determined by the specified <code>_index</code>.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-multi-termvectors.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;MultiTermVectorsResponse&gt; MtermvectorsAsync(IndexName? index, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.MultiTermVectorsResponse.html">MultiTermVectorsResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MtermvectorsAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MtermvectorsAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MtermvectorsAsync_Elastic_Clients_Elasticsearch_MultiTermVectorsRequest_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MtermvectorsAsync(Elastic.Clients.Elasticsearch.MultiTermVectorsRequest,System.Threading.CancellationToken)">
  MtermvectorsAsync(MultiTermVectorsRequest, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L22560"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get multiple term vectors.
</p>
<p>
Get multiple term vectors with a single request.
You can specify existing documents by index and ID or provide artificial documents in the body of the request.
You can specify the index in the request body or request URI.
The response contains a <code>docs</code> array with all the fetched termvectors.
Each element has the structure provided by the termvectors API.
</p>
<p>
<strong>Artificial documents</strong>
</p>
<p>
You can also use <code>mtermvectors</code> to generate term vectors for artificial documents provided in the body of the request.
The mapping used is determined by the specified <code>_index</code>.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-multi-termvectors.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;MultiTermVectorsResponse&gt; MtermvectorsAsync(MultiTermVectorsRequest request, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.MultiTermVectorsRequest.html">MultiTermVectorsRequest</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.MultiTermVectorsResponse.html">MultiTermVectorsResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MtermvectorsAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MtermvectorsAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MtermvectorsAsync_Elastic_Clients_Elasticsearch_MultiTermVectorsRequestDescriptor_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MtermvectorsAsync(Elastic.Clients.Elasticsearch.MultiTermVectorsRequestDescriptor,System.Threading.CancellationToken)">
  MtermvectorsAsync(MultiTermVectorsRequestDescriptor, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L23004"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get multiple term vectors.
</p>
<p>
Get multiple term vectors with a single request.
You can specify existing documents by index and ID or provide artificial documents in the body of the request.
You can specify the index in the request body or request URI.
The response contains a <code>docs</code> array with all the fetched termvectors.
Each element has the structure provided by the termvectors API.
</p>
<p>
<strong>Artificial documents</strong>
</p>
<p>
You can also use <code>mtermvectors</code> to generate term vectors for artificial documents provided in the body of the request.
The mapping used is determined by the specified <code>_index</code>.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-multi-termvectors.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;MultiTermVectorsResponse&gt; MtermvectorsAsync(MultiTermVectorsRequestDescriptor descriptor, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.MultiTermVectorsRequestDescriptor.html">MultiTermVectorsRequestDescriptor</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.MultiTermVectorsResponse.html">MultiTermVectorsResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MtermvectorsAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MtermvectorsAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MtermvectorsAsync_System_Action_Elastic_Clients_Elasticsearch_MultiTermVectorsRequestDescriptor__System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MtermvectorsAsync(System.Action{Elastic.Clients.Elasticsearch.MultiTermVectorsRequestDescriptor},System.Threading.CancellationToken)">
  MtermvectorsAsync(Action&lt;MultiTermVectorsRequestDescriptor&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L23112"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get multiple term vectors.
</p>
<p>
Get multiple term vectors with a single request.
You can specify existing documents by index and ID or provide artificial documents in the body of the request.
You can specify the index in the request body or request URI.
The response contains a <code>docs</code> array with all the fetched termvectors.
Each element has the structure provided by the termvectors API.
</p>
<p>
<strong>Artificial documents</strong>
</p>
<p>
You can also use <code>mtermvectors</code> to generate term vectors for artificial documents provided in the body of the request.
The mapping used is determined by the specified <code>_index</code>.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-multi-termvectors.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;MultiTermVectorsResponse&gt; MtermvectorsAsync(Action&lt;MultiTermVectorsRequestDescriptor&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.MultiTermVectorsRequestDescriptor.html">MultiTermVectorsRequestDescriptor</a>&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.MultiTermVectorsResponse.html">MultiTermVectorsResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MtermvectorsAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MtermvectorsAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MtermvectorsAsync_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MtermvectorsAsync(System.Threading.CancellationToken)">
  MtermvectorsAsync(CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L23085"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get multiple term vectors.
</p>
<p>
Get multiple term vectors with a single request.
You can specify existing documents by index and ID or provide artificial documents in the body of the request.
You can specify the index in the request body or request URI.
The response contains a <code>docs</code> array with all the fetched termvectors.
Each element has the structure provided by the termvectors API.
</p>
<p>
<strong>Artificial documents</strong>
</p>
<p>
You can also use <code>mtermvectors</code> to generate term vectors for artificial documents provided in the body of the request.
The mapping used is determined by the specified <code>_index</code>.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-multi-termvectors.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;MultiTermVectorsResponse&gt; MtermvectorsAsync(CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.MultiTermVectorsResponse.html">MultiTermVectorsResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MtermvectorsAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MtermvectorsAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MtermvectorsAsync__1_Elastic_Clients_Elasticsearch_IndexName_System_Action_Elastic_Clients_Elasticsearch_MultiTermVectorsRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MtermvectorsAsync``1(Elastic.Clients.Elasticsearch.IndexName,System.Action{Elastic.Clients.Elasticsearch.MultiTermVectorsRequestDescriptor{``0}},System.Threading.CancellationToken)">
  MtermvectorsAsync&lt;TDocument&gt;(IndexName?, Action&lt;MultiTermVectorsRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L22921"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get multiple term vectors.
</p>
<p>
Get multiple term vectors with a single request.
You can specify existing documents by index and ID or provide artificial documents in the body of the request.
You can specify the index in the request body or request URI.
The response contains a <code>docs</code> array with all the fetched termvectors.
Each element has the structure provided by the termvectors API.
</p>
<p>
<strong>Artificial documents</strong>
</p>
<p>
You can also use <code>mtermvectors</code> to generate term vectors for artificial documents provided in the body of the request.
The mapping used is determined by the specified <code>_index</code>.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-multi-termvectors.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;MultiTermVectorsResponse&gt; MtermvectorsAsync&lt;TDocument&gt;(IndexName? index, Action&lt;MultiTermVectorsRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.MultiTermVectorsRequestDescriptor-1.html">MultiTermVectorsRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.MultiTermVectorsResponse.html">MultiTermVectorsResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MtermvectorsAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MtermvectorsAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MtermvectorsAsync__1_Elastic_Clients_Elasticsearch_IndexName_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MtermvectorsAsync``1(Elastic.Clients.Elasticsearch.IndexName,System.Threading.CancellationToken)">
  MtermvectorsAsync&lt;TDocument&gt;(IndexName?, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L22894"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get multiple term vectors.
</p>
<p>
Get multiple term vectors with a single request.
You can specify existing documents by index and ID or provide artificial documents in the body of the request.
You can specify the index in the request body or request URI.
The response contains a <code>docs</code> array with all the fetched termvectors.
Each element has the structure provided by the termvectors API.
</p>
<p>
<strong>Artificial documents</strong>
</p>
<p>
You can also use <code>mtermvectors</code> to generate term vectors for artificial documents provided in the body of the request.
The mapping used is determined by the specified <code>_index</code>.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-multi-termvectors.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;MultiTermVectorsResponse&gt; MtermvectorsAsync&lt;TDocument&gt;(IndexName? index, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.MultiTermVectorsResponse.html">MultiTermVectorsResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MtermvectorsAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MtermvectorsAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MtermvectorsAsync__1_Elastic_Clients_Elasticsearch_MultiTermVectorsRequestDescriptor___0__System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MtermvectorsAsync``1(Elastic.Clients.Elasticsearch.MultiTermVectorsRequestDescriptor{``0},System.Threading.CancellationToken)">
  MtermvectorsAsync&lt;TDocument&gt;(MultiTermVectorsRequestDescriptor&lt;TDocument&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L22868"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get multiple term vectors.
</p>
<p>
Get multiple term vectors with a single request.
You can specify existing documents by index and ID or provide artificial documents in the body of the request.
You can specify the index in the request body or request URI.
The response contains a <code>docs</code> array with all the fetched termvectors.
Each element has the structure provided by the termvectors API.
</p>
<p>
<strong>Artificial documents</strong>
</p>
<p>
You can also use <code>mtermvectors</code> to generate term vectors for artificial documents provided in the body of the request.
The mapping used is determined by the specified <code>_index</code>.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-multi-termvectors.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;MultiTermVectorsResponse&gt; MtermvectorsAsync&lt;TDocument&gt;(MultiTermVectorsRequestDescriptor&lt;TDocument&gt; descriptor, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.MultiTermVectorsRequestDescriptor-1.html">MultiTermVectorsRequestDescriptor</a>&lt;TDocument&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.MultiTermVectorsResponse.html">MultiTermVectorsResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MtermvectorsAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MtermvectorsAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MtermvectorsAsync__1_System_Action_Elastic_Clients_Elasticsearch_MultiTermVectorsRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MtermvectorsAsync``1(System.Action{Elastic.Clients.Elasticsearch.MultiTermVectorsRequestDescriptor{``0}},System.Threading.CancellationToken)">
  MtermvectorsAsync&lt;TDocument&gt;(Action&lt;MultiTermVectorsRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L22976"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get multiple term vectors.
</p>
<p>
Get multiple term vectors with a single request.
You can specify existing documents by index and ID or provide artificial documents in the body of the request.
You can specify the index in the request body or request URI.
The response contains a <code>docs</code> array with all the fetched termvectors.
Each element has the structure provided by the termvectors API.
</p>
<p>
<strong>Artificial documents</strong>
</p>
<p>
You can also use <code>mtermvectors</code> to generate term vectors for artificial documents provided in the body of the request.
The mapping used is determined by the specified <code>_index</code>.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-multi-termvectors.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;MultiTermVectorsResponse&gt; MtermvectorsAsync&lt;TDocument&gt;(Action&lt;MultiTermVectorsRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.MultiTermVectorsRequestDescriptor-1.html">MultiTermVectorsRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.MultiTermVectorsResponse.html">MultiTermVectorsResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MtermvectorsAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MtermvectorsAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MtermvectorsAsync__1_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MtermvectorsAsync``1(System.Threading.CancellationToken)">
  MtermvectorsAsync&lt;TDocument&gt;(CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L22949"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get multiple term vectors.
</p>
<p>
Get multiple term vectors with a single request.
You can specify existing documents by index and ID or provide artificial documents in the body of the request.
You can specify the index in the request body or request URI.
The response contains a <code>docs</code> array with all the fetched termvectors.
Each element has the structure provided by the termvectors API.
</p>
<p>
<strong>Artificial documents</strong>
</p>
<p>
You can also use <code>mtermvectors</code> to generate term vectors for artificial documents provided in the body of the request.
The mapping used is determined by the specified <code>_index</code>.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-multi-termvectors.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;MultiTermVectorsResponse&gt; MtermvectorsAsync&lt;TDocument&gt;(CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.MultiTermVectorsResponse.html">MultiTermVectorsResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Mtermvectors_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Mtermvectors*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Mtermvectors__1" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Mtermvectors``1">
  Mtermvectors&lt;TDocument&gt;()
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L22670"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get multiple term vectors.
</p>
<p>
Get multiple term vectors with a single request.
You can specify existing documents by index and ID or provide artificial documents in the body of the request.
You can specify the index in the request body or request URI.
The response contains a <code>docs</code> array with all the fetched termvectors.
Each element has the structure provided by the termvectors API.
</p>
<p>
<strong>Artificial documents</strong>
</p>
<p>
You can also use <code>mtermvectors</code> to generate term vectors for artificial documents provided in the body of the request.
The mapping used is determined by the specified <code>_index</code>.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-multi-termvectors.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual MultiTermVectorsResponse Mtermvectors&lt;TDocument&gt;()</code></pre>
  </div>


  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.MultiTermVectorsResponse.html">MultiTermVectorsResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Mtermvectors_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Mtermvectors*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Mtermvectors__1_Elastic_Clients_Elasticsearch_IndexName_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Mtermvectors``1(Elastic.Clients.Elasticsearch.IndexName)">
  Mtermvectors&lt;TDocument&gt;(IndexName?)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L22613"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get multiple term vectors.
</p>
<p>
Get multiple term vectors with a single request.
You can specify existing documents by index and ID or provide artificial documents in the body of the request.
You can specify the index in the request body or request URI.
The response contains a <code>docs</code> array with all the fetched termvectors.
Each element has the structure provided by the termvectors API.
</p>
<p>
<strong>Artificial documents</strong>
</p>
<p>
You can also use <code>mtermvectors</code> to generate term vectors for artificial documents provided in the body of the request.
The mapping used is determined by the specified <code>_index</code>.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-multi-termvectors.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual MultiTermVectorsResponse Mtermvectors&lt;TDocument&gt;(IndexName? index)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.MultiTermVectorsResponse.html">MultiTermVectorsResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Mtermvectors_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Mtermvectors*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Mtermvectors__1_Elastic_Clients_Elasticsearch_IndexName_System_Action_Elastic_Clients_Elasticsearch_MultiTermVectorsRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Mtermvectors``1(Elastic.Clients.Elasticsearch.IndexName,System.Action{Elastic.Clients.Elasticsearch.MultiTermVectorsRequestDescriptor{``0}})">
  Mtermvectors&lt;TDocument&gt;(IndexName?, Action&lt;MultiTermVectorsRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L22641"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get multiple term vectors.
</p>
<p>
Get multiple term vectors with a single request.
You can specify existing documents by index and ID or provide artificial documents in the body of the request.
You can specify the index in the request body or request URI.
The response contains a <code>docs</code> array with all the fetched termvectors.
Each element has the structure provided by the termvectors API.
</p>
<p>
<strong>Artificial documents</strong>
</p>
<p>
You can also use <code>mtermvectors</code> to generate term vectors for artificial documents provided in the body of the request.
The mapping used is determined by the specified <code>_index</code>.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-multi-termvectors.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual MultiTermVectorsResponse Mtermvectors&lt;TDocument&gt;(IndexName? index, Action&lt;MultiTermVectorsRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.MultiTermVectorsRequestDescriptor-1.html">MultiTermVectorsRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.MultiTermVectorsResponse.html">MultiTermVectorsResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Mtermvectors_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Mtermvectors*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Mtermvectors__1_Elastic_Clients_Elasticsearch_MultiTermVectorsRequestDescriptor___0__" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Mtermvectors``1(Elastic.Clients.Elasticsearch.MultiTermVectorsRequestDescriptor{``0})">
  Mtermvectors&lt;TDocument&gt;(MultiTermVectorsRequestDescriptor&lt;TDocument&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L22586"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get multiple term vectors.
</p>
<p>
Get multiple term vectors with a single request.
You can specify existing documents by index and ID or provide artificial documents in the body of the request.
You can specify the index in the request body or request URI.
The response contains a <code>docs</code> array with all the fetched termvectors.
Each element has the structure provided by the termvectors API.
</p>
<p>
<strong>Artificial documents</strong>
</p>
<p>
You can also use <code>mtermvectors</code> to generate term vectors for artificial documents provided in the body of the request.
The mapping used is determined by the specified <code>_index</code>.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-multi-termvectors.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual MultiTermVectorsResponse Mtermvectors&lt;TDocument&gt;(MultiTermVectorsRequestDescriptor&lt;TDocument&gt; descriptor)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.MultiTermVectorsRequestDescriptor-1.html">MultiTermVectorsRequestDescriptor</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.MultiTermVectorsResponse.html">MultiTermVectorsResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Mtermvectors_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Mtermvectors*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Mtermvectors__1_System_Action_Elastic_Clients_Elasticsearch_MultiTermVectorsRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Mtermvectors``1(System.Action{Elastic.Clients.Elasticsearch.MultiTermVectorsRequestDescriptor{``0}})">
  Mtermvectors&lt;TDocument&gt;(Action&lt;MultiTermVectorsRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L22698"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get multiple term vectors.
</p>
<p>
Get multiple term vectors with a single request.
You can specify existing documents by index and ID or provide artificial documents in the body of the request.
You can specify the index in the request body or request URI.
The response contains a <code>docs</code> array with all the fetched termvectors.
Each element has the structure provided by the termvectors API.
</p>
<p>
<strong>Artificial documents</strong>
</p>
<p>
You can also use <code>mtermvectors</code> to generate term vectors for artificial documents provided in the body of the request.
The mapping used is determined by the specified <code>_index</code>.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-multi-termvectors.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual MultiTermVectorsResponse Mtermvectors&lt;TDocument&gt;(Action&lt;MultiTermVectorsRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.MultiTermVectorsRequestDescriptor-1.html">MultiTermVectorsRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.MultiTermVectorsResponse.html">MultiTermVectorsResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MultiGetAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MultiGetAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MultiGetAsync__1_Elastic_Clients_Elasticsearch_IndexName_System_Action_Elastic_Clients_Elasticsearch_MultiGetRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MultiGetAsync``1(Elastic.Clients.Elasticsearch.IndexName,System.Action{Elastic.Clients.Elasticsearch.MultiGetRequestDescriptor{``0}},System.Threading.CancellationToken)">
  MultiGetAsync&lt;TDocument&gt;(IndexName?, Action&lt;MultiGetRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L23457"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get multiple documents.
</p>
<p>
Get multiple JSON documents by ID from one or more indices.
If you specify an index in the request URI, you only need to specify the document IDs in the request body.
To ensure fast responses, this multi get (mget) API responds with partial results if one or more shards fail.
</p>
<p>
<strong>Filter source fields</strong>
</p>
<p>
By default, the <code>_source</code> field is returned for every document (if stored).
Use the <code>_source</code> and <code>_source_include</code> or <code>source_exclude</code> attributes to filter what fields are returned for a particular document.
You can include the <code>_source</code>, <code>_source_includes</code>, and <code>_source_excludes</code> query parameters in the request URI to specify the defaults to use when there are no per-document instructions.
</p>
<p>
<strong>Get stored fields</strong>
</p>
<p>
Use the <code>stored_fields</code> attribute to specify the set of stored fields you want to retrieve.
Any requested fields that are not stored are ignored.
You can include the <code>stored_fields</code> query parameter in the request URI to specify the defaults to use when there are no per-document instructions.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-multi-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;MultiGetResponse&lt;TDocument&gt;&gt; MultiGetAsync&lt;TDocument&gt;(IndexName? index, Action&lt;MultiGetRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.MultiGetRequestDescriptor-1.html">MultiGetRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.MultiGetResponse-1.html">MultiGetResponse</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MultiGetAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MultiGetAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MultiGetAsync__1_Elastic_Clients_Elasticsearch_IndexName_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MultiGetAsync``1(Elastic.Clients.Elasticsearch.IndexName,System.Threading.CancellationToken)">
  MultiGetAsync&lt;TDocument&gt;(IndexName?, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L23423"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get multiple documents.
</p>
<p>
Get multiple JSON documents by ID from one or more indices.
If you specify an index in the request URI, you only need to specify the document IDs in the request body.
To ensure fast responses, this multi get (mget) API responds with partial results if one or more shards fail.
</p>
<p>
<strong>Filter source fields</strong>
</p>
<p>
By default, the <code>_source</code> field is returned for every document (if stored).
Use the <code>_source</code> and <code>_source_include</code> or <code>source_exclude</code> attributes to filter what fields are returned for a particular document.
You can include the <code>_source</code>, <code>_source_includes</code>, and <code>_source_excludes</code> query parameters in the request URI to specify the defaults to use when there are no per-document instructions.
</p>
<p>
<strong>Get stored fields</strong>
</p>
<p>
Use the <code>stored_fields</code> attribute to specify the set of stored fields you want to retrieve.
Any requested fields that are not stored are ignored.
You can include the <code>stored_fields</code> query parameter in the request URI to specify the defaults to use when there are no per-document instructions.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-multi-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;MultiGetResponse&lt;TDocument&gt;&gt; MultiGetAsync&lt;TDocument&gt;(IndexName? index, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.MultiGetResponse-1.html">MultiGetResponse</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MultiGetAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MultiGetAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MultiGetAsync__1_Elastic_Clients_Elasticsearch_MultiGetRequest_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MultiGetAsync``1(Elastic.Clients.Elasticsearch.MultiGetRequest,System.Threading.CancellationToken)">
  MultiGetAsync&lt;TDocument&gt;(MultiGetRequest, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L23181"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get multiple documents.
</p>
<p>
Get multiple JSON documents by ID from one or more indices.
If you specify an index in the request URI, you only need to specify the document IDs in the request body.
To ensure fast responses, this multi get (mget) API responds with partial results if one or more shards fail.
</p>
<p>
<strong>Filter source fields</strong>
</p>
<p>
By default, the <code>_source</code> field is returned for every document (if stored).
Use the <code>_source</code> and <code>_source_include</code> or <code>source_exclude</code> attributes to filter what fields are returned for a particular document.
You can include the <code>_source</code>, <code>_source_includes</code>, and <code>_source_excludes</code> query parameters in the request URI to specify the defaults to use when there are no per-document instructions.
</p>
<p>
<strong>Get stored fields</strong>
</p>
<p>
Use the <code>stored_fields</code> attribute to specify the set of stored fields you want to retrieve.
Any requested fields that are not stored are ignored.
You can include the <code>stored_fields</code> query parameter in the request URI to specify the defaults to use when there are no per-document instructions.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-multi-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;MultiGetResponse&lt;TDocument&gt;&gt; MultiGetAsync&lt;TDocument&gt;(MultiGetRequest request, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.MultiGetRequest.html">MultiGetRequest</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.MultiGetResponse-1.html">MultiGetResponse</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MultiGetAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MultiGetAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MultiGetAsync__1_Elastic_Clients_Elasticsearch_MultiGetRequestDescriptor___0__System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MultiGetAsync``1(Elastic.Clients.Elasticsearch.MultiGetRequestDescriptor{``0},System.Threading.CancellationToken)">
  MultiGetAsync&lt;TDocument&gt;(MultiGetRequestDescriptor&lt;TDocument&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L23390"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get multiple documents.
</p>
<p>
Get multiple JSON documents by ID from one or more indices.
If you specify an index in the request URI, you only need to specify the document IDs in the request body.
To ensure fast responses, this multi get (mget) API responds with partial results if one or more shards fail.
</p>
<p>
<strong>Filter source fields</strong>
</p>
<p>
By default, the <code>_source</code> field is returned for every document (if stored).
Use the <code>_source</code> and <code>_source_include</code> or <code>source_exclude</code> attributes to filter what fields are returned for a particular document.
You can include the <code>_source</code>, <code>_source_includes</code>, and <code>_source_excludes</code> query parameters in the request URI to specify the defaults to use when there are no per-document instructions.
</p>
<p>
<strong>Get stored fields</strong>
</p>
<p>
Use the <code>stored_fields</code> attribute to specify the set of stored fields you want to retrieve.
Any requested fields that are not stored are ignored.
You can include the <code>stored_fields</code> query parameter in the request URI to specify the defaults to use when there are no per-document instructions.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-multi-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;MultiGetResponse&lt;TDocument&gt;&gt; MultiGetAsync&lt;TDocument&gt;(MultiGetRequestDescriptor&lt;TDocument&gt; descriptor, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.MultiGetRequestDescriptor-1.html">MultiGetRequestDescriptor</a>&lt;TDocument&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.MultiGetResponse-1.html">MultiGetResponse</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MultiGetAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MultiGetAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MultiGetAsync__1_System_Action_Elastic_Clients_Elasticsearch_MultiGetRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MultiGetAsync``1(System.Action{Elastic.Clients.Elasticsearch.MultiGetRequestDescriptor{``0}},System.Threading.CancellationToken)">
  MultiGetAsync&lt;TDocument&gt;(Action&lt;MultiGetRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L23526"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get multiple documents.
</p>
<p>
Get multiple JSON documents by ID from one or more indices.
If you specify an index in the request URI, you only need to specify the document IDs in the request body.
To ensure fast responses, this multi get (mget) API responds with partial results if one or more shards fail.
</p>
<p>
<strong>Filter source fields</strong>
</p>
<p>
By default, the <code>_source</code> field is returned for every document (if stored).
Use the <code>_source</code> and <code>_source_include</code> or <code>source_exclude</code> attributes to filter what fields are returned for a particular document.
You can include the <code>_source</code>, <code>_source_includes</code>, and <code>_source_excludes</code> query parameters in the request URI to specify the defaults to use when there are no per-document instructions.
</p>
<p>
<strong>Get stored fields</strong>
</p>
<p>
Use the <code>stored_fields</code> attribute to specify the set of stored fields you want to retrieve.
Any requested fields that are not stored are ignored.
You can include the <code>stored_fields</code> query parameter in the request URI to specify the defaults to use when there are no per-document instructions.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-multi-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;MultiGetResponse&lt;TDocument&gt;&gt; MultiGetAsync&lt;TDocument&gt;(Action&lt;MultiGetRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.MultiGetRequestDescriptor-1.html">MultiGetRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.MultiGetResponse-1.html">MultiGetResponse</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MultiGetAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MultiGetAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MultiGetAsync__1_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MultiGetAsync``1(System.Threading.CancellationToken)">
  MultiGetAsync&lt;TDocument&gt;(CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L23492"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get multiple documents.
</p>
<p>
Get multiple JSON documents by ID from one or more indices.
If you specify an index in the request URI, you only need to specify the document IDs in the request body.
To ensure fast responses, this multi get (mget) API responds with partial results if one or more shards fail.
</p>
<p>
<strong>Filter source fields</strong>
</p>
<p>
By default, the <code>_source</code> field is returned for every document (if stored).
Use the <code>_source</code> and <code>_source_include</code> or <code>source_exclude</code> attributes to filter what fields are returned for a particular document.
You can include the <code>_source</code>, <code>_source_includes</code>, and <code>_source_excludes</code> query parameters in the request URI to specify the defaults to use when there are no per-document instructions.
</p>
<p>
<strong>Get stored fields</strong>
</p>
<p>
Use the <code>stored_fields</code> attribute to specify the set of stored fields you want to retrieve.
Any requested fields that are not stored are ignored.
You can include the <code>stored_fields</code> query parameter in the request URI to specify the defaults to use when there are no per-document instructions.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-multi-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;MultiGetResponse&lt;TDocument&gt;&gt; MultiGetAsync&lt;TDocument&gt;(CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.MultiGetResponse-1.html">MultiGetResponse</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MultiGet_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MultiGet*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MultiGet__1" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MultiGet``1">
  MultiGet&lt;TDocument&gt;()
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L23319"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get multiple documents.
</p>
<p>
Get multiple JSON documents by ID from one or more indices.
If you specify an index in the request URI, you only need to specify the document IDs in the request body.
To ensure fast responses, this multi get (mget) API responds with partial results if one or more shards fail.
</p>
<p>
<strong>Filter source fields</strong>
</p>
<p>
By default, the <code>_source</code> field is returned for every document (if stored).
Use the <code>_source</code> and <code>_source_include</code> or <code>source_exclude</code> attributes to filter what fields are returned for a particular document.
You can include the <code>_source</code>, <code>_source_includes</code>, and <code>_source_excludes</code> query parameters in the request URI to specify the defaults to use when there are no per-document instructions.
</p>
<p>
<strong>Get stored fields</strong>
</p>
<p>
Use the <code>stored_fields</code> attribute to specify the set of stored fields you want to retrieve.
Any requested fields that are not stored are ignored.
You can include the <code>stored_fields</code> query parameter in the request URI to specify the defaults to use when there are no per-document instructions.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-multi-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual MultiGetResponse&lt;TDocument&gt; MultiGet&lt;TDocument&gt;()</code></pre>
  </div>


  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.MultiGetResponse-1.html">MultiGetResponse</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MultiGet_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MultiGet*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MultiGet__1_Elastic_Clients_Elasticsearch_IndexName_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MultiGet``1(Elastic.Clients.Elasticsearch.IndexName)">
  MultiGet&lt;TDocument&gt;(IndexName?)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L23248"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get multiple documents.
</p>
<p>
Get multiple JSON documents by ID from one or more indices.
If you specify an index in the request URI, you only need to specify the document IDs in the request body.
To ensure fast responses, this multi get (mget) API responds with partial results if one or more shards fail.
</p>
<p>
<strong>Filter source fields</strong>
</p>
<p>
By default, the <code>_source</code> field is returned for every document (if stored).
Use the <code>_source</code> and <code>_source_include</code> or <code>source_exclude</code> attributes to filter what fields are returned for a particular document.
You can include the <code>_source</code>, <code>_source_includes</code>, and <code>_source_excludes</code> query parameters in the request URI to specify the defaults to use when there are no per-document instructions.
</p>
<p>
<strong>Get stored fields</strong>
</p>
<p>
Use the <code>stored_fields</code> attribute to specify the set of stored fields you want to retrieve.
Any requested fields that are not stored are ignored.
You can include the <code>stored_fields</code> query parameter in the request URI to specify the defaults to use when there are no per-document instructions.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-multi-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual MultiGetResponse&lt;TDocument&gt; MultiGet&lt;TDocument&gt;(IndexName? index)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.MultiGetResponse-1.html">MultiGetResponse</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MultiGet_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MultiGet*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MultiGet__1_Elastic_Clients_Elasticsearch_IndexName_System_Action_Elastic_Clients_Elasticsearch_MultiGetRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MultiGet``1(Elastic.Clients.Elasticsearch.IndexName,System.Action{Elastic.Clients.Elasticsearch.MultiGetRequestDescriptor{``0}})">
  MultiGet&lt;TDocument&gt;(IndexName?, Action&lt;MultiGetRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L23283"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get multiple documents.
</p>
<p>
Get multiple JSON documents by ID from one or more indices.
If you specify an index in the request URI, you only need to specify the document IDs in the request body.
To ensure fast responses, this multi get (mget) API responds with partial results if one or more shards fail.
</p>
<p>
<strong>Filter source fields</strong>
</p>
<p>
By default, the <code>_source</code> field is returned for every document (if stored).
Use the <code>_source</code> and <code>_source_include</code> or <code>source_exclude</code> attributes to filter what fields are returned for a particular document.
You can include the <code>_source</code>, <code>_source_includes</code>, and <code>_source_excludes</code> query parameters in the request URI to specify the defaults to use when there are no per-document instructions.
</p>
<p>
<strong>Get stored fields</strong>
</p>
<p>
Use the <code>stored_fields</code> attribute to specify the set of stored fields you want to retrieve.
Any requested fields that are not stored are ignored.
You can include the <code>stored_fields</code> query parameter in the request URI to specify the defaults to use when there are no per-document instructions.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-multi-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual MultiGetResponse&lt;TDocument&gt; MultiGet&lt;TDocument&gt;(IndexName? index, Action&lt;MultiGetRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.MultiGetRequestDescriptor-1.html">MultiGetRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.MultiGetResponse-1.html">MultiGetResponse</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MultiGet_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MultiGet*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MultiGet__1_Elastic_Clients_Elasticsearch_MultiGetRequest_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MultiGet``1(Elastic.Clients.Elasticsearch.MultiGetRequest)">
  MultiGet&lt;TDocument&gt;(MultiGetRequest)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L23147"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get multiple documents.
</p>
<p>
Get multiple JSON documents by ID from one or more indices.
If you specify an index in the request URI, you only need to specify the document IDs in the request body.
To ensure fast responses, this multi get (mget) API responds with partial results if one or more shards fail.
</p>
<p>
<strong>Filter source fields</strong>
</p>
<p>
By default, the <code>_source</code> field is returned for every document (if stored).
Use the <code>_source</code> and <code>_source_include</code> or <code>source_exclude</code> attributes to filter what fields are returned for a particular document.
You can include the <code>_source</code>, <code>_source_includes</code>, and <code>_source_excludes</code> query parameters in the request URI to specify the defaults to use when there are no per-document instructions.
</p>
<p>
<strong>Get stored fields</strong>
</p>
<p>
Use the <code>stored_fields</code> attribute to specify the set of stored fields you want to retrieve.
Any requested fields that are not stored are ignored.
You can include the <code>stored_fields</code> query parameter in the request URI to specify the defaults to use when there are no per-document instructions.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-multi-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual MultiGetResponse&lt;TDocument&gt; MultiGet&lt;TDocument&gt;(MultiGetRequest request)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.MultiGetRequest.html">MultiGetRequest</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.MultiGetResponse-1.html">MultiGetResponse</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MultiGet_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MultiGet*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MultiGet__1_Elastic_Clients_Elasticsearch_MultiGetRequestDescriptor___0__" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MultiGet``1(Elastic.Clients.Elasticsearch.MultiGetRequestDescriptor{``0})">
  MultiGet&lt;TDocument&gt;(MultiGetRequestDescriptor&lt;TDocument&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L23214"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get multiple documents.
</p>
<p>
Get multiple JSON documents by ID from one or more indices.
If you specify an index in the request URI, you only need to specify the document IDs in the request body.
To ensure fast responses, this multi get (mget) API responds with partial results if one or more shards fail.
</p>
<p>
<strong>Filter source fields</strong>
</p>
<p>
By default, the <code>_source</code> field is returned for every document (if stored).
Use the <code>_source</code> and <code>_source_include</code> or <code>source_exclude</code> attributes to filter what fields are returned for a particular document.
You can include the <code>_source</code>, <code>_source_includes</code>, and <code>_source_excludes</code> query parameters in the request URI to specify the defaults to use when there are no per-document instructions.
</p>
<p>
<strong>Get stored fields</strong>
</p>
<p>
Use the <code>stored_fields</code> attribute to specify the set of stored fields you want to retrieve.
Any requested fields that are not stored are ignored.
You can include the <code>stored_fields</code> query parameter in the request URI to specify the defaults to use when there are no per-document instructions.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-multi-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual MultiGetResponse&lt;TDocument&gt; MultiGet&lt;TDocument&gt;(MultiGetRequestDescriptor&lt;TDocument&gt; descriptor)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.MultiGetRequestDescriptor-1.html">MultiGetRequestDescriptor</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.MultiGetResponse-1.html">MultiGetResponse</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MultiGet_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MultiGet*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MultiGet__1_System_Action_Elastic_Clients_Elasticsearch_MultiGetRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MultiGet``1(System.Action{Elastic.Clients.Elasticsearch.MultiGetRequestDescriptor{``0}})">
  MultiGet&lt;TDocument&gt;(Action&lt;MultiGetRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L23354"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get multiple documents.
</p>
<p>
Get multiple JSON documents by ID from one or more indices.
If you specify an index in the request URI, you only need to specify the document IDs in the request body.
To ensure fast responses, this multi get (mget) API responds with partial results if one or more shards fail.
</p>
<p>
<strong>Filter source fields</strong>
</p>
<p>
By default, the <code>_source</code> field is returned for every document (if stored).
Use the <code>_source</code> and <code>_source_include</code> or <code>source_exclude</code> attributes to filter what fields are returned for a particular document.
You can include the <code>_source</code>, <code>_source_includes</code>, and <code>_source_excludes</code> query parameters in the request URI to specify the defaults to use when there are no per-document instructions.
</p>
<p>
<strong>Get stored fields</strong>
</p>
<p>
Use the <code>stored_fields</code> attribute to specify the set of stored fields you want to retrieve.
Any requested fields that are not stored are ignored.
You can include the <code>stored_fields</code> query parameter in the request URI to specify the defaults to use when there are no per-document instructions.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-multi-get.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual MultiGetResponse&lt;TDocument&gt; MultiGet&lt;TDocument&gt;(Action&lt;MultiGetRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.MultiGetRequestDescriptor-1.html">MultiGetRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.MultiGetResponse-1.html">MultiGetResponse</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MultiSearchAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MultiSearchAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MultiSearchAsync__1_Elastic_Clients_Elasticsearch_Indices_System_Action_Elastic_Clients_Elasticsearch_MultiSearchRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MultiSearchAsync``1(Elastic.Clients.Elasticsearch.Indices,System.Action{Elastic.Clients.Elasticsearch.MultiSearchRequestDescriptor{``0}},System.Threading.CancellationToken)">
  MultiSearchAsync&lt;TDocument&gt;(Indices?, Action&lt;MultiSearchRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L23841"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Run multiple searches.
</p>
<p>
The format of the request is similar to the bulk API format and makes use of the newline delimited JSON (NDJSON) format.
The structure is as follows:
</p>
<pre><code class="lang-csharp">header\n
body\n
header\n
body\n</code></pre>
<p>
This structure is specifically optimized to reduce parsing if a specific search ends up redirected to another node.
</p>
<p>
IMPORTANT: The final line of data must end with a newline character <code>\n</code>.
Each newline character may be preceded by a carriage return <code>\r</code>.
When sending requests to this endpoint the <code>Content-Type</code> header should be set to <code>application/x-ndjson</code>.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-multi-search.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;MultiSearchResponse&lt;TDocument&gt;&gt; MultiSearchAsync&lt;TDocument&gt;(Indices? indices, Action&lt;MultiSearchRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>indices</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Indices.html">Indices</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.MultiSearchRequestDescriptor-1.html">MultiSearchRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.MultiSearchResponse-1.html">MultiSearchResponse</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MultiSearchAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MultiSearchAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MultiSearchAsync__1_Elastic_Clients_Elasticsearch_Indices_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MultiSearchAsync``1(Elastic.Clients.Elasticsearch.Indices,System.Threading.CancellationToken)">
  MultiSearchAsync&lt;TDocument&gt;(Indices?, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L23810"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Run multiple searches.
</p>
<p>
The format of the request is similar to the bulk API format and makes use of the newline delimited JSON (NDJSON) format.
The structure is as follows:
</p>
<pre><code class="lang-csharp">header\n
body\n
header\n
body\n</code></pre>
<p>
This structure is specifically optimized to reduce parsing if a specific search ends up redirected to another node.
</p>
<p>
IMPORTANT: The final line of data must end with a newline character <code>\n</code>.
Each newline character may be preceded by a carriage return <code>\r</code>.
When sending requests to this endpoint the <code>Content-Type</code> header should be set to <code>application/x-ndjson</code>.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-multi-search.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;MultiSearchResponse&lt;TDocument&gt;&gt; MultiSearchAsync&lt;TDocument&gt;(Indices? indices, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>indices</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Indices.html">Indices</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.MultiSearchResponse-1.html">MultiSearchResponse</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MultiSearchAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MultiSearchAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MultiSearchAsync__1_Elastic_Clients_Elasticsearch_MultiSearchRequest_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MultiSearchAsync``1(Elastic.Clients.Elasticsearch.MultiSearchRequest,System.Threading.CancellationToken)">
  MultiSearchAsync&lt;TDocument&gt;(MultiSearchRequest, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L23589"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Run multiple searches.
</p>
<p>
The format of the request is similar to the bulk API format and makes use of the newline delimited JSON (NDJSON) format.
The structure is as follows:
</p>
<pre><code class="lang-csharp">header\n
body\n
header\n
body\n</code></pre>
<p>
This structure is specifically optimized to reduce parsing if a specific search ends up redirected to another node.
</p>
<p>
IMPORTANT: The final line of data must end with a newline character <code>\n</code>.
Each newline character may be preceded by a carriage return <code>\r</code>.
When sending requests to this endpoint the <code>Content-Type</code> header should be set to <code>application/x-ndjson</code>.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-multi-search.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;MultiSearchResponse&lt;TDocument&gt;&gt; MultiSearchAsync&lt;TDocument&gt;(MultiSearchRequest request, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.MultiSearchRequest.html">MultiSearchRequest</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.MultiSearchResponse-1.html">MultiSearchResponse</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MultiSearchAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MultiSearchAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MultiSearchAsync__1_Elastic_Clients_Elasticsearch_MultiSearchRequestDescriptor___0__System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MultiSearchAsync``1(Elastic.Clients.Elasticsearch.MultiSearchRequestDescriptor{``0},System.Threading.CancellationToken)">
  MultiSearchAsync&lt;TDocument&gt;(MultiSearchRequestDescriptor&lt;TDocument&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L23780"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Run multiple searches.
</p>
<p>
The format of the request is similar to the bulk API format and makes use of the newline delimited JSON (NDJSON) format.
The structure is as follows:
</p>
<pre><code class="lang-csharp">header\n
body\n
header\n
body\n</code></pre>
<p>
This structure is specifically optimized to reduce parsing if a specific search ends up redirected to another node.
</p>
<p>
IMPORTANT: The final line of data must end with a newline character <code>\n</code>.
Each newline character may be preceded by a carriage return <code>\r</code>.
When sending requests to this endpoint the <code>Content-Type</code> header should be set to <code>application/x-ndjson</code>.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-multi-search.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;MultiSearchResponse&lt;TDocument&gt;&gt; MultiSearchAsync&lt;TDocument&gt;(MultiSearchRequestDescriptor&lt;TDocument&gt; descriptor, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.MultiSearchRequestDescriptor-1.html">MultiSearchRequestDescriptor</a>&lt;TDocument&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.MultiSearchResponse-1.html">MultiSearchResponse</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MultiSearchAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MultiSearchAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MultiSearchAsync__1_System_Action_Elastic_Clients_Elasticsearch_MultiSearchRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MultiSearchAsync``1(System.Action{Elastic.Clients.Elasticsearch.MultiSearchRequestDescriptor{``0}},System.Threading.CancellationToken)">
  MultiSearchAsync&lt;TDocument&gt;(Action&lt;MultiSearchRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L23904"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Run multiple searches.
</p>
<p>
The format of the request is similar to the bulk API format and makes use of the newline delimited JSON (NDJSON) format.
The structure is as follows:
</p>
<pre><code class="lang-csharp">header\n
body\n
header\n
body\n</code></pre>
<p>
This structure is specifically optimized to reduce parsing if a specific search ends up redirected to another node.
</p>
<p>
IMPORTANT: The final line of data must end with a newline character <code>\n</code>.
Each newline character may be preceded by a carriage return <code>\r</code>.
When sending requests to this endpoint the <code>Content-Type</code> header should be set to <code>application/x-ndjson</code>.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-multi-search.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;MultiSearchResponse&lt;TDocument&gt;&gt; MultiSearchAsync&lt;TDocument&gt;(Action&lt;MultiSearchRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.MultiSearchRequestDescriptor-1.html">MultiSearchRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.MultiSearchResponse-1.html">MultiSearchResponse</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MultiSearchAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MultiSearchAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MultiSearchAsync__1_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MultiSearchAsync``1(System.Threading.CancellationToken)">
  MultiSearchAsync&lt;TDocument&gt;(CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L23873"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Run multiple searches.
</p>
<p>
The format of the request is similar to the bulk API format and makes use of the newline delimited JSON (NDJSON) format.
The structure is as follows:
</p>
<pre><code class="lang-csharp">header\n
body\n
header\n
body\n</code></pre>
<p>
This structure is specifically optimized to reduce parsing if a specific search ends up redirected to another node.
</p>
<p>
IMPORTANT: The final line of data must end with a newline character <code>\n</code>.
Each newline character may be preceded by a carriage return <code>\r</code>.
When sending requests to this endpoint the <code>Content-Type</code> header should be set to <code>application/x-ndjson</code>.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-multi-search.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;MultiSearchResponse&lt;TDocument&gt;&gt; MultiSearchAsync&lt;TDocument&gt;(CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.MultiSearchResponse-1.html">MultiSearchResponse</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MultiSearchTemplateAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MultiSearchTemplateAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MultiSearchTemplateAsync__1_Elastic_Clients_Elasticsearch_Indices_System_Action_Elastic_Clients_Elasticsearch_MultiSearchTemplateRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MultiSearchTemplateAsync``1(Elastic.Clients.Elasticsearch.Indices,System.Action{Elastic.Clients.Elasticsearch.MultiSearchTemplateRequestDescriptor{``0}},System.Threading.CancellationToken)">
  MultiSearchTemplateAsync&lt;TDocument&gt;(Indices?, Action&lt;MultiSearchTemplateRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L24179"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Run multiple templated searches.
</p>
<p>
Run multiple templated searches with a single request.
If you are providing a text file or text input to <code>curl</code>, use the <code>--data-binary</code> flag instead of <code>-d</code> to preserve newlines.
For example:
</p>
<pre><code class="lang-csharp">$ cat requests
{ "index": "my-index" }
{ "id": "my-search-template", "params": { "query_string": "hello world", "from": 0, "size": 10 }}
{ "index": "my-other-index" }
{ "id": "my-other-search-template", "params": { "query_type": "match_all" }}

$ curl -H "Content-Type: application/x-ndjson" -XGET localhost:9200/_msearch/template --data-binary "@requests"; echo</code></pre>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/multi-search-template.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;MultiSearchTemplateResponse&lt;TDocument&gt;&gt; MultiSearchTemplateAsync&lt;TDocument&gt;(Indices? indices, Action&lt;MultiSearchTemplateRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>indices</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Indices.html">Indices</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.MultiSearchTemplateRequestDescriptor-1.html">MultiSearchTemplateRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.MultiSearchTemplateResponse-1.html">MultiSearchTemplateResponse</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MultiSearchTemplateAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MultiSearchTemplateAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MultiSearchTemplateAsync__1_Elastic_Clients_Elasticsearch_Indices_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MultiSearchTemplateAsync``1(Elastic.Clients.Elasticsearch.Indices,System.Threading.CancellationToken)">
  MultiSearchTemplateAsync&lt;TDocument&gt;(Indices?, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L24152"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Run multiple templated searches.
</p>
<p>
Run multiple templated searches with a single request.
If you are providing a text file or text input to <code>curl</code>, use the <code>--data-binary</code> flag instead of <code>-d</code> to preserve newlines.
For example:
</p>
<pre><code class="lang-csharp">$ cat requests
{ "index": "my-index" }
{ "id": "my-search-template", "params": { "query_string": "hello world", "from": 0, "size": 10 }}
{ "index": "my-other-index" }
{ "id": "my-other-search-template", "params": { "query_type": "match_all" }}

$ curl -H "Content-Type: application/x-ndjson" -XGET localhost:9200/_msearch/template --data-binary "@requests"; echo</code></pre>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/multi-search-template.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;MultiSearchTemplateResponse&lt;TDocument&gt;&gt; MultiSearchTemplateAsync&lt;TDocument&gt;(Indices? indices, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>indices</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Indices.html">Indices</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.MultiSearchTemplateResponse-1.html">MultiSearchTemplateResponse</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MultiSearchTemplateAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MultiSearchTemplateAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MultiSearchTemplateAsync__1_Elastic_Clients_Elasticsearch_MultiSearchTemplateRequest_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MultiSearchTemplateAsync``1(Elastic.Clients.Elasticsearch.MultiSearchTemplateRequest,System.Threading.CancellationToken)">
  MultiSearchTemplateAsync&lt;TDocument&gt;(MultiSearchTemplateRequest, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L23959"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Run multiple templated searches.
</p>
<p>
Run multiple templated searches with a single request.
If you are providing a text file or text input to <code>curl</code>, use the <code>--data-binary</code> flag instead of <code>-d</code> to preserve newlines.
For example:
</p>
<pre><code class="lang-csharp">$ cat requests
{ "index": "my-index" }
{ "id": "my-search-template", "params": { "query_string": "hello world", "from": 0, "size": 10 }}
{ "index": "my-other-index" }
{ "id": "my-other-search-template", "params": { "query_type": "match_all" }}

$ curl -H "Content-Type: application/x-ndjson" -XGET localhost:9200/_msearch/template --data-binary "@requests"; echo</code></pre>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/multi-search-template.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;MultiSearchTemplateResponse&lt;TDocument&gt;&gt; MultiSearchTemplateAsync&lt;TDocument&gt;(MultiSearchTemplateRequest request, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.MultiSearchTemplateRequest.html">MultiSearchTemplateRequest</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.MultiSearchTemplateResponse-1.html">MultiSearchTemplateResponse</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MultiSearchTemplateAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MultiSearchTemplateAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MultiSearchTemplateAsync__1_Elastic_Clients_Elasticsearch_MultiSearchTemplateRequestDescriptor___0__System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MultiSearchTemplateAsync``1(Elastic.Clients.Elasticsearch.MultiSearchTemplateRequestDescriptor{``0},System.Threading.CancellationToken)">
  MultiSearchTemplateAsync&lt;TDocument&gt;(MultiSearchTemplateRequestDescriptor&lt;TDocument&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L24126"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Run multiple templated searches.
</p>
<p>
Run multiple templated searches with a single request.
If you are providing a text file or text input to <code>curl</code>, use the <code>--data-binary</code> flag instead of <code>-d</code> to preserve newlines.
For example:
</p>
<pre><code class="lang-csharp">$ cat requests
{ "index": "my-index" }
{ "id": "my-search-template", "params": { "query_string": "hello world", "from": 0, "size": 10 }}
{ "index": "my-other-index" }
{ "id": "my-other-search-template", "params": { "query_type": "match_all" }}

$ curl -H "Content-Type: application/x-ndjson" -XGET localhost:9200/_msearch/template --data-binary "@requests"; echo</code></pre>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/multi-search-template.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;MultiSearchTemplateResponse&lt;TDocument&gt;&gt; MultiSearchTemplateAsync&lt;TDocument&gt;(MultiSearchTemplateRequestDescriptor&lt;TDocument&gt; descriptor, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.MultiSearchTemplateRequestDescriptor-1.html">MultiSearchTemplateRequestDescriptor</a>&lt;TDocument&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.MultiSearchTemplateResponse-1.html">MultiSearchTemplateResponse</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MultiSearchTemplateAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MultiSearchTemplateAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MultiSearchTemplateAsync__1_System_Action_Elastic_Clients_Elasticsearch_MultiSearchTemplateRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MultiSearchTemplateAsync``1(System.Action{Elastic.Clients.Elasticsearch.MultiSearchTemplateRequestDescriptor{``0}},System.Threading.CancellationToken)">
  MultiSearchTemplateAsync&lt;TDocument&gt;(Action&lt;MultiSearchTemplateRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L24234"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Run multiple templated searches.
</p>
<p>
Run multiple templated searches with a single request.
If you are providing a text file or text input to <code>curl</code>, use the <code>--data-binary</code> flag instead of <code>-d</code> to preserve newlines.
For example:
</p>
<pre><code class="lang-csharp">$ cat requests
{ "index": "my-index" }
{ "id": "my-search-template", "params": { "query_string": "hello world", "from": 0, "size": 10 }}
{ "index": "my-other-index" }
{ "id": "my-other-search-template", "params": { "query_type": "match_all" }}

$ curl -H "Content-Type: application/x-ndjson" -XGET localhost:9200/_msearch/template --data-binary "@requests"; echo</code></pre>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/multi-search-template.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;MultiSearchTemplateResponse&lt;TDocument&gt;&gt; MultiSearchTemplateAsync&lt;TDocument&gt;(Action&lt;MultiSearchTemplateRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.MultiSearchTemplateRequestDescriptor-1.html">MultiSearchTemplateRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.MultiSearchTemplateResponse-1.html">MultiSearchTemplateResponse</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MultiSearchTemplateAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MultiSearchTemplateAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MultiSearchTemplateAsync__1_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MultiSearchTemplateAsync``1(System.Threading.CancellationToken)">
  MultiSearchTemplateAsync&lt;TDocument&gt;(CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L24207"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Run multiple templated searches.
</p>
<p>
Run multiple templated searches with a single request.
If you are providing a text file or text input to <code>curl</code>, use the <code>--data-binary</code> flag instead of <code>-d</code> to preserve newlines.
For example:
</p>
<pre><code class="lang-csharp">$ cat requests
{ "index": "my-index" }
{ "id": "my-search-template", "params": { "query_string": "hello world", "from": 0, "size": 10 }}
{ "index": "my-other-index" }
{ "id": "my-other-search-template", "params": { "query_type": "match_all" }}

$ curl -H "Content-Type: application/x-ndjson" -XGET localhost:9200/_msearch/template --data-binary "@requests"; echo</code></pre>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/multi-search-template.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;MultiSearchTemplateResponse&lt;TDocument&gt;&gt; MultiSearchTemplateAsync&lt;TDocument&gt;(CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.MultiSearchTemplateResponse-1.html">MultiSearchTemplateResponse</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MultiSearchTemplate_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MultiSearchTemplate*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MultiSearchTemplate__1" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MultiSearchTemplate``1">
  MultiSearchTemplate&lt;TDocument&gt;()
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L24069"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Run multiple templated searches.
</p>
<p>
Run multiple templated searches with a single request.
If you are providing a text file or text input to <code>curl</code>, use the <code>--data-binary</code> flag instead of <code>-d</code> to preserve newlines.
For example:
</p>
<pre><code class="lang-csharp">$ cat requests
{ "index": "my-index" }
{ "id": "my-search-template", "params": { "query_string": "hello world", "from": 0, "size": 10 }}
{ "index": "my-other-index" }
{ "id": "my-other-search-template", "params": { "query_type": "match_all" }}

$ curl -H "Content-Type: application/x-ndjson" -XGET localhost:9200/_msearch/template --data-binary "@requests"; echo</code></pre>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/multi-search-template.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual MultiSearchTemplateResponse&lt;TDocument&gt; MultiSearchTemplate&lt;TDocument&gt;()</code></pre>
  </div>


  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.MultiSearchTemplateResponse-1.html">MultiSearchTemplateResponse</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MultiSearchTemplate_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MultiSearchTemplate*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MultiSearchTemplate__1_Elastic_Clients_Elasticsearch_Indices_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MultiSearchTemplate``1(Elastic.Clients.Elasticsearch.Indices)">
  MultiSearchTemplate&lt;TDocument&gt;(Indices?)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L24012"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Run multiple templated searches.
</p>
<p>
Run multiple templated searches with a single request.
If you are providing a text file or text input to <code>curl</code>, use the <code>--data-binary</code> flag instead of <code>-d</code> to preserve newlines.
For example:
</p>
<pre><code class="lang-csharp">$ cat requests
{ "index": "my-index" }
{ "id": "my-search-template", "params": { "query_string": "hello world", "from": 0, "size": 10 }}
{ "index": "my-other-index" }
{ "id": "my-other-search-template", "params": { "query_type": "match_all" }}

$ curl -H "Content-Type: application/x-ndjson" -XGET localhost:9200/_msearch/template --data-binary "@requests"; echo</code></pre>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/multi-search-template.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual MultiSearchTemplateResponse&lt;TDocument&gt; MultiSearchTemplate&lt;TDocument&gt;(Indices? indices)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>indices</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Indices.html">Indices</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.MultiSearchTemplateResponse-1.html">MultiSearchTemplateResponse</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MultiSearchTemplate_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MultiSearchTemplate*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MultiSearchTemplate__1_Elastic_Clients_Elasticsearch_Indices_System_Action_Elastic_Clients_Elasticsearch_MultiSearchTemplateRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MultiSearchTemplate``1(Elastic.Clients.Elasticsearch.Indices,System.Action{Elastic.Clients.Elasticsearch.MultiSearchTemplateRequestDescriptor{``0}})">
  MultiSearchTemplate&lt;TDocument&gt;(Indices?, Action&lt;MultiSearchTemplateRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L24040"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Run multiple templated searches.
</p>
<p>
Run multiple templated searches with a single request.
If you are providing a text file or text input to <code>curl</code>, use the <code>--data-binary</code> flag instead of <code>-d</code> to preserve newlines.
For example:
</p>
<pre><code class="lang-csharp">$ cat requests
{ "index": "my-index" }
{ "id": "my-search-template", "params": { "query_string": "hello world", "from": 0, "size": 10 }}
{ "index": "my-other-index" }
{ "id": "my-other-search-template", "params": { "query_type": "match_all" }}

$ curl -H "Content-Type: application/x-ndjson" -XGET localhost:9200/_msearch/template --data-binary "@requests"; echo</code></pre>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/multi-search-template.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual MultiSearchTemplateResponse&lt;TDocument&gt; MultiSearchTemplate&lt;TDocument&gt;(Indices? indices, Action&lt;MultiSearchTemplateRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>indices</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Indices.html">Indices</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.MultiSearchTemplateRequestDescriptor-1.html">MultiSearchTemplateRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.MultiSearchTemplateResponse-1.html">MultiSearchTemplateResponse</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MultiSearchTemplate_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MultiSearchTemplate*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MultiSearchTemplate__1_Elastic_Clients_Elasticsearch_MultiSearchTemplateRequest_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MultiSearchTemplate``1(Elastic.Clients.Elasticsearch.MultiSearchTemplateRequest)">
  MultiSearchTemplate&lt;TDocument&gt;(MultiSearchTemplateRequest)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L23932"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Run multiple templated searches.
</p>
<p>
Run multiple templated searches with a single request.
If you are providing a text file or text input to <code>curl</code>, use the <code>--data-binary</code> flag instead of <code>-d</code> to preserve newlines.
For example:
</p>
<pre><code class="lang-csharp">$ cat requests
{ "index": "my-index" }
{ "id": "my-search-template", "params": { "query_string": "hello world", "from": 0, "size": 10 }}
{ "index": "my-other-index" }
{ "id": "my-other-search-template", "params": { "query_type": "match_all" }}

$ curl -H "Content-Type: application/x-ndjson" -XGET localhost:9200/_msearch/template --data-binary "@requests"; echo</code></pre>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/multi-search-template.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual MultiSearchTemplateResponse&lt;TDocument&gt; MultiSearchTemplate&lt;TDocument&gt;(MultiSearchTemplateRequest request)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.MultiSearchTemplateRequest.html">MultiSearchTemplateRequest</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.MultiSearchTemplateResponse-1.html">MultiSearchTemplateResponse</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MultiSearchTemplate_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MultiSearchTemplate*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MultiSearchTemplate__1_Elastic_Clients_Elasticsearch_MultiSearchTemplateRequestDescriptor___0__" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MultiSearchTemplate``1(Elastic.Clients.Elasticsearch.MultiSearchTemplateRequestDescriptor{``0})">
  MultiSearchTemplate&lt;TDocument&gt;(MultiSearchTemplateRequestDescriptor&lt;TDocument&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L23985"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Run multiple templated searches.
</p>
<p>
Run multiple templated searches with a single request.
If you are providing a text file or text input to <code>curl</code>, use the <code>--data-binary</code> flag instead of <code>-d</code> to preserve newlines.
For example:
</p>
<pre><code class="lang-csharp">$ cat requests
{ "index": "my-index" }
{ "id": "my-search-template", "params": { "query_string": "hello world", "from": 0, "size": 10 }}
{ "index": "my-other-index" }
{ "id": "my-other-search-template", "params": { "query_type": "match_all" }}

$ curl -H "Content-Type: application/x-ndjson" -XGET localhost:9200/_msearch/template --data-binary "@requests"; echo</code></pre>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/multi-search-template.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual MultiSearchTemplateResponse&lt;TDocument&gt; MultiSearchTemplate&lt;TDocument&gt;(MultiSearchTemplateRequestDescriptor&lt;TDocument&gt; descriptor)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.MultiSearchTemplateRequestDescriptor-1.html">MultiSearchTemplateRequestDescriptor</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.MultiSearchTemplateResponse-1.html">MultiSearchTemplateResponse</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MultiSearchTemplate_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MultiSearchTemplate*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MultiSearchTemplate__1_System_Action_Elastic_Clients_Elasticsearch_MultiSearchTemplateRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MultiSearchTemplate``1(System.Action{Elastic.Clients.Elasticsearch.MultiSearchTemplateRequestDescriptor{``0}})">
  MultiSearchTemplate&lt;TDocument&gt;(Action&lt;MultiSearchTemplateRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L24097"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Run multiple templated searches.
</p>
<p>
Run multiple templated searches with a single request.
If you are providing a text file or text input to <code>curl</code>, use the <code>--data-binary</code> flag instead of <code>-d</code> to preserve newlines.
For example:
</p>
<pre><code class="lang-csharp">$ cat requests
{ "index": "my-index" }
{ "id": "my-search-template", "params": { "query_string": "hello world", "from": 0, "size": 10 }}
{ "index": "my-other-index" }
{ "id": "my-other-search-template", "params": { "query_type": "match_all" }}

$ curl -H "Content-Type: application/x-ndjson" -XGET localhost:9200/_msearch/template --data-binary "@requests"; echo</code></pre>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/multi-search-template.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual MultiSearchTemplateResponse&lt;TDocument&gt; MultiSearchTemplate&lt;TDocument&gt;(Action&lt;MultiSearchTemplateRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.MultiSearchTemplateRequestDescriptor-1.html">MultiSearchTemplateRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.MultiSearchTemplateResponse-1.html">MultiSearchTemplateResponse</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MultiSearch_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MultiSearch*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MultiSearch__1" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MultiSearch``1">
  MultiSearch&lt;TDocument&gt;()
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L23715"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Run multiple searches.
</p>
<p>
The format of the request is similar to the bulk API format and makes use of the newline delimited JSON (NDJSON) format.
The structure is as follows:
</p>
<pre><code class="lang-csharp">header\n
body\n
header\n
body\n</code></pre>
<p>
This structure is specifically optimized to reduce parsing if a specific search ends up redirected to another node.
</p>
<p>
IMPORTANT: The final line of data must end with a newline character <code>\n</code>.
Each newline character may be preceded by a carriage return <code>\r</code>.
When sending requests to this endpoint the <code>Content-Type</code> header should be set to <code>application/x-ndjson</code>.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-multi-search.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual MultiSearchResponse&lt;TDocument&gt; MultiSearch&lt;TDocument&gt;()</code></pre>
  </div>


  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.MultiSearchResponse-1.html">MultiSearchResponse</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MultiSearch_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MultiSearch*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MultiSearch__1_Elastic_Clients_Elasticsearch_Indices_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MultiSearch``1(Elastic.Clients.Elasticsearch.Indices)">
  MultiSearch&lt;TDocument&gt;(Indices?)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L23650"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Run multiple searches.
</p>
<p>
The format of the request is similar to the bulk API format and makes use of the newline delimited JSON (NDJSON) format.
The structure is as follows:
</p>
<pre><code class="lang-csharp">header\n
body\n
header\n
body\n</code></pre>
<p>
This structure is specifically optimized to reduce parsing if a specific search ends up redirected to another node.
</p>
<p>
IMPORTANT: The final line of data must end with a newline character <code>\n</code>.
Each newline character may be preceded by a carriage return <code>\r</code>.
When sending requests to this endpoint the <code>Content-Type</code> header should be set to <code>application/x-ndjson</code>.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-multi-search.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual MultiSearchResponse&lt;TDocument&gt; MultiSearch&lt;TDocument&gt;(Indices? indices)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>indices</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Indices.html">Indices</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.MultiSearchResponse-1.html">MultiSearchResponse</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MultiSearch_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MultiSearch*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MultiSearch__1_Elastic_Clients_Elasticsearch_Indices_System_Action_Elastic_Clients_Elasticsearch_MultiSearchRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MultiSearch``1(Elastic.Clients.Elasticsearch.Indices,System.Action{Elastic.Clients.Elasticsearch.MultiSearchRequestDescriptor{``0}})">
  MultiSearch&lt;TDocument&gt;(Indices?, Action&lt;MultiSearchRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L23682"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Run multiple searches.
</p>
<p>
The format of the request is similar to the bulk API format and makes use of the newline delimited JSON (NDJSON) format.
The structure is as follows:
</p>
<pre><code class="lang-csharp">header\n
body\n
header\n
body\n</code></pre>
<p>
This structure is specifically optimized to reduce parsing if a specific search ends up redirected to another node.
</p>
<p>
IMPORTANT: The final line of data must end with a newline character <code>\n</code>.
Each newline character may be preceded by a carriage return <code>\r</code>.
When sending requests to this endpoint the <code>Content-Type</code> header should be set to <code>application/x-ndjson</code>.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-multi-search.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual MultiSearchResponse&lt;TDocument&gt; MultiSearch&lt;TDocument&gt;(Indices? indices, Action&lt;MultiSearchRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>indices</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Indices.html">Indices</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.MultiSearchRequestDescriptor-1.html">MultiSearchRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.MultiSearchResponse-1.html">MultiSearchResponse</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MultiSearch_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MultiSearch*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MultiSearch__1_Elastic_Clients_Elasticsearch_MultiSearchRequest_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MultiSearch``1(Elastic.Clients.Elasticsearch.MultiSearchRequest)">
  MultiSearch&lt;TDocument&gt;(MultiSearchRequest)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L23558"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Run multiple searches.
</p>
<p>
The format of the request is similar to the bulk API format and makes use of the newline delimited JSON (NDJSON) format.
The structure is as follows:
</p>
<pre><code class="lang-csharp">header\n
body\n
header\n
body\n</code></pre>
<p>
This structure is specifically optimized to reduce parsing if a specific search ends up redirected to another node.
</p>
<p>
IMPORTANT: The final line of data must end with a newline character <code>\n</code>.
Each newline character may be preceded by a carriage return <code>\r</code>.
When sending requests to this endpoint the <code>Content-Type</code> header should be set to <code>application/x-ndjson</code>.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-multi-search.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual MultiSearchResponse&lt;TDocument&gt; MultiSearch&lt;TDocument&gt;(MultiSearchRequest request)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.MultiSearchRequest.html">MultiSearchRequest</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.MultiSearchResponse-1.html">MultiSearchResponse</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MultiSearch_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MultiSearch*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MultiSearch__1_Elastic_Clients_Elasticsearch_MultiSearchRequestDescriptor___0__" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MultiSearch``1(Elastic.Clients.Elasticsearch.MultiSearchRequestDescriptor{``0})">
  MultiSearch&lt;TDocument&gt;(MultiSearchRequestDescriptor&lt;TDocument&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L23619"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Run multiple searches.
</p>
<p>
The format of the request is similar to the bulk API format and makes use of the newline delimited JSON (NDJSON) format.
The structure is as follows:
</p>
<pre><code class="lang-csharp">header\n
body\n
header\n
body\n</code></pre>
<p>
This structure is specifically optimized to reduce parsing if a specific search ends up redirected to another node.
</p>
<p>
IMPORTANT: The final line of data must end with a newline character <code>\n</code>.
Each newline character may be preceded by a carriage return <code>\r</code>.
When sending requests to this endpoint the <code>Content-Type</code> header should be set to <code>application/x-ndjson</code>.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-multi-search.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual MultiSearchResponse&lt;TDocument&gt; MultiSearch&lt;TDocument&gt;(MultiSearchRequestDescriptor&lt;TDocument&gt; descriptor)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.MultiSearchRequestDescriptor-1.html">MultiSearchRequestDescriptor</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.MultiSearchResponse-1.html">MultiSearchResponse</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MultiSearch_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MultiSearch*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_MultiSearch__1_System_Action_Elastic_Clients_Elasticsearch_MultiSearchRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.MultiSearch``1(System.Action{Elastic.Clients.Elasticsearch.MultiSearchRequestDescriptor{``0}})">
  MultiSearch&lt;TDocument&gt;(Action&lt;MultiSearchRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L23747"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Run multiple searches.
</p>
<p>
The format of the request is similar to the bulk API format and makes use of the newline delimited JSON (NDJSON) format.
The structure is as follows:
</p>
<pre><code class="lang-csharp">header\n
body\n
header\n
body\n</code></pre>
<p>
This structure is specifically optimized to reduce parsing if a specific search ends up redirected to another node.
</p>
<p>
IMPORTANT: The final line of data must end with a newline character <code>\n</code>.
Each newline character may be preceded by a carriage return <code>\r</code>.
When sending requests to this endpoint the <code>Content-Type</code> header should be set to <code>application/x-ndjson</code>.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-multi-search.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual MultiSearchResponse&lt;TDocument&gt; MultiSearch&lt;TDocument&gt;(Action&lt;MultiSearchRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.MultiSearchRequestDescriptor-1.html">MultiSearchRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.MultiSearchResponse-1.html">MultiSearchResponse</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_OpenPointInTime_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.OpenPointInTime*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_OpenPointInTime_Elastic_Clients_Elasticsearch_Indices_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.OpenPointInTime(Elastic.Clients.Elasticsearch.Indices)">
  OpenPointInTime(Indices)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L24780"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Open a point in time.
</p>
<p>
A search request by default runs against the most recent visible data of the target indices,
which is called point in time. Elasticsearch pit (point in time) is a lightweight view into the
state of the data as it existed when initiated. In some cases, it’s preferred to perform multiple
search requests using the same point in time. For example, if refreshes happen between
<code>search_after</code> requests, then the results of those requests might not be consistent as changes happening
between searches are only visible to the more recent point in time.
</p>
<p>
A point in time must be opened explicitly before being used in search requests.
</p>
<p>
A subsequent search request with the <code>pit</code> parameter must not specify <code>index</code>, <code>routing</code>, or <code>preference</code> values as these parameters are copied from the point in time.
</p>
<p>
Just like regular searches, you can use <code>from</code> and <code>size</code> to page through point in time search results, up to the first 10,000 hits.
If you want to retrieve more hits, use PIT with <code>search_after</code>.
</p>
<p>
IMPORTANT: The open point in time request and each subsequent search request can return different identifiers; always use the most recently received ID for the next search request.
</p>
<p>
When a PIT that contains shard failures is used in a search request, the missing are always reported in the search response as a <code>NoShardAvailableActionException</code> exception.
To get rid of these exceptions, a new PIT needs to be created so that shards missing from the previous PIT can be handled, assuming they become available in the meantime.
</p>
<p>
<strong>Keeping point in time alive</strong>
</p>
<p>
The <code>keep_alive</code> parameter, which is passed to a open point in time request and search request, extends the time to live of the corresponding point in time.
The value does not need to be long enough to process all data — it just needs to be long enough for the next request.
</p>
<p>
Normally, the background merge process optimizes the index by merging together smaller segments to create new, bigger segments.
Once the smaller segments are no longer needed they are deleted.
However, open point-in-times prevent the old segments from being deleted since they are still in use.
</p>
<p>
TIP: Keeping older segments alive means that more disk space and file handles are needed.
Ensure that you have configured your nodes to have ample free file handles.
</p>
<p>
Additionally, if a segment contains deleted or updated documents then the point in time must keep track of whether each document in the segment was live at the time of the initial search request.
Ensure that your nodes have sufficient heap space if you have many open point-in-times on an index that is subject to ongoing deletes or updates.
Note that a point-in-time doesn't prevent its associated indices from being deleted.
You can check how many point-in-times (that is, search contexts) are open with the nodes stats API.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/point-in-time-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual OpenPointInTimeResponse OpenPointInTime(Indices indices)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>indices</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Indices.html">Indices</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.OpenPointInTimeResponse.html">OpenPointInTimeResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_OpenPointInTime_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.OpenPointInTime*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_OpenPointInTime_Elastic_Clients_Elasticsearch_Indices_System_Action_Elastic_Clients_Elasticsearch_OpenPointInTimeRequestDescriptor__" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.OpenPointInTime(Elastic.Clients.Elasticsearch.Indices,System.Action{Elastic.Clients.Elasticsearch.OpenPointInTimeRequestDescriptor})">
  OpenPointInTime(Indices, Action&lt;OpenPointInTimeRequestDescriptor&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L24841"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Open a point in time.
</p>
<p>
A search request by default runs against the most recent visible data of the target indices,
which is called point in time. Elasticsearch pit (point in time) is a lightweight view into the
state of the data as it existed when initiated. In some cases, it’s preferred to perform multiple
search requests using the same point in time. For example, if refreshes happen between
<code>search_after</code> requests, then the results of those requests might not be consistent as changes happening
between searches are only visible to the more recent point in time.
</p>
<p>
A point in time must be opened explicitly before being used in search requests.
</p>
<p>
A subsequent search request with the <code>pit</code> parameter must not specify <code>index</code>, <code>routing</code>, or <code>preference</code> values as these parameters are copied from the point in time.
</p>
<p>
Just like regular searches, you can use <code>from</code> and <code>size</code> to page through point in time search results, up to the first 10,000 hits.
If you want to retrieve more hits, use PIT with <code>search_after</code>.
</p>
<p>
IMPORTANT: The open point in time request and each subsequent search request can return different identifiers; always use the most recently received ID for the next search request.
</p>
<p>
When a PIT that contains shard failures is used in a search request, the missing are always reported in the search response as a <code>NoShardAvailableActionException</code> exception.
To get rid of these exceptions, a new PIT needs to be created so that shards missing from the previous PIT can be handled, assuming they become available in the meantime.
</p>
<p>
<strong>Keeping point in time alive</strong>
</p>
<p>
The <code>keep_alive</code> parameter, which is passed to a open point in time request and search request, extends the time to live of the corresponding point in time.
The value does not need to be long enough to process all data — it just needs to be long enough for the next request.
</p>
<p>
Normally, the background merge process optimizes the index by merging together smaller segments to create new, bigger segments.
Once the smaller segments are no longer needed they are deleted.
However, open point-in-times prevent the old segments from being deleted since they are still in use.
</p>
<p>
TIP: Keeping older segments alive means that more disk space and file handles are needed.
Ensure that you have configured your nodes to have ample free file handles.
</p>
<p>
Additionally, if a segment contains deleted or updated documents then the point in time must keep track of whether each document in the segment was live at the time of the initial search request.
Ensure that your nodes have sufficient heap space if you have many open point-in-times on an index that is subject to ongoing deletes or updates.
Note that a point-in-time doesn't prevent its associated indices from being deleted.
You can check how many point-in-times (that is, search contexts) are open with the nodes stats API.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/point-in-time-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual OpenPointInTimeResponse OpenPointInTime(Indices indices, Action&lt;OpenPointInTimeRequestDescriptor&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>indices</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Indices.html">Indices</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.OpenPointInTimeRequestDescriptor.html">OpenPointInTimeRequestDescriptor</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.OpenPointInTimeResponse.html">OpenPointInTimeResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_OpenPointInTime_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.OpenPointInTime*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_OpenPointInTime_Elastic_Clients_Elasticsearch_OpenPointInTimeRequest_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.OpenPointInTime(Elastic.Clients.Elasticsearch.OpenPointInTimeRequest)">
  OpenPointInTime(OpenPointInTimeRequest)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L24295"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Open a point in time.
</p>
<p>
A search request by default runs against the most recent visible data of the target indices,
which is called point in time. Elasticsearch pit (point in time) is a lightweight view into the
state of the data as it existed when initiated. In some cases, it’s preferred to perform multiple
search requests using the same point in time. For example, if refreshes happen between
<code>search_after</code> requests, then the results of those requests might not be consistent as changes happening
between searches are only visible to the more recent point in time.
</p>
<p>
A point in time must be opened explicitly before being used in search requests.
</p>
<p>
A subsequent search request with the <code>pit</code> parameter must not specify <code>index</code>, <code>routing</code>, or <code>preference</code> values as these parameters are copied from the point in time.
</p>
<p>
Just like regular searches, you can use <code>from</code> and <code>size</code> to page through point in time search results, up to the first 10,000 hits.
If you want to retrieve more hits, use PIT with <code>search_after</code>.
</p>
<p>
IMPORTANT: The open point in time request and each subsequent search request can return different identifiers; always use the most recently received ID for the next search request.
</p>
<p>
When a PIT that contains shard failures is used in a search request, the missing are always reported in the search response as a <code>NoShardAvailableActionException</code> exception.
To get rid of these exceptions, a new PIT needs to be created so that shards missing from the previous PIT can be handled, assuming they become available in the meantime.
</p>
<p>
<strong>Keeping point in time alive</strong>
</p>
<p>
The <code>keep_alive</code> parameter, which is passed to a open point in time request and search request, extends the time to live of the corresponding point in time.
The value does not need to be long enough to process all data — it just needs to be long enough for the next request.
</p>
<p>
Normally, the background merge process optimizes the index by merging together smaller segments to create new, bigger segments.
Once the smaller segments are no longer needed they are deleted.
However, open point-in-times prevent the old segments from being deleted since they are still in use.
</p>
<p>
TIP: Keeping older segments alive means that more disk space and file handles are needed.
Ensure that you have configured your nodes to have ample free file handles.
</p>
<p>
Additionally, if a segment contains deleted or updated documents then the point in time must keep track of whether each document in the segment was live at the time of the initial search request.
Ensure that your nodes have sufficient heap space if you have many open point-in-times on an index that is subject to ongoing deletes or updates.
Note that a point-in-time doesn't prevent its associated indices from being deleted.
You can check how many point-in-times (that is, search contexts) are open with the nodes stats API.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/point-in-time-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual OpenPointInTimeResponse OpenPointInTime(OpenPointInTimeRequest request)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.OpenPointInTimeRequest.html">OpenPointInTimeRequest</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.OpenPointInTimeResponse.html">OpenPointInTimeResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_OpenPointInTime_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.OpenPointInTime*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_OpenPointInTime_Elastic_Clients_Elasticsearch_OpenPointInTimeRequestDescriptor_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.OpenPointInTime(Elastic.Clients.Elasticsearch.OpenPointInTimeRequestDescriptor)">
  OpenPointInTime(OpenPointInTimeRequestDescriptor)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L24720"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Open a point in time.
</p>
<p>
A search request by default runs against the most recent visible data of the target indices,
which is called point in time. Elasticsearch pit (point in time) is a lightweight view into the
state of the data as it existed when initiated. In some cases, it’s preferred to perform multiple
search requests using the same point in time. For example, if refreshes happen between
<code>search_after</code> requests, then the results of those requests might not be consistent as changes happening
between searches are only visible to the more recent point in time.
</p>
<p>
A point in time must be opened explicitly before being used in search requests.
</p>
<p>
A subsequent search request with the <code>pit</code> parameter must not specify <code>index</code>, <code>routing</code>, or <code>preference</code> values as these parameters are copied from the point in time.
</p>
<p>
Just like regular searches, you can use <code>from</code> and <code>size</code> to page through point in time search results, up to the first 10,000 hits.
If you want to retrieve more hits, use PIT with <code>search_after</code>.
</p>
<p>
IMPORTANT: The open point in time request and each subsequent search request can return different identifiers; always use the most recently received ID for the next search request.
</p>
<p>
When a PIT that contains shard failures is used in a search request, the missing are always reported in the search response as a <code>NoShardAvailableActionException</code> exception.
To get rid of these exceptions, a new PIT needs to be created so that shards missing from the previous PIT can be handled, assuming they become available in the meantime.
</p>
<p>
<strong>Keeping point in time alive</strong>
</p>
<p>
The <code>keep_alive</code> parameter, which is passed to a open point in time request and search request, extends the time to live of the corresponding point in time.
The value does not need to be long enough to process all data — it just needs to be long enough for the next request.
</p>
<p>
Normally, the background merge process optimizes the index by merging together smaller segments to create new, bigger segments.
Once the smaller segments are no longer needed they are deleted.
However, open point-in-times prevent the old segments from being deleted since they are still in use.
</p>
<p>
TIP: Keeping older segments alive means that more disk space and file handles are needed.
Ensure that you have configured your nodes to have ample free file handles.
</p>
<p>
Additionally, if a segment contains deleted or updated documents then the point in time must keep track of whether each document in the segment was live at the time of the initial search request.
Ensure that your nodes have sufficient heap space if you have many open point-in-times on an index that is subject to ongoing deletes or updates.
Note that a point-in-time doesn't prevent its associated indices from being deleted.
You can check how many point-in-times (that is, search contexts) are open with the nodes stats API.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/point-in-time-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual OpenPointInTimeResponse OpenPointInTime(OpenPointInTimeRequestDescriptor descriptor)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.OpenPointInTimeRequestDescriptor.html">OpenPointInTimeRequestDescriptor</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.OpenPointInTimeResponse.html">OpenPointInTimeResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_OpenPointInTimeAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.OpenPointInTimeAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_OpenPointInTimeAsync_Elastic_Clients_Elasticsearch_Indices_System_Action_Elastic_Clients_Elasticsearch_OpenPointInTimeRequestDescriptor__System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.OpenPointInTimeAsync(Elastic.Clients.Elasticsearch.Indices,System.Action{Elastic.Clients.Elasticsearch.OpenPointInTimeRequestDescriptor},System.Threading.CancellationToken)">
  OpenPointInTimeAsync(Indices, Action&lt;OpenPointInTimeRequestDescriptor&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L25323"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Open a point in time.
</p>
<p>
A search request by default runs against the most recent visible data of the target indices,
which is called point in time. Elasticsearch pit (point in time) is a lightweight view into the
state of the data as it existed when initiated. In some cases, it’s preferred to perform multiple
search requests using the same point in time. For example, if refreshes happen between
<code>search_after</code> requests, then the results of those requests might not be consistent as changes happening
between searches are only visible to the more recent point in time.
</p>
<p>
A point in time must be opened explicitly before being used in search requests.
</p>
<p>
A subsequent search request with the <code>pit</code> parameter must not specify <code>index</code>, <code>routing</code>, or <code>preference</code> values as these parameters are copied from the point in time.
</p>
<p>
Just like regular searches, you can use <code>from</code> and <code>size</code> to page through point in time search results, up to the first 10,000 hits.
If you want to retrieve more hits, use PIT with <code>search_after</code>.
</p>
<p>
IMPORTANT: The open point in time request and each subsequent search request can return different identifiers; always use the most recently received ID for the next search request.
</p>
<p>
When a PIT that contains shard failures is used in a search request, the missing are always reported in the search response as a <code>NoShardAvailableActionException</code> exception.
To get rid of these exceptions, a new PIT needs to be created so that shards missing from the previous PIT can be handled, assuming they become available in the meantime.
</p>
<p>
<strong>Keeping point in time alive</strong>
</p>
<p>
The <code>keep_alive</code> parameter, which is passed to a open point in time request and search request, extends the time to live of the corresponding point in time.
The value does not need to be long enough to process all data — it just needs to be long enough for the next request.
</p>
<p>
Normally, the background merge process optimizes the index by merging together smaller segments to create new, bigger segments.
Once the smaller segments are no longer needed they are deleted.
However, open point-in-times prevent the old segments from being deleted since they are still in use.
</p>
<p>
TIP: Keeping older segments alive means that more disk space and file handles are needed.
Ensure that you have configured your nodes to have ample free file handles.
</p>
<p>
Additionally, if a segment contains deleted or updated documents then the point in time must keep track of whether each document in the segment was live at the time of the initial search request.
Ensure that your nodes have sufficient heap space if you have many open point-in-times on an index that is subject to ongoing deletes or updates.
Note that a point-in-time doesn't prevent its associated indices from being deleted.
You can check how many point-in-times (that is, search contexts) are open with the nodes stats API.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/point-in-time-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;OpenPointInTimeResponse&gt; OpenPointInTimeAsync(Indices indices, Action&lt;OpenPointInTimeRequestDescriptor&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>indices</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Indices.html">Indices</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.OpenPointInTimeRequestDescriptor.html">OpenPointInTimeRequestDescriptor</a>&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.OpenPointInTimeResponse.html">OpenPointInTimeResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_OpenPointInTimeAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.OpenPointInTimeAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_OpenPointInTimeAsync_Elastic_Clients_Elasticsearch_Indices_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.OpenPointInTimeAsync(Elastic.Clients.Elasticsearch.Indices,System.Threading.CancellationToken)">
  OpenPointInTimeAsync(Indices, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L25263"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Open a point in time.
</p>
<p>
A search request by default runs against the most recent visible data of the target indices,
which is called point in time. Elasticsearch pit (point in time) is a lightweight view into the
state of the data as it existed when initiated. In some cases, it’s preferred to perform multiple
search requests using the same point in time. For example, if refreshes happen between
<code>search_after</code> requests, then the results of those requests might not be consistent as changes happening
between searches are only visible to the more recent point in time.
</p>
<p>
A point in time must be opened explicitly before being used in search requests.
</p>
<p>
A subsequent search request with the <code>pit</code> parameter must not specify <code>index</code>, <code>routing</code>, or <code>preference</code> values as these parameters are copied from the point in time.
</p>
<p>
Just like regular searches, you can use <code>from</code> and <code>size</code> to page through point in time search results, up to the first 10,000 hits.
If you want to retrieve more hits, use PIT with <code>search_after</code>.
</p>
<p>
IMPORTANT: The open point in time request and each subsequent search request can return different identifiers; always use the most recently received ID for the next search request.
</p>
<p>
When a PIT that contains shard failures is used in a search request, the missing are always reported in the search response as a <code>NoShardAvailableActionException</code> exception.
To get rid of these exceptions, a new PIT needs to be created so that shards missing from the previous PIT can be handled, assuming they become available in the meantime.
</p>
<p>
<strong>Keeping point in time alive</strong>
</p>
<p>
The <code>keep_alive</code> parameter, which is passed to a open point in time request and search request, extends the time to live of the corresponding point in time.
The value does not need to be long enough to process all data — it just needs to be long enough for the next request.
</p>
<p>
Normally, the background merge process optimizes the index by merging together smaller segments to create new, bigger segments.
Once the smaller segments are no longer needed they are deleted.
However, open point-in-times prevent the old segments from being deleted since they are still in use.
</p>
<p>
TIP: Keeping older segments alive means that more disk space and file handles are needed.
Ensure that you have configured your nodes to have ample free file handles.
</p>
<p>
Additionally, if a segment contains deleted or updated documents then the point in time must keep track of whether each document in the segment was live at the time of the initial search request.
Ensure that your nodes have sufficient heap space if you have many open point-in-times on an index that is subject to ongoing deletes or updates.
Note that a point-in-time doesn't prevent its associated indices from being deleted.
You can check how many point-in-times (that is, search contexts) are open with the nodes stats API.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/point-in-time-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;OpenPointInTimeResponse&gt; OpenPointInTimeAsync(Indices indices, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>indices</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Indices.html">Indices</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.OpenPointInTimeResponse.html">OpenPointInTimeResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_OpenPointInTimeAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.OpenPointInTimeAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_OpenPointInTimeAsync_Elastic_Clients_Elasticsearch_OpenPointInTimeRequest_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.OpenPointInTimeAsync(Elastic.Clients.Elasticsearch.OpenPointInTimeRequest,System.Threading.CancellationToken)">
  OpenPointInTimeAsync(OpenPointInTimeRequest, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L24355"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Open a point in time.
</p>
<p>
A search request by default runs against the most recent visible data of the target indices,
which is called point in time. Elasticsearch pit (point in time) is a lightweight view into the
state of the data as it existed when initiated. In some cases, it’s preferred to perform multiple
search requests using the same point in time. For example, if refreshes happen between
<code>search_after</code> requests, then the results of those requests might not be consistent as changes happening
between searches are only visible to the more recent point in time.
</p>
<p>
A point in time must be opened explicitly before being used in search requests.
</p>
<p>
A subsequent search request with the <code>pit</code> parameter must not specify <code>index</code>, <code>routing</code>, or <code>preference</code> values as these parameters are copied from the point in time.
</p>
<p>
Just like regular searches, you can use <code>from</code> and <code>size</code> to page through point in time search results, up to the first 10,000 hits.
If you want to retrieve more hits, use PIT with <code>search_after</code>.
</p>
<p>
IMPORTANT: The open point in time request and each subsequent search request can return different identifiers; always use the most recently received ID for the next search request.
</p>
<p>
When a PIT that contains shard failures is used in a search request, the missing are always reported in the search response as a <code>NoShardAvailableActionException</code> exception.
To get rid of these exceptions, a new PIT needs to be created so that shards missing from the previous PIT can be handled, assuming they become available in the meantime.
</p>
<p>
<strong>Keeping point in time alive</strong>
</p>
<p>
The <code>keep_alive</code> parameter, which is passed to a open point in time request and search request, extends the time to live of the corresponding point in time.
The value does not need to be long enough to process all data — it just needs to be long enough for the next request.
</p>
<p>
Normally, the background merge process optimizes the index by merging together smaller segments to create new, bigger segments.
Once the smaller segments are no longer needed they are deleted.
However, open point-in-times prevent the old segments from being deleted since they are still in use.
</p>
<p>
TIP: Keeping older segments alive means that more disk space and file handles are needed.
Ensure that you have configured your nodes to have ample free file handles.
</p>
<p>
Additionally, if a segment contains deleted or updated documents then the point in time must keep track of whether each document in the segment was live at the time of the initial search request.
Ensure that your nodes have sufficient heap space if you have many open point-in-times on an index that is subject to ongoing deletes or updates.
Note that a point-in-time doesn't prevent its associated indices from being deleted.
You can check how many point-in-times (that is, search contexts) are open with the nodes stats API.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/point-in-time-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;OpenPointInTimeResponse&gt; OpenPointInTimeAsync(OpenPointInTimeRequest request, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.OpenPointInTimeRequest.html">OpenPointInTimeRequest</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.OpenPointInTimeResponse.html">OpenPointInTimeResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_OpenPointInTimeAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.OpenPointInTimeAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_OpenPointInTimeAsync_Elastic_Clients_Elasticsearch_OpenPointInTimeRequestDescriptor_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.OpenPointInTimeAsync(Elastic.Clients.Elasticsearch.OpenPointInTimeRequestDescriptor,System.Threading.CancellationToken)">
  OpenPointInTimeAsync(OpenPointInTimeRequestDescriptor, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L25204"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Open a point in time.
</p>
<p>
A search request by default runs against the most recent visible data of the target indices,
which is called point in time. Elasticsearch pit (point in time) is a lightweight view into the
state of the data as it existed when initiated. In some cases, it’s preferred to perform multiple
search requests using the same point in time. For example, if refreshes happen between
<code>search_after</code> requests, then the results of those requests might not be consistent as changes happening
between searches are only visible to the more recent point in time.
</p>
<p>
A point in time must be opened explicitly before being used in search requests.
</p>
<p>
A subsequent search request with the <code>pit</code> parameter must not specify <code>index</code>, <code>routing</code>, or <code>preference</code> values as these parameters are copied from the point in time.
</p>
<p>
Just like regular searches, you can use <code>from</code> and <code>size</code> to page through point in time search results, up to the first 10,000 hits.
If you want to retrieve more hits, use PIT with <code>search_after</code>.
</p>
<p>
IMPORTANT: The open point in time request and each subsequent search request can return different identifiers; always use the most recently received ID for the next search request.
</p>
<p>
When a PIT that contains shard failures is used in a search request, the missing are always reported in the search response as a <code>NoShardAvailableActionException</code> exception.
To get rid of these exceptions, a new PIT needs to be created so that shards missing from the previous PIT can be handled, assuming they become available in the meantime.
</p>
<p>
<strong>Keeping point in time alive</strong>
</p>
<p>
The <code>keep_alive</code> parameter, which is passed to a open point in time request and search request, extends the time to live of the corresponding point in time.
The value does not need to be long enough to process all data — it just needs to be long enough for the next request.
</p>
<p>
Normally, the background merge process optimizes the index by merging together smaller segments to create new, bigger segments.
Once the smaller segments are no longer needed they are deleted.
However, open point-in-times prevent the old segments from being deleted since they are still in use.
</p>
<p>
TIP: Keeping older segments alive means that more disk space and file handles are needed.
Ensure that you have configured your nodes to have ample free file handles.
</p>
<p>
Additionally, if a segment contains deleted or updated documents then the point in time must keep track of whether each document in the segment was live at the time of the initial search request.
Ensure that your nodes have sufficient heap space if you have many open point-in-times on an index that is subject to ongoing deletes or updates.
Note that a point-in-time doesn't prevent its associated indices from being deleted.
You can check how many point-in-times (that is, search contexts) are open with the nodes stats API.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/point-in-time-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;OpenPointInTimeResponse&gt; OpenPointInTimeAsync(OpenPointInTimeRequestDescriptor descriptor, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.OpenPointInTimeRequestDescriptor.html">OpenPointInTimeRequestDescriptor</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.OpenPointInTimeResponse.html">OpenPointInTimeResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_OpenPointInTimeAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.OpenPointInTimeAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_OpenPointInTimeAsync__1_Elastic_Clients_Elasticsearch_Indices_System_Action_Elastic_Clients_Elasticsearch_OpenPointInTimeRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.OpenPointInTimeAsync``1(Elastic.Clients.Elasticsearch.Indices,System.Action{Elastic.Clients.Elasticsearch.OpenPointInTimeRequestDescriptor{``0}},System.Threading.CancellationToken)">
  OpenPointInTimeAsync&lt;TDocument&gt;(Indices, Action&lt;OpenPointInTimeRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L25022"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Open a point in time.
</p>
<p>
A search request by default runs against the most recent visible data of the target indices,
which is called point in time. Elasticsearch pit (point in time) is a lightweight view into the
state of the data as it existed when initiated. In some cases, it’s preferred to perform multiple
search requests using the same point in time. For example, if refreshes happen between
<code>search_after</code> requests, then the results of those requests might not be consistent as changes happening
between searches are only visible to the more recent point in time.
</p>
<p>
A point in time must be opened explicitly before being used in search requests.
</p>
<p>
A subsequent search request with the <code>pit</code> parameter must not specify <code>index</code>, <code>routing</code>, or <code>preference</code> values as these parameters are copied from the point in time.
</p>
<p>
Just like regular searches, you can use <code>from</code> and <code>size</code> to page through point in time search results, up to the first 10,000 hits.
If you want to retrieve more hits, use PIT with <code>search_after</code>.
</p>
<p>
IMPORTANT: The open point in time request and each subsequent search request can return different identifiers; always use the most recently received ID for the next search request.
</p>
<p>
When a PIT that contains shard failures is used in a search request, the missing are always reported in the search response as a <code>NoShardAvailableActionException</code> exception.
To get rid of these exceptions, a new PIT needs to be created so that shards missing from the previous PIT can be handled, assuming they become available in the meantime.
</p>
<p>
<strong>Keeping point in time alive</strong>
</p>
<p>
The <code>keep_alive</code> parameter, which is passed to a open point in time request and search request, extends the time to live of the corresponding point in time.
The value does not need to be long enough to process all data — it just needs to be long enough for the next request.
</p>
<p>
Normally, the background merge process optimizes the index by merging together smaller segments to create new, bigger segments.
Once the smaller segments are no longer needed they are deleted.
However, open point-in-times prevent the old segments from being deleted since they are still in use.
</p>
<p>
TIP: Keeping older segments alive means that more disk space and file handles are needed.
Ensure that you have configured your nodes to have ample free file handles.
</p>
<p>
Additionally, if a segment contains deleted or updated documents then the point in time must keep track of whether each document in the segment was live at the time of the initial search request.
Ensure that your nodes have sufficient heap space if you have many open point-in-times on an index that is subject to ongoing deletes or updates.
Note that a point-in-time doesn't prevent its associated indices from being deleted.
You can check how many point-in-times (that is, search contexts) are open with the nodes stats API.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/point-in-time-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;OpenPointInTimeResponse&gt; OpenPointInTimeAsync&lt;TDocument&gt;(Indices indices, Action&lt;OpenPointInTimeRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>indices</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Indices.html">Indices</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.OpenPointInTimeRequestDescriptor-1.html">OpenPointInTimeRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.OpenPointInTimeResponse.html">OpenPointInTimeResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_OpenPointInTimeAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.OpenPointInTimeAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_OpenPointInTimeAsync__1_Elastic_Clients_Elasticsearch_Indices_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.OpenPointInTimeAsync``1(Elastic.Clients.Elasticsearch.Indices,System.Threading.CancellationToken)">
  OpenPointInTimeAsync&lt;TDocument&gt;(Indices, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L24962"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Open a point in time.
</p>
<p>
A search request by default runs against the most recent visible data of the target indices,
which is called point in time. Elasticsearch pit (point in time) is a lightweight view into the
state of the data as it existed when initiated. In some cases, it’s preferred to perform multiple
search requests using the same point in time. For example, if refreshes happen between
<code>search_after</code> requests, then the results of those requests might not be consistent as changes happening
between searches are only visible to the more recent point in time.
</p>
<p>
A point in time must be opened explicitly before being used in search requests.
</p>
<p>
A subsequent search request with the <code>pit</code> parameter must not specify <code>index</code>, <code>routing</code>, or <code>preference</code> values as these parameters are copied from the point in time.
</p>
<p>
Just like regular searches, you can use <code>from</code> and <code>size</code> to page through point in time search results, up to the first 10,000 hits.
If you want to retrieve more hits, use PIT with <code>search_after</code>.
</p>
<p>
IMPORTANT: The open point in time request and each subsequent search request can return different identifiers; always use the most recently received ID for the next search request.
</p>
<p>
When a PIT that contains shard failures is used in a search request, the missing are always reported in the search response as a <code>NoShardAvailableActionException</code> exception.
To get rid of these exceptions, a new PIT needs to be created so that shards missing from the previous PIT can be handled, assuming they become available in the meantime.
</p>
<p>
<strong>Keeping point in time alive</strong>
</p>
<p>
The <code>keep_alive</code> parameter, which is passed to a open point in time request and search request, extends the time to live of the corresponding point in time.
The value does not need to be long enough to process all data — it just needs to be long enough for the next request.
</p>
<p>
Normally, the background merge process optimizes the index by merging together smaller segments to create new, bigger segments.
Once the smaller segments are no longer needed they are deleted.
However, open point-in-times prevent the old segments from being deleted since they are still in use.
</p>
<p>
TIP: Keeping older segments alive means that more disk space and file handles are needed.
Ensure that you have configured your nodes to have ample free file handles.
</p>
<p>
Additionally, if a segment contains deleted or updated documents then the point in time must keep track of whether each document in the segment was live at the time of the initial search request.
Ensure that your nodes have sufficient heap space if you have many open point-in-times on an index that is subject to ongoing deletes or updates.
Note that a point-in-time doesn't prevent its associated indices from being deleted.
You can check how many point-in-times (that is, search contexts) are open with the nodes stats API.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/point-in-time-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;OpenPointInTimeResponse&gt; OpenPointInTimeAsync&lt;TDocument&gt;(Indices indices, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>indices</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Indices.html">Indices</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.OpenPointInTimeResponse.html">OpenPointInTimeResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_OpenPointInTimeAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.OpenPointInTimeAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_OpenPointInTimeAsync__1_Elastic_Clients_Elasticsearch_OpenPointInTimeRequestDescriptor___0__System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.OpenPointInTimeAsync``1(Elastic.Clients.Elasticsearch.OpenPointInTimeRequestDescriptor{``0},System.Threading.CancellationToken)">
  OpenPointInTimeAsync&lt;TDocument&gt;(OpenPointInTimeRequestDescriptor&lt;TDocument&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L24903"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Open a point in time.
</p>
<p>
A search request by default runs against the most recent visible data of the target indices,
which is called point in time. Elasticsearch pit (point in time) is a lightweight view into the
state of the data as it existed when initiated. In some cases, it’s preferred to perform multiple
search requests using the same point in time. For example, if refreshes happen between
<code>search_after</code> requests, then the results of those requests might not be consistent as changes happening
between searches are only visible to the more recent point in time.
</p>
<p>
A point in time must be opened explicitly before being used in search requests.
</p>
<p>
A subsequent search request with the <code>pit</code> parameter must not specify <code>index</code>, <code>routing</code>, or <code>preference</code> values as these parameters are copied from the point in time.
</p>
<p>
Just like regular searches, you can use <code>from</code> and <code>size</code> to page through point in time search results, up to the first 10,000 hits.
If you want to retrieve more hits, use PIT with <code>search_after</code>.
</p>
<p>
IMPORTANT: The open point in time request and each subsequent search request can return different identifiers; always use the most recently received ID for the next search request.
</p>
<p>
When a PIT that contains shard failures is used in a search request, the missing are always reported in the search response as a <code>NoShardAvailableActionException</code> exception.
To get rid of these exceptions, a new PIT needs to be created so that shards missing from the previous PIT can be handled, assuming they become available in the meantime.
</p>
<p>
<strong>Keeping point in time alive</strong>
</p>
<p>
The <code>keep_alive</code> parameter, which is passed to a open point in time request and search request, extends the time to live of the corresponding point in time.
The value does not need to be long enough to process all data — it just needs to be long enough for the next request.
</p>
<p>
Normally, the background merge process optimizes the index by merging together smaller segments to create new, bigger segments.
Once the smaller segments are no longer needed they are deleted.
However, open point-in-times prevent the old segments from being deleted since they are still in use.
</p>
<p>
TIP: Keeping older segments alive means that more disk space and file handles are needed.
Ensure that you have configured your nodes to have ample free file handles.
</p>
<p>
Additionally, if a segment contains deleted or updated documents then the point in time must keep track of whether each document in the segment was live at the time of the initial search request.
Ensure that your nodes have sufficient heap space if you have many open point-in-times on an index that is subject to ongoing deletes or updates.
Note that a point-in-time doesn't prevent its associated indices from being deleted.
You can check how many point-in-times (that is, search contexts) are open with the nodes stats API.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/point-in-time-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;OpenPointInTimeResponse&gt; OpenPointInTimeAsync&lt;TDocument&gt;(OpenPointInTimeRequestDescriptor&lt;TDocument&gt; descriptor, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.OpenPointInTimeRequestDescriptor-1.html">OpenPointInTimeRequestDescriptor</a>&lt;TDocument&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.OpenPointInTimeResponse.html">OpenPointInTimeResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_OpenPointInTimeAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.OpenPointInTimeAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_OpenPointInTimeAsync__1_System_Action_Elastic_Clients_Elasticsearch_OpenPointInTimeRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.OpenPointInTimeAsync``1(System.Action{Elastic.Clients.Elasticsearch.OpenPointInTimeRequestDescriptor{``0}},System.Threading.CancellationToken)">
  OpenPointInTimeAsync&lt;TDocument&gt;(Action&lt;OpenPointInTimeRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L25143"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Open a point in time.
</p>
<p>
A search request by default runs against the most recent visible data of the target indices,
which is called point in time. Elasticsearch pit (point in time) is a lightweight view into the
state of the data as it existed when initiated. In some cases, it’s preferred to perform multiple
search requests using the same point in time. For example, if refreshes happen between
<code>search_after</code> requests, then the results of those requests might not be consistent as changes happening
between searches are only visible to the more recent point in time.
</p>
<p>
A point in time must be opened explicitly before being used in search requests.
</p>
<p>
A subsequent search request with the <code>pit</code> parameter must not specify <code>index</code>, <code>routing</code>, or <code>preference</code> values as these parameters are copied from the point in time.
</p>
<p>
Just like regular searches, you can use <code>from</code> and <code>size</code> to page through point in time search results, up to the first 10,000 hits.
If you want to retrieve more hits, use PIT with <code>search_after</code>.
</p>
<p>
IMPORTANT: The open point in time request and each subsequent search request can return different identifiers; always use the most recently received ID for the next search request.
</p>
<p>
When a PIT that contains shard failures is used in a search request, the missing are always reported in the search response as a <code>NoShardAvailableActionException</code> exception.
To get rid of these exceptions, a new PIT needs to be created so that shards missing from the previous PIT can be handled, assuming they become available in the meantime.
</p>
<p>
<strong>Keeping point in time alive</strong>
</p>
<p>
The <code>keep_alive</code> parameter, which is passed to a open point in time request and search request, extends the time to live of the corresponding point in time.
The value does not need to be long enough to process all data — it just needs to be long enough for the next request.
</p>
<p>
Normally, the background merge process optimizes the index by merging together smaller segments to create new, bigger segments.
Once the smaller segments are no longer needed they are deleted.
However, open point-in-times prevent the old segments from being deleted since they are still in use.
</p>
<p>
TIP: Keeping older segments alive means that more disk space and file handles are needed.
Ensure that you have configured your nodes to have ample free file handles.
</p>
<p>
Additionally, if a segment contains deleted or updated documents then the point in time must keep track of whether each document in the segment was live at the time of the initial search request.
Ensure that your nodes have sufficient heap space if you have many open point-in-times on an index that is subject to ongoing deletes or updates.
Note that a point-in-time doesn't prevent its associated indices from being deleted.
You can check how many point-in-times (that is, search contexts) are open with the nodes stats API.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/point-in-time-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;OpenPointInTimeResponse&gt; OpenPointInTimeAsync&lt;TDocument&gt;(Action&lt;OpenPointInTimeRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.OpenPointInTimeRequestDescriptor-1.html">OpenPointInTimeRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.OpenPointInTimeResponse.html">OpenPointInTimeResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_OpenPointInTimeAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.OpenPointInTimeAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_OpenPointInTimeAsync__1_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.OpenPointInTimeAsync``1(System.Threading.CancellationToken)">
  OpenPointInTimeAsync&lt;TDocument&gt;(CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L25083"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Open a point in time.
</p>
<p>
A search request by default runs against the most recent visible data of the target indices,
which is called point in time. Elasticsearch pit (point in time) is a lightweight view into the
state of the data as it existed when initiated. In some cases, it’s preferred to perform multiple
search requests using the same point in time. For example, if refreshes happen between
<code>search_after</code> requests, then the results of those requests might not be consistent as changes happening
between searches are only visible to the more recent point in time.
</p>
<p>
A point in time must be opened explicitly before being used in search requests.
</p>
<p>
A subsequent search request with the <code>pit</code> parameter must not specify <code>index</code>, <code>routing</code>, or <code>preference</code> values as these parameters are copied from the point in time.
</p>
<p>
Just like regular searches, you can use <code>from</code> and <code>size</code> to page through point in time search results, up to the first 10,000 hits.
If you want to retrieve more hits, use PIT with <code>search_after</code>.
</p>
<p>
IMPORTANT: The open point in time request and each subsequent search request can return different identifiers; always use the most recently received ID for the next search request.
</p>
<p>
When a PIT that contains shard failures is used in a search request, the missing are always reported in the search response as a <code>NoShardAvailableActionException</code> exception.
To get rid of these exceptions, a new PIT needs to be created so that shards missing from the previous PIT can be handled, assuming they become available in the meantime.
</p>
<p>
<strong>Keeping point in time alive</strong>
</p>
<p>
The <code>keep_alive</code> parameter, which is passed to a open point in time request and search request, extends the time to live of the corresponding point in time.
The value does not need to be long enough to process all data — it just needs to be long enough for the next request.
</p>
<p>
Normally, the background merge process optimizes the index by merging together smaller segments to create new, bigger segments.
Once the smaller segments are no longer needed they are deleted.
However, open point-in-times prevent the old segments from being deleted since they are still in use.
</p>
<p>
TIP: Keeping older segments alive means that more disk space and file handles are needed.
Ensure that you have configured your nodes to have ample free file handles.
</p>
<p>
Additionally, if a segment contains deleted or updated documents then the point in time must keep track of whether each document in the segment was live at the time of the initial search request.
Ensure that your nodes have sufficient heap space if you have many open point-in-times on an index that is subject to ongoing deletes or updates.
Note that a point-in-time doesn't prevent its associated indices from being deleted.
You can check how many point-in-times (that is, search contexts) are open with the nodes stats API.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/point-in-time-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;OpenPointInTimeResponse&gt; OpenPointInTimeAsync&lt;TDocument&gt;(CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.OpenPointInTimeResponse.html">OpenPointInTimeResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_OpenPointInTime_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.OpenPointInTime*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_OpenPointInTime__1" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.OpenPointInTime``1">
  OpenPointInTime&lt;TDocument&gt;()
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L24597"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Open a point in time.
</p>
<p>
A search request by default runs against the most recent visible data of the target indices,
which is called point in time. Elasticsearch pit (point in time) is a lightweight view into the
state of the data as it existed when initiated. In some cases, it’s preferred to perform multiple
search requests using the same point in time. For example, if refreshes happen between
<code>search_after</code> requests, then the results of those requests might not be consistent as changes happening
between searches are only visible to the more recent point in time.
</p>
<p>
A point in time must be opened explicitly before being used in search requests.
</p>
<p>
A subsequent search request with the <code>pit</code> parameter must not specify <code>index</code>, <code>routing</code>, or <code>preference</code> values as these parameters are copied from the point in time.
</p>
<p>
Just like regular searches, you can use <code>from</code> and <code>size</code> to page through point in time search results, up to the first 10,000 hits.
If you want to retrieve more hits, use PIT with <code>search_after</code>.
</p>
<p>
IMPORTANT: The open point in time request and each subsequent search request can return different identifiers; always use the most recently received ID for the next search request.
</p>
<p>
When a PIT that contains shard failures is used in a search request, the missing are always reported in the search response as a <code>NoShardAvailableActionException</code> exception.
To get rid of these exceptions, a new PIT needs to be created so that shards missing from the previous PIT can be handled, assuming they become available in the meantime.
</p>
<p>
<strong>Keeping point in time alive</strong>
</p>
<p>
The <code>keep_alive</code> parameter, which is passed to a open point in time request and search request, extends the time to live of the corresponding point in time.
The value does not need to be long enough to process all data — it just needs to be long enough for the next request.
</p>
<p>
Normally, the background merge process optimizes the index by merging together smaller segments to create new, bigger segments.
Once the smaller segments are no longer needed they are deleted.
However, open point-in-times prevent the old segments from being deleted since they are still in use.
</p>
<p>
TIP: Keeping older segments alive means that more disk space and file handles are needed.
Ensure that you have configured your nodes to have ample free file handles.
</p>
<p>
Additionally, if a segment contains deleted or updated documents then the point in time must keep track of whether each document in the segment was live at the time of the initial search request.
Ensure that your nodes have sufficient heap space if you have many open point-in-times on an index that is subject to ongoing deletes or updates.
Note that a point-in-time doesn't prevent its associated indices from being deleted.
You can check how many point-in-times (that is, search contexts) are open with the nodes stats API.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/point-in-time-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual OpenPointInTimeResponse OpenPointInTime&lt;TDocument&gt;()</code></pre>
  </div>


  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.OpenPointInTimeResponse.html">OpenPointInTimeResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_OpenPointInTime_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.OpenPointInTime*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_OpenPointInTime__1_Elastic_Clients_Elasticsearch_Indices_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.OpenPointInTime``1(Elastic.Clients.Elasticsearch.Indices)">
  OpenPointInTime&lt;TDocument&gt;(Indices)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L24474"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Open a point in time.
</p>
<p>
A search request by default runs against the most recent visible data of the target indices,
which is called point in time. Elasticsearch pit (point in time) is a lightweight view into the
state of the data as it existed when initiated. In some cases, it’s preferred to perform multiple
search requests using the same point in time. For example, if refreshes happen between
<code>search_after</code> requests, then the results of those requests might not be consistent as changes happening
between searches are only visible to the more recent point in time.
</p>
<p>
A point in time must be opened explicitly before being used in search requests.
</p>
<p>
A subsequent search request with the <code>pit</code> parameter must not specify <code>index</code>, <code>routing</code>, or <code>preference</code> values as these parameters are copied from the point in time.
</p>
<p>
Just like regular searches, you can use <code>from</code> and <code>size</code> to page through point in time search results, up to the first 10,000 hits.
If you want to retrieve more hits, use PIT with <code>search_after</code>.
</p>
<p>
IMPORTANT: The open point in time request and each subsequent search request can return different identifiers; always use the most recently received ID for the next search request.
</p>
<p>
When a PIT that contains shard failures is used in a search request, the missing are always reported in the search response as a <code>NoShardAvailableActionException</code> exception.
To get rid of these exceptions, a new PIT needs to be created so that shards missing from the previous PIT can be handled, assuming they become available in the meantime.
</p>
<p>
<strong>Keeping point in time alive</strong>
</p>
<p>
The <code>keep_alive</code> parameter, which is passed to a open point in time request and search request, extends the time to live of the corresponding point in time.
The value does not need to be long enough to process all data — it just needs to be long enough for the next request.
</p>
<p>
Normally, the background merge process optimizes the index by merging together smaller segments to create new, bigger segments.
Once the smaller segments are no longer needed they are deleted.
However, open point-in-times prevent the old segments from being deleted since they are still in use.
</p>
<p>
TIP: Keeping older segments alive means that more disk space and file handles are needed.
Ensure that you have configured your nodes to have ample free file handles.
</p>
<p>
Additionally, if a segment contains deleted or updated documents then the point in time must keep track of whether each document in the segment was live at the time of the initial search request.
Ensure that your nodes have sufficient heap space if you have many open point-in-times on an index that is subject to ongoing deletes or updates.
Note that a point-in-time doesn't prevent its associated indices from being deleted.
You can check how many point-in-times (that is, search contexts) are open with the nodes stats API.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/point-in-time-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual OpenPointInTimeResponse OpenPointInTime&lt;TDocument&gt;(Indices indices)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>indices</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Indices.html">Indices</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.OpenPointInTimeResponse.html">OpenPointInTimeResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_OpenPointInTime_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.OpenPointInTime*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_OpenPointInTime__1_Elastic_Clients_Elasticsearch_Indices_System_Action_Elastic_Clients_Elasticsearch_OpenPointInTimeRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.OpenPointInTime``1(Elastic.Clients.Elasticsearch.Indices,System.Action{Elastic.Clients.Elasticsearch.OpenPointInTimeRequestDescriptor{``0}})">
  OpenPointInTime&lt;TDocument&gt;(Indices, Action&lt;OpenPointInTimeRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L24535"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Open a point in time.
</p>
<p>
A search request by default runs against the most recent visible data of the target indices,
which is called point in time. Elasticsearch pit (point in time) is a lightweight view into the
state of the data as it existed when initiated. In some cases, it’s preferred to perform multiple
search requests using the same point in time. For example, if refreshes happen between
<code>search_after</code> requests, then the results of those requests might not be consistent as changes happening
between searches are only visible to the more recent point in time.
</p>
<p>
A point in time must be opened explicitly before being used in search requests.
</p>
<p>
A subsequent search request with the <code>pit</code> parameter must not specify <code>index</code>, <code>routing</code>, or <code>preference</code> values as these parameters are copied from the point in time.
</p>
<p>
Just like regular searches, you can use <code>from</code> and <code>size</code> to page through point in time search results, up to the first 10,000 hits.
If you want to retrieve more hits, use PIT with <code>search_after</code>.
</p>
<p>
IMPORTANT: The open point in time request and each subsequent search request can return different identifiers; always use the most recently received ID for the next search request.
</p>
<p>
When a PIT that contains shard failures is used in a search request, the missing are always reported in the search response as a <code>NoShardAvailableActionException</code> exception.
To get rid of these exceptions, a new PIT needs to be created so that shards missing from the previous PIT can be handled, assuming they become available in the meantime.
</p>
<p>
<strong>Keeping point in time alive</strong>
</p>
<p>
The <code>keep_alive</code> parameter, which is passed to a open point in time request and search request, extends the time to live of the corresponding point in time.
The value does not need to be long enough to process all data — it just needs to be long enough for the next request.
</p>
<p>
Normally, the background merge process optimizes the index by merging together smaller segments to create new, bigger segments.
Once the smaller segments are no longer needed they are deleted.
However, open point-in-times prevent the old segments from being deleted since they are still in use.
</p>
<p>
TIP: Keeping older segments alive means that more disk space and file handles are needed.
Ensure that you have configured your nodes to have ample free file handles.
</p>
<p>
Additionally, if a segment contains deleted or updated documents then the point in time must keep track of whether each document in the segment was live at the time of the initial search request.
Ensure that your nodes have sufficient heap space if you have many open point-in-times on an index that is subject to ongoing deletes or updates.
Note that a point-in-time doesn't prevent its associated indices from being deleted.
You can check how many point-in-times (that is, search contexts) are open with the nodes stats API.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/point-in-time-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual OpenPointInTimeResponse OpenPointInTime&lt;TDocument&gt;(Indices indices, Action&lt;OpenPointInTimeRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>indices</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Indices.html">Indices</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.OpenPointInTimeRequestDescriptor-1.html">OpenPointInTimeRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.OpenPointInTimeResponse.html">OpenPointInTimeResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_OpenPointInTime_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.OpenPointInTime*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_OpenPointInTime__1_Elastic_Clients_Elasticsearch_OpenPointInTimeRequestDescriptor___0__" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.OpenPointInTime``1(Elastic.Clients.Elasticsearch.OpenPointInTimeRequestDescriptor{``0})">
  OpenPointInTime&lt;TDocument&gt;(OpenPointInTimeRequestDescriptor&lt;TDocument&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L24414"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Open a point in time.
</p>
<p>
A search request by default runs against the most recent visible data of the target indices,
which is called point in time. Elasticsearch pit (point in time) is a lightweight view into the
state of the data as it existed when initiated. In some cases, it’s preferred to perform multiple
search requests using the same point in time. For example, if refreshes happen between
<code>search_after</code> requests, then the results of those requests might not be consistent as changes happening
between searches are only visible to the more recent point in time.
</p>
<p>
A point in time must be opened explicitly before being used in search requests.
</p>
<p>
A subsequent search request with the <code>pit</code> parameter must not specify <code>index</code>, <code>routing</code>, or <code>preference</code> values as these parameters are copied from the point in time.
</p>
<p>
Just like regular searches, you can use <code>from</code> and <code>size</code> to page through point in time search results, up to the first 10,000 hits.
If you want to retrieve more hits, use PIT with <code>search_after</code>.
</p>
<p>
IMPORTANT: The open point in time request and each subsequent search request can return different identifiers; always use the most recently received ID for the next search request.
</p>
<p>
When a PIT that contains shard failures is used in a search request, the missing are always reported in the search response as a <code>NoShardAvailableActionException</code> exception.
To get rid of these exceptions, a new PIT needs to be created so that shards missing from the previous PIT can be handled, assuming they become available in the meantime.
</p>
<p>
<strong>Keeping point in time alive</strong>
</p>
<p>
The <code>keep_alive</code> parameter, which is passed to a open point in time request and search request, extends the time to live of the corresponding point in time.
The value does not need to be long enough to process all data — it just needs to be long enough for the next request.
</p>
<p>
Normally, the background merge process optimizes the index by merging together smaller segments to create new, bigger segments.
Once the smaller segments are no longer needed they are deleted.
However, open point-in-times prevent the old segments from being deleted since they are still in use.
</p>
<p>
TIP: Keeping older segments alive means that more disk space and file handles are needed.
Ensure that you have configured your nodes to have ample free file handles.
</p>
<p>
Additionally, if a segment contains deleted or updated documents then the point in time must keep track of whether each document in the segment was live at the time of the initial search request.
Ensure that your nodes have sufficient heap space if you have many open point-in-times on an index that is subject to ongoing deletes or updates.
Note that a point-in-time doesn't prevent its associated indices from being deleted.
You can check how many point-in-times (that is, search contexts) are open with the nodes stats API.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/point-in-time-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual OpenPointInTimeResponse OpenPointInTime&lt;TDocument&gt;(OpenPointInTimeRequestDescriptor&lt;TDocument&gt; descriptor)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.OpenPointInTimeRequestDescriptor-1.html">OpenPointInTimeRequestDescriptor</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.OpenPointInTimeResponse.html">OpenPointInTimeResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_OpenPointInTime_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.OpenPointInTime*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_OpenPointInTime__1_System_Action_Elastic_Clients_Elasticsearch_OpenPointInTimeRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.OpenPointInTime``1(System.Action{Elastic.Clients.Elasticsearch.OpenPointInTimeRequestDescriptor{``0}})">
  OpenPointInTime&lt;TDocument&gt;(Action&lt;OpenPointInTimeRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L24658"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Open a point in time.
</p>
<p>
A search request by default runs against the most recent visible data of the target indices,
which is called point in time. Elasticsearch pit (point in time) is a lightweight view into the
state of the data as it existed when initiated. In some cases, it’s preferred to perform multiple
search requests using the same point in time. For example, if refreshes happen between
<code>search_after</code> requests, then the results of those requests might not be consistent as changes happening
between searches are only visible to the more recent point in time.
</p>
<p>
A point in time must be opened explicitly before being used in search requests.
</p>
<p>
A subsequent search request with the <code>pit</code> parameter must not specify <code>index</code>, <code>routing</code>, or <code>preference</code> values as these parameters are copied from the point in time.
</p>
<p>
Just like regular searches, you can use <code>from</code> and <code>size</code> to page through point in time search results, up to the first 10,000 hits.
If you want to retrieve more hits, use PIT with <code>search_after</code>.
</p>
<p>
IMPORTANT: The open point in time request and each subsequent search request can return different identifiers; always use the most recently received ID for the next search request.
</p>
<p>
When a PIT that contains shard failures is used in a search request, the missing are always reported in the search response as a <code>NoShardAvailableActionException</code> exception.
To get rid of these exceptions, a new PIT needs to be created so that shards missing from the previous PIT can be handled, assuming they become available in the meantime.
</p>
<p>
<strong>Keeping point in time alive</strong>
</p>
<p>
The <code>keep_alive</code> parameter, which is passed to a open point in time request and search request, extends the time to live of the corresponding point in time.
The value does not need to be long enough to process all data — it just needs to be long enough for the next request.
</p>
<p>
Normally, the background merge process optimizes the index by merging together smaller segments to create new, bigger segments.
Once the smaller segments are no longer needed they are deleted.
However, open point-in-times prevent the old segments from being deleted since they are still in use.
</p>
<p>
TIP: Keeping older segments alive means that more disk space and file handles are needed.
Ensure that you have configured your nodes to have ample free file handles.
</p>
<p>
Additionally, if a segment contains deleted or updated documents then the point in time must keep track of whether each document in the segment was live at the time of the initial search request.
Ensure that your nodes have sufficient heap space if you have many open point-in-times on an index that is subject to ongoing deletes or updates.
Note that a point-in-time doesn't prevent its associated indices from being deleted.
You can check how many point-in-times (that is, search contexts) are open with the nodes stats API.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/point-in-time-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual OpenPointInTimeResponse OpenPointInTime&lt;TDocument&gt;(Action&lt;OpenPointInTimeRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.OpenPointInTimeRequestDescriptor-1.html">OpenPointInTimeRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.OpenPointInTimeResponse.html">OpenPointInTimeResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Ping_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Ping*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Ping" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Ping">
  Ping()
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L25379"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Ping the cluster.
Get information about whether the cluster is running.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/cluster.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual PingResponse Ping()</code></pre>
  </div>


  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.PingResponse.html">PingResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Ping_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Ping*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Ping_Elastic_Clients_Elasticsearch_PingRequest_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Ping(Elastic.Clients.Elasticsearch.PingRequest)">
  Ping(PingRequest)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L25338"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Ping the cluster.
Get information about whether the cluster is running.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/cluster.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual PingResponse Ping(PingRequest request)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.PingRequest.html">PingRequest</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.PingResponse.html">PingResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Ping_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Ping*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Ping_Elastic_Clients_Elasticsearch_PingRequestDescriptor_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Ping(Elastic.Clients.Elasticsearch.PingRequestDescriptor)">
  Ping(PingRequestDescriptor)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L25365"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Ping the cluster.
Get information about whether the cluster is running.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/cluster.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual PingResponse Ping(PingRequestDescriptor descriptor)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.PingRequestDescriptor.html">PingRequestDescriptor</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.PingResponse.html">PingResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Ping_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Ping*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Ping_System_Action_Elastic_Clients_Elasticsearch_PingRequestDescriptor__" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Ping(System.Action{Elastic.Clients.Elasticsearch.PingRequestDescriptor})">
  Ping(Action&lt;PingRequestDescriptor&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L25394"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Ping the cluster.
Get information about whether the cluster is running.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/cluster.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual PingResponse Ping(Action&lt;PingRequestDescriptor&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.PingRequestDescriptor.html">PingRequestDescriptor</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.PingResponse.html">PingResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_PingAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.PingAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_PingAsync_Elastic_Clients_Elasticsearch_PingRequest_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.PingAsync(Elastic.Clients.Elasticsearch.PingRequest,System.Threading.CancellationToken)">
  PingAsync(PingRequest, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L25352"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Ping the cluster.
Get information about whether the cluster is running.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/cluster.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;PingResponse&gt; PingAsync(PingRequest request, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.PingRequest.html">PingRequest</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.PingResponse.html">PingResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_PingAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.PingAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_PingAsync_Elastic_Clients_Elasticsearch_PingRequestDescriptor_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.PingAsync(Elastic.Clients.Elasticsearch.PingRequestDescriptor,System.Threading.CancellationToken)">
  PingAsync(PingRequestDescriptor, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L25410"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Ping the cluster.
Get information about whether the cluster is running.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/cluster.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;PingResponse&gt; PingAsync(PingRequestDescriptor descriptor, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.PingRequestDescriptor.html">PingRequestDescriptor</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.PingResponse.html">PingResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_PingAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.PingAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_PingAsync_System_Action_Elastic_Clients_Elasticsearch_PingRequestDescriptor__System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.PingAsync(System.Action{Elastic.Clients.Elasticsearch.PingRequestDescriptor},System.Threading.CancellationToken)">
  PingAsync(Action&lt;PingRequestDescriptor&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L25437"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Ping the cluster.
Get information about whether the cluster is running.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/cluster.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;PingResponse&gt; PingAsync(Action&lt;PingRequestDescriptor&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.PingRequestDescriptor.html">PingRequestDescriptor</a>&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.PingResponse.html">PingResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_PingAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.PingAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_PingAsync_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.PingAsync(System.Threading.CancellationToken)">
  PingAsync(CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L25423"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Ping the cluster.
Get information about whether the cluster is running.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/cluster.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;PingResponse&gt; PingAsync(CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.PingResponse.html">PingResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_PutScript_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.PutScript*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_PutScript_Elastic_Clients_Elasticsearch_Id_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.PutScript(Elastic.Clients.Elasticsearch.Id)">
  PutScript(Id)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L25600"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Create or update a script or search template.
Creates or updates a stored script or search template.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/create-stored-script-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual PutScriptResponse PutScript(Id id)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.PutScriptResponse.html">PutScriptResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_PutScript_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.PutScript*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_PutScript_Elastic_Clients_Elasticsearch_Id_Elastic_Clients_Elasticsearch_Name_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.PutScript(Elastic.Clients.Elasticsearch.Id,Elastic.Clients.Elasticsearch.Name)">
  PutScript(Id, Name?)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L25569"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Create or update a script or search template.
Creates or updates a stored script or search template.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/create-stored-script-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual PutScriptResponse PutScript(Id id, Name? context)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>context</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Name.html">Name</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.PutScriptResponse.html">PutScriptResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_PutScript_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.PutScript*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_PutScript_Elastic_Clients_Elasticsearch_Id_Elastic_Clients_Elasticsearch_Name_System_Action_Elastic_Clients_Elasticsearch_PutScriptRequestDescriptor__" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.PutScript(Elastic.Clients.Elasticsearch.Id,Elastic.Clients.Elasticsearch.Name,System.Action{Elastic.Clients.Elasticsearch.PutScriptRequestDescriptor})">
  PutScript(Id, Name?, Action&lt;PutScriptRequestDescriptor&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L25584"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Create or update a script or search template.
Creates or updates a stored script or search template.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/create-stored-script-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual PutScriptResponse PutScript(Id id, Name? context, Action&lt;PutScriptRequestDescriptor&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>context</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Name.html">Name</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.PutScriptRequestDescriptor.html">PutScriptRequestDescriptor</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.PutScriptResponse.html">PutScriptResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_PutScript_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.PutScript*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_PutScript_Elastic_Clients_Elasticsearch_Id_System_Action_Elastic_Clients_Elasticsearch_PutScriptRequestDescriptor__" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.PutScript(Elastic.Clients.Elasticsearch.Id,System.Action{Elastic.Clients.Elasticsearch.PutScriptRequestDescriptor})">
  PutScript(Id, Action&lt;PutScriptRequestDescriptor&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L25615"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Create or update a script or search template.
Creates or updates a stored script or search template.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/create-stored-script-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual PutScriptResponse PutScript(Id id, Action&lt;PutScriptRequestDescriptor&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.PutScriptRequestDescriptor.html">PutScriptRequestDescriptor</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.PutScriptResponse.html">PutScriptResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_PutScript_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.PutScript*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_PutScript_Elastic_Clients_Elasticsearch_PutScriptRequest_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.PutScript(Elastic.Clients.Elasticsearch.PutScriptRequest)">
  PutScript(PutScriptRequest)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L25452"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Create or update a script or search template.
Creates or updates a stored script or search template.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/create-stored-script-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual PutScriptResponse PutScript(PutScriptRequest request)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.PutScriptRequest.html">PutScriptRequest</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.PutScriptResponse.html">PutScriptResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_PutScript_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.PutScript*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_PutScript_Elastic_Clients_Elasticsearch_PutScriptRequestDescriptor_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.PutScript(Elastic.Clients.Elasticsearch.PutScriptRequestDescriptor)">
  PutScript(PutScriptRequestDescriptor)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L25555"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Create or update a script or search template.
Creates or updates a stored script or search template.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/create-stored-script-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual PutScriptResponse PutScript(PutScriptRequestDescriptor descriptor)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.PutScriptRequestDescriptor.html">PutScriptRequestDescriptor</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.PutScriptResponse.html">PutScriptResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_PutScriptAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.PutScriptAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_PutScriptAsync_Elastic_Clients_Elasticsearch_Id_Elastic_Clients_Elasticsearch_Name_System_Action_Elastic_Clients_Elasticsearch_PutScriptRequestDescriptor__System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.PutScriptAsync(Elastic.Clients.Elasticsearch.Id,Elastic.Clients.Elasticsearch.Name,System.Action{Elastic.Clients.Elasticsearch.PutScriptRequestDescriptor},System.Threading.CancellationToken)">
  PutScriptAsync(Id, Name?, Action&lt;PutScriptRequestDescriptor&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L25729"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Create or update a script or search template.
Creates or updates a stored script or search template.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/create-stored-script-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;PutScriptResponse&gt; PutScriptAsync(Id id, Name? context, Action&lt;PutScriptRequestDescriptor&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>context</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Name.html">Name</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.PutScriptRequestDescriptor.html">PutScriptRequestDescriptor</a>&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.PutScriptResponse.html">PutScriptResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_PutScriptAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.PutScriptAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_PutScriptAsync_Elastic_Clients_Elasticsearch_Id_Elastic_Clients_Elasticsearch_Name_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.PutScriptAsync(Elastic.Clients.Elasticsearch.Id,Elastic.Clients.Elasticsearch.Name,System.Threading.CancellationToken)">
  PutScriptAsync(Id, Name?, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L25715"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Create or update a script or search template.
Creates or updates a stored script or search template.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/create-stored-script-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;PutScriptResponse&gt; PutScriptAsync(Id id, Name? context, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>context</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Name.html">Name</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.PutScriptResponse.html">PutScriptResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_PutScriptAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.PutScriptAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_PutScriptAsync_Elastic_Clients_Elasticsearch_Id_System_Action_Elastic_Clients_Elasticsearch_PutScriptRequestDescriptor__System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.PutScriptAsync(Elastic.Clients.Elasticsearch.Id,System.Action{Elastic.Clients.Elasticsearch.PutScriptRequestDescriptor},System.Threading.CancellationToken)">
  PutScriptAsync(Id, Action&lt;PutScriptRequestDescriptor&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L25758"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Create or update a script or search template.
Creates or updates a stored script or search template.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/create-stored-script-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;PutScriptResponse&gt; PutScriptAsync(Id id, Action&lt;PutScriptRequestDescriptor&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.PutScriptRequestDescriptor.html">PutScriptRequestDescriptor</a>&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.PutScriptResponse.html">PutScriptResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_PutScriptAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.PutScriptAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_PutScriptAsync_Elastic_Clients_Elasticsearch_Id_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.PutScriptAsync(Elastic.Clients.Elasticsearch.Id,System.Threading.CancellationToken)">
  PutScriptAsync(Id, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L25744"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Create or update a script or search template.
Creates or updates a stored script or search template.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/create-stored-script-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;PutScriptResponse&gt; PutScriptAsync(Id id, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.PutScriptResponse.html">PutScriptResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_PutScriptAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.PutScriptAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_PutScriptAsync_Elastic_Clients_Elasticsearch_PutScriptRequest_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.PutScriptAsync(Elastic.Clients.Elasticsearch.PutScriptRequest,System.Threading.CancellationToken)">
  PutScriptAsync(PutScriptRequest, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L25466"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Create or update a script or search template.
Creates or updates a stored script or search template.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/create-stored-script-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;PutScriptResponse&gt; PutScriptAsync(PutScriptRequest request, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.PutScriptRequest.html">PutScriptRequest</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.PutScriptResponse.html">PutScriptResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_PutScriptAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.PutScriptAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_PutScriptAsync_Elastic_Clients_Elasticsearch_PutScriptRequestDescriptor_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.PutScriptAsync(Elastic.Clients.Elasticsearch.PutScriptRequestDescriptor,System.Threading.CancellationToken)">
  PutScriptAsync(PutScriptRequestDescriptor, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L25702"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Create or update a script or search template.
Creates or updates a stored script or search template.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/create-stored-script-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;PutScriptResponse&gt; PutScriptAsync(PutScriptRequestDescriptor descriptor, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.PutScriptRequestDescriptor.html">PutScriptRequestDescriptor</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.PutScriptResponse.html">PutScriptResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_PutScriptAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.PutScriptAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_PutScriptAsync__1_Elastic_Clients_Elasticsearch_Id_Elastic_Clients_Elasticsearch_Name_System_Action_Elastic_Clients_Elasticsearch_PutScriptRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.PutScriptAsync``1(Elastic.Clients.Elasticsearch.Id,Elastic.Clients.Elasticsearch.Name,System.Action{Elastic.Clients.Elasticsearch.PutScriptRequestDescriptor{``0}},System.Threading.CancellationToken)">
  PutScriptAsync&lt;TDocument&gt;(Id, Name?, Action&lt;PutScriptRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L25658"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Create or update a script or search template.
Creates or updates a stored script or search template.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/create-stored-script-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;PutScriptResponse&gt; PutScriptAsync&lt;TDocument&gt;(Id id, Name? context, Action&lt;PutScriptRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>context</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Name.html">Name</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.PutScriptRequestDescriptor-1.html">PutScriptRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.PutScriptResponse.html">PutScriptResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_PutScriptAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.PutScriptAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_PutScriptAsync__1_Elastic_Clients_Elasticsearch_Id_Elastic_Clients_Elasticsearch_Name_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.PutScriptAsync``1(Elastic.Clients.Elasticsearch.Id,Elastic.Clients.Elasticsearch.Name,System.Threading.CancellationToken)">
  PutScriptAsync&lt;TDocument&gt;(Id, Name?, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L25644"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Create or update a script or search template.
Creates or updates a stored script or search template.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/create-stored-script-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;PutScriptResponse&gt; PutScriptAsync&lt;TDocument&gt;(Id id, Name? context, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>context</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Name.html">Name</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.PutScriptResponse.html">PutScriptResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_PutScriptAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.PutScriptAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_PutScriptAsync__1_Elastic_Clients_Elasticsearch_Id_System_Action_Elastic_Clients_Elasticsearch_PutScriptRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.PutScriptAsync``1(Elastic.Clients.Elasticsearch.Id,System.Action{Elastic.Clients.Elasticsearch.PutScriptRequestDescriptor{``0}},System.Threading.CancellationToken)">
  PutScriptAsync&lt;TDocument&gt;(Id, Action&lt;PutScriptRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L25687"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Create or update a script or search template.
Creates or updates a stored script or search template.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/create-stored-script-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;PutScriptResponse&gt; PutScriptAsync&lt;TDocument&gt;(Id id, Action&lt;PutScriptRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.PutScriptRequestDescriptor-1.html">PutScriptRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.PutScriptResponse.html">PutScriptResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_PutScriptAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.PutScriptAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_PutScriptAsync__1_Elastic_Clients_Elasticsearch_Id_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.PutScriptAsync``1(Elastic.Clients.Elasticsearch.Id,System.Threading.CancellationToken)">
  PutScriptAsync&lt;TDocument&gt;(Id, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L25673"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Create or update a script or search template.
Creates or updates a stored script or search template.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/create-stored-script-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;PutScriptResponse&gt; PutScriptAsync&lt;TDocument&gt;(Id id, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.PutScriptResponse.html">PutScriptResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_PutScriptAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.PutScriptAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_PutScriptAsync__1_Elastic_Clients_Elasticsearch_PutScriptRequestDescriptor___0__System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.PutScriptAsync``1(Elastic.Clients.Elasticsearch.PutScriptRequestDescriptor{``0},System.Threading.CancellationToken)">
  PutScriptAsync&lt;TDocument&gt;(PutScriptRequestDescriptor&lt;TDocument&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L25631"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Create or update a script or search template.
Creates or updates a stored script or search template.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/create-stored-script-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;PutScriptResponse&gt; PutScriptAsync&lt;TDocument&gt;(PutScriptRequestDescriptor&lt;TDocument&gt; descriptor, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.PutScriptRequestDescriptor-1.html">PutScriptRequestDescriptor</a>&lt;TDocument&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.PutScriptResponse.html">PutScriptResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_PutScript_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.PutScript*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_PutScript__1_Elastic_Clients_Elasticsearch_Id_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.PutScript``1(Elastic.Clients.Elasticsearch.Id)">
  PutScript&lt;TDocument&gt;(Id)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L25524"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Create or update a script or search template.
Creates or updates a stored script or search template.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/create-stored-script-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual PutScriptResponse PutScript&lt;TDocument&gt;(Id id)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.PutScriptResponse.html">PutScriptResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_PutScript_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.PutScript*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_PutScript__1_Elastic_Clients_Elasticsearch_Id_Elastic_Clients_Elasticsearch_Name_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.PutScript``1(Elastic.Clients.Elasticsearch.Id,Elastic.Clients.Elasticsearch.Name)">
  PutScript&lt;TDocument&gt;(Id, Name?)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L25493"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Create or update a script or search template.
Creates or updates a stored script or search template.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/create-stored-script-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual PutScriptResponse PutScript&lt;TDocument&gt;(Id id, Name? context)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>context</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Name.html">Name</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.PutScriptResponse.html">PutScriptResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_PutScript_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.PutScript*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_PutScript__1_Elastic_Clients_Elasticsearch_Id_Elastic_Clients_Elasticsearch_Name_System_Action_Elastic_Clients_Elasticsearch_PutScriptRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.PutScript``1(Elastic.Clients.Elasticsearch.Id,Elastic.Clients.Elasticsearch.Name,System.Action{Elastic.Clients.Elasticsearch.PutScriptRequestDescriptor{``0}})">
  PutScript&lt;TDocument&gt;(Id, Name?, Action&lt;PutScriptRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L25508"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Create or update a script or search template.
Creates or updates a stored script or search template.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/create-stored-script-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual PutScriptResponse PutScript&lt;TDocument&gt;(Id id, Name? context, Action&lt;PutScriptRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>context</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Name.html">Name</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.PutScriptRequestDescriptor-1.html">PutScriptRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.PutScriptResponse.html">PutScriptResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_PutScript_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.PutScript*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_PutScript__1_Elastic_Clients_Elasticsearch_Id_System_Action_Elastic_Clients_Elasticsearch_PutScriptRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.PutScript``1(Elastic.Clients.Elasticsearch.Id,System.Action{Elastic.Clients.Elasticsearch.PutScriptRequestDescriptor{``0}})">
  PutScript&lt;TDocument&gt;(Id, Action&lt;PutScriptRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L25539"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Create or update a script or search template.
Creates or updates a stored script or search template.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/create-stored-script-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual PutScriptResponse PutScript&lt;TDocument&gt;(Id id, Action&lt;PutScriptRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.PutScriptRequestDescriptor-1.html">PutScriptRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.PutScriptResponse.html">PutScriptResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_PutScript_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.PutScript*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_PutScript__1_Elastic_Clients_Elasticsearch_PutScriptRequestDescriptor___0__" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.PutScript``1(Elastic.Clients.Elasticsearch.PutScriptRequestDescriptor{``0})">
  PutScript&lt;TDocument&gt;(PutScriptRequestDescriptor&lt;TDocument&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L25479"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Create or update a script or search template.
Creates or updates a stored script or search template.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/create-stored-script-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual PutScriptResponse PutScript&lt;TDocument&gt;(PutScriptRequestDescriptor&lt;TDocument&gt; descriptor)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.PutScriptRequestDescriptor-1.html">PutScriptRequestDescriptor</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.PutScriptResponse.html">PutScriptResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_RankEval_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.RankEval*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_RankEval" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.RankEval">
  RankEval()
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L25943"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Evaluate ranked search results.
</p>
<p>
Evaluate the quality of ranked search results over a set of typical search queries.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-rank-eval.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual RankEvalResponse RankEval()</code></pre>
  </div>


  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.RankEvalResponse.html">RankEvalResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_RankEval_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.RankEval*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_RankEval_Elastic_Clients_Elasticsearch_Indices_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.RankEval(Elastic.Clients.Elasticsearch.Indices)">
  RankEval(Indices?)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L25908"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Evaluate ranked search results.
</p>
<p>
Evaluate the quality of ranked search results over a set of typical search queries.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-rank-eval.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual RankEvalResponse RankEval(Indices? indices)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>indices</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Indices.html">Indices</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.RankEvalResponse.html">RankEvalResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_RankEval_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.RankEval*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_RankEval_Elastic_Clients_Elasticsearch_Indices_System_Action_Elastic_Clients_Elasticsearch_RankEvalRequestDescriptor__" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.RankEval(Elastic.Clients.Elasticsearch.Indices,System.Action{Elastic.Clients.Elasticsearch.RankEvalRequestDescriptor})">
  RankEval(Indices?, Action&lt;RankEvalRequestDescriptor&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L25925"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Evaluate ranked search results.
</p>
<p>
Evaluate the quality of ranked search results over a set of typical search queries.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-rank-eval.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual RankEvalResponse RankEval(Indices? indices, Action&lt;RankEvalRequestDescriptor&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>indices</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Indices.html">Indices</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.RankEvalRequestDescriptor.html">RankEvalRequestDescriptor</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.RankEvalResponse.html">RankEvalResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_RankEval_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.RankEval*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_RankEval_Elastic_Clients_Elasticsearch_RankEvalRequest_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.RankEval(Elastic.Clients.Elasticsearch.RankEvalRequest)">
  RankEval(RankEvalRequest)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L25775"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Evaluate ranked search results.
</p>
<p>
Evaluate the quality of ranked search results over a set of typical search queries.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-rank-eval.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual RankEvalResponse RankEval(RankEvalRequest request)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.RankEvalRequest.html">RankEvalRequest</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.RankEvalResponse.html">RankEvalResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_RankEval_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.RankEval*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_RankEval_Elastic_Clients_Elasticsearch_RankEvalRequestDescriptor_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.RankEval(Elastic.Clients.Elasticsearch.RankEvalRequestDescriptor)">
  RankEval(RankEvalRequestDescriptor)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L25892"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Evaluate ranked search results.
</p>
<p>
Evaluate the quality of ranked search results over a set of typical search queries.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-rank-eval.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual RankEvalResponse RankEval(RankEvalRequestDescriptor descriptor)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.RankEvalRequestDescriptor.html">RankEvalRequestDescriptor</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.RankEvalResponse.html">RankEvalResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_RankEval_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.RankEval*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_RankEval_System_Action_Elastic_Clients_Elasticsearch_RankEvalRequestDescriptor__" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.RankEval(System.Action{Elastic.Clients.Elasticsearch.RankEvalRequestDescriptor})">
  RankEval(Action&lt;RankEvalRequestDescriptor&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L25960"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Evaluate ranked search results.
</p>
<p>
Evaluate the quality of ranked search results over a set of typical search queries.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-rank-eval.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual RankEvalResponse RankEval(Action&lt;RankEvalRequestDescriptor&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.RankEvalRequestDescriptor.html">RankEvalRequestDescriptor</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.RankEvalResponse.html">RankEvalResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_RankEvalAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.RankEvalAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_RankEvalAsync_Elastic_Clients_Elasticsearch_Indices_System_Action_Elastic_Clients_Elasticsearch_RankEvalRequestDescriptor__System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.RankEvalAsync(Elastic.Clients.Elasticsearch.Indices,System.Action{Elastic.Clients.Elasticsearch.RankEvalRequestDescriptor},System.Threading.CancellationToken)">
  RankEvalAsync(Indices?, Action&lt;RankEvalRequestDescriptor&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L26090"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Evaluate ranked search results.
</p>
<p>
Evaluate the quality of ranked search results over a set of typical search queries.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-rank-eval.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;RankEvalResponse&gt; RankEvalAsync(Indices? indices, Action&lt;RankEvalRequestDescriptor&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>indices</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Indices.html">Indices</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.RankEvalRequestDescriptor.html">RankEvalRequestDescriptor</a>&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.RankEvalResponse.html">RankEvalResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_RankEvalAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.RankEvalAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_RankEvalAsync_Elastic_Clients_Elasticsearch_Indices_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.RankEvalAsync(Elastic.Clients.Elasticsearch.Indices,System.Threading.CancellationToken)">
  RankEvalAsync(Indices?, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L26074"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Evaluate ranked search results.
</p>
<p>
Evaluate the quality of ranked search results over a set of typical search queries.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-rank-eval.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;RankEvalResponse&gt; RankEvalAsync(Indices? indices, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>indices</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Indices.html">Indices</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.RankEvalResponse.html">RankEvalResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_RankEvalAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.RankEvalAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_RankEvalAsync_Elastic_Clients_Elasticsearch_RankEvalRequest_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.RankEvalAsync(Elastic.Clients.Elasticsearch.RankEvalRequest,System.Threading.CancellationToken)">
  RankEvalAsync(RankEvalRequest, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L25791"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Evaluate ranked search results.
</p>
<p>
Evaluate the quality of ranked search results over a set of typical search queries.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-rank-eval.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;RankEvalResponse&gt; RankEvalAsync(RankEvalRequest request, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.RankEvalRequest.html">RankEvalRequest</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.RankEvalResponse.html">RankEvalResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_RankEvalAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.RankEvalAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_RankEvalAsync_Elastic_Clients_Elasticsearch_RankEvalRequestDescriptor_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.RankEvalAsync(Elastic.Clients.Elasticsearch.RankEvalRequestDescriptor,System.Threading.CancellationToken)">
  RankEvalAsync(RankEvalRequestDescriptor, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L26059"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Evaluate ranked search results.
</p>
<p>
Evaluate the quality of ranked search results over a set of typical search queries.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-rank-eval.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;RankEvalResponse&gt; RankEvalAsync(RankEvalRequestDescriptor descriptor, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.RankEvalRequestDescriptor.html">RankEvalRequestDescriptor</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.RankEvalResponse.html">RankEvalResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_RankEvalAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.RankEvalAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_RankEvalAsync_System_Action_Elastic_Clients_Elasticsearch_RankEvalRequestDescriptor__System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.RankEvalAsync(System.Action{Elastic.Clients.Elasticsearch.RankEvalRequestDescriptor},System.Threading.CancellationToken)">
  RankEvalAsync(Action&lt;RankEvalRequestDescriptor&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L26123"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Evaluate ranked search results.
</p>
<p>
Evaluate the quality of ranked search results over a set of typical search queries.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-rank-eval.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;RankEvalResponse&gt; RankEvalAsync(Action&lt;RankEvalRequestDescriptor&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.RankEvalRequestDescriptor.html">RankEvalRequestDescriptor</a>&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.RankEvalResponse.html">RankEvalResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_RankEvalAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.RankEvalAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_RankEvalAsync_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.RankEvalAsync(System.Threading.CancellationToken)">
  RankEvalAsync(CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L26107"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Evaluate ranked search results.
</p>
<p>
Evaluate the quality of ranked search results over a set of typical search queries.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-rank-eval.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;RankEvalResponse&gt; RankEvalAsync(CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.RankEvalResponse.html">RankEvalResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_RankEvalAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.RankEvalAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_RankEvalAsync__1_Elastic_Clients_Elasticsearch_Indices_System_Action_Elastic_Clients_Elasticsearch_RankEvalRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.RankEvalAsync``1(Elastic.Clients.Elasticsearch.Indices,System.Action{Elastic.Clients.Elasticsearch.RankEvalRequestDescriptor{``0}},System.Threading.CancellationToken)">
  RankEvalAsync&lt;TDocument&gt;(Indices?, Action&lt;RankEvalRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L26009"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Evaluate ranked search results.
</p>
<p>
Evaluate the quality of ranked search results over a set of typical search queries.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-rank-eval.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;RankEvalResponse&gt; RankEvalAsync&lt;TDocument&gt;(Indices? indices, Action&lt;RankEvalRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>indices</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Indices.html">Indices</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.RankEvalRequestDescriptor-1.html">RankEvalRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.RankEvalResponse.html">RankEvalResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_RankEvalAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.RankEvalAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_RankEvalAsync__1_Elastic_Clients_Elasticsearch_Indices_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.RankEvalAsync``1(Elastic.Clients.Elasticsearch.Indices,System.Threading.CancellationToken)">
  RankEvalAsync&lt;TDocument&gt;(Indices?, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L25993"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Evaluate ranked search results.
</p>
<p>
Evaluate the quality of ranked search results over a set of typical search queries.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-rank-eval.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;RankEvalResponse&gt; RankEvalAsync&lt;TDocument&gt;(Indices? indices, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>indices</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Indices.html">Indices</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.RankEvalResponse.html">RankEvalResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_RankEvalAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.RankEvalAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_RankEvalAsync__1_Elastic_Clients_Elasticsearch_RankEvalRequestDescriptor___0__System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.RankEvalAsync``1(Elastic.Clients.Elasticsearch.RankEvalRequestDescriptor{``0},System.Threading.CancellationToken)">
  RankEvalAsync&lt;TDocument&gt;(RankEvalRequestDescriptor&lt;TDocument&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L25978"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Evaluate ranked search results.
</p>
<p>
Evaluate the quality of ranked search results over a set of typical search queries.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-rank-eval.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;RankEvalResponse&gt; RankEvalAsync&lt;TDocument&gt;(RankEvalRequestDescriptor&lt;TDocument&gt; descriptor, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.RankEvalRequestDescriptor-1.html">RankEvalRequestDescriptor</a>&lt;TDocument&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.RankEvalResponse.html">RankEvalResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_RankEvalAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.RankEvalAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_RankEvalAsync__1_System_Action_Elastic_Clients_Elasticsearch_RankEvalRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.RankEvalAsync``1(System.Action{Elastic.Clients.Elasticsearch.RankEvalRequestDescriptor{``0}},System.Threading.CancellationToken)">
  RankEvalAsync&lt;TDocument&gt;(Action&lt;RankEvalRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L26042"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Evaluate ranked search results.
</p>
<p>
Evaluate the quality of ranked search results over a set of typical search queries.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-rank-eval.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;RankEvalResponse&gt; RankEvalAsync&lt;TDocument&gt;(Action&lt;RankEvalRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.RankEvalRequestDescriptor-1.html">RankEvalRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.RankEvalResponse.html">RankEvalResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_RankEvalAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.RankEvalAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_RankEvalAsync__1_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.RankEvalAsync``1(System.Threading.CancellationToken)">
  RankEvalAsync&lt;TDocument&gt;(CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L26026"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Evaluate ranked search results.
</p>
<p>
Evaluate the quality of ranked search results over a set of typical search queries.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-rank-eval.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;RankEvalResponse&gt; RankEvalAsync&lt;TDocument&gt;(CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.RankEvalResponse.html">RankEvalResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_RankEval_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.RankEval*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_RankEval__1" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.RankEval``1">
  RankEval&lt;TDocument&gt;()
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L25857"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Evaluate ranked search results.
</p>
<p>
Evaluate the quality of ranked search results over a set of typical search queries.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-rank-eval.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual RankEvalResponse RankEval&lt;TDocument&gt;()</code></pre>
  </div>


  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.RankEvalResponse.html">RankEvalResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_RankEval_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.RankEval*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_RankEval__1_Elastic_Clients_Elasticsearch_Indices_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.RankEval``1(Elastic.Clients.Elasticsearch.Indices)">
  RankEval&lt;TDocument&gt;(Indices?)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L25822"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Evaluate ranked search results.
</p>
<p>
Evaluate the quality of ranked search results over a set of typical search queries.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-rank-eval.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual RankEvalResponse RankEval&lt;TDocument&gt;(Indices? indices)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>indices</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Indices.html">Indices</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.RankEvalResponse.html">RankEvalResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_RankEval_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.RankEval*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_RankEval__1_Elastic_Clients_Elasticsearch_Indices_System_Action_Elastic_Clients_Elasticsearch_RankEvalRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.RankEval``1(Elastic.Clients.Elasticsearch.Indices,System.Action{Elastic.Clients.Elasticsearch.RankEvalRequestDescriptor{``0}})">
  RankEval&lt;TDocument&gt;(Indices?, Action&lt;RankEvalRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L25839"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Evaluate ranked search results.
</p>
<p>
Evaluate the quality of ranked search results over a set of typical search queries.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-rank-eval.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual RankEvalResponse RankEval&lt;TDocument&gt;(Indices? indices, Action&lt;RankEvalRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>indices</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Indices.html">Indices</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.RankEvalRequestDescriptor-1.html">RankEvalRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.RankEvalResponse.html">RankEvalResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_RankEval_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.RankEval*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_RankEval__1_Elastic_Clients_Elasticsearch_RankEvalRequestDescriptor___0__" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.RankEval``1(Elastic.Clients.Elasticsearch.RankEvalRequestDescriptor{``0})">
  RankEval&lt;TDocument&gt;(RankEvalRequestDescriptor&lt;TDocument&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L25806"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Evaluate ranked search results.
</p>
<p>
Evaluate the quality of ranked search results over a set of typical search queries.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-rank-eval.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual RankEvalResponse RankEval&lt;TDocument&gt;(RankEvalRequestDescriptor&lt;TDocument&gt; descriptor)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.RankEvalRequestDescriptor-1.html">RankEvalRequestDescriptor</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.RankEvalResponse.html">RankEvalResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_RankEval_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.RankEval*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_RankEval__1_System_Action_Elastic_Clients_Elasticsearch_RankEvalRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.RankEval``1(System.Action{Elastic.Clients.Elasticsearch.RankEvalRequestDescriptor{``0}})">
  RankEval&lt;TDocument&gt;(Action&lt;RankEvalRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L25874"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Evaluate ranked search results.
</p>
<p>
Evaluate the quality of ranked search results over a set of typical search queries.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-rank-eval.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual RankEvalResponse RankEval&lt;TDocument&gt;(Action&lt;RankEvalRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.RankEvalRequestDescriptor-1.html">RankEvalRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.RankEvalResponse.html">RankEvalResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Reindex_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Reindex*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Reindex" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Reindex">
  Reindex()
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L28233"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Reindex documents.
</p>
<p>
Copy documents from a source to a destination.
You can copy all documents to the destination index or reindex a subset of the documents.
The source can be any existing index, alias, or data stream.
The destination must differ from the source.
For example, you cannot reindex a data stream into itself.
</p>
<p>
IMPORTANT: Reindex requires <code>_source</code> to be enabled for all documents in the source.
The destination should be configured as wanted before calling the reindex API.
Reindex does not copy the settings from the source or its associated template.
Mappings, shard counts, and replicas, for example, must be configured ahead of time.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following security privileges:
</p>
<ul><li>
<p>
The <code>read</code> index privilege for the source data stream, index, or alias.
</p>
</li><li>
<p>
The <code>write</code> index privilege for the destination data stream, index, or index alias.
</p>
</li><li>
<p>
To automatically create a data stream or index with a reindex API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege for the destination data stream, index, or alias.
</p>
</li><li>
<p>
If reindexing from a remote cluster, the <code>source.remote.user</code> must have the <code>monitor</code> cluster privilege and the <code>read</code> index privilege for the source data stream, index, or alias.
</p>
</li></ul>
<p>
If reindexing from a remote cluster, you must explicitly allow the remote host in the <code>reindex.remote.whitelist</code> setting.
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
The <code>dest</code> element can be configured like the index API to control optimistic concurrency control.
Omitting <code>version_type</code> or setting it to <code>internal</code> causes Elasticsearch to blindly dump documents into the destination, overwriting any that happen to have the same ID.
</p>
<p>
Setting <code>version_type</code> to <code>external</code> causes Elasticsearch to preserve the <code>version</code> from the source, create any documents that are missing, and update any documents that have an older version in the destination than they do in the source.
</p>
<p>
Setting <code>op_type</code> to <code>create</code> causes the reindex API to create only missing documents in the destination.
All existing documents will cause a version conflict.
</p>
<p>
IMPORTANT: Because data streams are append-only, any reindex request to a destination data stream must have an <code>op_type</code> of <code>create</code>.
A reindex can only add new documents to a destination data stream.
It cannot update existing documents in a destination data stream.
</p>
<p>
By default, version conflicts abort the reindex process.
To continue reindexing if there are conflicts, set the <code>conflicts</code> request body property to <code>proceed</code>.
In this case, the response includes a count of the version conflicts that were encountered.
Note that the handling of other error types is unaffected by the <code>conflicts</code> property.
Additionally, if you opt to count version conflicts, the operation could attempt to reindex more documents from the source than <code>max_docs</code> until it has successfully indexed <code>max_docs</code> documents into the target or it has gone through every document in the source query.
</p>
<p>
NOTE: The reindex API makes no effort to handle ID collisions.
The last document written will "win" but the order isn't usually predictable so it is not a good idea to rely on this behavior.
Instead, make sure that IDs are unique by using a script.
</p>
<p>
<strong>Running reindex asynchronously</strong>
</p>
<p>
If the request contains <code>wait_for_completion=false</code>, Elasticsearch performs some preflight checks, launches the request, and returns a task you can use to cancel or get the status of the task.
Elasticsearch creates a record of this task as a document at <code>_tasks/&lt;task_id&gt;</code>.
</p>
<p>
<strong>Reindex from multiple sources</strong>
</p>
<p>
If you have many sources to reindex it is generally better to reindex them one at a time rather than using a glob pattern to pick up multiple sources.
That way you can resume the process if there are any errors by removing the partially completed source and starting over.
It also makes parallelizing the process fairly simple: split the list of sources to reindex and run each list in parallel.
</p>
<p>
For example, you can use a bash script like this:
</p>
<pre><code class="lang-csharp">for index in i1 i2 i3 i4 i5; do
  curl -HContent-Type:application/json -XPOST localhost:9200/_reindex?pretty -d'{
    "source": {
      "index": "'$index'"
    },
    "dest": {
      "index": "'$index'-reindexed"
    }
  }'
done</code></pre>
<p>
<strong>Throttling</strong>
</p>
<p>
Set <code>requests_per_second</code> to any positive decimal number (<code>1.4</code>, <code>6</code>, <code>1000</code>, for example) to throttle the rate at which reindex issues batches of index operations.
Requests are throttled by padding each batch with a wait time.
To turn off throttling, set <code>requests_per_second</code> to <code>-1</code>.
</p>
<p>
The throttling is done by waiting between batches so that the scroll that reindex uses internally can be given a timeout that takes into account the padding.
The padding time is the difference between the batch size divided by the <code>requests_per_second</code> and the time spent writing.
By default the batch size is <code>1000</code>, so if <code>requests_per_second</code> is set to <code>500</code>:
</p>
<pre><code class="lang-csharp">target_time = 1000 / 500 per second = 2 seconds
wait_time = target_time - write_time = 2 seconds - .5 seconds = 1.5 seconds</code></pre>
<p>
Since the batch is issued as a single bulk request, large batch sizes cause Elasticsearch to create many requests and then wait for a while before starting the next set.
This is "bursty" instead of "smooth".
</p>
<p>
<strong>Slicing</strong>
</p>
<p>
Reindex supports sliced scroll to parallelize the reindexing process.
This parallelization can improve efficiency and provide a convenient way to break the request down into smaller parts.
</p>
<p>
NOTE: Reindexing from remote clusters does not support manual or automatic slicing.
</p>
<p>
You can slice a reindex request manually by providing a slice ID and total number of slices to each request.
You can also let reindex automatically parallelize by using sliced scroll to slice on <code>_id</code>.
The <code>slices</code> parameter specifies the number of slices to use.
</p>
<p>
Adding <code>slices</code> to the reindex request just automates the manual process, creating sub-requests which means it has some quirks:
</p>
<ul><li>
<p>
You can see these requests in the tasks API. These sub-requests are "child" tasks of the task for the request with slices.
</p>
</li><li>
<p>
Fetching the status of the task for the request with <code>slices</code> only contains the status of completed slices.
</p>
</li><li>
<p>
These sub-requests are individually addressable for things like cancellation and rethrottling.
</p>
</li><li>
<p>
Rethrottling the request with <code>slices</code> will rethrottle the unfinished sub-request proportionally.
</p>
</li><li>
<p>
Canceling the request with <code>slices</code> will cancel each sub-request.
</p>
</li><li>
<p>
Due to the nature of <code>slices</code>, each sub-request won't get a perfectly even portion of the documents. All documents will be addressed, but some slices may be larger than others. Expect larger slices to have a more even distribution.
</p>
</li><li>
<p>
Parameters like <code>requests_per_second</code> and <code>max_docs</code> on a request with <code>slices</code> are distributed proportionally to each sub-request. Combine that with the previous point about distribution being uneven and you should conclude that using <code>max_docs</code> with <code>slices</code> might not result in exactly <code>max_docs</code> documents being reindexed.
</p>
</li><li>
<p>
Each sub-request gets a slightly different snapshot of the source, though these are all taken at approximately the same time.
</p>
</li></ul>
<p>
If slicing automatically, setting <code>slices</code> to <code>auto</code> will choose a reasonable number for most indices.
If slicing manually or otherwise tuning automatic slicing, use the following guidelines.
</p>
<p>
Query performance is most efficient when the number of slices is equal to the number of shards in the index.
If that number is large (for example, <code>500</code>), choose a lower number as too many slices will hurt performance.
Setting slices higher than the number of shards generally does not improve efficiency and adds overhead.
</p>
<p>
Indexing performance scales linearly across available resources with the number of slices.
</p>
<p>
Whether query or indexing performance dominates the runtime depends on the documents being reindexed and cluster resources.
</p>
<p>
<strong>Modify documents during reindexing</strong>
</p>
<p>
Like <code>_update_by_query</code>, reindex operations support a script that modifies the document.
Unlike <code>_update_by_query</code>, the script is allowed to modify the document's metadata.
</p>
<p>
Just as in <code>_update_by_query</code>, you can set <code>ctx.op</code> to change the operation that is run on the destination.
For example, set <code>ctx.op</code> to <code>noop</code> if your script decides that the document doesn’t have to be indexed in the destination. This "no operation" will be reported in the <code>noop</code> counter in the response body.
Set <code>ctx.op</code> to <code>delete</code> if your script decides that the document must be deleted from the destination.
The deletion will be reported in the <code>deleted</code> counter in the response body.
Setting <code>ctx.op</code> to anything else will return an error, as will setting any other field in <code>ctx</code>.
</p>
<p>
Think of the possibilities! Just be careful; you are able to change:
</p>
<ul><li>
<p>
<code>_id</code>
</p>
</li><li>
<p>
<code>_index</code>
</p>
</li><li>
<p>
<code>_version</code>
</p>
</li><li>
<p>
<code>_routing</code>
</p>
</li></ul>
<p>
Setting <code>_version</code> to <code>null</code> or clearing it from the <code>ctx</code> map is just like not sending the version in an indexing request.
It will cause the document to be overwritten in the destination regardless of the version on the target or the version type you use in the reindex API.
</p>
<p>
<strong>Reindex from remote</strong>
</p>
<p>
Reindex supports reindexing from a remote Elasticsearch cluster.
The <code>host</code> parameter must contain a scheme, host, port, and optional path.
The <code>username</code> and <code>password</code> parameters are optional and when they are present the reindex operation will connect to the remote Elasticsearch node using basic authentication.
Be sure to use HTTPS when using basic authentication or the password will be sent in plain text.
There are a range of settings available to configure the behavior of the HTTPS connection.
</p>
<p>
When using Elastic Cloud, it is also possible to authenticate against the remote cluster through the use of a valid API key.
Remote hosts must be explicitly allowed with the <code>reindex.remote.whitelist</code> setting.
It can be set to a comma delimited list of allowed remote host and port combinations.
Scheme is ignored; only the host and port are used.
For example:
</p>
<pre><code class="lang-csharp">reindex.remote.whitelist: [otherhost:9200, another:9200, 127.0.10.*:9200, localhost:*"]</code></pre>
<p>
The list of allowed hosts must be configured on any nodes that will coordinate the reindex.
This feature should work with remote clusters of any version of Elasticsearch.
This should enable you to upgrade from any version of Elasticsearch to the current version by reindexing from a cluster of the old version.
</p>
<p>
WARNING: Elasticsearch does not support forward compatibility across major versions.
For example, you cannot reindex from a 7.x cluster into a 6.x cluster.
</p>
<p>
To enable queries sent to older versions of Elasticsearch, the <code>query</code> parameter is sent directly to the remote host without validation or modification.
</p>
<p>
NOTE: Reindexing from remote clusters does not support manual or automatic slicing.
</p>
<p>
Reindexing from a remote server uses an on-heap buffer that defaults to a maximum size of 100mb.
If the remote index includes very large documents you'll need to use a smaller batch size.
It is also possible to set the socket read timeout on the remote connection with the <code>socket_timeout</code> field and the connection timeout with the <code>connect_timeout</code> field.
Both default to 30 seconds.
</p>
<p>
<strong>Configuring SSL parameters</strong>
</p>
<p>
Reindex from remote supports configurable SSL settings.
These must be specified in the <code>elasticsearch.yml</code> file, with the exception of the secure settings, which you add in the Elasticsearch keystore.
It is not possible to configure SSL in the body of the reindex request.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-reindex.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual ReindexResponse Reindex()</code></pre>
  </div>


  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ReindexResponse.html">ReindexResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Reindex_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Reindex*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Reindex_Elastic_Clients_Elasticsearch_ReindexRequest_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Reindex(Elastic.Clients.Elasticsearch.ReindexRequest)">
  Reindex(ReindexRequest)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L26425"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Reindex documents.
</p>
<p>
Copy documents from a source to a destination.
You can copy all documents to the destination index or reindex a subset of the documents.
The source can be any existing index, alias, or data stream.
The destination must differ from the source.
For example, you cannot reindex a data stream into itself.
</p>
<p>
IMPORTANT: Reindex requires <code>_source</code> to be enabled for all documents in the source.
The destination should be configured as wanted before calling the reindex API.
Reindex does not copy the settings from the source or its associated template.
Mappings, shard counts, and replicas, for example, must be configured ahead of time.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following security privileges:
</p>
<ul><li>
<p>
The <code>read</code> index privilege for the source data stream, index, or alias.
</p>
</li><li>
<p>
The <code>write</code> index privilege for the destination data stream, index, or index alias.
</p>
</li><li>
<p>
To automatically create a data stream or index with a reindex API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege for the destination data stream, index, or alias.
</p>
</li><li>
<p>
If reindexing from a remote cluster, the <code>source.remote.user</code> must have the <code>monitor</code> cluster privilege and the <code>read</code> index privilege for the source data stream, index, or alias.
</p>
</li></ul>
<p>
If reindexing from a remote cluster, you must explicitly allow the remote host in the <code>reindex.remote.whitelist</code> setting.
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
The <code>dest</code> element can be configured like the index API to control optimistic concurrency control.
Omitting <code>version_type</code> or setting it to <code>internal</code> causes Elasticsearch to blindly dump documents into the destination, overwriting any that happen to have the same ID.
</p>
<p>
Setting <code>version_type</code> to <code>external</code> causes Elasticsearch to preserve the <code>version</code> from the source, create any documents that are missing, and update any documents that have an older version in the destination than they do in the source.
</p>
<p>
Setting <code>op_type</code> to <code>create</code> causes the reindex API to create only missing documents in the destination.
All existing documents will cause a version conflict.
</p>
<p>
IMPORTANT: Because data streams are append-only, any reindex request to a destination data stream must have an <code>op_type</code> of <code>create</code>.
A reindex can only add new documents to a destination data stream.
It cannot update existing documents in a destination data stream.
</p>
<p>
By default, version conflicts abort the reindex process.
To continue reindexing if there are conflicts, set the <code>conflicts</code> request body property to <code>proceed</code>.
In this case, the response includes a count of the version conflicts that were encountered.
Note that the handling of other error types is unaffected by the <code>conflicts</code> property.
Additionally, if you opt to count version conflicts, the operation could attempt to reindex more documents from the source than <code>max_docs</code> until it has successfully indexed <code>max_docs</code> documents into the target or it has gone through every document in the source query.
</p>
<p>
NOTE: The reindex API makes no effort to handle ID collisions.
The last document written will "win" but the order isn't usually predictable so it is not a good idea to rely on this behavior.
Instead, make sure that IDs are unique by using a script.
</p>
<p>
<strong>Running reindex asynchronously</strong>
</p>
<p>
If the request contains <code>wait_for_completion=false</code>, Elasticsearch performs some preflight checks, launches the request, and returns a task you can use to cancel or get the status of the task.
Elasticsearch creates a record of this task as a document at <code>_tasks/&lt;task_id&gt;</code>.
</p>
<p>
<strong>Reindex from multiple sources</strong>
</p>
<p>
If you have many sources to reindex it is generally better to reindex them one at a time rather than using a glob pattern to pick up multiple sources.
That way you can resume the process if there are any errors by removing the partially completed source and starting over.
It also makes parallelizing the process fairly simple: split the list of sources to reindex and run each list in parallel.
</p>
<p>
For example, you can use a bash script like this:
</p>
<pre><code class="lang-csharp">for index in i1 i2 i3 i4 i5; do
  curl -HContent-Type:application/json -XPOST localhost:9200/_reindex?pretty -d'{
    "source": {
      "index": "'$index'"
    },
    "dest": {
      "index": "'$index'-reindexed"
    }
  }'
done</code></pre>
<p>
<strong>Throttling</strong>
</p>
<p>
Set <code>requests_per_second</code> to any positive decimal number (<code>1.4</code>, <code>6</code>, <code>1000</code>, for example) to throttle the rate at which reindex issues batches of index operations.
Requests are throttled by padding each batch with a wait time.
To turn off throttling, set <code>requests_per_second</code> to <code>-1</code>.
</p>
<p>
The throttling is done by waiting between batches so that the scroll that reindex uses internally can be given a timeout that takes into account the padding.
The padding time is the difference between the batch size divided by the <code>requests_per_second</code> and the time spent writing.
By default the batch size is <code>1000</code>, so if <code>requests_per_second</code> is set to <code>500</code>:
</p>
<pre><code class="lang-csharp">target_time = 1000 / 500 per second = 2 seconds
wait_time = target_time - write_time = 2 seconds - .5 seconds = 1.5 seconds</code></pre>
<p>
Since the batch is issued as a single bulk request, large batch sizes cause Elasticsearch to create many requests and then wait for a while before starting the next set.
This is "bursty" instead of "smooth".
</p>
<p>
<strong>Slicing</strong>
</p>
<p>
Reindex supports sliced scroll to parallelize the reindexing process.
This parallelization can improve efficiency and provide a convenient way to break the request down into smaller parts.
</p>
<p>
NOTE: Reindexing from remote clusters does not support manual or automatic slicing.
</p>
<p>
You can slice a reindex request manually by providing a slice ID and total number of slices to each request.
You can also let reindex automatically parallelize by using sliced scroll to slice on <code>_id</code>.
The <code>slices</code> parameter specifies the number of slices to use.
</p>
<p>
Adding <code>slices</code> to the reindex request just automates the manual process, creating sub-requests which means it has some quirks:
</p>
<ul><li>
<p>
You can see these requests in the tasks API. These sub-requests are "child" tasks of the task for the request with slices.
</p>
</li><li>
<p>
Fetching the status of the task for the request with <code>slices</code> only contains the status of completed slices.
</p>
</li><li>
<p>
These sub-requests are individually addressable for things like cancellation and rethrottling.
</p>
</li><li>
<p>
Rethrottling the request with <code>slices</code> will rethrottle the unfinished sub-request proportionally.
</p>
</li><li>
<p>
Canceling the request with <code>slices</code> will cancel each sub-request.
</p>
</li><li>
<p>
Due to the nature of <code>slices</code>, each sub-request won't get a perfectly even portion of the documents. All documents will be addressed, but some slices may be larger than others. Expect larger slices to have a more even distribution.
</p>
</li><li>
<p>
Parameters like <code>requests_per_second</code> and <code>max_docs</code> on a request with <code>slices</code> are distributed proportionally to each sub-request. Combine that with the previous point about distribution being uneven and you should conclude that using <code>max_docs</code> with <code>slices</code> might not result in exactly <code>max_docs</code> documents being reindexed.
</p>
</li><li>
<p>
Each sub-request gets a slightly different snapshot of the source, though these are all taken at approximately the same time.
</p>
</li></ul>
<p>
If slicing automatically, setting <code>slices</code> to <code>auto</code> will choose a reasonable number for most indices.
If slicing manually or otherwise tuning automatic slicing, use the following guidelines.
</p>
<p>
Query performance is most efficient when the number of slices is equal to the number of shards in the index.
If that number is large (for example, <code>500</code>), choose a lower number as too many slices will hurt performance.
Setting slices higher than the number of shards generally does not improve efficiency and adds overhead.
</p>
<p>
Indexing performance scales linearly across available resources with the number of slices.
</p>
<p>
Whether query or indexing performance dominates the runtime depends on the documents being reindexed and cluster resources.
</p>
<p>
<strong>Modify documents during reindexing</strong>
</p>
<p>
Like <code>_update_by_query</code>, reindex operations support a script that modifies the document.
Unlike <code>_update_by_query</code>, the script is allowed to modify the document's metadata.
</p>
<p>
Just as in <code>_update_by_query</code>, you can set <code>ctx.op</code> to change the operation that is run on the destination.
For example, set <code>ctx.op</code> to <code>noop</code> if your script decides that the document doesn’t have to be indexed in the destination. This "no operation" will be reported in the <code>noop</code> counter in the response body.
Set <code>ctx.op</code> to <code>delete</code> if your script decides that the document must be deleted from the destination.
The deletion will be reported in the <code>deleted</code> counter in the response body.
Setting <code>ctx.op</code> to anything else will return an error, as will setting any other field in <code>ctx</code>.
</p>
<p>
Think of the possibilities! Just be careful; you are able to change:
</p>
<ul><li>
<p>
<code>_id</code>
</p>
</li><li>
<p>
<code>_index</code>
</p>
</li><li>
<p>
<code>_version</code>
</p>
</li><li>
<p>
<code>_routing</code>
</p>
</li></ul>
<p>
Setting <code>_version</code> to <code>null</code> or clearing it from the <code>ctx</code> map is just like not sending the version in an indexing request.
It will cause the document to be overwritten in the destination regardless of the version on the target or the version type you use in the reindex API.
</p>
<p>
<strong>Reindex from remote</strong>
</p>
<p>
Reindex supports reindexing from a remote Elasticsearch cluster.
The <code>host</code> parameter must contain a scheme, host, port, and optional path.
The <code>username</code> and <code>password</code> parameters are optional and when they are present the reindex operation will connect to the remote Elasticsearch node using basic authentication.
Be sure to use HTTPS when using basic authentication or the password will be sent in plain text.
There are a range of settings available to configure the behavior of the HTTPS connection.
</p>
<p>
When using Elastic Cloud, it is also possible to authenticate against the remote cluster through the use of a valid API key.
Remote hosts must be explicitly allowed with the <code>reindex.remote.whitelist</code> setting.
It can be set to a comma delimited list of allowed remote host and port combinations.
Scheme is ignored; only the host and port are used.
For example:
</p>
<pre><code class="lang-csharp">reindex.remote.whitelist: [otherhost:9200, another:9200, 127.0.10.*:9200, localhost:*"]</code></pre>
<p>
The list of allowed hosts must be configured on any nodes that will coordinate the reindex.
This feature should work with remote clusters of any version of Elasticsearch.
This should enable you to upgrade from any version of Elasticsearch to the current version by reindexing from a cluster of the old version.
</p>
<p>
WARNING: Elasticsearch does not support forward compatibility across major versions.
For example, you cannot reindex from a 7.x cluster into a 6.x cluster.
</p>
<p>
To enable queries sent to older versions of Elasticsearch, the <code>query</code> parameter is sent directly to the remote host without validation or modification.
</p>
<p>
NOTE: Reindexing from remote clusters does not support manual or automatic slicing.
</p>
<p>
Reindexing from a remote server uses an on-heap buffer that defaults to a maximum size of 100mb.
If the remote index includes very large documents you'll need to use a smaller batch size.
It is also possible to set the socket read timeout on the remote connection with the <code>socket_timeout</code> field and the connection timeout with the <code>connect_timeout</code> field.
Both default to 30 seconds.
</p>
<p>
<strong>Configuring SSL parameters</strong>
</p>
<p>
Reindex from remote supports configurable SSL settings.
These must be specified in the <code>elasticsearch.yml</code> file, with the exception of the secure settings, which you add in the Elasticsearch keystore.
It is not possible to configure SSL in the body of the reindex request.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-reindex.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual ReindexResponse Reindex(ReindexRequest request)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.ReindexRequest.html">ReindexRequest</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ReindexResponse.html">ReindexResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Reindex_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Reindex*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Reindex_Elastic_Clients_Elasticsearch_ReindexRequestDescriptor_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Reindex(Elastic.Clients.Elasticsearch.ReindexRequestDescriptor)">
  Reindex(ReindexRequestDescriptor)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L27932"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Reindex documents.
</p>
<p>
Copy documents from a source to a destination.
You can copy all documents to the destination index or reindex a subset of the documents.
The source can be any existing index, alias, or data stream.
The destination must differ from the source.
For example, you cannot reindex a data stream into itself.
</p>
<p>
IMPORTANT: Reindex requires <code>_source</code> to be enabled for all documents in the source.
The destination should be configured as wanted before calling the reindex API.
Reindex does not copy the settings from the source or its associated template.
Mappings, shard counts, and replicas, for example, must be configured ahead of time.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following security privileges:
</p>
<ul><li>
<p>
The <code>read</code> index privilege for the source data stream, index, or alias.
</p>
</li><li>
<p>
The <code>write</code> index privilege for the destination data stream, index, or index alias.
</p>
</li><li>
<p>
To automatically create a data stream or index with a reindex API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege for the destination data stream, index, or alias.
</p>
</li><li>
<p>
If reindexing from a remote cluster, the <code>source.remote.user</code> must have the <code>monitor</code> cluster privilege and the <code>read</code> index privilege for the source data stream, index, or alias.
</p>
</li></ul>
<p>
If reindexing from a remote cluster, you must explicitly allow the remote host in the <code>reindex.remote.whitelist</code> setting.
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
The <code>dest</code> element can be configured like the index API to control optimistic concurrency control.
Omitting <code>version_type</code> or setting it to <code>internal</code> causes Elasticsearch to blindly dump documents into the destination, overwriting any that happen to have the same ID.
</p>
<p>
Setting <code>version_type</code> to <code>external</code> causes Elasticsearch to preserve the <code>version</code> from the source, create any documents that are missing, and update any documents that have an older version in the destination than they do in the source.
</p>
<p>
Setting <code>op_type</code> to <code>create</code> causes the reindex API to create only missing documents in the destination.
All existing documents will cause a version conflict.
</p>
<p>
IMPORTANT: Because data streams are append-only, any reindex request to a destination data stream must have an <code>op_type</code> of <code>create</code>.
A reindex can only add new documents to a destination data stream.
It cannot update existing documents in a destination data stream.
</p>
<p>
By default, version conflicts abort the reindex process.
To continue reindexing if there are conflicts, set the <code>conflicts</code> request body property to <code>proceed</code>.
In this case, the response includes a count of the version conflicts that were encountered.
Note that the handling of other error types is unaffected by the <code>conflicts</code> property.
Additionally, if you opt to count version conflicts, the operation could attempt to reindex more documents from the source than <code>max_docs</code> until it has successfully indexed <code>max_docs</code> documents into the target or it has gone through every document in the source query.
</p>
<p>
NOTE: The reindex API makes no effort to handle ID collisions.
The last document written will "win" but the order isn't usually predictable so it is not a good idea to rely on this behavior.
Instead, make sure that IDs are unique by using a script.
</p>
<p>
<strong>Running reindex asynchronously</strong>
</p>
<p>
If the request contains <code>wait_for_completion=false</code>, Elasticsearch performs some preflight checks, launches the request, and returns a task you can use to cancel or get the status of the task.
Elasticsearch creates a record of this task as a document at <code>_tasks/&lt;task_id&gt;</code>.
</p>
<p>
<strong>Reindex from multiple sources</strong>
</p>
<p>
If you have many sources to reindex it is generally better to reindex them one at a time rather than using a glob pattern to pick up multiple sources.
That way you can resume the process if there are any errors by removing the partially completed source and starting over.
It also makes parallelizing the process fairly simple: split the list of sources to reindex and run each list in parallel.
</p>
<p>
For example, you can use a bash script like this:
</p>
<pre><code class="lang-csharp">for index in i1 i2 i3 i4 i5; do
  curl -HContent-Type:application/json -XPOST localhost:9200/_reindex?pretty -d'{
    "source": {
      "index": "'$index'"
    },
    "dest": {
      "index": "'$index'-reindexed"
    }
  }'
done</code></pre>
<p>
<strong>Throttling</strong>
</p>
<p>
Set <code>requests_per_second</code> to any positive decimal number (<code>1.4</code>, <code>6</code>, <code>1000</code>, for example) to throttle the rate at which reindex issues batches of index operations.
Requests are throttled by padding each batch with a wait time.
To turn off throttling, set <code>requests_per_second</code> to <code>-1</code>.
</p>
<p>
The throttling is done by waiting between batches so that the scroll that reindex uses internally can be given a timeout that takes into account the padding.
The padding time is the difference between the batch size divided by the <code>requests_per_second</code> and the time spent writing.
By default the batch size is <code>1000</code>, so if <code>requests_per_second</code> is set to <code>500</code>:
</p>
<pre><code class="lang-csharp">target_time = 1000 / 500 per second = 2 seconds
wait_time = target_time - write_time = 2 seconds - .5 seconds = 1.5 seconds</code></pre>
<p>
Since the batch is issued as a single bulk request, large batch sizes cause Elasticsearch to create many requests and then wait for a while before starting the next set.
This is "bursty" instead of "smooth".
</p>
<p>
<strong>Slicing</strong>
</p>
<p>
Reindex supports sliced scroll to parallelize the reindexing process.
This parallelization can improve efficiency and provide a convenient way to break the request down into smaller parts.
</p>
<p>
NOTE: Reindexing from remote clusters does not support manual or automatic slicing.
</p>
<p>
You can slice a reindex request manually by providing a slice ID and total number of slices to each request.
You can also let reindex automatically parallelize by using sliced scroll to slice on <code>_id</code>.
The <code>slices</code> parameter specifies the number of slices to use.
</p>
<p>
Adding <code>slices</code> to the reindex request just automates the manual process, creating sub-requests which means it has some quirks:
</p>
<ul><li>
<p>
You can see these requests in the tasks API. These sub-requests are "child" tasks of the task for the request with slices.
</p>
</li><li>
<p>
Fetching the status of the task for the request with <code>slices</code> only contains the status of completed slices.
</p>
</li><li>
<p>
These sub-requests are individually addressable for things like cancellation and rethrottling.
</p>
</li><li>
<p>
Rethrottling the request with <code>slices</code> will rethrottle the unfinished sub-request proportionally.
</p>
</li><li>
<p>
Canceling the request with <code>slices</code> will cancel each sub-request.
</p>
</li><li>
<p>
Due to the nature of <code>slices</code>, each sub-request won't get a perfectly even portion of the documents. All documents will be addressed, but some slices may be larger than others. Expect larger slices to have a more even distribution.
</p>
</li><li>
<p>
Parameters like <code>requests_per_second</code> and <code>max_docs</code> on a request with <code>slices</code> are distributed proportionally to each sub-request. Combine that with the previous point about distribution being uneven and you should conclude that using <code>max_docs</code> with <code>slices</code> might not result in exactly <code>max_docs</code> documents being reindexed.
</p>
</li><li>
<p>
Each sub-request gets a slightly different snapshot of the source, though these are all taken at approximately the same time.
</p>
</li></ul>
<p>
If slicing automatically, setting <code>slices</code> to <code>auto</code> will choose a reasonable number for most indices.
If slicing manually or otherwise tuning automatic slicing, use the following guidelines.
</p>
<p>
Query performance is most efficient when the number of slices is equal to the number of shards in the index.
If that number is large (for example, <code>500</code>), choose a lower number as too many slices will hurt performance.
Setting slices higher than the number of shards generally does not improve efficiency and adds overhead.
</p>
<p>
Indexing performance scales linearly across available resources with the number of slices.
</p>
<p>
Whether query or indexing performance dominates the runtime depends on the documents being reindexed and cluster resources.
</p>
<p>
<strong>Modify documents during reindexing</strong>
</p>
<p>
Like <code>_update_by_query</code>, reindex operations support a script that modifies the document.
Unlike <code>_update_by_query</code>, the script is allowed to modify the document's metadata.
</p>
<p>
Just as in <code>_update_by_query</code>, you can set <code>ctx.op</code> to change the operation that is run on the destination.
For example, set <code>ctx.op</code> to <code>noop</code> if your script decides that the document doesn’t have to be indexed in the destination. This "no operation" will be reported in the <code>noop</code> counter in the response body.
Set <code>ctx.op</code> to <code>delete</code> if your script decides that the document must be deleted from the destination.
The deletion will be reported in the <code>deleted</code> counter in the response body.
Setting <code>ctx.op</code> to anything else will return an error, as will setting any other field in <code>ctx</code>.
</p>
<p>
Think of the possibilities! Just be careful; you are able to change:
</p>
<ul><li>
<p>
<code>_id</code>
</p>
</li><li>
<p>
<code>_index</code>
</p>
</li><li>
<p>
<code>_version</code>
</p>
</li><li>
<p>
<code>_routing</code>
</p>
</li></ul>
<p>
Setting <code>_version</code> to <code>null</code> or clearing it from the <code>ctx</code> map is just like not sending the version in an indexing request.
It will cause the document to be overwritten in the destination regardless of the version on the target or the version type you use in the reindex API.
</p>
<p>
<strong>Reindex from remote</strong>
</p>
<p>
Reindex supports reindexing from a remote Elasticsearch cluster.
The <code>host</code> parameter must contain a scheme, host, port, and optional path.
The <code>username</code> and <code>password</code> parameters are optional and when they are present the reindex operation will connect to the remote Elasticsearch node using basic authentication.
Be sure to use HTTPS when using basic authentication or the password will be sent in plain text.
There are a range of settings available to configure the behavior of the HTTPS connection.
</p>
<p>
When using Elastic Cloud, it is also possible to authenticate against the remote cluster through the use of a valid API key.
Remote hosts must be explicitly allowed with the <code>reindex.remote.whitelist</code> setting.
It can be set to a comma delimited list of allowed remote host and port combinations.
Scheme is ignored; only the host and port are used.
For example:
</p>
<pre><code class="lang-csharp">reindex.remote.whitelist: [otherhost:9200, another:9200, 127.0.10.*:9200, localhost:*"]</code></pre>
<p>
The list of allowed hosts must be configured on any nodes that will coordinate the reindex.
This feature should work with remote clusters of any version of Elasticsearch.
This should enable you to upgrade from any version of Elasticsearch to the current version by reindexing from a cluster of the old version.
</p>
<p>
WARNING: Elasticsearch does not support forward compatibility across major versions.
For example, you cannot reindex from a 7.x cluster into a 6.x cluster.
</p>
<p>
To enable queries sent to older versions of Elasticsearch, the <code>query</code> parameter is sent directly to the remote host without validation or modification.
</p>
<p>
NOTE: Reindexing from remote clusters does not support manual or automatic slicing.
</p>
<p>
Reindexing from a remote server uses an on-heap buffer that defaults to a maximum size of 100mb.
If the remote index includes very large documents you'll need to use a smaller batch size.
It is also possible to set the socket read timeout on the remote connection with the <code>socket_timeout</code> field and the connection timeout with the <code>connect_timeout</code> field.
Both default to 30 seconds.
</p>
<p>
<strong>Configuring SSL parameters</strong>
</p>
<p>
Reindex from remote supports configurable SSL settings.
These must be specified in the <code>elasticsearch.yml</code> file, with the exception of the secure settings, which you add in the Elasticsearch keystore.
It is not possible to configure SSL in the body of the reindex request.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-reindex.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual ReindexResponse Reindex(ReindexRequestDescriptor descriptor)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.ReindexRequestDescriptor.html">ReindexRequestDescriptor</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ReindexResponse.html">ReindexResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Reindex_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Reindex*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Reindex_System_Action_Elastic_Clients_Elasticsearch_ReindexRequestDescriptor__" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Reindex(System.Action{Elastic.Clients.Elasticsearch.ReindexRequestDescriptor})">
  Reindex(Action&lt;ReindexRequestDescriptor&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L28535"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Reindex documents.
</p>
<p>
Copy documents from a source to a destination.
You can copy all documents to the destination index or reindex a subset of the documents.
The source can be any existing index, alias, or data stream.
The destination must differ from the source.
For example, you cannot reindex a data stream into itself.
</p>
<p>
IMPORTANT: Reindex requires <code>_source</code> to be enabled for all documents in the source.
The destination should be configured as wanted before calling the reindex API.
Reindex does not copy the settings from the source or its associated template.
Mappings, shard counts, and replicas, for example, must be configured ahead of time.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following security privileges:
</p>
<ul><li>
<p>
The <code>read</code> index privilege for the source data stream, index, or alias.
</p>
</li><li>
<p>
The <code>write</code> index privilege for the destination data stream, index, or index alias.
</p>
</li><li>
<p>
To automatically create a data stream or index with a reindex API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege for the destination data stream, index, or alias.
</p>
</li><li>
<p>
If reindexing from a remote cluster, the <code>source.remote.user</code> must have the <code>monitor</code> cluster privilege and the <code>read</code> index privilege for the source data stream, index, or alias.
</p>
</li></ul>
<p>
If reindexing from a remote cluster, you must explicitly allow the remote host in the <code>reindex.remote.whitelist</code> setting.
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
The <code>dest</code> element can be configured like the index API to control optimistic concurrency control.
Omitting <code>version_type</code> or setting it to <code>internal</code> causes Elasticsearch to blindly dump documents into the destination, overwriting any that happen to have the same ID.
</p>
<p>
Setting <code>version_type</code> to <code>external</code> causes Elasticsearch to preserve the <code>version</code> from the source, create any documents that are missing, and update any documents that have an older version in the destination than they do in the source.
</p>
<p>
Setting <code>op_type</code> to <code>create</code> causes the reindex API to create only missing documents in the destination.
All existing documents will cause a version conflict.
</p>
<p>
IMPORTANT: Because data streams are append-only, any reindex request to a destination data stream must have an <code>op_type</code> of <code>create</code>.
A reindex can only add new documents to a destination data stream.
It cannot update existing documents in a destination data stream.
</p>
<p>
By default, version conflicts abort the reindex process.
To continue reindexing if there are conflicts, set the <code>conflicts</code> request body property to <code>proceed</code>.
In this case, the response includes a count of the version conflicts that were encountered.
Note that the handling of other error types is unaffected by the <code>conflicts</code> property.
Additionally, if you opt to count version conflicts, the operation could attempt to reindex more documents from the source than <code>max_docs</code> until it has successfully indexed <code>max_docs</code> documents into the target or it has gone through every document in the source query.
</p>
<p>
NOTE: The reindex API makes no effort to handle ID collisions.
The last document written will "win" but the order isn't usually predictable so it is not a good idea to rely on this behavior.
Instead, make sure that IDs are unique by using a script.
</p>
<p>
<strong>Running reindex asynchronously</strong>
</p>
<p>
If the request contains <code>wait_for_completion=false</code>, Elasticsearch performs some preflight checks, launches the request, and returns a task you can use to cancel or get the status of the task.
Elasticsearch creates a record of this task as a document at <code>_tasks/&lt;task_id&gt;</code>.
</p>
<p>
<strong>Reindex from multiple sources</strong>
</p>
<p>
If you have many sources to reindex it is generally better to reindex them one at a time rather than using a glob pattern to pick up multiple sources.
That way you can resume the process if there are any errors by removing the partially completed source and starting over.
It also makes parallelizing the process fairly simple: split the list of sources to reindex and run each list in parallel.
</p>
<p>
For example, you can use a bash script like this:
</p>
<pre><code class="lang-csharp">for index in i1 i2 i3 i4 i5; do
  curl -HContent-Type:application/json -XPOST localhost:9200/_reindex?pretty -d'{
    "source": {
      "index": "'$index'"
    },
    "dest": {
      "index": "'$index'-reindexed"
    }
  }'
done</code></pre>
<p>
<strong>Throttling</strong>
</p>
<p>
Set <code>requests_per_second</code> to any positive decimal number (<code>1.4</code>, <code>6</code>, <code>1000</code>, for example) to throttle the rate at which reindex issues batches of index operations.
Requests are throttled by padding each batch with a wait time.
To turn off throttling, set <code>requests_per_second</code> to <code>-1</code>.
</p>
<p>
The throttling is done by waiting between batches so that the scroll that reindex uses internally can be given a timeout that takes into account the padding.
The padding time is the difference between the batch size divided by the <code>requests_per_second</code> and the time spent writing.
By default the batch size is <code>1000</code>, so if <code>requests_per_second</code> is set to <code>500</code>:
</p>
<pre><code class="lang-csharp">target_time = 1000 / 500 per second = 2 seconds
wait_time = target_time - write_time = 2 seconds - .5 seconds = 1.5 seconds</code></pre>
<p>
Since the batch is issued as a single bulk request, large batch sizes cause Elasticsearch to create many requests and then wait for a while before starting the next set.
This is "bursty" instead of "smooth".
</p>
<p>
<strong>Slicing</strong>
</p>
<p>
Reindex supports sliced scroll to parallelize the reindexing process.
This parallelization can improve efficiency and provide a convenient way to break the request down into smaller parts.
</p>
<p>
NOTE: Reindexing from remote clusters does not support manual or automatic slicing.
</p>
<p>
You can slice a reindex request manually by providing a slice ID and total number of slices to each request.
You can also let reindex automatically parallelize by using sliced scroll to slice on <code>_id</code>.
The <code>slices</code> parameter specifies the number of slices to use.
</p>
<p>
Adding <code>slices</code> to the reindex request just automates the manual process, creating sub-requests which means it has some quirks:
</p>
<ul><li>
<p>
You can see these requests in the tasks API. These sub-requests are "child" tasks of the task for the request with slices.
</p>
</li><li>
<p>
Fetching the status of the task for the request with <code>slices</code> only contains the status of completed slices.
</p>
</li><li>
<p>
These sub-requests are individually addressable for things like cancellation and rethrottling.
</p>
</li><li>
<p>
Rethrottling the request with <code>slices</code> will rethrottle the unfinished sub-request proportionally.
</p>
</li><li>
<p>
Canceling the request with <code>slices</code> will cancel each sub-request.
</p>
</li><li>
<p>
Due to the nature of <code>slices</code>, each sub-request won't get a perfectly even portion of the documents. All documents will be addressed, but some slices may be larger than others. Expect larger slices to have a more even distribution.
</p>
</li><li>
<p>
Parameters like <code>requests_per_second</code> and <code>max_docs</code> on a request with <code>slices</code> are distributed proportionally to each sub-request. Combine that with the previous point about distribution being uneven and you should conclude that using <code>max_docs</code> with <code>slices</code> might not result in exactly <code>max_docs</code> documents being reindexed.
</p>
</li><li>
<p>
Each sub-request gets a slightly different snapshot of the source, though these are all taken at approximately the same time.
</p>
</li></ul>
<p>
If slicing automatically, setting <code>slices</code> to <code>auto</code> will choose a reasonable number for most indices.
If slicing manually or otherwise tuning automatic slicing, use the following guidelines.
</p>
<p>
Query performance is most efficient when the number of slices is equal to the number of shards in the index.
If that number is large (for example, <code>500</code>), choose a lower number as too many slices will hurt performance.
Setting slices higher than the number of shards generally does not improve efficiency and adds overhead.
</p>
<p>
Indexing performance scales linearly across available resources with the number of slices.
</p>
<p>
Whether query or indexing performance dominates the runtime depends on the documents being reindexed and cluster resources.
</p>
<p>
<strong>Modify documents during reindexing</strong>
</p>
<p>
Like <code>_update_by_query</code>, reindex operations support a script that modifies the document.
Unlike <code>_update_by_query</code>, the script is allowed to modify the document's metadata.
</p>
<p>
Just as in <code>_update_by_query</code>, you can set <code>ctx.op</code> to change the operation that is run on the destination.
For example, set <code>ctx.op</code> to <code>noop</code> if your script decides that the document doesn’t have to be indexed in the destination. This "no operation" will be reported in the <code>noop</code> counter in the response body.
Set <code>ctx.op</code> to <code>delete</code> if your script decides that the document must be deleted from the destination.
The deletion will be reported in the <code>deleted</code> counter in the response body.
Setting <code>ctx.op</code> to anything else will return an error, as will setting any other field in <code>ctx</code>.
</p>
<p>
Think of the possibilities! Just be careful; you are able to change:
</p>
<ul><li>
<p>
<code>_id</code>
</p>
</li><li>
<p>
<code>_index</code>
</p>
</li><li>
<p>
<code>_version</code>
</p>
</li><li>
<p>
<code>_routing</code>
</p>
</li></ul>
<p>
Setting <code>_version</code> to <code>null</code> or clearing it from the <code>ctx</code> map is just like not sending the version in an indexing request.
It will cause the document to be overwritten in the destination regardless of the version on the target or the version type you use in the reindex API.
</p>
<p>
<strong>Reindex from remote</strong>
</p>
<p>
Reindex supports reindexing from a remote Elasticsearch cluster.
The <code>host</code> parameter must contain a scheme, host, port, and optional path.
The <code>username</code> and <code>password</code> parameters are optional and when they are present the reindex operation will connect to the remote Elasticsearch node using basic authentication.
Be sure to use HTTPS when using basic authentication or the password will be sent in plain text.
There are a range of settings available to configure the behavior of the HTTPS connection.
</p>
<p>
When using Elastic Cloud, it is also possible to authenticate against the remote cluster through the use of a valid API key.
Remote hosts must be explicitly allowed with the <code>reindex.remote.whitelist</code> setting.
It can be set to a comma delimited list of allowed remote host and port combinations.
Scheme is ignored; only the host and port are used.
For example:
</p>
<pre><code class="lang-csharp">reindex.remote.whitelist: [otherhost:9200, another:9200, 127.0.10.*:9200, localhost:*"]</code></pre>
<p>
The list of allowed hosts must be configured on any nodes that will coordinate the reindex.
This feature should work with remote clusters of any version of Elasticsearch.
This should enable you to upgrade from any version of Elasticsearch to the current version by reindexing from a cluster of the old version.
</p>
<p>
WARNING: Elasticsearch does not support forward compatibility across major versions.
For example, you cannot reindex from a 7.x cluster into a 6.x cluster.
</p>
<p>
To enable queries sent to older versions of Elasticsearch, the <code>query</code> parameter is sent directly to the remote host without validation or modification.
</p>
<p>
NOTE: Reindexing from remote clusters does not support manual or automatic slicing.
</p>
<p>
Reindexing from a remote server uses an on-heap buffer that defaults to a maximum size of 100mb.
If the remote index includes very large documents you'll need to use a smaller batch size.
It is also possible to set the socket read timeout on the remote connection with the <code>socket_timeout</code> field and the connection timeout with the <code>connect_timeout</code> field.
Both default to 30 seconds.
</p>
<p>
<strong>Configuring SSL parameters</strong>
</p>
<p>
Reindex from remote supports configurable SSL settings.
These must be specified in the <code>elasticsearch.yml</code> file, with the exception of the secure settings, which you add in the Elasticsearch keystore.
It is not possible to configure SSL in the body of the reindex request.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-reindex.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual ReindexResponse Reindex(Action&lt;ReindexRequestDescriptor&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ReindexRequestDescriptor.html">ReindexRequestDescriptor</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ReindexResponse.html">ReindexResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ReindexAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ReindexAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ReindexAsync_Elastic_Clients_Elasticsearch_ReindexRequest_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ReindexAsync(Elastic.Clients.Elasticsearch.ReindexRequest,System.Threading.CancellationToken)">
  ReindexAsync(ReindexRequest, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L26726"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Reindex documents.
</p>
<p>
Copy documents from a source to a destination.
You can copy all documents to the destination index or reindex a subset of the documents.
The source can be any existing index, alias, or data stream.
The destination must differ from the source.
For example, you cannot reindex a data stream into itself.
</p>
<p>
IMPORTANT: Reindex requires <code>_source</code> to be enabled for all documents in the source.
The destination should be configured as wanted before calling the reindex API.
Reindex does not copy the settings from the source or its associated template.
Mappings, shard counts, and replicas, for example, must be configured ahead of time.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following security privileges:
</p>
<ul><li>
<p>
The <code>read</code> index privilege for the source data stream, index, or alias.
</p>
</li><li>
<p>
The <code>write</code> index privilege for the destination data stream, index, or index alias.
</p>
</li><li>
<p>
To automatically create a data stream or index with a reindex API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege for the destination data stream, index, or alias.
</p>
</li><li>
<p>
If reindexing from a remote cluster, the <code>source.remote.user</code> must have the <code>monitor</code> cluster privilege and the <code>read</code> index privilege for the source data stream, index, or alias.
</p>
</li></ul>
<p>
If reindexing from a remote cluster, you must explicitly allow the remote host in the <code>reindex.remote.whitelist</code> setting.
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
The <code>dest</code> element can be configured like the index API to control optimistic concurrency control.
Omitting <code>version_type</code> or setting it to <code>internal</code> causes Elasticsearch to blindly dump documents into the destination, overwriting any that happen to have the same ID.
</p>
<p>
Setting <code>version_type</code> to <code>external</code> causes Elasticsearch to preserve the <code>version</code> from the source, create any documents that are missing, and update any documents that have an older version in the destination than they do in the source.
</p>
<p>
Setting <code>op_type</code> to <code>create</code> causes the reindex API to create only missing documents in the destination.
All existing documents will cause a version conflict.
</p>
<p>
IMPORTANT: Because data streams are append-only, any reindex request to a destination data stream must have an <code>op_type</code> of <code>create</code>.
A reindex can only add new documents to a destination data stream.
It cannot update existing documents in a destination data stream.
</p>
<p>
By default, version conflicts abort the reindex process.
To continue reindexing if there are conflicts, set the <code>conflicts</code> request body property to <code>proceed</code>.
In this case, the response includes a count of the version conflicts that were encountered.
Note that the handling of other error types is unaffected by the <code>conflicts</code> property.
Additionally, if you opt to count version conflicts, the operation could attempt to reindex more documents from the source than <code>max_docs</code> until it has successfully indexed <code>max_docs</code> documents into the target or it has gone through every document in the source query.
</p>
<p>
NOTE: The reindex API makes no effort to handle ID collisions.
The last document written will "win" but the order isn't usually predictable so it is not a good idea to rely on this behavior.
Instead, make sure that IDs are unique by using a script.
</p>
<p>
<strong>Running reindex asynchronously</strong>
</p>
<p>
If the request contains <code>wait_for_completion=false</code>, Elasticsearch performs some preflight checks, launches the request, and returns a task you can use to cancel or get the status of the task.
Elasticsearch creates a record of this task as a document at <code>_tasks/&lt;task_id&gt;</code>.
</p>
<p>
<strong>Reindex from multiple sources</strong>
</p>
<p>
If you have many sources to reindex it is generally better to reindex them one at a time rather than using a glob pattern to pick up multiple sources.
That way you can resume the process if there are any errors by removing the partially completed source and starting over.
It also makes parallelizing the process fairly simple: split the list of sources to reindex and run each list in parallel.
</p>
<p>
For example, you can use a bash script like this:
</p>
<pre><code class="lang-csharp">for index in i1 i2 i3 i4 i5; do
  curl -HContent-Type:application/json -XPOST localhost:9200/_reindex?pretty -d'{
    "source": {
      "index": "'$index'"
    },
    "dest": {
      "index": "'$index'-reindexed"
    }
  }'
done</code></pre>
<p>
<strong>Throttling</strong>
</p>
<p>
Set <code>requests_per_second</code> to any positive decimal number (<code>1.4</code>, <code>6</code>, <code>1000</code>, for example) to throttle the rate at which reindex issues batches of index operations.
Requests are throttled by padding each batch with a wait time.
To turn off throttling, set <code>requests_per_second</code> to <code>-1</code>.
</p>
<p>
The throttling is done by waiting between batches so that the scroll that reindex uses internally can be given a timeout that takes into account the padding.
The padding time is the difference between the batch size divided by the <code>requests_per_second</code> and the time spent writing.
By default the batch size is <code>1000</code>, so if <code>requests_per_second</code> is set to <code>500</code>:
</p>
<pre><code class="lang-csharp">target_time = 1000 / 500 per second = 2 seconds
wait_time = target_time - write_time = 2 seconds - .5 seconds = 1.5 seconds</code></pre>
<p>
Since the batch is issued as a single bulk request, large batch sizes cause Elasticsearch to create many requests and then wait for a while before starting the next set.
This is "bursty" instead of "smooth".
</p>
<p>
<strong>Slicing</strong>
</p>
<p>
Reindex supports sliced scroll to parallelize the reindexing process.
This parallelization can improve efficiency and provide a convenient way to break the request down into smaller parts.
</p>
<p>
NOTE: Reindexing from remote clusters does not support manual or automatic slicing.
</p>
<p>
You can slice a reindex request manually by providing a slice ID and total number of slices to each request.
You can also let reindex automatically parallelize by using sliced scroll to slice on <code>_id</code>.
The <code>slices</code> parameter specifies the number of slices to use.
</p>
<p>
Adding <code>slices</code> to the reindex request just automates the manual process, creating sub-requests which means it has some quirks:
</p>
<ul><li>
<p>
You can see these requests in the tasks API. These sub-requests are "child" tasks of the task for the request with slices.
</p>
</li><li>
<p>
Fetching the status of the task for the request with <code>slices</code> only contains the status of completed slices.
</p>
</li><li>
<p>
These sub-requests are individually addressable for things like cancellation and rethrottling.
</p>
</li><li>
<p>
Rethrottling the request with <code>slices</code> will rethrottle the unfinished sub-request proportionally.
</p>
</li><li>
<p>
Canceling the request with <code>slices</code> will cancel each sub-request.
</p>
</li><li>
<p>
Due to the nature of <code>slices</code>, each sub-request won't get a perfectly even portion of the documents. All documents will be addressed, but some slices may be larger than others. Expect larger slices to have a more even distribution.
</p>
</li><li>
<p>
Parameters like <code>requests_per_second</code> and <code>max_docs</code> on a request with <code>slices</code> are distributed proportionally to each sub-request. Combine that with the previous point about distribution being uneven and you should conclude that using <code>max_docs</code> with <code>slices</code> might not result in exactly <code>max_docs</code> documents being reindexed.
</p>
</li><li>
<p>
Each sub-request gets a slightly different snapshot of the source, though these are all taken at approximately the same time.
</p>
</li></ul>
<p>
If slicing automatically, setting <code>slices</code> to <code>auto</code> will choose a reasonable number for most indices.
If slicing manually or otherwise tuning automatic slicing, use the following guidelines.
</p>
<p>
Query performance is most efficient when the number of slices is equal to the number of shards in the index.
If that number is large (for example, <code>500</code>), choose a lower number as too many slices will hurt performance.
Setting slices higher than the number of shards generally does not improve efficiency and adds overhead.
</p>
<p>
Indexing performance scales linearly across available resources with the number of slices.
</p>
<p>
Whether query or indexing performance dominates the runtime depends on the documents being reindexed and cluster resources.
</p>
<p>
<strong>Modify documents during reindexing</strong>
</p>
<p>
Like <code>_update_by_query</code>, reindex operations support a script that modifies the document.
Unlike <code>_update_by_query</code>, the script is allowed to modify the document's metadata.
</p>
<p>
Just as in <code>_update_by_query</code>, you can set <code>ctx.op</code> to change the operation that is run on the destination.
For example, set <code>ctx.op</code> to <code>noop</code> if your script decides that the document doesn’t have to be indexed in the destination. This "no operation" will be reported in the <code>noop</code> counter in the response body.
Set <code>ctx.op</code> to <code>delete</code> if your script decides that the document must be deleted from the destination.
The deletion will be reported in the <code>deleted</code> counter in the response body.
Setting <code>ctx.op</code> to anything else will return an error, as will setting any other field in <code>ctx</code>.
</p>
<p>
Think of the possibilities! Just be careful; you are able to change:
</p>
<ul><li>
<p>
<code>_id</code>
</p>
</li><li>
<p>
<code>_index</code>
</p>
</li><li>
<p>
<code>_version</code>
</p>
</li><li>
<p>
<code>_routing</code>
</p>
</li></ul>
<p>
Setting <code>_version</code> to <code>null</code> or clearing it from the <code>ctx</code> map is just like not sending the version in an indexing request.
It will cause the document to be overwritten in the destination regardless of the version on the target or the version type you use in the reindex API.
</p>
<p>
<strong>Reindex from remote</strong>
</p>
<p>
Reindex supports reindexing from a remote Elasticsearch cluster.
The <code>host</code> parameter must contain a scheme, host, port, and optional path.
The <code>username</code> and <code>password</code> parameters are optional and when they are present the reindex operation will connect to the remote Elasticsearch node using basic authentication.
Be sure to use HTTPS when using basic authentication or the password will be sent in plain text.
There are a range of settings available to configure the behavior of the HTTPS connection.
</p>
<p>
When using Elastic Cloud, it is also possible to authenticate against the remote cluster through the use of a valid API key.
Remote hosts must be explicitly allowed with the <code>reindex.remote.whitelist</code> setting.
It can be set to a comma delimited list of allowed remote host and port combinations.
Scheme is ignored; only the host and port are used.
For example:
</p>
<pre><code class="lang-csharp">reindex.remote.whitelist: [otherhost:9200, another:9200, 127.0.10.*:9200, localhost:*"]</code></pre>
<p>
The list of allowed hosts must be configured on any nodes that will coordinate the reindex.
This feature should work with remote clusters of any version of Elasticsearch.
This should enable you to upgrade from any version of Elasticsearch to the current version by reindexing from a cluster of the old version.
</p>
<p>
WARNING: Elasticsearch does not support forward compatibility across major versions.
For example, you cannot reindex from a 7.x cluster into a 6.x cluster.
</p>
<p>
To enable queries sent to older versions of Elasticsearch, the <code>query</code> parameter is sent directly to the remote host without validation or modification.
</p>
<p>
NOTE: Reindexing from remote clusters does not support manual or automatic slicing.
</p>
<p>
Reindexing from a remote server uses an on-heap buffer that defaults to a maximum size of 100mb.
If the remote index includes very large documents you'll need to use a smaller batch size.
It is also possible to set the socket read timeout on the remote connection with the <code>socket_timeout</code> field and the connection timeout with the <code>connect_timeout</code> field.
Both default to 30 seconds.
</p>
<p>
<strong>Configuring SSL parameters</strong>
</p>
<p>
Reindex from remote supports configurable SSL settings.
These must be specified in the <code>elasticsearch.yml</code> file, with the exception of the secure settings, which you add in the Elasticsearch keystore.
It is not possible to configure SSL in the body of the reindex request.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-reindex.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;ReindexResponse&gt; ReindexAsync(ReindexRequest request, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.ReindexRequest.html">ReindexRequest</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ReindexResponse.html">ReindexResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ReindexAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ReindexAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ReindexAsync_Elastic_Clients_Elasticsearch_ReindexRequestDescriptor_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ReindexAsync(Elastic.Clients.Elasticsearch.ReindexRequestDescriptor,System.Threading.CancellationToken)">
  ReindexAsync(ReindexRequestDescriptor, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L29741"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Reindex documents.
</p>
<p>
Copy documents from a source to a destination.
You can copy all documents to the destination index or reindex a subset of the documents.
The source can be any existing index, alias, or data stream.
The destination must differ from the source.
For example, you cannot reindex a data stream into itself.
</p>
<p>
IMPORTANT: Reindex requires <code>_source</code> to be enabled for all documents in the source.
The destination should be configured as wanted before calling the reindex API.
Reindex does not copy the settings from the source or its associated template.
Mappings, shard counts, and replicas, for example, must be configured ahead of time.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following security privileges:
</p>
<ul><li>
<p>
The <code>read</code> index privilege for the source data stream, index, or alias.
</p>
</li><li>
<p>
The <code>write</code> index privilege for the destination data stream, index, or index alias.
</p>
</li><li>
<p>
To automatically create a data stream or index with a reindex API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege for the destination data stream, index, or alias.
</p>
</li><li>
<p>
If reindexing from a remote cluster, the <code>source.remote.user</code> must have the <code>monitor</code> cluster privilege and the <code>read</code> index privilege for the source data stream, index, or alias.
</p>
</li></ul>
<p>
If reindexing from a remote cluster, you must explicitly allow the remote host in the <code>reindex.remote.whitelist</code> setting.
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
The <code>dest</code> element can be configured like the index API to control optimistic concurrency control.
Omitting <code>version_type</code> or setting it to <code>internal</code> causes Elasticsearch to blindly dump documents into the destination, overwriting any that happen to have the same ID.
</p>
<p>
Setting <code>version_type</code> to <code>external</code> causes Elasticsearch to preserve the <code>version</code> from the source, create any documents that are missing, and update any documents that have an older version in the destination than they do in the source.
</p>
<p>
Setting <code>op_type</code> to <code>create</code> causes the reindex API to create only missing documents in the destination.
All existing documents will cause a version conflict.
</p>
<p>
IMPORTANT: Because data streams are append-only, any reindex request to a destination data stream must have an <code>op_type</code> of <code>create</code>.
A reindex can only add new documents to a destination data stream.
It cannot update existing documents in a destination data stream.
</p>
<p>
By default, version conflicts abort the reindex process.
To continue reindexing if there are conflicts, set the <code>conflicts</code> request body property to <code>proceed</code>.
In this case, the response includes a count of the version conflicts that were encountered.
Note that the handling of other error types is unaffected by the <code>conflicts</code> property.
Additionally, if you opt to count version conflicts, the operation could attempt to reindex more documents from the source than <code>max_docs</code> until it has successfully indexed <code>max_docs</code> documents into the target or it has gone through every document in the source query.
</p>
<p>
NOTE: The reindex API makes no effort to handle ID collisions.
The last document written will "win" but the order isn't usually predictable so it is not a good idea to rely on this behavior.
Instead, make sure that IDs are unique by using a script.
</p>
<p>
<strong>Running reindex asynchronously</strong>
</p>
<p>
If the request contains <code>wait_for_completion=false</code>, Elasticsearch performs some preflight checks, launches the request, and returns a task you can use to cancel or get the status of the task.
Elasticsearch creates a record of this task as a document at <code>_tasks/&lt;task_id&gt;</code>.
</p>
<p>
<strong>Reindex from multiple sources</strong>
</p>
<p>
If you have many sources to reindex it is generally better to reindex them one at a time rather than using a glob pattern to pick up multiple sources.
That way you can resume the process if there are any errors by removing the partially completed source and starting over.
It also makes parallelizing the process fairly simple: split the list of sources to reindex and run each list in parallel.
</p>
<p>
For example, you can use a bash script like this:
</p>
<pre><code class="lang-csharp">for index in i1 i2 i3 i4 i5; do
  curl -HContent-Type:application/json -XPOST localhost:9200/_reindex?pretty -d'{
    "source": {
      "index": "'$index'"
    },
    "dest": {
      "index": "'$index'-reindexed"
    }
  }'
done</code></pre>
<p>
<strong>Throttling</strong>
</p>
<p>
Set <code>requests_per_second</code> to any positive decimal number (<code>1.4</code>, <code>6</code>, <code>1000</code>, for example) to throttle the rate at which reindex issues batches of index operations.
Requests are throttled by padding each batch with a wait time.
To turn off throttling, set <code>requests_per_second</code> to <code>-1</code>.
</p>
<p>
The throttling is done by waiting between batches so that the scroll that reindex uses internally can be given a timeout that takes into account the padding.
The padding time is the difference between the batch size divided by the <code>requests_per_second</code> and the time spent writing.
By default the batch size is <code>1000</code>, so if <code>requests_per_second</code> is set to <code>500</code>:
</p>
<pre><code class="lang-csharp">target_time = 1000 / 500 per second = 2 seconds
wait_time = target_time - write_time = 2 seconds - .5 seconds = 1.5 seconds</code></pre>
<p>
Since the batch is issued as a single bulk request, large batch sizes cause Elasticsearch to create many requests and then wait for a while before starting the next set.
This is "bursty" instead of "smooth".
</p>
<p>
<strong>Slicing</strong>
</p>
<p>
Reindex supports sliced scroll to parallelize the reindexing process.
This parallelization can improve efficiency and provide a convenient way to break the request down into smaller parts.
</p>
<p>
NOTE: Reindexing from remote clusters does not support manual or automatic slicing.
</p>
<p>
You can slice a reindex request manually by providing a slice ID and total number of slices to each request.
You can also let reindex automatically parallelize by using sliced scroll to slice on <code>_id</code>.
The <code>slices</code> parameter specifies the number of slices to use.
</p>
<p>
Adding <code>slices</code> to the reindex request just automates the manual process, creating sub-requests which means it has some quirks:
</p>
<ul><li>
<p>
You can see these requests in the tasks API. These sub-requests are "child" tasks of the task for the request with slices.
</p>
</li><li>
<p>
Fetching the status of the task for the request with <code>slices</code> only contains the status of completed slices.
</p>
</li><li>
<p>
These sub-requests are individually addressable for things like cancellation and rethrottling.
</p>
</li><li>
<p>
Rethrottling the request with <code>slices</code> will rethrottle the unfinished sub-request proportionally.
</p>
</li><li>
<p>
Canceling the request with <code>slices</code> will cancel each sub-request.
</p>
</li><li>
<p>
Due to the nature of <code>slices</code>, each sub-request won't get a perfectly even portion of the documents. All documents will be addressed, but some slices may be larger than others. Expect larger slices to have a more even distribution.
</p>
</li><li>
<p>
Parameters like <code>requests_per_second</code> and <code>max_docs</code> on a request with <code>slices</code> are distributed proportionally to each sub-request. Combine that with the previous point about distribution being uneven and you should conclude that using <code>max_docs</code> with <code>slices</code> might not result in exactly <code>max_docs</code> documents being reindexed.
</p>
</li><li>
<p>
Each sub-request gets a slightly different snapshot of the source, though these are all taken at approximately the same time.
</p>
</li></ul>
<p>
If slicing automatically, setting <code>slices</code> to <code>auto</code> will choose a reasonable number for most indices.
If slicing manually or otherwise tuning automatic slicing, use the following guidelines.
</p>
<p>
Query performance is most efficient when the number of slices is equal to the number of shards in the index.
If that number is large (for example, <code>500</code>), choose a lower number as too many slices will hurt performance.
Setting slices higher than the number of shards generally does not improve efficiency and adds overhead.
</p>
<p>
Indexing performance scales linearly across available resources with the number of slices.
</p>
<p>
Whether query or indexing performance dominates the runtime depends on the documents being reindexed and cluster resources.
</p>
<p>
<strong>Modify documents during reindexing</strong>
</p>
<p>
Like <code>_update_by_query</code>, reindex operations support a script that modifies the document.
Unlike <code>_update_by_query</code>, the script is allowed to modify the document's metadata.
</p>
<p>
Just as in <code>_update_by_query</code>, you can set <code>ctx.op</code> to change the operation that is run on the destination.
For example, set <code>ctx.op</code> to <code>noop</code> if your script decides that the document doesn’t have to be indexed in the destination. This "no operation" will be reported in the <code>noop</code> counter in the response body.
Set <code>ctx.op</code> to <code>delete</code> if your script decides that the document must be deleted from the destination.
The deletion will be reported in the <code>deleted</code> counter in the response body.
Setting <code>ctx.op</code> to anything else will return an error, as will setting any other field in <code>ctx</code>.
</p>
<p>
Think of the possibilities! Just be careful; you are able to change:
</p>
<ul><li>
<p>
<code>_id</code>
</p>
</li><li>
<p>
<code>_index</code>
</p>
</li><li>
<p>
<code>_version</code>
</p>
</li><li>
<p>
<code>_routing</code>
</p>
</li></ul>
<p>
Setting <code>_version</code> to <code>null</code> or clearing it from the <code>ctx</code> map is just like not sending the version in an indexing request.
It will cause the document to be overwritten in the destination regardless of the version on the target or the version type you use in the reindex API.
</p>
<p>
<strong>Reindex from remote</strong>
</p>
<p>
Reindex supports reindexing from a remote Elasticsearch cluster.
The <code>host</code> parameter must contain a scheme, host, port, and optional path.
The <code>username</code> and <code>password</code> parameters are optional and when they are present the reindex operation will connect to the remote Elasticsearch node using basic authentication.
Be sure to use HTTPS when using basic authentication or the password will be sent in plain text.
There are a range of settings available to configure the behavior of the HTTPS connection.
</p>
<p>
When using Elastic Cloud, it is also possible to authenticate against the remote cluster through the use of a valid API key.
Remote hosts must be explicitly allowed with the <code>reindex.remote.whitelist</code> setting.
It can be set to a comma delimited list of allowed remote host and port combinations.
Scheme is ignored; only the host and port are used.
For example:
</p>
<pre><code class="lang-csharp">reindex.remote.whitelist: [otherhost:9200, another:9200, 127.0.10.*:9200, localhost:*"]</code></pre>
<p>
The list of allowed hosts must be configured on any nodes that will coordinate the reindex.
This feature should work with remote clusters of any version of Elasticsearch.
This should enable you to upgrade from any version of Elasticsearch to the current version by reindexing from a cluster of the old version.
</p>
<p>
WARNING: Elasticsearch does not support forward compatibility across major versions.
For example, you cannot reindex from a 7.x cluster into a 6.x cluster.
</p>
<p>
To enable queries sent to older versions of Elasticsearch, the <code>query</code> parameter is sent directly to the remote host without validation or modification.
</p>
<p>
NOTE: Reindexing from remote clusters does not support manual or automatic slicing.
</p>
<p>
Reindexing from a remote server uses an on-heap buffer that defaults to a maximum size of 100mb.
If the remote index includes very large documents you'll need to use a smaller batch size.
It is also possible to set the socket read timeout on the remote connection with the <code>socket_timeout</code> field and the connection timeout with the <code>connect_timeout</code> field.
Both default to 30 seconds.
</p>
<p>
<strong>Configuring SSL parameters</strong>
</p>
<p>
Reindex from remote supports configurable SSL settings.
These must be specified in the <code>elasticsearch.yml</code> file, with the exception of the secure settings, which you add in the Elasticsearch keystore.
It is not possible to configure SSL in the body of the reindex request.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-reindex.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;ReindexResponse&gt; ReindexAsync(ReindexRequestDescriptor descriptor, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.ReindexRequestDescriptor.html">ReindexRequestDescriptor</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ReindexResponse.html">ReindexResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ReindexAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ReindexAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ReindexAsync_System_Action_Elastic_Clients_Elasticsearch_ReindexRequestDescriptor__System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ReindexAsync(System.Action{Elastic.Clients.Elasticsearch.ReindexRequestDescriptor},System.Threading.CancellationToken)">
  ReindexAsync(Action&lt;ReindexRequestDescriptor&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L30342"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Reindex documents.
</p>
<p>
Copy documents from a source to a destination.
You can copy all documents to the destination index or reindex a subset of the documents.
The source can be any existing index, alias, or data stream.
The destination must differ from the source.
For example, you cannot reindex a data stream into itself.
</p>
<p>
IMPORTANT: Reindex requires <code>_source</code> to be enabled for all documents in the source.
The destination should be configured as wanted before calling the reindex API.
Reindex does not copy the settings from the source or its associated template.
Mappings, shard counts, and replicas, for example, must be configured ahead of time.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following security privileges:
</p>
<ul><li>
<p>
The <code>read</code> index privilege for the source data stream, index, or alias.
</p>
</li><li>
<p>
The <code>write</code> index privilege for the destination data stream, index, or index alias.
</p>
</li><li>
<p>
To automatically create a data stream or index with a reindex API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege for the destination data stream, index, or alias.
</p>
</li><li>
<p>
If reindexing from a remote cluster, the <code>source.remote.user</code> must have the <code>monitor</code> cluster privilege and the <code>read</code> index privilege for the source data stream, index, or alias.
</p>
</li></ul>
<p>
If reindexing from a remote cluster, you must explicitly allow the remote host in the <code>reindex.remote.whitelist</code> setting.
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
The <code>dest</code> element can be configured like the index API to control optimistic concurrency control.
Omitting <code>version_type</code> or setting it to <code>internal</code> causes Elasticsearch to blindly dump documents into the destination, overwriting any that happen to have the same ID.
</p>
<p>
Setting <code>version_type</code> to <code>external</code> causes Elasticsearch to preserve the <code>version</code> from the source, create any documents that are missing, and update any documents that have an older version in the destination than they do in the source.
</p>
<p>
Setting <code>op_type</code> to <code>create</code> causes the reindex API to create only missing documents in the destination.
All existing documents will cause a version conflict.
</p>
<p>
IMPORTANT: Because data streams are append-only, any reindex request to a destination data stream must have an <code>op_type</code> of <code>create</code>.
A reindex can only add new documents to a destination data stream.
It cannot update existing documents in a destination data stream.
</p>
<p>
By default, version conflicts abort the reindex process.
To continue reindexing if there are conflicts, set the <code>conflicts</code> request body property to <code>proceed</code>.
In this case, the response includes a count of the version conflicts that were encountered.
Note that the handling of other error types is unaffected by the <code>conflicts</code> property.
Additionally, if you opt to count version conflicts, the operation could attempt to reindex more documents from the source than <code>max_docs</code> until it has successfully indexed <code>max_docs</code> documents into the target or it has gone through every document in the source query.
</p>
<p>
NOTE: The reindex API makes no effort to handle ID collisions.
The last document written will "win" but the order isn't usually predictable so it is not a good idea to rely on this behavior.
Instead, make sure that IDs are unique by using a script.
</p>
<p>
<strong>Running reindex asynchronously</strong>
</p>
<p>
If the request contains <code>wait_for_completion=false</code>, Elasticsearch performs some preflight checks, launches the request, and returns a task you can use to cancel or get the status of the task.
Elasticsearch creates a record of this task as a document at <code>_tasks/&lt;task_id&gt;</code>.
</p>
<p>
<strong>Reindex from multiple sources</strong>
</p>
<p>
If you have many sources to reindex it is generally better to reindex them one at a time rather than using a glob pattern to pick up multiple sources.
That way you can resume the process if there are any errors by removing the partially completed source and starting over.
It also makes parallelizing the process fairly simple: split the list of sources to reindex and run each list in parallel.
</p>
<p>
For example, you can use a bash script like this:
</p>
<pre><code class="lang-csharp">for index in i1 i2 i3 i4 i5; do
  curl -HContent-Type:application/json -XPOST localhost:9200/_reindex?pretty -d'{
    "source": {
      "index": "'$index'"
    },
    "dest": {
      "index": "'$index'-reindexed"
    }
  }'
done</code></pre>
<p>
<strong>Throttling</strong>
</p>
<p>
Set <code>requests_per_second</code> to any positive decimal number (<code>1.4</code>, <code>6</code>, <code>1000</code>, for example) to throttle the rate at which reindex issues batches of index operations.
Requests are throttled by padding each batch with a wait time.
To turn off throttling, set <code>requests_per_second</code> to <code>-1</code>.
</p>
<p>
The throttling is done by waiting between batches so that the scroll that reindex uses internally can be given a timeout that takes into account the padding.
The padding time is the difference between the batch size divided by the <code>requests_per_second</code> and the time spent writing.
By default the batch size is <code>1000</code>, so if <code>requests_per_second</code> is set to <code>500</code>:
</p>
<pre><code class="lang-csharp">target_time = 1000 / 500 per second = 2 seconds
wait_time = target_time - write_time = 2 seconds - .5 seconds = 1.5 seconds</code></pre>
<p>
Since the batch is issued as a single bulk request, large batch sizes cause Elasticsearch to create many requests and then wait for a while before starting the next set.
This is "bursty" instead of "smooth".
</p>
<p>
<strong>Slicing</strong>
</p>
<p>
Reindex supports sliced scroll to parallelize the reindexing process.
This parallelization can improve efficiency and provide a convenient way to break the request down into smaller parts.
</p>
<p>
NOTE: Reindexing from remote clusters does not support manual or automatic slicing.
</p>
<p>
You can slice a reindex request manually by providing a slice ID and total number of slices to each request.
You can also let reindex automatically parallelize by using sliced scroll to slice on <code>_id</code>.
The <code>slices</code> parameter specifies the number of slices to use.
</p>
<p>
Adding <code>slices</code> to the reindex request just automates the manual process, creating sub-requests which means it has some quirks:
</p>
<ul><li>
<p>
You can see these requests in the tasks API. These sub-requests are "child" tasks of the task for the request with slices.
</p>
</li><li>
<p>
Fetching the status of the task for the request with <code>slices</code> only contains the status of completed slices.
</p>
</li><li>
<p>
These sub-requests are individually addressable for things like cancellation and rethrottling.
</p>
</li><li>
<p>
Rethrottling the request with <code>slices</code> will rethrottle the unfinished sub-request proportionally.
</p>
</li><li>
<p>
Canceling the request with <code>slices</code> will cancel each sub-request.
</p>
</li><li>
<p>
Due to the nature of <code>slices</code>, each sub-request won't get a perfectly even portion of the documents. All documents will be addressed, but some slices may be larger than others. Expect larger slices to have a more even distribution.
</p>
</li><li>
<p>
Parameters like <code>requests_per_second</code> and <code>max_docs</code> on a request with <code>slices</code> are distributed proportionally to each sub-request. Combine that with the previous point about distribution being uneven and you should conclude that using <code>max_docs</code> with <code>slices</code> might not result in exactly <code>max_docs</code> documents being reindexed.
</p>
</li><li>
<p>
Each sub-request gets a slightly different snapshot of the source, though these are all taken at approximately the same time.
</p>
</li></ul>
<p>
If slicing automatically, setting <code>slices</code> to <code>auto</code> will choose a reasonable number for most indices.
If slicing manually or otherwise tuning automatic slicing, use the following guidelines.
</p>
<p>
Query performance is most efficient when the number of slices is equal to the number of shards in the index.
If that number is large (for example, <code>500</code>), choose a lower number as too many slices will hurt performance.
Setting slices higher than the number of shards generally does not improve efficiency and adds overhead.
</p>
<p>
Indexing performance scales linearly across available resources with the number of slices.
</p>
<p>
Whether query or indexing performance dominates the runtime depends on the documents being reindexed and cluster resources.
</p>
<p>
<strong>Modify documents during reindexing</strong>
</p>
<p>
Like <code>_update_by_query</code>, reindex operations support a script that modifies the document.
Unlike <code>_update_by_query</code>, the script is allowed to modify the document's metadata.
</p>
<p>
Just as in <code>_update_by_query</code>, you can set <code>ctx.op</code> to change the operation that is run on the destination.
For example, set <code>ctx.op</code> to <code>noop</code> if your script decides that the document doesn’t have to be indexed in the destination. This "no operation" will be reported in the <code>noop</code> counter in the response body.
Set <code>ctx.op</code> to <code>delete</code> if your script decides that the document must be deleted from the destination.
The deletion will be reported in the <code>deleted</code> counter in the response body.
Setting <code>ctx.op</code> to anything else will return an error, as will setting any other field in <code>ctx</code>.
</p>
<p>
Think of the possibilities! Just be careful; you are able to change:
</p>
<ul><li>
<p>
<code>_id</code>
</p>
</li><li>
<p>
<code>_index</code>
</p>
</li><li>
<p>
<code>_version</code>
</p>
</li><li>
<p>
<code>_routing</code>
</p>
</li></ul>
<p>
Setting <code>_version</code> to <code>null</code> or clearing it from the <code>ctx</code> map is just like not sending the version in an indexing request.
It will cause the document to be overwritten in the destination regardless of the version on the target or the version type you use in the reindex API.
</p>
<p>
<strong>Reindex from remote</strong>
</p>
<p>
Reindex supports reindexing from a remote Elasticsearch cluster.
The <code>host</code> parameter must contain a scheme, host, port, and optional path.
The <code>username</code> and <code>password</code> parameters are optional and when they are present the reindex operation will connect to the remote Elasticsearch node using basic authentication.
Be sure to use HTTPS when using basic authentication or the password will be sent in plain text.
There are a range of settings available to configure the behavior of the HTTPS connection.
</p>
<p>
When using Elastic Cloud, it is also possible to authenticate against the remote cluster through the use of a valid API key.
Remote hosts must be explicitly allowed with the <code>reindex.remote.whitelist</code> setting.
It can be set to a comma delimited list of allowed remote host and port combinations.
Scheme is ignored; only the host and port are used.
For example:
</p>
<pre><code class="lang-csharp">reindex.remote.whitelist: [otherhost:9200, another:9200, 127.0.10.*:9200, localhost:*"]</code></pre>
<p>
The list of allowed hosts must be configured on any nodes that will coordinate the reindex.
This feature should work with remote clusters of any version of Elasticsearch.
This should enable you to upgrade from any version of Elasticsearch to the current version by reindexing from a cluster of the old version.
</p>
<p>
WARNING: Elasticsearch does not support forward compatibility across major versions.
For example, you cannot reindex from a 7.x cluster into a 6.x cluster.
</p>
<p>
To enable queries sent to older versions of Elasticsearch, the <code>query</code> parameter is sent directly to the remote host without validation or modification.
</p>
<p>
NOTE: Reindexing from remote clusters does not support manual or automatic slicing.
</p>
<p>
Reindexing from a remote server uses an on-heap buffer that defaults to a maximum size of 100mb.
If the remote index includes very large documents you'll need to use a smaller batch size.
It is also possible to set the socket read timeout on the remote connection with the <code>socket_timeout</code> field and the connection timeout with the <code>connect_timeout</code> field.
Both default to 30 seconds.
</p>
<p>
<strong>Configuring SSL parameters</strong>
</p>
<p>
Reindex from remote supports configurable SSL settings.
These must be specified in the <code>elasticsearch.yml</code> file, with the exception of the secure settings, which you add in the Elasticsearch keystore.
It is not possible to configure SSL in the body of the reindex request.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-reindex.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;ReindexResponse&gt; ReindexAsync(Action&lt;ReindexRequestDescriptor&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ReindexRequestDescriptor.html">ReindexRequestDescriptor</a>&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ReindexResponse.html">ReindexResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ReindexAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ReindexAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ReindexAsync_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ReindexAsync(System.Threading.CancellationToken)">
  ReindexAsync(CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L30041"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Reindex documents.
</p>
<p>
Copy documents from a source to a destination.
You can copy all documents to the destination index or reindex a subset of the documents.
The source can be any existing index, alias, or data stream.
The destination must differ from the source.
For example, you cannot reindex a data stream into itself.
</p>
<p>
IMPORTANT: Reindex requires <code>_source</code> to be enabled for all documents in the source.
The destination should be configured as wanted before calling the reindex API.
Reindex does not copy the settings from the source or its associated template.
Mappings, shard counts, and replicas, for example, must be configured ahead of time.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following security privileges:
</p>
<ul><li>
<p>
The <code>read</code> index privilege for the source data stream, index, or alias.
</p>
</li><li>
<p>
The <code>write</code> index privilege for the destination data stream, index, or index alias.
</p>
</li><li>
<p>
To automatically create a data stream or index with a reindex API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege for the destination data stream, index, or alias.
</p>
</li><li>
<p>
If reindexing from a remote cluster, the <code>source.remote.user</code> must have the <code>monitor</code> cluster privilege and the <code>read</code> index privilege for the source data stream, index, or alias.
</p>
</li></ul>
<p>
If reindexing from a remote cluster, you must explicitly allow the remote host in the <code>reindex.remote.whitelist</code> setting.
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
The <code>dest</code> element can be configured like the index API to control optimistic concurrency control.
Omitting <code>version_type</code> or setting it to <code>internal</code> causes Elasticsearch to blindly dump documents into the destination, overwriting any that happen to have the same ID.
</p>
<p>
Setting <code>version_type</code> to <code>external</code> causes Elasticsearch to preserve the <code>version</code> from the source, create any documents that are missing, and update any documents that have an older version in the destination than they do in the source.
</p>
<p>
Setting <code>op_type</code> to <code>create</code> causes the reindex API to create only missing documents in the destination.
All existing documents will cause a version conflict.
</p>
<p>
IMPORTANT: Because data streams are append-only, any reindex request to a destination data stream must have an <code>op_type</code> of <code>create</code>.
A reindex can only add new documents to a destination data stream.
It cannot update existing documents in a destination data stream.
</p>
<p>
By default, version conflicts abort the reindex process.
To continue reindexing if there are conflicts, set the <code>conflicts</code> request body property to <code>proceed</code>.
In this case, the response includes a count of the version conflicts that were encountered.
Note that the handling of other error types is unaffected by the <code>conflicts</code> property.
Additionally, if you opt to count version conflicts, the operation could attempt to reindex more documents from the source than <code>max_docs</code> until it has successfully indexed <code>max_docs</code> documents into the target or it has gone through every document in the source query.
</p>
<p>
NOTE: The reindex API makes no effort to handle ID collisions.
The last document written will "win" but the order isn't usually predictable so it is not a good idea to rely on this behavior.
Instead, make sure that IDs are unique by using a script.
</p>
<p>
<strong>Running reindex asynchronously</strong>
</p>
<p>
If the request contains <code>wait_for_completion=false</code>, Elasticsearch performs some preflight checks, launches the request, and returns a task you can use to cancel or get the status of the task.
Elasticsearch creates a record of this task as a document at <code>_tasks/&lt;task_id&gt;</code>.
</p>
<p>
<strong>Reindex from multiple sources</strong>
</p>
<p>
If you have many sources to reindex it is generally better to reindex them one at a time rather than using a glob pattern to pick up multiple sources.
That way you can resume the process if there are any errors by removing the partially completed source and starting over.
It also makes parallelizing the process fairly simple: split the list of sources to reindex and run each list in parallel.
</p>
<p>
For example, you can use a bash script like this:
</p>
<pre><code class="lang-csharp">for index in i1 i2 i3 i4 i5; do
  curl -HContent-Type:application/json -XPOST localhost:9200/_reindex?pretty -d'{
    "source": {
      "index": "'$index'"
    },
    "dest": {
      "index": "'$index'-reindexed"
    }
  }'
done</code></pre>
<p>
<strong>Throttling</strong>
</p>
<p>
Set <code>requests_per_second</code> to any positive decimal number (<code>1.4</code>, <code>6</code>, <code>1000</code>, for example) to throttle the rate at which reindex issues batches of index operations.
Requests are throttled by padding each batch with a wait time.
To turn off throttling, set <code>requests_per_second</code> to <code>-1</code>.
</p>
<p>
The throttling is done by waiting between batches so that the scroll that reindex uses internally can be given a timeout that takes into account the padding.
The padding time is the difference between the batch size divided by the <code>requests_per_second</code> and the time spent writing.
By default the batch size is <code>1000</code>, so if <code>requests_per_second</code> is set to <code>500</code>:
</p>
<pre><code class="lang-csharp">target_time = 1000 / 500 per second = 2 seconds
wait_time = target_time - write_time = 2 seconds - .5 seconds = 1.5 seconds</code></pre>
<p>
Since the batch is issued as a single bulk request, large batch sizes cause Elasticsearch to create many requests and then wait for a while before starting the next set.
This is "bursty" instead of "smooth".
</p>
<p>
<strong>Slicing</strong>
</p>
<p>
Reindex supports sliced scroll to parallelize the reindexing process.
This parallelization can improve efficiency and provide a convenient way to break the request down into smaller parts.
</p>
<p>
NOTE: Reindexing from remote clusters does not support manual or automatic slicing.
</p>
<p>
You can slice a reindex request manually by providing a slice ID and total number of slices to each request.
You can also let reindex automatically parallelize by using sliced scroll to slice on <code>_id</code>.
The <code>slices</code> parameter specifies the number of slices to use.
</p>
<p>
Adding <code>slices</code> to the reindex request just automates the manual process, creating sub-requests which means it has some quirks:
</p>
<ul><li>
<p>
You can see these requests in the tasks API. These sub-requests are "child" tasks of the task for the request with slices.
</p>
</li><li>
<p>
Fetching the status of the task for the request with <code>slices</code> only contains the status of completed slices.
</p>
</li><li>
<p>
These sub-requests are individually addressable for things like cancellation and rethrottling.
</p>
</li><li>
<p>
Rethrottling the request with <code>slices</code> will rethrottle the unfinished sub-request proportionally.
</p>
</li><li>
<p>
Canceling the request with <code>slices</code> will cancel each sub-request.
</p>
</li><li>
<p>
Due to the nature of <code>slices</code>, each sub-request won't get a perfectly even portion of the documents. All documents will be addressed, but some slices may be larger than others. Expect larger slices to have a more even distribution.
</p>
</li><li>
<p>
Parameters like <code>requests_per_second</code> and <code>max_docs</code> on a request with <code>slices</code> are distributed proportionally to each sub-request. Combine that with the previous point about distribution being uneven and you should conclude that using <code>max_docs</code> with <code>slices</code> might not result in exactly <code>max_docs</code> documents being reindexed.
</p>
</li><li>
<p>
Each sub-request gets a slightly different snapshot of the source, though these are all taken at approximately the same time.
</p>
</li></ul>
<p>
If slicing automatically, setting <code>slices</code> to <code>auto</code> will choose a reasonable number for most indices.
If slicing manually or otherwise tuning automatic slicing, use the following guidelines.
</p>
<p>
Query performance is most efficient when the number of slices is equal to the number of shards in the index.
If that number is large (for example, <code>500</code>), choose a lower number as too many slices will hurt performance.
Setting slices higher than the number of shards generally does not improve efficiency and adds overhead.
</p>
<p>
Indexing performance scales linearly across available resources with the number of slices.
</p>
<p>
Whether query or indexing performance dominates the runtime depends on the documents being reindexed and cluster resources.
</p>
<p>
<strong>Modify documents during reindexing</strong>
</p>
<p>
Like <code>_update_by_query</code>, reindex operations support a script that modifies the document.
Unlike <code>_update_by_query</code>, the script is allowed to modify the document's metadata.
</p>
<p>
Just as in <code>_update_by_query</code>, you can set <code>ctx.op</code> to change the operation that is run on the destination.
For example, set <code>ctx.op</code> to <code>noop</code> if your script decides that the document doesn’t have to be indexed in the destination. This "no operation" will be reported in the <code>noop</code> counter in the response body.
Set <code>ctx.op</code> to <code>delete</code> if your script decides that the document must be deleted from the destination.
The deletion will be reported in the <code>deleted</code> counter in the response body.
Setting <code>ctx.op</code> to anything else will return an error, as will setting any other field in <code>ctx</code>.
</p>
<p>
Think of the possibilities! Just be careful; you are able to change:
</p>
<ul><li>
<p>
<code>_id</code>
</p>
</li><li>
<p>
<code>_index</code>
</p>
</li><li>
<p>
<code>_version</code>
</p>
</li><li>
<p>
<code>_routing</code>
</p>
</li></ul>
<p>
Setting <code>_version</code> to <code>null</code> or clearing it from the <code>ctx</code> map is just like not sending the version in an indexing request.
It will cause the document to be overwritten in the destination regardless of the version on the target or the version type you use in the reindex API.
</p>
<p>
<strong>Reindex from remote</strong>
</p>
<p>
Reindex supports reindexing from a remote Elasticsearch cluster.
The <code>host</code> parameter must contain a scheme, host, port, and optional path.
The <code>username</code> and <code>password</code> parameters are optional and when they are present the reindex operation will connect to the remote Elasticsearch node using basic authentication.
Be sure to use HTTPS when using basic authentication or the password will be sent in plain text.
There are a range of settings available to configure the behavior of the HTTPS connection.
</p>
<p>
When using Elastic Cloud, it is also possible to authenticate against the remote cluster through the use of a valid API key.
Remote hosts must be explicitly allowed with the <code>reindex.remote.whitelist</code> setting.
It can be set to a comma delimited list of allowed remote host and port combinations.
Scheme is ignored; only the host and port are used.
For example:
</p>
<pre><code class="lang-csharp">reindex.remote.whitelist: [otherhost:9200, another:9200, 127.0.10.*:9200, localhost:*"]</code></pre>
<p>
The list of allowed hosts must be configured on any nodes that will coordinate the reindex.
This feature should work with remote clusters of any version of Elasticsearch.
This should enable you to upgrade from any version of Elasticsearch to the current version by reindexing from a cluster of the old version.
</p>
<p>
WARNING: Elasticsearch does not support forward compatibility across major versions.
For example, you cannot reindex from a 7.x cluster into a 6.x cluster.
</p>
<p>
To enable queries sent to older versions of Elasticsearch, the <code>query</code> parameter is sent directly to the remote host without validation or modification.
</p>
<p>
NOTE: Reindexing from remote clusters does not support manual or automatic slicing.
</p>
<p>
Reindexing from a remote server uses an on-heap buffer that defaults to a maximum size of 100mb.
If the remote index includes very large documents you'll need to use a smaller batch size.
It is also possible to set the socket read timeout on the remote connection with the <code>socket_timeout</code> field and the connection timeout with the <code>connect_timeout</code> field.
Both default to 30 seconds.
</p>
<p>
<strong>Configuring SSL parameters</strong>
</p>
<p>
Reindex from remote supports configurable SSL settings.
These must be specified in the <code>elasticsearch.yml</code> file, with the exception of the secure settings, which you add in the Elasticsearch keystore.
It is not possible to configure SSL in the body of the reindex request.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-reindex.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;ReindexResponse&gt; ReindexAsync(CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ReindexResponse.html">ReindexResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ReindexAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ReindexAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ReindexAsync__1_Elastic_Clients_Elasticsearch_ReindexRequestDescriptor___0__System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ReindexAsync``1(Elastic.Clients.Elasticsearch.ReindexRequestDescriptor{``0},System.Threading.CancellationToken)">
  ReindexAsync&lt;TDocument&gt;(ReindexRequestDescriptor&lt;TDocument&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L28838"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Reindex documents.
</p>
<p>
Copy documents from a source to a destination.
You can copy all documents to the destination index or reindex a subset of the documents.
The source can be any existing index, alias, or data stream.
The destination must differ from the source.
For example, you cannot reindex a data stream into itself.
</p>
<p>
IMPORTANT: Reindex requires <code>_source</code> to be enabled for all documents in the source.
The destination should be configured as wanted before calling the reindex API.
Reindex does not copy the settings from the source or its associated template.
Mappings, shard counts, and replicas, for example, must be configured ahead of time.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following security privileges:
</p>
<ul><li>
<p>
The <code>read</code> index privilege for the source data stream, index, or alias.
</p>
</li><li>
<p>
The <code>write</code> index privilege for the destination data stream, index, or index alias.
</p>
</li><li>
<p>
To automatically create a data stream or index with a reindex API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege for the destination data stream, index, or alias.
</p>
</li><li>
<p>
If reindexing from a remote cluster, the <code>source.remote.user</code> must have the <code>monitor</code> cluster privilege and the <code>read</code> index privilege for the source data stream, index, or alias.
</p>
</li></ul>
<p>
If reindexing from a remote cluster, you must explicitly allow the remote host in the <code>reindex.remote.whitelist</code> setting.
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
The <code>dest</code> element can be configured like the index API to control optimistic concurrency control.
Omitting <code>version_type</code> or setting it to <code>internal</code> causes Elasticsearch to blindly dump documents into the destination, overwriting any that happen to have the same ID.
</p>
<p>
Setting <code>version_type</code> to <code>external</code> causes Elasticsearch to preserve the <code>version</code> from the source, create any documents that are missing, and update any documents that have an older version in the destination than they do in the source.
</p>
<p>
Setting <code>op_type</code> to <code>create</code> causes the reindex API to create only missing documents in the destination.
All existing documents will cause a version conflict.
</p>
<p>
IMPORTANT: Because data streams are append-only, any reindex request to a destination data stream must have an <code>op_type</code> of <code>create</code>.
A reindex can only add new documents to a destination data stream.
It cannot update existing documents in a destination data stream.
</p>
<p>
By default, version conflicts abort the reindex process.
To continue reindexing if there are conflicts, set the <code>conflicts</code> request body property to <code>proceed</code>.
In this case, the response includes a count of the version conflicts that were encountered.
Note that the handling of other error types is unaffected by the <code>conflicts</code> property.
Additionally, if you opt to count version conflicts, the operation could attempt to reindex more documents from the source than <code>max_docs</code> until it has successfully indexed <code>max_docs</code> documents into the target or it has gone through every document in the source query.
</p>
<p>
NOTE: The reindex API makes no effort to handle ID collisions.
The last document written will "win" but the order isn't usually predictable so it is not a good idea to rely on this behavior.
Instead, make sure that IDs are unique by using a script.
</p>
<p>
<strong>Running reindex asynchronously</strong>
</p>
<p>
If the request contains <code>wait_for_completion=false</code>, Elasticsearch performs some preflight checks, launches the request, and returns a task you can use to cancel or get the status of the task.
Elasticsearch creates a record of this task as a document at <code>_tasks/&lt;task_id&gt;</code>.
</p>
<p>
<strong>Reindex from multiple sources</strong>
</p>
<p>
If you have many sources to reindex it is generally better to reindex them one at a time rather than using a glob pattern to pick up multiple sources.
That way you can resume the process if there are any errors by removing the partially completed source and starting over.
It also makes parallelizing the process fairly simple: split the list of sources to reindex and run each list in parallel.
</p>
<p>
For example, you can use a bash script like this:
</p>
<pre><code class="lang-csharp">for index in i1 i2 i3 i4 i5; do
  curl -HContent-Type:application/json -XPOST localhost:9200/_reindex?pretty -d'{
    "source": {
      "index": "'$index'"
    },
    "dest": {
      "index": "'$index'-reindexed"
    }
  }'
done</code></pre>
<p>
<strong>Throttling</strong>
</p>
<p>
Set <code>requests_per_second</code> to any positive decimal number (<code>1.4</code>, <code>6</code>, <code>1000</code>, for example) to throttle the rate at which reindex issues batches of index operations.
Requests are throttled by padding each batch with a wait time.
To turn off throttling, set <code>requests_per_second</code> to <code>-1</code>.
</p>
<p>
The throttling is done by waiting between batches so that the scroll that reindex uses internally can be given a timeout that takes into account the padding.
The padding time is the difference between the batch size divided by the <code>requests_per_second</code> and the time spent writing.
By default the batch size is <code>1000</code>, so if <code>requests_per_second</code> is set to <code>500</code>:
</p>
<pre><code class="lang-csharp">target_time = 1000 / 500 per second = 2 seconds
wait_time = target_time - write_time = 2 seconds - .5 seconds = 1.5 seconds</code></pre>
<p>
Since the batch is issued as a single bulk request, large batch sizes cause Elasticsearch to create many requests and then wait for a while before starting the next set.
This is "bursty" instead of "smooth".
</p>
<p>
<strong>Slicing</strong>
</p>
<p>
Reindex supports sliced scroll to parallelize the reindexing process.
This parallelization can improve efficiency and provide a convenient way to break the request down into smaller parts.
</p>
<p>
NOTE: Reindexing from remote clusters does not support manual or automatic slicing.
</p>
<p>
You can slice a reindex request manually by providing a slice ID and total number of slices to each request.
You can also let reindex automatically parallelize by using sliced scroll to slice on <code>_id</code>.
The <code>slices</code> parameter specifies the number of slices to use.
</p>
<p>
Adding <code>slices</code> to the reindex request just automates the manual process, creating sub-requests which means it has some quirks:
</p>
<ul><li>
<p>
You can see these requests in the tasks API. These sub-requests are "child" tasks of the task for the request with slices.
</p>
</li><li>
<p>
Fetching the status of the task for the request with <code>slices</code> only contains the status of completed slices.
</p>
</li><li>
<p>
These sub-requests are individually addressable for things like cancellation and rethrottling.
</p>
</li><li>
<p>
Rethrottling the request with <code>slices</code> will rethrottle the unfinished sub-request proportionally.
</p>
</li><li>
<p>
Canceling the request with <code>slices</code> will cancel each sub-request.
</p>
</li><li>
<p>
Due to the nature of <code>slices</code>, each sub-request won't get a perfectly even portion of the documents. All documents will be addressed, but some slices may be larger than others. Expect larger slices to have a more even distribution.
</p>
</li><li>
<p>
Parameters like <code>requests_per_second</code> and <code>max_docs</code> on a request with <code>slices</code> are distributed proportionally to each sub-request. Combine that with the previous point about distribution being uneven and you should conclude that using <code>max_docs</code> with <code>slices</code> might not result in exactly <code>max_docs</code> documents being reindexed.
</p>
</li><li>
<p>
Each sub-request gets a slightly different snapshot of the source, though these are all taken at approximately the same time.
</p>
</li></ul>
<p>
If slicing automatically, setting <code>slices</code> to <code>auto</code> will choose a reasonable number for most indices.
If slicing manually or otherwise tuning automatic slicing, use the following guidelines.
</p>
<p>
Query performance is most efficient when the number of slices is equal to the number of shards in the index.
If that number is large (for example, <code>500</code>), choose a lower number as too many slices will hurt performance.
Setting slices higher than the number of shards generally does not improve efficiency and adds overhead.
</p>
<p>
Indexing performance scales linearly across available resources with the number of slices.
</p>
<p>
Whether query or indexing performance dominates the runtime depends on the documents being reindexed and cluster resources.
</p>
<p>
<strong>Modify documents during reindexing</strong>
</p>
<p>
Like <code>_update_by_query</code>, reindex operations support a script that modifies the document.
Unlike <code>_update_by_query</code>, the script is allowed to modify the document's metadata.
</p>
<p>
Just as in <code>_update_by_query</code>, you can set <code>ctx.op</code> to change the operation that is run on the destination.
For example, set <code>ctx.op</code> to <code>noop</code> if your script decides that the document doesn’t have to be indexed in the destination. This "no operation" will be reported in the <code>noop</code> counter in the response body.
Set <code>ctx.op</code> to <code>delete</code> if your script decides that the document must be deleted from the destination.
The deletion will be reported in the <code>deleted</code> counter in the response body.
Setting <code>ctx.op</code> to anything else will return an error, as will setting any other field in <code>ctx</code>.
</p>
<p>
Think of the possibilities! Just be careful; you are able to change:
</p>
<ul><li>
<p>
<code>_id</code>
</p>
</li><li>
<p>
<code>_index</code>
</p>
</li><li>
<p>
<code>_version</code>
</p>
</li><li>
<p>
<code>_routing</code>
</p>
</li></ul>
<p>
Setting <code>_version</code> to <code>null</code> or clearing it from the <code>ctx</code> map is just like not sending the version in an indexing request.
It will cause the document to be overwritten in the destination regardless of the version on the target or the version type you use in the reindex API.
</p>
<p>
<strong>Reindex from remote</strong>
</p>
<p>
Reindex supports reindexing from a remote Elasticsearch cluster.
The <code>host</code> parameter must contain a scheme, host, port, and optional path.
The <code>username</code> and <code>password</code> parameters are optional and when they are present the reindex operation will connect to the remote Elasticsearch node using basic authentication.
Be sure to use HTTPS when using basic authentication or the password will be sent in plain text.
There are a range of settings available to configure the behavior of the HTTPS connection.
</p>
<p>
When using Elastic Cloud, it is also possible to authenticate against the remote cluster through the use of a valid API key.
Remote hosts must be explicitly allowed with the <code>reindex.remote.whitelist</code> setting.
It can be set to a comma delimited list of allowed remote host and port combinations.
Scheme is ignored; only the host and port are used.
For example:
</p>
<pre><code class="lang-csharp">reindex.remote.whitelist: [otherhost:9200, another:9200, 127.0.10.*:9200, localhost:*"]</code></pre>
<p>
The list of allowed hosts must be configured on any nodes that will coordinate the reindex.
This feature should work with remote clusters of any version of Elasticsearch.
This should enable you to upgrade from any version of Elasticsearch to the current version by reindexing from a cluster of the old version.
</p>
<p>
WARNING: Elasticsearch does not support forward compatibility across major versions.
For example, you cannot reindex from a 7.x cluster into a 6.x cluster.
</p>
<p>
To enable queries sent to older versions of Elasticsearch, the <code>query</code> parameter is sent directly to the remote host without validation or modification.
</p>
<p>
NOTE: Reindexing from remote clusters does not support manual or automatic slicing.
</p>
<p>
Reindexing from a remote server uses an on-heap buffer that defaults to a maximum size of 100mb.
If the remote index includes very large documents you'll need to use a smaller batch size.
It is also possible to set the socket read timeout on the remote connection with the <code>socket_timeout</code> field and the connection timeout with the <code>connect_timeout</code> field.
Both default to 30 seconds.
</p>
<p>
<strong>Configuring SSL parameters</strong>
</p>
<p>
Reindex from remote supports configurable SSL settings.
These must be specified in the <code>elasticsearch.yml</code> file, with the exception of the secure settings, which you add in the Elasticsearch keystore.
It is not possible to configure SSL in the body of the reindex request.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-reindex.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;ReindexResponse&gt; ReindexAsync&lt;TDocument&gt;(ReindexRequestDescriptor&lt;TDocument&gt; descriptor, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.ReindexRequestDescriptor-1.html">ReindexRequestDescriptor</a>&lt;TDocument&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ReindexResponse.html">ReindexResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ReindexAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ReindexAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ReindexAsync__1_System_Action_Elastic_Clients_Elasticsearch_ReindexRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ReindexAsync``1(System.Action{Elastic.Clients.Elasticsearch.ReindexRequestDescriptor{``0}},System.Threading.CancellationToken)">
  ReindexAsync&lt;TDocument&gt;(Action&lt;ReindexRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L29439"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Reindex documents.
</p>
<p>
Copy documents from a source to a destination.
You can copy all documents to the destination index or reindex a subset of the documents.
The source can be any existing index, alias, or data stream.
The destination must differ from the source.
For example, you cannot reindex a data stream into itself.
</p>
<p>
IMPORTANT: Reindex requires <code>_source</code> to be enabled for all documents in the source.
The destination should be configured as wanted before calling the reindex API.
Reindex does not copy the settings from the source or its associated template.
Mappings, shard counts, and replicas, for example, must be configured ahead of time.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following security privileges:
</p>
<ul><li>
<p>
The <code>read</code> index privilege for the source data stream, index, or alias.
</p>
</li><li>
<p>
The <code>write</code> index privilege for the destination data stream, index, or index alias.
</p>
</li><li>
<p>
To automatically create a data stream or index with a reindex API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege for the destination data stream, index, or alias.
</p>
</li><li>
<p>
If reindexing from a remote cluster, the <code>source.remote.user</code> must have the <code>monitor</code> cluster privilege and the <code>read</code> index privilege for the source data stream, index, or alias.
</p>
</li></ul>
<p>
If reindexing from a remote cluster, you must explicitly allow the remote host in the <code>reindex.remote.whitelist</code> setting.
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
The <code>dest</code> element can be configured like the index API to control optimistic concurrency control.
Omitting <code>version_type</code> or setting it to <code>internal</code> causes Elasticsearch to blindly dump documents into the destination, overwriting any that happen to have the same ID.
</p>
<p>
Setting <code>version_type</code> to <code>external</code> causes Elasticsearch to preserve the <code>version</code> from the source, create any documents that are missing, and update any documents that have an older version in the destination than they do in the source.
</p>
<p>
Setting <code>op_type</code> to <code>create</code> causes the reindex API to create only missing documents in the destination.
All existing documents will cause a version conflict.
</p>
<p>
IMPORTANT: Because data streams are append-only, any reindex request to a destination data stream must have an <code>op_type</code> of <code>create</code>.
A reindex can only add new documents to a destination data stream.
It cannot update existing documents in a destination data stream.
</p>
<p>
By default, version conflicts abort the reindex process.
To continue reindexing if there are conflicts, set the <code>conflicts</code> request body property to <code>proceed</code>.
In this case, the response includes a count of the version conflicts that were encountered.
Note that the handling of other error types is unaffected by the <code>conflicts</code> property.
Additionally, if you opt to count version conflicts, the operation could attempt to reindex more documents from the source than <code>max_docs</code> until it has successfully indexed <code>max_docs</code> documents into the target or it has gone through every document in the source query.
</p>
<p>
NOTE: The reindex API makes no effort to handle ID collisions.
The last document written will "win" but the order isn't usually predictable so it is not a good idea to rely on this behavior.
Instead, make sure that IDs are unique by using a script.
</p>
<p>
<strong>Running reindex asynchronously</strong>
</p>
<p>
If the request contains <code>wait_for_completion=false</code>, Elasticsearch performs some preflight checks, launches the request, and returns a task you can use to cancel or get the status of the task.
Elasticsearch creates a record of this task as a document at <code>_tasks/&lt;task_id&gt;</code>.
</p>
<p>
<strong>Reindex from multiple sources</strong>
</p>
<p>
If you have many sources to reindex it is generally better to reindex them one at a time rather than using a glob pattern to pick up multiple sources.
That way you can resume the process if there are any errors by removing the partially completed source and starting over.
It also makes parallelizing the process fairly simple: split the list of sources to reindex and run each list in parallel.
</p>
<p>
For example, you can use a bash script like this:
</p>
<pre><code class="lang-csharp">for index in i1 i2 i3 i4 i5; do
  curl -HContent-Type:application/json -XPOST localhost:9200/_reindex?pretty -d'{
    "source": {
      "index": "'$index'"
    },
    "dest": {
      "index": "'$index'-reindexed"
    }
  }'
done</code></pre>
<p>
<strong>Throttling</strong>
</p>
<p>
Set <code>requests_per_second</code> to any positive decimal number (<code>1.4</code>, <code>6</code>, <code>1000</code>, for example) to throttle the rate at which reindex issues batches of index operations.
Requests are throttled by padding each batch with a wait time.
To turn off throttling, set <code>requests_per_second</code> to <code>-1</code>.
</p>
<p>
The throttling is done by waiting between batches so that the scroll that reindex uses internally can be given a timeout that takes into account the padding.
The padding time is the difference between the batch size divided by the <code>requests_per_second</code> and the time spent writing.
By default the batch size is <code>1000</code>, so if <code>requests_per_second</code> is set to <code>500</code>:
</p>
<pre><code class="lang-csharp">target_time = 1000 / 500 per second = 2 seconds
wait_time = target_time - write_time = 2 seconds - .5 seconds = 1.5 seconds</code></pre>
<p>
Since the batch is issued as a single bulk request, large batch sizes cause Elasticsearch to create many requests and then wait for a while before starting the next set.
This is "bursty" instead of "smooth".
</p>
<p>
<strong>Slicing</strong>
</p>
<p>
Reindex supports sliced scroll to parallelize the reindexing process.
This parallelization can improve efficiency and provide a convenient way to break the request down into smaller parts.
</p>
<p>
NOTE: Reindexing from remote clusters does not support manual or automatic slicing.
</p>
<p>
You can slice a reindex request manually by providing a slice ID and total number of slices to each request.
You can also let reindex automatically parallelize by using sliced scroll to slice on <code>_id</code>.
The <code>slices</code> parameter specifies the number of slices to use.
</p>
<p>
Adding <code>slices</code> to the reindex request just automates the manual process, creating sub-requests which means it has some quirks:
</p>
<ul><li>
<p>
You can see these requests in the tasks API. These sub-requests are "child" tasks of the task for the request with slices.
</p>
</li><li>
<p>
Fetching the status of the task for the request with <code>slices</code> only contains the status of completed slices.
</p>
</li><li>
<p>
These sub-requests are individually addressable for things like cancellation and rethrottling.
</p>
</li><li>
<p>
Rethrottling the request with <code>slices</code> will rethrottle the unfinished sub-request proportionally.
</p>
</li><li>
<p>
Canceling the request with <code>slices</code> will cancel each sub-request.
</p>
</li><li>
<p>
Due to the nature of <code>slices</code>, each sub-request won't get a perfectly even portion of the documents. All documents will be addressed, but some slices may be larger than others. Expect larger slices to have a more even distribution.
</p>
</li><li>
<p>
Parameters like <code>requests_per_second</code> and <code>max_docs</code> on a request with <code>slices</code> are distributed proportionally to each sub-request. Combine that with the previous point about distribution being uneven and you should conclude that using <code>max_docs</code> with <code>slices</code> might not result in exactly <code>max_docs</code> documents being reindexed.
</p>
</li><li>
<p>
Each sub-request gets a slightly different snapshot of the source, though these are all taken at approximately the same time.
</p>
</li></ul>
<p>
If slicing automatically, setting <code>slices</code> to <code>auto</code> will choose a reasonable number for most indices.
If slicing manually or otherwise tuning automatic slicing, use the following guidelines.
</p>
<p>
Query performance is most efficient when the number of slices is equal to the number of shards in the index.
If that number is large (for example, <code>500</code>), choose a lower number as too many slices will hurt performance.
Setting slices higher than the number of shards generally does not improve efficiency and adds overhead.
</p>
<p>
Indexing performance scales linearly across available resources with the number of slices.
</p>
<p>
Whether query or indexing performance dominates the runtime depends on the documents being reindexed and cluster resources.
</p>
<p>
<strong>Modify documents during reindexing</strong>
</p>
<p>
Like <code>_update_by_query</code>, reindex operations support a script that modifies the document.
Unlike <code>_update_by_query</code>, the script is allowed to modify the document's metadata.
</p>
<p>
Just as in <code>_update_by_query</code>, you can set <code>ctx.op</code> to change the operation that is run on the destination.
For example, set <code>ctx.op</code> to <code>noop</code> if your script decides that the document doesn’t have to be indexed in the destination. This "no operation" will be reported in the <code>noop</code> counter in the response body.
Set <code>ctx.op</code> to <code>delete</code> if your script decides that the document must be deleted from the destination.
The deletion will be reported in the <code>deleted</code> counter in the response body.
Setting <code>ctx.op</code> to anything else will return an error, as will setting any other field in <code>ctx</code>.
</p>
<p>
Think of the possibilities! Just be careful; you are able to change:
</p>
<ul><li>
<p>
<code>_id</code>
</p>
</li><li>
<p>
<code>_index</code>
</p>
</li><li>
<p>
<code>_version</code>
</p>
</li><li>
<p>
<code>_routing</code>
</p>
</li></ul>
<p>
Setting <code>_version</code> to <code>null</code> or clearing it from the <code>ctx</code> map is just like not sending the version in an indexing request.
It will cause the document to be overwritten in the destination regardless of the version on the target or the version type you use in the reindex API.
</p>
<p>
<strong>Reindex from remote</strong>
</p>
<p>
Reindex supports reindexing from a remote Elasticsearch cluster.
The <code>host</code> parameter must contain a scheme, host, port, and optional path.
The <code>username</code> and <code>password</code> parameters are optional and when they are present the reindex operation will connect to the remote Elasticsearch node using basic authentication.
Be sure to use HTTPS when using basic authentication or the password will be sent in plain text.
There are a range of settings available to configure the behavior of the HTTPS connection.
</p>
<p>
When using Elastic Cloud, it is also possible to authenticate against the remote cluster through the use of a valid API key.
Remote hosts must be explicitly allowed with the <code>reindex.remote.whitelist</code> setting.
It can be set to a comma delimited list of allowed remote host and port combinations.
Scheme is ignored; only the host and port are used.
For example:
</p>
<pre><code class="lang-csharp">reindex.remote.whitelist: [otherhost:9200, another:9200, 127.0.10.*:9200, localhost:*"]</code></pre>
<p>
The list of allowed hosts must be configured on any nodes that will coordinate the reindex.
This feature should work with remote clusters of any version of Elasticsearch.
This should enable you to upgrade from any version of Elasticsearch to the current version by reindexing from a cluster of the old version.
</p>
<p>
WARNING: Elasticsearch does not support forward compatibility across major versions.
For example, you cannot reindex from a 7.x cluster into a 6.x cluster.
</p>
<p>
To enable queries sent to older versions of Elasticsearch, the <code>query</code> parameter is sent directly to the remote host without validation or modification.
</p>
<p>
NOTE: Reindexing from remote clusters does not support manual or automatic slicing.
</p>
<p>
Reindexing from a remote server uses an on-heap buffer that defaults to a maximum size of 100mb.
If the remote index includes very large documents you'll need to use a smaller batch size.
It is also possible to set the socket read timeout on the remote connection with the <code>socket_timeout</code> field and the connection timeout with the <code>connect_timeout</code> field.
Both default to 30 seconds.
</p>
<p>
<strong>Configuring SSL parameters</strong>
</p>
<p>
Reindex from remote supports configurable SSL settings.
These must be specified in the <code>elasticsearch.yml</code> file, with the exception of the secure settings, which you add in the Elasticsearch keystore.
It is not possible to configure SSL in the body of the reindex request.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-reindex.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;ReindexResponse&gt; ReindexAsync&lt;TDocument&gt;(Action&lt;ReindexRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ReindexRequestDescriptor-1.html">ReindexRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ReindexResponse.html">ReindexResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ReindexAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ReindexAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ReindexAsync__1_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ReindexAsync``1(System.Threading.CancellationToken)">
  ReindexAsync&lt;TDocument&gt;(CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L29138"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Reindex documents.
</p>
<p>
Copy documents from a source to a destination.
You can copy all documents to the destination index or reindex a subset of the documents.
The source can be any existing index, alias, or data stream.
The destination must differ from the source.
For example, you cannot reindex a data stream into itself.
</p>
<p>
IMPORTANT: Reindex requires <code>_source</code> to be enabled for all documents in the source.
The destination should be configured as wanted before calling the reindex API.
Reindex does not copy the settings from the source or its associated template.
Mappings, shard counts, and replicas, for example, must be configured ahead of time.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following security privileges:
</p>
<ul><li>
<p>
The <code>read</code> index privilege for the source data stream, index, or alias.
</p>
</li><li>
<p>
The <code>write</code> index privilege for the destination data stream, index, or index alias.
</p>
</li><li>
<p>
To automatically create a data stream or index with a reindex API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege for the destination data stream, index, or alias.
</p>
</li><li>
<p>
If reindexing from a remote cluster, the <code>source.remote.user</code> must have the <code>monitor</code> cluster privilege and the <code>read</code> index privilege for the source data stream, index, or alias.
</p>
</li></ul>
<p>
If reindexing from a remote cluster, you must explicitly allow the remote host in the <code>reindex.remote.whitelist</code> setting.
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
The <code>dest</code> element can be configured like the index API to control optimistic concurrency control.
Omitting <code>version_type</code> or setting it to <code>internal</code> causes Elasticsearch to blindly dump documents into the destination, overwriting any that happen to have the same ID.
</p>
<p>
Setting <code>version_type</code> to <code>external</code> causes Elasticsearch to preserve the <code>version</code> from the source, create any documents that are missing, and update any documents that have an older version in the destination than they do in the source.
</p>
<p>
Setting <code>op_type</code> to <code>create</code> causes the reindex API to create only missing documents in the destination.
All existing documents will cause a version conflict.
</p>
<p>
IMPORTANT: Because data streams are append-only, any reindex request to a destination data stream must have an <code>op_type</code> of <code>create</code>.
A reindex can only add new documents to a destination data stream.
It cannot update existing documents in a destination data stream.
</p>
<p>
By default, version conflicts abort the reindex process.
To continue reindexing if there are conflicts, set the <code>conflicts</code> request body property to <code>proceed</code>.
In this case, the response includes a count of the version conflicts that were encountered.
Note that the handling of other error types is unaffected by the <code>conflicts</code> property.
Additionally, if you opt to count version conflicts, the operation could attempt to reindex more documents from the source than <code>max_docs</code> until it has successfully indexed <code>max_docs</code> documents into the target or it has gone through every document in the source query.
</p>
<p>
NOTE: The reindex API makes no effort to handle ID collisions.
The last document written will "win" but the order isn't usually predictable so it is not a good idea to rely on this behavior.
Instead, make sure that IDs are unique by using a script.
</p>
<p>
<strong>Running reindex asynchronously</strong>
</p>
<p>
If the request contains <code>wait_for_completion=false</code>, Elasticsearch performs some preflight checks, launches the request, and returns a task you can use to cancel or get the status of the task.
Elasticsearch creates a record of this task as a document at <code>_tasks/&lt;task_id&gt;</code>.
</p>
<p>
<strong>Reindex from multiple sources</strong>
</p>
<p>
If you have many sources to reindex it is generally better to reindex them one at a time rather than using a glob pattern to pick up multiple sources.
That way you can resume the process if there are any errors by removing the partially completed source and starting over.
It also makes parallelizing the process fairly simple: split the list of sources to reindex and run each list in parallel.
</p>
<p>
For example, you can use a bash script like this:
</p>
<pre><code class="lang-csharp">for index in i1 i2 i3 i4 i5; do
  curl -HContent-Type:application/json -XPOST localhost:9200/_reindex?pretty -d'{
    "source": {
      "index": "'$index'"
    },
    "dest": {
      "index": "'$index'-reindexed"
    }
  }'
done</code></pre>
<p>
<strong>Throttling</strong>
</p>
<p>
Set <code>requests_per_second</code> to any positive decimal number (<code>1.4</code>, <code>6</code>, <code>1000</code>, for example) to throttle the rate at which reindex issues batches of index operations.
Requests are throttled by padding each batch with a wait time.
To turn off throttling, set <code>requests_per_second</code> to <code>-1</code>.
</p>
<p>
The throttling is done by waiting between batches so that the scroll that reindex uses internally can be given a timeout that takes into account the padding.
The padding time is the difference between the batch size divided by the <code>requests_per_second</code> and the time spent writing.
By default the batch size is <code>1000</code>, so if <code>requests_per_second</code> is set to <code>500</code>:
</p>
<pre><code class="lang-csharp">target_time = 1000 / 500 per second = 2 seconds
wait_time = target_time - write_time = 2 seconds - .5 seconds = 1.5 seconds</code></pre>
<p>
Since the batch is issued as a single bulk request, large batch sizes cause Elasticsearch to create many requests and then wait for a while before starting the next set.
This is "bursty" instead of "smooth".
</p>
<p>
<strong>Slicing</strong>
</p>
<p>
Reindex supports sliced scroll to parallelize the reindexing process.
This parallelization can improve efficiency and provide a convenient way to break the request down into smaller parts.
</p>
<p>
NOTE: Reindexing from remote clusters does not support manual or automatic slicing.
</p>
<p>
You can slice a reindex request manually by providing a slice ID and total number of slices to each request.
You can also let reindex automatically parallelize by using sliced scroll to slice on <code>_id</code>.
The <code>slices</code> parameter specifies the number of slices to use.
</p>
<p>
Adding <code>slices</code> to the reindex request just automates the manual process, creating sub-requests which means it has some quirks:
</p>
<ul><li>
<p>
You can see these requests in the tasks API. These sub-requests are "child" tasks of the task for the request with slices.
</p>
</li><li>
<p>
Fetching the status of the task for the request with <code>slices</code> only contains the status of completed slices.
</p>
</li><li>
<p>
These sub-requests are individually addressable for things like cancellation and rethrottling.
</p>
</li><li>
<p>
Rethrottling the request with <code>slices</code> will rethrottle the unfinished sub-request proportionally.
</p>
</li><li>
<p>
Canceling the request with <code>slices</code> will cancel each sub-request.
</p>
</li><li>
<p>
Due to the nature of <code>slices</code>, each sub-request won't get a perfectly even portion of the documents. All documents will be addressed, but some slices may be larger than others. Expect larger slices to have a more even distribution.
</p>
</li><li>
<p>
Parameters like <code>requests_per_second</code> and <code>max_docs</code> on a request with <code>slices</code> are distributed proportionally to each sub-request. Combine that with the previous point about distribution being uneven and you should conclude that using <code>max_docs</code> with <code>slices</code> might not result in exactly <code>max_docs</code> documents being reindexed.
</p>
</li><li>
<p>
Each sub-request gets a slightly different snapshot of the source, though these are all taken at approximately the same time.
</p>
</li></ul>
<p>
If slicing automatically, setting <code>slices</code> to <code>auto</code> will choose a reasonable number for most indices.
If slicing manually or otherwise tuning automatic slicing, use the following guidelines.
</p>
<p>
Query performance is most efficient when the number of slices is equal to the number of shards in the index.
If that number is large (for example, <code>500</code>), choose a lower number as too many slices will hurt performance.
Setting slices higher than the number of shards generally does not improve efficiency and adds overhead.
</p>
<p>
Indexing performance scales linearly across available resources with the number of slices.
</p>
<p>
Whether query or indexing performance dominates the runtime depends on the documents being reindexed and cluster resources.
</p>
<p>
<strong>Modify documents during reindexing</strong>
</p>
<p>
Like <code>_update_by_query</code>, reindex operations support a script that modifies the document.
Unlike <code>_update_by_query</code>, the script is allowed to modify the document's metadata.
</p>
<p>
Just as in <code>_update_by_query</code>, you can set <code>ctx.op</code> to change the operation that is run on the destination.
For example, set <code>ctx.op</code> to <code>noop</code> if your script decides that the document doesn’t have to be indexed in the destination. This "no operation" will be reported in the <code>noop</code> counter in the response body.
Set <code>ctx.op</code> to <code>delete</code> if your script decides that the document must be deleted from the destination.
The deletion will be reported in the <code>deleted</code> counter in the response body.
Setting <code>ctx.op</code> to anything else will return an error, as will setting any other field in <code>ctx</code>.
</p>
<p>
Think of the possibilities! Just be careful; you are able to change:
</p>
<ul><li>
<p>
<code>_id</code>
</p>
</li><li>
<p>
<code>_index</code>
</p>
</li><li>
<p>
<code>_version</code>
</p>
</li><li>
<p>
<code>_routing</code>
</p>
</li></ul>
<p>
Setting <code>_version</code> to <code>null</code> or clearing it from the <code>ctx</code> map is just like not sending the version in an indexing request.
It will cause the document to be overwritten in the destination regardless of the version on the target or the version type you use in the reindex API.
</p>
<p>
<strong>Reindex from remote</strong>
</p>
<p>
Reindex supports reindexing from a remote Elasticsearch cluster.
The <code>host</code> parameter must contain a scheme, host, port, and optional path.
The <code>username</code> and <code>password</code> parameters are optional and when they are present the reindex operation will connect to the remote Elasticsearch node using basic authentication.
Be sure to use HTTPS when using basic authentication or the password will be sent in plain text.
There are a range of settings available to configure the behavior of the HTTPS connection.
</p>
<p>
When using Elastic Cloud, it is also possible to authenticate against the remote cluster through the use of a valid API key.
Remote hosts must be explicitly allowed with the <code>reindex.remote.whitelist</code> setting.
It can be set to a comma delimited list of allowed remote host and port combinations.
Scheme is ignored; only the host and port are used.
For example:
</p>
<pre><code class="lang-csharp">reindex.remote.whitelist: [otherhost:9200, another:9200, 127.0.10.*:9200, localhost:*"]</code></pre>
<p>
The list of allowed hosts must be configured on any nodes that will coordinate the reindex.
This feature should work with remote clusters of any version of Elasticsearch.
This should enable you to upgrade from any version of Elasticsearch to the current version by reindexing from a cluster of the old version.
</p>
<p>
WARNING: Elasticsearch does not support forward compatibility across major versions.
For example, you cannot reindex from a 7.x cluster into a 6.x cluster.
</p>
<p>
To enable queries sent to older versions of Elasticsearch, the <code>query</code> parameter is sent directly to the remote host without validation or modification.
</p>
<p>
NOTE: Reindexing from remote clusters does not support manual or automatic slicing.
</p>
<p>
Reindexing from a remote server uses an on-heap buffer that defaults to a maximum size of 100mb.
If the remote index includes very large documents you'll need to use a smaller batch size.
It is also possible to set the socket read timeout on the remote connection with the <code>socket_timeout</code> field and the connection timeout with the <code>connect_timeout</code> field.
Both default to 30 seconds.
</p>
<p>
<strong>Configuring SSL parameters</strong>
</p>
<p>
Reindex from remote supports configurable SSL settings.
These must be specified in the <code>elasticsearch.yml</code> file, with the exception of the secure settings, which you add in the Elasticsearch keystore.
It is not possible to configure SSL in the body of the reindex request.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-reindex.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;ReindexResponse&gt; ReindexAsync&lt;TDocument&gt;(CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ReindexResponse.html">ReindexResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ReindexRethrottle_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ReindexRethrottle*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ReindexRethrottle_Elastic_Clients_Elasticsearch_Id_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ReindexRethrottle(Elastic.Clients.Elasticsearch.Id)">
  ReindexRethrottle(Id)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L30442"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Throttle a reindex operation.
</p>
<p>
Change the number of requests per second for a particular reindex operation.
For example:
</p>
<pre><code class="lang-csharp">POST _reindex/r1A2WoRbTwKZ516z6NEs5A:36619/_rethrottle?requests_per_second=-1</code></pre>
<p>
Rethrottling that speeds up the query takes effect immediately.
Rethrottling that slows down the query will take effect after completing the current batch.
This behavior prevents scroll timeouts.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-reindex.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual ReindexRethrottleResponse ReindexRethrottle(Id taskId)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>taskId</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ReindexRethrottleResponse.html">ReindexRethrottleResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ReindexRethrottle_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ReindexRethrottle*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ReindexRethrottle_Elastic_Clients_Elasticsearch_Id_System_Action_Elastic_Clients_Elasticsearch_ReindexRethrottleRequestDescriptor__" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ReindexRethrottle(Elastic.Clients.Elasticsearch.Id,System.Action{Elastic.Clients.Elasticsearch.ReindexRethrottleRequestDescriptor})">
  ReindexRethrottle(Id, Action&lt;ReindexRethrottleRequestDescriptor&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L30468"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Throttle a reindex operation.
</p>
<p>
Change the number of requests per second for a particular reindex operation.
For example:
</p>
<pre><code class="lang-csharp">POST _reindex/r1A2WoRbTwKZ516z6NEs5A:36619/_rethrottle?requests_per_second=-1</code></pre>
<p>
Rethrottling that speeds up the query takes effect immediately.
Rethrottling that slows down the query will take effect after completing the current batch.
This behavior prevents scroll timeouts.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-reindex.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual ReindexRethrottleResponse ReindexRethrottle(Id taskId, Action&lt;ReindexRethrottleRequestDescriptor&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>taskId</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ReindexRethrottleRequestDescriptor.html">ReindexRethrottleRequestDescriptor</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ReindexRethrottleResponse.html">ReindexRethrottleResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ReindexRethrottle_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ReindexRethrottle*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ReindexRethrottle_Elastic_Clients_Elasticsearch_ReindexRethrottleRequest_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ReindexRethrottle(Elastic.Clients.Elasticsearch.ReindexRethrottleRequest)">
  ReindexRethrottle(ReindexRethrottleRequest)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L30368"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Throttle a reindex operation.
</p>
<p>
Change the number of requests per second for a particular reindex operation.
For example:
</p>
<pre><code class="lang-csharp">POST _reindex/r1A2WoRbTwKZ516z6NEs5A:36619/_rethrottle?requests_per_second=-1</code></pre>
<p>
Rethrottling that speeds up the query takes effect immediately.
Rethrottling that slows down the query will take effect after completing the current batch.
This behavior prevents scroll timeouts.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-reindex.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual ReindexRethrottleResponse ReindexRethrottle(ReindexRethrottleRequest request)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.ReindexRethrottleRequest.html">ReindexRethrottleRequest</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ReindexRethrottleResponse.html">ReindexRethrottleResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ReindexRethrottle_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ReindexRethrottle*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ReindexRethrottle_Elastic_Clients_Elasticsearch_ReindexRethrottleRequestDescriptor_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ReindexRethrottle(Elastic.Clients.Elasticsearch.ReindexRethrottleRequestDescriptor)">
  ReindexRethrottle(ReindexRethrottleRequestDescriptor)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L30417"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Throttle a reindex operation.
</p>
<p>
Change the number of requests per second for a particular reindex operation.
For example:
</p>
<pre><code class="lang-csharp">POST _reindex/r1A2WoRbTwKZ516z6NEs5A:36619/_rethrottle?requests_per_second=-1</code></pre>
<p>
Rethrottling that speeds up the query takes effect immediately.
Rethrottling that slows down the query will take effect after completing the current batch.
This behavior prevents scroll timeouts.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-reindex.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual ReindexRethrottleResponse ReindexRethrottle(ReindexRethrottleRequestDescriptor descriptor)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.ReindexRethrottleRequestDescriptor.html">ReindexRethrottleRequestDescriptor</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ReindexRethrottleResponse.html">ReindexRethrottleResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ReindexRethrottleAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ReindexRethrottleAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ReindexRethrottleAsync_Elastic_Clients_Elasticsearch_Id_System_Action_Elastic_Clients_Elasticsearch_ReindexRethrottleRequestDescriptor__System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ReindexRethrottleAsync(Elastic.Clients.Elasticsearch.Id,System.Action{Elastic.Clients.Elasticsearch.ReindexRethrottleRequestDescriptor},System.Threading.CancellationToken)">
  ReindexRethrottleAsync(Id, Action&lt;ReindexRethrottleRequestDescriptor&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L30544"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Throttle a reindex operation.
</p>
<p>
Change the number of requests per second for a particular reindex operation.
For example:
</p>
<pre><code class="lang-csharp">POST _reindex/r1A2WoRbTwKZ516z6NEs5A:36619/_rethrottle?requests_per_second=-1</code></pre>
<p>
Rethrottling that speeds up the query takes effect immediately.
Rethrottling that slows down the query will take effect after completing the current batch.
This behavior prevents scroll timeouts.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-reindex.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;ReindexRethrottleResponse&gt; ReindexRethrottleAsync(Id taskId, Action&lt;ReindexRethrottleRequestDescriptor&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>taskId</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ReindexRethrottleRequestDescriptor.html">ReindexRethrottleRequestDescriptor</a>&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ReindexRethrottleResponse.html">ReindexRethrottleResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ReindexRethrottleAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ReindexRethrottleAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ReindexRethrottleAsync_Elastic_Clients_Elasticsearch_Id_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ReindexRethrottleAsync(Elastic.Clients.Elasticsearch.Id,System.Threading.CancellationToken)">
  ReindexRethrottleAsync(Id, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L30519"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Throttle a reindex operation.
</p>
<p>
Change the number of requests per second for a particular reindex operation.
For example:
</p>
<pre><code class="lang-csharp">POST _reindex/r1A2WoRbTwKZ516z6NEs5A:36619/_rethrottle?requests_per_second=-1</code></pre>
<p>
Rethrottling that speeds up the query takes effect immediately.
Rethrottling that slows down the query will take effect after completing the current batch.
This behavior prevents scroll timeouts.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-reindex.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;ReindexRethrottleResponse&gt; ReindexRethrottleAsync(Id taskId, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>taskId</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ReindexRethrottleResponse.html">ReindexRethrottleResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ReindexRethrottleAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ReindexRethrottleAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ReindexRethrottleAsync_Elastic_Clients_Elasticsearch_ReindexRethrottleRequest_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ReindexRethrottleAsync(Elastic.Clients.Elasticsearch.ReindexRethrottleRequest,System.Threading.CancellationToken)">
  ReindexRethrottleAsync(ReindexRethrottleRequest, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L30393"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Throttle a reindex operation.
</p>
<p>
Change the number of requests per second for a particular reindex operation.
For example:
</p>
<pre><code class="lang-csharp">POST _reindex/r1A2WoRbTwKZ516z6NEs5A:36619/_rethrottle?requests_per_second=-1</code></pre>
<p>
Rethrottling that speeds up the query takes effect immediately.
Rethrottling that slows down the query will take effect after completing the current batch.
This behavior prevents scroll timeouts.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-reindex.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;ReindexRethrottleResponse&gt; ReindexRethrottleAsync(ReindexRethrottleRequest request, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.ReindexRethrottleRequest.html">ReindexRethrottleRequest</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ReindexRethrottleResponse.html">ReindexRethrottleResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ReindexRethrottleAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ReindexRethrottleAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ReindexRethrottleAsync_Elastic_Clients_Elasticsearch_ReindexRethrottleRequestDescriptor_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ReindexRethrottleAsync(Elastic.Clients.Elasticsearch.ReindexRethrottleRequestDescriptor,System.Threading.CancellationToken)">
  ReindexRethrottleAsync(ReindexRethrottleRequestDescriptor, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L30495"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Throttle a reindex operation.
</p>
<p>
Change the number of requests per second for a particular reindex operation.
For example:
</p>
<pre><code class="lang-csharp">POST _reindex/r1A2WoRbTwKZ516z6NEs5A:36619/_rethrottle?requests_per_second=-1</code></pre>
<p>
Rethrottling that speeds up the query takes effect immediately.
Rethrottling that slows down the query will take effect after completing the current batch.
This behavior prevents scroll timeouts.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-reindex.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;ReindexRethrottleResponse&gt; ReindexRethrottleAsync(ReindexRethrottleRequestDescriptor descriptor, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.ReindexRethrottleRequestDescriptor.html">ReindexRethrottleRequestDescriptor</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ReindexRethrottleResponse.html">ReindexRethrottleResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Reindex_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Reindex*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Reindex__1" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Reindex``1">
  Reindex&lt;TDocument&gt;()
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L27327"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Reindex documents.
</p>
<p>
Copy documents from a source to a destination.
You can copy all documents to the destination index or reindex a subset of the documents.
The source can be any existing index, alias, or data stream.
The destination must differ from the source.
For example, you cannot reindex a data stream into itself.
</p>
<p>
IMPORTANT: Reindex requires <code>_source</code> to be enabled for all documents in the source.
The destination should be configured as wanted before calling the reindex API.
Reindex does not copy the settings from the source or its associated template.
Mappings, shard counts, and replicas, for example, must be configured ahead of time.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following security privileges:
</p>
<ul><li>
<p>
The <code>read</code> index privilege for the source data stream, index, or alias.
</p>
</li><li>
<p>
The <code>write</code> index privilege for the destination data stream, index, or index alias.
</p>
</li><li>
<p>
To automatically create a data stream or index with a reindex API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege for the destination data stream, index, or alias.
</p>
</li><li>
<p>
If reindexing from a remote cluster, the <code>source.remote.user</code> must have the <code>monitor</code> cluster privilege and the <code>read</code> index privilege for the source data stream, index, or alias.
</p>
</li></ul>
<p>
If reindexing from a remote cluster, you must explicitly allow the remote host in the <code>reindex.remote.whitelist</code> setting.
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
The <code>dest</code> element can be configured like the index API to control optimistic concurrency control.
Omitting <code>version_type</code> or setting it to <code>internal</code> causes Elasticsearch to blindly dump documents into the destination, overwriting any that happen to have the same ID.
</p>
<p>
Setting <code>version_type</code> to <code>external</code> causes Elasticsearch to preserve the <code>version</code> from the source, create any documents that are missing, and update any documents that have an older version in the destination than they do in the source.
</p>
<p>
Setting <code>op_type</code> to <code>create</code> causes the reindex API to create only missing documents in the destination.
All existing documents will cause a version conflict.
</p>
<p>
IMPORTANT: Because data streams are append-only, any reindex request to a destination data stream must have an <code>op_type</code> of <code>create</code>.
A reindex can only add new documents to a destination data stream.
It cannot update existing documents in a destination data stream.
</p>
<p>
By default, version conflicts abort the reindex process.
To continue reindexing if there are conflicts, set the <code>conflicts</code> request body property to <code>proceed</code>.
In this case, the response includes a count of the version conflicts that were encountered.
Note that the handling of other error types is unaffected by the <code>conflicts</code> property.
Additionally, if you opt to count version conflicts, the operation could attempt to reindex more documents from the source than <code>max_docs</code> until it has successfully indexed <code>max_docs</code> documents into the target or it has gone through every document in the source query.
</p>
<p>
NOTE: The reindex API makes no effort to handle ID collisions.
The last document written will "win" but the order isn't usually predictable so it is not a good idea to rely on this behavior.
Instead, make sure that IDs are unique by using a script.
</p>
<p>
<strong>Running reindex asynchronously</strong>
</p>
<p>
If the request contains <code>wait_for_completion=false</code>, Elasticsearch performs some preflight checks, launches the request, and returns a task you can use to cancel or get the status of the task.
Elasticsearch creates a record of this task as a document at <code>_tasks/&lt;task_id&gt;</code>.
</p>
<p>
<strong>Reindex from multiple sources</strong>
</p>
<p>
If you have many sources to reindex it is generally better to reindex them one at a time rather than using a glob pattern to pick up multiple sources.
That way you can resume the process if there are any errors by removing the partially completed source and starting over.
It also makes parallelizing the process fairly simple: split the list of sources to reindex and run each list in parallel.
</p>
<p>
For example, you can use a bash script like this:
</p>
<pre><code class="lang-csharp">for index in i1 i2 i3 i4 i5; do
  curl -HContent-Type:application/json -XPOST localhost:9200/_reindex?pretty -d'{
    "source": {
      "index": "'$index'"
    },
    "dest": {
      "index": "'$index'-reindexed"
    }
  }'
done</code></pre>
<p>
<strong>Throttling</strong>
</p>
<p>
Set <code>requests_per_second</code> to any positive decimal number (<code>1.4</code>, <code>6</code>, <code>1000</code>, for example) to throttle the rate at which reindex issues batches of index operations.
Requests are throttled by padding each batch with a wait time.
To turn off throttling, set <code>requests_per_second</code> to <code>-1</code>.
</p>
<p>
The throttling is done by waiting between batches so that the scroll that reindex uses internally can be given a timeout that takes into account the padding.
The padding time is the difference between the batch size divided by the <code>requests_per_second</code> and the time spent writing.
By default the batch size is <code>1000</code>, so if <code>requests_per_second</code> is set to <code>500</code>:
</p>
<pre><code class="lang-csharp">target_time = 1000 / 500 per second = 2 seconds
wait_time = target_time - write_time = 2 seconds - .5 seconds = 1.5 seconds</code></pre>
<p>
Since the batch is issued as a single bulk request, large batch sizes cause Elasticsearch to create many requests and then wait for a while before starting the next set.
This is "bursty" instead of "smooth".
</p>
<p>
<strong>Slicing</strong>
</p>
<p>
Reindex supports sliced scroll to parallelize the reindexing process.
This parallelization can improve efficiency and provide a convenient way to break the request down into smaller parts.
</p>
<p>
NOTE: Reindexing from remote clusters does not support manual or automatic slicing.
</p>
<p>
You can slice a reindex request manually by providing a slice ID and total number of slices to each request.
You can also let reindex automatically parallelize by using sliced scroll to slice on <code>_id</code>.
The <code>slices</code> parameter specifies the number of slices to use.
</p>
<p>
Adding <code>slices</code> to the reindex request just automates the manual process, creating sub-requests which means it has some quirks:
</p>
<ul><li>
<p>
You can see these requests in the tasks API. These sub-requests are "child" tasks of the task for the request with slices.
</p>
</li><li>
<p>
Fetching the status of the task for the request with <code>slices</code> only contains the status of completed slices.
</p>
</li><li>
<p>
These sub-requests are individually addressable for things like cancellation and rethrottling.
</p>
</li><li>
<p>
Rethrottling the request with <code>slices</code> will rethrottle the unfinished sub-request proportionally.
</p>
</li><li>
<p>
Canceling the request with <code>slices</code> will cancel each sub-request.
</p>
</li><li>
<p>
Due to the nature of <code>slices</code>, each sub-request won't get a perfectly even portion of the documents. All documents will be addressed, but some slices may be larger than others. Expect larger slices to have a more even distribution.
</p>
</li><li>
<p>
Parameters like <code>requests_per_second</code> and <code>max_docs</code> on a request with <code>slices</code> are distributed proportionally to each sub-request. Combine that with the previous point about distribution being uneven and you should conclude that using <code>max_docs</code> with <code>slices</code> might not result in exactly <code>max_docs</code> documents being reindexed.
</p>
</li><li>
<p>
Each sub-request gets a slightly different snapshot of the source, though these are all taken at approximately the same time.
</p>
</li></ul>
<p>
If slicing automatically, setting <code>slices</code> to <code>auto</code> will choose a reasonable number for most indices.
If slicing manually or otherwise tuning automatic slicing, use the following guidelines.
</p>
<p>
Query performance is most efficient when the number of slices is equal to the number of shards in the index.
If that number is large (for example, <code>500</code>), choose a lower number as too many slices will hurt performance.
Setting slices higher than the number of shards generally does not improve efficiency and adds overhead.
</p>
<p>
Indexing performance scales linearly across available resources with the number of slices.
</p>
<p>
Whether query or indexing performance dominates the runtime depends on the documents being reindexed and cluster resources.
</p>
<p>
<strong>Modify documents during reindexing</strong>
</p>
<p>
Like <code>_update_by_query</code>, reindex operations support a script that modifies the document.
Unlike <code>_update_by_query</code>, the script is allowed to modify the document's metadata.
</p>
<p>
Just as in <code>_update_by_query</code>, you can set <code>ctx.op</code> to change the operation that is run on the destination.
For example, set <code>ctx.op</code> to <code>noop</code> if your script decides that the document doesn’t have to be indexed in the destination. This "no operation" will be reported in the <code>noop</code> counter in the response body.
Set <code>ctx.op</code> to <code>delete</code> if your script decides that the document must be deleted from the destination.
The deletion will be reported in the <code>deleted</code> counter in the response body.
Setting <code>ctx.op</code> to anything else will return an error, as will setting any other field in <code>ctx</code>.
</p>
<p>
Think of the possibilities! Just be careful; you are able to change:
</p>
<ul><li>
<p>
<code>_id</code>
</p>
</li><li>
<p>
<code>_index</code>
</p>
</li><li>
<p>
<code>_version</code>
</p>
</li><li>
<p>
<code>_routing</code>
</p>
</li></ul>
<p>
Setting <code>_version</code> to <code>null</code> or clearing it from the <code>ctx</code> map is just like not sending the version in an indexing request.
It will cause the document to be overwritten in the destination regardless of the version on the target or the version type you use in the reindex API.
</p>
<p>
<strong>Reindex from remote</strong>
</p>
<p>
Reindex supports reindexing from a remote Elasticsearch cluster.
The <code>host</code> parameter must contain a scheme, host, port, and optional path.
The <code>username</code> and <code>password</code> parameters are optional and when they are present the reindex operation will connect to the remote Elasticsearch node using basic authentication.
Be sure to use HTTPS when using basic authentication or the password will be sent in plain text.
There are a range of settings available to configure the behavior of the HTTPS connection.
</p>
<p>
When using Elastic Cloud, it is also possible to authenticate against the remote cluster through the use of a valid API key.
Remote hosts must be explicitly allowed with the <code>reindex.remote.whitelist</code> setting.
It can be set to a comma delimited list of allowed remote host and port combinations.
Scheme is ignored; only the host and port are used.
For example:
</p>
<pre><code class="lang-csharp">reindex.remote.whitelist: [otherhost:9200, another:9200, 127.0.10.*:9200, localhost:*"]</code></pre>
<p>
The list of allowed hosts must be configured on any nodes that will coordinate the reindex.
This feature should work with remote clusters of any version of Elasticsearch.
This should enable you to upgrade from any version of Elasticsearch to the current version by reindexing from a cluster of the old version.
</p>
<p>
WARNING: Elasticsearch does not support forward compatibility across major versions.
For example, you cannot reindex from a 7.x cluster into a 6.x cluster.
</p>
<p>
To enable queries sent to older versions of Elasticsearch, the <code>query</code> parameter is sent directly to the remote host without validation or modification.
</p>
<p>
NOTE: Reindexing from remote clusters does not support manual or automatic slicing.
</p>
<p>
Reindexing from a remote server uses an on-heap buffer that defaults to a maximum size of 100mb.
If the remote index includes very large documents you'll need to use a smaller batch size.
It is also possible to set the socket read timeout on the remote connection with the <code>socket_timeout</code> field and the connection timeout with the <code>connect_timeout</code> field.
Both default to 30 seconds.
</p>
<p>
<strong>Configuring SSL parameters</strong>
</p>
<p>
Reindex from remote supports configurable SSL settings.
These must be specified in the <code>elasticsearch.yml</code> file, with the exception of the secure settings, which you add in the Elasticsearch keystore.
It is not possible to configure SSL in the body of the reindex request.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-reindex.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual ReindexResponse Reindex&lt;TDocument&gt;()</code></pre>
  </div>


  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ReindexResponse.html">ReindexResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Reindex_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Reindex*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Reindex__1_Elastic_Clients_Elasticsearch_ReindexRequestDescriptor___0__" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Reindex``1(Elastic.Clients.Elasticsearch.ReindexRequestDescriptor{``0})">
  Reindex&lt;TDocument&gt;(ReindexRequestDescriptor&lt;TDocument&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L27026"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Reindex documents.
</p>
<p>
Copy documents from a source to a destination.
You can copy all documents to the destination index or reindex a subset of the documents.
The source can be any existing index, alias, or data stream.
The destination must differ from the source.
For example, you cannot reindex a data stream into itself.
</p>
<p>
IMPORTANT: Reindex requires <code>_source</code> to be enabled for all documents in the source.
The destination should be configured as wanted before calling the reindex API.
Reindex does not copy the settings from the source or its associated template.
Mappings, shard counts, and replicas, for example, must be configured ahead of time.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following security privileges:
</p>
<ul><li>
<p>
The <code>read</code> index privilege for the source data stream, index, or alias.
</p>
</li><li>
<p>
The <code>write</code> index privilege for the destination data stream, index, or index alias.
</p>
</li><li>
<p>
To automatically create a data stream or index with a reindex API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege for the destination data stream, index, or alias.
</p>
</li><li>
<p>
If reindexing from a remote cluster, the <code>source.remote.user</code> must have the <code>monitor</code> cluster privilege and the <code>read</code> index privilege for the source data stream, index, or alias.
</p>
</li></ul>
<p>
If reindexing from a remote cluster, you must explicitly allow the remote host in the <code>reindex.remote.whitelist</code> setting.
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
The <code>dest</code> element can be configured like the index API to control optimistic concurrency control.
Omitting <code>version_type</code> or setting it to <code>internal</code> causes Elasticsearch to blindly dump documents into the destination, overwriting any that happen to have the same ID.
</p>
<p>
Setting <code>version_type</code> to <code>external</code> causes Elasticsearch to preserve the <code>version</code> from the source, create any documents that are missing, and update any documents that have an older version in the destination than they do in the source.
</p>
<p>
Setting <code>op_type</code> to <code>create</code> causes the reindex API to create only missing documents in the destination.
All existing documents will cause a version conflict.
</p>
<p>
IMPORTANT: Because data streams are append-only, any reindex request to a destination data stream must have an <code>op_type</code> of <code>create</code>.
A reindex can only add new documents to a destination data stream.
It cannot update existing documents in a destination data stream.
</p>
<p>
By default, version conflicts abort the reindex process.
To continue reindexing if there are conflicts, set the <code>conflicts</code> request body property to <code>proceed</code>.
In this case, the response includes a count of the version conflicts that were encountered.
Note that the handling of other error types is unaffected by the <code>conflicts</code> property.
Additionally, if you opt to count version conflicts, the operation could attempt to reindex more documents from the source than <code>max_docs</code> until it has successfully indexed <code>max_docs</code> documents into the target or it has gone through every document in the source query.
</p>
<p>
NOTE: The reindex API makes no effort to handle ID collisions.
The last document written will "win" but the order isn't usually predictable so it is not a good idea to rely on this behavior.
Instead, make sure that IDs are unique by using a script.
</p>
<p>
<strong>Running reindex asynchronously</strong>
</p>
<p>
If the request contains <code>wait_for_completion=false</code>, Elasticsearch performs some preflight checks, launches the request, and returns a task you can use to cancel or get the status of the task.
Elasticsearch creates a record of this task as a document at <code>_tasks/&lt;task_id&gt;</code>.
</p>
<p>
<strong>Reindex from multiple sources</strong>
</p>
<p>
If you have many sources to reindex it is generally better to reindex them one at a time rather than using a glob pattern to pick up multiple sources.
That way you can resume the process if there are any errors by removing the partially completed source and starting over.
It also makes parallelizing the process fairly simple: split the list of sources to reindex and run each list in parallel.
</p>
<p>
For example, you can use a bash script like this:
</p>
<pre><code class="lang-csharp">for index in i1 i2 i3 i4 i5; do
  curl -HContent-Type:application/json -XPOST localhost:9200/_reindex?pretty -d'{
    "source": {
      "index": "'$index'"
    },
    "dest": {
      "index": "'$index'-reindexed"
    }
  }'
done</code></pre>
<p>
<strong>Throttling</strong>
</p>
<p>
Set <code>requests_per_second</code> to any positive decimal number (<code>1.4</code>, <code>6</code>, <code>1000</code>, for example) to throttle the rate at which reindex issues batches of index operations.
Requests are throttled by padding each batch with a wait time.
To turn off throttling, set <code>requests_per_second</code> to <code>-1</code>.
</p>
<p>
The throttling is done by waiting between batches so that the scroll that reindex uses internally can be given a timeout that takes into account the padding.
The padding time is the difference between the batch size divided by the <code>requests_per_second</code> and the time spent writing.
By default the batch size is <code>1000</code>, so if <code>requests_per_second</code> is set to <code>500</code>:
</p>
<pre><code class="lang-csharp">target_time = 1000 / 500 per second = 2 seconds
wait_time = target_time - write_time = 2 seconds - .5 seconds = 1.5 seconds</code></pre>
<p>
Since the batch is issued as a single bulk request, large batch sizes cause Elasticsearch to create many requests and then wait for a while before starting the next set.
This is "bursty" instead of "smooth".
</p>
<p>
<strong>Slicing</strong>
</p>
<p>
Reindex supports sliced scroll to parallelize the reindexing process.
This parallelization can improve efficiency and provide a convenient way to break the request down into smaller parts.
</p>
<p>
NOTE: Reindexing from remote clusters does not support manual or automatic slicing.
</p>
<p>
You can slice a reindex request manually by providing a slice ID and total number of slices to each request.
You can also let reindex automatically parallelize by using sliced scroll to slice on <code>_id</code>.
The <code>slices</code> parameter specifies the number of slices to use.
</p>
<p>
Adding <code>slices</code> to the reindex request just automates the manual process, creating sub-requests which means it has some quirks:
</p>
<ul><li>
<p>
You can see these requests in the tasks API. These sub-requests are "child" tasks of the task for the request with slices.
</p>
</li><li>
<p>
Fetching the status of the task for the request with <code>slices</code> only contains the status of completed slices.
</p>
</li><li>
<p>
These sub-requests are individually addressable for things like cancellation and rethrottling.
</p>
</li><li>
<p>
Rethrottling the request with <code>slices</code> will rethrottle the unfinished sub-request proportionally.
</p>
</li><li>
<p>
Canceling the request with <code>slices</code> will cancel each sub-request.
</p>
</li><li>
<p>
Due to the nature of <code>slices</code>, each sub-request won't get a perfectly even portion of the documents. All documents will be addressed, but some slices may be larger than others. Expect larger slices to have a more even distribution.
</p>
</li><li>
<p>
Parameters like <code>requests_per_second</code> and <code>max_docs</code> on a request with <code>slices</code> are distributed proportionally to each sub-request. Combine that with the previous point about distribution being uneven and you should conclude that using <code>max_docs</code> with <code>slices</code> might not result in exactly <code>max_docs</code> documents being reindexed.
</p>
</li><li>
<p>
Each sub-request gets a slightly different snapshot of the source, though these are all taken at approximately the same time.
</p>
</li></ul>
<p>
If slicing automatically, setting <code>slices</code> to <code>auto</code> will choose a reasonable number for most indices.
If slicing manually or otherwise tuning automatic slicing, use the following guidelines.
</p>
<p>
Query performance is most efficient when the number of slices is equal to the number of shards in the index.
If that number is large (for example, <code>500</code>), choose a lower number as too many slices will hurt performance.
Setting slices higher than the number of shards generally does not improve efficiency and adds overhead.
</p>
<p>
Indexing performance scales linearly across available resources with the number of slices.
</p>
<p>
Whether query or indexing performance dominates the runtime depends on the documents being reindexed and cluster resources.
</p>
<p>
<strong>Modify documents during reindexing</strong>
</p>
<p>
Like <code>_update_by_query</code>, reindex operations support a script that modifies the document.
Unlike <code>_update_by_query</code>, the script is allowed to modify the document's metadata.
</p>
<p>
Just as in <code>_update_by_query</code>, you can set <code>ctx.op</code> to change the operation that is run on the destination.
For example, set <code>ctx.op</code> to <code>noop</code> if your script decides that the document doesn’t have to be indexed in the destination. This "no operation" will be reported in the <code>noop</code> counter in the response body.
Set <code>ctx.op</code> to <code>delete</code> if your script decides that the document must be deleted from the destination.
The deletion will be reported in the <code>deleted</code> counter in the response body.
Setting <code>ctx.op</code> to anything else will return an error, as will setting any other field in <code>ctx</code>.
</p>
<p>
Think of the possibilities! Just be careful; you are able to change:
</p>
<ul><li>
<p>
<code>_id</code>
</p>
</li><li>
<p>
<code>_index</code>
</p>
</li><li>
<p>
<code>_version</code>
</p>
</li><li>
<p>
<code>_routing</code>
</p>
</li></ul>
<p>
Setting <code>_version</code> to <code>null</code> or clearing it from the <code>ctx</code> map is just like not sending the version in an indexing request.
It will cause the document to be overwritten in the destination regardless of the version on the target or the version type you use in the reindex API.
</p>
<p>
<strong>Reindex from remote</strong>
</p>
<p>
Reindex supports reindexing from a remote Elasticsearch cluster.
The <code>host</code> parameter must contain a scheme, host, port, and optional path.
The <code>username</code> and <code>password</code> parameters are optional and when they are present the reindex operation will connect to the remote Elasticsearch node using basic authentication.
Be sure to use HTTPS when using basic authentication or the password will be sent in plain text.
There are a range of settings available to configure the behavior of the HTTPS connection.
</p>
<p>
When using Elastic Cloud, it is also possible to authenticate against the remote cluster through the use of a valid API key.
Remote hosts must be explicitly allowed with the <code>reindex.remote.whitelist</code> setting.
It can be set to a comma delimited list of allowed remote host and port combinations.
Scheme is ignored; only the host and port are used.
For example:
</p>
<pre><code class="lang-csharp">reindex.remote.whitelist: [otherhost:9200, another:9200, 127.0.10.*:9200, localhost:*"]</code></pre>
<p>
The list of allowed hosts must be configured on any nodes that will coordinate the reindex.
This feature should work with remote clusters of any version of Elasticsearch.
This should enable you to upgrade from any version of Elasticsearch to the current version by reindexing from a cluster of the old version.
</p>
<p>
WARNING: Elasticsearch does not support forward compatibility across major versions.
For example, you cannot reindex from a 7.x cluster into a 6.x cluster.
</p>
<p>
To enable queries sent to older versions of Elasticsearch, the <code>query</code> parameter is sent directly to the remote host without validation or modification.
</p>
<p>
NOTE: Reindexing from remote clusters does not support manual or automatic slicing.
</p>
<p>
Reindexing from a remote server uses an on-heap buffer that defaults to a maximum size of 100mb.
If the remote index includes very large documents you'll need to use a smaller batch size.
It is also possible to set the socket read timeout on the remote connection with the <code>socket_timeout</code> field and the connection timeout with the <code>connect_timeout</code> field.
Both default to 30 seconds.
</p>
<p>
<strong>Configuring SSL parameters</strong>
</p>
<p>
Reindex from remote supports configurable SSL settings.
These must be specified in the <code>elasticsearch.yml</code> file, with the exception of the secure settings, which you add in the Elasticsearch keystore.
It is not possible to configure SSL in the body of the reindex request.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-reindex.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual ReindexResponse Reindex&lt;TDocument&gt;(ReindexRequestDescriptor&lt;TDocument&gt; descriptor)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.ReindexRequestDescriptor-1.html">ReindexRequestDescriptor</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ReindexResponse.html">ReindexResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Reindex_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Reindex*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Reindex__1_System_Action_Elastic_Clients_Elasticsearch_ReindexRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Reindex``1(System.Action{Elastic.Clients.Elasticsearch.ReindexRequestDescriptor{``0}})">
  Reindex&lt;TDocument&gt;(Action&lt;ReindexRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L27629"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Reindex documents.
</p>
<p>
Copy documents from a source to a destination.
You can copy all documents to the destination index or reindex a subset of the documents.
The source can be any existing index, alias, or data stream.
The destination must differ from the source.
For example, you cannot reindex a data stream into itself.
</p>
<p>
IMPORTANT: Reindex requires <code>_source</code> to be enabled for all documents in the source.
The destination should be configured as wanted before calling the reindex API.
Reindex does not copy the settings from the source or its associated template.
Mappings, shard counts, and replicas, for example, must be configured ahead of time.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following security privileges:
</p>
<ul><li>
<p>
The <code>read</code> index privilege for the source data stream, index, or alias.
</p>
</li><li>
<p>
The <code>write</code> index privilege for the destination data stream, index, or index alias.
</p>
</li><li>
<p>
To automatically create a data stream or index with a reindex API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege for the destination data stream, index, or alias.
</p>
</li><li>
<p>
If reindexing from a remote cluster, the <code>source.remote.user</code> must have the <code>monitor</code> cluster privilege and the <code>read</code> index privilege for the source data stream, index, or alias.
</p>
</li></ul>
<p>
If reindexing from a remote cluster, you must explicitly allow the remote host in the <code>reindex.remote.whitelist</code> setting.
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
The <code>dest</code> element can be configured like the index API to control optimistic concurrency control.
Omitting <code>version_type</code> or setting it to <code>internal</code> causes Elasticsearch to blindly dump documents into the destination, overwriting any that happen to have the same ID.
</p>
<p>
Setting <code>version_type</code> to <code>external</code> causes Elasticsearch to preserve the <code>version</code> from the source, create any documents that are missing, and update any documents that have an older version in the destination than they do in the source.
</p>
<p>
Setting <code>op_type</code> to <code>create</code> causes the reindex API to create only missing documents in the destination.
All existing documents will cause a version conflict.
</p>
<p>
IMPORTANT: Because data streams are append-only, any reindex request to a destination data stream must have an <code>op_type</code> of <code>create</code>.
A reindex can only add new documents to a destination data stream.
It cannot update existing documents in a destination data stream.
</p>
<p>
By default, version conflicts abort the reindex process.
To continue reindexing if there are conflicts, set the <code>conflicts</code> request body property to <code>proceed</code>.
In this case, the response includes a count of the version conflicts that were encountered.
Note that the handling of other error types is unaffected by the <code>conflicts</code> property.
Additionally, if you opt to count version conflicts, the operation could attempt to reindex more documents from the source than <code>max_docs</code> until it has successfully indexed <code>max_docs</code> documents into the target or it has gone through every document in the source query.
</p>
<p>
NOTE: The reindex API makes no effort to handle ID collisions.
The last document written will "win" but the order isn't usually predictable so it is not a good idea to rely on this behavior.
Instead, make sure that IDs are unique by using a script.
</p>
<p>
<strong>Running reindex asynchronously</strong>
</p>
<p>
If the request contains <code>wait_for_completion=false</code>, Elasticsearch performs some preflight checks, launches the request, and returns a task you can use to cancel or get the status of the task.
Elasticsearch creates a record of this task as a document at <code>_tasks/&lt;task_id&gt;</code>.
</p>
<p>
<strong>Reindex from multiple sources</strong>
</p>
<p>
If you have many sources to reindex it is generally better to reindex them one at a time rather than using a glob pattern to pick up multiple sources.
That way you can resume the process if there are any errors by removing the partially completed source and starting over.
It also makes parallelizing the process fairly simple: split the list of sources to reindex and run each list in parallel.
</p>
<p>
For example, you can use a bash script like this:
</p>
<pre><code class="lang-csharp">for index in i1 i2 i3 i4 i5; do
  curl -HContent-Type:application/json -XPOST localhost:9200/_reindex?pretty -d'{
    "source": {
      "index": "'$index'"
    },
    "dest": {
      "index": "'$index'-reindexed"
    }
  }'
done</code></pre>
<p>
<strong>Throttling</strong>
</p>
<p>
Set <code>requests_per_second</code> to any positive decimal number (<code>1.4</code>, <code>6</code>, <code>1000</code>, for example) to throttle the rate at which reindex issues batches of index operations.
Requests are throttled by padding each batch with a wait time.
To turn off throttling, set <code>requests_per_second</code> to <code>-1</code>.
</p>
<p>
The throttling is done by waiting between batches so that the scroll that reindex uses internally can be given a timeout that takes into account the padding.
The padding time is the difference between the batch size divided by the <code>requests_per_second</code> and the time spent writing.
By default the batch size is <code>1000</code>, so if <code>requests_per_second</code> is set to <code>500</code>:
</p>
<pre><code class="lang-csharp">target_time = 1000 / 500 per second = 2 seconds
wait_time = target_time - write_time = 2 seconds - .5 seconds = 1.5 seconds</code></pre>
<p>
Since the batch is issued as a single bulk request, large batch sizes cause Elasticsearch to create many requests and then wait for a while before starting the next set.
This is "bursty" instead of "smooth".
</p>
<p>
<strong>Slicing</strong>
</p>
<p>
Reindex supports sliced scroll to parallelize the reindexing process.
This parallelization can improve efficiency and provide a convenient way to break the request down into smaller parts.
</p>
<p>
NOTE: Reindexing from remote clusters does not support manual or automatic slicing.
</p>
<p>
You can slice a reindex request manually by providing a slice ID and total number of slices to each request.
You can also let reindex automatically parallelize by using sliced scroll to slice on <code>_id</code>.
The <code>slices</code> parameter specifies the number of slices to use.
</p>
<p>
Adding <code>slices</code> to the reindex request just automates the manual process, creating sub-requests which means it has some quirks:
</p>
<ul><li>
<p>
You can see these requests in the tasks API. These sub-requests are "child" tasks of the task for the request with slices.
</p>
</li><li>
<p>
Fetching the status of the task for the request with <code>slices</code> only contains the status of completed slices.
</p>
</li><li>
<p>
These sub-requests are individually addressable for things like cancellation and rethrottling.
</p>
</li><li>
<p>
Rethrottling the request with <code>slices</code> will rethrottle the unfinished sub-request proportionally.
</p>
</li><li>
<p>
Canceling the request with <code>slices</code> will cancel each sub-request.
</p>
</li><li>
<p>
Due to the nature of <code>slices</code>, each sub-request won't get a perfectly even portion of the documents. All documents will be addressed, but some slices may be larger than others. Expect larger slices to have a more even distribution.
</p>
</li><li>
<p>
Parameters like <code>requests_per_second</code> and <code>max_docs</code> on a request with <code>slices</code> are distributed proportionally to each sub-request. Combine that with the previous point about distribution being uneven and you should conclude that using <code>max_docs</code> with <code>slices</code> might not result in exactly <code>max_docs</code> documents being reindexed.
</p>
</li><li>
<p>
Each sub-request gets a slightly different snapshot of the source, though these are all taken at approximately the same time.
</p>
</li></ul>
<p>
If slicing automatically, setting <code>slices</code> to <code>auto</code> will choose a reasonable number for most indices.
If slicing manually or otherwise tuning automatic slicing, use the following guidelines.
</p>
<p>
Query performance is most efficient when the number of slices is equal to the number of shards in the index.
If that number is large (for example, <code>500</code>), choose a lower number as too many slices will hurt performance.
Setting slices higher than the number of shards generally does not improve efficiency and adds overhead.
</p>
<p>
Indexing performance scales linearly across available resources with the number of slices.
</p>
<p>
Whether query or indexing performance dominates the runtime depends on the documents being reindexed and cluster resources.
</p>
<p>
<strong>Modify documents during reindexing</strong>
</p>
<p>
Like <code>_update_by_query</code>, reindex operations support a script that modifies the document.
Unlike <code>_update_by_query</code>, the script is allowed to modify the document's metadata.
</p>
<p>
Just as in <code>_update_by_query</code>, you can set <code>ctx.op</code> to change the operation that is run on the destination.
For example, set <code>ctx.op</code> to <code>noop</code> if your script decides that the document doesn’t have to be indexed in the destination. This "no operation" will be reported in the <code>noop</code> counter in the response body.
Set <code>ctx.op</code> to <code>delete</code> if your script decides that the document must be deleted from the destination.
The deletion will be reported in the <code>deleted</code> counter in the response body.
Setting <code>ctx.op</code> to anything else will return an error, as will setting any other field in <code>ctx</code>.
</p>
<p>
Think of the possibilities! Just be careful; you are able to change:
</p>
<ul><li>
<p>
<code>_id</code>
</p>
</li><li>
<p>
<code>_index</code>
</p>
</li><li>
<p>
<code>_version</code>
</p>
</li><li>
<p>
<code>_routing</code>
</p>
</li></ul>
<p>
Setting <code>_version</code> to <code>null</code> or clearing it from the <code>ctx</code> map is just like not sending the version in an indexing request.
It will cause the document to be overwritten in the destination regardless of the version on the target or the version type you use in the reindex API.
</p>
<p>
<strong>Reindex from remote</strong>
</p>
<p>
Reindex supports reindexing from a remote Elasticsearch cluster.
The <code>host</code> parameter must contain a scheme, host, port, and optional path.
The <code>username</code> and <code>password</code> parameters are optional and when they are present the reindex operation will connect to the remote Elasticsearch node using basic authentication.
Be sure to use HTTPS when using basic authentication or the password will be sent in plain text.
There are a range of settings available to configure the behavior of the HTTPS connection.
</p>
<p>
When using Elastic Cloud, it is also possible to authenticate against the remote cluster through the use of a valid API key.
Remote hosts must be explicitly allowed with the <code>reindex.remote.whitelist</code> setting.
It can be set to a comma delimited list of allowed remote host and port combinations.
Scheme is ignored; only the host and port are used.
For example:
</p>
<pre><code class="lang-csharp">reindex.remote.whitelist: [otherhost:9200, another:9200, 127.0.10.*:9200, localhost:*"]</code></pre>
<p>
The list of allowed hosts must be configured on any nodes that will coordinate the reindex.
This feature should work with remote clusters of any version of Elasticsearch.
This should enable you to upgrade from any version of Elasticsearch to the current version by reindexing from a cluster of the old version.
</p>
<p>
WARNING: Elasticsearch does not support forward compatibility across major versions.
For example, you cannot reindex from a 7.x cluster into a 6.x cluster.
</p>
<p>
To enable queries sent to older versions of Elasticsearch, the <code>query</code> parameter is sent directly to the remote host without validation or modification.
</p>
<p>
NOTE: Reindexing from remote clusters does not support manual or automatic slicing.
</p>
<p>
Reindexing from a remote server uses an on-heap buffer that defaults to a maximum size of 100mb.
If the remote index includes very large documents you'll need to use a smaller batch size.
It is also possible to set the socket read timeout on the remote connection with the <code>socket_timeout</code> field and the connection timeout with the <code>connect_timeout</code> field.
Both default to 30 seconds.
</p>
<p>
<strong>Configuring SSL parameters</strong>
</p>
<p>
Reindex from remote supports configurable SSL settings.
These must be specified in the <code>elasticsearch.yml</code> file, with the exception of the secure settings, which you add in the Elasticsearch keystore.
It is not possible to configure SSL in the body of the reindex request.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-reindex.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual ReindexResponse Reindex&lt;TDocument&gt;(Action&lt;ReindexRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ReindexRequestDescriptor-1.html">ReindexRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ReindexResponse.html">ReindexResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_RenderSearchTemplate_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.RenderSearchTemplate*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_RenderSearchTemplate" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.RenderSearchTemplate">
  RenderSearchTemplate()
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L30659"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Render a search template.
</p>
<p>
Render a search template as a search request body.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/render-search-template-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual RenderSearchTemplateResponse RenderSearchTemplate()</code></pre>
  </div>


  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.RenderSearchTemplateResponse.html">RenderSearchTemplateResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_RenderSearchTemplate_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.RenderSearchTemplate*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_RenderSearchTemplate_Elastic_Clients_Elasticsearch_RenderSearchTemplateRequest_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.RenderSearchTemplate(Elastic.Clients.Elasticsearch.RenderSearchTemplateRequest)">
  RenderSearchTemplate(RenderSearchTemplateRequest)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L30561"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Render a search template.
</p>
<p>
Render a search template as a search request body.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/render-search-template-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual RenderSearchTemplateResponse RenderSearchTemplate(RenderSearchTemplateRequest request)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.RenderSearchTemplateRequest.html">RenderSearchTemplateRequest</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.RenderSearchTemplateResponse.html">RenderSearchTemplateResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_RenderSearchTemplate_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.RenderSearchTemplate*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_RenderSearchTemplate_Elastic_Clients_Elasticsearch_RenderSearchTemplateRequestDescriptor_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.RenderSearchTemplate(Elastic.Clients.Elasticsearch.RenderSearchTemplateRequestDescriptor)">
  RenderSearchTemplate(RenderSearchTemplateRequestDescriptor)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L30643"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Render a search template.
</p>
<p>
Render a search template as a search request body.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/render-search-template-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual RenderSearchTemplateResponse RenderSearchTemplate(RenderSearchTemplateRequestDescriptor descriptor)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.RenderSearchTemplateRequestDescriptor.html">RenderSearchTemplateRequestDescriptor</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.RenderSearchTemplateResponse.html">RenderSearchTemplateResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_RenderSearchTemplate_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.RenderSearchTemplate*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_RenderSearchTemplate_System_Action_Elastic_Clients_Elasticsearch_RenderSearchTemplateRequestDescriptor__" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.RenderSearchTemplate(System.Action{Elastic.Clients.Elasticsearch.RenderSearchTemplateRequestDescriptor})">
  RenderSearchTemplate(Action&lt;RenderSearchTemplateRequestDescriptor&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L30676"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Render a search template.
</p>
<p>
Render a search template as a search request body.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/render-search-template-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual RenderSearchTemplateResponse RenderSearchTemplate(Action&lt;RenderSearchTemplateRequestDescriptor&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.RenderSearchTemplateRequestDescriptor.html">RenderSearchTemplateRequestDescriptor</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.RenderSearchTemplateResponse.html">RenderSearchTemplateResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_RenderSearchTemplateAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.RenderSearchTemplateAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_RenderSearchTemplateAsync_Elastic_Clients_Elasticsearch_RenderSearchTemplateRequest_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.RenderSearchTemplateAsync(Elastic.Clients.Elasticsearch.RenderSearchTemplateRequest,System.Threading.CancellationToken)">
  RenderSearchTemplateAsync(RenderSearchTemplateRequest, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L30577"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Render a search template.
</p>
<p>
Render a search template as a search request body.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/render-search-template-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;RenderSearchTemplateResponse&gt; RenderSearchTemplateAsync(RenderSearchTemplateRequest request, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.RenderSearchTemplateRequest.html">RenderSearchTemplateRequest</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.RenderSearchTemplateResponse.html">RenderSearchTemplateResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_RenderSearchTemplateAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.RenderSearchTemplateAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_RenderSearchTemplateAsync_Elastic_Clients_Elasticsearch_RenderSearchTemplateRequestDescriptor_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.RenderSearchTemplateAsync(Elastic.Clients.Elasticsearch.RenderSearchTemplateRequestDescriptor,System.Threading.CancellationToken)">
  RenderSearchTemplateAsync(RenderSearchTemplateRequestDescriptor, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L30742"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Render a search template.
</p>
<p>
Render a search template as a search request body.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/render-search-template-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;RenderSearchTemplateResponse&gt; RenderSearchTemplateAsync(RenderSearchTemplateRequestDescriptor descriptor, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.RenderSearchTemplateRequestDescriptor.html">RenderSearchTemplateRequestDescriptor</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.RenderSearchTemplateResponse.html">RenderSearchTemplateResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_RenderSearchTemplateAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.RenderSearchTemplateAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_RenderSearchTemplateAsync_System_Action_Elastic_Clients_Elasticsearch_RenderSearchTemplateRequestDescriptor__System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.RenderSearchTemplateAsync(System.Action{Elastic.Clients.Elasticsearch.RenderSearchTemplateRequestDescriptor},System.Threading.CancellationToken)">
  RenderSearchTemplateAsync(Action&lt;RenderSearchTemplateRequestDescriptor&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L30773"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Render a search template.
</p>
<p>
Render a search template as a search request body.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/render-search-template-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;RenderSearchTemplateResponse&gt; RenderSearchTemplateAsync(Action&lt;RenderSearchTemplateRequestDescriptor&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.RenderSearchTemplateRequestDescriptor.html">RenderSearchTemplateRequestDescriptor</a>&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.RenderSearchTemplateResponse.html">RenderSearchTemplateResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_RenderSearchTemplateAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.RenderSearchTemplateAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_RenderSearchTemplateAsync_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.RenderSearchTemplateAsync(System.Threading.CancellationToken)">
  RenderSearchTemplateAsync(CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L30757"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Render a search template.
</p>
<p>
Render a search template as a search request body.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/render-search-template-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;RenderSearchTemplateResponse&gt; RenderSearchTemplateAsync(CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.RenderSearchTemplateResponse.html">RenderSearchTemplateResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_RenderSearchTemplateAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.RenderSearchTemplateAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_RenderSearchTemplateAsync__1_Elastic_Clients_Elasticsearch_RenderSearchTemplateRequestDescriptor___0__System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.RenderSearchTemplateAsync``1(Elastic.Clients.Elasticsearch.RenderSearchTemplateRequestDescriptor{``0},System.Threading.CancellationToken)">
  RenderSearchTemplateAsync&lt;TDocument&gt;(RenderSearchTemplateRequestDescriptor&lt;TDocument&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L30694"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Render a search template.
</p>
<p>
Render a search template as a search request body.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/render-search-template-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;RenderSearchTemplateResponse&gt; RenderSearchTemplateAsync&lt;TDocument&gt;(RenderSearchTemplateRequestDescriptor&lt;TDocument&gt; descriptor, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.RenderSearchTemplateRequestDescriptor-1.html">RenderSearchTemplateRequestDescriptor</a>&lt;TDocument&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.RenderSearchTemplateResponse.html">RenderSearchTemplateResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_RenderSearchTemplateAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.RenderSearchTemplateAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_RenderSearchTemplateAsync__1_System_Action_Elastic_Clients_Elasticsearch_RenderSearchTemplateRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.RenderSearchTemplateAsync``1(System.Action{Elastic.Clients.Elasticsearch.RenderSearchTemplateRequestDescriptor{``0}},System.Threading.CancellationToken)">
  RenderSearchTemplateAsync&lt;TDocument&gt;(Action&lt;RenderSearchTemplateRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L30725"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Render a search template.
</p>
<p>
Render a search template as a search request body.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/render-search-template-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;RenderSearchTemplateResponse&gt; RenderSearchTemplateAsync&lt;TDocument&gt;(Action&lt;RenderSearchTemplateRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.RenderSearchTemplateRequestDescriptor-1.html">RenderSearchTemplateRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.RenderSearchTemplateResponse.html">RenderSearchTemplateResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_RenderSearchTemplateAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.RenderSearchTemplateAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_RenderSearchTemplateAsync__1_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.RenderSearchTemplateAsync``1(System.Threading.CancellationToken)">
  RenderSearchTemplateAsync&lt;TDocument&gt;(CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L30709"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Render a search template.
</p>
<p>
Render a search template as a search request body.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/render-search-template-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;RenderSearchTemplateResponse&gt; RenderSearchTemplateAsync&lt;TDocument&gt;(CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.RenderSearchTemplateResponse.html">RenderSearchTemplateResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_RenderSearchTemplate_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.RenderSearchTemplate*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_RenderSearchTemplate__1" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.RenderSearchTemplate``1">
  RenderSearchTemplate&lt;TDocument&gt;()
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L30608"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Render a search template.
</p>
<p>
Render a search template as a search request body.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/render-search-template-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual RenderSearchTemplateResponse RenderSearchTemplate&lt;TDocument&gt;()</code></pre>
  </div>


  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.RenderSearchTemplateResponse.html">RenderSearchTemplateResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_RenderSearchTemplate_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.RenderSearchTemplate*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_RenderSearchTemplate__1_Elastic_Clients_Elasticsearch_RenderSearchTemplateRequestDescriptor___0__" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.RenderSearchTemplate``1(Elastic.Clients.Elasticsearch.RenderSearchTemplateRequestDescriptor{``0})">
  RenderSearchTemplate&lt;TDocument&gt;(RenderSearchTemplateRequestDescriptor&lt;TDocument&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L30592"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Render a search template.
</p>
<p>
Render a search template as a search request body.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/render-search-template-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual RenderSearchTemplateResponse RenderSearchTemplate&lt;TDocument&gt;(RenderSearchTemplateRequestDescriptor&lt;TDocument&gt; descriptor)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.RenderSearchTemplateRequestDescriptor-1.html">RenderSearchTemplateRequestDescriptor</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.RenderSearchTemplateResponse.html">RenderSearchTemplateResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_RenderSearchTemplate_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.RenderSearchTemplate*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_RenderSearchTemplate__1_System_Action_Elastic_Clients_Elasticsearch_RenderSearchTemplateRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.RenderSearchTemplate``1(System.Action{Elastic.Clients.Elasticsearch.RenderSearchTemplateRequestDescriptor{``0}})">
  RenderSearchTemplate&lt;TDocument&gt;(Action&lt;RenderSearchTemplateRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L30625"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Render a search template.
</p>
<p>
Render a search template as a search request body.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/render-search-template-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual RenderSearchTemplateResponse RenderSearchTemplate&lt;TDocument&gt;(Action&lt;RenderSearchTemplateRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.RenderSearchTemplateRequestDescriptor-1.html">RenderSearchTemplateRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.RenderSearchTemplateResponse.html">RenderSearchTemplateResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ScriptsPainlessExecuteAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ScriptsPainlessExecuteAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ScriptsPainlessExecuteAsync__1_Elastic_Clients_Elasticsearch_ScriptsPainlessExecuteRequest_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ScriptsPainlessExecuteAsync``1(Elastic.Clients.Elasticsearch.ScriptsPainlessExecuteRequest,System.Threading.CancellationToken)">
  ScriptsPainlessExecuteAsync&lt;TResult&gt;(ScriptsPainlessExecuteRequest, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L30822"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Run a script.
</p>
<p>
Runs a script and returns a result.
Use this API to build and test scripts, such as when defining a script for a runtime field.
This API requires very few dependencies and is especially useful if you don't have permissions to write documents on a cluster.
</p>
<p>
The API uses several <em>contexts</em>, which control how scripts are run, what variables are available at runtime, and what the return type is.
</p>
<p>
Each context requires a script, but additional parameters depend on the context you're using for that script.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/painless/8.18/painless-execute-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;ScriptsPainlessExecuteResponse&lt;TResult&gt;&gt; ScriptsPainlessExecuteAsync&lt;TResult&gt;(ScriptsPainlessExecuteRequest request, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.ScriptsPainlessExecuteRequest.html">ScriptsPainlessExecuteRequest</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ScriptsPainlessExecuteResponse-1.html">ScriptsPainlessExecuteResponse</a>&lt;TResult&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TResult</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ScriptsPainlessExecuteAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ScriptsPainlessExecuteAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ScriptsPainlessExecuteAsync__1_Elastic_Clients_Elasticsearch_ScriptsPainlessExecuteRequestDescriptor___0__System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ScriptsPainlessExecuteAsync``1(Elastic.Clients.Elasticsearch.ScriptsPainlessExecuteRequestDescriptor{``0},System.Threading.CancellationToken)">
  ScriptsPainlessExecuteAsync&lt;TResult&gt;(ScriptsPainlessExecuteRequestDescriptor&lt;TResult&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L30920"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Run a script.
</p>
<p>
Runs a script and returns a result.
Use this API to build and test scripts, such as when defining a script for a runtime field.
This API requires very few dependencies and is especially useful if you don't have permissions to write documents on a cluster.
</p>
<p>
The API uses several <em>contexts</em>, which control how scripts are run, what variables are available at runtime, and what the return type is.
</p>
<p>
Each context requires a script, but additional parameters depend on the context you're using for that script.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/painless/8.18/painless-execute-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;ScriptsPainlessExecuteResponse&lt;TResult&gt;&gt; ScriptsPainlessExecuteAsync&lt;TResult&gt;(ScriptsPainlessExecuteRequestDescriptor&lt;TResult&gt; descriptor, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.ScriptsPainlessExecuteRequestDescriptor-1.html">ScriptsPainlessExecuteRequestDescriptor</a>&lt;TResult&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ScriptsPainlessExecuteResponse-1.html">ScriptsPainlessExecuteResponse</a>&lt;TResult&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TResult</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ScriptsPainlessExecuteAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ScriptsPainlessExecuteAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ScriptsPainlessExecuteAsync__1_System_Action_Elastic_Clients_Elasticsearch_ScriptsPainlessExecuteRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ScriptsPainlessExecuteAsync``1(System.Action{Elastic.Clients.Elasticsearch.ScriptsPainlessExecuteRequestDescriptor{``0}},System.Threading.CancellationToken)">
  ScriptsPainlessExecuteAsync&lt;TResult&gt;(Action&lt;ScriptsPainlessExecuteRequestDescriptor&lt;TResult&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L30967"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Run a script.
</p>
<p>
Runs a script and returns a result.
Use this API to build and test scripts, such as when defining a script for a runtime field.
This API requires very few dependencies and is especially useful if you don't have permissions to write documents on a cluster.
</p>
<p>
The API uses several <em>contexts</em>, which control how scripts are run, what variables are available at runtime, and what the return type is.
</p>
<p>
Each context requires a script, but additional parameters depend on the context you're using for that script.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/painless/8.18/painless-execute-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;ScriptsPainlessExecuteResponse&lt;TResult&gt;&gt; ScriptsPainlessExecuteAsync&lt;TResult&gt;(Action&lt;ScriptsPainlessExecuteRequestDescriptor&lt;TResult&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ScriptsPainlessExecuteRequestDescriptor-1.html">ScriptsPainlessExecuteRequestDescriptor</a>&lt;TResult&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ScriptsPainlessExecuteResponse-1.html">ScriptsPainlessExecuteResponse</a>&lt;TResult&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TResult</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ScriptsPainlessExecuteAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ScriptsPainlessExecuteAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ScriptsPainlessExecuteAsync__1_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ScriptsPainlessExecuteAsync``1(System.Threading.CancellationToken)">
  ScriptsPainlessExecuteAsync&lt;TResult&gt;(CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L30943"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Run a script.
</p>
<p>
Runs a script and returns a result.
Use this API to build and test scripts, such as when defining a script for a runtime field.
This API requires very few dependencies and is especially useful if you don't have permissions to write documents on a cluster.
</p>
<p>
The API uses several <em>contexts</em>, which control how scripts are run, what variables are available at runtime, and what the return type is.
</p>
<p>
Each context requires a script, but additional parameters depend on the context you're using for that script.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/painless/8.18/painless-execute-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;ScriptsPainlessExecuteResponse&lt;TResult&gt;&gt; ScriptsPainlessExecuteAsync&lt;TResult&gt;(CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ScriptsPainlessExecuteResponse-1.html">ScriptsPainlessExecuteResponse</a>&lt;TResult&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TResult</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ScriptsPainlessExecute_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ScriptsPainlessExecute*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ScriptsPainlessExecute__1" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ScriptsPainlessExecute``1">
  ScriptsPainlessExecute&lt;TResult&gt;()
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L30869"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Run a script.
</p>
<p>
Runs a script and returns a result.
Use this API to build and test scripts, such as when defining a script for a runtime field.
This API requires very few dependencies and is especially useful if you don't have permissions to write documents on a cluster.
</p>
<p>
The API uses several <em>contexts</em>, which control how scripts are run, what variables are available at runtime, and what the return type is.
</p>
<p>
Each context requires a script, but additional parameters depend on the context you're using for that script.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/painless/8.18/painless-execute-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual ScriptsPainlessExecuteResponse&lt;TResult&gt; ScriptsPainlessExecute&lt;TResult&gt;()</code></pre>
  </div>


  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ScriptsPainlessExecuteResponse-1.html">ScriptsPainlessExecuteResponse</a>&lt;TResult&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TResult</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ScriptsPainlessExecute_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ScriptsPainlessExecute*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ScriptsPainlessExecute__1_Elastic_Clients_Elasticsearch_ScriptsPainlessExecuteRequest_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ScriptsPainlessExecute``1(Elastic.Clients.Elasticsearch.ScriptsPainlessExecuteRequest)">
  ScriptsPainlessExecute&lt;TResult&gt;(ScriptsPainlessExecuteRequest)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L30798"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Run a script.
</p>
<p>
Runs a script and returns a result.
Use this API to build and test scripts, such as when defining a script for a runtime field.
This API requires very few dependencies and is especially useful if you don't have permissions to write documents on a cluster.
</p>
<p>
The API uses several <em>contexts</em>, which control how scripts are run, what variables are available at runtime, and what the return type is.
</p>
<p>
Each context requires a script, but additional parameters depend on the context you're using for that script.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/painless/8.18/painless-execute-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual ScriptsPainlessExecuteResponse&lt;TResult&gt; ScriptsPainlessExecute&lt;TResult&gt;(ScriptsPainlessExecuteRequest request)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.ScriptsPainlessExecuteRequest.html">ScriptsPainlessExecuteRequest</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ScriptsPainlessExecuteResponse-1.html">ScriptsPainlessExecuteResponse</a>&lt;TResult&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TResult</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ScriptsPainlessExecute_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ScriptsPainlessExecute*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ScriptsPainlessExecute__1_Elastic_Clients_Elasticsearch_ScriptsPainlessExecuteRequestDescriptor___0__" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ScriptsPainlessExecute``1(Elastic.Clients.Elasticsearch.ScriptsPainlessExecuteRequestDescriptor{``0})">
  ScriptsPainlessExecute&lt;TResult&gt;(ScriptsPainlessExecuteRequestDescriptor&lt;TResult&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L30845"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Run a script.
</p>
<p>
Runs a script and returns a result.
Use this API to build and test scripts, such as when defining a script for a runtime field.
This API requires very few dependencies and is especially useful if you don't have permissions to write documents on a cluster.
</p>
<p>
The API uses several <em>contexts</em>, which control how scripts are run, what variables are available at runtime, and what the return type is.
</p>
<p>
Each context requires a script, but additional parameters depend on the context you're using for that script.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/painless/8.18/painless-execute-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual ScriptsPainlessExecuteResponse&lt;TResult&gt; ScriptsPainlessExecute&lt;TResult&gt;(ScriptsPainlessExecuteRequestDescriptor&lt;TResult&gt; descriptor)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.ScriptsPainlessExecuteRequestDescriptor-1.html">ScriptsPainlessExecuteRequestDescriptor</a>&lt;TResult&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ScriptsPainlessExecuteResponse-1.html">ScriptsPainlessExecuteResponse</a>&lt;TResult&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TResult</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ScriptsPainlessExecute_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ScriptsPainlessExecute*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ScriptsPainlessExecute__1_System_Action_Elastic_Clients_Elasticsearch_ScriptsPainlessExecuteRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ScriptsPainlessExecute``1(System.Action{Elastic.Clients.Elasticsearch.ScriptsPainlessExecuteRequestDescriptor{``0}})">
  ScriptsPainlessExecute&lt;TResult&gt;(Action&lt;ScriptsPainlessExecuteRequestDescriptor&lt;TResult&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L30894"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Run a script.
</p>
<p>
Runs a script and returns a result.
Use this API to build and test scripts, such as when defining a script for a runtime field.
This API requires very few dependencies and is especially useful if you don't have permissions to write documents on a cluster.
</p>
<p>
The API uses several <em>contexts</em>, which control how scripts are run, what variables are available at runtime, and what the return type is.
</p>
<p>
Each context requires a script, but additional parameters depend on the context you're using for that script.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/painless/8.18/painless-execute-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual ScriptsPainlessExecuteResponse&lt;TResult&gt; ScriptsPainlessExecute&lt;TResult&gt;(Action&lt;ScriptsPainlessExecuteRequestDescriptor&lt;TResult&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ScriptsPainlessExecuteRequestDescriptor-1.html">ScriptsPainlessExecuteRequestDescriptor</a>&lt;TResult&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ScriptsPainlessExecuteResponse-1.html">ScriptsPainlessExecuteResponse</a>&lt;TResult&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TResult</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ScrollAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ScrollAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_ScrollAsync__1_Elastic_Clients_Elasticsearch_ScrollRequest_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.ScrollAsync``1(Elastic.Clients.Elasticsearch.ScrollRequest,System.Threading.CancellationToken)">
  ScrollAsync&lt;TDocument&gt;(ScrollRequest, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L31028"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Run a scrolling search.
</p>
<p>
IMPORTANT: The scroll API is no longer recommend for deep pagination. If you need to preserve the index state while paging through more than 10,000 hits, use the <code>search_after</code> parameter with a point in time (PIT).
</p>
<p>
The scroll API gets large sets of results from a single scrolling search request.
To get the necessary scroll ID, submit a search API request that includes an argument for the <code>scroll</code> query parameter.
The <code>scroll</code> parameter indicates how long Elasticsearch should retain the search context for the request.
The search response returns a scroll ID in the <code>_scroll_id</code> response body parameter.
You can then use the scroll ID with the scroll API to retrieve the next batch of results for the request.
If the Elasticsearch security features are enabled, the access to the results of a specific scroll ID is restricted to the user or API key that submitted the search.
</p>
<p>
You can also use the scroll API to specify a new scroll parameter that extends or shortens the retention period for the search context.
</p>
<p>
IMPORTANT: Results from a scrolling search reflect the state of the index at the time of the initial search request. Subsequent indexing or document changes only affect later search and scroll requests.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/scroll-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;ScrollResponse&lt;TDocument&gt;&gt; ScrollAsync&lt;TDocument&gt;(ScrollRequest request, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.ScrollRequest.html">ScrollRequest</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ScrollResponse-1.html">ScrollResponse</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Scroll_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Scroll*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Scroll__1_Elastic_Clients_Elasticsearch_ScrollRequest_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Scroll``1(Elastic.Clients.Elasticsearch.ScrollRequest)">
  Scroll&lt;TDocument&gt;(ScrollRequest)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L30998"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Run a scrolling search.
</p>
<p>
IMPORTANT: The scroll API is no longer recommend for deep pagination. If you need to preserve the index state while paging through more than 10,000 hits, use the <code>search_after</code> parameter with a point in time (PIT).
</p>
<p>
The scroll API gets large sets of results from a single scrolling search request.
To get the necessary scroll ID, submit a search API request that includes an argument for the <code>scroll</code> query parameter.
The <code>scroll</code> parameter indicates how long Elasticsearch should retain the search context for the request.
The search response returns a scroll ID in the <code>_scroll_id</code> response body parameter.
You can then use the scroll ID with the scroll API to retrieve the next batch of results for the request.
If the Elasticsearch security features are enabled, the access to the results of a specific scroll ID is restricted to the user or API key that submitted the search.
</p>
<p>
You can also use the scroll API to specify a new scroll parameter that extends or shortens the retention period for the search context.
</p>
<p>
IMPORTANT: Results from a scrolling search reflect the state of the index at the time of the initial search request. Subsequent indexing or document changes only affect later search and scroll requests.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/scroll-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual ScrollResponse&lt;TDocument&gt; Scroll&lt;TDocument&gt;(ScrollRequest request)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.ScrollRequest.html">ScrollRequest</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ScrollResponse-1.html">ScrollResponse</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchAsync__1_Elastic_Clients_Elasticsearch_Indices_System_Action_Elastic_Clients_Elasticsearch_SearchRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchAsync``1(Elastic.Clients.Elasticsearch.Indices,System.Action{Elastic.Clients.Elasticsearch.SearchRequestDescriptor{``0}},System.Threading.CancellationToken)">
  SearchAsync&lt;TDocument&gt;(Indices?, Action&lt;SearchRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L31411"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Run a search.
</p>
<p>
Get search hits that match the query defined in the request.
You can provide search queries using the <code>q</code> query string parameter or the request body.
If both are specified, only the query parameter is used.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the read index privilege for the target data stream, index, or alias. For cross-cluster search, refer to the documentation about configuring CCS privileges.
To search a point in time (PIT) for an alias, you must have the <code>read</code> index privilege for the alias's data streams or indices.
</p>
<p>
<strong>Search slicing</strong>
</p>
<p>
When paging through a large number of documents, it can be helpful to split the search into multiple slices to consume them independently with the <code>slice</code> and <code>pit</code> properties.
By default the splitting is done first on the shards, then locally on each shard.
The local splitting partitions the shard into contiguous ranges based on Lucene document IDs.
</p>
<p>
For instance if the number of shards is equal to 2 and you request 4 slices, the slices 0 and 2 are assigned to the first shard and the slices 1 and 3 are assigned to the second shard.
</p>
<p>
IMPORTANT: The same point-in-time ID should be used for all slices.
If different PIT IDs are used, slices can overlap and miss documents.
This situation can occur because the splitting criterion is based on Lucene document IDs, which are not stable across changes to the index.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-search.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;SearchResponse&lt;TDocument&gt;&gt; SearchAsync&lt;TDocument&gt;(Indices? indices, Action&lt;SearchRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>indices</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Indices.html">Indices</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.SearchRequestDescriptor-1.html">SearchRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.SearchResponse-1.html">SearchResponse</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchAsync__1_Elastic_Clients_Elasticsearch_Indices_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchAsync``1(Elastic.Clients.Elasticsearch.Indices,System.Threading.CancellationToken)">
  SearchAsync&lt;TDocument&gt;(Indices?, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L31373"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Run a search.
</p>
<p>
Get search hits that match the query defined in the request.
You can provide search queries using the <code>q</code> query string parameter or the request body.
If both are specified, only the query parameter is used.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the read index privilege for the target data stream, index, or alias. For cross-cluster search, refer to the documentation about configuring CCS privileges.
To search a point in time (PIT) for an alias, you must have the <code>read</code> index privilege for the alias's data streams or indices.
</p>
<p>
<strong>Search slicing</strong>
</p>
<p>
When paging through a large number of documents, it can be helpful to split the search into multiple slices to consume them independently with the <code>slice</code> and <code>pit</code> properties.
By default the splitting is done first on the shards, then locally on each shard.
The local splitting partitions the shard into contiguous ranges based on Lucene document IDs.
</p>
<p>
For instance if the number of shards is equal to 2 and you request 4 slices, the slices 0 and 2 are assigned to the first shard and the slices 1 and 3 are assigned to the second shard.
</p>
<p>
IMPORTANT: The same point-in-time ID should be used for all slices.
If different PIT IDs are used, slices can overlap and miss documents.
This situation can occur because the splitting criterion is based on Lucene document IDs, which are not stable across changes to the index.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-search.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;SearchResponse&lt;TDocument&gt;&gt; SearchAsync&lt;TDocument&gt;(Indices? indices, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>indices</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Indices.html">Indices</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.SearchResponse-1.html">SearchResponse</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchAsync__1_Elastic_Clients_Elasticsearch_SearchRequest_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchAsync``1(Elastic.Clients.Elasticsearch.SearchRequest,System.Threading.CancellationToken)">
  SearchAsync&lt;TDocument&gt;(SearchRequest, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L31103"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Run a search.
</p>
<p>
Get search hits that match the query defined in the request.
You can provide search queries using the <code>q</code> query string parameter or the request body.
If both are specified, only the query parameter is used.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the read index privilege for the target data stream, index, or alias. For cross-cluster search, refer to the documentation about configuring CCS privileges.
To search a point in time (PIT) for an alias, you must have the <code>read</code> index privilege for the alias's data streams or indices.
</p>
<p>
<strong>Search slicing</strong>
</p>
<p>
When paging through a large number of documents, it can be helpful to split the search into multiple slices to consume them independently with the <code>slice</code> and <code>pit</code> properties.
By default the splitting is done first on the shards, then locally on each shard.
The local splitting partitions the shard into contiguous ranges based on Lucene document IDs.
</p>
<p>
For instance if the number of shards is equal to 2 and you request 4 slices, the slices 0 and 2 are assigned to the first shard and the slices 1 and 3 are assigned to the second shard.
</p>
<p>
IMPORTANT: The same point-in-time ID should be used for all slices.
If different PIT IDs are used, slices can overlap and miss documents.
This situation can occur because the splitting criterion is based on Lucene document IDs, which are not stable across changes to the index.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-search.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;SearchResponse&lt;TDocument&gt;&gt; SearchAsync&lt;TDocument&gt;(SearchRequest request, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.SearchRequest.html">SearchRequest</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.SearchResponse-1.html">SearchResponse</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchAsync__1_Elastic_Clients_Elasticsearch_SearchRequestDescriptor___0__System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchAsync``1(Elastic.Clients.Elasticsearch.SearchRequestDescriptor{``0},System.Threading.CancellationToken)">
  SearchAsync&lt;TDocument&gt;(SearchRequestDescriptor&lt;TDocument&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L31336"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Run a search.
</p>
<p>
Get search hits that match the query defined in the request.
You can provide search queries using the <code>q</code> query string parameter or the request body.
If both are specified, only the query parameter is used.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the read index privilege for the target data stream, index, or alias. For cross-cluster search, refer to the documentation about configuring CCS privileges.
To search a point in time (PIT) for an alias, you must have the <code>read</code> index privilege for the alias's data streams or indices.
</p>
<p>
<strong>Search slicing</strong>
</p>
<p>
When paging through a large number of documents, it can be helpful to split the search into multiple slices to consume them independently with the <code>slice</code> and <code>pit</code> properties.
By default the splitting is done first on the shards, then locally on each shard.
The local splitting partitions the shard into contiguous ranges based on Lucene document IDs.
</p>
<p>
For instance if the number of shards is equal to 2 and you request 4 slices, the slices 0 and 2 are assigned to the first shard and the slices 1 and 3 are assigned to the second shard.
</p>
<p>
IMPORTANT: The same point-in-time ID should be used for all slices.
If different PIT IDs are used, slices can overlap and miss documents.
This situation can occur because the splitting criterion is based on Lucene document IDs, which are not stable across changes to the index.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-search.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;SearchResponse&lt;TDocument&gt;&gt; SearchAsync&lt;TDocument&gt;(SearchRequestDescriptor&lt;TDocument&gt; descriptor, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.SearchRequestDescriptor-1.html">SearchRequestDescriptor</a>&lt;TDocument&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.SearchResponse-1.html">SearchResponse</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchAsync__1_System_Action_Elastic_Clients_Elasticsearch_SearchRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchAsync``1(System.Action{Elastic.Clients.Elasticsearch.SearchRequestDescriptor{``0}},System.Threading.CancellationToken)">
  SearchAsync&lt;TDocument&gt;(Action&lt;SearchRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L31488"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Run a search.
</p>
<p>
Get search hits that match the query defined in the request.
You can provide search queries using the <code>q</code> query string parameter or the request body.
If both are specified, only the query parameter is used.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the read index privilege for the target data stream, index, or alias. For cross-cluster search, refer to the documentation about configuring CCS privileges.
To search a point in time (PIT) for an alias, you must have the <code>read</code> index privilege for the alias's data streams or indices.
</p>
<p>
<strong>Search slicing</strong>
</p>
<p>
When paging through a large number of documents, it can be helpful to split the search into multiple slices to consume them independently with the <code>slice</code> and <code>pit</code> properties.
By default the splitting is done first on the shards, then locally on each shard.
The local splitting partitions the shard into contiguous ranges based on Lucene document IDs.
</p>
<p>
For instance if the number of shards is equal to 2 and you request 4 slices, the slices 0 and 2 are assigned to the first shard and the slices 1 and 3 are assigned to the second shard.
</p>
<p>
IMPORTANT: The same point-in-time ID should be used for all slices.
If different PIT IDs are used, slices can overlap and miss documents.
This situation can occur because the splitting criterion is based on Lucene document IDs, which are not stable across changes to the index.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-search.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;SearchResponse&lt;TDocument&gt;&gt; SearchAsync&lt;TDocument&gt;(Action&lt;SearchRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.SearchRequestDescriptor-1.html">SearchRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.SearchResponse-1.html">SearchResponse</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchAsync__1_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchAsync``1(System.Threading.CancellationToken)">
  SearchAsync&lt;TDocument&gt;(CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L31450"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Run a search.
</p>
<p>
Get search hits that match the query defined in the request.
You can provide search queries using the <code>q</code> query string parameter or the request body.
If both are specified, only the query parameter is used.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the read index privilege for the target data stream, index, or alias. For cross-cluster search, refer to the documentation about configuring CCS privileges.
To search a point in time (PIT) for an alias, you must have the <code>read</code> index privilege for the alias's data streams or indices.
</p>
<p>
<strong>Search slicing</strong>
</p>
<p>
When paging through a large number of documents, it can be helpful to split the search into multiple slices to consume them independently with the <code>slice</code> and <code>pit</code> properties.
By default the splitting is done first on the shards, then locally on each shard.
The local splitting partitions the shard into contiguous ranges based on Lucene document IDs.
</p>
<p>
For instance if the number of shards is equal to 2 and you request 4 slices, the slices 0 and 2 are assigned to the first shard and the slices 1 and 3 are assigned to the second shard.
</p>
<p>
IMPORTANT: The same point-in-time ID should be used for all slices.
If different PIT IDs are used, slices can overlap and miss documents.
This situation can occur because the splitting criterion is based on Lucene document IDs, which are not stable across changes to the index.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-search.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;SearchResponse&lt;TDocument&gt;&gt; SearchAsync&lt;TDocument&gt;(CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.SearchResponse-1.html">SearchResponse</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchMvt_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchMvt*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchMvt_Elastic_Clients_Elasticsearch_Indices_Elastic_Clients_Elasticsearch_Field_System_Int32_System_Int32_System_Int32_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchMvt(Elastic.Clients.Elasticsearch.Indices,Elastic.Clients.Elasticsearch.Field,System.Int32,System.Int32,System.Int32)">
  SearchMvt(Indices, Field, int, int, int)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L33321"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Search a vector tile.
</p>
<p>
Search a vector tile for geospatial values.
Before using this API, you should be familiar with the Mapbox vector tile specification.
The API returns results as a binary mapbox vector tile.
</p>
<p>
Internally, Elasticsearch translates a vector tile search API request into a search containing:
</p>
<ul><li>
<p>
A <code>geo_bounding_box</code> query on the <code>&lt;field&gt;</code>. The query uses the <code>&lt;zoom&gt;/&lt;x&gt;/&lt;y&gt;</code> tile as a bounding box.
</p>
</li><li>
<p>
A <code>geotile_grid</code> or <code>geohex_grid</code> aggregation on the <code>&lt;field&gt;</code>. The <code>grid_agg</code> parameter determines the aggregation type. The aggregation uses the <code>&lt;zoom&gt;/&lt;x&gt;/&lt;y&gt;</code> tile as a bounding box.
</p>
</li><li>
<p>
Optionally, a <code>geo_bounds</code> aggregation on the <code>&lt;field&gt;</code>. The search only includes this aggregation if the <code>exact_bounds</code> parameter is <code>true</code>.
</p>
</li><li>
<p>
If the optional parameter <code>with_labels</code> is <code>true</code>, the internal search will include a dynamic runtime field that calls the <code>getLabelPosition</code> function of the geometry doc value. This enables the generation of new point features containing suggested geometry labels, so that, for example, multi-polygons will have only one label.
</p>
</li></ul>
<p>
For example, Elasticsearch may translate a vector tile search API request with a <code>grid_agg</code> argument of <code>geotile</code> and an <code>exact_bounds</code> argument of <code>true</code> into the following search
</p>
<pre><code class="lang-csharp">GET my-index/_search
{
  "size": 10000,
  "query": {
    "geo_bounding_box": {
      "my-geo-field": {
        "top_left": {
          "lat": -40.979898069620134,
          "lon": -45
        },
        "bottom_right": {
          "lat": -66.51326044311186,
          "lon": 0
        }
      }
    }
  },
  "aggregations": {
    "grid": {
      "geotile_grid": {
        "field": "my-geo-field",
        "precision": 11,
        "size": 65536,
        "bounds": {
          "top_left": {
            "lat": -40.979898069620134,
            "lon": -45
          },
          "bottom_right": {
            "lat": -66.51326044311186,
            "lon": 0
          }
        }
      }
    },
    "bounds": {
      "geo_bounds": {
        "field": "my-geo-field",
        "wrap_longitude": false
      }
    }
  }
}</code></pre>
<p>
The API returns results as a binary Mapbox vector tile.
Mapbox vector tiles are encoded as Google Protobufs (PBF). By default, the tile contains three layers:
</p>
<ul><li>
<p>
A <code>hits</code> layer containing a feature for each <code>&lt;field&gt;</code> value matching the <code>geo_bounding_box</code> query.
</p>
</li><li>
<p>
An <code>aggs</code> layer containing a feature for each cell of the <code>geotile_grid</code> or <code>geohex_grid</code>. The layer only contains features for cells with matching data.
</p>
</li><li>
<p>
A meta layer containing:
</p>
<ul><li>
<p>
A feature containing a bounding box. By default, this is the bounding box of the tile.
</p>
</li><li>
<p>
Value ranges for any sub-aggregations on the <code>geotile_grid</code> or <code>geohex_grid</code>.
</p>
</li><li>
<p>
Metadata for the search.
</p>
</li></ul>
</li></ul>
<p>
The API only returns features that can display at its zoom level.
For example, if a polygon feature has no area at its zoom level, the API omits it.
The API returns errors as UTF-8 encoded JSON.
</p>
<p>
IMPORTANT: You can specify several options for this API as either a query parameter or request body parameter.
If you specify both parameters, the query parameter takes precedence.
</p>
<p>
<strong>Grid precision for geotile</strong>
</p>
<p>
For a <code>grid_agg</code> of <code>geotile</code>, you can use cells in the <code>aggs</code> layer as tiles for lower zoom levels.
<code>grid_precision</code> represents the additional zoom levels available through these cells. The final precision is computed by as follows: <code>&lt;zoom&gt; + grid_precision</code>.
For example, if <code>&lt;zoom&gt;</code> is 7 and <code>grid_precision</code> is 8, then the <code>geotile_grid</code> aggregation will use a precision of 15.
The maximum final precision is 29.
The <code>grid_precision</code> also determines the number of cells for the grid as follows: <code>(2^grid_precision) x (2^grid_precision)</code>.
For example, a value of 8 divides the tile into a grid of 256 x 256 cells.
The <code>aggs</code> layer only contains features for cells with matching data.
</p>
<p>
<strong>Grid precision for geohex</strong>
</p>
<p>
For a <code>grid_agg</code> of <code>geohex</code>, Elasticsearch uses <code>&lt;zoom&gt;</code> and <code>grid_precision</code> to calculate a final precision as follows: <code>&lt;zoom&gt; + grid_precision</code>.
</p>
<p>
This precision determines the H3 resolution of the hexagonal cells produced by the <code>geohex</code> aggregation.
The following table maps the H3 resolution for each precision.
For example, if <code>&lt;zoom&gt;</code> is 3 and <code>grid_precision</code> is 3, the precision is 6.
At a precision of 6, hexagonal cells have an H3 resolution of 2.
If <code>&lt;zoom&gt;</code> is 3 and <code>grid_precision</code> is 4, the precision is 7.
At a precision of 7, hexagonal cells have an H3 resolution of 3.
</p>
<p>
| Precision | Unique tile bins | H3 resolution | Unique hex bins |	Ratio |
| --------- | ---------------- | ------------- | ----------------| ----- |
| 1  | 4                  | 0  | 122             | 30.5           |
| 2  | 16                 | 0  | 122             | 7.625          |
| 3  | 64                 | 1  | 842             | 13.15625       |
| 4  | 256                | 1  | 842             | 3.2890625      |
| 5  | 1024               | 2  | 5882            | 5.744140625    |
| 6  | 4096               | 2  | 5882            | 1.436035156    |
| 7  | 16384              | 3  | 41162           | 2.512329102    |
| 8  | 65536              | 3  | 41162           | 0.6280822754   |
| 9  | 262144             | 4  | 288122          | 1.099098206    |
| 10 | 1048576            | 4  | 288122          | 0.2747745514   |
| 11 | 4194304            | 5  | 2016842         | 0.4808526039   |
| 12 | 16777216           | 6  | 14117882        | 0.8414913416   |
| 13 | 67108864           | 6  | 14117882        | 0.2103728354   |
| 14 | 268435456          | 7  | 98825162        | 0.3681524172   |
| 15 | 1073741824         | 8  | 691776122       | 0.644266719    |
| 16 | 4294967296         | 8  | 691776122       | 0.1610666797   |
| 17 | 17179869184        | 9  | 4842432842      | 0.2818666889   |
| 18 | 68719476736        | 10 | 33897029882     | 0.4932667053   |
| 19 | 274877906944       | 11 | 237279209162    | 0.8632167343   |
| 20 | 1099511627776      | 11 | 237279209162    | 0.2158041836   |
| 21 | 4398046511104      | 12 | 1660954464122   | 0.3776573213   |
| 22 | 17592186044416     | 13 | 11626681248842  | 0.6609003122   |
| 23 | 70368744177664     | 13 | 11626681248842  | 0.165225078    |
| 24 | 281474976710656    | 14 | 81386768741882  | 0.2891438866   |
| 25 | 1125899906842620   | 15 | 569707381193162 | 0.5060018015   |
| 26 | 4503599627370500   | 15 | 569707381193162 | 0.1265004504   |
| 27 | 18014398509482000  | 15 | 569707381193162 | 0.03162511259  |
| 28 | 72057594037927900  | 15 | 569707381193162 | 0.007906278149 |
| 29 | 288230376151712000 | 15 | 569707381193162 | 0.001976569537 |
</p>
<p>
Hexagonal cells don't align perfectly on a vector tile.
Some cells may intersect more than one vector tile.
To compute the H3 resolution for each precision, Elasticsearch compares the average density of hexagonal bins at each resolution with the average density of tile bins at each zoom level.
Elasticsearch uses the H3 resolution that is closest to the corresponding geotile density.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-vector-tile-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual SearchMvtResponse SearchMvt(Indices indices, Field field, int zoom, int x, int y)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>indices</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Indices.html">Indices</a></dt>
    <dd></dd>
    <dt><code>field</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Field.html">Field</a></dt>
    <dd></dd>
    <dt><code>zoom</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd></dd>
    <dt><code>x</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd></dd>
    <dt><code>y</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.SearchMvtResponse.html">SearchMvtResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchMvt_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchMvt*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchMvt_Elastic_Clients_Elasticsearch_Indices_Elastic_Clients_Elasticsearch_Field_System_Int32_System_Int32_System_Int32_System_Action_Elastic_Clients_Elasticsearch_SearchMvtRequestDescriptor__" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchMvt(Elastic.Clients.Elasticsearch.Indices,Elastic.Clients.Elasticsearch.Field,System.Int32,System.Int32,System.Int32,System.Action{Elastic.Clients.Elasticsearch.SearchMvtRequestDescriptor})">
  SearchMvt(Indices, Field, int, int, int, Action&lt;SearchMvtRequestDescriptor&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L33525"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Search a vector tile.
</p>
<p>
Search a vector tile for geospatial values.
Before using this API, you should be familiar with the Mapbox vector tile specification.
The API returns results as a binary mapbox vector tile.
</p>
<p>
Internally, Elasticsearch translates a vector tile search API request into a search containing:
</p>
<ul><li>
<p>
A <code>geo_bounding_box</code> query on the <code>&lt;field&gt;</code>. The query uses the <code>&lt;zoom&gt;/&lt;x&gt;/&lt;y&gt;</code> tile as a bounding box.
</p>
</li><li>
<p>
A <code>geotile_grid</code> or <code>geohex_grid</code> aggregation on the <code>&lt;field&gt;</code>. The <code>grid_agg</code> parameter determines the aggregation type. The aggregation uses the <code>&lt;zoom&gt;/&lt;x&gt;/&lt;y&gt;</code> tile as a bounding box.
</p>
</li><li>
<p>
Optionally, a <code>geo_bounds</code> aggregation on the <code>&lt;field&gt;</code>. The search only includes this aggregation if the <code>exact_bounds</code> parameter is <code>true</code>.
</p>
</li><li>
<p>
If the optional parameter <code>with_labels</code> is <code>true</code>, the internal search will include a dynamic runtime field that calls the <code>getLabelPosition</code> function of the geometry doc value. This enables the generation of new point features containing suggested geometry labels, so that, for example, multi-polygons will have only one label.
</p>
</li></ul>
<p>
For example, Elasticsearch may translate a vector tile search API request with a <code>grid_agg</code> argument of <code>geotile</code> and an <code>exact_bounds</code> argument of <code>true</code> into the following search
</p>
<pre><code class="lang-csharp">GET my-index/_search
{
  "size": 10000,
  "query": {
    "geo_bounding_box": {
      "my-geo-field": {
        "top_left": {
          "lat": -40.979898069620134,
          "lon": -45
        },
        "bottom_right": {
          "lat": -66.51326044311186,
          "lon": 0
        }
      }
    }
  },
  "aggregations": {
    "grid": {
      "geotile_grid": {
        "field": "my-geo-field",
        "precision": 11,
        "size": 65536,
        "bounds": {
          "top_left": {
            "lat": -40.979898069620134,
            "lon": -45
          },
          "bottom_right": {
            "lat": -66.51326044311186,
            "lon": 0
          }
        }
      }
    },
    "bounds": {
      "geo_bounds": {
        "field": "my-geo-field",
        "wrap_longitude": false
      }
    }
  }
}</code></pre>
<p>
The API returns results as a binary Mapbox vector tile.
Mapbox vector tiles are encoded as Google Protobufs (PBF). By default, the tile contains three layers:
</p>
<ul><li>
<p>
A <code>hits</code> layer containing a feature for each <code>&lt;field&gt;</code> value matching the <code>geo_bounding_box</code> query.
</p>
</li><li>
<p>
An <code>aggs</code> layer containing a feature for each cell of the <code>geotile_grid</code> or <code>geohex_grid</code>. The layer only contains features for cells with matching data.
</p>
</li><li>
<p>
A meta layer containing:
</p>
<ul><li>
<p>
A feature containing a bounding box. By default, this is the bounding box of the tile.
</p>
</li><li>
<p>
Value ranges for any sub-aggregations on the <code>geotile_grid</code> or <code>geohex_grid</code>.
</p>
</li><li>
<p>
Metadata for the search.
</p>
</li></ul>
</li></ul>
<p>
The API only returns features that can display at its zoom level.
For example, if a polygon feature has no area at its zoom level, the API omits it.
The API returns errors as UTF-8 encoded JSON.
</p>
<p>
IMPORTANT: You can specify several options for this API as either a query parameter or request body parameter.
If you specify both parameters, the query parameter takes precedence.
</p>
<p>
<strong>Grid precision for geotile</strong>
</p>
<p>
For a <code>grid_agg</code> of <code>geotile</code>, you can use cells in the <code>aggs</code> layer as tiles for lower zoom levels.
<code>grid_precision</code> represents the additional zoom levels available through these cells. The final precision is computed by as follows: <code>&lt;zoom&gt; + grid_precision</code>.
For example, if <code>&lt;zoom&gt;</code> is 7 and <code>grid_precision</code> is 8, then the <code>geotile_grid</code> aggregation will use a precision of 15.
The maximum final precision is 29.
The <code>grid_precision</code> also determines the number of cells for the grid as follows: <code>(2^grid_precision) x (2^grid_precision)</code>.
For example, a value of 8 divides the tile into a grid of 256 x 256 cells.
The <code>aggs</code> layer only contains features for cells with matching data.
</p>
<p>
<strong>Grid precision for geohex</strong>
</p>
<p>
For a <code>grid_agg</code> of <code>geohex</code>, Elasticsearch uses <code>&lt;zoom&gt;</code> and <code>grid_precision</code> to calculate a final precision as follows: <code>&lt;zoom&gt; + grid_precision</code>.
</p>
<p>
This precision determines the H3 resolution of the hexagonal cells produced by the <code>geohex</code> aggregation.
The following table maps the H3 resolution for each precision.
For example, if <code>&lt;zoom&gt;</code> is 3 and <code>grid_precision</code> is 3, the precision is 6.
At a precision of 6, hexagonal cells have an H3 resolution of 2.
If <code>&lt;zoom&gt;</code> is 3 and <code>grid_precision</code> is 4, the precision is 7.
At a precision of 7, hexagonal cells have an H3 resolution of 3.
</p>
<p>
| Precision | Unique tile bins | H3 resolution | Unique hex bins |	Ratio |
| --------- | ---------------- | ------------- | ----------------| ----- |
| 1  | 4                  | 0  | 122             | 30.5           |
| 2  | 16                 | 0  | 122             | 7.625          |
| 3  | 64                 | 1  | 842             | 13.15625       |
| 4  | 256                | 1  | 842             | 3.2890625      |
| 5  | 1024               | 2  | 5882            | 5.744140625    |
| 6  | 4096               | 2  | 5882            | 1.436035156    |
| 7  | 16384              | 3  | 41162           | 2.512329102    |
| 8  | 65536              | 3  | 41162           | 0.6280822754   |
| 9  | 262144             | 4  | 288122          | 1.099098206    |
| 10 | 1048576            | 4  | 288122          | 0.2747745514   |
| 11 | 4194304            | 5  | 2016842         | 0.4808526039   |
| 12 | 16777216           | 6  | 14117882        | 0.8414913416   |
| 13 | 67108864           | 6  | 14117882        | 0.2103728354   |
| 14 | 268435456          | 7  | 98825162        | 0.3681524172   |
| 15 | 1073741824         | 8  | 691776122       | 0.644266719    |
| 16 | 4294967296         | 8  | 691776122       | 0.1610666797   |
| 17 | 17179869184        | 9  | 4842432842      | 0.2818666889   |
| 18 | 68719476736        | 10 | 33897029882     | 0.4932667053   |
| 19 | 274877906944       | 11 | 237279209162    | 0.8632167343   |
| 20 | 1099511627776      | 11 | 237279209162    | 0.2158041836   |
| 21 | 4398046511104      | 12 | 1660954464122   | 0.3776573213   |
| 22 | 17592186044416     | 13 | 11626681248842  | 0.6609003122   |
| 23 | 70368744177664     | 13 | 11626681248842  | 0.165225078    |
| 24 | 281474976710656    | 14 | 81386768741882  | 0.2891438866   |
| 25 | 1125899906842620   | 15 | 569707381193162 | 0.5060018015   |
| 26 | 4503599627370500   | 15 | 569707381193162 | 0.1265004504   |
| 27 | 18014398509482000  | 15 | 569707381193162 | 0.03162511259  |
| 28 | 72057594037927900  | 15 | 569707381193162 | 0.007906278149 |
| 29 | 288230376151712000 | 15 | 569707381193162 | 0.001976569537 |
</p>
<p>
Hexagonal cells don't align perfectly on a vector tile.
Some cells may intersect more than one vector tile.
To compute the H3 resolution for each precision, Elasticsearch compares the average density of hexagonal bins at each resolution with the average density of tile bins at each zoom level.
Elasticsearch uses the H3 resolution that is closest to the corresponding geotile density.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-vector-tile-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual SearchMvtResponse SearchMvt(Indices indices, Field field, int zoom, int x, int y, Action&lt;SearchMvtRequestDescriptor&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>indices</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Indices.html">Indices</a></dt>
    <dd></dd>
    <dt><code>field</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Field.html">Field</a></dt>
    <dd></dd>
    <dt><code>zoom</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd></dd>
    <dt><code>x</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd></dd>
    <dt><code>y</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.SearchMvtRequestDescriptor.html">SearchMvtRequestDescriptor</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.SearchMvtResponse.html">SearchMvtResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchMvt_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchMvt*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchMvt_Elastic_Clients_Elasticsearch_SearchMvtRequest_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchMvt(Elastic.Clients.Elasticsearch.SearchMvtRequest)">
  SearchMvt(SearchMvtRequest)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L31692"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Search a vector tile.
</p>
<p>
Search a vector tile for geospatial values.
Before using this API, you should be familiar with the Mapbox vector tile specification.
The API returns results as a binary mapbox vector tile.
</p>
<p>
Internally, Elasticsearch translates a vector tile search API request into a search containing:
</p>
<ul><li>
<p>
A <code>geo_bounding_box</code> query on the <code>&lt;field&gt;</code>. The query uses the <code>&lt;zoom&gt;/&lt;x&gt;/&lt;y&gt;</code> tile as a bounding box.
</p>
</li><li>
<p>
A <code>geotile_grid</code> or <code>geohex_grid</code> aggregation on the <code>&lt;field&gt;</code>. The <code>grid_agg</code> parameter determines the aggregation type. The aggregation uses the <code>&lt;zoom&gt;/&lt;x&gt;/&lt;y&gt;</code> tile as a bounding box.
</p>
</li><li>
<p>
Optionally, a <code>geo_bounds</code> aggregation on the <code>&lt;field&gt;</code>. The search only includes this aggregation if the <code>exact_bounds</code> parameter is <code>true</code>.
</p>
</li><li>
<p>
If the optional parameter <code>with_labels</code> is <code>true</code>, the internal search will include a dynamic runtime field that calls the <code>getLabelPosition</code> function of the geometry doc value. This enables the generation of new point features containing suggested geometry labels, so that, for example, multi-polygons will have only one label.
</p>
</li></ul>
<p>
For example, Elasticsearch may translate a vector tile search API request with a <code>grid_agg</code> argument of <code>geotile</code> and an <code>exact_bounds</code> argument of <code>true</code> into the following search
</p>
<pre><code class="lang-csharp">GET my-index/_search
{
  "size": 10000,
  "query": {
    "geo_bounding_box": {
      "my-geo-field": {
        "top_left": {
          "lat": -40.979898069620134,
          "lon": -45
        },
        "bottom_right": {
          "lat": -66.51326044311186,
          "lon": 0
        }
      }
    }
  },
  "aggregations": {
    "grid": {
      "geotile_grid": {
        "field": "my-geo-field",
        "precision": 11,
        "size": 65536,
        "bounds": {
          "top_left": {
            "lat": -40.979898069620134,
            "lon": -45
          },
          "bottom_right": {
            "lat": -66.51326044311186,
            "lon": 0
          }
        }
      }
    },
    "bounds": {
      "geo_bounds": {
        "field": "my-geo-field",
        "wrap_longitude": false
      }
    }
  }
}</code></pre>
<p>
The API returns results as a binary Mapbox vector tile.
Mapbox vector tiles are encoded as Google Protobufs (PBF). By default, the tile contains three layers:
</p>
<ul><li>
<p>
A <code>hits</code> layer containing a feature for each <code>&lt;field&gt;</code> value matching the <code>geo_bounding_box</code> query.
</p>
</li><li>
<p>
An <code>aggs</code> layer containing a feature for each cell of the <code>geotile_grid</code> or <code>geohex_grid</code>. The layer only contains features for cells with matching data.
</p>
</li><li>
<p>
A meta layer containing:
</p>
<ul><li>
<p>
A feature containing a bounding box. By default, this is the bounding box of the tile.
</p>
</li><li>
<p>
Value ranges for any sub-aggregations on the <code>geotile_grid</code> or <code>geohex_grid</code>.
</p>
</li><li>
<p>
Metadata for the search.
</p>
</li></ul>
</li></ul>
<p>
The API only returns features that can display at its zoom level.
For example, if a polygon feature has no area at its zoom level, the API omits it.
The API returns errors as UTF-8 encoded JSON.
</p>
<p>
IMPORTANT: You can specify several options for this API as either a query parameter or request body parameter.
If you specify both parameters, the query parameter takes precedence.
</p>
<p>
<strong>Grid precision for geotile</strong>
</p>
<p>
For a <code>grid_agg</code> of <code>geotile</code>, you can use cells in the <code>aggs</code> layer as tiles for lower zoom levels.
<code>grid_precision</code> represents the additional zoom levels available through these cells. The final precision is computed by as follows: <code>&lt;zoom&gt; + grid_precision</code>.
For example, if <code>&lt;zoom&gt;</code> is 7 and <code>grid_precision</code> is 8, then the <code>geotile_grid</code> aggregation will use a precision of 15.
The maximum final precision is 29.
The <code>grid_precision</code> also determines the number of cells for the grid as follows: <code>(2^grid_precision) x (2^grid_precision)</code>.
For example, a value of 8 divides the tile into a grid of 256 x 256 cells.
The <code>aggs</code> layer only contains features for cells with matching data.
</p>
<p>
<strong>Grid precision for geohex</strong>
</p>
<p>
For a <code>grid_agg</code> of <code>geohex</code>, Elasticsearch uses <code>&lt;zoom&gt;</code> and <code>grid_precision</code> to calculate a final precision as follows: <code>&lt;zoom&gt; + grid_precision</code>.
</p>
<p>
This precision determines the H3 resolution of the hexagonal cells produced by the <code>geohex</code> aggregation.
The following table maps the H3 resolution for each precision.
For example, if <code>&lt;zoom&gt;</code> is 3 and <code>grid_precision</code> is 3, the precision is 6.
At a precision of 6, hexagonal cells have an H3 resolution of 2.
If <code>&lt;zoom&gt;</code> is 3 and <code>grid_precision</code> is 4, the precision is 7.
At a precision of 7, hexagonal cells have an H3 resolution of 3.
</p>
<p>
| Precision | Unique tile bins | H3 resolution | Unique hex bins |	Ratio |
| --------- | ---------------- | ------------- | ----------------| ----- |
| 1  | 4                  | 0  | 122             | 30.5           |
| 2  | 16                 | 0  | 122             | 7.625          |
| 3  | 64                 | 1  | 842             | 13.15625       |
| 4  | 256                | 1  | 842             | 3.2890625      |
| 5  | 1024               | 2  | 5882            | 5.744140625    |
| 6  | 4096               | 2  | 5882            | 1.436035156    |
| 7  | 16384              | 3  | 41162           | 2.512329102    |
| 8  | 65536              | 3  | 41162           | 0.6280822754   |
| 9  | 262144             | 4  | 288122          | 1.099098206    |
| 10 | 1048576            | 4  | 288122          | 0.2747745514   |
| 11 | 4194304            | 5  | 2016842         | 0.4808526039   |
| 12 | 16777216           | 6  | 14117882        | 0.8414913416   |
| 13 | 67108864           | 6  | 14117882        | 0.2103728354   |
| 14 | 268435456          | 7  | 98825162        | 0.3681524172   |
| 15 | 1073741824         | 8  | 691776122       | 0.644266719    |
| 16 | 4294967296         | 8  | 691776122       | 0.1610666797   |
| 17 | 17179869184        | 9  | 4842432842      | 0.2818666889   |
| 18 | 68719476736        | 10 | 33897029882     | 0.4932667053   |
| 19 | 274877906944       | 11 | 237279209162    | 0.8632167343   |
| 20 | 1099511627776      | 11 | 237279209162    | 0.2158041836   |
| 21 | 4398046511104      | 12 | 1660954464122   | 0.3776573213   |
| 22 | 17592186044416     | 13 | 11626681248842  | 0.6609003122   |
| 23 | 70368744177664     | 13 | 11626681248842  | 0.165225078    |
| 24 | 281474976710656    | 14 | 81386768741882  | 0.2891438866   |
| 25 | 1125899906842620   | 15 | 569707381193162 | 0.5060018015   |
| 26 | 4503599627370500   | 15 | 569707381193162 | 0.1265004504   |
| 27 | 18014398509482000  | 15 | 569707381193162 | 0.03162511259  |
| 28 | 72057594037927900  | 15 | 569707381193162 | 0.007906278149 |
| 29 | 288230376151712000 | 15 | 569707381193162 | 0.001976569537 |
</p>
<p>
Hexagonal cells don't align perfectly on a vector tile.
Some cells may intersect more than one vector tile.
To compute the H3 resolution for each precision, Elasticsearch compares the average density of hexagonal bins at each resolution with the average density of tile bins at each zoom level.
Elasticsearch uses the H3 resolution that is closest to the corresponding geotile density.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-vector-tile-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual SearchMvtResponse SearchMvt(SearchMvtRequest request)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.SearchMvtRequest.html">SearchMvtRequest</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.SearchMvtResponse.html">SearchMvtResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchMvt_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchMvt*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchMvt_Elastic_Clients_Elasticsearch_SearchMvtRequestDescriptor_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchMvt(Elastic.Clients.Elasticsearch.SearchMvtRequestDescriptor)">
  SearchMvt(SearchMvtRequestDescriptor)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L33118"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Search a vector tile.
</p>
<p>
Search a vector tile for geospatial values.
Before using this API, you should be familiar with the Mapbox vector tile specification.
The API returns results as a binary mapbox vector tile.
</p>
<p>
Internally, Elasticsearch translates a vector tile search API request into a search containing:
</p>
<ul><li>
<p>
A <code>geo_bounding_box</code> query on the <code>&lt;field&gt;</code>. The query uses the <code>&lt;zoom&gt;/&lt;x&gt;/&lt;y&gt;</code> tile as a bounding box.
</p>
</li><li>
<p>
A <code>geotile_grid</code> or <code>geohex_grid</code> aggregation on the <code>&lt;field&gt;</code>. The <code>grid_agg</code> parameter determines the aggregation type. The aggregation uses the <code>&lt;zoom&gt;/&lt;x&gt;/&lt;y&gt;</code> tile as a bounding box.
</p>
</li><li>
<p>
Optionally, a <code>geo_bounds</code> aggregation on the <code>&lt;field&gt;</code>. The search only includes this aggregation if the <code>exact_bounds</code> parameter is <code>true</code>.
</p>
</li><li>
<p>
If the optional parameter <code>with_labels</code> is <code>true</code>, the internal search will include a dynamic runtime field that calls the <code>getLabelPosition</code> function of the geometry doc value. This enables the generation of new point features containing suggested geometry labels, so that, for example, multi-polygons will have only one label.
</p>
</li></ul>
<p>
For example, Elasticsearch may translate a vector tile search API request with a <code>grid_agg</code> argument of <code>geotile</code> and an <code>exact_bounds</code> argument of <code>true</code> into the following search
</p>
<pre><code class="lang-csharp">GET my-index/_search
{
  "size": 10000,
  "query": {
    "geo_bounding_box": {
      "my-geo-field": {
        "top_left": {
          "lat": -40.979898069620134,
          "lon": -45
        },
        "bottom_right": {
          "lat": -66.51326044311186,
          "lon": 0
        }
      }
    }
  },
  "aggregations": {
    "grid": {
      "geotile_grid": {
        "field": "my-geo-field",
        "precision": 11,
        "size": 65536,
        "bounds": {
          "top_left": {
            "lat": -40.979898069620134,
            "lon": -45
          },
          "bottom_right": {
            "lat": -66.51326044311186,
            "lon": 0
          }
        }
      }
    },
    "bounds": {
      "geo_bounds": {
        "field": "my-geo-field",
        "wrap_longitude": false
      }
    }
  }
}</code></pre>
<p>
The API returns results as a binary Mapbox vector tile.
Mapbox vector tiles are encoded as Google Protobufs (PBF). By default, the tile contains three layers:
</p>
<ul><li>
<p>
A <code>hits</code> layer containing a feature for each <code>&lt;field&gt;</code> value matching the <code>geo_bounding_box</code> query.
</p>
</li><li>
<p>
An <code>aggs</code> layer containing a feature for each cell of the <code>geotile_grid</code> or <code>geohex_grid</code>. The layer only contains features for cells with matching data.
</p>
</li><li>
<p>
A meta layer containing:
</p>
<ul><li>
<p>
A feature containing a bounding box. By default, this is the bounding box of the tile.
</p>
</li><li>
<p>
Value ranges for any sub-aggregations on the <code>geotile_grid</code> or <code>geohex_grid</code>.
</p>
</li><li>
<p>
Metadata for the search.
</p>
</li></ul>
</li></ul>
<p>
The API only returns features that can display at its zoom level.
For example, if a polygon feature has no area at its zoom level, the API omits it.
The API returns errors as UTF-8 encoded JSON.
</p>
<p>
IMPORTANT: You can specify several options for this API as either a query parameter or request body parameter.
If you specify both parameters, the query parameter takes precedence.
</p>
<p>
<strong>Grid precision for geotile</strong>
</p>
<p>
For a <code>grid_agg</code> of <code>geotile</code>, you can use cells in the <code>aggs</code> layer as tiles for lower zoom levels.
<code>grid_precision</code> represents the additional zoom levels available through these cells. The final precision is computed by as follows: <code>&lt;zoom&gt; + grid_precision</code>.
For example, if <code>&lt;zoom&gt;</code> is 7 and <code>grid_precision</code> is 8, then the <code>geotile_grid</code> aggregation will use a precision of 15.
The maximum final precision is 29.
The <code>grid_precision</code> also determines the number of cells for the grid as follows: <code>(2^grid_precision) x (2^grid_precision)</code>.
For example, a value of 8 divides the tile into a grid of 256 x 256 cells.
The <code>aggs</code> layer only contains features for cells with matching data.
</p>
<p>
<strong>Grid precision for geohex</strong>
</p>
<p>
For a <code>grid_agg</code> of <code>geohex</code>, Elasticsearch uses <code>&lt;zoom&gt;</code> and <code>grid_precision</code> to calculate a final precision as follows: <code>&lt;zoom&gt; + grid_precision</code>.
</p>
<p>
This precision determines the H3 resolution of the hexagonal cells produced by the <code>geohex</code> aggregation.
The following table maps the H3 resolution for each precision.
For example, if <code>&lt;zoom&gt;</code> is 3 and <code>grid_precision</code> is 3, the precision is 6.
At a precision of 6, hexagonal cells have an H3 resolution of 2.
If <code>&lt;zoom&gt;</code> is 3 and <code>grid_precision</code> is 4, the precision is 7.
At a precision of 7, hexagonal cells have an H3 resolution of 3.
</p>
<p>
| Precision | Unique tile bins | H3 resolution | Unique hex bins |	Ratio |
| --------- | ---------------- | ------------- | ----------------| ----- |
| 1  | 4                  | 0  | 122             | 30.5           |
| 2  | 16                 | 0  | 122             | 7.625          |
| 3  | 64                 | 1  | 842             | 13.15625       |
| 4  | 256                | 1  | 842             | 3.2890625      |
| 5  | 1024               | 2  | 5882            | 5.744140625    |
| 6  | 4096               | 2  | 5882            | 1.436035156    |
| 7  | 16384              | 3  | 41162           | 2.512329102    |
| 8  | 65536              | 3  | 41162           | 0.6280822754   |
| 9  | 262144             | 4  | 288122          | 1.099098206    |
| 10 | 1048576            | 4  | 288122          | 0.2747745514   |
| 11 | 4194304            | 5  | 2016842         | 0.4808526039   |
| 12 | 16777216           | 6  | 14117882        | 0.8414913416   |
| 13 | 67108864           | 6  | 14117882        | 0.2103728354   |
| 14 | 268435456          | 7  | 98825162        | 0.3681524172   |
| 15 | 1073741824         | 8  | 691776122       | 0.644266719    |
| 16 | 4294967296         | 8  | 691776122       | 0.1610666797   |
| 17 | 17179869184        | 9  | 4842432842      | 0.2818666889   |
| 18 | 68719476736        | 10 | 33897029882     | 0.4932667053   |
| 19 | 274877906944       | 11 | 237279209162    | 0.8632167343   |
| 20 | 1099511627776      | 11 | 237279209162    | 0.2158041836   |
| 21 | 4398046511104      | 12 | 1660954464122   | 0.3776573213   |
| 22 | 17592186044416     | 13 | 11626681248842  | 0.6609003122   |
| 23 | 70368744177664     | 13 | 11626681248842  | 0.165225078    |
| 24 | 281474976710656    | 14 | 81386768741882  | 0.2891438866   |
| 25 | 1125899906842620   | 15 | 569707381193162 | 0.5060018015   |
| 26 | 4503599627370500   | 15 | 569707381193162 | 0.1265004504   |
| 27 | 18014398509482000  | 15 | 569707381193162 | 0.03162511259  |
| 28 | 72057594037927900  | 15 | 569707381193162 | 0.007906278149 |
| 29 | 288230376151712000 | 15 | 569707381193162 | 0.001976569537 |
</p>
<p>
Hexagonal cells don't align perfectly on a vector tile.
Some cells may intersect more than one vector tile.
To compute the H3 resolution for each precision, Elasticsearch compares the average density of hexagonal bins at each resolution with the average density of tile bins at each zoom level.
Elasticsearch uses the H3 resolution that is closest to the corresponding geotile density.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-vector-tile-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual SearchMvtResponse SearchMvt(SearchMvtRequestDescriptor descriptor)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.SearchMvtRequestDescriptor.html">SearchMvtRequestDescriptor</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.SearchMvtResponse.html">SearchMvtResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchMvtAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchMvtAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchMvtAsync_Elastic_Clients_Elasticsearch_Indices_Elastic_Clients_Elasticsearch_Field_System_Int32_System_Int32_System_Int32_System_Action_Elastic_Clients_Elasticsearch_SearchMvtRequestDescriptor__System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchMvtAsync(Elastic.Clients.Elasticsearch.Indices,Elastic.Clients.Elasticsearch.Field,System.Int32,System.Int32,System.Int32,System.Action{Elastic.Clients.Elasticsearch.SearchMvtRequestDescriptor},System.Threading.CancellationToken)">
  SearchMvtAsync(Indices, Field, int, int, int, Action&lt;SearchMvtRequestDescriptor&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L35151"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Search a vector tile.
</p>
<p>
Search a vector tile for geospatial values.
Before using this API, you should be familiar with the Mapbox vector tile specification.
The API returns results as a binary mapbox vector tile.
</p>
<p>
Internally, Elasticsearch translates a vector tile search API request into a search containing:
</p>
<ul><li>
<p>
A <code>geo_bounding_box</code> query on the <code>&lt;field&gt;</code>. The query uses the <code>&lt;zoom&gt;/&lt;x&gt;/&lt;y&gt;</code> tile as a bounding box.
</p>
</li><li>
<p>
A <code>geotile_grid</code> or <code>geohex_grid</code> aggregation on the <code>&lt;field&gt;</code>. The <code>grid_agg</code> parameter determines the aggregation type. The aggregation uses the <code>&lt;zoom&gt;/&lt;x&gt;/&lt;y&gt;</code> tile as a bounding box.
</p>
</li><li>
<p>
Optionally, a <code>geo_bounds</code> aggregation on the <code>&lt;field&gt;</code>. The search only includes this aggregation if the <code>exact_bounds</code> parameter is <code>true</code>.
</p>
</li><li>
<p>
If the optional parameter <code>with_labels</code> is <code>true</code>, the internal search will include a dynamic runtime field that calls the <code>getLabelPosition</code> function of the geometry doc value. This enables the generation of new point features containing suggested geometry labels, so that, for example, multi-polygons will have only one label.
</p>
</li></ul>
<p>
For example, Elasticsearch may translate a vector tile search API request with a <code>grid_agg</code> argument of <code>geotile</code> and an <code>exact_bounds</code> argument of <code>true</code> into the following search
</p>
<pre><code class="lang-csharp">GET my-index/_search
{
  "size": 10000,
  "query": {
    "geo_bounding_box": {
      "my-geo-field": {
        "top_left": {
          "lat": -40.979898069620134,
          "lon": -45
        },
        "bottom_right": {
          "lat": -66.51326044311186,
          "lon": 0
        }
      }
    }
  },
  "aggregations": {
    "grid": {
      "geotile_grid": {
        "field": "my-geo-field",
        "precision": 11,
        "size": 65536,
        "bounds": {
          "top_left": {
            "lat": -40.979898069620134,
            "lon": -45
          },
          "bottom_right": {
            "lat": -66.51326044311186,
            "lon": 0
          }
        }
      }
    },
    "bounds": {
      "geo_bounds": {
        "field": "my-geo-field",
        "wrap_longitude": false
      }
    }
  }
}</code></pre>
<p>
The API returns results as a binary Mapbox vector tile.
Mapbox vector tiles are encoded as Google Protobufs (PBF). By default, the tile contains three layers:
</p>
<ul><li>
<p>
A <code>hits</code> layer containing a feature for each <code>&lt;field&gt;</code> value matching the <code>geo_bounding_box</code> query.
</p>
</li><li>
<p>
An <code>aggs</code> layer containing a feature for each cell of the <code>geotile_grid</code> or <code>geohex_grid</code>. The layer only contains features for cells with matching data.
</p>
</li><li>
<p>
A meta layer containing:
</p>
<ul><li>
<p>
A feature containing a bounding box. By default, this is the bounding box of the tile.
</p>
</li><li>
<p>
Value ranges for any sub-aggregations on the <code>geotile_grid</code> or <code>geohex_grid</code>.
</p>
</li><li>
<p>
Metadata for the search.
</p>
</li></ul>
</li></ul>
<p>
The API only returns features that can display at its zoom level.
For example, if a polygon feature has no area at its zoom level, the API omits it.
The API returns errors as UTF-8 encoded JSON.
</p>
<p>
IMPORTANT: You can specify several options for this API as either a query parameter or request body parameter.
If you specify both parameters, the query parameter takes precedence.
</p>
<p>
<strong>Grid precision for geotile</strong>
</p>
<p>
For a <code>grid_agg</code> of <code>geotile</code>, you can use cells in the <code>aggs</code> layer as tiles for lower zoom levels.
<code>grid_precision</code> represents the additional zoom levels available through these cells. The final precision is computed by as follows: <code>&lt;zoom&gt; + grid_precision</code>.
For example, if <code>&lt;zoom&gt;</code> is 7 and <code>grid_precision</code> is 8, then the <code>geotile_grid</code> aggregation will use a precision of 15.
The maximum final precision is 29.
The <code>grid_precision</code> also determines the number of cells for the grid as follows: <code>(2^grid_precision) x (2^grid_precision)</code>.
For example, a value of 8 divides the tile into a grid of 256 x 256 cells.
The <code>aggs</code> layer only contains features for cells with matching data.
</p>
<p>
<strong>Grid precision for geohex</strong>
</p>
<p>
For a <code>grid_agg</code> of <code>geohex</code>, Elasticsearch uses <code>&lt;zoom&gt;</code> and <code>grid_precision</code> to calculate a final precision as follows: <code>&lt;zoom&gt; + grid_precision</code>.
</p>
<p>
This precision determines the H3 resolution of the hexagonal cells produced by the <code>geohex</code> aggregation.
The following table maps the H3 resolution for each precision.
For example, if <code>&lt;zoom&gt;</code> is 3 and <code>grid_precision</code> is 3, the precision is 6.
At a precision of 6, hexagonal cells have an H3 resolution of 2.
If <code>&lt;zoom&gt;</code> is 3 and <code>grid_precision</code> is 4, the precision is 7.
At a precision of 7, hexagonal cells have an H3 resolution of 3.
</p>
<p>
| Precision | Unique tile bins | H3 resolution | Unique hex bins |	Ratio |
| --------- | ---------------- | ------------- | ----------------| ----- |
| 1  | 4                  | 0  | 122             | 30.5           |
| 2  | 16                 | 0  | 122             | 7.625          |
| 3  | 64                 | 1  | 842             | 13.15625       |
| 4  | 256                | 1  | 842             | 3.2890625      |
| 5  | 1024               | 2  | 5882            | 5.744140625    |
| 6  | 4096               | 2  | 5882            | 1.436035156    |
| 7  | 16384              | 3  | 41162           | 2.512329102    |
| 8  | 65536              | 3  | 41162           | 0.6280822754   |
| 9  | 262144             | 4  | 288122          | 1.099098206    |
| 10 | 1048576            | 4  | 288122          | 0.2747745514   |
| 11 | 4194304            | 5  | 2016842         | 0.4808526039   |
| 12 | 16777216           | 6  | 14117882        | 0.8414913416   |
| 13 | 67108864           | 6  | 14117882        | 0.2103728354   |
| 14 | 268435456          | 7  | 98825162        | 0.3681524172   |
| 15 | 1073741824         | 8  | 691776122       | 0.644266719    |
| 16 | 4294967296         | 8  | 691776122       | 0.1610666797   |
| 17 | 17179869184        | 9  | 4842432842      | 0.2818666889   |
| 18 | 68719476736        | 10 | 33897029882     | 0.4932667053   |
| 19 | 274877906944       | 11 | 237279209162    | 0.8632167343   |
| 20 | 1099511627776      | 11 | 237279209162    | 0.2158041836   |
| 21 | 4398046511104      | 12 | 1660954464122   | 0.3776573213   |
| 22 | 17592186044416     | 13 | 11626681248842  | 0.6609003122   |
| 23 | 70368744177664     | 13 | 11626681248842  | 0.165225078    |
| 24 | 281474976710656    | 14 | 81386768741882  | 0.2891438866   |
| 25 | 1125899906842620   | 15 | 569707381193162 | 0.5060018015   |
| 26 | 4503599627370500   | 15 | 569707381193162 | 0.1265004504   |
| 27 | 18014398509482000  | 15 | 569707381193162 | 0.03162511259  |
| 28 | 72057594037927900  | 15 | 569707381193162 | 0.007906278149 |
| 29 | 288230376151712000 | 15 | 569707381193162 | 0.001976569537 |
</p>
<p>
Hexagonal cells don't align perfectly on a vector tile.
Some cells may intersect more than one vector tile.
To compute the H3 resolution for each precision, Elasticsearch compares the average density of hexagonal bins at each resolution with the average density of tile bins at each zoom level.
Elasticsearch uses the H3 resolution that is closest to the corresponding geotile density.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-vector-tile-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;SearchMvtResponse&gt; SearchMvtAsync(Indices indices, Field field, int zoom, int x, int y, Action&lt;SearchMvtRequestDescriptor&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>indices</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Indices.html">Indices</a></dt>
    <dd></dd>
    <dt><code>field</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Field.html">Field</a></dt>
    <dd></dd>
    <dt><code>zoom</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd></dd>
    <dt><code>x</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd></dd>
    <dt><code>y</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.SearchMvtRequestDescriptor.html">SearchMvtRequestDescriptor</a>&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.SearchMvtResponse.html">SearchMvtResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchMvtAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchMvtAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchMvtAsync_Elastic_Clients_Elasticsearch_Indices_Elastic_Clients_Elasticsearch_Field_System_Int32_System_Int32_System_Int32_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchMvtAsync(Elastic.Clients.Elasticsearch.Indices,Elastic.Clients.Elasticsearch.Field,System.Int32,System.Int32,System.Int32,System.Threading.CancellationToken)">
  SearchMvtAsync(Indices, Field, int, int, int, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L34948"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Search a vector tile.
</p>
<p>
Search a vector tile for geospatial values.
Before using this API, you should be familiar with the Mapbox vector tile specification.
The API returns results as a binary mapbox vector tile.
</p>
<p>
Internally, Elasticsearch translates a vector tile search API request into a search containing:
</p>
<ul><li>
<p>
A <code>geo_bounding_box</code> query on the <code>&lt;field&gt;</code>. The query uses the <code>&lt;zoom&gt;/&lt;x&gt;/&lt;y&gt;</code> tile as a bounding box.
</p>
</li><li>
<p>
A <code>geotile_grid</code> or <code>geohex_grid</code> aggregation on the <code>&lt;field&gt;</code>. The <code>grid_agg</code> parameter determines the aggregation type. The aggregation uses the <code>&lt;zoom&gt;/&lt;x&gt;/&lt;y&gt;</code> tile as a bounding box.
</p>
</li><li>
<p>
Optionally, a <code>geo_bounds</code> aggregation on the <code>&lt;field&gt;</code>. The search only includes this aggregation if the <code>exact_bounds</code> parameter is <code>true</code>.
</p>
</li><li>
<p>
If the optional parameter <code>with_labels</code> is <code>true</code>, the internal search will include a dynamic runtime field that calls the <code>getLabelPosition</code> function of the geometry doc value. This enables the generation of new point features containing suggested geometry labels, so that, for example, multi-polygons will have only one label.
</p>
</li></ul>
<p>
For example, Elasticsearch may translate a vector tile search API request with a <code>grid_agg</code> argument of <code>geotile</code> and an <code>exact_bounds</code> argument of <code>true</code> into the following search
</p>
<pre><code class="lang-csharp">GET my-index/_search
{
  "size": 10000,
  "query": {
    "geo_bounding_box": {
      "my-geo-field": {
        "top_left": {
          "lat": -40.979898069620134,
          "lon": -45
        },
        "bottom_right": {
          "lat": -66.51326044311186,
          "lon": 0
        }
      }
    }
  },
  "aggregations": {
    "grid": {
      "geotile_grid": {
        "field": "my-geo-field",
        "precision": 11,
        "size": 65536,
        "bounds": {
          "top_left": {
            "lat": -40.979898069620134,
            "lon": -45
          },
          "bottom_right": {
            "lat": -66.51326044311186,
            "lon": 0
          }
        }
      }
    },
    "bounds": {
      "geo_bounds": {
        "field": "my-geo-field",
        "wrap_longitude": false
      }
    }
  }
}</code></pre>
<p>
The API returns results as a binary Mapbox vector tile.
Mapbox vector tiles are encoded as Google Protobufs (PBF). By default, the tile contains three layers:
</p>
<ul><li>
<p>
A <code>hits</code> layer containing a feature for each <code>&lt;field&gt;</code> value matching the <code>geo_bounding_box</code> query.
</p>
</li><li>
<p>
An <code>aggs</code> layer containing a feature for each cell of the <code>geotile_grid</code> or <code>geohex_grid</code>. The layer only contains features for cells with matching data.
</p>
</li><li>
<p>
A meta layer containing:
</p>
<ul><li>
<p>
A feature containing a bounding box. By default, this is the bounding box of the tile.
</p>
</li><li>
<p>
Value ranges for any sub-aggregations on the <code>geotile_grid</code> or <code>geohex_grid</code>.
</p>
</li><li>
<p>
Metadata for the search.
</p>
</li></ul>
</li></ul>
<p>
The API only returns features that can display at its zoom level.
For example, if a polygon feature has no area at its zoom level, the API omits it.
The API returns errors as UTF-8 encoded JSON.
</p>
<p>
IMPORTANT: You can specify several options for this API as either a query parameter or request body parameter.
If you specify both parameters, the query parameter takes precedence.
</p>
<p>
<strong>Grid precision for geotile</strong>
</p>
<p>
For a <code>grid_agg</code> of <code>geotile</code>, you can use cells in the <code>aggs</code> layer as tiles for lower zoom levels.
<code>grid_precision</code> represents the additional zoom levels available through these cells. The final precision is computed by as follows: <code>&lt;zoom&gt; + grid_precision</code>.
For example, if <code>&lt;zoom&gt;</code> is 7 and <code>grid_precision</code> is 8, then the <code>geotile_grid</code> aggregation will use a precision of 15.
The maximum final precision is 29.
The <code>grid_precision</code> also determines the number of cells for the grid as follows: <code>(2^grid_precision) x (2^grid_precision)</code>.
For example, a value of 8 divides the tile into a grid of 256 x 256 cells.
The <code>aggs</code> layer only contains features for cells with matching data.
</p>
<p>
<strong>Grid precision for geohex</strong>
</p>
<p>
For a <code>grid_agg</code> of <code>geohex</code>, Elasticsearch uses <code>&lt;zoom&gt;</code> and <code>grid_precision</code> to calculate a final precision as follows: <code>&lt;zoom&gt; + grid_precision</code>.
</p>
<p>
This precision determines the H3 resolution of the hexagonal cells produced by the <code>geohex</code> aggregation.
The following table maps the H3 resolution for each precision.
For example, if <code>&lt;zoom&gt;</code> is 3 and <code>grid_precision</code> is 3, the precision is 6.
At a precision of 6, hexagonal cells have an H3 resolution of 2.
If <code>&lt;zoom&gt;</code> is 3 and <code>grid_precision</code> is 4, the precision is 7.
At a precision of 7, hexagonal cells have an H3 resolution of 3.
</p>
<p>
| Precision | Unique tile bins | H3 resolution | Unique hex bins |	Ratio |
| --------- | ---------------- | ------------- | ----------------| ----- |
| 1  | 4                  | 0  | 122             | 30.5           |
| 2  | 16                 | 0  | 122             | 7.625          |
| 3  | 64                 | 1  | 842             | 13.15625       |
| 4  | 256                | 1  | 842             | 3.2890625      |
| 5  | 1024               | 2  | 5882            | 5.744140625    |
| 6  | 4096               | 2  | 5882            | 1.436035156    |
| 7  | 16384              | 3  | 41162           | 2.512329102    |
| 8  | 65536              | 3  | 41162           | 0.6280822754   |
| 9  | 262144             | 4  | 288122          | 1.099098206    |
| 10 | 1048576            | 4  | 288122          | 0.2747745514   |
| 11 | 4194304            | 5  | 2016842         | 0.4808526039   |
| 12 | 16777216           | 6  | 14117882        | 0.8414913416   |
| 13 | 67108864           | 6  | 14117882        | 0.2103728354   |
| 14 | 268435456          | 7  | 98825162        | 0.3681524172   |
| 15 | 1073741824         | 8  | 691776122       | 0.644266719    |
| 16 | 4294967296         | 8  | 691776122       | 0.1610666797   |
| 17 | 17179869184        | 9  | 4842432842      | 0.2818666889   |
| 18 | 68719476736        | 10 | 33897029882     | 0.4932667053   |
| 19 | 274877906944       | 11 | 237279209162    | 0.8632167343   |
| 20 | 1099511627776      | 11 | 237279209162    | 0.2158041836   |
| 21 | 4398046511104      | 12 | 1660954464122   | 0.3776573213   |
| 22 | 17592186044416     | 13 | 11626681248842  | 0.6609003122   |
| 23 | 70368744177664     | 13 | 11626681248842  | 0.165225078    |
| 24 | 281474976710656    | 14 | 81386768741882  | 0.2891438866   |
| 25 | 1125899906842620   | 15 | 569707381193162 | 0.5060018015   |
| 26 | 4503599627370500   | 15 | 569707381193162 | 0.1265004504   |
| 27 | 18014398509482000  | 15 | 569707381193162 | 0.03162511259  |
| 28 | 72057594037927900  | 15 | 569707381193162 | 0.007906278149 |
| 29 | 288230376151712000 | 15 | 569707381193162 | 0.001976569537 |
</p>
<p>
Hexagonal cells don't align perfectly on a vector tile.
Some cells may intersect more than one vector tile.
To compute the H3 resolution for each precision, Elasticsearch compares the average density of hexagonal bins at each resolution with the average density of tile bins at each zoom level.
Elasticsearch uses the H3 resolution that is closest to the corresponding geotile density.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-vector-tile-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;SearchMvtResponse&gt; SearchMvtAsync(Indices indices, Field field, int zoom, int x, int y, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>indices</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Indices.html">Indices</a></dt>
    <dd></dd>
    <dt><code>field</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Field.html">Field</a></dt>
    <dd></dd>
    <dt><code>zoom</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd></dd>
    <dt><code>x</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd></dd>
    <dt><code>y</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.SearchMvtResponse.html">SearchMvtResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchMvtAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchMvtAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchMvtAsync_Elastic_Clients_Elasticsearch_SearchMvtRequest_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchMvtAsync(Elastic.Clients.Elasticsearch.SearchMvtRequest,System.Threading.CancellationToken)">
  SearchMvtAsync(SearchMvtRequest, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L31895"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Search a vector tile.
</p>
<p>
Search a vector tile for geospatial values.
Before using this API, you should be familiar with the Mapbox vector tile specification.
The API returns results as a binary mapbox vector tile.
</p>
<p>
Internally, Elasticsearch translates a vector tile search API request into a search containing:
</p>
<ul><li>
<p>
A <code>geo_bounding_box</code> query on the <code>&lt;field&gt;</code>. The query uses the <code>&lt;zoom&gt;/&lt;x&gt;/&lt;y&gt;</code> tile as a bounding box.
</p>
</li><li>
<p>
A <code>geotile_grid</code> or <code>geohex_grid</code> aggregation on the <code>&lt;field&gt;</code>. The <code>grid_agg</code> parameter determines the aggregation type. The aggregation uses the <code>&lt;zoom&gt;/&lt;x&gt;/&lt;y&gt;</code> tile as a bounding box.
</p>
</li><li>
<p>
Optionally, a <code>geo_bounds</code> aggregation on the <code>&lt;field&gt;</code>. The search only includes this aggregation if the <code>exact_bounds</code> parameter is <code>true</code>.
</p>
</li><li>
<p>
If the optional parameter <code>with_labels</code> is <code>true</code>, the internal search will include a dynamic runtime field that calls the <code>getLabelPosition</code> function of the geometry doc value. This enables the generation of new point features containing suggested geometry labels, so that, for example, multi-polygons will have only one label.
</p>
</li></ul>
<p>
For example, Elasticsearch may translate a vector tile search API request with a <code>grid_agg</code> argument of <code>geotile</code> and an <code>exact_bounds</code> argument of <code>true</code> into the following search
</p>
<pre><code class="lang-csharp">GET my-index/_search
{
  "size": 10000,
  "query": {
    "geo_bounding_box": {
      "my-geo-field": {
        "top_left": {
          "lat": -40.979898069620134,
          "lon": -45
        },
        "bottom_right": {
          "lat": -66.51326044311186,
          "lon": 0
        }
      }
    }
  },
  "aggregations": {
    "grid": {
      "geotile_grid": {
        "field": "my-geo-field",
        "precision": 11,
        "size": 65536,
        "bounds": {
          "top_left": {
            "lat": -40.979898069620134,
            "lon": -45
          },
          "bottom_right": {
            "lat": -66.51326044311186,
            "lon": 0
          }
        }
      }
    },
    "bounds": {
      "geo_bounds": {
        "field": "my-geo-field",
        "wrap_longitude": false
      }
    }
  }
}</code></pre>
<p>
The API returns results as a binary Mapbox vector tile.
Mapbox vector tiles are encoded as Google Protobufs (PBF). By default, the tile contains three layers:
</p>
<ul><li>
<p>
A <code>hits</code> layer containing a feature for each <code>&lt;field&gt;</code> value matching the <code>geo_bounding_box</code> query.
</p>
</li><li>
<p>
An <code>aggs</code> layer containing a feature for each cell of the <code>geotile_grid</code> or <code>geohex_grid</code>. The layer only contains features for cells with matching data.
</p>
</li><li>
<p>
A meta layer containing:
</p>
<ul><li>
<p>
A feature containing a bounding box. By default, this is the bounding box of the tile.
</p>
</li><li>
<p>
Value ranges for any sub-aggregations on the <code>geotile_grid</code> or <code>geohex_grid</code>.
</p>
</li><li>
<p>
Metadata for the search.
</p>
</li></ul>
</li></ul>
<p>
The API only returns features that can display at its zoom level.
For example, if a polygon feature has no area at its zoom level, the API omits it.
The API returns errors as UTF-8 encoded JSON.
</p>
<p>
IMPORTANT: You can specify several options for this API as either a query parameter or request body parameter.
If you specify both parameters, the query parameter takes precedence.
</p>
<p>
<strong>Grid precision for geotile</strong>
</p>
<p>
For a <code>grid_agg</code> of <code>geotile</code>, you can use cells in the <code>aggs</code> layer as tiles for lower zoom levels.
<code>grid_precision</code> represents the additional zoom levels available through these cells. The final precision is computed by as follows: <code>&lt;zoom&gt; + grid_precision</code>.
For example, if <code>&lt;zoom&gt;</code> is 7 and <code>grid_precision</code> is 8, then the <code>geotile_grid</code> aggregation will use a precision of 15.
The maximum final precision is 29.
The <code>grid_precision</code> also determines the number of cells for the grid as follows: <code>(2^grid_precision) x (2^grid_precision)</code>.
For example, a value of 8 divides the tile into a grid of 256 x 256 cells.
The <code>aggs</code> layer only contains features for cells with matching data.
</p>
<p>
<strong>Grid precision for geohex</strong>
</p>
<p>
For a <code>grid_agg</code> of <code>geohex</code>, Elasticsearch uses <code>&lt;zoom&gt;</code> and <code>grid_precision</code> to calculate a final precision as follows: <code>&lt;zoom&gt; + grid_precision</code>.
</p>
<p>
This precision determines the H3 resolution of the hexagonal cells produced by the <code>geohex</code> aggregation.
The following table maps the H3 resolution for each precision.
For example, if <code>&lt;zoom&gt;</code> is 3 and <code>grid_precision</code> is 3, the precision is 6.
At a precision of 6, hexagonal cells have an H3 resolution of 2.
If <code>&lt;zoom&gt;</code> is 3 and <code>grid_precision</code> is 4, the precision is 7.
At a precision of 7, hexagonal cells have an H3 resolution of 3.
</p>
<p>
| Precision | Unique tile bins | H3 resolution | Unique hex bins |	Ratio |
| --------- | ---------------- | ------------- | ----------------| ----- |
| 1  | 4                  | 0  | 122             | 30.5           |
| 2  | 16                 | 0  | 122             | 7.625          |
| 3  | 64                 | 1  | 842             | 13.15625       |
| 4  | 256                | 1  | 842             | 3.2890625      |
| 5  | 1024               | 2  | 5882            | 5.744140625    |
| 6  | 4096               | 2  | 5882            | 1.436035156    |
| 7  | 16384              | 3  | 41162           | 2.512329102    |
| 8  | 65536              | 3  | 41162           | 0.6280822754   |
| 9  | 262144             | 4  | 288122          | 1.099098206    |
| 10 | 1048576            | 4  | 288122          | 0.2747745514   |
| 11 | 4194304            | 5  | 2016842         | 0.4808526039   |
| 12 | 16777216           | 6  | 14117882        | 0.8414913416   |
| 13 | 67108864           | 6  | 14117882        | 0.2103728354   |
| 14 | 268435456          | 7  | 98825162        | 0.3681524172   |
| 15 | 1073741824         | 8  | 691776122       | 0.644266719    |
| 16 | 4294967296         | 8  | 691776122       | 0.1610666797   |
| 17 | 17179869184        | 9  | 4842432842      | 0.2818666889   |
| 18 | 68719476736        | 10 | 33897029882     | 0.4932667053   |
| 19 | 274877906944       | 11 | 237279209162    | 0.8632167343   |
| 20 | 1099511627776      | 11 | 237279209162    | 0.2158041836   |
| 21 | 4398046511104      | 12 | 1660954464122   | 0.3776573213   |
| 22 | 17592186044416     | 13 | 11626681248842  | 0.6609003122   |
| 23 | 70368744177664     | 13 | 11626681248842  | 0.165225078    |
| 24 | 281474976710656    | 14 | 81386768741882  | 0.2891438866   |
| 25 | 1125899906842620   | 15 | 569707381193162 | 0.5060018015   |
| 26 | 4503599627370500   | 15 | 569707381193162 | 0.1265004504   |
| 27 | 18014398509482000  | 15 | 569707381193162 | 0.03162511259  |
| 28 | 72057594037927900  | 15 | 569707381193162 | 0.007906278149 |
| 29 | 288230376151712000 | 15 | 569707381193162 | 0.001976569537 |
</p>
<p>
Hexagonal cells don't align perfectly on a vector tile.
Some cells may intersect more than one vector tile.
To compute the H3 resolution for each precision, Elasticsearch compares the average density of hexagonal bins at each resolution with the average density of tile bins at each zoom level.
Elasticsearch uses the H3 resolution that is closest to the corresponding geotile density.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-vector-tile-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;SearchMvtResponse&gt; SearchMvtAsync(SearchMvtRequest request, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.SearchMvtRequest.html">SearchMvtRequest</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.SearchMvtResponse.html">SearchMvtResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchMvtAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchMvtAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchMvtAsync_Elastic_Clients_Elasticsearch_SearchMvtRequestDescriptor_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchMvtAsync(Elastic.Clients.Elasticsearch.SearchMvtRequestDescriptor,System.Threading.CancellationToken)">
  SearchMvtAsync(SearchMvtRequestDescriptor, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L34746"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Search a vector tile.
</p>
<p>
Search a vector tile for geospatial values.
Before using this API, you should be familiar with the Mapbox vector tile specification.
The API returns results as a binary mapbox vector tile.
</p>
<p>
Internally, Elasticsearch translates a vector tile search API request into a search containing:
</p>
<ul><li>
<p>
A <code>geo_bounding_box</code> query on the <code>&lt;field&gt;</code>. The query uses the <code>&lt;zoom&gt;/&lt;x&gt;/&lt;y&gt;</code> tile as a bounding box.
</p>
</li><li>
<p>
A <code>geotile_grid</code> or <code>geohex_grid</code> aggregation on the <code>&lt;field&gt;</code>. The <code>grid_agg</code> parameter determines the aggregation type. The aggregation uses the <code>&lt;zoom&gt;/&lt;x&gt;/&lt;y&gt;</code> tile as a bounding box.
</p>
</li><li>
<p>
Optionally, a <code>geo_bounds</code> aggregation on the <code>&lt;field&gt;</code>. The search only includes this aggregation if the <code>exact_bounds</code> parameter is <code>true</code>.
</p>
</li><li>
<p>
If the optional parameter <code>with_labels</code> is <code>true</code>, the internal search will include a dynamic runtime field that calls the <code>getLabelPosition</code> function of the geometry doc value. This enables the generation of new point features containing suggested geometry labels, so that, for example, multi-polygons will have only one label.
</p>
</li></ul>
<p>
For example, Elasticsearch may translate a vector tile search API request with a <code>grid_agg</code> argument of <code>geotile</code> and an <code>exact_bounds</code> argument of <code>true</code> into the following search
</p>
<pre><code class="lang-csharp">GET my-index/_search
{
  "size": 10000,
  "query": {
    "geo_bounding_box": {
      "my-geo-field": {
        "top_left": {
          "lat": -40.979898069620134,
          "lon": -45
        },
        "bottom_right": {
          "lat": -66.51326044311186,
          "lon": 0
        }
      }
    }
  },
  "aggregations": {
    "grid": {
      "geotile_grid": {
        "field": "my-geo-field",
        "precision": 11,
        "size": 65536,
        "bounds": {
          "top_left": {
            "lat": -40.979898069620134,
            "lon": -45
          },
          "bottom_right": {
            "lat": -66.51326044311186,
            "lon": 0
          }
        }
      }
    },
    "bounds": {
      "geo_bounds": {
        "field": "my-geo-field",
        "wrap_longitude": false
      }
    }
  }
}</code></pre>
<p>
The API returns results as a binary Mapbox vector tile.
Mapbox vector tiles are encoded as Google Protobufs (PBF). By default, the tile contains three layers:
</p>
<ul><li>
<p>
A <code>hits</code> layer containing a feature for each <code>&lt;field&gt;</code> value matching the <code>geo_bounding_box</code> query.
</p>
</li><li>
<p>
An <code>aggs</code> layer containing a feature for each cell of the <code>geotile_grid</code> or <code>geohex_grid</code>. The layer only contains features for cells with matching data.
</p>
</li><li>
<p>
A meta layer containing:
</p>
<ul><li>
<p>
A feature containing a bounding box. By default, this is the bounding box of the tile.
</p>
</li><li>
<p>
Value ranges for any sub-aggregations on the <code>geotile_grid</code> or <code>geohex_grid</code>.
</p>
</li><li>
<p>
Metadata for the search.
</p>
</li></ul>
</li></ul>
<p>
The API only returns features that can display at its zoom level.
For example, if a polygon feature has no area at its zoom level, the API omits it.
The API returns errors as UTF-8 encoded JSON.
</p>
<p>
IMPORTANT: You can specify several options for this API as either a query parameter or request body parameter.
If you specify both parameters, the query parameter takes precedence.
</p>
<p>
<strong>Grid precision for geotile</strong>
</p>
<p>
For a <code>grid_agg</code> of <code>geotile</code>, you can use cells in the <code>aggs</code> layer as tiles for lower zoom levels.
<code>grid_precision</code> represents the additional zoom levels available through these cells. The final precision is computed by as follows: <code>&lt;zoom&gt; + grid_precision</code>.
For example, if <code>&lt;zoom&gt;</code> is 7 and <code>grid_precision</code> is 8, then the <code>geotile_grid</code> aggregation will use a precision of 15.
The maximum final precision is 29.
The <code>grid_precision</code> also determines the number of cells for the grid as follows: <code>(2^grid_precision) x (2^grid_precision)</code>.
For example, a value of 8 divides the tile into a grid of 256 x 256 cells.
The <code>aggs</code> layer only contains features for cells with matching data.
</p>
<p>
<strong>Grid precision for geohex</strong>
</p>
<p>
For a <code>grid_agg</code> of <code>geohex</code>, Elasticsearch uses <code>&lt;zoom&gt;</code> and <code>grid_precision</code> to calculate a final precision as follows: <code>&lt;zoom&gt; + grid_precision</code>.
</p>
<p>
This precision determines the H3 resolution of the hexagonal cells produced by the <code>geohex</code> aggregation.
The following table maps the H3 resolution for each precision.
For example, if <code>&lt;zoom&gt;</code> is 3 and <code>grid_precision</code> is 3, the precision is 6.
At a precision of 6, hexagonal cells have an H3 resolution of 2.
If <code>&lt;zoom&gt;</code> is 3 and <code>grid_precision</code> is 4, the precision is 7.
At a precision of 7, hexagonal cells have an H3 resolution of 3.
</p>
<p>
| Precision | Unique tile bins | H3 resolution | Unique hex bins |	Ratio |
| --------- | ---------------- | ------------- | ----------------| ----- |
| 1  | 4                  | 0  | 122             | 30.5           |
| 2  | 16                 | 0  | 122             | 7.625          |
| 3  | 64                 | 1  | 842             | 13.15625       |
| 4  | 256                | 1  | 842             | 3.2890625      |
| 5  | 1024               | 2  | 5882            | 5.744140625    |
| 6  | 4096               | 2  | 5882            | 1.436035156    |
| 7  | 16384              | 3  | 41162           | 2.512329102    |
| 8  | 65536              | 3  | 41162           | 0.6280822754   |
| 9  | 262144             | 4  | 288122          | 1.099098206    |
| 10 | 1048576            | 4  | 288122          | 0.2747745514   |
| 11 | 4194304            | 5  | 2016842         | 0.4808526039   |
| 12 | 16777216           | 6  | 14117882        | 0.8414913416   |
| 13 | 67108864           | 6  | 14117882        | 0.2103728354   |
| 14 | 268435456          | 7  | 98825162        | 0.3681524172   |
| 15 | 1073741824         | 8  | 691776122       | 0.644266719    |
| 16 | 4294967296         | 8  | 691776122       | 0.1610666797   |
| 17 | 17179869184        | 9  | 4842432842      | 0.2818666889   |
| 18 | 68719476736        | 10 | 33897029882     | 0.4932667053   |
| 19 | 274877906944       | 11 | 237279209162    | 0.8632167343   |
| 20 | 1099511627776      | 11 | 237279209162    | 0.2158041836   |
| 21 | 4398046511104      | 12 | 1660954464122   | 0.3776573213   |
| 22 | 17592186044416     | 13 | 11626681248842  | 0.6609003122   |
| 23 | 70368744177664     | 13 | 11626681248842  | 0.165225078    |
| 24 | 281474976710656    | 14 | 81386768741882  | 0.2891438866   |
| 25 | 1125899906842620   | 15 | 569707381193162 | 0.5060018015   |
| 26 | 4503599627370500   | 15 | 569707381193162 | 0.1265004504   |
| 27 | 18014398509482000  | 15 | 569707381193162 | 0.03162511259  |
| 28 | 72057594037927900  | 15 | 569707381193162 | 0.007906278149 |
| 29 | 288230376151712000 | 15 | 569707381193162 | 0.001976569537 |
</p>
<p>
Hexagonal cells don't align perfectly on a vector tile.
Some cells may intersect more than one vector tile.
To compute the H3 resolution for each precision, Elasticsearch compares the average density of hexagonal bins at each resolution with the average density of tile bins at each zoom level.
Elasticsearch uses the H3 resolution that is closest to the corresponding geotile density.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-vector-tile-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;SearchMvtResponse&gt; SearchMvtAsync(SearchMvtRequestDescriptor descriptor, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.SearchMvtRequestDescriptor.html">SearchMvtRequestDescriptor</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.SearchMvtResponse.html">SearchMvtResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchMvtAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchMvtAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchMvtAsync__1_Elastic_Clients_Elasticsearch_Field_System_Int32_System_Int32_System_Int32_System_Action_Elastic_Clients_Elasticsearch_SearchMvtRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchMvtAsync``1(Elastic.Clients.Elasticsearch.Field,System.Int32,System.Int32,System.Int32,System.Action{Elastic.Clients.Elasticsearch.SearchMvtRequestDescriptor{``0}},System.Threading.CancellationToken)">
  SearchMvtAsync&lt;TDocument&gt;(Field, int, int, int, Action&lt;SearchMvtRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L34542"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Search a vector tile.
</p>
<p>
Search a vector tile for geospatial values.
Before using this API, you should be familiar with the Mapbox vector tile specification.
The API returns results as a binary mapbox vector tile.
</p>
<p>
Internally, Elasticsearch translates a vector tile search API request into a search containing:
</p>
<ul><li>
<p>
A <code>geo_bounding_box</code> query on the <code>&lt;field&gt;</code>. The query uses the <code>&lt;zoom&gt;/&lt;x&gt;/&lt;y&gt;</code> tile as a bounding box.
</p>
</li><li>
<p>
A <code>geotile_grid</code> or <code>geohex_grid</code> aggregation on the <code>&lt;field&gt;</code>. The <code>grid_agg</code> parameter determines the aggregation type. The aggregation uses the <code>&lt;zoom&gt;/&lt;x&gt;/&lt;y&gt;</code> tile as a bounding box.
</p>
</li><li>
<p>
Optionally, a <code>geo_bounds</code> aggregation on the <code>&lt;field&gt;</code>. The search only includes this aggregation if the <code>exact_bounds</code> parameter is <code>true</code>.
</p>
</li><li>
<p>
If the optional parameter <code>with_labels</code> is <code>true</code>, the internal search will include a dynamic runtime field that calls the <code>getLabelPosition</code> function of the geometry doc value. This enables the generation of new point features containing suggested geometry labels, so that, for example, multi-polygons will have only one label.
</p>
</li></ul>
<p>
For example, Elasticsearch may translate a vector tile search API request with a <code>grid_agg</code> argument of <code>geotile</code> and an <code>exact_bounds</code> argument of <code>true</code> into the following search
</p>
<pre><code class="lang-csharp">GET my-index/_search
{
  "size": 10000,
  "query": {
    "geo_bounding_box": {
      "my-geo-field": {
        "top_left": {
          "lat": -40.979898069620134,
          "lon": -45
        },
        "bottom_right": {
          "lat": -66.51326044311186,
          "lon": 0
        }
      }
    }
  },
  "aggregations": {
    "grid": {
      "geotile_grid": {
        "field": "my-geo-field",
        "precision": 11,
        "size": 65536,
        "bounds": {
          "top_left": {
            "lat": -40.979898069620134,
            "lon": -45
          },
          "bottom_right": {
            "lat": -66.51326044311186,
            "lon": 0
          }
        }
      }
    },
    "bounds": {
      "geo_bounds": {
        "field": "my-geo-field",
        "wrap_longitude": false
      }
    }
  }
}</code></pre>
<p>
The API returns results as a binary Mapbox vector tile.
Mapbox vector tiles are encoded as Google Protobufs (PBF). By default, the tile contains three layers:
</p>
<ul><li>
<p>
A <code>hits</code> layer containing a feature for each <code>&lt;field&gt;</code> value matching the <code>geo_bounding_box</code> query.
</p>
</li><li>
<p>
An <code>aggs</code> layer containing a feature for each cell of the <code>geotile_grid</code> or <code>geohex_grid</code>. The layer only contains features for cells with matching data.
</p>
</li><li>
<p>
A meta layer containing:
</p>
<ul><li>
<p>
A feature containing a bounding box. By default, this is the bounding box of the tile.
</p>
</li><li>
<p>
Value ranges for any sub-aggregations on the <code>geotile_grid</code> or <code>geohex_grid</code>.
</p>
</li><li>
<p>
Metadata for the search.
</p>
</li></ul>
</li></ul>
<p>
The API only returns features that can display at its zoom level.
For example, if a polygon feature has no area at its zoom level, the API omits it.
The API returns errors as UTF-8 encoded JSON.
</p>
<p>
IMPORTANT: You can specify several options for this API as either a query parameter or request body parameter.
If you specify both parameters, the query parameter takes precedence.
</p>
<p>
<strong>Grid precision for geotile</strong>
</p>
<p>
For a <code>grid_agg</code> of <code>geotile</code>, you can use cells in the <code>aggs</code> layer as tiles for lower zoom levels.
<code>grid_precision</code> represents the additional zoom levels available through these cells. The final precision is computed by as follows: <code>&lt;zoom&gt; + grid_precision</code>.
For example, if <code>&lt;zoom&gt;</code> is 7 and <code>grid_precision</code> is 8, then the <code>geotile_grid</code> aggregation will use a precision of 15.
The maximum final precision is 29.
The <code>grid_precision</code> also determines the number of cells for the grid as follows: <code>(2^grid_precision) x (2^grid_precision)</code>.
For example, a value of 8 divides the tile into a grid of 256 x 256 cells.
The <code>aggs</code> layer only contains features for cells with matching data.
</p>
<p>
<strong>Grid precision for geohex</strong>
</p>
<p>
For a <code>grid_agg</code> of <code>geohex</code>, Elasticsearch uses <code>&lt;zoom&gt;</code> and <code>grid_precision</code> to calculate a final precision as follows: <code>&lt;zoom&gt; + grid_precision</code>.
</p>
<p>
This precision determines the H3 resolution of the hexagonal cells produced by the <code>geohex</code> aggregation.
The following table maps the H3 resolution for each precision.
For example, if <code>&lt;zoom&gt;</code> is 3 and <code>grid_precision</code> is 3, the precision is 6.
At a precision of 6, hexagonal cells have an H3 resolution of 2.
If <code>&lt;zoom&gt;</code> is 3 and <code>grid_precision</code> is 4, the precision is 7.
At a precision of 7, hexagonal cells have an H3 resolution of 3.
</p>
<p>
| Precision | Unique tile bins | H3 resolution | Unique hex bins |	Ratio |
| --------- | ---------------- | ------------- | ----------------| ----- |
| 1  | 4                  | 0  | 122             | 30.5           |
| 2  | 16                 | 0  | 122             | 7.625          |
| 3  | 64                 | 1  | 842             | 13.15625       |
| 4  | 256                | 1  | 842             | 3.2890625      |
| 5  | 1024               | 2  | 5882            | 5.744140625    |
| 6  | 4096               | 2  | 5882            | 1.436035156    |
| 7  | 16384              | 3  | 41162           | 2.512329102    |
| 8  | 65536              | 3  | 41162           | 0.6280822754   |
| 9  | 262144             | 4  | 288122          | 1.099098206    |
| 10 | 1048576            | 4  | 288122          | 0.2747745514   |
| 11 | 4194304            | 5  | 2016842         | 0.4808526039   |
| 12 | 16777216           | 6  | 14117882        | 0.8414913416   |
| 13 | 67108864           | 6  | 14117882        | 0.2103728354   |
| 14 | 268435456          | 7  | 98825162        | 0.3681524172   |
| 15 | 1073741824         | 8  | 691776122       | 0.644266719    |
| 16 | 4294967296         | 8  | 691776122       | 0.1610666797   |
| 17 | 17179869184        | 9  | 4842432842      | 0.2818666889   |
| 18 | 68719476736        | 10 | 33897029882     | 0.4932667053   |
| 19 | 274877906944       | 11 | 237279209162    | 0.8632167343   |
| 20 | 1099511627776      | 11 | 237279209162    | 0.2158041836   |
| 21 | 4398046511104      | 12 | 1660954464122   | 0.3776573213   |
| 22 | 17592186044416     | 13 | 11626681248842  | 0.6609003122   |
| 23 | 70368744177664     | 13 | 11626681248842  | 0.165225078    |
| 24 | 281474976710656    | 14 | 81386768741882  | 0.2891438866   |
| 25 | 1125899906842620   | 15 | 569707381193162 | 0.5060018015   |
| 26 | 4503599627370500   | 15 | 569707381193162 | 0.1265004504   |
| 27 | 18014398509482000  | 15 | 569707381193162 | 0.03162511259  |
| 28 | 72057594037927900  | 15 | 569707381193162 | 0.007906278149 |
| 29 | 288230376151712000 | 15 | 569707381193162 | 0.001976569537 |
</p>
<p>
Hexagonal cells don't align perfectly on a vector tile.
Some cells may intersect more than one vector tile.
To compute the H3 resolution for each precision, Elasticsearch compares the average density of hexagonal bins at each resolution with the average density of tile bins at each zoom level.
Elasticsearch uses the H3 resolution that is closest to the corresponding geotile density.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-vector-tile-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;SearchMvtResponse&gt; SearchMvtAsync&lt;TDocument&gt;(Field field, int zoom, int x, int y, Action&lt;SearchMvtRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>field</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Field.html">Field</a></dt>
    <dd></dd>
    <dt><code>zoom</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd></dd>
    <dt><code>x</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd></dd>
    <dt><code>y</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.SearchMvtRequestDescriptor-1.html">SearchMvtRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.SearchMvtResponse.html">SearchMvtResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchMvtAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchMvtAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchMvtAsync__1_Elastic_Clients_Elasticsearch_Field_System_Int32_System_Int32_System_Int32_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchMvtAsync``1(Elastic.Clients.Elasticsearch.Field,System.Int32,System.Int32,System.Int32,System.Threading.CancellationToken)">
  SearchMvtAsync&lt;TDocument&gt;(Field, int, int, int, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L34339"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Search a vector tile.
</p>
<p>
Search a vector tile for geospatial values.
Before using this API, you should be familiar with the Mapbox vector tile specification.
The API returns results as a binary mapbox vector tile.
</p>
<p>
Internally, Elasticsearch translates a vector tile search API request into a search containing:
</p>
<ul><li>
<p>
A <code>geo_bounding_box</code> query on the <code>&lt;field&gt;</code>. The query uses the <code>&lt;zoom&gt;/&lt;x&gt;/&lt;y&gt;</code> tile as a bounding box.
</p>
</li><li>
<p>
A <code>geotile_grid</code> or <code>geohex_grid</code> aggregation on the <code>&lt;field&gt;</code>. The <code>grid_agg</code> parameter determines the aggregation type. The aggregation uses the <code>&lt;zoom&gt;/&lt;x&gt;/&lt;y&gt;</code> tile as a bounding box.
</p>
</li><li>
<p>
Optionally, a <code>geo_bounds</code> aggregation on the <code>&lt;field&gt;</code>. The search only includes this aggregation if the <code>exact_bounds</code> parameter is <code>true</code>.
</p>
</li><li>
<p>
If the optional parameter <code>with_labels</code> is <code>true</code>, the internal search will include a dynamic runtime field that calls the <code>getLabelPosition</code> function of the geometry doc value. This enables the generation of new point features containing suggested geometry labels, so that, for example, multi-polygons will have only one label.
</p>
</li></ul>
<p>
For example, Elasticsearch may translate a vector tile search API request with a <code>grid_agg</code> argument of <code>geotile</code> and an <code>exact_bounds</code> argument of <code>true</code> into the following search
</p>
<pre><code class="lang-csharp">GET my-index/_search
{
  "size": 10000,
  "query": {
    "geo_bounding_box": {
      "my-geo-field": {
        "top_left": {
          "lat": -40.979898069620134,
          "lon": -45
        },
        "bottom_right": {
          "lat": -66.51326044311186,
          "lon": 0
        }
      }
    }
  },
  "aggregations": {
    "grid": {
      "geotile_grid": {
        "field": "my-geo-field",
        "precision": 11,
        "size": 65536,
        "bounds": {
          "top_left": {
            "lat": -40.979898069620134,
            "lon": -45
          },
          "bottom_right": {
            "lat": -66.51326044311186,
            "lon": 0
          }
        }
      }
    },
    "bounds": {
      "geo_bounds": {
        "field": "my-geo-field",
        "wrap_longitude": false
      }
    }
  }
}</code></pre>
<p>
The API returns results as a binary Mapbox vector tile.
Mapbox vector tiles are encoded as Google Protobufs (PBF). By default, the tile contains three layers:
</p>
<ul><li>
<p>
A <code>hits</code> layer containing a feature for each <code>&lt;field&gt;</code> value matching the <code>geo_bounding_box</code> query.
</p>
</li><li>
<p>
An <code>aggs</code> layer containing a feature for each cell of the <code>geotile_grid</code> or <code>geohex_grid</code>. The layer only contains features for cells with matching data.
</p>
</li><li>
<p>
A meta layer containing:
</p>
<ul><li>
<p>
A feature containing a bounding box. By default, this is the bounding box of the tile.
</p>
</li><li>
<p>
Value ranges for any sub-aggregations on the <code>geotile_grid</code> or <code>geohex_grid</code>.
</p>
</li><li>
<p>
Metadata for the search.
</p>
</li></ul>
</li></ul>
<p>
The API only returns features that can display at its zoom level.
For example, if a polygon feature has no area at its zoom level, the API omits it.
The API returns errors as UTF-8 encoded JSON.
</p>
<p>
IMPORTANT: You can specify several options for this API as either a query parameter or request body parameter.
If you specify both parameters, the query parameter takes precedence.
</p>
<p>
<strong>Grid precision for geotile</strong>
</p>
<p>
For a <code>grid_agg</code> of <code>geotile</code>, you can use cells in the <code>aggs</code> layer as tiles for lower zoom levels.
<code>grid_precision</code> represents the additional zoom levels available through these cells. The final precision is computed by as follows: <code>&lt;zoom&gt; + grid_precision</code>.
For example, if <code>&lt;zoom&gt;</code> is 7 and <code>grid_precision</code> is 8, then the <code>geotile_grid</code> aggregation will use a precision of 15.
The maximum final precision is 29.
The <code>grid_precision</code> also determines the number of cells for the grid as follows: <code>(2^grid_precision) x (2^grid_precision)</code>.
For example, a value of 8 divides the tile into a grid of 256 x 256 cells.
The <code>aggs</code> layer only contains features for cells with matching data.
</p>
<p>
<strong>Grid precision for geohex</strong>
</p>
<p>
For a <code>grid_agg</code> of <code>geohex</code>, Elasticsearch uses <code>&lt;zoom&gt;</code> and <code>grid_precision</code> to calculate a final precision as follows: <code>&lt;zoom&gt; + grid_precision</code>.
</p>
<p>
This precision determines the H3 resolution of the hexagonal cells produced by the <code>geohex</code> aggregation.
The following table maps the H3 resolution for each precision.
For example, if <code>&lt;zoom&gt;</code> is 3 and <code>grid_precision</code> is 3, the precision is 6.
At a precision of 6, hexagonal cells have an H3 resolution of 2.
If <code>&lt;zoom&gt;</code> is 3 and <code>grid_precision</code> is 4, the precision is 7.
At a precision of 7, hexagonal cells have an H3 resolution of 3.
</p>
<p>
| Precision | Unique tile bins | H3 resolution | Unique hex bins |	Ratio |
| --------- | ---------------- | ------------- | ----------------| ----- |
| 1  | 4                  | 0  | 122             | 30.5           |
| 2  | 16                 | 0  | 122             | 7.625          |
| 3  | 64                 | 1  | 842             | 13.15625       |
| 4  | 256                | 1  | 842             | 3.2890625      |
| 5  | 1024               | 2  | 5882            | 5.744140625    |
| 6  | 4096               | 2  | 5882            | 1.436035156    |
| 7  | 16384              | 3  | 41162           | 2.512329102    |
| 8  | 65536              | 3  | 41162           | 0.6280822754   |
| 9  | 262144             | 4  | 288122          | 1.099098206    |
| 10 | 1048576            | 4  | 288122          | 0.2747745514   |
| 11 | 4194304            | 5  | 2016842         | 0.4808526039   |
| 12 | 16777216           | 6  | 14117882        | 0.8414913416   |
| 13 | 67108864           | 6  | 14117882        | 0.2103728354   |
| 14 | 268435456          | 7  | 98825162        | 0.3681524172   |
| 15 | 1073741824         | 8  | 691776122       | 0.644266719    |
| 16 | 4294967296         | 8  | 691776122       | 0.1610666797   |
| 17 | 17179869184        | 9  | 4842432842      | 0.2818666889   |
| 18 | 68719476736        | 10 | 33897029882     | 0.4932667053   |
| 19 | 274877906944       | 11 | 237279209162    | 0.8632167343   |
| 20 | 1099511627776      | 11 | 237279209162    | 0.2158041836   |
| 21 | 4398046511104      | 12 | 1660954464122   | 0.3776573213   |
| 22 | 17592186044416     | 13 | 11626681248842  | 0.6609003122   |
| 23 | 70368744177664     | 13 | 11626681248842  | 0.165225078    |
| 24 | 281474976710656    | 14 | 81386768741882  | 0.2891438866   |
| 25 | 1125899906842620   | 15 | 569707381193162 | 0.5060018015   |
| 26 | 4503599627370500   | 15 | 569707381193162 | 0.1265004504   |
| 27 | 18014398509482000  | 15 | 569707381193162 | 0.03162511259  |
| 28 | 72057594037927900  | 15 | 569707381193162 | 0.007906278149 |
| 29 | 288230376151712000 | 15 | 569707381193162 | 0.001976569537 |
</p>
<p>
Hexagonal cells don't align perfectly on a vector tile.
Some cells may intersect more than one vector tile.
To compute the H3 resolution for each precision, Elasticsearch compares the average density of hexagonal bins at each resolution with the average density of tile bins at each zoom level.
Elasticsearch uses the H3 resolution that is closest to the corresponding geotile density.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-vector-tile-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;SearchMvtResponse&gt; SearchMvtAsync&lt;TDocument&gt;(Field field, int zoom, int x, int y, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>field</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Field.html">Field</a></dt>
    <dd></dd>
    <dt><code>zoom</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd></dd>
    <dt><code>x</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd></dd>
    <dt><code>y</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.SearchMvtResponse.html">SearchMvtResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchMvtAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchMvtAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchMvtAsync__1_Elastic_Clients_Elasticsearch_Indices_Elastic_Clients_Elasticsearch_Field_System_Int32_System_Int32_System_Int32_System_Action_Elastic_Clients_Elasticsearch_SearchMvtRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchMvtAsync``1(Elastic.Clients.Elasticsearch.Indices,Elastic.Clients.Elasticsearch.Field,System.Int32,System.Int32,System.Int32,System.Action{Elastic.Clients.Elasticsearch.SearchMvtRequestDescriptor{``0}},System.Threading.CancellationToken)">
  SearchMvtAsync&lt;TDocument&gt;(Indices, Field, int, int, int, Action&lt;SearchMvtRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L34135"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Search a vector tile.
</p>
<p>
Search a vector tile for geospatial values.
Before using this API, you should be familiar with the Mapbox vector tile specification.
The API returns results as a binary mapbox vector tile.
</p>
<p>
Internally, Elasticsearch translates a vector tile search API request into a search containing:
</p>
<ul><li>
<p>
A <code>geo_bounding_box</code> query on the <code>&lt;field&gt;</code>. The query uses the <code>&lt;zoom&gt;/&lt;x&gt;/&lt;y&gt;</code> tile as a bounding box.
</p>
</li><li>
<p>
A <code>geotile_grid</code> or <code>geohex_grid</code> aggregation on the <code>&lt;field&gt;</code>. The <code>grid_agg</code> parameter determines the aggregation type. The aggregation uses the <code>&lt;zoom&gt;/&lt;x&gt;/&lt;y&gt;</code> tile as a bounding box.
</p>
</li><li>
<p>
Optionally, a <code>geo_bounds</code> aggregation on the <code>&lt;field&gt;</code>. The search only includes this aggregation if the <code>exact_bounds</code> parameter is <code>true</code>.
</p>
</li><li>
<p>
If the optional parameter <code>with_labels</code> is <code>true</code>, the internal search will include a dynamic runtime field that calls the <code>getLabelPosition</code> function of the geometry doc value. This enables the generation of new point features containing suggested geometry labels, so that, for example, multi-polygons will have only one label.
</p>
</li></ul>
<p>
For example, Elasticsearch may translate a vector tile search API request with a <code>grid_agg</code> argument of <code>geotile</code> and an <code>exact_bounds</code> argument of <code>true</code> into the following search
</p>
<pre><code class="lang-csharp">GET my-index/_search
{
  "size": 10000,
  "query": {
    "geo_bounding_box": {
      "my-geo-field": {
        "top_left": {
          "lat": -40.979898069620134,
          "lon": -45
        },
        "bottom_right": {
          "lat": -66.51326044311186,
          "lon": 0
        }
      }
    }
  },
  "aggregations": {
    "grid": {
      "geotile_grid": {
        "field": "my-geo-field",
        "precision": 11,
        "size": 65536,
        "bounds": {
          "top_left": {
            "lat": -40.979898069620134,
            "lon": -45
          },
          "bottom_right": {
            "lat": -66.51326044311186,
            "lon": 0
          }
        }
      }
    },
    "bounds": {
      "geo_bounds": {
        "field": "my-geo-field",
        "wrap_longitude": false
      }
    }
  }
}</code></pre>
<p>
The API returns results as a binary Mapbox vector tile.
Mapbox vector tiles are encoded as Google Protobufs (PBF). By default, the tile contains three layers:
</p>
<ul><li>
<p>
A <code>hits</code> layer containing a feature for each <code>&lt;field&gt;</code> value matching the <code>geo_bounding_box</code> query.
</p>
</li><li>
<p>
An <code>aggs</code> layer containing a feature for each cell of the <code>geotile_grid</code> or <code>geohex_grid</code>. The layer only contains features for cells with matching data.
</p>
</li><li>
<p>
A meta layer containing:
</p>
<ul><li>
<p>
A feature containing a bounding box. By default, this is the bounding box of the tile.
</p>
</li><li>
<p>
Value ranges for any sub-aggregations on the <code>geotile_grid</code> or <code>geohex_grid</code>.
</p>
</li><li>
<p>
Metadata for the search.
</p>
</li></ul>
</li></ul>
<p>
The API only returns features that can display at its zoom level.
For example, if a polygon feature has no area at its zoom level, the API omits it.
The API returns errors as UTF-8 encoded JSON.
</p>
<p>
IMPORTANT: You can specify several options for this API as either a query parameter or request body parameter.
If you specify both parameters, the query parameter takes precedence.
</p>
<p>
<strong>Grid precision for geotile</strong>
</p>
<p>
For a <code>grid_agg</code> of <code>geotile</code>, you can use cells in the <code>aggs</code> layer as tiles for lower zoom levels.
<code>grid_precision</code> represents the additional zoom levels available through these cells. The final precision is computed by as follows: <code>&lt;zoom&gt; + grid_precision</code>.
For example, if <code>&lt;zoom&gt;</code> is 7 and <code>grid_precision</code> is 8, then the <code>geotile_grid</code> aggregation will use a precision of 15.
The maximum final precision is 29.
The <code>grid_precision</code> also determines the number of cells for the grid as follows: <code>(2^grid_precision) x (2^grid_precision)</code>.
For example, a value of 8 divides the tile into a grid of 256 x 256 cells.
The <code>aggs</code> layer only contains features for cells with matching data.
</p>
<p>
<strong>Grid precision for geohex</strong>
</p>
<p>
For a <code>grid_agg</code> of <code>geohex</code>, Elasticsearch uses <code>&lt;zoom&gt;</code> and <code>grid_precision</code> to calculate a final precision as follows: <code>&lt;zoom&gt; + grid_precision</code>.
</p>
<p>
This precision determines the H3 resolution of the hexagonal cells produced by the <code>geohex</code> aggregation.
The following table maps the H3 resolution for each precision.
For example, if <code>&lt;zoom&gt;</code> is 3 and <code>grid_precision</code> is 3, the precision is 6.
At a precision of 6, hexagonal cells have an H3 resolution of 2.
If <code>&lt;zoom&gt;</code> is 3 and <code>grid_precision</code> is 4, the precision is 7.
At a precision of 7, hexagonal cells have an H3 resolution of 3.
</p>
<p>
| Precision | Unique tile bins | H3 resolution | Unique hex bins |	Ratio |
| --------- | ---------------- | ------------- | ----------------| ----- |
| 1  | 4                  | 0  | 122             | 30.5           |
| 2  | 16                 | 0  | 122             | 7.625          |
| 3  | 64                 | 1  | 842             | 13.15625       |
| 4  | 256                | 1  | 842             | 3.2890625      |
| 5  | 1024               | 2  | 5882            | 5.744140625    |
| 6  | 4096               | 2  | 5882            | 1.436035156    |
| 7  | 16384              | 3  | 41162           | 2.512329102    |
| 8  | 65536              | 3  | 41162           | 0.6280822754   |
| 9  | 262144             | 4  | 288122          | 1.099098206    |
| 10 | 1048576            | 4  | 288122          | 0.2747745514   |
| 11 | 4194304            | 5  | 2016842         | 0.4808526039   |
| 12 | 16777216           | 6  | 14117882        | 0.8414913416   |
| 13 | 67108864           | 6  | 14117882        | 0.2103728354   |
| 14 | 268435456          | 7  | 98825162        | 0.3681524172   |
| 15 | 1073741824         | 8  | 691776122       | 0.644266719    |
| 16 | 4294967296         | 8  | 691776122       | 0.1610666797   |
| 17 | 17179869184        | 9  | 4842432842      | 0.2818666889   |
| 18 | 68719476736        | 10 | 33897029882     | 0.4932667053   |
| 19 | 274877906944       | 11 | 237279209162    | 0.8632167343   |
| 20 | 1099511627776      | 11 | 237279209162    | 0.2158041836   |
| 21 | 4398046511104      | 12 | 1660954464122   | 0.3776573213   |
| 22 | 17592186044416     | 13 | 11626681248842  | 0.6609003122   |
| 23 | 70368744177664     | 13 | 11626681248842  | 0.165225078    |
| 24 | 281474976710656    | 14 | 81386768741882  | 0.2891438866   |
| 25 | 1125899906842620   | 15 | 569707381193162 | 0.5060018015   |
| 26 | 4503599627370500   | 15 | 569707381193162 | 0.1265004504   |
| 27 | 18014398509482000  | 15 | 569707381193162 | 0.03162511259  |
| 28 | 72057594037927900  | 15 | 569707381193162 | 0.007906278149 |
| 29 | 288230376151712000 | 15 | 569707381193162 | 0.001976569537 |
</p>
<p>
Hexagonal cells don't align perfectly on a vector tile.
Some cells may intersect more than one vector tile.
To compute the H3 resolution for each precision, Elasticsearch compares the average density of hexagonal bins at each resolution with the average density of tile bins at each zoom level.
Elasticsearch uses the H3 resolution that is closest to the corresponding geotile density.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-vector-tile-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;SearchMvtResponse&gt; SearchMvtAsync&lt;TDocument&gt;(Indices indices, Field field, int zoom, int x, int y, Action&lt;SearchMvtRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>indices</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Indices.html">Indices</a></dt>
    <dd></dd>
    <dt><code>field</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Field.html">Field</a></dt>
    <dd></dd>
    <dt><code>zoom</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd></dd>
    <dt><code>x</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd></dd>
    <dt><code>y</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.SearchMvtRequestDescriptor-1.html">SearchMvtRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.SearchMvtResponse.html">SearchMvtResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchMvtAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchMvtAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchMvtAsync__1_Elastic_Clients_Elasticsearch_Indices_Elastic_Clients_Elasticsearch_Field_System_Int32_System_Int32_System_Int32_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchMvtAsync``1(Elastic.Clients.Elasticsearch.Indices,Elastic.Clients.Elasticsearch.Field,System.Int32,System.Int32,System.Int32,System.Threading.CancellationToken)">
  SearchMvtAsync&lt;TDocument&gt;(Indices, Field, int, int, int, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L33932"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Search a vector tile.
</p>
<p>
Search a vector tile for geospatial values.
Before using this API, you should be familiar with the Mapbox vector tile specification.
The API returns results as a binary mapbox vector tile.
</p>
<p>
Internally, Elasticsearch translates a vector tile search API request into a search containing:
</p>
<ul><li>
<p>
A <code>geo_bounding_box</code> query on the <code>&lt;field&gt;</code>. The query uses the <code>&lt;zoom&gt;/&lt;x&gt;/&lt;y&gt;</code> tile as a bounding box.
</p>
</li><li>
<p>
A <code>geotile_grid</code> or <code>geohex_grid</code> aggregation on the <code>&lt;field&gt;</code>. The <code>grid_agg</code> parameter determines the aggregation type. The aggregation uses the <code>&lt;zoom&gt;/&lt;x&gt;/&lt;y&gt;</code> tile as a bounding box.
</p>
</li><li>
<p>
Optionally, a <code>geo_bounds</code> aggregation on the <code>&lt;field&gt;</code>. The search only includes this aggregation if the <code>exact_bounds</code> parameter is <code>true</code>.
</p>
</li><li>
<p>
If the optional parameter <code>with_labels</code> is <code>true</code>, the internal search will include a dynamic runtime field that calls the <code>getLabelPosition</code> function of the geometry doc value. This enables the generation of new point features containing suggested geometry labels, so that, for example, multi-polygons will have only one label.
</p>
</li></ul>
<p>
For example, Elasticsearch may translate a vector tile search API request with a <code>grid_agg</code> argument of <code>geotile</code> and an <code>exact_bounds</code> argument of <code>true</code> into the following search
</p>
<pre><code class="lang-csharp">GET my-index/_search
{
  "size": 10000,
  "query": {
    "geo_bounding_box": {
      "my-geo-field": {
        "top_left": {
          "lat": -40.979898069620134,
          "lon": -45
        },
        "bottom_right": {
          "lat": -66.51326044311186,
          "lon": 0
        }
      }
    }
  },
  "aggregations": {
    "grid": {
      "geotile_grid": {
        "field": "my-geo-field",
        "precision": 11,
        "size": 65536,
        "bounds": {
          "top_left": {
            "lat": -40.979898069620134,
            "lon": -45
          },
          "bottom_right": {
            "lat": -66.51326044311186,
            "lon": 0
          }
        }
      }
    },
    "bounds": {
      "geo_bounds": {
        "field": "my-geo-field",
        "wrap_longitude": false
      }
    }
  }
}</code></pre>
<p>
The API returns results as a binary Mapbox vector tile.
Mapbox vector tiles are encoded as Google Protobufs (PBF). By default, the tile contains three layers:
</p>
<ul><li>
<p>
A <code>hits</code> layer containing a feature for each <code>&lt;field&gt;</code> value matching the <code>geo_bounding_box</code> query.
</p>
</li><li>
<p>
An <code>aggs</code> layer containing a feature for each cell of the <code>geotile_grid</code> or <code>geohex_grid</code>. The layer only contains features for cells with matching data.
</p>
</li><li>
<p>
A meta layer containing:
</p>
<ul><li>
<p>
A feature containing a bounding box. By default, this is the bounding box of the tile.
</p>
</li><li>
<p>
Value ranges for any sub-aggregations on the <code>geotile_grid</code> or <code>geohex_grid</code>.
</p>
</li><li>
<p>
Metadata for the search.
</p>
</li></ul>
</li></ul>
<p>
The API only returns features that can display at its zoom level.
For example, if a polygon feature has no area at its zoom level, the API omits it.
The API returns errors as UTF-8 encoded JSON.
</p>
<p>
IMPORTANT: You can specify several options for this API as either a query parameter or request body parameter.
If you specify both parameters, the query parameter takes precedence.
</p>
<p>
<strong>Grid precision for geotile</strong>
</p>
<p>
For a <code>grid_agg</code> of <code>geotile</code>, you can use cells in the <code>aggs</code> layer as tiles for lower zoom levels.
<code>grid_precision</code> represents the additional zoom levels available through these cells. The final precision is computed by as follows: <code>&lt;zoom&gt; + grid_precision</code>.
For example, if <code>&lt;zoom&gt;</code> is 7 and <code>grid_precision</code> is 8, then the <code>geotile_grid</code> aggregation will use a precision of 15.
The maximum final precision is 29.
The <code>grid_precision</code> also determines the number of cells for the grid as follows: <code>(2^grid_precision) x (2^grid_precision)</code>.
For example, a value of 8 divides the tile into a grid of 256 x 256 cells.
The <code>aggs</code> layer only contains features for cells with matching data.
</p>
<p>
<strong>Grid precision for geohex</strong>
</p>
<p>
For a <code>grid_agg</code> of <code>geohex</code>, Elasticsearch uses <code>&lt;zoom&gt;</code> and <code>grid_precision</code> to calculate a final precision as follows: <code>&lt;zoom&gt; + grid_precision</code>.
</p>
<p>
This precision determines the H3 resolution of the hexagonal cells produced by the <code>geohex</code> aggregation.
The following table maps the H3 resolution for each precision.
For example, if <code>&lt;zoom&gt;</code> is 3 and <code>grid_precision</code> is 3, the precision is 6.
At a precision of 6, hexagonal cells have an H3 resolution of 2.
If <code>&lt;zoom&gt;</code> is 3 and <code>grid_precision</code> is 4, the precision is 7.
At a precision of 7, hexagonal cells have an H3 resolution of 3.
</p>
<p>
| Precision | Unique tile bins | H3 resolution | Unique hex bins |	Ratio |
| --------- | ---------------- | ------------- | ----------------| ----- |
| 1  | 4                  | 0  | 122             | 30.5           |
| 2  | 16                 | 0  | 122             | 7.625          |
| 3  | 64                 | 1  | 842             | 13.15625       |
| 4  | 256                | 1  | 842             | 3.2890625      |
| 5  | 1024               | 2  | 5882            | 5.744140625    |
| 6  | 4096               | 2  | 5882            | 1.436035156    |
| 7  | 16384              | 3  | 41162           | 2.512329102    |
| 8  | 65536              | 3  | 41162           | 0.6280822754   |
| 9  | 262144             | 4  | 288122          | 1.099098206    |
| 10 | 1048576            | 4  | 288122          | 0.2747745514   |
| 11 | 4194304            | 5  | 2016842         | 0.4808526039   |
| 12 | 16777216           | 6  | 14117882        | 0.8414913416   |
| 13 | 67108864           | 6  | 14117882        | 0.2103728354   |
| 14 | 268435456          | 7  | 98825162        | 0.3681524172   |
| 15 | 1073741824         | 8  | 691776122       | 0.644266719    |
| 16 | 4294967296         | 8  | 691776122       | 0.1610666797   |
| 17 | 17179869184        | 9  | 4842432842      | 0.2818666889   |
| 18 | 68719476736        | 10 | 33897029882     | 0.4932667053   |
| 19 | 274877906944       | 11 | 237279209162    | 0.8632167343   |
| 20 | 1099511627776      | 11 | 237279209162    | 0.2158041836   |
| 21 | 4398046511104      | 12 | 1660954464122   | 0.3776573213   |
| 22 | 17592186044416     | 13 | 11626681248842  | 0.6609003122   |
| 23 | 70368744177664     | 13 | 11626681248842  | 0.165225078    |
| 24 | 281474976710656    | 14 | 81386768741882  | 0.2891438866   |
| 25 | 1125899906842620   | 15 | 569707381193162 | 0.5060018015   |
| 26 | 4503599627370500   | 15 | 569707381193162 | 0.1265004504   |
| 27 | 18014398509482000  | 15 | 569707381193162 | 0.03162511259  |
| 28 | 72057594037927900  | 15 | 569707381193162 | 0.007906278149 |
| 29 | 288230376151712000 | 15 | 569707381193162 | 0.001976569537 |
</p>
<p>
Hexagonal cells don't align perfectly on a vector tile.
Some cells may intersect more than one vector tile.
To compute the H3 resolution for each precision, Elasticsearch compares the average density of hexagonal bins at each resolution with the average density of tile bins at each zoom level.
Elasticsearch uses the H3 resolution that is closest to the corresponding geotile density.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-vector-tile-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;SearchMvtResponse&gt; SearchMvtAsync&lt;TDocument&gt;(Indices indices, Field field, int zoom, int x, int y, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>indices</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Indices.html">Indices</a></dt>
    <dd></dd>
    <dt><code>field</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Field.html">Field</a></dt>
    <dd></dd>
    <dt><code>zoom</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd></dd>
    <dt><code>x</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd></dd>
    <dt><code>y</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.SearchMvtResponse.html">SearchMvtResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchMvtAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchMvtAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchMvtAsync__1_Elastic_Clients_Elasticsearch_SearchMvtRequestDescriptor___0__System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchMvtAsync``1(Elastic.Clients.Elasticsearch.SearchMvtRequestDescriptor{``0},System.Threading.CancellationToken)">
  SearchMvtAsync&lt;TDocument&gt;(SearchMvtRequestDescriptor&lt;TDocument&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L33730"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Search a vector tile.
</p>
<p>
Search a vector tile for geospatial values.
Before using this API, you should be familiar with the Mapbox vector tile specification.
The API returns results as a binary mapbox vector tile.
</p>
<p>
Internally, Elasticsearch translates a vector tile search API request into a search containing:
</p>
<ul><li>
<p>
A <code>geo_bounding_box</code> query on the <code>&lt;field&gt;</code>. The query uses the <code>&lt;zoom&gt;/&lt;x&gt;/&lt;y&gt;</code> tile as a bounding box.
</p>
</li><li>
<p>
A <code>geotile_grid</code> or <code>geohex_grid</code> aggregation on the <code>&lt;field&gt;</code>. The <code>grid_agg</code> parameter determines the aggregation type. The aggregation uses the <code>&lt;zoom&gt;/&lt;x&gt;/&lt;y&gt;</code> tile as a bounding box.
</p>
</li><li>
<p>
Optionally, a <code>geo_bounds</code> aggregation on the <code>&lt;field&gt;</code>. The search only includes this aggregation if the <code>exact_bounds</code> parameter is <code>true</code>.
</p>
</li><li>
<p>
If the optional parameter <code>with_labels</code> is <code>true</code>, the internal search will include a dynamic runtime field that calls the <code>getLabelPosition</code> function of the geometry doc value. This enables the generation of new point features containing suggested geometry labels, so that, for example, multi-polygons will have only one label.
</p>
</li></ul>
<p>
For example, Elasticsearch may translate a vector tile search API request with a <code>grid_agg</code> argument of <code>geotile</code> and an <code>exact_bounds</code> argument of <code>true</code> into the following search
</p>
<pre><code class="lang-csharp">GET my-index/_search
{
  "size": 10000,
  "query": {
    "geo_bounding_box": {
      "my-geo-field": {
        "top_left": {
          "lat": -40.979898069620134,
          "lon": -45
        },
        "bottom_right": {
          "lat": -66.51326044311186,
          "lon": 0
        }
      }
    }
  },
  "aggregations": {
    "grid": {
      "geotile_grid": {
        "field": "my-geo-field",
        "precision": 11,
        "size": 65536,
        "bounds": {
          "top_left": {
            "lat": -40.979898069620134,
            "lon": -45
          },
          "bottom_right": {
            "lat": -66.51326044311186,
            "lon": 0
          }
        }
      }
    },
    "bounds": {
      "geo_bounds": {
        "field": "my-geo-field",
        "wrap_longitude": false
      }
    }
  }
}</code></pre>
<p>
The API returns results as a binary Mapbox vector tile.
Mapbox vector tiles are encoded as Google Protobufs (PBF). By default, the tile contains three layers:
</p>
<ul><li>
<p>
A <code>hits</code> layer containing a feature for each <code>&lt;field&gt;</code> value matching the <code>geo_bounding_box</code> query.
</p>
</li><li>
<p>
An <code>aggs</code> layer containing a feature for each cell of the <code>geotile_grid</code> or <code>geohex_grid</code>. The layer only contains features for cells with matching data.
</p>
</li><li>
<p>
A meta layer containing:
</p>
<ul><li>
<p>
A feature containing a bounding box. By default, this is the bounding box of the tile.
</p>
</li><li>
<p>
Value ranges for any sub-aggregations on the <code>geotile_grid</code> or <code>geohex_grid</code>.
</p>
</li><li>
<p>
Metadata for the search.
</p>
</li></ul>
</li></ul>
<p>
The API only returns features that can display at its zoom level.
For example, if a polygon feature has no area at its zoom level, the API omits it.
The API returns errors as UTF-8 encoded JSON.
</p>
<p>
IMPORTANT: You can specify several options for this API as either a query parameter or request body parameter.
If you specify both parameters, the query parameter takes precedence.
</p>
<p>
<strong>Grid precision for geotile</strong>
</p>
<p>
For a <code>grid_agg</code> of <code>geotile</code>, you can use cells in the <code>aggs</code> layer as tiles for lower zoom levels.
<code>grid_precision</code> represents the additional zoom levels available through these cells. The final precision is computed by as follows: <code>&lt;zoom&gt; + grid_precision</code>.
For example, if <code>&lt;zoom&gt;</code> is 7 and <code>grid_precision</code> is 8, then the <code>geotile_grid</code> aggregation will use a precision of 15.
The maximum final precision is 29.
The <code>grid_precision</code> also determines the number of cells for the grid as follows: <code>(2^grid_precision) x (2^grid_precision)</code>.
For example, a value of 8 divides the tile into a grid of 256 x 256 cells.
The <code>aggs</code> layer only contains features for cells with matching data.
</p>
<p>
<strong>Grid precision for geohex</strong>
</p>
<p>
For a <code>grid_agg</code> of <code>geohex</code>, Elasticsearch uses <code>&lt;zoom&gt;</code> and <code>grid_precision</code> to calculate a final precision as follows: <code>&lt;zoom&gt; + grid_precision</code>.
</p>
<p>
This precision determines the H3 resolution of the hexagonal cells produced by the <code>geohex</code> aggregation.
The following table maps the H3 resolution for each precision.
For example, if <code>&lt;zoom&gt;</code> is 3 and <code>grid_precision</code> is 3, the precision is 6.
At a precision of 6, hexagonal cells have an H3 resolution of 2.
If <code>&lt;zoom&gt;</code> is 3 and <code>grid_precision</code> is 4, the precision is 7.
At a precision of 7, hexagonal cells have an H3 resolution of 3.
</p>
<p>
| Precision | Unique tile bins | H3 resolution | Unique hex bins |	Ratio |
| --------- | ---------------- | ------------- | ----------------| ----- |
| 1  | 4                  | 0  | 122             | 30.5           |
| 2  | 16                 | 0  | 122             | 7.625          |
| 3  | 64                 | 1  | 842             | 13.15625       |
| 4  | 256                | 1  | 842             | 3.2890625      |
| 5  | 1024               | 2  | 5882            | 5.744140625    |
| 6  | 4096               | 2  | 5882            | 1.436035156    |
| 7  | 16384              | 3  | 41162           | 2.512329102    |
| 8  | 65536              | 3  | 41162           | 0.6280822754   |
| 9  | 262144             | 4  | 288122          | 1.099098206    |
| 10 | 1048576            | 4  | 288122          | 0.2747745514   |
| 11 | 4194304            | 5  | 2016842         | 0.4808526039   |
| 12 | 16777216           | 6  | 14117882        | 0.8414913416   |
| 13 | 67108864           | 6  | 14117882        | 0.2103728354   |
| 14 | 268435456          | 7  | 98825162        | 0.3681524172   |
| 15 | 1073741824         | 8  | 691776122       | 0.644266719    |
| 16 | 4294967296         | 8  | 691776122       | 0.1610666797   |
| 17 | 17179869184        | 9  | 4842432842      | 0.2818666889   |
| 18 | 68719476736        | 10 | 33897029882     | 0.4932667053   |
| 19 | 274877906944       | 11 | 237279209162    | 0.8632167343   |
| 20 | 1099511627776      | 11 | 237279209162    | 0.2158041836   |
| 21 | 4398046511104      | 12 | 1660954464122   | 0.3776573213   |
| 22 | 17592186044416     | 13 | 11626681248842  | 0.6609003122   |
| 23 | 70368744177664     | 13 | 11626681248842  | 0.165225078    |
| 24 | 281474976710656    | 14 | 81386768741882  | 0.2891438866   |
| 25 | 1125899906842620   | 15 | 569707381193162 | 0.5060018015   |
| 26 | 4503599627370500   | 15 | 569707381193162 | 0.1265004504   |
| 27 | 18014398509482000  | 15 | 569707381193162 | 0.03162511259  |
| 28 | 72057594037927900  | 15 | 569707381193162 | 0.007906278149 |
| 29 | 288230376151712000 | 15 | 569707381193162 | 0.001976569537 |
</p>
<p>
Hexagonal cells don't align perfectly on a vector tile.
Some cells may intersect more than one vector tile.
To compute the H3 resolution for each precision, Elasticsearch compares the average density of hexagonal bins at each resolution with the average density of tile bins at each zoom level.
Elasticsearch uses the H3 resolution that is closest to the corresponding geotile density.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-vector-tile-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;SearchMvtResponse&gt; SearchMvtAsync&lt;TDocument&gt;(SearchMvtRequestDescriptor&lt;TDocument&gt; descriptor, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.SearchMvtRequestDescriptor-1.html">SearchMvtRequestDescriptor</a>&lt;TDocument&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.SearchMvtResponse.html">SearchMvtResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchMvt_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchMvt*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchMvt__1_Elastic_Clients_Elasticsearch_Field_System_Int32_System_Int32_System_Int32_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchMvt``1(Elastic.Clients.Elasticsearch.Field,System.Int32,System.Int32,System.Int32)">
  SearchMvt&lt;TDocument&gt;(Field, int, int, int)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L32709"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Search a vector tile.
</p>
<p>
Search a vector tile for geospatial values.
Before using this API, you should be familiar with the Mapbox vector tile specification.
The API returns results as a binary mapbox vector tile.
</p>
<p>
Internally, Elasticsearch translates a vector tile search API request into a search containing:
</p>
<ul><li>
<p>
A <code>geo_bounding_box</code> query on the <code>&lt;field&gt;</code>. The query uses the <code>&lt;zoom&gt;/&lt;x&gt;/&lt;y&gt;</code> tile as a bounding box.
</p>
</li><li>
<p>
A <code>geotile_grid</code> or <code>geohex_grid</code> aggregation on the <code>&lt;field&gt;</code>. The <code>grid_agg</code> parameter determines the aggregation type. The aggregation uses the <code>&lt;zoom&gt;/&lt;x&gt;/&lt;y&gt;</code> tile as a bounding box.
</p>
</li><li>
<p>
Optionally, a <code>geo_bounds</code> aggregation on the <code>&lt;field&gt;</code>. The search only includes this aggregation if the <code>exact_bounds</code> parameter is <code>true</code>.
</p>
</li><li>
<p>
If the optional parameter <code>with_labels</code> is <code>true</code>, the internal search will include a dynamic runtime field that calls the <code>getLabelPosition</code> function of the geometry doc value. This enables the generation of new point features containing suggested geometry labels, so that, for example, multi-polygons will have only one label.
</p>
</li></ul>
<p>
For example, Elasticsearch may translate a vector tile search API request with a <code>grid_agg</code> argument of <code>geotile</code> and an <code>exact_bounds</code> argument of <code>true</code> into the following search
</p>
<pre><code class="lang-csharp">GET my-index/_search
{
  "size": 10000,
  "query": {
    "geo_bounding_box": {
      "my-geo-field": {
        "top_left": {
          "lat": -40.979898069620134,
          "lon": -45
        },
        "bottom_right": {
          "lat": -66.51326044311186,
          "lon": 0
        }
      }
    }
  },
  "aggregations": {
    "grid": {
      "geotile_grid": {
        "field": "my-geo-field",
        "precision": 11,
        "size": 65536,
        "bounds": {
          "top_left": {
            "lat": -40.979898069620134,
            "lon": -45
          },
          "bottom_right": {
            "lat": -66.51326044311186,
            "lon": 0
          }
        }
      }
    },
    "bounds": {
      "geo_bounds": {
        "field": "my-geo-field",
        "wrap_longitude": false
      }
    }
  }
}</code></pre>
<p>
The API returns results as a binary Mapbox vector tile.
Mapbox vector tiles are encoded as Google Protobufs (PBF). By default, the tile contains three layers:
</p>
<ul><li>
<p>
A <code>hits</code> layer containing a feature for each <code>&lt;field&gt;</code> value matching the <code>geo_bounding_box</code> query.
</p>
</li><li>
<p>
An <code>aggs</code> layer containing a feature for each cell of the <code>geotile_grid</code> or <code>geohex_grid</code>. The layer only contains features for cells with matching data.
</p>
</li><li>
<p>
A meta layer containing:
</p>
<ul><li>
<p>
A feature containing a bounding box. By default, this is the bounding box of the tile.
</p>
</li><li>
<p>
Value ranges for any sub-aggregations on the <code>geotile_grid</code> or <code>geohex_grid</code>.
</p>
</li><li>
<p>
Metadata for the search.
</p>
</li></ul>
</li></ul>
<p>
The API only returns features that can display at its zoom level.
For example, if a polygon feature has no area at its zoom level, the API omits it.
The API returns errors as UTF-8 encoded JSON.
</p>
<p>
IMPORTANT: You can specify several options for this API as either a query parameter or request body parameter.
If you specify both parameters, the query parameter takes precedence.
</p>
<p>
<strong>Grid precision for geotile</strong>
</p>
<p>
For a <code>grid_agg</code> of <code>geotile</code>, you can use cells in the <code>aggs</code> layer as tiles for lower zoom levels.
<code>grid_precision</code> represents the additional zoom levels available through these cells. The final precision is computed by as follows: <code>&lt;zoom&gt; + grid_precision</code>.
For example, if <code>&lt;zoom&gt;</code> is 7 and <code>grid_precision</code> is 8, then the <code>geotile_grid</code> aggregation will use a precision of 15.
The maximum final precision is 29.
The <code>grid_precision</code> also determines the number of cells for the grid as follows: <code>(2^grid_precision) x (2^grid_precision)</code>.
For example, a value of 8 divides the tile into a grid of 256 x 256 cells.
The <code>aggs</code> layer only contains features for cells with matching data.
</p>
<p>
<strong>Grid precision for geohex</strong>
</p>
<p>
For a <code>grid_agg</code> of <code>geohex</code>, Elasticsearch uses <code>&lt;zoom&gt;</code> and <code>grid_precision</code> to calculate a final precision as follows: <code>&lt;zoom&gt; + grid_precision</code>.
</p>
<p>
This precision determines the H3 resolution of the hexagonal cells produced by the <code>geohex</code> aggregation.
The following table maps the H3 resolution for each precision.
For example, if <code>&lt;zoom&gt;</code> is 3 and <code>grid_precision</code> is 3, the precision is 6.
At a precision of 6, hexagonal cells have an H3 resolution of 2.
If <code>&lt;zoom&gt;</code> is 3 and <code>grid_precision</code> is 4, the precision is 7.
At a precision of 7, hexagonal cells have an H3 resolution of 3.
</p>
<p>
| Precision | Unique tile bins | H3 resolution | Unique hex bins |	Ratio |
| --------- | ---------------- | ------------- | ----------------| ----- |
| 1  | 4                  | 0  | 122             | 30.5           |
| 2  | 16                 | 0  | 122             | 7.625          |
| 3  | 64                 | 1  | 842             | 13.15625       |
| 4  | 256                | 1  | 842             | 3.2890625      |
| 5  | 1024               | 2  | 5882            | 5.744140625    |
| 6  | 4096               | 2  | 5882            | 1.436035156    |
| 7  | 16384              | 3  | 41162           | 2.512329102    |
| 8  | 65536              | 3  | 41162           | 0.6280822754   |
| 9  | 262144             | 4  | 288122          | 1.099098206    |
| 10 | 1048576            | 4  | 288122          | 0.2747745514   |
| 11 | 4194304            | 5  | 2016842         | 0.4808526039   |
| 12 | 16777216           | 6  | 14117882        | 0.8414913416   |
| 13 | 67108864           | 6  | 14117882        | 0.2103728354   |
| 14 | 268435456          | 7  | 98825162        | 0.3681524172   |
| 15 | 1073741824         | 8  | 691776122       | 0.644266719    |
| 16 | 4294967296         | 8  | 691776122       | 0.1610666797   |
| 17 | 17179869184        | 9  | 4842432842      | 0.2818666889   |
| 18 | 68719476736        | 10 | 33897029882     | 0.4932667053   |
| 19 | 274877906944       | 11 | 237279209162    | 0.8632167343   |
| 20 | 1099511627776      | 11 | 237279209162    | 0.2158041836   |
| 21 | 4398046511104      | 12 | 1660954464122   | 0.3776573213   |
| 22 | 17592186044416     | 13 | 11626681248842  | 0.6609003122   |
| 23 | 70368744177664     | 13 | 11626681248842  | 0.165225078    |
| 24 | 281474976710656    | 14 | 81386768741882  | 0.2891438866   |
| 25 | 1125899906842620   | 15 | 569707381193162 | 0.5060018015   |
| 26 | 4503599627370500   | 15 | 569707381193162 | 0.1265004504   |
| 27 | 18014398509482000  | 15 | 569707381193162 | 0.03162511259  |
| 28 | 72057594037927900  | 15 | 569707381193162 | 0.007906278149 |
| 29 | 288230376151712000 | 15 | 569707381193162 | 0.001976569537 |
</p>
<p>
Hexagonal cells don't align perfectly on a vector tile.
Some cells may intersect more than one vector tile.
To compute the H3 resolution for each precision, Elasticsearch compares the average density of hexagonal bins at each resolution with the average density of tile bins at each zoom level.
Elasticsearch uses the H3 resolution that is closest to the corresponding geotile density.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-vector-tile-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual SearchMvtResponse SearchMvt&lt;TDocument&gt;(Field field, int zoom, int x, int y)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>field</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Field.html">Field</a></dt>
    <dd></dd>
    <dt><code>zoom</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd></dd>
    <dt><code>x</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd></dd>
    <dt><code>y</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.SearchMvtResponse.html">SearchMvtResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchMvt_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchMvt*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchMvt__1_Elastic_Clients_Elasticsearch_Field_System_Int32_System_Int32_System_Int32_System_Action_Elastic_Clients_Elasticsearch_SearchMvtRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchMvt``1(Elastic.Clients.Elasticsearch.Field,System.Int32,System.Int32,System.Int32,System.Action{Elastic.Clients.Elasticsearch.SearchMvtRequestDescriptor{``0}})">
  SearchMvt&lt;TDocument&gt;(Field, int, int, int, Action&lt;SearchMvtRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L32913"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Search a vector tile.
</p>
<p>
Search a vector tile for geospatial values.
Before using this API, you should be familiar with the Mapbox vector tile specification.
The API returns results as a binary mapbox vector tile.
</p>
<p>
Internally, Elasticsearch translates a vector tile search API request into a search containing:
</p>
<ul><li>
<p>
A <code>geo_bounding_box</code> query on the <code>&lt;field&gt;</code>. The query uses the <code>&lt;zoom&gt;/&lt;x&gt;/&lt;y&gt;</code> tile as a bounding box.
</p>
</li><li>
<p>
A <code>geotile_grid</code> or <code>geohex_grid</code> aggregation on the <code>&lt;field&gt;</code>. The <code>grid_agg</code> parameter determines the aggregation type. The aggregation uses the <code>&lt;zoom&gt;/&lt;x&gt;/&lt;y&gt;</code> tile as a bounding box.
</p>
</li><li>
<p>
Optionally, a <code>geo_bounds</code> aggregation on the <code>&lt;field&gt;</code>. The search only includes this aggregation if the <code>exact_bounds</code> parameter is <code>true</code>.
</p>
</li><li>
<p>
If the optional parameter <code>with_labels</code> is <code>true</code>, the internal search will include a dynamic runtime field that calls the <code>getLabelPosition</code> function of the geometry doc value. This enables the generation of new point features containing suggested geometry labels, so that, for example, multi-polygons will have only one label.
</p>
</li></ul>
<p>
For example, Elasticsearch may translate a vector tile search API request with a <code>grid_agg</code> argument of <code>geotile</code> and an <code>exact_bounds</code> argument of <code>true</code> into the following search
</p>
<pre><code class="lang-csharp">GET my-index/_search
{
  "size": 10000,
  "query": {
    "geo_bounding_box": {
      "my-geo-field": {
        "top_left": {
          "lat": -40.979898069620134,
          "lon": -45
        },
        "bottom_right": {
          "lat": -66.51326044311186,
          "lon": 0
        }
      }
    }
  },
  "aggregations": {
    "grid": {
      "geotile_grid": {
        "field": "my-geo-field",
        "precision": 11,
        "size": 65536,
        "bounds": {
          "top_left": {
            "lat": -40.979898069620134,
            "lon": -45
          },
          "bottom_right": {
            "lat": -66.51326044311186,
            "lon": 0
          }
        }
      }
    },
    "bounds": {
      "geo_bounds": {
        "field": "my-geo-field",
        "wrap_longitude": false
      }
    }
  }
}</code></pre>
<p>
The API returns results as a binary Mapbox vector tile.
Mapbox vector tiles are encoded as Google Protobufs (PBF). By default, the tile contains three layers:
</p>
<ul><li>
<p>
A <code>hits</code> layer containing a feature for each <code>&lt;field&gt;</code> value matching the <code>geo_bounding_box</code> query.
</p>
</li><li>
<p>
An <code>aggs</code> layer containing a feature for each cell of the <code>geotile_grid</code> or <code>geohex_grid</code>. The layer only contains features for cells with matching data.
</p>
</li><li>
<p>
A meta layer containing:
</p>
<ul><li>
<p>
A feature containing a bounding box. By default, this is the bounding box of the tile.
</p>
</li><li>
<p>
Value ranges for any sub-aggregations on the <code>geotile_grid</code> or <code>geohex_grid</code>.
</p>
</li><li>
<p>
Metadata for the search.
</p>
</li></ul>
</li></ul>
<p>
The API only returns features that can display at its zoom level.
For example, if a polygon feature has no area at its zoom level, the API omits it.
The API returns errors as UTF-8 encoded JSON.
</p>
<p>
IMPORTANT: You can specify several options for this API as either a query parameter or request body parameter.
If you specify both parameters, the query parameter takes precedence.
</p>
<p>
<strong>Grid precision for geotile</strong>
</p>
<p>
For a <code>grid_agg</code> of <code>geotile</code>, you can use cells in the <code>aggs</code> layer as tiles for lower zoom levels.
<code>grid_precision</code> represents the additional zoom levels available through these cells. The final precision is computed by as follows: <code>&lt;zoom&gt; + grid_precision</code>.
For example, if <code>&lt;zoom&gt;</code> is 7 and <code>grid_precision</code> is 8, then the <code>geotile_grid</code> aggregation will use a precision of 15.
The maximum final precision is 29.
The <code>grid_precision</code> also determines the number of cells for the grid as follows: <code>(2^grid_precision) x (2^grid_precision)</code>.
For example, a value of 8 divides the tile into a grid of 256 x 256 cells.
The <code>aggs</code> layer only contains features for cells with matching data.
</p>
<p>
<strong>Grid precision for geohex</strong>
</p>
<p>
For a <code>grid_agg</code> of <code>geohex</code>, Elasticsearch uses <code>&lt;zoom&gt;</code> and <code>grid_precision</code> to calculate a final precision as follows: <code>&lt;zoom&gt; + grid_precision</code>.
</p>
<p>
This precision determines the H3 resolution of the hexagonal cells produced by the <code>geohex</code> aggregation.
The following table maps the H3 resolution for each precision.
For example, if <code>&lt;zoom&gt;</code> is 3 and <code>grid_precision</code> is 3, the precision is 6.
At a precision of 6, hexagonal cells have an H3 resolution of 2.
If <code>&lt;zoom&gt;</code> is 3 and <code>grid_precision</code> is 4, the precision is 7.
At a precision of 7, hexagonal cells have an H3 resolution of 3.
</p>
<p>
| Precision | Unique tile bins | H3 resolution | Unique hex bins |	Ratio |
| --------- | ---------------- | ------------- | ----------------| ----- |
| 1  | 4                  | 0  | 122             | 30.5           |
| 2  | 16                 | 0  | 122             | 7.625          |
| 3  | 64                 | 1  | 842             | 13.15625       |
| 4  | 256                | 1  | 842             | 3.2890625      |
| 5  | 1024               | 2  | 5882            | 5.744140625    |
| 6  | 4096               | 2  | 5882            | 1.436035156    |
| 7  | 16384              | 3  | 41162           | 2.512329102    |
| 8  | 65536              | 3  | 41162           | 0.6280822754   |
| 9  | 262144             | 4  | 288122          | 1.099098206    |
| 10 | 1048576            | 4  | 288122          | 0.2747745514   |
| 11 | 4194304            | 5  | 2016842         | 0.4808526039   |
| 12 | 16777216           | 6  | 14117882        | 0.8414913416   |
| 13 | 67108864           | 6  | 14117882        | 0.2103728354   |
| 14 | 268435456          | 7  | 98825162        | 0.3681524172   |
| 15 | 1073741824         | 8  | 691776122       | 0.644266719    |
| 16 | 4294967296         | 8  | 691776122       | 0.1610666797   |
| 17 | 17179869184        | 9  | 4842432842      | 0.2818666889   |
| 18 | 68719476736        | 10 | 33897029882     | 0.4932667053   |
| 19 | 274877906944       | 11 | 237279209162    | 0.8632167343   |
| 20 | 1099511627776      | 11 | 237279209162    | 0.2158041836   |
| 21 | 4398046511104      | 12 | 1660954464122   | 0.3776573213   |
| 22 | 17592186044416     | 13 | 11626681248842  | 0.6609003122   |
| 23 | 70368744177664     | 13 | 11626681248842  | 0.165225078    |
| 24 | 281474976710656    | 14 | 81386768741882  | 0.2891438866   |
| 25 | 1125899906842620   | 15 | 569707381193162 | 0.5060018015   |
| 26 | 4503599627370500   | 15 | 569707381193162 | 0.1265004504   |
| 27 | 18014398509482000  | 15 | 569707381193162 | 0.03162511259  |
| 28 | 72057594037927900  | 15 | 569707381193162 | 0.007906278149 |
| 29 | 288230376151712000 | 15 | 569707381193162 | 0.001976569537 |
</p>
<p>
Hexagonal cells don't align perfectly on a vector tile.
Some cells may intersect more than one vector tile.
To compute the H3 resolution for each precision, Elasticsearch compares the average density of hexagonal bins at each resolution with the average density of tile bins at each zoom level.
Elasticsearch uses the H3 resolution that is closest to the corresponding geotile density.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-vector-tile-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual SearchMvtResponse SearchMvt&lt;TDocument&gt;(Field field, int zoom, int x, int y, Action&lt;SearchMvtRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>field</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Field.html">Field</a></dt>
    <dd></dd>
    <dt><code>zoom</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd></dd>
    <dt><code>x</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd></dd>
    <dt><code>y</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.SearchMvtRequestDescriptor-1.html">SearchMvtRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.SearchMvtResponse.html">SearchMvtResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchMvt_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchMvt*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchMvt__1_Elastic_Clients_Elasticsearch_Indices_Elastic_Clients_Elasticsearch_Field_System_Int32_System_Int32_System_Int32_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchMvt``1(Elastic.Clients.Elasticsearch.Indices,Elastic.Clients.Elasticsearch.Field,System.Int32,System.Int32,System.Int32)">
  SearchMvt&lt;TDocument&gt;(Indices, Field, int, int, int)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L32300"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Search a vector tile.
</p>
<p>
Search a vector tile for geospatial values.
Before using this API, you should be familiar with the Mapbox vector tile specification.
The API returns results as a binary mapbox vector tile.
</p>
<p>
Internally, Elasticsearch translates a vector tile search API request into a search containing:
</p>
<ul><li>
<p>
A <code>geo_bounding_box</code> query on the <code>&lt;field&gt;</code>. The query uses the <code>&lt;zoom&gt;/&lt;x&gt;/&lt;y&gt;</code> tile as a bounding box.
</p>
</li><li>
<p>
A <code>geotile_grid</code> or <code>geohex_grid</code> aggregation on the <code>&lt;field&gt;</code>. The <code>grid_agg</code> parameter determines the aggregation type. The aggregation uses the <code>&lt;zoom&gt;/&lt;x&gt;/&lt;y&gt;</code> tile as a bounding box.
</p>
</li><li>
<p>
Optionally, a <code>geo_bounds</code> aggregation on the <code>&lt;field&gt;</code>. The search only includes this aggregation if the <code>exact_bounds</code> parameter is <code>true</code>.
</p>
</li><li>
<p>
If the optional parameter <code>with_labels</code> is <code>true</code>, the internal search will include a dynamic runtime field that calls the <code>getLabelPosition</code> function of the geometry doc value. This enables the generation of new point features containing suggested geometry labels, so that, for example, multi-polygons will have only one label.
</p>
</li></ul>
<p>
For example, Elasticsearch may translate a vector tile search API request with a <code>grid_agg</code> argument of <code>geotile</code> and an <code>exact_bounds</code> argument of <code>true</code> into the following search
</p>
<pre><code class="lang-csharp">GET my-index/_search
{
  "size": 10000,
  "query": {
    "geo_bounding_box": {
      "my-geo-field": {
        "top_left": {
          "lat": -40.979898069620134,
          "lon": -45
        },
        "bottom_right": {
          "lat": -66.51326044311186,
          "lon": 0
        }
      }
    }
  },
  "aggregations": {
    "grid": {
      "geotile_grid": {
        "field": "my-geo-field",
        "precision": 11,
        "size": 65536,
        "bounds": {
          "top_left": {
            "lat": -40.979898069620134,
            "lon": -45
          },
          "bottom_right": {
            "lat": -66.51326044311186,
            "lon": 0
          }
        }
      }
    },
    "bounds": {
      "geo_bounds": {
        "field": "my-geo-field",
        "wrap_longitude": false
      }
    }
  }
}</code></pre>
<p>
The API returns results as a binary Mapbox vector tile.
Mapbox vector tiles are encoded as Google Protobufs (PBF). By default, the tile contains three layers:
</p>
<ul><li>
<p>
A <code>hits</code> layer containing a feature for each <code>&lt;field&gt;</code> value matching the <code>geo_bounding_box</code> query.
</p>
</li><li>
<p>
An <code>aggs</code> layer containing a feature for each cell of the <code>geotile_grid</code> or <code>geohex_grid</code>. The layer only contains features for cells with matching data.
</p>
</li><li>
<p>
A meta layer containing:
</p>
<ul><li>
<p>
A feature containing a bounding box. By default, this is the bounding box of the tile.
</p>
</li><li>
<p>
Value ranges for any sub-aggregations on the <code>geotile_grid</code> or <code>geohex_grid</code>.
</p>
</li><li>
<p>
Metadata for the search.
</p>
</li></ul>
</li></ul>
<p>
The API only returns features that can display at its zoom level.
For example, if a polygon feature has no area at its zoom level, the API omits it.
The API returns errors as UTF-8 encoded JSON.
</p>
<p>
IMPORTANT: You can specify several options for this API as either a query parameter or request body parameter.
If you specify both parameters, the query parameter takes precedence.
</p>
<p>
<strong>Grid precision for geotile</strong>
</p>
<p>
For a <code>grid_agg</code> of <code>geotile</code>, you can use cells in the <code>aggs</code> layer as tiles for lower zoom levels.
<code>grid_precision</code> represents the additional zoom levels available through these cells. The final precision is computed by as follows: <code>&lt;zoom&gt; + grid_precision</code>.
For example, if <code>&lt;zoom&gt;</code> is 7 and <code>grid_precision</code> is 8, then the <code>geotile_grid</code> aggregation will use a precision of 15.
The maximum final precision is 29.
The <code>grid_precision</code> also determines the number of cells for the grid as follows: <code>(2^grid_precision) x (2^grid_precision)</code>.
For example, a value of 8 divides the tile into a grid of 256 x 256 cells.
The <code>aggs</code> layer only contains features for cells with matching data.
</p>
<p>
<strong>Grid precision for geohex</strong>
</p>
<p>
For a <code>grid_agg</code> of <code>geohex</code>, Elasticsearch uses <code>&lt;zoom&gt;</code> and <code>grid_precision</code> to calculate a final precision as follows: <code>&lt;zoom&gt; + grid_precision</code>.
</p>
<p>
This precision determines the H3 resolution of the hexagonal cells produced by the <code>geohex</code> aggregation.
The following table maps the H3 resolution for each precision.
For example, if <code>&lt;zoom&gt;</code> is 3 and <code>grid_precision</code> is 3, the precision is 6.
At a precision of 6, hexagonal cells have an H3 resolution of 2.
If <code>&lt;zoom&gt;</code> is 3 and <code>grid_precision</code> is 4, the precision is 7.
At a precision of 7, hexagonal cells have an H3 resolution of 3.
</p>
<p>
| Precision | Unique tile bins | H3 resolution | Unique hex bins |	Ratio |
| --------- | ---------------- | ------------- | ----------------| ----- |
| 1  | 4                  | 0  | 122             | 30.5           |
| 2  | 16                 | 0  | 122             | 7.625          |
| 3  | 64                 | 1  | 842             | 13.15625       |
| 4  | 256                | 1  | 842             | 3.2890625      |
| 5  | 1024               | 2  | 5882            | 5.744140625    |
| 6  | 4096               | 2  | 5882            | 1.436035156    |
| 7  | 16384              | 3  | 41162           | 2.512329102    |
| 8  | 65536              | 3  | 41162           | 0.6280822754   |
| 9  | 262144             | 4  | 288122          | 1.099098206    |
| 10 | 1048576            | 4  | 288122          | 0.2747745514   |
| 11 | 4194304            | 5  | 2016842         | 0.4808526039   |
| 12 | 16777216           | 6  | 14117882        | 0.8414913416   |
| 13 | 67108864           | 6  | 14117882        | 0.2103728354   |
| 14 | 268435456          | 7  | 98825162        | 0.3681524172   |
| 15 | 1073741824         | 8  | 691776122       | 0.644266719    |
| 16 | 4294967296         | 8  | 691776122       | 0.1610666797   |
| 17 | 17179869184        | 9  | 4842432842      | 0.2818666889   |
| 18 | 68719476736        | 10 | 33897029882     | 0.4932667053   |
| 19 | 274877906944       | 11 | 237279209162    | 0.8632167343   |
| 20 | 1099511627776      | 11 | 237279209162    | 0.2158041836   |
| 21 | 4398046511104      | 12 | 1660954464122   | 0.3776573213   |
| 22 | 17592186044416     | 13 | 11626681248842  | 0.6609003122   |
| 23 | 70368744177664     | 13 | 11626681248842  | 0.165225078    |
| 24 | 281474976710656    | 14 | 81386768741882  | 0.2891438866   |
| 25 | 1125899906842620   | 15 | 569707381193162 | 0.5060018015   |
| 26 | 4503599627370500   | 15 | 569707381193162 | 0.1265004504   |
| 27 | 18014398509482000  | 15 | 569707381193162 | 0.03162511259  |
| 28 | 72057594037927900  | 15 | 569707381193162 | 0.007906278149 |
| 29 | 288230376151712000 | 15 | 569707381193162 | 0.001976569537 |
</p>
<p>
Hexagonal cells don't align perfectly on a vector tile.
Some cells may intersect more than one vector tile.
To compute the H3 resolution for each precision, Elasticsearch compares the average density of hexagonal bins at each resolution with the average density of tile bins at each zoom level.
Elasticsearch uses the H3 resolution that is closest to the corresponding geotile density.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-vector-tile-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual SearchMvtResponse SearchMvt&lt;TDocument&gt;(Indices indices, Field field, int zoom, int x, int y)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>indices</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Indices.html">Indices</a></dt>
    <dd></dd>
    <dt><code>field</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Field.html">Field</a></dt>
    <dd></dd>
    <dt><code>zoom</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd></dd>
    <dt><code>x</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd></dd>
    <dt><code>y</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.SearchMvtResponse.html">SearchMvtResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchMvt_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchMvt*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchMvt__1_Elastic_Clients_Elasticsearch_Indices_Elastic_Clients_Elasticsearch_Field_System_Int32_System_Int32_System_Int32_System_Action_Elastic_Clients_Elasticsearch_SearchMvtRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchMvt``1(Elastic.Clients.Elasticsearch.Indices,Elastic.Clients.Elasticsearch.Field,System.Int32,System.Int32,System.Int32,System.Action{Elastic.Clients.Elasticsearch.SearchMvtRequestDescriptor{``0}})">
  SearchMvt&lt;TDocument&gt;(Indices, Field, int, int, int, Action&lt;SearchMvtRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L32504"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Search a vector tile.
</p>
<p>
Search a vector tile for geospatial values.
Before using this API, you should be familiar with the Mapbox vector tile specification.
The API returns results as a binary mapbox vector tile.
</p>
<p>
Internally, Elasticsearch translates a vector tile search API request into a search containing:
</p>
<ul><li>
<p>
A <code>geo_bounding_box</code> query on the <code>&lt;field&gt;</code>. The query uses the <code>&lt;zoom&gt;/&lt;x&gt;/&lt;y&gt;</code> tile as a bounding box.
</p>
</li><li>
<p>
A <code>geotile_grid</code> or <code>geohex_grid</code> aggregation on the <code>&lt;field&gt;</code>. The <code>grid_agg</code> parameter determines the aggregation type. The aggregation uses the <code>&lt;zoom&gt;/&lt;x&gt;/&lt;y&gt;</code> tile as a bounding box.
</p>
</li><li>
<p>
Optionally, a <code>geo_bounds</code> aggregation on the <code>&lt;field&gt;</code>. The search only includes this aggregation if the <code>exact_bounds</code> parameter is <code>true</code>.
</p>
</li><li>
<p>
If the optional parameter <code>with_labels</code> is <code>true</code>, the internal search will include a dynamic runtime field that calls the <code>getLabelPosition</code> function of the geometry doc value. This enables the generation of new point features containing suggested geometry labels, so that, for example, multi-polygons will have only one label.
</p>
</li></ul>
<p>
For example, Elasticsearch may translate a vector tile search API request with a <code>grid_agg</code> argument of <code>geotile</code> and an <code>exact_bounds</code> argument of <code>true</code> into the following search
</p>
<pre><code class="lang-csharp">GET my-index/_search
{
  "size": 10000,
  "query": {
    "geo_bounding_box": {
      "my-geo-field": {
        "top_left": {
          "lat": -40.979898069620134,
          "lon": -45
        },
        "bottom_right": {
          "lat": -66.51326044311186,
          "lon": 0
        }
      }
    }
  },
  "aggregations": {
    "grid": {
      "geotile_grid": {
        "field": "my-geo-field",
        "precision": 11,
        "size": 65536,
        "bounds": {
          "top_left": {
            "lat": -40.979898069620134,
            "lon": -45
          },
          "bottom_right": {
            "lat": -66.51326044311186,
            "lon": 0
          }
        }
      }
    },
    "bounds": {
      "geo_bounds": {
        "field": "my-geo-field",
        "wrap_longitude": false
      }
    }
  }
}</code></pre>
<p>
The API returns results as a binary Mapbox vector tile.
Mapbox vector tiles are encoded as Google Protobufs (PBF). By default, the tile contains three layers:
</p>
<ul><li>
<p>
A <code>hits</code> layer containing a feature for each <code>&lt;field&gt;</code> value matching the <code>geo_bounding_box</code> query.
</p>
</li><li>
<p>
An <code>aggs</code> layer containing a feature for each cell of the <code>geotile_grid</code> or <code>geohex_grid</code>. The layer only contains features for cells with matching data.
</p>
</li><li>
<p>
A meta layer containing:
</p>
<ul><li>
<p>
A feature containing a bounding box. By default, this is the bounding box of the tile.
</p>
</li><li>
<p>
Value ranges for any sub-aggregations on the <code>geotile_grid</code> or <code>geohex_grid</code>.
</p>
</li><li>
<p>
Metadata for the search.
</p>
</li></ul>
</li></ul>
<p>
The API only returns features that can display at its zoom level.
For example, if a polygon feature has no area at its zoom level, the API omits it.
The API returns errors as UTF-8 encoded JSON.
</p>
<p>
IMPORTANT: You can specify several options for this API as either a query parameter or request body parameter.
If you specify both parameters, the query parameter takes precedence.
</p>
<p>
<strong>Grid precision for geotile</strong>
</p>
<p>
For a <code>grid_agg</code> of <code>geotile</code>, you can use cells in the <code>aggs</code> layer as tiles for lower zoom levels.
<code>grid_precision</code> represents the additional zoom levels available through these cells. The final precision is computed by as follows: <code>&lt;zoom&gt; + grid_precision</code>.
For example, if <code>&lt;zoom&gt;</code> is 7 and <code>grid_precision</code> is 8, then the <code>geotile_grid</code> aggregation will use a precision of 15.
The maximum final precision is 29.
The <code>grid_precision</code> also determines the number of cells for the grid as follows: <code>(2^grid_precision) x (2^grid_precision)</code>.
For example, a value of 8 divides the tile into a grid of 256 x 256 cells.
The <code>aggs</code> layer only contains features for cells with matching data.
</p>
<p>
<strong>Grid precision for geohex</strong>
</p>
<p>
For a <code>grid_agg</code> of <code>geohex</code>, Elasticsearch uses <code>&lt;zoom&gt;</code> and <code>grid_precision</code> to calculate a final precision as follows: <code>&lt;zoom&gt; + grid_precision</code>.
</p>
<p>
This precision determines the H3 resolution of the hexagonal cells produced by the <code>geohex</code> aggregation.
The following table maps the H3 resolution for each precision.
For example, if <code>&lt;zoom&gt;</code> is 3 and <code>grid_precision</code> is 3, the precision is 6.
At a precision of 6, hexagonal cells have an H3 resolution of 2.
If <code>&lt;zoom&gt;</code> is 3 and <code>grid_precision</code> is 4, the precision is 7.
At a precision of 7, hexagonal cells have an H3 resolution of 3.
</p>
<p>
| Precision | Unique tile bins | H3 resolution | Unique hex bins |	Ratio |
| --------- | ---------------- | ------------- | ----------------| ----- |
| 1  | 4                  | 0  | 122             | 30.5           |
| 2  | 16                 | 0  | 122             | 7.625          |
| 3  | 64                 | 1  | 842             | 13.15625       |
| 4  | 256                | 1  | 842             | 3.2890625      |
| 5  | 1024               | 2  | 5882            | 5.744140625    |
| 6  | 4096               | 2  | 5882            | 1.436035156    |
| 7  | 16384              | 3  | 41162           | 2.512329102    |
| 8  | 65536              | 3  | 41162           | 0.6280822754   |
| 9  | 262144             | 4  | 288122          | 1.099098206    |
| 10 | 1048576            | 4  | 288122          | 0.2747745514   |
| 11 | 4194304            | 5  | 2016842         | 0.4808526039   |
| 12 | 16777216           | 6  | 14117882        | 0.8414913416   |
| 13 | 67108864           | 6  | 14117882        | 0.2103728354   |
| 14 | 268435456          | 7  | 98825162        | 0.3681524172   |
| 15 | 1073741824         | 8  | 691776122       | 0.644266719    |
| 16 | 4294967296         | 8  | 691776122       | 0.1610666797   |
| 17 | 17179869184        | 9  | 4842432842      | 0.2818666889   |
| 18 | 68719476736        | 10 | 33897029882     | 0.4932667053   |
| 19 | 274877906944       | 11 | 237279209162    | 0.8632167343   |
| 20 | 1099511627776      | 11 | 237279209162    | 0.2158041836   |
| 21 | 4398046511104      | 12 | 1660954464122   | 0.3776573213   |
| 22 | 17592186044416     | 13 | 11626681248842  | 0.6609003122   |
| 23 | 70368744177664     | 13 | 11626681248842  | 0.165225078    |
| 24 | 281474976710656    | 14 | 81386768741882  | 0.2891438866   |
| 25 | 1125899906842620   | 15 | 569707381193162 | 0.5060018015   |
| 26 | 4503599627370500   | 15 | 569707381193162 | 0.1265004504   |
| 27 | 18014398509482000  | 15 | 569707381193162 | 0.03162511259  |
| 28 | 72057594037927900  | 15 | 569707381193162 | 0.007906278149 |
| 29 | 288230376151712000 | 15 | 569707381193162 | 0.001976569537 |
</p>
<p>
Hexagonal cells don't align perfectly on a vector tile.
Some cells may intersect more than one vector tile.
To compute the H3 resolution for each precision, Elasticsearch compares the average density of hexagonal bins at each resolution with the average density of tile bins at each zoom level.
Elasticsearch uses the H3 resolution that is closest to the corresponding geotile density.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-vector-tile-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual SearchMvtResponse SearchMvt&lt;TDocument&gt;(Indices indices, Field field, int zoom, int x, int y, Action&lt;SearchMvtRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>indices</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Indices.html">Indices</a></dt>
    <dd></dd>
    <dt><code>field</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Field.html">Field</a></dt>
    <dd></dd>
    <dt><code>zoom</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd></dd>
    <dt><code>x</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd></dd>
    <dt><code>y</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.SearchMvtRequestDescriptor-1.html">SearchMvtRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.SearchMvtResponse.html">SearchMvtResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchMvt_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchMvt*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchMvt__1_Elastic_Clients_Elasticsearch_SearchMvtRequestDescriptor___0__" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchMvt``1(Elastic.Clients.Elasticsearch.SearchMvtRequestDescriptor{``0})">
  SearchMvt&lt;TDocument&gt;(SearchMvtRequestDescriptor&lt;TDocument&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L32097"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Search a vector tile.
</p>
<p>
Search a vector tile for geospatial values.
Before using this API, you should be familiar with the Mapbox vector tile specification.
The API returns results as a binary mapbox vector tile.
</p>
<p>
Internally, Elasticsearch translates a vector tile search API request into a search containing:
</p>
<ul><li>
<p>
A <code>geo_bounding_box</code> query on the <code>&lt;field&gt;</code>. The query uses the <code>&lt;zoom&gt;/&lt;x&gt;/&lt;y&gt;</code> tile as a bounding box.
</p>
</li><li>
<p>
A <code>geotile_grid</code> or <code>geohex_grid</code> aggregation on the <code>&lt;field&gt;</code>. The <code>grid_agg</code> parameter determines the aggregation type. The aggregation uses the <code>&lt;zoom&gt;/&lt;x&gt;/&lt;y&gt;</code> tile as a bounding box.
</p>
</li><li>
<p>
Optionally, a <code>geo_bounds</code> aggregation on the <code>&lt;field&gt;</code>. The search only includes this aggregation if the <code>exact_bounds</code> parameter is <code>true</code>.
</p>
</li><li>
<p>
If the optional parameter <code>with_labels</code> is <code>true</code>, the internal search will include a dynamic runtime field that calls the <code>getLabelPosition</code> function of the geometry doc value. This enables the generation of new point features containing suggested geometry labels, so that, for example, multi-polygons will have only one label.
</p>
</li></ul>
<p>
For example, Elasticsearch may translate a vector tile search API request with a <code>grid_agg</code> argument of <code>geotile</code> and an <code>exact_bounds</code> argument of <code>true</code> into the following search
</p>
<pre><code class="lang-csharp">GET my-index/_search
{
  "size": 10000,
  "query": {
    "geo_bounding_box": {
      "my-geo-field": {
        "top_left": {
          "lat": -40.979898069620134,
          "lon": -45
        },
        "bottom_right": {
          "lat": -66.51326044311186,
          "lon": 0
        }
      }
    }
  },
  "aggregations": {
    "grid": {
      "geotile_grid": {
        "field": "my-geo-field",
        "precision": 11,
        "size": 65536,
        "bounds": {
          "top_left": {
            "lat": -40.979898069620134,
            "lon": -45
          },
          "bottom_right": {
            "lat": -66.51326044311186,
            "lon": 0
          }
        }
      }
    },
    "bounds": {
      "geo_bounds": {
        "field": "my-geo-field",
        "wrap_longitude": false
      }
    }
  }
}</code></pre>
<p>
The API returns results as a binary Mapbox vector tile.
Mapbox vector tiles are encoded as Google Protobufs (PBF). By default, the tile contains three layers:
</p>
<ul><li>
<p>
A <code>hits</code> layer containing a feature for each <code>&lt;field&gt;</code> value matching the <code>geo_bounding_box</code> query.
</p>
</li><li>
<p>
An <code>aggs</code> layer containing a feature for each cell of the <code>geotile_grid</code> or <code>geohex_grid</code>. The layer only contains features for cells with matching data.
</p>
</li><li>
<p>
A meta layer containing:
</p>
<ul><li>
<p>
A feature containing a bounding box. By default, this is the bounding box of the tile.
</p>
</li><li>
<p>
Value ranges for any sub-aggregations on the <code>geotile_grid</code> or <code>geohex_grid</code>.
</p>
</li><li>
<p>
Metadata for the search.
</p>
</li></ul>
</li></ul>
<p>
The API only returns features that can display at its zoom level.
For example, if a polygon feature has no area at its zoom level, the API omits it.
The API returns errors as UTF-8 encoded JSON.
</p>
<p>
IMPORTANT: You can specify several options for this API as either a query parameter or request body parameter.
If you specify both parameters, the query parameter takes precedence.
</p>
<p>
<strong>Grid precision for geotile</strong>
</p>
<p>
For a <code>grid_agg</code> of <code>geotile</code>, you can use cells in the <code>aggs</code> layer as tiles for lower zoom levels.
<code>grid_precision</code> represents the additional zoom levels available through these cells. The final precision is computed by as follows: <code>&lt;zoom&gt; + grid_precision</code>.
For example, if <code>&lt;zoom&gt;</code> is 7 and <code>grid_precision</code> is 8, then the <code>geotile_grid</code> aggregation will use a precision of 15.
The maximum final precision is 29.
The <code>grid_precision</code> also determines the number of cells for the grid as follows: <code>(2^grid_precision) x (2^grid_precision)</code>.
For example, a value of 8 divides the tile into a grid of 256 x 256 cells.
The <code>aggs</code> layer only contains features for cells with matching data.
</p>
<p>
<strong>Grid precision for geohex</strong>
</p>
<p>
For a <code>grid_agg</code> of <code>geohex</code>, Elasticsearch uses <code>&lt;zoom&gt;</code> and <code>grid_precision</code> to calculate a final precision as follows: <code>&lt;zoom&gt; + grid_precision</code>.
</p>
<p>
This precision determines the H3 resolution of the hexagonal cells produced by the <code>geohex</code> aggregation.
The following table maps the H3 resolution for each precision.
For example, if <code>&lt;zoom&gt;</code> is 3 and <code>grid_precision</code> is 3, the precision is 6.
At a precision of 6, hexagonal cells have an H3 resolution of 2.
If <code>&lt;zoom&gt;</code> is 3 and <code>grid_precision</code> is 4, the precision is 7.
At a precision of 7, hexagonal cells have an H3 resolution of 3.
</p>
<p>
| Precision | Unique tile bins | H3 resolution | Unique hex bins |	Ratio |
| --------- | ---------------- | ------------- | ----------------| ----- |
| 1  | 4                  | 0  | 122             | 30.5           |
| 2  | 16                 | 0  | 122             | 7.625          |
| 3  | 64                 | 1  | 842             | 13.15625       |
| 4  | 256                | 1  | 842             | 3.2890625      |
| 5  | 1024               | 2  | 5882            | 5.744140625    |
| 6  | 4096               | 2  | 5882            | 1.436035156    |
| 7  | 16384              | 3  | 41162           | 2.512329102    |
| 8  | 65536              | 3  | 41162           | 0.6280822754   |
| 9  | 262144             | 4  | 288122          | 1.099098206    |
| 10 | 1048576            | 4  | 288122          | 0.2747745514   |
| 11 | 4194304            | 5  | 2016842         | 0.4808526039   |
| 12 | 16777216           | 6  | 14117882        | 0.8414913416   |
| 13 | 67108864           | 6  | 14117882        | 0.2103728354   |
| 14 | 268435456          | 7  | 98825162        | 0.3681524172   |
| 15 | 1073741824         | 8  | 691776122       | 0.644266719    |
| 16 | 4294967296         | 8  | 691776122       | 0.1610666797   |
| 17 | 17179869184        | 9  | 4842432842      | 0.2818666889   |
| 18 | 68719476736        | 10 | 33897029882     | 0.4932667053   |
| 19 | 274877906944       | 11 | 237279209162    | 0.8632167343   |
| 20 | 1099511627776      | 11 | 237279209162    | 0.2158041836   |
| 21 | 4398046511104      | 12 | 1660954464122   | 0.3776573213   |
| 22 | 17592186044416     | 13 | 11626681248842  | 0.6609003122   |
| 23 | 70368744177664     | 13 | 11626681248842  | 0.165225078    |
| 24 | 281474976710656    | 14 | 81386768741882  | 0.2891438866   |
| 25 | 1125899906842620   | 15 | 569707381193162 | 0.5060018015   |
| 26 | 4503599627370500   | 15 | 569707381193162 | 0.1265004504   |
| 27 | 18014398509482000  | 15 | 569707381193162 | 0.03162511259  |
| 28 | 72057594037927900  | 15 | 569707381193162 | 0.007906278149 |
| 29 | 288230376151712000 | 15 | 569707381193162 | 0.001976569537 |
</p>
<p>
Hexagonal cells don't align perfectly on a vector tile.
Some cells may intersect more than one vector tile.
To compute the H3 resolution for each precision, Elasticsearch compares the average density of hexagonal bins at each resolution with the average density of tile bins at each zoom level.
Elasticsearch uses the H3 resolution that is closest to the corresponding geotile density.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-vector-tile-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual SearchMvtResponse SearchMvt&lt;TDocument&gt;(SearchMvtRequestDescriptor&lt;TDocument&gt; descriptor)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.SearchMvtRequestDescriptor-1.html">SearchMvtRequestDescriptor</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.SearchMvtResponse.html">SearchMvtResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchShards_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchShards*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchShards" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchShards">
  SearchShards()
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L35391"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get the search shards.
</p>
<p>
Get the indices and shards that a search request would be run against.
This information can be useful for working out issues or planning optimizations with routing and shard preferences.
When filtered aliases are used, the filter is returned as part of the <code>indices</code> section.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the <code>view_index_metadata</code> or <code>manage</code> index privilege for the target data stream, index, or alias.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-shards.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual SearchShardsResponse SearchShards()</code></pre>
  </div>


  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.SearchShardsResponse.html">SearchShardsResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchShards_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchShards*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchShards_Elastic_Clients_Elasticsearch_Indices_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchShards(Elastic.Clients.Elasticsearch.Indices)">
  SearchShards(Indices?)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L35346"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get the search shards.
</p>
<p>
Get the indices and shards that a search request would be run against.
This information can be useful for working out issues or planning optimizations with routing and shard preferences.
When filtered aliases are used, the filter is returned as part of the <code>indices</code> section.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the <code>view_index_metadata</code> or <code>manage</code> index privilege for the target data stream, index, or alias.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-shards.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual SearchShardsResponse SearchShards(Indices? indices)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>indices</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Indices.html">Indices</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.SearchShardsResponse.html">SearchShardsResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchShards_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchShards*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchShards_Elastic_Clients_Elasticsearch_Indices_System_Action_Elastic_Clients_Elasticsearch_SearchShardsRequestDescriptor__" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchShards(Elastic.Clients.Elasticsearch.Indices,System.Action{Elastic.Clients.Elasticsearch.SearchShardsRequestDescriptor})">
  SearchShards(Indices?, Action&lt;SearchShardsRequestDescriptor&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L35368"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get the search shards.
</p>
<p>
Get the indices and shards that a search request would be run against.
This information can be useful for working out issues or planning optimizations with routing and shard preferences.
When filtered aliases are used, the filter is returned as part of the <code>indices</code> section.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the <code>view_index_metadata</code> or <code>manage</code> index privilege for the target data stream, index, or alias.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-shards.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual SearchShardsResponse SearchShards(Indices? indices, Action&lt;SearchShardsRequestDescriptor&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>indices</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Indices.html">Indices</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.SearchShardsRequestDescriptor.html">SearchShardsRequestDescriptor</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.SearchShardsResponse.html">SearchShardsResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchShards_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchShards*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchShards_Elastic_Clients_Elasticsearch_SearchShardsRequest_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchShards(Elastic.Clients.Elasticsearch.SearchShardsRequest)">
  SearchShards(SearchShardsRequest)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L35173"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get the search shards.
</p>
<p>
Get the indices and shards that a search request would be run against.
This information can be useful for working out issues or planning optimizations with routing and shard preferences.
When filtered aliases are used, the filter is returned as part of the <code>indices</code> section.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the <code>view_index_metadata</code> or <code>manage</code> index privilege for the target data stream, index, or alias.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-shards.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual SearchShardsResponse SearchShards(SearchShardsRequest request)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.SearchShardsRequest.html">SearchShardsRequest</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.SearchShardsResponse.html">SearchShardsResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchShards_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchShards*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchShards_Elastic_Clients_Elasticsearch_SearchShardsRequestDescriptor_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchShards(Elastic.Clients.Elasticsearch.SearchShardsRequestDescriptor)">
  SearchShards(SearchShardsRequestDescriptor)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L35325"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get the search shards.
</p>
<p>
Get the indices and shards that a search request would be run against.
This information can be useful for working out issues or planning optimizations with routing and shard preferences.
When filtered aliases are used, the filter is returned as part of the <code>indices</code> section.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the <code>view_index_metadata</code> or <code>manage</code> index privilege for the target data stream, index, or alias.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-shards.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual SearchShardsResponse SearchShards(SearchShardsRequestDescriptor descriptor)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.SearchShardsRequestDescriptor.html">SearchShardsRequestDescriptor</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.SearchShardsResponse.html">SearchShardsResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchShards_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchShards*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchShards_System_Action_Elastic_Clients_Elasticsearch_SearchShardsRequestDescriptor__" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchShards(System.Action{Elastic.Clients.Elasticsearch.SearchShardsRequestDescriptor})">
  SearchShards(Action&lt;SearchShardsRequestDescriptor&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L35413"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get the search shards.
</p>
<p>
Get the indices and shards that a search request would be run against.
This information can be useful for working out issues or planning optimizations with routing and shard preferences.
When filtered aliases are used, the filter is returned as part of the <code>indices</code> section.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the <code>view_index_metadata</code> or <code>manage</code> index privilege for the target data stream, index, or alias.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-shards.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual SearchShardsResponse SearchShards(Action&lt;SearchShardsRequestDescriptor&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.SearchShardsRequestDescriptor.html">SearchShardsRequestDescriptor</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.SearchShardsResponse.html">SearchShardsResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchShardsAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchShardsAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchShardsAsync_Elastic_Clients_Elasticsearch_Indices_System_Action_Elastic_Clients_Elasticsearch_SearchShardsRequestDescriptor__System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchShardsAsync(Elastic.Clients.Elasticsearch.Indices,System.Action{Elastic.Clients.Elasticsearch.SearchShardsRequestDescriptor},System.Threading.CancellationToken)">
  SearchShardsAsync(Indices?, Action&lt;SearchShardsRequestDescriptor&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L35583"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get the search shards.
</p>
<p>
Get the indices and shards that a search request would be run against.
This information can be useful for working out issues or planning optimizations with routing and shard preferences.
When filtered aliases are used, the filter is returned as part of the <code>indices</code> section.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the <code>view_index_metadata</code> or <code>manage</code> index privilege for the target data stream, index, or alias.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-shards.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;SearchShardsResponse&gt; SearchShardsAsync(Indices? indices, Action&lt;SearchShardsRequestDescriptor&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>indices</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Indices.html">Indices</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.SearchShardsRequestDescriptor.html">SearchShardsRequestDescriptor</a>&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.SearchShardsResponse.html">SearchShardsResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchShardsAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchShardsAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchShardsAsync_Elastic_Clients_Elasticsearch_Indices_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchShardsAsync(Elastic.Clients.Elasticsearch.Indices,System.Threading.CancellationToken)">
  SearchShardsAsync(Indices?, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L35562"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get the search shards.
</p>
<p>
Get the indices and shards that a search request would be run against.
This information can be useful for working out issues or planning optimizations with routing and shard preferences.
When filtered aliases are used, the filter is returned as part of the <code>indices</code> section.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the <code>view_index_metadata</code> or <code>manage</code> index privilege for the target data stream, index, or alias.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-shards.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;SearchShardsResponse&gt; SearchShardsAsync(Indices? indices, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>indices</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Indices.html">Indices</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.SearchShardsResponse.html">SearchShardsResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchShardsAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchShardsAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchShardsAsync_Elastic_Clients_Elasticsearch_SearchShardsRequest_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchShardsAsync(Elastic.Clients.Elasticsearch.SearchShardsRequest,System.Threading.CancellationToken)">
  SearchShardsAsync(SearchShardsRequest, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L35194"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get the search shards.
</p>
<p>
Get the indices and shards that a search request would be run against.
This information can be useful for working out issues or planning optimizations with routing and shard preferences.
When filtered aliases are used, the filter is returned as part of the <code>indices</code> section.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the <code>view_index_metadata</code> or <code>manage</code> index privilege for the target data stream, index, or alias.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-shards.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;SearchShardsResponse&gt; SearchShardsAsync(SearchShardsRequest request, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.SearchShardsRequest.html">SearchShardsRequest</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.SearchShardsResponse.html">SearchShardsResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchShardsAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchShardsAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchShardsAsync_Elastic_Clients_Elasticsearch_SearchShardsRequestDescriptor_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchShardsAsync(Elastic.Clients.Elasticsearch.SearchShardsRequestDescriptor,System.Threading.CancellationToken)">
  SearchShardsAsync(SearchShardsRequestDescriptor, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L35542"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get the search shards.
</p>
<p>
Get the indices and shards that a search request would be run against.
This information can be useful for working out issues or planning optimizations with routing and shard preferences.
When filtered aliases are used, the filter is returned as part of the <code>indices</code> section.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the <code>view_index_metadata</code> or <code>manage</code> index privilege for the target data stream, index, or alias.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-shards.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;SearchShardsResponse&gt; SearchShardsAsync(SearchShardsRequestDescriptor descriptor, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.SearchShardsRequestDescriptor.html">SearchShardsRequestDescriptor</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.SearchShardsResponse.html">SearchShardsResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchShardsAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchShardsAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchShardsAsync_System_Action_Elastic_Clients_Elasticsearch_SearchShardsRequestDescriptor__System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchShardsAsync(System.Action{Elastic.Clients.Elasticsearch.SearchShardsRequestDescriptor},System.Threading.CancellationToken)">
  SearchShardsAsync(Action&lt;SearchShardsRequestDescriptor&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L35626"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get the search shards.
</p>
<p>
Get the indices and shards that a search request would be run against.
This information can be useful for working out issues or planning optimizations with routing and shard preferences.
When filtered aliases are used, the filter is returned as part of the <code>indices</code> section.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the <code>view_index_metadata</code> or <code>manage</code> index privilege for the target data stream, index, or alias.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-shards.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;SearchShardsResponse&gt; SearchShardsAsync(Action&lt;SearchShardsRequestDescriptor&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.SearchShardsRequestDescriptor.html">SearchShardsRequestDescriptor</a>&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.SearchShardsResponse.html">SearchShardsResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchShardsAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchShardsAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchShardsAsync_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchShardsAsync(System.Threading.CancellationToken)">
  SearchShardsAsync(CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L35605"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get the search shards.
</p>
<p>
Get the indices and shards that a search request would be run against.
This information can be useful for working out issues or planning optimizations with routing and shard preferences.
When filtered aliases are used, the filter is returned as part of the <code>indices</code> section.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the <code>view_index_metadata</code> or <code>manage</code> index privilege for the target data stream, index, or alias.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-shards.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;SearchShardsResponse&gt; SearchShardsAsync(CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.SearchShardsResponse.html">SearchShardsResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchShardsAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchShardsAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchShardsAsync__1_Elastic_Clients_Elasticsearch_Indices_System_Action_Elastic_Clients_Elasticsearch_SearchShardsRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchShardsAsync``1(Elastic.Clients.Elasticsearch.Indices,System.Action{Elastic.Clients.Elasticsearch.SearchShardsRequestDescriptor{``0}},System.Threading.CancellationToken)">
  SearchShardsAsync&lt;TDocument&gt;(Indices?, Action&lt;SearchShardsRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L35477"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get the search shards.
</p>
<p>
Get the indices and shards that a search request would be run against.
This information can be useful for working out issues or planning optimizations with routing and shard preferences.
When filtered aliases are used, the filter is returned as part of the <code>indices</code> section.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the <code>view_index_metadata</code> or <code>manage</code> index privilege for the target data stream, index, or alias.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-shards.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;SearchShardsResponse&gt; SearchShardsAsync&lt;TDocument&gt;(Indices? indices, Action&lt;SearchShardsRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>indices</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Indices.html">Indices</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.SearchShardsRequestDescriptor-1.html">SearchShardsRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.SearchShardsResponse.html">SearchShardsResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchShardsAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchShardsAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchShardsAsync__1_Elastic_Clients_Elasticsearch_Indices_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchShardsAsync``1(Elastic.Clients.Elasticsearch.Indices,System.Threading.CancellationToken)">
  SearchShardsAsync&lt;TDocument&gt;(Indices?, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L35456"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get the search shards.
</p>
<p>
Get the indices and shards that a search request would be run against.
This information can be useful for working out issues or planning optimizations with routing and shard preferences.
When filtered aliases are used, the filter is returned as part of the <code>indices</code> section.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the <code>view_index_metadata</code> or <code>manage</code> index privilege for the target data stream, index, or alias.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-shards.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;SearchShardsResponse&gt; SearchShardsAsync&lt;TDocument&gt;(Indices? indices, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>indices</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Indices.html">Indices</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.SearchShardsResponse.html">SearchShardsResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchShardsAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchShardsAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchShardsAsync__1_Elastic_Clients_Elasticsearch_SearchShardsRequestDescriptor___0__System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchShardsAsync``1(Elastic.Clients.Elasticsearch.SearchShardsRequestDescriptor{``0},System.Threading.CancellationToken)">
  SearchShardsAsync&lt;TDocument&gt;(SearchShardsRequestDescriptor&lt;TDocument&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L35436"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get the search shards.
</p>
<p>
Get the indices and shards that a search request would be run against.
This information can be useful for working out issues or planning optimizations with routing and shard preferences.
When filtered aliases are used, the filter is returned as part of the <code>indices</code> section.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the <code>view_index_metadata</code> or <code>manage</code> index privilege for the target data stream, index, or alias.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-shards.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;SearchShardsResponse&gt; SearchShardsAsync&lt;TDocument&gt;(SearchShardsRequestDescriptor&lt;TDocument&gt; descriptor, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.SearchShardsRequestDescriptor-1.html">SearchShardsRequestDescriptor</a>&lt;TDocument&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.SearchShardsResponse.html">SearchShardsResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchShardsAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchShardsAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchShardsAsync__1_System_Action_Elastic_Clients_Elasticsearch_SearchShardsRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchShardsAsync``1(System.Action{Elastic.Clients.Elasticsearch.SearchShardsRequestDescriptor{``0}},System.Threading.CancellationToken)">
  SearchShardsAsync&lt;TDocument&gt;(Action&lt;SearchShardsRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L35520"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get the search shards.
</p>
<p>
Get the indices and shards that a search request would be run against.
This information can be useful for working out issues or planning optimizations with routing and shard preferences.
When filtered aliases are used, the filter is returned as part of the <code>indices</code> section.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the <code>view_index_metadata</code> or <code>manage</code> index privilege for the target data stream, index, or alias.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-shards.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;SearchShardsResponse&gt; SearchShardsAsync&lt;TDocument&gt;(Action&lt;SearchShardsRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.SearchShardsRequestDescriptor-1.html">SearchShardsRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.SearchShardsResponse.html">SearchShardsResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchShardsAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchShardsAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchShardsAsync__1_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchShardsAsync``1(System.Threading.CancellationToken)">
  SearchShardsAsync&lt;TDocument&gt;(CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L35499"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get the search shards.
</p>
<p>
Get the indices and shards that a search request would be run against.
This information can be useful for working out issues or planning optimizations with routing and shard preferences.
When filtered aliases are used, the filter is returned as part of the <code>indices</code> section.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the <code>view_index_metadata</code> or <code>manage</code> index privilege for the target data stream, index, or alias.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-shards.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;SearchShardsResponse&gt; SearchShardsAsync&lt;TDocument&gt;(CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.SearchShardsResponse.html">SearchShardsResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchShards_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchShards*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchShards__1" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchShards``1">
  SearchShards&lt;TDocument&gt;()
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L35280"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get the search shards.
</p>
<p>
Get the indices and shards that a search request would be run against.
This information can be useful for working out issues or planning optimizations with routing and shard preferences.
When filtered aliases are used, the filter is returned as part of the <code>indices</code> section.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the <code>view_index_metadata</code> or <code>manage</code> index privilege for the target data stream, index, or alias.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-shards.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual SearchShardsResponse SearchShards&lt;TDocument&gt;()</code></pre>
  </div>


  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.SearchShardsResponse.html">SearchShardsResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchShards_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchShards*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchShards__1_Elastic_Clients_Elasticsearch_Indices_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchShards``1(Elastic.Clients.Elasticsearch.Indices)">
  SearchShards&lt;TDocument&gt;(Indices?)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L35235"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get the search shards.
</p>
<p>
Get the indices and shards that a search request would be run against.
This information can be useful for working out issues or planning optimizations with routing and shard preferences.
When filtered aliases are used, the filter is returned as part of the <code>indices</code> section.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the <code>view_index_metadata</code> or <code>manage</code> index privilege for the target data stream, index, or alias.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-shards.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual SearchShardsResponse SearchShards&lt;TDocument&gt;(Indices? indices)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>indices</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Indices.html">Indices</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.SearchShardsResponse.html">SearchShardsResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchShards_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchShards*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchShards__1_Elastic_Clients_Elasticsearch_Indices_System_Action_Elastic_Clients_Elasticsearch_SearchShardsRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchShards``1(Elastic.Clients.Elasticsearch.Indices,System.Action{Elastic.Clients.Elasticsearch.SearchShardsRequestDescriptor{``0}})">
  SearchShards&lt;TDocument&gt;(Indices?, Action&lt;SearchShardsRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L35257"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get the search shards.
</p>
<p>
Get the indices and shards that a search request would be run against.
This information can be useful for working out issues or planning optimizations with routing and shard preferences.
When filtered aliases are used, the filter is returned as part of the <code>indices</code> section.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the <code>view_index_metadata</code> or <code>manage</code> index privilege for the target data stream, index, or alias.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-shards.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual SearchShardsResponse SearchShards&lt;TDocument&gt;(Indices? indices, Action&lt;SearchShardsRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>indices</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Indices.html">Indices</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.SearchShardsRequestDescriptor-1.html">SearchShardsRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.SearchShardsResponse.html">SearchShardsResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchShards_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchShards*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchShards__1_Elastic_Clients_Elasticsearch_SearchShardsRequestDescriptor___0__" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchShards``1(Elastic.Clients.Elasticsearch.SearchShardsRequestDescriptor{``0})">
  SearchShards&lt;TDocument&gt;(SearchShardsRequestDescriptor&lt;TDocument&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L35214"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get the search shards.
</p>
<p>
Get the indices and shards that a search request would be run against.
This information can be useful for working out issues or planning optimizations with routing and shard preferences.
When filtered aliases are used, the filter is returned as part of the <code>indices</code> section.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the <code>view_index_metadata</code> or <code>manage</code> index privilege for the target data stream, index, or alias.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-shards.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual SearchShardsResponse SearchShards&lt;TDocument&gt;(SearchShardsRequestDescriptor&lt;TDocument&gt; descriptor)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.SearchShardsRequestDescriptor-1.html">SearchShardsRequestDescriptor</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.SearchShardsResponse.html">SearchShardsResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchShards_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchShards*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchShards__1_System_Action_Elastic_Clients_Elasticsearch_SearchShardsRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchShards``1(System.Action{Elastic.Clients.Elasticsearch.SearchShardsRequestDescriptor{``0}})">
  SearchShards&lt;TDocument&gt;(Action&lt;SearchShardsRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L35302"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get the search shards.
</p>
<p>
Get the indices and shards that a search request would be run against.
This information can be useful for working out issues or planning optimizations with routing and shard preferences.
When filtered aliases are used, the filter is returned as part of the <code>indices</code> section.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the <code>view_index_metadata</code> or <code>manage</code> index privilege for the target data stream, index, or alias.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-shards.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual SearchShardsResponse SearchShards&lt;TDocument&gt;(Action&lt;SearchShardsRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.SearchShardsRequestDescriptor-1.html">SearchShardsRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.SearchShardsResponse.html">SearchShardsResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchTemplateAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchTemplateAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchTemplateAsync__1_Elastic_Clients_Elasticsearch_Indices_System_Action_Elastic_Clients_Elasticsearch_SearchTemplateRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchTemplateAsync``1(Elastic.Clients.Elasticsearch.Indices,System.Action{Elastic.Clients.Elasticsearch.SearchTemplateRequestDescriptor{``0}},System.Threading.CancellationToken)">
  SearchTemplateAsync&lt;TDocument&gt;(Indices?, Action&lt;SearchTemplateRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L35761"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Run a search with a search template.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-template-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;SearchTemplateResponse&lt;TDocument&gt;&gt; SearchTemplateAsync&lt;TDocument&gt;(Indices? indices, Action&lt;SearchTemplateRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>indices</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Indices.html">Indices</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.SearchTemplateRequestDescriptor-1.html">SearchTemplateRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.SearchTemplateResponse-1.html">SearchTemplateResponse</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchTemplateAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchTemplateAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchTemplateAsync__1_Elastic_Clients_Elasticsearch_Indices_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchTemplateAsync``1(Elastic.Clients.Elasticsearch.Indices,System.Threading.CancellationToken)">
  SearchTemplateAsync&lt;TDocument&gt;(Indices?, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L35748"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Run a search with a search template.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-template-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;SearchTemplateResponse&lt;TDocument&gt;&gt; SearchTemplateAsync&lt;TDocument&gt;(Indices? indices, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>indices</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Indices.html">Indices</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.SearchTemplateResponse-1.html">SearchTemplateResponse</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchTemplateAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchTemplateAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchTemplateAsync__1_Elastic_Clients_Elasticsearch_SearchTemplateRequest_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchTemplateAsync``1(Elastic.Clients.Elasticsearch.SearchTemplateRequest,System.Threading.CancellationToken)">
  SearchTemplateAsync&lt;TDocument&gt;(SearchTemplateRequest, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L35653"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Run a search with a search template.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-template-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;SearchTemplateResponse&lt;TDocument&gt;&gt; SearchTemplateAsync&lt;TDocument&gt;(SearchTemplateRequest request, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.SearchTemplateRequest.html">SearchTemplateRequest</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.SearchTemplateResponse-1.html">SearchTemplateResponse</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchTemplateAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchTemplateAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchTemplateAsync__1_Elastic_Clients_Elasticsearch_SearchTemplateRequestDescriptor___0__System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchTemplateAsync``1(Elastic.Clients.Elasticsearch.SearchTemplateRequestDescriptor{``0},System.Threading.CancellationToken)">
  SearchTemplateAsync&lt;TDocument&gt;(SearchTemplateRequestDescriptor&lt;TDocument&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L35736"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Run a search with a search template.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-template-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;SearchTemplateResponse&lt;TDocument&gt;&gt; SearchTemplateAsync&lt;TDocument&gt;(SearchTemplateRequestDescriptor&lt;TDocument&gt; descriptor, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.SearchTemplateRequestDescriptor-1.html">SearchTemplateRequestDescriptor</a>&lt;TDocument&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.SearchTemplateResponse-1.html">SearchTemplateResponse</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchTemplateAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchTemplateAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchTemplateAsync__1_System_Action_Elastic_Clients_Elasticsearch_SearchTemplateRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchTemplateAsync``1(System.Action{Elastic.Clients.Elasticsearch.SearchTemplateRequestDescriptor{``0}},System.Threading.CancellationToken)">
  SearchTemplateAsync&lt;TDocument&gt;(Action&lt;SearchTemplateRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L35788"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Run a search with a search template.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-template-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;SearchTemplateResponse&lt;TDocument&gt;&gt; SearchTemplateAsync&lt;TDocument&gt;(Action&lt;SearchTemplateRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.SearchTemplateRequestDescriptor-1.html">SearchTemplateRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.SearchTemplateResponse-1.html">SearchTemplateResponse</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchTemplateAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchTemplateAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchTemplateAsync__1_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchTemplateAsync``1(System.Threading.CancellationToken)">
  SearchTemplateAsync&lt;TDocument&gt;(CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L35775"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Run a search with a search template.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-template-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;SearchTemplateResponse&lt;TDocument&gt;&gt; SearchTemplateAsync&lt;TDocument&gt;(CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.SearchTemplateResponse-1.html">SearchTemplateResponse</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchTemplate_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchTemplate*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchTemplate__1" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchTemplate``1">
  SearchTemplate&lt;TDocument&gt;()
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L35707"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Run a search with a search template.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-template-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual SearchTemplateResponse&lt;TDocument&gt; SearchTemplate&lt;TDocument&gt;()</code></pre>
  </div>


  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.SearchTemplateResponse-1.html">SearchTemplateResponse</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchTemplate_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchTemplate*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchTemplate__1_Elastic_Clients_Elasticsearch_Indices_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchTemplate``1(Elastic.Clients.Elasticsearch.Indices)">
  SearchTemplate&lt;TDocument&gt;(Indices?)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L35678"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Run a search with a search template.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-template-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual SearchTemplateResponse&lt;TDocument&gt; SearchTemplate&lt;TDocument&gt;(Indices? indices)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>indices</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Indices.html">Indices</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.SearchTemplateResponse-1.html">SearchTemplateResponse</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchTemplate_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchTemplate*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchTemplate__1_Elastic_Clients_Elasticsearch_Indices_System_Action_Elastic_Clients_Elasticsearch_SearchTemplateRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchTemplate``1(Elastic.Clients.Elasticsearch.Indices,System.Action{Elastic.Clients.Elasticsearch.SearchTemplateRequestDescriptor{``0}})">
  SearchTemplate&lt;TDocument&gt;(Indices?, Action&lt;SearchTemplateRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L35692"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Run a search with a search template.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-template-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual SearchTemplateResponse&lt;TDocument&gt; SearchTemplate&lt;TDocument&gt;(Indices? indices, Action&lt;SearchTemplateRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>indices</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Indices.html">Indices</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.SearchTemplateRequestDescriptor-1.html">SearchTemplateRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.SearchTemplateResponse-1.html">SearchTemplateResponse</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchTemplate_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchTemplate*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchTemplate__1_Elastic_Clients_Elasticsearch_SearchTemplateRequest_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchTemplate``1(Elastic.Clients.Elasticsearch.SearchTemplateRequest)">
  SearchTemplate&lt;TDocument&gt;(SearchTemplateRequest)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L35640"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Run a search with a search template.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-template-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual SearchTemplateResponse&lt;TDocument&gt; SearchTemplate&lt;TDocument&gt;(SearchTemplateRequest request)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.SearchTemplateRequest.html">SearchTemplateRequest</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.SearchTemplateResponse-1.html">SearchTemplateResponse</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchTemplate_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchTemplate*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchTemplate__1_Elastic_Clients_Elasticsearch_SearchTemplateRequestDescriptor___0__" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchTemplate``1(Elastic.Clients.Elasticsearch.SearchTemplateRequestDescriptor{``0})">
  SearchTemplate&lt;TDocument&gt;(SearchTemplateRequestDescriptor&lt;TDocument&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L35665"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Run a search with a search template.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-template-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual SearchTemplateResponse&lt;TDocument&gt; SearchTemplate&lt;TDocument&gt;(SearchTemplateRequestDescriptor&lt;TDocument&gt; descriptor)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.SearchTemplateRequestDescriptor-1.html">SearchTemplateRequestDescriptor</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.SearchTemplateResponse-1.html">SearchTemplateResponse</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchTemplate_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchTemplate*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_SearchTemplate__1_System_Action_Elastic_Clients_Elasticsearch_SearchTemplateRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.SearchTemplate``1(System.Action{Elastic.Clients.Elasticsearch.SearchTemplateRequestDescriptor{``0}})">
  SearchTemplate&lt;TDocument&gt;(Action&lt;SearchTemplateRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L35721"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Run a search with a search template.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-template-api.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual SearchTemplateResponse&lt;TDocument&gt; SearchTemplate&lt;TDocument&gt;(Action&lt;SearchTemplateRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.SearchTemplateRequestDescriptor-1.html">SearchTemplateRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.SearchTemplateResponse-1.html">SearchTemplateResponse</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Search_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Search*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Search__1" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Search``1">
  Search&lt;TDocument&gt;()
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L31257"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Run a search.
</p>
<p>
Get search hits that match the query defined in the request.
You can provide search queries using the <code>q</code> query string parameter or the request body.
If both are specified, only the query parameter is used.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the read index privilege for the target data stream, index, or alias. For cross-cluster search, refer to the documentation about configuring CCS privileges.
To search a point in time (PIT) for an alias, you must have the <code>read</code> index privilege for the alias's data streams or indices.
</p>
<p>
<strong>Search slicing</strong>
</p>
<p>
When paging through a large number of documents, it can be helpful to split the search into multiple slices to consume them independently with the <code>slice</code> and <code>pit</code> properties.
By default the splitting is done first on the shards, then locally on each shard.
The local splitting partitions the shard into contiguous ranges based on Lucene document IDs.
</p>
<p>
For instance if the number of shards is equal to 2 and you request 4 slices, the slices 0 and 2 are assigned to the first shard and the slices 1 and 3 are assigned to the second shard.
</p>
<p>
IMPORTANT: The same point-in-time ID should be used for all slices.
If different PIT IDs are used, slices can overlap and miss documents.
This situation can occur because the splitting criterion is based on Lucene document IDs, which are not stable across changes to the index.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-search.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual SearchResponse&lt;TDocument&gt; Search&lt;TDocument&gt;()</code></pre>
  </div>


  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.SearchResponse-1.html">SearchResponse</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Search_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Search*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Search__1_Elastic_Clients_Elasticsearch_Indices_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Search``1(Elastic.Clients.Elasticsearch.Indices)">
  Search&lt;TDocument&gt;(Indices?)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L31178"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Run a search.
</p>
<p>
Get search hits that match the query defined in the request.
You can provide search queries using the <code>q</code> query string parameter or the request body.
If both are specified, only the query parameter is used.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the read index privilege for the target data stream, index, or alias. For cross-cluster search, refer to the documentation about configuring CCS privileges.
To search a point in time (PIT) for an alias, you must have the <code>read</code> index privilege for the alias's data streams or indices.
</p>
<p>
<strong>Search slicing</strong>
</p>
<p>
When paging through a large number of documents, it can be helpful to split the search into multiple slices to consume them independently with the <code>slice</code> and <code>pit</code> properties.
By default the splitting is done first on the shards, then locally on each shard.
The local splitting partitions the shard into contiguous ranges based on Lucene document IDs.
</p>
<p>
For instance if the number of shards is equal to 2 and you request 4 slices, the slices 0 and 2 are assigned to the first shard and the slices 1 and 3 are assigned to the second shard.
</p>
<p>
IMPORTANT: The same point-in-time ID should be used for all slices.
If different PIT IDs are used, slices can overlap and miss documents.
This situation can occur because the splitting criterion is based on Lucene document IDs, which are not stable across changes to the index.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-search.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual SearchResponse&lt;TDocument&gt; Search&lt;TDocument&gt;(Indices? indices)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>indices</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Indices.html">Indices</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.SearchResponse-1.html">SearchResponse</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Search_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Search*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Search__1_Elastic_Clients_Elasticsearch_Indices_System_Action_Elastic_Clients_Elasticsearch_SearchRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Search``1(Elastic.Clients.Elasticsearch.Indices,System.Action{Elastic.Clients.Elasticsearch.SearchRequestDescriptor{``0}})">
  Search&lt;TDocument&gt;(Indices?, Action&lt;SearchRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L31217"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Run a search.
</p>
<p>
Get search hits that match the query defined in the request.
You can provide search queries using the <code>q</code> query string parameter or the request body.
If both are specified, only the query parameter is used.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the read index privilege for the target data stream, index, or alias. For cross-cluster search, refer to the documentation about configuring CCS privileges.
To search a point in time (PIT) for an alias, you must have the <code>read</code> index privilege for the alias's data streams or indices.
</p>
<p>
<strong>Search slicing</strong>
</p>
<p>
When paging through a large number of documents, it can be helpful to split the search into multiple slices to consume them independently with the <code>slice</code> and <code>pit</code> properties.
By default the splitting is done first on the shards, then locally on each shard.
The local splitting partitions the shard into contiguous ranges based on Lucene document IDs.
</p>
<p>
For instance if the number of shards is equal to 2 and you request 4 slices, the slices 0 and 2 are assigned to the first shard and the slices 1 and 3 are assigned to the second shard.
</p>
<p>
IMPORTANT: The same point-in-time ID should be used for all slices.
If different PIT IDs are used, slices can overlap and miss documents.
This situation can occur because the splitting criterion is based on Lucene document IDs, which are not stable across changes to the index.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-search.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual SearchResponse&lt;TDocument&gt; Search&lt;TDocument&gt;(Indices? indices, Action&lt;SearchRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>indices</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Indices.html">Indices</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.SearchRequestDescriptor-1.html">SearchRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.SearchResponse-1.html">SearchResponse</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Search_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Search*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Search__1_Elastic_Clients_Elasticsearch_SearchRequest_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Search``1(Elastic.Clients.Elasticsearch.SearchRequest)">
  Search&lt;TDocument&gt;(SearchRequest)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L31065"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Run a search.
</p>
<p>
Get search hits that match the query defined in the request.
You can provide search queries using the <code>q</code> query string parameter or the request body.
If both are specified, only the query parameter is used.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the read index privilege for the target data stream, index, or alias. For cross-cluster search, refer to the documentation about configuring CCS privileges.
To search a point in time (PIT) for an alias, you must have the <code>read</code> index privilege for the alias's data streams or indices.
</p>
<p>
<strong>Search slicing</strong>
</p>
<p>
When paging through a large number of documents, it can be helpful to split the search into multiple slices to consume them independently with the <code>slice</code> and <code>pit</code> properties.
By default the splitting is done first on the shards, then locally on each shard.
The local splitting partitions the shard into contiguous ranges based on Lucene document IDs.
</p>
<p>
For instance if the number of shards is equal to 2 and you request 4 slices, the slices 0 and 2 are assigned to the first shard and the slices 1 and 3 are assigned to the second shard.
</p>
<p>
IMPORTANT: The same point-in-time ID should be used for all slices.
If different PIT IDs are used, slices can overlap and miss documents.
This situation can occur because the splitting criterion is based on Lucene document IDs, which are not stable across changes to the index.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-search.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual SearchResponse&lt;TDocument&gt; Search&lt;TDocument&gt;(SearchRequest request)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.SearchRequest.html">SearchRequest</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.SearchResponse-1.html">SearchResponse</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Search_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Search*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Search__1_Elastic_Clients_Elasticsearch_SearchRequestDescriptor___0__" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Search``1(Elastic.Clients.Elasticsearch.SearchRequestDescriptor{``0})">
  Search&lt;TDocument&gt;(SearchRequestDescriptor&lt;TDocument&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L31140"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Run a search.
</p>
<p>
Get search hits that match the query defined in the request.
You can provide search queries using the <code>q</code> query string parameter or the request body.
If both are specified, only the query parameter is used.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the read index privilege for the target data stream, index, or alias. For cross-cluster search, refer to the documentation about configuring CCS privileges.
To search a point in time (PIT) for an alias, you must have the <code>read</code> index privilege for the alias's data streams or indices.
</p>
<p>
<strong>Search slicing</strong>
</p>
<p>
When paging through a large number of documents, it can be helpful to split the search into multiple slices to consume them independently with the <code>slice</code> and <code>pit</code> properties.
By default the splitting is done first on the shards, then locally on each shard.
The local splitting partitions the shard into contiguous ranges based on Lucene document IDs.
</p>
<p>
For instance if the number of shards is equal to 2 and you request 4 slices, the slices 0 and 2 are assigned to the first shard and the slices 1 and 3 are assigned to the second shard.
</p>
<p>
IMPORTANT: The same point-in-time ID should be used for all slices.
If different PIT IDs are used, slices can overlap and miss documents.
This situation can occur because the splitting criterion is based on Lucene document IDs, which are not stable across changes to the index.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-search.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual SearchResponse&lt;TDocument&gt; Search&lt;TDocument&gt;(SearchRequestDescriptor&lt;TDocument&gt; descriptor)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.SearchRequestDescriptor-1.html">SearchRequestDescriptor</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.SearchResponse-1.html">SearchResponse</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Search_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Search*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Search__1_System_Action_Elastic_Clients_Elasticsearch_SearchRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Search``1(System.Action{Elastic.Clients.Elasticsearch.SearchRequestDescriptor{``0}})">
  Search&lt;TDocument&gt;(Action&lt;SearchRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L31296"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Run a search.
</p>
<p>
Get search hits that match the query defined in the request.
You can provide search queries using the <code>q</code> query string parameter or the request body.
If both are specified, only the query parameter is used.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the read index privilege for the target data stream, index, or alias. For cross-cluster search, refer to the documentation about configuring CCS privileges.
To search a point in time (PIT) for an alias, you must have the <code>read</code> index privilege for the alias's data streams or indices.
</p>
<p>
<strong>Search slicing</strong>
</p>
<p>
When paging through a large number of documents, it can be helpful to split the search into multiple slices to consume them independently with the <code>slice</code> and <code>pit</code> properties.
By default the splitting is done first on the shards, then locally on each shard.
The local splitting partitions the shard into contiguous ranges based on Lucene document IDs.
</p>
<p>
For instance if the number of shards is equal to 2 and you request 4 slices, the slices 0 and 2 are assigned to the first shard and the slices 1 and 3 are assigned to the second shard.
</p>
<p>
IMPORTANT: The same point-in-time ID should be used for all slices.
If different PIT IDs are used, slices can overlap and miss documents.
This situation can occur because the splitting criterion is based on Lucene document IDs, which are not stable across changes to the index.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-search.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual SearchResponse&lt;TDocument&gt; Search&lt;TDocument&gt;(Action&lt;SearchRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.SearchRequestDescriptor-1.html">SearchRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.SearchResponse-1.html">SearchResponse</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_TermsEnum_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.TermsEnum*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_TermsEnum_Elastic_Clients_Elasticsearch_IndexName_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.TermsEnum(Elastic.Clients.Elasticsearch.IndexName)">
  TermsEnum(IndexName)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L35983"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get terms in an index.
</p>
<p>
Discover terms that match a partial string in an index.
This API is designed for low-latency look-ups used in auto-complete scenarios.
</p>
<p>
info
The terms enum API may return terms from deleted documents. Deleted documents are initially only marked as deleted. It is not until their segments are merged that documents are actually deleted. Until that happens, the terms enum API will return terms from these documents.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-terms-enum.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual TermsEnumResponse TermsEnum(IndexName index)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.TermsEnumResponse.html">TermsEnumResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_TermsEnum_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.TermsEnum*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_TermsEnum_Elastic_Clients_Elasticsearch_IndexName_System_Action_Elastic_Clients_Elasticsearch_TermsEnumRequestDescriptor__" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.TermsEnum(Elastic.Clients.Elasticsearch.IndexName,System.Action{Elastic.Clients.Elasticsearch.TermsEnumRequestDescriptor})">
  TermsEnum(IndexName, Action&lt;TermsEnumRequestDescriptor&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L36005"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get terms in an index.
</p>
<p>
Discover terms that match a partial string in an index.
This API is designed for low-latency look-ups used in auto-complete scenarios.
</p>
<p>
info
The terms enum API may return terms from deleted documents. Deleted documents are initially only marked as deleted. It is not until their segments are merged that documents are actually deleted. Until that happens, the terms enum API will return terms from these documents.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-terms-enum.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual TermsEnumResponse TermsEnum(IndexName index, Action&lt;TermsEnumRequestDescriptor&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.TermsEnumRequestDescriptor.html">TermsEnumRequestDescriptor</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.TermsEnumResponse.html">TermsEnumResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_TermsEnum_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.TermsEnum*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_TermsEnum_Elastic_Clients_Elasticsearch_TermsEnumRequest_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.TermsEnum(Elastic.Clients.Elasticsearch.TermsEnumRequest)">
  TermsEnum(TermsEnumRequest)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L35810"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get terms in an index.
</p>
<p>
Discover terms that match a partial string in an index.
This API is designed for low-latency look-ups used in auto-complete scenarios.
</p>
<p>
info
The terms enum API may return terms from deleted documents. Deleted documents are initially only marked as deleted. It is not until their segments are merged that documents are actually deleted. Until that happens, the terms enum API will return terms from these documents.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-terms-enum.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual TermsEnumResponse TermsEnum(TermsEnumRequest request)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.TermsEnumRequest.html">TermsEnumRequest</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.TermsEnumResponse.html">TermsEnumResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_TermsEnum_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.TermsEnum*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_TermsEnum_Elastic_Clients_Elasticsearch_TermsEnumRequestDescriptor_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.TermsEnum(Elastic.Clients.Elasticsearch.TermsEnumRequestDescriptor)">
  TermsEnum(TermsEnumRequestDescriptor)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L35962"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get terms in an index.
</p>
<p>
Discover terms that match a partial string in an index.
This API is designed for low-latency look-ups used in auto-complete scenarios.
</p>
<p>
info
The terms enum API may return terms from deleted documents. Deleted documents are initially only marked as deleted. It is not until their segments are merged that documents are actually deleted. Until that happens, the terms enum API will return terms from these documents.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-terms-enum.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual TermsEnumResponse TermsEnum(TermsEnumRequestDescriptor descriptor)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.TermsEnumRequestDescriptor.html">TermsEnumRequestDescriptor</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.TermsEnumResponse.html">TermsEnumResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_TermsEnumAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.TermsEnumAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_TermsEnumAsync_Elastic_Clients_Elasticsearch_IndexName_System_Action_Elastic_Clients_Elasticsearch_TermsEnumRequestDescriptor__System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.TermsEnumAsync(Elastic.Clients.Elasticsearch.IndexName,System.Action{Elastic.Clients.Elasticsearch.TermsEnumRequestDescriptor},System.Threading.CancellationToken)">
  TermsEnumAsync(IndexName, Action&lt;TermsEnumRequestDescriptor&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L36175"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get terms in an index.
</p>
<p>
Discover terms that match a partial string in an index.
This API is designed for low-latency look-ups used in auto-complete scenarios.
</p>
<p>
info
The terms enum API may return terms from deleted documents. Deleted documents are initially only marked as deleted. It is not until their segments are merged that documents are actually deleted. Until that happens, the terms enum API will return terms from these documents.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-terms-enum.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;TermsEnumResponse&gt; TermsEnumAsync(IndexName index, Action&lt;TermsEnumRequestDescriptor&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.TermsEnumRequestDescriptor.html">TermsEnumRequestDescriptor</a>&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.TermsEnumResponse.html">TermsEnumResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_TermsEnumAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.TermsEnumAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_TermsEnumAsync_Elastic_Clients_Elasticsearch_IndexName_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.TermsEnumAsync(Elastic.Clients.Elasticsearch.IndexName,System.Threading.CancellationToken)">
  TermsEnumAsync(IndexName, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L36154"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get terms in an index.
</p>
<p>
Discover terms that match a partial string in an index.
This API is designed for low-latency look-ups used in auto-complete scenarios.
</p>
<p>
info
The terms enum API may return terms from deleted documents. Deleted documents are initially only marked as deleted. It is not until their segments are merged that documents are actually deleted. Until that happens, the terms enum API will return terms from these documents.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-terms-enum.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;TermsEnumResponse&gt; TermsEnumAsync(IndexName index, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.TermsEnumResponse.html">TermsEnumResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_TermsEnumAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.TermsEnumAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_TermsEnumAsync_Elastic_Clients_Elasticsearch_TermsEnumRequest_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.TermsEnumAsync(Elastic.Clients.Elasticsearch.TermsEnumRequest,System.Threading.CancellationToken)">
  TermsEnumAsync(TermsEnumRequest, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L35831"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get terms in an index.
</p>
<p>
Discover terms that match a partial string in an index.
This API is designed for low-latency look-ups used in auto-complete scenarios.
</p>
<p>
info
The terms enum API may return terms from deleted documents. Deleted documents are initially only marked as deleted. It is not until their segments are merged that documents are actually deleted. Until that happens, the terms enum API will return terms from these documents.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-terms-enum.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;TermsEnumResponse&gt; TermsEnumAsync(TermsEnumRequest request, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.TermsEnumRequest.html">TermsEnumRequest</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.TermsEnumResponse.html">TermsEnumResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_TermsEnumAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.TermsEnumAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_TermsEnumAsync_Elastic_Clients_Elasticsearch_TermsEnumRequestDescriptor_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.TermsEnumAsync(Elastic.Clients.Elasticsearch.TermsEnumRequestDescriptor,System.Threading.CancellationToken)">
  TermsEnumAsync(TermsEnumRequestDescriptor, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L36134"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get terms in an index.
</p>
<p>
Discover terms that match a partial string in an index.
This API is designed for low-latency look-ups used in auto-complete scenarios.
</p>
<p>
info
The terms enum API may return terms from deleted documents. Deleted documents are initially only marked as deleted. It is not until their segments are merged that documents are actually deleted. Until that happens, the terms enum API will return terms from these documents.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-terms-enum.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;TermsEnumResponse&gt; TermsEnumAsync(TermsEnumRequestDescriptor descriptor, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.TermsEnumRequestDescriptor.html">TermsEnumRequestDescriptor</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.TermsEnumResponse.html">TermsEnumResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_TermsEnumAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.TermsEnumAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_TermsEnumAsync__1_Elastic_Clients_Elasticsearch_IndexName_System_Action_Elastic_Clients_Elasticsearch_TermsEnumRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.TermsEnumAsync``1(Elastic.Clients.Elasticsearch.IndexName,System.Action{Elastic.Clients.Elasticsearch.TermsEnumRequestDescriptor{``0}},System.Threading.CancellationToken)">
  TermsEnumAsync&lt;TDocument&gt;(IndexName, Action&lt;TermsEnumRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L36069"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get terms in an index.
</p>
<p>
Discover terms that match a partial string in an index.
This API is designed for low-latency look-ups used in auto-complete scenarios.
</p>
<p>
info
The terms enum API may return terms from deleted documents. Deleted documents are initially only marked as deleted. It is not until their segments are merged that documents are actually deleted. Until that happens, the terms enum API will return terms from these documents.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-terms-enum.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;TermsEnumResponse&gt; TermsEnumAsync&lt;TDocument&gt;(IndexName index, Action&lt;TermsEnumRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.TermsEnumRequestDescriptor-1.html">TermsEnumRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.TermsEnumResponse.html">TermsEnumResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_TermsEnumAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.TermsEnumAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_TermsEnumAsync__1_Elastic_Clients_Elasticsearch_IndexName_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.TermsEnumAsync``1(Elastic.Clients.Elasticsearch.IndexName,System.Threading.CancellationToken)">
  TermsEnumAsync&lt;TDocument&gt;(IndexName, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L36048"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get terms in an index.
</p>
<p>
Discover terms that match a partial string in an index.
This API is designed for low-latency look-ups used in auto-complete scenarios.
</p>
<p>
info
The terms enum API may return terms from deleted documents. Deleted documents are initially only marked as deleted. It is not until their segments are merged that documents are actually deleted. Until that happens, the terms enum API will return terms from these documents.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-terms-enum.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;TermsEnumResponse&gt; TermsEnumAsync&lt;TDocument&gt;(IndexName index, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.TermsEnumResponse.html">TermsEnumResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_TermsEnumAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.TermsEnumAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_TermsEnumAsync__1_Elastic_Clients_Elasticsearch_TermsEnumRequestDescriptor___0__System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.TermsEnumAsync``1(Elastic.Clients.Elasticsearch.TermsEnumRequestDescriptor{``0},System.Threading.CancellationToken)">
  TermsEnumAsync&lt;TDocument&gt;(TermsEnumRequestDescriptor&lt;TDocument&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L36028"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get terms in an index.
</p>
<p>
Discover terms that match a partial string in an index.
This API is designed for low-latency look-ups used in auto-complete scenarios.
</p>
<p>
info
The terms enum API may return terms from deleted documents. Deleted documents are initially only marked as deleted. It is not until their segments are merged that documents are actually deleted. Until that happens, the terms enum API will return terms from these documents.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-terms-enum.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;TermsEnumResponse&gt; TermsEnumAsync&lt;TDocument&gt;(TermsEnumRequestDescriptor&lt;TDocument&gt; descriptor, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.TermsEnumRequestDescriptor-1.html">TermsEnumRequestDescriptor</a>&lt;TDocument&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.TermsEnumResponse.html">TermsEnumResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_TermsEnumAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.TermsEnumAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_TermsEnumAsync__1_System_Action_Elastic_Clients_Elasticsearch_TermsEnumRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.TermsEnumAsync``1(System.Action{Elastic.Clients.Elasticsearch.TermsEnumRequestDescriptor{``0}},System.Threading.CancellationToken)">
  TermsEnumAsync&lt;TDocument&gt;(Action&lt;TermsEnumRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L36112"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get terms in an index.
</p>
<p>
Discover terms that match a partial string in an index.
This API is designed for low-latency look-ups used in auto-complete scenarios.
</p>
<p>
info
The terms enum API may return terms from deleted documents. Deleted documents are initially only marked as deleted. It is not until their segments are merged that documents are actually deleted. Until that happens, the terms enum API will return terms from these documents.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-terms-enum.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;TermsEnumResponse&gt; TermsEnumAsync&lt;TDocument&gt;(Action&lt;TermsEnumRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.TermsEnumRequestDescriptor-1.html">TermsEnumRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.TermsEnumResponse.html">TermsEnumResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_TermsEnumAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.TermsEnumAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_TermsEnumAsync__1_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.TermsEnumAsync``1(System.Threading.CancellationToken)">
  TermsEnumAsync&lt;TDocument&gt;(CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L36091"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get terms in an index.
</p>
<p>
Discover terms that match a partial string in an index.
This API is designed for low-latency look-ups used in auto-complete scenarios.
</p>
<p>
info
The terms enum API may return terms from deleted documents. Deleted documents are initially only marked as deleted. It is not until their segments are merged that documents are actually deleted. Until that happens, the terms enum API will return terms from these documents.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-terms-enum.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;TermsEnumResponse&gt; TermsEnumAsync&lt;TDocument&gt;(CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.TermsEnumResponse.html">TermsEnumResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_TermsEnum_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.TermsEnum*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_TermsEnum__1" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.TermsEnum``1">
  TermsEnum&lt;TDocument&gt;()
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L35917"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get terms in an index.
</p>
<p>
Discover terms that match a partial string in an index.
This API is designed for low-latency look-ups used in auto-complete scenarios.
</p>
<p>
info
The terms enum API may return terms from deleted documents. Deleted documents are initially only marked as deleted. It is not until their segments are merged that documents are actually deleted. Until that happens, the terms enum API will return terms from these documents.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-terms-enum.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual TermsEnumResponse TermsEnum&lt;TDocument&gt;()</code></pre>
  </div>


  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.TermsEnumResponse.html">TermsEnumResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_TermsEnum_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.TermsEnum*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_TermsEnum__1_Elastic_Clients_Elasticsearch_IndexName_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.TermsEnum``1(Elastic.Clients.Elasticsearch.IndexName)">
  TermsEnum&lt;TDocument&gt;(IndexName)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L35872"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get terms in an index.
</p>
<p>
Discover terms that match a partial string in an index.
This API is designed for low-latency look-ups used in auto-complete scenarios.
</p>
<p>
info
The terms enum API may return terms from deleted documents. Deleted documents are initially only marked as deleted. It is not until their segments are merged that documents are actually deleted. Until that happens, the terms enum API will return terms from these documents.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-terms-enum.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual TermsEnumResponse TermsEnum&lt;TDocument&gt;(IndexName index)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.TermsEnumResponse.html">TermsEnumResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_TermsEnum_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.TermsEnum*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_TermsEnum__1_Elastic_Clients_Elasticsearch_IndexName_System_Action_Elastic_Clients_Elasticsearch_TermsEnumRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.TermsEnum``1(Elastic.Clients.Elasticsearch.IndexName,System.Action{Elastic.Clients.Elasticsearch.TermsEnumRequestDescriptor{``0}})">
  TermsEnum&lt;TDocument&gt;(IndexName, Action&lt;TermsEnumRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L35894"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get terms in an index.
</p>
<p>
Discover terms that match a partial string in an index.
This API is designed for low-latency look-ups used in auto-complete scenarios.
</p>
<p>
info
The terms enum API may return terms from deleted documents. Deleted documents are initially only marked as deleted. It is not until their segments are merged that documents are actually deleted. Until that happens, the terms enum API will return terms from these documents.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-terms-enum.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual TermsEnumResponse TermsEnum&lt;TDocument&gt;(IndexName index, Action&lt;TermsEnumRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.TermsEnumRequestDescriptor-1.html">TermsEnumRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.TermsEnumResponse.html">TermsEnumResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_TermsEnum_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.TermsEnum*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_TermsEnum__1_Elastic_Clients_Elasticsearch_TermsEnumRequestDescriptor___0__" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.TermsEnum``1(Elastic.Clients.Elasticsearch.TermsEnumRequestDescriptor{``0})">
  TermsEnum&lt;TDocument&gt;(TermsEnumRequestDescriptor&lt;TDocument&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L35851"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get terms in an index.
</p>
<p>
Discover terms that match a partial string in an index.
This API is designed for low-latency look-ups used in auto-complete scenarios.
</p>
<p>
info
The terms enum API may return terms from deleted documents. Deleted documents are initially only marked as deleted. It is not until their segments are merged that documents are actually deleted. Until that happens, the terms enum API will return terms from these documents.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-terms-enum.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual TermsEnumResponse TermsEnum&lt;TDocument&gt;(TermsEnumRequestDescriptor&lt;TDocument&gt; descriptor)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.TermsEnumRequestDescriptor-1.html">TermsEnumRequestDescriptor</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.TermsEnumResponse.html">TermsEnumResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_TermsEnum_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.TermsEnum*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_TermsEnum__1_System_Action_Elastic_Clients_Elasticsearch_TermsEnumRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.TermsEnum``1(System.Action{Elastic.Clients.Elasticsearch.TermsEnumRequestDescriptor{``0}})">
  TermsEnum&lt;TDocument&gt;(Action&lt;TermsEnumRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L35939"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get terms in an index.
</p>
<p>
Discover terms that match a partial string in an index.
This API is designed for low-latency look-ups used in auto-complete scenarios.
</p>
<p>
info
The terms enum API may return terms from deleted documents. Deleted documents are initially only marked as deleted. It is not until their segments are merged that documents are actually deleted. Until that happens, the terms enum API will return terms from these documents.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/search-terms-enum.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual TermsEnumResponse TermsEnum&lt;TDocument&gt;(Action&lt;TermsEnumRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.TermsEnumRequestDescriptor-1.html">TermsEnumRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.TermsEnumResponse.html">TermsEnumResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_TermvectorsAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.TermvectorsAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_TermvectorsAsync__1_Elastic_Clients_Elasticsearch_Id_System_Action_Elastic_Clients_Elasticsearch_TermVectorsRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.TermvectorsAsync``1(Elastic.Clients.Elasticsearch.Id,System.Action{Elastic.Clients.Elasticsearch.TermVectorsRequestDescriptor{``0}},System.Threading.CancellationToken)">
  TermvectorsAsync&lt;TDocument&gt;(Id?, Action&lt;TermVectorsRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L38409"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get term vector information.
</p>
<p>
Get information and statistics about terms in the fields of a particular document.
</p>
<p>
You can retrieve term vectors for documents stored in the index or for artificial documents passed in the body of the request.
You can specify the fields you are interested in through the <code>fields</code> parameter or by adding the fields to the request body.
For example:
</p>
<pre><code class="lang-csharp">GET /my-index-000001/_termvectors/1?fields=message</code></pre>
<p>
Fields can be specified using wildcards, similar to the multi match query.
</p>
<p>
Term vectors are real-time by default, not near real-time.
This can be changed by setting <code>realtime</code> parameter to <code>false</code>.
</p>
<p>
You can request three types of values: <em>term information</em>, <em>term statistics</em>, and <em>field statistics</em>.
By default, all term information and field statistics are returned for all fields but term statistics are excluded.
</p>
<p>
<strong>Term information</strong>
</p>
<ul><li>
<p>
term frequency in the field (always returned)
</p>
</li><li>
<p>
term positions (<code>positions: true</code>)
</p>
</li><li>
<p>
start and end offsets (<code>offsets: true</code>)
</p>
</li><li>
<p>
term payloads (<code>payloads: true</code>), as base64 encoded bytes
</p>
</li></ul>
<p>
If the requested information wasn't stored in the index, it will be computed on the fly if possible.
Additionally, term vectors could be computed for documents not even existing in the index, but instead provided by the user.
</p>
<p>
warn
Start and end offsets assume UTF-16 encoding is being used. If you want to use these offsets in order to get the original text that produced this token, you should make sure that the string you are taking a sub-string of is also encoded using UTF-16.
</p>
<p>
<strong>Behaviour</strong>
</p>
<p>
The term and field statistics are not accurate.
Deleted documents are not taken into account.
The information is only retrieved for the shard the requested document resides in.
The term and field statistics are therefore only useful as relative measures whereas the absolute numbers have no meaning in this context.
By default, when requesting term vectors of artificial documents, a shard to get the statistics from is randomly selected.
Use <code>routing</code> only to hit a particular shard.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-termvectors.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;TermVectorsResponse&gt; TermvectorsAsync&lt;TDocument&gt;(Id? id, Action&lt;TermVectorsRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.TermVectorsRequestDescriptor-1.html">TermVectorsRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.TermVectorsResponse.html">TermVectorsResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_TermvectorsAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.TermvectorsAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_TermvectorsAsync__1_Elastic_Clients_Elasticsearch_Id_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.TermvectorsAsync``1(Elastic.Clients.Elasticsearch.Id,System.Threading.CancellationToken)">
  TermvectorsAsync&lt;TDocument&gt;(Id?, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L38330"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get term vector information.
</p>
<p>
Get information and statistics about terms in the fields of a particular document.
</p>
<p>
You can retrieve term vectors for documents stored in the index or for artificial documents passed in the body of the request.
You can specify the fields you are interested in through the <code>fields</code> parameter or by adding the fields to the request body.
For example:
</p>
<pre><code class="lang-csharp">GET /my-index-000001/_termvectors/1?fields=message</code></pre>
<p>
Fields can be specified using wildcards, similar to the multi match query.
</p>
<p>
Term vectors are real-time by default, not near real-time.
This can be changed by setting <code>realtime</code> parameter to <code>false</code>.
</p>
<p>
You can request three types of values: <em>term information</em>, <em>term statistics</em>, and <em>field statistics</em>.
By default, all term information and field statistics are returned for all fields but term statistics are excluded.
</p>
<p>
<strong>Term information</strong>
</p>
<ul><li>
<p>
term frequency in the field (always returned)
</p>
</li><li>
<p>
term positions (<code>positions: true</code>)
</p>
</li><li>
<p>
start and end offsets (<code>offsets: true</code>)
</p>
</li><li>
<p>
term payloads (<code>payloads: true</code>), as base64 encoded bytes
</p>
</li></ul>
<p>
If the requested information wasn't stored in the index, it will be computed on the fly if possible.
Additionally, term vectors could be computed for documents not even existing in the index, but instead provided by the user.
</p>
<p>
warn
Start and end offsets assume UTF-16 encoding is being used. If you want to use these offsets in order to get the original text that produced this token, you should make sure that the string you are taking a sub-string of is also encoded using UTF-16.
</p>
<p>
<strong>Behaviour</strong>
</p>
<p>
The term and field statistics are not accurate.
Deleted documents are not taken into account.
The information is only retrieved for the shard the requested document resides in.
The term and field statistics are therefore only useful as relative measures whereas the absolute numbers have no meaning in this context.
By default, when requesting term vectors of artificial documents, a shard to get the statistics from is randomly selected.
Use <code>routing</code> only to hit a particular shard.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-termvectors.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;TermVectorsResponse&gt; TermvectorsAsync&lt;TDocument&gt;(Id? id, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.TermVectorsResponse.html">TermVectorsResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_TermvectorsAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.TermvectorsAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_TermvectorsAsync__1_Elastic_Clients_Elasticsearch_IndexName_Elastic_Clients_Elasticsearch_Id_System_Action_Elastic_Clients_Elasticsearch_TermVectorsRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.TermvectorsAsync``1(Elastic.Clients.Elasticsearch.IndexName,Elastic.Clients.Elasticsearch.Id,System.Action{Elastic.Clients.Elasticsearch.TermVectorsRequestDescriptor{``0}},System.Threading.CancellationToken)">
  TermvectorsAsync&lt;TDocument&gt;(IndexName, Id?, Action&lt;TermVectorsRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L37614"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get term vector information.
</p>
<p>
Get information and statistics about terms in the fields of a particular document.
</p>
<p>
You can retrieve term vectors for documents stored in the index or for artificial documents passed in the body of the request.
You can specify the fields you are interested in through the <code>fields</code> parameter or by adding the fields to the request body.
For example:
</p>
<pre><code class="lang-csharp">GET /my-index-000001/_termvectors/1?fields=message</code></pre>
<p>
Fields can be specified using wildcards, similar to the multi match query.
</p>
<p>
Term vectors are real-time by default, not near real-time.
This can be changed by setting <code>realtime</code> parameter to <code>false</code>.
</p>
<p>
You can request three types of values: <em>term information</em>, <em>term statistics</em>, and <em>field statistics</em>.
By default, all term information and field statistics are returned for all fields but term statistics are excluded.
</p>
<p>
<strong>Term information</strong>
</p>
<ul><li>
<p>
term frequency in the field (always returned)
</p>
</li><li>
<p>
term positions (<code>positions: true</code>)
</p>
</li><li>
<p>
start and end offsets (<code>offsets: true</code>)
</p>
</li><li>
<p>
term payloads (<code>payloads: true</code>), as base64 encoded bytes
</p>
</li></ul>
<p>
If the requested information wasn't stored in the index, it will be computed on the fly if possible.
Additionally, term vectors could be computed for documents not even existing in the index, but instead provided by the user.
</p>
<p>
warn
Start and end offsets assume UTF-16 encoding is being used. If you want to use these offsets in order to get the original text that produced this token, you should make sure that the string you are taking a sub-string of is also encoded using UTF-16.
</p>
<p>
<strong>Behaviour</strong>
</p>
<p>
The term and field statistics are not accurate.
Deleted documents are not taken into account.
The information is only retrieved for the shard the requested document resides in.
The term and field statistics are therefore only useful as relative measures whereas the absolute numbers have no meaning in this context.
By default, when requesting term vectors of artificial documents, a shard to get the statistics from is randomly selected.
Use <code>routing</code> only to hit a particular shard.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-termvectors.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;TermVectorsResponse&gt; TermvectorsAsync&lt;TDocument&gt;(IndexName index, Id? id, Action&lt;TermVectorsRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.TermVectorsRequestDescriptor-1.html">TermVectorsRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.TermVectorsResponse.html">TermVectorsResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_TermvectorsAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.TermvectorsAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_TermvectorsAsync__1_Elastic_Clients_Elasticsearch_IndexName_Elastic_Clients_Elasticsearch_Id_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.TermvectorsAsync``1(Elastic.Clients.Elasticsearch.IndexName,Elastic.Clients.Elasticsearch.Id,System.Threading.CancellationToken)">
  TermvectorsAsync&lt;TDocument&gt;(IndexName, Id?, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L37535"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get term vector information.
</p>
<p>
Get information and statistics about terms in the fields of a particular document.
</p>
<p>
You can retrieve term vectors for documents stored in the index or for artificial documents passed in the body of the request.
You can specify the fields you are interested in through the <code>fields</code> parameter or by adding the fields to the request body.
For example:
</p>
<pre><code class="lang-csharp">GET /my-index-000001/_termvectors/1?fields=message</code></pre>
<p>
Fields can be specified using wildcards, similar to the multi match query.
</p>
<p>
Term vectors are real-time by default, not near real-time.
This can be changed by setting <code>realtime</code> parameter to <code>false</code>.
</p>
<p>
You can request three types of values: <em>term information</em>, <em>term statistics</em>, and <em>field statistics</em>.
By default, all term information and field statistics are returned for all fields but term statistics are excluded.
</p>
<p>
<strong>Term information</strong>
</p>
<ul><li>
<p>
term frequency in the field (always returned)
</p>
</li><li>
<p>
term positions (<code>positions: true</code>)
</p>
</li><li>
<p>
start and end offsets (<code>offsets: true</code>)
</p>
</li><li>
<p>
term payloads (<code>payloads: true</code>), as base64 encoded bytes
</p>
</li></ul>
<p>
If the requested information wasn't stored in the index, it will be computed on the fly if possible.
Additionally, term vectors could be computed for documents not even existing in the index, but instead provided by the user.
</p>
<p>
warn
Start and end offsets assume UTF-16 encoding is being used. If you want to use these offsets in order to get the original text that produced this token, you should make sure that the string you are taking a sub-string of is also encoded using UTF-16.
</p>
<p>
<strong>Behaviour</strong>
</p>
<p>
The term and field statistics are not accurate.
Deleted documents are not taken into account.
The information is only retrieved for the shard the requested document resides in.
The term and field statistics are therefore only useful as relative measures whereas the absolute numbers have no meaning in this context.
By default, when requesting term vectors of artificial documents, a shard to get the statistics from is randomly selected.
Use <code>routing</code> only to hit a particular shard.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-termvectors.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;TermVectorsResponse&gt; TermvectorsAsync&lt;TDocument&gt;(IndexName index, Id? id, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.TermVectorsResponse.html">TermVectorsResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_TermvectorsAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.TermvectorsAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_TermvectorsAsync__1_Elastic_Clients_Elasticsearch_IndexName_System_Action_Elastic_Clients_Elasticsearch_TermVectorsRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.TermvectorsAsync``1(Elastic.Clients.Elasticsearch.IndexName,System.Action{Elastic.Clients.Elasticsearch.TermVectorsRequestDescriptor{``0}},System.Threading.CancellationToken)">
  TermvectorsAsync&lt;TDocument&gt;(IndexName, Action&lt;TermVectorsRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L37773"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get term vector information.
</p>
<p>
Get information and statistics about terms in the fields of a particular document.
</p>
<p>
You can retrieve term vectors for documents stored in the index or for artificial documents passed in the body of the request.
You can specify the fields you are interested in through the <code>fields</code> parameter or by adding the fields to the request body.
For example:
</p>
<pre><code class="lang-csharp">GET /my-index-000001/_termvectors/1?fields=message</code></pre>
<p>
Fields can be specified using wildcards, similar to the multi match query.
</p>
<p>
Term vectors are real-time by default, not near real-time.
This can be changed by setting <code>realtime</code> parameter to <code>false</code>.
</p>
<p>
You can request three types of values: <em>term information</em>, <em>term statistics</em>, and <em>field statistics</em>.
By default, all term information and field statistics are returned for all fields but term statistics are excluded.
</p>
<p>
<strong>Term information</strong>
</p>
<ul><li>
<p>
term frequency in the field (always returned)
</p>
</li><li>
<p>
term positions (<code>positions: true</code>)
</p>
</li><li>
<p>
start and end offsets (<code>offsets: true</code>)
</p>
</li><li>
<p>
term payloads (<code>payloads: true</code>), as base64 encoded bytes
</p>
</li></ul>
<p>
If the requested information wasn't stored in the index, it will be computed on the fly if possible.
Additionally, term vectors could be computed for documents not even existing in the index, but instead provided by the user.
</p>
<p>
warn
Start and end offsets assume UTF-16 encoding is being used. If you want to use these offsets in order to get the original text that produced this token, you should make sure that the string you are taking a sub-string of is also encoded using UTF-16.
</p>
<p>
<strong>Behaviour</strong>
</p>
<p>
The term and field statistics are not accurate.
Deleted documents are not taken into account.
The information is only retrieved for the shard the requested document resides in.
The term and field statistics are therefore only useful as relative measures whereas the absolute numbers have no meaning in this context.
By default, when requesting term vectors of artificial documents, a shard to get the statistics from is randomly selected.
Use <code>routing</code> only to hit a particular shard.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-termvectors.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;TermVectorsResponse&gt; TermvectorsAsync&lt;TDocument&gt;(IndexName index, Action&lt;TermVectorsRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.TermVectorsRequestDescriptor-1.html">TermVectorsRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.TermVectorsResponse.html">TermVectorsResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_TermvectorsAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.TermvectorsAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_TermvectorsAsync__1_Elastic_Clients_Elasticsearch_IndexName_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.TermvectorsAsync``1(Elastic.Clients.Elasticsearch.IndexName,System.Threading.CancellationToken)">
  TermvectorsAsync&lt;TDocument&gt;(IndexName, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L37694"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get term vector information.
</p>
<p>
Get information and statistics about terms in the fields of a particular document.
</p>
<p>
You can retrieve term vectors for documents stored in the index or for artificial documents passed in the body of the request.
You can specify the fields you are interested in through the <code>fields</code> parameter or by adding the fields to the request body.
For example:
</p>
<pre><code class="lang-csharp">GET /my-index-000001/_termvectors/1?fields=message</code></pre>
<p>
Fields can be specified using wildcards, similar to the multi match query.
</p>
<p>
Term vectors are real-time by default, not near real-time.
This can be changed by setting <code>realtime</code> parameter to <code>false</code>.
</p>
<p>
You can request three types of values: <em>term information</em>, <em>term statistics</em>, and <em>field statistics</em>.
By default, all term information and field statistics are returned for all fields but term statistics are excluded.
</p>
<p>
<strong>Term information</strong>
</p>
<ul><li>
<p>
term frequency in the field (always returned)
</p>
</li><li>
<p>
term positions (<code>positions: true</code>)
</p>
</li><li>
<p>
start and end offsets (<code>offsets: true</code>)
</p>
</li><li>
<p>
term payloads (<code>payloads: true</code>), as base64 encoded bytes
</p>
</li></ul>
<p>
If the requested information wasn't stored in the index, it will be computed on the fly if possible.
Additionally, term vectors could be computed for documents not even existing in the index, but instead provided by the user.
</p>
<p>
warn
Start and end offsets assume UTF-16 encoding is being used. If you want to use these offsets in order to get the original text that produced this token, you should make sure that the string you are taking a sub-string of is also encoded using UTF-16.
</p>
<p>
<strong>Behaviour</strong>
</p>
<p>
The term and field statistics are not accurate.
Deleted documents are not taken into account.
The information is only retrieved for the shard the requested document resides in.
The term and field statistics are therefore only useful as relative measures whereas the absolute numbers have no meaning in this context.
By default, when requesting term vectors of artificial documents, a shard to get the statistics from is randomly selected.
Use <code>routing</code> only to hit a particular shard.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-termvectors.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;TermVectorsResponse&gt; TermvectorsAsync&lt;TDocument&gt;(IndexName index, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.TermVectorsResponse.html">TermVectorsResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_TermvectorsAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.TermvectorsAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_TermvectorsAsync__1_Elastic_Clients_Elasticsearch_TermVectorsRequestDescriptor___0__System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.TermvectorsAsync``1(Elastic.Clients.Elasticsearch.TermVectorsRequestDescriptor{``0},System.Threading.CancellationToken)">
  TermvectorsAsync&lt;TDocument&gt;(TermVectorsRequestDescriptor&lt;TDocument&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L37457"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get term vector information.
</p>
<p>
Get information and statistics about terms in the fields of a particular document.
</p>
<p>
You can retrieve term vectors for documents stored in the index or for artificial documents passed in the body of the request.
You can specify the fields you are interested in through the <code>fields</code> parameter or by adding the fields to the request body.
For example:
</p>
<pre><code class="lang-csharp">GET /my-index-000001/_termvectors/1?fields=message</code></pre>
<p>
Fields can be specified using wildcards, similar to the multi match query.
</p>
<p>
Term vectors are real-time by default, not near real-time.
This can be changed by setting <code>realtime</code> parameter to <code>false</code>.
</p>
<p>
You can request three types of values: <em>term information</em>, <em>term statistics</em>, and <em>field statistics</em>.
By default, all term information and field statistics are returned for all fields but term statistics are excluded.
</p>
<p>
<strong>Term information</strong>
</p>
<ul><li>
<p>
term frequency in the field (always returned)
</p>
</li><li>
<p>
term positions (<code>positions: true</code>)
</p>
</li><li>
<p>
start and end offsets (<code>offsets: true</code>)
</p>
</li><li>
<p>
term payloads (<code>payloads: true</code>), as base64 encoded bytes
</p>
</li></ul>
<p>
If the requested information wasn't stored in the index, it will be computed on the fly if possible.
Additionally, term vectors could be computed for documents not even existing in the index, but instead provided by the user.
</p>
<p>
warn
Start and end offsets assume UTF-16 encoding is being used. If you want to use these offsets in order to get the original text that produced this token, you should make sure that the string you are taking a sub-string of is also encoded using UTF-16.
</p>
<p>
<strong>Behaviour</strong>
</p>
<p>
The term and field statistics are not accurate.
Deleted documents are not taken into account.
The information is only retrieved for the shard the requested document resides in.
The term and field statistics are therefore only useful as relative measures whereas the absolute numbers have no meaning in this context.
By default, when requesting term vectors of artificial documents, a shard to get the statistics from is randomly selected.
Use <code>routing</code> only to hit a particular shard.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-termvectors.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;TermVectorsResponse&gt; TermvectorsAsync&lt;TDocument&gt;(TermVectorsRequestDescriptor&lt;TDocument&gt; descriptor, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.TermVectorsRequestDescriptor-1.html">TermVectorsRequestDescriptor</a>&lt;TDocument&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.TermVectorsResponse.html">TermVectorsResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_TermvectorsAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.TermvectorsAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_TermvectorsAsync__1_Elastic_Clients_Elasticsearch_TermVectorsRequest___0__System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.TermvectorsAsync``1(Elastic.Clients.Elasticsearch.TermVectorsRequest{``0},System.Threading.CancellationToken)">
  TermvectorsAsync&lt;TDocument&gt;(TermVectorsRequest&lt;TDocument&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L36334"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get term vector information.
</p>
<p>
Get information and statistics about terms in the fields of a particular document.
</p>
<p>
You can retrieve term vectors for documents stored in the index or for artificial documents passed in the body of the request.
You can specify the fields you are interested in through the <code>fields</code> parameter or by adding the fields to the request body.
For example:
</p>
<pre><code class="lang-csharp">GET /my-index-000001/_termvectors/1?fields=message</code></pre>
<p>
Fields can be specified using wildcards, similar to the multi match query.
</p>
<p>
Term vectors are real-time by default, not near real-time.
This can be changed by setting <code>realtime</code> parameter to <code>false</code>.
</p>
<p>
You can request three types of values: <em>term information</em>, <em>term statistics</em>, and <em>field statistics</em>.
By default, all term information and field statistics are returned for all fields but term statistics are excluded.
</p>
<p>
<strong>Term information</strong>
</p>
<ul><li>
<p>
term frequency in the field (always returned)
</p>
</li><li>
<p>
term positions (<code>positions: true</code>)
</p>
</li><li>
<p>
start and end offsets (<code>offsets: true</code>)
</p>
</li><li>
<p>
term payloads (<code>payloads: true</code>), as base64 encoded bytes
</p>
</li></ul>
<p>
If the requested information wasn't stored in the index, it will be computed on the fly if possible.
Additionally, term vectors could be computed for documents not even existing in the index, but instead provided by the user.
</p>
<p>
warn
Start and end offsets assume UTF-16 encoding is being used. If you want to use these offsets in order to get the original text that produced this token, you should make sure that the string you are taking a sub-string of is also encoded using UTF-16.
</p>
<p>
<strong>Behaviour</strong>
</p>
<p>
The term and field statistics are not accurate.
Deleted documents are not taken into account.
The information is only retrieved for the shard the requested document resides in.
The term and field statistics are therefore only useful as relative measures whereas the absolute numbers have no meaning in this context.
By default, when requesting term vectors of artificial documents, a shard to get the statistics from is randomly selected.
Use <code>routing</code> only to hit a particular shard.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-termvectors.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;TermVectorsResponse&gt; TermvectorsAsync&lt;TDocument&gt;(TermVectorsRequest&lt;TDocument&gt; request, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.TermVectorsRequest-1.html">TermVectorsRequest</a>&lt;TDocument&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.TermVectorsResponse.html">TermVectorsResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_TermvectorsAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.TermvectorsAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_TermvectorsAsync__1___0_Elastic_Clients_Elasticsearch_Id_System_Action_Elastic_Clients_Elasticsearch_TermVectorsRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.TermvectorsAsync``1(``0,Elastic.Clients.Elasticsearch.Id,System.Action{Elastic.Clients.Elasticsearch.TermVectorsRequestDescriptor{``0}},System.Threading.CancellationToken)">
  TermvectorsAsync&lt;TDocument&gt;(TDocument, Id?, Action&lt;TermVectorsRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L38250"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get term vector information.
</p>
<p>
Get information and statistics about terms in the fields of a particular document.
</p>
<p>
You can retrieve term vectors for documents stored in the index or for artificial documents passed in the body of the request.
You can specify the fields you are interested in through the <code>fields</code> parameter or by adding the fields to the request body.
For example:
</p>
<pre><code class="lang-csharp">GET /my-index-000001/_termvectors/1?fields=message</code></pre>
<p>
Fields can be specified using wildcards, similar to the multi match query.
</p>
<p>
Term vectors are real-time by default, not near real-time.
This can be changed by setting <code>realtime</code> parameter to <code>false</code>.
</p>
<p>
You can request three types of values: <em>term information</em>, <em>term statistics</em>, and <em>field statistics</em>.
By default, all term information and field statistics are returned for all fields but term statistics are excluded.
</p>
<p>
<strong>Term information</strong>
</p>
<ul><li>
<p>
term frequency in the field (always returned)
</p>
</li><li>
<p>
term positions (<code>positions: true</code>)
</p>
</li><li>
<p>
start and end offsets (<code>offsets: true</code>)
</p>
</li><li>
<p>
term payloads (<code>payloads: true</code>), as base64 encoded bytes
</p>
</li></ul>
<p>
If the requested information wasn't stored in the index, it will be computed on the fly if possible.
Additionally, term vectors could be computed for documents not even existing in the index, but instead provided by the user.
</p>
<p>
warn
Start and end offsets assume UTF-16 encoding is being used. If you want to use these offsets in order to get the original text that produced this token, you should make sure that the string you are taking a sub-string of is also encoded using UTF-16.
</p>
<p>
<strong>Behaviour</strong>
</p>
<p>
The term and field statistics are not accurate.
Deleted documents are not taken into account.
The information is only retrieved for the shard the requested document resides in.
The term and field statistics are therefore only useful as relative measures whereas the absolute numbers have no meaning in this context.
By default, when requesting term vectors of artificial documents, a shard to get the statistics from is randomly selected.
Use <code>routing</code> only to hit a particular shard.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-termvectors.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;TermVectorsResponse&gt; TermvectorsAsync&lt;TDocument&gt;(TDocument document, Id? id, Action&lt;TermVectorsRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.TermVectorsRequestDescriptor-1.html">TermVectorsRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.TermVectorsResponse.html">TermVectorsResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_TermvectorsAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.TermvectorsAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_TermvectorsAsync__1___0_Elastic_Clients_Elasticsearch_Id_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.TermvectorsAsync``1(``0,Elastic.Clients.Elasticsearch.Id,System.Threading.CancellationToken)">
  TermvectorsAsync&lt;TDocument&gt;(TDocument, Id?, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L38171"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get term vector information.
</p>
<p>
Get information and statistics about terms in the fields of a particular document.
</p>
<p>
You can retrieve term vectors for documents stored in the index or for artificial documents passed in the body of the request.
You can specify the fields you are interested in through the <code>fields</code> parameter or by adding the fields to the request body.
For example:
</p>
<pre><code class="lang-csharp">GET /my-index-000001/_termvectors/1?fields=message</code></pre>
<p>
Fields can be specified using wildcards, similar to the multi match query.
</p>
<p>
Term vectors are real-time by default, not near real-time.
This can be changed by setting <code>realtime</code> parameter to <code>false</code>.
</p>
<p>
You can request three types of values: <em>term information</em>, <em>term statistics</em>, and <em>field statistics</em>.
By default, all term information and field statistics are returned for all fields but term statistics are excluded.
</p>
<p>
<strong>Term information</strong>
</p>
<ul><li>
<p>
term frequency in the field (always returned)
</p>
</li><li>
<p>
term positions (<code>positions: true</code>)
</p>
</li><li>
<p>
start and end offsets (<code>offsets: true</code>)
</p>
</li><li>
<p>
term payloads (<code>payloads: true</code>), as base64 encoded bytes
</p>
</li></ul>
<p>
If the requested information wasn't stored in the index, it will be computed on the fly if possible.
Additionally, term vectors could be computed for documents not even existing in the index, but instead provided by the user.
</p>
<p>
warn
Start and end offsets assume UTF-16 encoding is being used. If you want to use these offsets in order to get the original text that produced this token, you should make sure that the string you are taking a sub-string of is also encoded using UTF-16.
</p>
<p>
<strong>Behaviour</strong>
</p>
<p>
The term and field statistics are not accurate.
Deleted documents are not taken into account.
The information is only retrieved for the shard the requested document resides in.
The term and field statistics are therefore only useful as relative measures whereas the absolute numbers have no meaning in this context.
By default, when requesting term vectors of artificial documents, a shard to get the statistics from is randomly selected.
Use <code>routing</code> only to hit a particular shard.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-termvectors.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;TermVectorsResponse&gt; TermvectorsAsync&lt;TDocument&gt;(TDocument document, Id? id, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.TermVectorsResponse.html">TermVectorsResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_TermvectorsAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.TermvectorsAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_TermvectorsAsync__1___0_Elastic_Clients_Elasticsearch_IndexName_System_Action_Elastic_Clients_Elasticsearch_TermVectorsRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.TermvectorsAsync``1(``0,Elastic.Clients.Elasticsearch.IndexName,System.Action{Elastic.Clients.Elasticsearch.TermVectorsRequestDescriptor{``0}},System.Threading.CancellationToken)">
  TermvectorsAsync&lt;TDocument&gt;(TDocument, IndexName, Action&lt;TermVectorsRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L38091"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get term vector information.
</p>
<p>
Get information and statistics about terms in the fields of a particular document.
</p>
<p>
You can retrieve term vectors for documents stored in the index or for artificial documents passed in the body of the request.
You can specify the fields you are interested in through the <code>fields</code> parameter or by adding the fields to the request body.
For example:
</p>
<pre><code class="lang-csharp">GET /my-index-000001/_termvectors/1?fields=message</code></pre>
<p>
Fields can be specified using wildcards, similar to the multi match query.
</p>
<p>
Term vectors are real-time by default, not near real-time.
This can be changed by setting <code>realtime</code> parameter to <code>false</code>.
</p>
<p>
You can request three types of values: <em>term information</em>, <em>term statistics</em>, and <em>field statistics</em>.
By default, all term information and field statistics are returned for all fields but term statistics are excluded.
</p>
<p>
<strong>Term information</strong>
</p>
<ul><li>
<p>
term frequency in the field (always returned)
</p>
</li><li>
<p>
term positions (<code>positions: true</code>)
</p>
</li><li>
<p>
start and end offsets (<code>offsets: true</code>)
</p>
</li><li>
<p>
term payloads (<code>payloads: true</code>), as base64 encoded bytes
</p>
</li></ul>
<p>
If the requested information wasn't stored in the index, it will be computed on the fly if possible.
Additionally, term vectors could be computed for documents not even existing in the index, but instead provided by the user.
</p>
<p>
warn
Start and end offsets assume UTF-16 encoding is being used. If you want to use these offsets in order to get the original text that produced this token, you should make sure that the string you are taking a sub-string of is also encoded using UTF-16.
</p>
<p>
<strong>Behaviour</strong>
</p>
<p>
The term and field statistics are not accurate.
Deleted documents are not taken into account.
The information is only retrieved for the shard the requested document resides in.
The term and field statistics are therefore only useful as relative measures whereas the absolute numbers have no meaning in this context.
By default, when requesting term vectors of artificial documents, a shard to get the statistics from is randomly selected.
Use <code>routing</code> only to hit a particular shard.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-termvectors.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;TermVectorsResponse&gt; TermvectorsAsync&lt;TDocument&gt;(TDocument document, IndexName index, Action&lt;TermVectorsRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.TermVectorsRequestDescriptor-1.html">TermVectorsRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.TermVectorsResponse.html">TermVectorsResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_TermvectorsAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.TermvectorsAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_TermvectorsAsync__1___0_Elastic_Clients_Elasticsearch_IndexName_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.TermvectorsAsync``1(``0,Elastic.Clients.Elasticsearch.IndexName,System.Threading.CancellationToken)">
  TermvectorsAsync&lt;TDocument&gt;(TDocument, IndexName, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L38012"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get term vector information.
</p>
<p>
Get information and statistics about terms in the fields of a particular document.
</p>
<p>
You can retrieve term vectors for documents stored in the index or for artificial documents passed in the body of the request.
You can specify the fields you are interested in through the <code>fields</code> parameter or by adding the fields to the request body.
For example:
</p>
<pre><code class="lang-csharp">GET /my-index-000001/_termvectors/1?fields=message</code></pre>
<p>
Fields can be specified using wildcards, similar to the multi match query.
</p>
<p>
Term vectors are real-time by default, not near real-time.
This can be changed by setting <code>realtime</code> parameter to <code>false</code>.
</p>
<p>
You can request three types of values: <em>term information</em>, <em>term statistics</em>, and <em>field statistics</em>.
By default, all term information and field statistics are returned for all fields but term statistics are excluded.
</p>
<p>
<strong>Term information</strong>
</p>
<ul><li>
<p>
term frequency in the field (always returned)
</p>
</li><li>
<p>
term positions (<code>positions: true</code>)
</p>
</li><li>
<p>
start and end offsets (<code>offsets: true</code>)
</p>
</li><li>
<p>
term payloads (<code>payloads: true</code>), as base64 encoded bytes
</p>
</li></ul>
<p>
If the requested information wasn't stored in the index, it will be computed on the fly if possible.
Additionally, term vectors could be computed for documents not even existing in the index, but instead provided by the user.
</p>
<p>
warn
Start and end offsets assume UTF-16 encoding is being used. If you want to use these offsets in order to get the original text that produced this token, you should make sure that the string you are taking a sub-string of is also encoded using UTF-16.
</p>
<p>
<strong>Behaviour</strong>
</p>
<p>
The term and field statistics are not accurate.
Deleted documents are not taken into account.
The information is only retrieved for the shard the requested document resides in.
The term and field statistics are therefore only useful as relative measures whereas the absolute numbers have no meaning in this context.
By default, when requesting term vectors of artificial documents, a shard to get the statistics from is randomly selected.
Use <code>routing</code> only to hit a particular shard.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-termvectors.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;TermVectorsResponse&gt; TermvectorsAsync&lt;TDocument&gt;(TDocument document, IndexName index, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.TermVectorsResponse.html">TermVectorsResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_TermvectorsAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.TermvectorsAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_TermvectorsAsync__1___0_System_Action_Elastic_Clients_Elasticsearch_TermVectorsRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.TermvectorsAsync``1(``0,System.Action{Elastic.Clients.Elasticsearch.TermVectorsRequestDescriptor{``0}},System.Threading.CancellationToken)">
  TermvectorsAsync&lt;TDocument&gt;(TDocument, Action&lt;TermVectorsRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L37932"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get term vector information.
</p>
<p>
Get information and statistics about terms in the fields of a particular document.
</p>
<p>
You can retrieve term vectors for documents stored in the index or for artificial documents passed in the body of the request.
You can specify the fields you are interested in through the <code>fields</code> parameter or by adding the fields to the request body.
For example:
</p>
<pre><code class="lang-csharp">GET /my-index-000001/_termvectors/1?fields=message</code></pre>
<p>
Fields can be specified using wildcards, similar to the multi match query.
</p>
<p>
Term vectors are real-time by default, not near real-time.
This can be changed by setting <code>realtime</code> parameter to <code>false</code>.
</p>
<p>
You can request three types of values: <em>term information</em>, <em>term statistics</em>, and <em>field statistics</em>.
By default, all term information and field statistics are returned for all fields but term statistics are excluded.
</p>
<p>
<strong>Term information</strong>
</p>
<ul><li>
<p>
term frequency in the field (always returned)
</p>
</li><li>
<p>
term positions (<code>positions: true</code>)
</p>
</li><li>
<p>
start and end offsets (<code>offsets: true</code>)
</p>
</li><li>
<p>
term payloads (<code>payloads: true</code>), as base64 encoded bytes
</p>
</li></ul>
<p>
If the requested information wasn't stored in the index, it will be computed on the fly if possible.
Additionally, term vectors could be computed for documents not even existing in the index, but instead provided by the user.
</p>
<p>
warn
Start and end offsets assume UTF-16 encoding is being used. If you want to use these offsets in order to get the original text that produced this token, you should make sure that the string you are taking a sub-string of is also encoded using UTF-16.
</p>
<p>
<strong>Behaviour</strong>
</p>
<p>
The term and field statistics are not accurate.
Deleted documents are not taken into account.
The information is only retrieved for the shard the requested document resides in.
The term and field statistics are therefore only useful as relative measures whereas the absolute numbers have no meaning in this context.
By default, when requesting term vectors of artificial documents, a shard to get the statistics from is randomly selected.
Use <code>routing</code> only to hit a particular shard.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-termvectors.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;TermVectorsResponse&gt; TermvectorsAsync&lt;TDocument&gt;(TDocument document, Action&lt;TermVectorsRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.TermVectorsRequestDescriptor-1.html">TermVectorsRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.TermVectorsResponse.html">TermVectorsResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_TermvectorsAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.TermvectorsAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_TermvectorsAsync__1___0_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.TermvectorsAsync``1(``0,System.Threading.CancellationToken)">
  TermvectorsAsync&lt;TDocument&gt;(TDocument, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L37853"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get term vector information.
</p>
<p>
Get information and statistics about terms in the fields of a particular document.
</p>
<p>
You can retrieve term vectors for documents stored in the index or for artificial documents passed in the body of the request.
You can specify the fields you are interested in through the <code>fields</code> parameter or by adding the fields to the request body.
For example:
</p>
<pre><code class="lang-csharp">GET /my-index-000001/_termvectors/1?fields=message</code></pre>
<p>
Fields can be specified using wildcards, similar to the multi match query.
</p>
<p>
Term vectors are real-time by default, not near real-time.
This can be changed by setting <code>realtime</code> parameter to <code>false</code>.
</p>
<p>
You can request three types of values: <em>term information</em>, <em>term statistics</em>, and <em>field statistics</em>.
By default, all term information and field statistics are returned for all fields but term statistics are excluded.
</p>
<p>
<strong>Term information</strong>
</p>
<ul><li>
<p>
term frequency in the field (always returned)
</p>
</li><li>
<p>
term positions (<code>positions: true</code>)
</p>
</li><li>
<p>
start and end offsets (<code>offsets: true</code>)
</p>
</li><li>
<p>
term payloads (<code>payloads: true</code>), as base64 encoded bytes
</p>
</li></ul>
<p>
If the requested information wasn't stored in the index, it will be computed on the fly if possible.
Additionally, term vectors could be computed for documents not even existing in the index, but instead provided by the user.
</p>
<p>
warn
Start and end offsets assume UTF-16 encoding is being used. If you want to use these offsets in order to get the original text that produced this token, you should make sure that the string you are taking a sub-string of is also encoded using UTF-16.
</p>
<p>
<strong>Behaviour</strong>
</p>
<p>
The term and field statistics are not accurate.
Deleted documents are not taken into account.
The information is only retrieved for the shard the requested document resides in.
The term and field statistics are therefore only useful as relative measures whereas the absolute numbers have no meaning in this context.
By default, when requesting term vectors of artificial documents, a shard to get the statistics from is randomly selected.
Use <code>routing</code> only to hit a particular shard.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-termvectors.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;TermVectorsResponse&gt; TermvectorsAsync&lt;TDocument&gt;(TDocument document, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.TermVectorsResponse.html">TermVectorsResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Termvectors_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Termvectors*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Termvectors__1_Elastic_Clients_Elasticsearch_Id_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Termvectors``1(Elastic.Clients.Elasticsearch.Id)">
  Termvectors&lt;TDocument&gt;(Id?)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L37296"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get term vector information.
</p>
<p>
Get information and statistics about terms in the fields of a particular document.
</p>
<p>
You can retrieve term vectors for documents stored in the index or for artificial documents passed in the body of the request.
You can specify the fields you are interested in through the <code>fields</code> parameter or by adding the fields to the request body.
For example:
</p>
<pre><code class="lang-csharp">GET /my-index-000001/_termvectors/1?fields=message</code></pre>
<p>
Fields can be specified using wildcards, similar to the multi match query.
</p>
<p>
Term vectors are real-time by default, not near real-time.
This can be changed by setting <code>realtime</code> parameter to <code>false</code>.
</p>
<p>
You can request three types of values: <em>term information</em>, <em>term statistics</em>, and <em>field statistics</em>.
By default, all term information and field statistics are returned for all fields but term statistics are excluded.
</p>
<p>
<strong>Term information</strong>
</p>
<ul><li>
<p>
term frequency in the field (always returned)
</p>
</li><li>
<p>
term positions (<code>positions: true</code>)
</p>
</li><li>
<p>
start and end offsets (<code>offsets: true</code>)
</p>
</li><li>
<p>
term payloads (<code>payloads: true</code>), as base64 encoded bytes
</p>
</li></ul>
<p>
If the requested information wasn't stored in the index, it will be computed on the fly if possible.
Additionally, term vectors could be computed for documents not even existing in the index, but instead provided by the user.
</p>
<p>
warn
Start and end offsets assume UTF-16 encoding is being used. If you want to use these offsets in order to get the original text that produced this token, you should make sure that the string you are taking a sub-string of is also encoded using UTF-16.
</p>
<p>
<strong>Behaviour</strong>
</p>
<p>
The term and field statistics are not accurate.
Deleted documents are not taken into account.
The information is only retrieved for the shard the requested document resides in.
The term and field statistics are therefore only useful as relative measures whereas the absolute numbers have no meaning in this context.
By default, when requesting term vectors of artificial documents, a shard to get the statistics from is randomly selected.
Use <code>routing</code> only to hit a particular shard.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-termvectors.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual TermVectorsResponse Termvectors&lt;TDocument&gt;(Id? id)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.TermVectorsResponse.html">TermVectorsResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Termvectors_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Termvectors*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Termvectors__1_Elastic_Clients_Elasticsearch_Id_System_Action_Elastic_Clients_Elasticsearch_TermVectorsRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Termvectors``1(Elastic.Clients.Elasticsearch.Id,System.Action{Elastic.Clients.Elasticsearch.TermVectorsRequestDescriptor{``0}})">
  Termvectors&lt;TDocument&gt;(Id?, Action&lt;TermVectorsRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L37376"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get term vector information.
</p>
<p>
Get information and statistics about terms in the fields of a particular document.
</p>
<p>
You can retrieve term vectors for documents stored in the index or for artificial documents passed in the body of the request.
You can specify the fields you are interested in through the <code>fields</code> parameter or by adding the fields to the request body.
For example:
</p>
<pre><code class="lang-csharp">GET /my-index-000001/_termvectors/1?fields=message</code></pre>
<p>
Fields can be specified using wildcards, similar to the multi match query.
</p>
<p>
Term vectors are real-time by default, not near real-time.
This can be changed by setting <code>realtime</code> parameter to <code>false</code>.
</p>
<p>
You can request three types of values: <em>term information</em>, <em>term statistics</em>, and <em>field statistics</em>.
By default, all term information and field statistics are returned for all fields but term statistics are excluded.
</p>
<p>
<strong>Term information</strong>
</p>
<ul><li>
<p>
term frequency in the field (always returned)
</p>
</li><li>
<p>
term positions (<code>positions: true</code>)
</p>
</li><li>
<p>
start and end offsets (<code>offsets: true</code>)
</p>
</li><li>
<p>
term payloads (<code>payloads: true</code>), as base64 encoded bytes
</p>
</li></ul>
<p>
If the requested information wasn't stored in the index, it will be computed on the fly if possible.
Additionally, term vectors could be computed for documents not even existing in the index, but instead provided by the user.
</p>
<p>
warn
Start and end offsets assume UTF-16 encoding is being used. If you want to use these offsets in order to get the original text that produced this token, you should make sure that the string you are taking a sub-string of is also encoded using UTF-16.
</p>
<p>
<strong>Behaviour</strong>
</p>
<p>
The term and field statistics are not accurate.
Deleted documents are not taken into account.
The information is only retrieved for the shard the requested document resides in.
The term and field statistics are therefore only useful as relative measures whereas the absolute numbers have no meaning in this context.
By default, when requesting term vectors of artificial documents, a shard to get the statistics from is randomly selected.
Use <code>routing</code> only to hit a particular shard.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-termvectors.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual TermVectorsResponse Termvectors&lt;TDocument&gt;(Id? id, Action&lt;TermVectorsRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.TermVectorsRequestDescriptor-1.html">TermVectorsRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.TermVectorsResponse.html">TermVectorsResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Termvectors_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Termvectors*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Termvectors__1_Elastic_Clients_Elasticsearch_IndexName_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Termvectors``1(Elastic.Clients.Elasticsearch.IndexName)">
  Termvectors&lt;TDocument&gt;(IndexName)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L36652"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get term vector information.
</p>
<p>
Get information and statistics about terms in the fields of a particular document.
</p>
<p>
You can retrieve term vectors for documents stored in the index or for artificial documents passed in the body of the request.
You can specify the fields you are interested in through the <code>fields</code> parameter or by adding the fields to the request body.
For example:
</p>
<pre><code class="lang-csharp">GET /my-index-000001/_termvectors/1?fields=message</code></pre>
<p>
Fields can be specified using wildcards, similar to the multi match query.
</p>
<p>
Term vectors are real-time by default, not near real-time.
This can be changed by setting <code>realtime</code> parameter to <code>false</code>.
</p>
<p>
You can request three types of values: <em>term information</em>, <em>term statistics</em>, and <em>field statistics</em>.
By default, all term information and field statistics are returned for all fields but term statistics are excluded.
</p>
<p>
<strong>Term information</strong>
</p>
<ul><li>
<p>
term frequency in the field (always returned)
</p>
</li><li>
<p>
term positions (<code>positions: true</code>)
</p>
</li><li>
<p>
start and end offsets (<code>offsets: true</code>)
</p>
</li><li>
<p>
term payloads (<code>payloads: true</code>), as base64 encoded bytes
</p>
</li></ul>
<p>
If the requested information wasn't stored in the index, it will be computed on the fly if possible.
Additionally, term vectors could be computed for documents not even existing in the index, but instead provided by the user.
</p>
<p>
warn
Start and end offsets assume UTF-16 encoding is being used. If you want to use these offsets in order to get the original text that produced this token, you should make sure that the string you are taking a sub-string of is also encoded using UTF-16.
</p>
<p>
<strong>Behaviour</strong>
</p>
<p>
The term and field statistics are not accurate.
Deleted documents are not taken into account.
The information is only retrieved for the shard the requested document resides in.
The term and field statistics are therefore only useful as relative measures whereas the absolute numbers have no meaning in this context.
By default, when requesting term vectors of artificial documents, a shard to get the statistics from is randomly selected.
Use <code>routing</code> only to hit a particular shard.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-termvectors.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual TermVectorsResponse Termvectors&lt;TDocument&gt;(IndexName index)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.TermVectorsResponse.html">TermVectorsResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Termvectors_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Termvectors*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Termvectors__1_Elastic_Clients_Elasticsearch_IndexName_Elastic_Clients_Elasticsearch_Id_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Termvectors``1(Elastic.Clients.Elasticsearch.IndexName,Elastic.Clients.Elasticsearch.Id)">
  Termvectors&lt;TDocument&gt;(IndexName, Id?)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L36491"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get term vector information.
</p>
<p>
Get information and statistics about terms in the fields of a particular document.
</p>
<p>
You can retrieve term vectors for documents stored in the index or for artificial documents passed in the body of the request.
You can specify the fields you are interested in through the <code>fields</code> parameter or by adding the fields to the request body.
For example:
</p>
<pre><code class="lang-csharp">GET /my-index-000001/_termvectors/1?fields=message</code></pre>
<p>
Fields can be specified using wildcards, similar to the multi match query.
</p>
<p>
Term vectors are real-time by default, not near real-time.
This can be changed by setting <code>realtime</code> parameter to <code>false</code>.
</p>
<p>
You can request three types of values: <em>term information</em>, <em>term statistics</em>, and <em>field statistics</em>.
By default, all term information and field statistics are returned for all fields but term statistics are excluded.
</p>
<p>
<strong>Term information</strong>
</p>
<ul><li>
<p>
term frequency in the field (always returned)
</p>
</li><li>
<p>
term positions (<code>positions: true</code>)
</p>
</li><li>
<p>
start and end offsets (<code>offsets: true</code>)
</p>
</li><li>
<p>
term payloads (<code>payloads: true</code>), as base64 encoded bytes
</p>
</li></ul>
<p>
If the requested information wasn't stored in the index, it will be computed on the fly if possible.
Additionally, term vectors could be computed for documents not even existing in the index, but instead provided by the user.
</p>
<p>
warn
Start and end offsets assume UTF-16 encoding is being used. If you want to use these offsets in order to get the original text that produced this token, you should make sure that the string you are taking a sub-string of is also encoded using UTF-16.
</p>
<p>
<strong>Behaviour</strong>
</p>
<p>
The term and field statistics are not accurate.
Deleted documents are not taken into account.
The information is only retrieved for the shard the requested document resides in.
The term and field statistics are therefore only useful as relative measures whereas the absolute numbers have no meaning in this context.
By default, when requesting term vectors of artificial documents, a shard to get the statistics from is randomly selected.
Use <code>routing</code> only to hit a particular shard.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-termvectors.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual TermVectorsResponse Termvectors&lt;TDocument&gt;(IndexName index, Id? id)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.TermVectorsResponse.html">TermVectorsResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Termvectors_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Termvectors*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Termvectors__1_Elastic_Clients_Elasticsearch_IndexName_Elastic_Clients_Elasticsearch_Id_System_Action_Elastic_Clients_Elasticsearch_TermVectorsRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Termvectors``1(Elastic.Clients.Elasticsearch.IndexName,Elastic.Clients.Elasticsearch.Id,System.Action{Elastic.Clients.Elasticsearch.TermVectorsRequestDescriptor{``0}})">
  Termvectors&lt;TDocument&gt;(IndexName, Id?, Action&lt;TermVectorsRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L36571"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get term vector information.
</p>
<p>
Get information and statistics about terms in the fields of a particular document.
</p>
<p>
You can retrieve term vectors for documents stored in the index or for artificial documents passed in the body of the request.
You can specify the fields you are interested in through the <code>fields</code> parameter or by adding the fields to the request body.
For example:
</p>
<pre><code class="lang-csharp">GET /my-index-000001/_termvectors/1?fields=message</code></pre>
<p>
Fields can be specified using wildcards, similar to the multi match query.
</p>
<p>
Term vectors are real-time by default, not near real-time.
This can be changed by setting <code>realtime</code> parameter to <code>false</code>.
</p>
<p>
You can request three types of values: <em>term information</em>, <em>term statistics</em>, and <em>field statistics</em>.
By default, all term information and field statistics are returned for all fields but term statistics are excluded.
</p>
<p>
<strong>Term information</strong>
</p>
<ul><li>
<p>
term frequency in the field (always returned)
</p>
</li><li>
<p>
term positions (<code>positions: true</code>)
</p>
</li><li>
<p>
start and end offsets (<code>offsets: true</code>)
</p>
</li><li>
<p>
term payloads (<code>payloads: true</code>), as base64 encoded bytes
</p>
</li></ul>
<p>
If the requested information wasn't stored in the index, it will be computed on the fly if possible.
Additionally, term vectors could be computed for documents not even existing in the index, but instead provided by the user.
</p>
<p>
warn
Start and end offsets assume UTF-16 encoding is being used. If you want to use these offsets in order to get the original text that produced this token, you should make sure that the string you are taking a sub-string of is also encoded using UTF-16.
</p>
<p>
<strong>Behaviour</strong>
</p>
<p>
The term and field statistics are not accurate.
Deleted documents are not taken into account.
The information is only retrieved for the shard the requested document resides in.
The term and field statistics are therefore only useful as relative measures whereas the absolute numbers have no meaning in this context.
By default, when requesting term vectors of artificial documents, a shard to get the statistics from is randomly selected.
Use <code>routing</code> only to hit a particular shard.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-termvectors.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual TermVectorsResponse Termvectors&lt;TDocument&gt;(IndexName index, Id? id, Action&lt;TermVectorsRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.TermVectorsRequestDescriptor-1.html">TermVectorsRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.TermVectorsResponse.html">TermVectorsResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Termvectors_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Termvectors*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Termvectors__1_Elastic_Clients_Elasticsearch_IndexName_System_Action_Elastic_Clients_Elasticsearch_TermVectorsRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Termvectors``1(Elastic.Clients.Elasticsearch.IndexName,System.Action{Elastic.Clients.Elasticsearch.TermVectorsRequestDescriptor{``0}})">
  Termvectors&lt;TDocument&gt;(IndexName, Action&lt;TermVectorsRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L36732"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get term vector information.
</p>
<p>
Get information and statistics about terms in the fields of a particular document.
</p>
<p>
You can retrieve term vectors for documents stored in the index or for artificial documents passed in the body of the request.
You can specify the fields you are interested in through the <code>fields</code> parameter or by adding the fields to the request body.
For example:
</p>
<pre><code class="lang-csharp">GET /my-index-000001/_termvectors/1?fields=message</code></pre>
<p>
Fields can be specified using wildcards, similar to the multi match query.
</p>
<p>
Term vectors are real-time by default, not near real-time.
This can be changed by setting <code>realtime</code> parameter to <code>false</code>.
</p>
<p>
You can request three types of values: <em>term information</em>, <em>term statistics</em>, and <em>field statistics</em>.
By default, all term information and field statistics are returned for all fields but term statistics are excluded.
</p>
<p>
<strong>Term information</strong>
</p>
<ul><li>
<p>
term frequency in the field (always returned)
</p>
</li><li>
<p>
term positions (<code>positions: true</code>)
</p>
</li><li>
<p>
start and end offsets (<code>offsets: true</code>)
</p>
</li><li>
<p>
term payloads (<code>payloads: true</code>), as base64 encoded bytes
</p>
</li></ul>
<p>
If the requested information wasn't stored in the index, it will be computed on the fly if possible.
Additionally, term vectors could be computed for documents not even existing in the index, but instead provided by the user.
</p>
<p>
warn
Start and end offsets assume UTF-16 encoding is being used. If you want to use these offsets in order to get the original text that produced this token, you should make sure that the string you are taking a sub-string of is also encoded using UTF-16.
</p>
<p>
<strong>Behaviour</strong>
</p>
<p>
The term and field statistics are not accurate.
Deleted documents are not taken into account.
The information is only retrieved for the shard the requested document resides in.
The term and field statistics are therefore only useful as relative measures whereas the absolute numbers have no meaning in this context.
By default, when requesting term vectors of artificial documents, a shard to get the statistics from is randomly selected.
Use <code>routing</code> only to hit a particular shard.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-termvectors.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual TermVectorsResponse Termvectors&lt;TDocument&gt;(IndexName index, Action&lt;TermVectorsRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.TermVectorsRequestDescriptor-1.html">TermVectorsRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.TermVectorsResponse.html">TermVectorsResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Termvectors_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Termvectors*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Termvectors__1_Elastic_Clients_Elasticsearch_TermVectorsRequestDescriptor___0__" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Termvectors``1(Elastic.Clients.Elasticsearch.TermVectorsRequestDescriptor{``0})">
  Termvectors&lt;TDocument&gt;(TermVectorsRequestDescriptor&lt;TDocument&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L36412"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get term vector information.
</p>
<p>
Get information and statistics about terms in the fields of a particular document.
</p>
<p>
You can retrieve term vectors for documents stored in the index or for artificial documents passed in the body of the request.
You can specify the fields you are interested in through the <code>fields</code> parameter or by adding the fields to the request body.
For example:
</p>
<pre><code class="lang-csharp">GET /my-index-000001/_termvectors/1?fields=message</code></pre>
<p>
Fields can be specified using wildcards, similar to the multi match query.
</p>
<p>
Term vectors are real-time by default, not near real-time.
This can be changed by setting <code>realtime</code> parameter to <code>false</code>.
</p>
<p>
You can request three types of values: <em>term information</em>, <em>term statistics</em>, and <em>field statistics</em>.
By default, all term information and field statistics are returned for all fields but term statistics are excluded.
</p>
<p>
<strong>Term information</strong>
</p>
<ul><li>
<p>
term frequency in the field (always returned)
</p>
</li><li>
<p>
term positions (<code>positions: true</code>)
</p>
</li><li>
<p>
start and end offsets (<code>offsets: true</code>)
</p>
</li><li>
<p>
term payloads (<code>payloads: true</code>), as base64 encoded bytes
</p>
</li></ul>
<p>
If the requested information wasn't stored in the index, it will be computed on the fly if possible.
Additionally, term vectors could be computed for documents not even existing in the index, but instead provided by the user.
</p>
<p>
warn
Start and end offsets assume UTF-16 encoding is being used. If you want to use these offsets in order to get the original text that produced this token, you should make sure that the string you are taking a sub-string of is also encoded using UTF-16.
</p>
<p>
<strong>Behaviour</strong>
</p>
<p>
The term and field statistics are not accurate.
Deleted documents are not taken into account.
The information is only retrieved for the shard the requested document resides in.
The term and field statistics are therefore only useful as relative measures whereas the absolute numbers have no meaning in this context.
By default, when requesting term vectors of artificial documents, a shard to get the statistics from is randomly selected.
Use <code>routing</code> only to hit a particular shard.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-termvectors.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual TermVectorsResponse Termvectors&lt;TDocument&gt;(TermVectorsRequestDescriptor&lt;TDocument&gt; descriptor)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.TermVectorsRequestDescriptor-1.html">TermVectorsRequestDescriptor</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.TermVectorsResponse.html">TermVectorsResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Termvectors_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Termvectors*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Termvectors__1_Elastic_Clients_Elasticsearch_TermVectorsRequest___0__" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Termvectors``1(Elastic.Clients.Elasticsearch.TermVectorsRequest{``0})">
  Termvectors&lt;TDocument&gt;(TermVectorsRequest&lt;TDocument&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L36255"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get term vector information.
</p>
<p>
Get information and statistics about terms in the fields of a particular document.
</p>
<p>
You can retrieve term vectors for documents stored in the index or for artificial documents passed in the body of the request.
You can specify the fields you are interested in through the <code>fields</code> parameter or by adding the fields to the request body.
For example:
</p>
<pre><code class="lang-csharp">GET /my-index-000001/_termvectors/1?fields=message</code></pre>
<p>
Fields can be specified using wildcards, similar to the multi match query.
</p>
<p>
Term vectors are real-time by default, not near real-time.
This can be changed by setting <code>realtime</code> parameter to <code>false</code>.
</p>
<p>
You can request three types of values: <em>term information</em>, <em>term statistics</em>, and <em>field statistics</em>.
By default, all term information and field statistics are returned for all fields but term statistics are excluded.
</p>
<p>
<strong>Term information</strong>
</p>
<ul><li>
<p>
term frequency in the field (always returned)
</p>
</li><li>
<p>
term positions (<code>positions: true</code>)
</p>
</li><li>
<p>
start and end offsets (<code>offsets: true</code>)
</p>
</li><li>
<p>
term payloads (<code>payloads: true</code>), as base64 encoded bytes
</p>
</li></ul>
<p>
If the requested information wasn't stored in the index, it will be computed on the fly if possible.
Additionally, term vectors could be computed for documents not even existing in the index, but instead provided by the user.
</p>
<p>
warn
Start and end offsets assume UTF-16 encoding is being used. If you want to use these offsets in order to get the original text that produced this token, you should make sure that the string you are taking a sub-string of is also encoded using UTF-16.
</p>
<p>
<strong>Behaviour</strong>
</p>
<p>
The term and field statistics are not accurate.
Deleted documents are not taken into account.
The information is only retrieved for the shard the requested document resides in.
The term and field statistics are therefore only useful as relative measures whereas the absolute numbers have no meaning in this context.
By default, when requesting term vectors of artificial documents, a shard to get the statistics from is randomly selected.
Use <code>routing</code> only to hit a particular shard.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-termvectors.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual TermVectorsResponse Termvectors&lt;TDocument&gt;(TermVectorsRequest&lt;TDocument&gt; request)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.TermVectorsRequest-1.html">TermVectorsRequest</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.TermVectorsResponse.html">TermVectorsResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Termvectors_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Termvectors*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Termvectors__1___0_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Termvectors``1(``0)">
  Termvectors&lt;TDocument&gt;(TDocument)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L36813"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get term vector information.
</p>
<p>
Get information and statistics about terms in the fields of a particular document.
</p>
<p>
You can retrieve term vectors for documents stored in the index or for artificial documents passed in the body of the request.
You can specify the fields you are interested in through the <code>fields</code> parameter or by adding the fields to the request body.
For example:
</p>
<pre><code class="lang-csharp">GET /my-index-000001/_termvectors/1?fields=message</code></pre>
<p>
Fields can be specified using wildcards, similar to the multi match query.
</p>
<p>
Term vectors are real-time by default, not near real-time.
This can be changed by setting <code>realtime</code> parameter to <code>false</code>.
</p>
<p>
You can request three types of values: <em>term information</em>, <em>term statistics</em>, and <em>field statistics</em>.
By default, all term information and field statistics are returned for all fields but term statistics are excluded.
</p>
<p>
<strong>Term information</strong>
</p>
<ul><li>
<p>
term frequency in the field (always returned)
</p>
</li><li>
<p>
term positions (<code>positions: true</code>)
</p>
</li><li>
<p>
start and end offsets (<code>offsets: true</code>)
</p>
</li><li>
<p>
term payloads (<code>payloads: true</code>), as base64 encoded bytes
</p>
</li></ul>
<p>
If the requested information wasn't stored in the index, it will be computed on the fly if possible.
Additionally, term vectors could be computed for documents not even existing in the index, but instead provided by the user.
</p>
<p>
warn
Start and end offsets assume UTF-16 encoding is being used. If you want to use these offsets in order to get the original text that produced this token, you should make sure that the string you are taking a sub-string of is also encoded using UTF-16.
</p>
<p>
<strong>Behaviour</strong>
</p>
<p>
The term and field statistics are not accurate.
Deleted documents are not taken into account.
The information is only retrieved for the shard the requested document resides in.
The term and field statistics are therefore only useful as relative measures whereas the absolute numbers have no meaning in this context.
By default, when requesting term vectors of artificial documents, a shard to get the statistics from is randomly selected.
Use <code>routing</code> only to hit a particular shard.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-termvectors.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual TermVectorsResponse Termvectors&lt;TDocument&gt;(TDocument document)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.TermVectorsResponse.html">TermVectorsResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Termvectors_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Termvectors*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Termvectors__1___0_Elastic_Clients_Elasticsearch_Id_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Termvectors``1(``0,Elastic.Clients.Elasticsearch.Id)">
  Termvectors&lt;TDocument&gt;(TDocument, Id?)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L37135"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get term vector information.
</p>
<p>
Get information and statistics about terms in the fields of a particular document.
</p>
<p>
You can retrieve term vectors for documents stored in the index or for artificial documents passed in the body of the request.
You can specify the fields you are interested in through the <code>fields</code> parameter or by adding the fields to the request body.
For example:
</p>
<pre><code class="lang-csharp">GET /my-index-000001/_termvectors/1?fields=message</code></pre>
<p>
Fields can be specified using wildcards, similar to the multi match query.
</p>
<p>
Term vectors are real-time by default, not near real-time.
This can be changed by setting <code>realtime</code> parameter to <code>false</code>.
</p>
<p>
You can request three types of values: <em>term information</em>, <em>term statistics</em>, and <em>field statistics</em>.
By default, all term information and field statistics are returned for all fields but term statistics are excluded.
</p>
<p>
<strong>Term information</strong>
</p>
<ul><li>
<p>
term frequency in the field (always returned)
</p>
</li><li>
<p>
term positions (<code>positions: true</code>)
</p>
</li><li>
<p>
start and end offsets (<code>offsets: true</code>)
</p>
</li><li>
<p>
term payloads (<code>payloads: true</code>), as base64 encoded bytes
</p>
</li></ul>
<p>
If the requested information wasn't stored in the index, it will be computed on the fly if possible.
Additionally, term vectors could be computed for documents not even existing in the index, but instead provided by the user.
</p>
<p>
warn
Start and end offsets assume UTF-16 encoding is being used. If you want to use these offsets in order to get the original text that produced this token, you should make sure that the string you are taking a sub-string of is also encoded using UTF-16.
</p>
<p>
<strong>Behaviour</strong>
</p>
<p>
The term and field statistics are not accurate.
Deleted documents are not taken into account.
The information is only retrieved for the shard the requested document resides in.
The term and field statistics are therefore only useful as relative measures whereas the absolute numbers have no meaning in this context.
By default, when requesting term vectors of artificial documents, a shard to get the statistics from is randomly selected.
Use <code>routing</code> only to hit a particular shard.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-termvectors.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual TermVectorsResponse Termvectors&lt;TDocument&gt;(TDocument document, Id? id)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.TermVectorsResponse.html">TermVectorsResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Termvectors_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Termvectors*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Termvectors__1___0_Elastic_Clients_Elasticsearch_Id_System_Action_Elastic_Clients_Elasticsearch_TermVectorsRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Termvectors``1(``0,Elastic.Clients.Elasticsearch.Id,System.Action{Elastic.Clients.Elasticsearch.TermVectorsRequestDescriptor{``0}})">
  Termvectors&lt;TDocument&gt;(TDocument, Id?, Action&lt;TermVectorsRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L37215"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get term vector information.
</p>
<p>
Get information and statistics about terms in the fields of a particular document.
</p>
<p>
You can retrieve term vectors for documents stored in the index or for artificial documents passed in the body of the request.
You can specify the fields you are interested in through the <code>fields</code> parameter or by adding the fields to the request body.
For example:
</p>
<pre><code class="lang-csharp">GET /my-index-000001/_termvectors/1?fields=message</code></pre>
<p>
Fields can be specified using wildcards, similar to the multi match query.
</p>
<p>
Term vectors are real-time by default, not near real-time.
This can be changed by setting <code>realtime</code> parameter to <code>false</code>.
</p>
<p>
You can request three types of values: <em>term information</em>, <em>term statistics</em>, and <em>field statistics</em>.
By default, all term information and field statistics are returned for all fields but term statistics are excluded.
</p>
<p>
<strong>Term information</strong>
</p>
<ul><li>
<p>
term frequency in the field (always returned)
</p>
</li><li>
<p>
term positions (<code>positions: true</code>)
</p>
</li><li>
<p>
start and end offsets (<code>offsets: true</code>)
</p>
</li><li>
<p>
term payloads (<code>payloads: true</code>), as base64 encoded bytes
</p>
</li></ul>
<p>
If the requested information wasn't stored in the index, it will be computed on the fly if possible.
Additionally, term vectors could be computed for documents not even existing in the index, but instead provided by the user.
</p>
<p>
warn
Start and end offsets assume UTF-16 encoding is being used. If you want to use these offsets in order to get the original text that produced this token, you should make sure that the string you are taking a sub-string of is also encoded using UTF-16.
</p>
<p>
<strong>Behaviour</strong>
</p>
<p>
The term and field statistics are not accurate.
Deleted documents are not taken into account.
The information is only retrieved for the shard the requested document resides in.
The term and field statistics are therefore only useful as relative measures whereas the absolute numbers have no meaning in this context.
By default, when requesting term vectors of artificial documents, a shard to get the statistics from is randomly selected.
Use <code>routing</code> only to hit a particular shard.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-termvectors.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual TermVectorsResponse Termvectors&lt;TDocument&gt;(TDocument document, Id? id, Action&lt;TermVectorsRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.TermVectorsRequestDescriptor-1.html">TermVectorsRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.TermVectorsResponse.html">TermVectorsResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Termvectors_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Termvectors*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Termvectors__1___0_Elastic_Clients_Elasticsearch_IndexName_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Termvectors``1(``0,Elastic.Clients.Elasticsearch.IndexName)">
  Termvectors&lt;TDocument&gt;(TDocument, IndexName)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L36974"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get term vector information.
</p>
<p>
Get information and statistics about terms in the fields of a particular document.
</p>
<p>
You can retrieve term vectors for documents stored in the index or for artificial documents passed in the body of the request.
You can specify the fields you are interested in through the <code>fields</code> parameter or by adding the fields to the request body.
For example:
</p>
<pre><code class="lang-csharp">GET /my-index-000001/_termvectors/1?fields=message</code></pre>
<p>
Fields can be specified using wildcards, similar to the multi match query.
</p>
<p>
Term vectors are real-time by default, not near real-time.
This can be changed by setting <code>realtime</code> parameter to <code>false</code>.
</p>
<p>
You can request three types of values: <em>term information</em>, <em>term statistics</em>, and <em>field statistics</em>.
By default, all term information and field statistics are returned for all fields but term statistics are excluded.
</p>
<p>
<strong>Term information</strong>
</p>
<ul><li>
<p>
term frequency in the field (always returned)
</p>
</li><li>
<p>
term positions (<code>positions: true</code>)
</p>
</li><li>
<p>
start and end offsets (<code>offsets: true</code>)
</p>
</li><li>
<p>
term payloads (<code>payloads: true</code>), as base64 encoded bytes
</p>
</li></ul>
<p>
If the requested information wasn't stored in the index, it will be computed on the fly if possible.
Additionally, term vectors could be computed for documents not even existing in the index, but instead provided by the user.
</p>
<p>
warn
Start and end offsets assume UTF-16 encoding is being used. If you want to use these offsets in order to get the original text that produced this token, you should make sure that the string you are taking a sub-string of is also encoded using UTF-16.
</p>
<p>
<strong>Behaviour</strong>
</p>
<p>
The term and field statistics are not accurate.
Deleted documents are not taken into account.
The information is only retrieved for the shard the requested document resides in.
The term and field statistics are therefore only useful as relative measures whereas the absolute numbers have no meaning in this context.
By default, when requesting term vectors of artificial documents, a shard to get the statistics from is randomly selected.
Use <code>routing</code> only to hit a particular shard.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-termvectors.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual TermVectorsResponse Termvectors&lt;TDocument&gt;(TDocument document, IndexName index)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.TermVectorsResponse.html">TermVectorsResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Termvectors_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Termvectors*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Termvectors__1___0_Elastic_Clients_Elasticsearch_IndexName_System_Action_Elastic_Clients_Elasticsearch_TermVectorsRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Termvectors``1(``0,Elastic.Clients.Elasticsearch.IndexName,System.Action{Elastic.Clients.Elasticsearch.TermVectorsRequestDescriptor{``0}})">
  Termvectors&lt;TDocument&gt;(TDocument, IndexName, Action&lt;TermVectorsRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L37054"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get term vector information.
</p>
<p>
Get information and statistics about terms in the fields of a particular document.
</p>
<p>
You can retrieve term vectors for documents stored in the index or for artificial documents passed in the body of the request.
You can specify the fields you are interested in through the <code>fields</code> parameter or by adding the fields to the request body.
For example:
</p>
<pre><code class="lang-csharp">GET /my-index-000001/_termvectors/1?fields=message</code></pre>
<p>
Fields can be specified using wildcards, similar to the multi match query.
</p>
<p>
Term vectors are real-time by default, not near real-time.
This can be changed by setting <code>realtime</code> parameter to <code>false</code>.
</p>
<p>
You can request three types of values: <em>term information</em>, <em>term statistics</em>, and <em>field statistics</em>.
By default, all term information and field statistics are returned for all fields but term statistics are excluded.
</p>
<p>
<strong>Term information</strong>
</p>
<ul><li>
<p>
term frequency in the field (always returned)
</p>
</li><li>
<p>
term positions (<code>positions: true</code>)
</p>
</li><li>
<p>
start and end offsets (<code>offsets: true</code>)
</p>
</li><li>
<p>
term payloads (<code>payloads: true</code>), as base64 encoded bytes
</p>
</li></ul>
<p>
If the requested information wasn't stored in the index, it will be computed on the fly if possible.
Additionally, term vectors could be computed for documents not even existing in the index, but instead provided by the user.
</p>
<p>
warn
Start and end offsets assume UTF-16 encoding is being used. If you want to use these offsets in order to get the original text that produced this token, you should make sure that the string you are taking a sub-string of is also encoded using UTF-16.
</p>
<p>
<strong>Behaviour</strong>
</p>
<p>
The term and field statistics are not accurate.
Deleted documents are not taken into account.
The information is only retrieved for the shard the requested document resides in.
The term and field statistics are therefore only useful as relative measures whereas the absolute numbers have no meaning in this context.
By default, when requesting term vectors of artificial documents, a shard to get the statistics from is randomly selected.
Use <code>routing</code> only to hit a particular shard.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-termvectors.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual TermVectorsResponse Termvectors&lt;TDocument&gt;(TDocument document, IndexName index, Action&lt;TermVectorsRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.TermVectorsRequestDescriptor-1.html">TermVectorsRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.TermVectorsResponse.html">TermVectorsResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Termvectors_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Termvectors*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Termvectors__1___0_System_Action_Elastic_Clients_Elasticsearch_TermVectorsRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Termvectors``1(``0,System.Action{Elastic.Clients.Elasticsearch.TermVectorsRequestDescriptor{``0}})">
  Termvectors&lt;TDocument&gt;(TDocument, Action&lt;TermVectorsRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L36893"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Get term vector information.
</p>
<p>
Get information and statistics about terms in the fields of a particular document.
</p>
<p>
You can retrieve term vectors for documents stored in the index or for artificial documents passed in the body of the request.
You can specify the fields you are interested in through the <code>fields</code> parameter or by adding the fields to the request body.
For example:
</p>
<pre><code class="lang-csharp">GET /my-index-000001/_termvectors/1?fields=message</code></pre>
<p>
Fields can be specified using wildcards, similar to the multi match query.
</p>
<p>
Term vectors are real-time by default, not near real-time.
This can be changed by setting <code>realtime</code> parameter to <code>false</code>.
</p>
<p>
You can request three types of values: <em>term information</em>, <em>term statistics</em>, and <em>field statistics</em>.
By default, all term information and field statistics are returned for all fields but term statistics are excluded.
</p>
<p>
<strong>Term information</strong>
</p>
<ul><li>
<p>
term frequency in the field (always returned)
</p>
</li><li>
<p>
term positions (<code>positions: true</code>)
</p>
</li><li>
<p>
start and end offsets (<code>offsets: true</code>)
</p>
</li><li>
<p>
term payloads (<code>payloads: true</code>), as base64 encoded bytes
</p>
</li></ul>
<p>
If the requested information wasn't stored in the index, it will be computed on the fly if possible.
Additionally, term vectors could be computed for documents not even existing in the index, but instead provided by the user.
</p>
<p>
warn
Start and end offsets assume UTF-16 encoding is being used. If you want to use these offsets in order to get the original text that produced this token, you should make sure that the string you are taking a sub-string of is also encoded using UTF-16.
</p>
<p>
<strong>Behaviour</strong>
</p>
<p>
The term and field statistics are not accurate.
Deleted documents are not taken into account.
The information is only retrieved for the shard the requested document resides in.
The term and field statistics are therefore only useful as relative measures whereas the absolute numbers have no meaning in this context.
By default, when requesting term vectors of artificial documents, a shard to get the statistics from is randomly selected.
Use <code>routing</code> only to hit a particular shard.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-termvectors.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual TermVectorsResponse Termvectors&lt;TDocument&gt;(TDocument document, Action&lt;TermVectorsRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.TermVectorsRequestDescriptor-1.html">TermVectorsRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.TermVectorsResponse.html">TermVectorsResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_UpdateAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.UpdateAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_UpdateAsync__2_Elastic_Clients_Elasticsearch_Id_System_Action_Elastic_Clients_Elasticsearch_UpdateRequestDescriptor___0___1___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.UpdateAsync``2(Elastic.Clients.Elasticsearch.Id,System.Action{Elastic.Clients.Elasticsearch.UpdateRequestDescriptor{``0,``1}},System.Threading.CancellationToken)">
  UpdateAsync&lt;TDocument, TPartialDocument&gt;(Id, Action&lt;UpdateRequestDescriptor&lt;TDocument, TPartialDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L39603"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Update a document.
</p>
<p>
Update a document by running a script or passing a partial document.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the <code>index</code> or <code>write</code> index privilege for the target index or index alias.
</p>
<p>
The script can update, delete, or skip modifying the document.
The API also supports passing a partial document, which is merged into the existing document.
To fully replace an existing document, use the index API.
This operation:
</p>
<ul><li>
<p>
Gets the document (collocated with the shard) from the index.
</p>
</li><li>
<p>
Runs the specified script.
</p>
</li><li>
<p>
Indexes the result.
</p>
</li></ul>
<p>
The document must still be reindexed, but using this API removes some network roundtrips and reduces chances of version conflicts between the GET and the index operation.
</p>
<p>
The <code>_source</code> field must be enabled to use this API.
In addition to <code>_source</code>, you can access the following variables through the <code>ctx</code> map: <code>_index</code>, <code>_type</code>, <code>_id</code>, <code>_version</code>, <code>_routing</code>, and <code>_now</code> (the current timestamp).
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-update.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;UpdateResponse&lt;TDocument&gt;&gt; UpdateAsync&lt;TDocument, TPartialDocument&gt;(Id id, Action&lt;UpdateRequestDescriptor&lt;TDocument, TPartialDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.UpdateRequestDescriptor-2.html">UpdateRequestDescriptor</a>&lt;TDocument, TPartialDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.UpdateResponse-1.html">UpdateResponse</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
    <dt><code>TPartialDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_UpdateAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.UpdateAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_UpdateAsync__2_Elastic_Clients_Elasticsearch_Id_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.UpdateAsync``2(Elastic.Clients.Elasticsearch.Id,System.Threading.CancellationToken)">
  UpdateAsync&lt;TDocument, TPartialDocument&gt;(Id, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L39554"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Update a document.
</p>
<p>
Update a document by running a script or passing a partial document.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the <code>index</code> or <code>write</code> index privilege for the target index or index alias.
</p>
<p>
The script can update, delete, or skip modifying the document.
The API also supports passing a partial document, which is merged into the existing document.
To fully replace an existing document, use the index API.
This operation:
</p>
<ul><li>
<p>
Gets the document (collocated with the shard) from the index.
</p>
</li><li>
<p>
Runs the specified script.
</p>
</li><li>
<p>
Indexes the result.
</p>
</li></ul>
<p>
The document must still be reindexed, but using this API removes some network roundtrips and reduces chances of version conflicts between the GET and the index operation.
</p>
<p>
The <code>_source</code> field must be enabled to use this API.
In addition to <code>_source</code>, you can access the following variables through the <code>ctx</code> map: <code>_index</code>, <code>_type</code>, <code>_id</code>, <code>_version</code>, <code>_routing</code>, and <code>_now</code> (the current timestamp).
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-update.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;UpdateResponse&lt;TDocument&gt;&gt; UpdateAsync&lt;TDocument, TPartialDocument&gt;(Id id, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.UpdateResponse-1.html">UpdateResponse</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
    <dt><code>TPartialDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_UpdateAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.UpdateAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_UpdateAsync__2_Elastic_Clients_Elasticsearch_IndexName_Elastic_Clients_Elasticsearch_Id_System_Action_Elastic_Clients_Elasticsearch_UpdateRequestDescriptor___0___1___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.UpdateAsync``2(Elastic.Clients.Elasticsearch.IndexName,Elastic.Clients.Elasticsearch.Id,System.Action{Elastic.Clients.Elasticsearch.UpdateRequestDescriptor{``0,``1}},System.Threading.CancellationToken)">
  UpdateAsync&lt;TDocument, TPartialDocument&gt;(IndexName, Id, Action&lt;UpdateRequestDescriptor&lt;TDocument, TPartialDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L39207"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Update a document.
</p>
<p>
Update a document by running a script or passing a partial document.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the <code>index</code> or <code>write</code> index privilege for the target index or index alias.
</p>
<p>
The script can update, delete, or skip modifying the document.
The API also supports passing a partial document, which is merged into the existing document.
To fully replace an existing document, use the index API.
This operation:
</p>
<ul><li>
<p>
Gets the document (collocated with the shard) from the index.
</p>
</li><li>
<p>
Runs the specified script.
</p>
</li><li>
<p>
Indexes the result.
</p>
</li></ul>
<p>
The document must still be reindexed, but using this API removes some network roundtrips and reduces chances of version conflicts between the GET and the index operation.
</p>
<p>
The <code>_source</code> field must be enabled to use this API.
In addition to <code>_source</code>, you can access the following variables through the <code>ctx</code> map: <code>_index</code>, <code>_type</code>, <code>_id</code>, <code>_version</code>, <code>_routing</code>, and <code>_now</code> (the current timestamp).
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-update.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;UpdateResponse&lt;TDocument&gt;&gt; UpdateAsync&lt;TDocument, TPartialDocument&gt;(IndexName index, Id id, Action&lt;UpdateRequestDescriptor&lt;TDocument, TPartialDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.UpdateRequestDescriptor-2.html">UpdateRequestDescriptor</a>&lt;TDocument, TPartialDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.UpdateResponse-1.html">UpdateResponse</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
    <dt><code>TPartialDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_UpdateAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.UpdateAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_UpdateAsync__2_Elastic_Clients_Elasticsearch_IndexName_Elastic_Clients_Elasticsearch_Id_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.UpdateAsync``2(Elastic.Clients.Elasticsearch.IndexName,Elastic.Clients.Elasticsearch.Id,System.Threading.CancellationToken)">
  UpdateAsync&lt;TDocument, TPartialDocument&gt;(IndexName, Id, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L39158"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Update a document.
</p>
<p>
Update a document by running a script or passing a partial document.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the <code>index</code> or <code>write</code> index privilege for the target index or index alias.
</p>
<p>
The script can update, delete, or skip modifying the document.
The API also supports passing a partial document, which is merged into the existing document.
To fully replace an existing document, use the index API.
This operation:
</p>
<ul><li>
<p>
Gets the document (collocated with the shard) from the index.
</p>
</li><li>
<p>
Runs the specified script.
</p>
</li><li>
<p>
Indexes the result.
</p>
</li></ul>
<p>
The document must still be reindexed, but using this API removes some network roundtrips and reduces chances of version conflicts between the GET and the index operation.
</p>
<p>
The <code>_source</code> field must be enabled to use this API.
In addition to <code>_source</code>, you can access the following variables through the <code>ctx</code> map: <code>_index</code>, <code>_type</code>, <code>_id</code>, <code>_version</code>, <code>_routing</code>, and <code>_now</code> (the current timestamp).
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-update.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;UpdateResponse&lt;TDocument&gt;&gt; UpdateAsync&lt;TDocument, TPartialDocument&gt;(IndexName index, Id id, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.UpdateResponse-1.html">UpdateResponse</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
    <dt><code>TPartialDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_UpdateAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.UpdateAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_UpdateAsync__2_Elastic_Clients_Elasticsearch_UpdateRequestDescriptor___0___1__System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.UpdateAsync``2(Elastic.Clients.Elasticsearch.UpdateRequestDescriptor{``0,``1},System.Threading.CancellationToken)">
  UpdateAsync&lt;TDocument, TPartialDocument&gt;(UpdateRequestDescriptor&lt;TDocument, TPartialDocument&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L39110"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Update a document.
</p>
<p>
Update a document by running a script or passing a partial document.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the <code>index</code> or <code>write</code> index privilege for the target index or index alias.
</p>
<p>
The script can update, delete, or skip modifying the document.
The API also supports passing a partial document, which is merged into the existing document.
To fully replace an existing document, use the index API.
This operation:
</p>
<ul><li>
<p>
Gets the document (collocated with the shard) from the index.
</p>
</li><li>
<p>
Runs the specified script.
</p>
</li><li>
<p>
Indexes the result.
</p>
</li></ul>
<p>
The document must still be reindexed, but using this API removes some network roundtrips and reduces chances of version conflicts between the GET and the index operation.
</p>
<p>
The <code>_source</code> field must be enabled to use this API.
In addition to <code>_source</code>, you can access the following variables through the <code>ctx</code> map: <code>_index</code>, <code>_type</code>, <code>_id</code>, <code>_version</code>, <code>_routing</code>, and <code>_now</code> (the current timestamp).
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-update.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;UpdateResponse&lt;TDocument&gt;&gt; UpdateAsync&lt;TDocument, TPartialDocument&gt;(UpdateRequestDescriptor&lt;TDocument, TPartialDocument&gt; descriptor, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.UpdateRequestDescriptor-2.html">UpdateRequestDescriptor</a>&lt;TDocument, TPartialDocument&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.UpdateResponse-1.html">UpdateResponse</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
    <dt><code>TPartialDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_UpdateAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.UpdateAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_UpdateAsync__2_Elastic_Clients_Elasticsearch_UpdateRequest___0___1__System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.UpdateAsync``2(Elastic.Clients.Elasticsearch.UpdateRequest{``0,``1},System.Threading.CancellationToken)">
  UpdateAsync&lt;TDocument, TPartialDocument&gt;(UpdateRequest&lt;TDocument, TPartialDocument&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L38508"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Update a document.
</p>
<p>
Update a document by running a script or passing a partial document.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the <code>index</code> or <code>write</code> index privilege for the target index or index alias.
</p>
<p>
The script can update, delete, or skip modifying the document.
The API also supports passing a partial document, which is merged into the existing document.
To fully replace an existing document, use the index API.
This operation:
</p>
<ul><li>
<p>
Gets the document (collocated with the shard) from the index.
</p>
</li><li>
<p>
Runs the specified script.
</p>
</li><li>
<p>
Indexes the result.
</p>
</li></ul>
<p>
The document must still be reindexed, but using this API removes some network roundtrips and reduces chances of version conflicts between the GET and the index operation.
</p>
<p>
The <code>_source</code> field must be enabled to use this API.
In addition to <code>_source</code>, you can access the following variables through the <code>ctx</code> map: <code>_index</code>, <code>_type</code>, <code>_id</code>, <code>_version</code>, <code>_routing</code>, and <code>_now</code> (the current timestamp).
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-update.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;UpdateResponse&lt;TDocument&gt;&gt; UpdateAsync&lt;TDocument, TPartialDocument&gt;(UpdateRequest&lt;TDocument, TPartialDocument&gt; request, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.UpdateRequest-2.html">UpdateRequest</a>&lt;TDocument, TPartialDocument&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.UpdateResponse-1.html">UpdateResponse</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
    <dt><code>TPartialDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_UpdateAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.UpdateAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_UpdateAsync__2___0_Elastic_Clients_Elasticsearch_Id_System_Action_Elastic_Clients_Elasticsearch_UpdateRequestDescriptor___0___1___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.UpdateAsync``2(``0,Elastic.Clients.Elasticsearch.Id,System.Action{Elastic.Clients.Elasticsearch.UpdateRequestDescriptor{``0,``1}},System.Threading.CancellationToken)">
  UpdateAsync&lt;TDocument, TPartialDocument&gt;(TDocument, Id, Action&lt;UpdateRequestDescriptor&lt;TDocument, TPartialDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L39504"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Update a document.
</p>
<p>
Update a document by running a script or passing a partial document.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the <code>index</code> or <code>write</code> index privilege for the target index or index alias.
</p>
<p>
The script can update, delete, or skip modifying the document.
The API also supports passing a partial document, which is merged into the existing document.
To fully replace an existing document, use the index API.
This operation:
</p>
<ul><li>
<p>
Gets the document (collocated with the shard) from the index.
</p>
</li><li>
<p>
Runs the specified script.
</p>
</li><li>
<p>
Indexes the result.
</p>
</li></ul>
<p>
The document must still be reindexed, but using this API removes some network roundtrips and reduces chances of version conflicts between the GET and the index operation.
</p>
<p>
The <code>_source</code> field must be enabled to use this API.
In addition to <code>_source</code>, you can access the following variables through the <code>ctx</code> map: <code>_index</code>, <code>_type</code>, <code>_id</code>, <code>_version</code>, <code>_routing</code>, and <code>_now</code> (the current timestamp).
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-update.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;UpdateResponse&lt;TDocument&gt;&gt; UpdateAsync&lt;TDocument, TPartialDocument&gt;(TDocument document, Id id, Action&lt;UpdateRequestDescriptor&lt;TDocument, TPartialDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.UpdateRequestDescriptor-2.html">UpdateRequestDescriptor</a>&lt;TDocument, TPartialDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.UpdateResponse-1.html">UpdateResponse</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
    <dt><code>TPartialDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_UpdateAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.UpdateAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_UpdateAsync__2___0_Elastic_Clients_Elasticsearch_Id_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.UpdateAsync``2(``0,Elastic.Clients.Elasticsearch.Id,System.Threading.CancellationToken)">
  UpdateAsync&lt;TDocument, TPartialDocument&gt;(TDocument, Id, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L39455"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Update a document.
</p>
<p>
Update a document by running a script or passing a partial document.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the <code>index</code> or <code>write</code> index privilege for the target index or index alias.
</p>
<p>
The script can update, delete, or skip modifying the document.
The API also supports passing a partial document, which is merged into the existing document.
To fully replace an existing document, use the index API.
This operation:
</p>
<ul><li>
<p>
Gets the document (collocated with the shard) from the index.
</p>
</li><li>
<p>
Runs the specified script.
</p>
</li><li>
<p>
Indexes the result.
</p>
</li></ul>
<p>
The document must still be reindexed, but using this API removes some network roundtrips and reduces chances of version conflicts between the GET and the index operation.
</p>
<p>
The <code>_source</code> field must be enabled to use this API.
In addition to <code>_source</code>, you can access the following variables through the <code>ctx</code> map: <code>_index</code>, <code>_type</code>, <code>_id</code>, <code>_version</code>, <code>_routing</code>, and <code>_now</code> (the current timestamp).
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-update.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;UpdateResponse&lt;TDocument&gt;&gt; UpdateAsync&lt;TDocument, TPartialDocument&gt;(TDocument document, Id id, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.UpdateResponse-1.html">UpdateResponse</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
    <dt><code>TPartialDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_UpdateAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.UpdateAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_UpdateAsync__2___0_Elastic_Clients_Elasticsearch_IndexName_System_Action_Elastic_Clients_Elasticsearch_UpdateRequestDescriptor___0___1___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.UpdateAsync``2(``0,Elastic.Clients.Elasticsearch.IndexName,System.Action{Elastic.Clients.Elasticsearch.UpdateRequestDescriptor{``0,``1}},System.Threading.CancellationToken)">
  UpdateAsync&lt;TDocument, TPartialDocument&gt;(TDocument, IndexName, Action&lt;UpdateRequestDescriptor&lt;TDocument, TPartialDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L39405"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Update a document.
</p>
<p>
Update a document by running a script or passing a partial document.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the <code>index</code> or <code>write</code> index privilege for the target index or index alias.
</p>
<p>
The script can update, delete, or skip modifying the document.
The API also supports passing a partial document, which is merged into the existing document.
To fully replace an existing document, use the index API.
This operation:
</p>
<ul><li>
<p>
Gets the document (collocated with the shard) from the index.
</p>
</li><li>
<p>
Runs the specified script.
</p>
</li><li>
<p>
Indexes the result.
</p>
</li></ul>
<p>
The document must still be reindexed, but using this API removes some network roundtrips and reduces chances of version conflicts between the GET and the index operation.
</p>
<p>
The <code>_source</code> field must be enabled to use this API.
In addition to <code>_source</code>, you can access the following variables through the <code>ctx</code> map: <code>_index</code>, <code>_type</code>, <code>_id</code>, <code>_version</code>, <code>_routing</code>, and <code>_now</code> (the current timestamp).
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-update.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;UpdateResponse&lt;TDocument&gt;&gt; UpdateAsync&lt;TDocument, TPartialDocument&gt;(TDocument document, IndexName index, Action&lt;UpdateRequestDescriptor&lt;TDocument, TPartialDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.UpdateRequestDescriptor-2.html">UpdateRequestDescriptor</a>&lt;TDocument, TPartialDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.UpdateResponse-1.html">UpdateResponse</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
    <dt><code>TPartialDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_UpdateAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.UpdateAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_UpdateAsync__2___0_Elastic_Clients_Elasticsearch_IndexName_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.UpdateAsync``2(``0,Elastic.Clients.Elasticsearch.IndexName,System.Threading.CancellationToken)">
  UpdateAsync&lt;TDocument, TPartialDocument&gt;(TDocument, IndexName, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L39356"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Update a document.
</p>
<p>
Update a document by running a script or passing a partial document.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the <code>index</code> or <code>write</code> index privilege for the target index or index alias.
</p>
<p>
The script can update, delete, or skip modifying the document.
The API also supports passing a partial document, which is merged into the existing document.
To fully replace an existing document, use the index API.
This operation:
</p>
<ul><li>
<p>
Gets the document (collocated with the shard) from the index.
</p>
</li><li>
<p>
Runs the specified script.
</p>
</li><li>
<p>
Indexes the result.
</p>
</li></ul>
<p>
The document must still be reindexed, but using this API removes some network roundtrips and reduces chances of version conflicts between the GET and the index operation.
</p>
<p>
The <code>_source</code> field must be enabled to use this API.
In addition to <code>_source</code>, you can access the following variables through the <code>ctx</code> map: <code>_index</code>, <code>_type</code>, <code>_id</code>, <code>_version</code>, <code>_routing</code>, and <code>_now</code> (the current timestamp).
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-update.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;UpdateResponse&lt;TDocument&gt;&gt; UpdateAsync&lt;TDocument, TPartialDocument&gt;(TDocument document, IndexName index, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.UpdateResponse-1.html">UpdateResponse</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
    <dt><code>TPartialDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_UpdateAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.UpdateAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_UpdateAsync__2___0_System_Action_Elastic_Clients_Elasticsearch_UpdateRequestDescriptor___0___1___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.UpdateAsync``2(``0,System.Action{Elastic.Clients.Elasticsearch.UpdateRequestDescriptor{``0,``1}},System.Threading.CancellationToken)">
  UpdateAsync&lt;TDocument, TPartialDocument&gt;(TDocument, Action&lt;UpdateRequestDescriptor&lt;TDocument, TPartialDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L39306"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Update a document.
</p>
<p>
Update a document by running a script or passing a partial document.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the <code>index</code> or <code>write</code> index privilege for the target index or index alias.
</p>
<p>
The script can update, delete, or skip modifying the document.
The API also supports passing a partial document, which is merged into the existing document.
To fully replace an existing document, use the index API.
This operation:
</p>
<ul><li>
<p>
Gets the document (collocated with the shard) from the index.
</p>
</li><li>
<p>
Runs the specified script.
</p>
</li><li>
<p>
Indexes the result.
</p>
</li></ul>
<p>
The document must still be reindexed, but using this API removes some network roundtrips and reduces chances of version conflicts between the GET and the index operation.
</p>
<p>
The <code>_source</code> field must be enabled to use this API.
In addition to <code>_source</code>, you can access the following variables through the <code>ctx</code> map: <code>_index</code>, <code>_type</code>, <code>_id</code>, <code>_version</code>, <code>_routing</code>, and <code>_now</code> (the current timestamp).
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-update.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;UpdateResponse&lt;TDocument&gt;&gt; UpdateAsync&lt;TDocument, TPartialDocument&gt;(TDocument document, Action&lt;UpdateRequestDescriptor&lt;TDocument, TPartialDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.UpdateRequestDescriptor-2.html">UpdateRequestDescriptor</a>&lt;TDocument, TPartialDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.UpdateResponse-1.html">UpdateResponse</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
    <dt><code>TPartialDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_UpdateAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.UpdateAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_UpdateAsync__2___0_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.UpdateAsync``2(``0,System.Threading.CancellationToken)">
  UpdateAsync&lt;TDocument, TPartialDocument&gt;(TDocument, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L39257"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Update a document.
</p>
<p>
Update a document by running a script or passing a partial document.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the <code>index</code> or <code>write</code> index privilege for the target index or index alias.
</p>
<p>
The script can update, delete, or skip modifying the document.
The API also supports passing a partial document, which is merged into the existing document.
To fully replace an existing document, use the index API.
This operation:
</p>
<ul><li>
<p>
Gets the document (collocated with the shard) from the index.
</p>
</li><li>
<p>
Runs the specified script.
</p>
</li><li>
<p>
Indexes the result.
</p>
</li></ul>
<p>
The document must still be reindexed, but using this API removes some network roundtrips and reduces chances of version conflicts between the GET and the index operation.
</p>
<p>
The <code>_source</code> field must be enabled to use this API.
In addition to <code>_source</code>, you can access the following variables through the <code>ctx</code> map: <code>_index</code>, <code>_type</code>, <code>_id</code>, <code>_version</code>, <code>_routing</code>, and <code>_now</code> (the current timestamp).
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-update.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;UpdateResponse&lt;TDocument&gt;&gt; UpdateAsync&lt;TDocument, TPartialDocument&gt;(TDocument document, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.UpdateResponse-1.html">UpdateResponse</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
    <dt><code>TPartialDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_UpdateAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.UpdateAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_UpdateAsync__2___0___1_Elastic_Clients_Elasticsearch_IndexName_Elastic_Clients_Elasticsearch_Id_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.UpdateAsync``2(``0,``1,Elastic.Clients.Elasticsearch.IndexName,Elastic.Clients.Elasticsearch.Id,System.Threading.CancellationToken)">
  UpdateAsync&lt;TDocument, TPartialDocument&gt;(TDocument, TPartialDocument, IndexName, Id, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Shared/Client/ElasticsearchClient-Manual.cs/#L23"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"></div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;UpdateResponse&lt;TDocument&gt;&gt; UpdateAsync&lt;TDocument, TPartialDocument&gt;(TDocument document, TPartialDocument partialDocument, IndexName index, Id id, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>partialDocument</code> <span class="xref">TPartialDocument</span></dt>
    <dd></dd>
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.UpdateResponse-1.html">UpdateResponse</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
    <dt><code>TPartialDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_UpdateAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.UpdateAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_UpdateAsync__2___0___1_System_Action_Elastic_Clients_Elasticsearch_UpdateRequestDescriptor___0___1___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.UpdateAsync``2(``0,``1,System.Action{Elastic.Clients.Elasticsearch.UpdateRequestDescriptor{``0,``1}},System.Threading.CancellationToken)">
  UpdateAsync&lt;TDocument, TPartialDocument&gt;(TDocument, TPartialDocument, Action&lt;UpdateRequestDescriptor&lt;TDocument, TPartialDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Shared/Client/ElasticsearchClient-Manual.cs/#L32"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"></div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;UpdateResponse&lt;TDocument&gt;&gt; UpdateAsync&lt;TDocument, TPartialDocument&gt;(TDocument document, TPartialDocument partialDocument, Action&lt;UpdateRequestDescriptor&lt;TDocument, TPartialDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>partialDocument</code> <span class="xref">TPartialDocument</span></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.UpdateRequestDescriptor-2.html">UpdateRequestDescriptor</a>&lt;TDocument, TPartialDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.UpdateResponse-1.html">UpdateResponse</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
    <dt><code>TPartialDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_UpdateByQuery_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.UpdateByQuery*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_UpdateByQuery_Elastic_Clients_Elasticsearch_Indices_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.UpdateByQuery(Elastic.Clients.Elasticsearch.Indices)">
  UpdateByQuery(Indices)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L41103"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Update documents.
Updates documents that match the specified query.
If no query is specified, performs an update on every document in the data stream or index without modifying the source, which is useful for picking up mapping changes.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or alias:
</p>
<ul><li>
<p>
<code>read</code>
</p>
</li><li>
<p>
<code>index</code> or <code>write</code>
</p>
</li></ul>
<p>
You can specify the query criteria in the request URI or the request body using the same syntax as the search API.
</p>
<p>
When you submit an update by query request, Elasticsearch gets a snapshot of the data stream or index when it begins processing the request and updates matching documents using internal versioning.
When the versions match, the document is updated and the version number is incremented.
If a document changes between the time that the snapshot is taken and the update operation is processed, it results in a version conflict and the operation fails.
You can opt to count version conflicts instead of halting and returning by setting <code>conflicts</code> to <code>proceed</code>.
Note that if you opt to count version conflicts, the operation could attempt to update more documents from the source than <code>max_docs</code> until it has successfully updated <code>max_docs</code> documents or it has gone through every document in the source query.
</p>
<p>
NOTE: Documents with a version equal to 0 cannot be updated using update by query because internal versioning does not support 0 as a valid version number.
</p>
<p>
While processing an update by query request, Elasticsearch performs multiple search requests sequentially to find all of the matching documents.
A bulk update request is performed for each batch of matching documents.
Any query or update failures cause the update by query request to fail and the failures are shown in the response.
Any update requests that completed successfully still stick, they are not rolled back.
</p>
<p>
<strong>Throttling update requests</strong>
</p>
<p>
To control the rate at which update by query issues batches of update operations, you can set <code>requests_per_second</code> to any positive decimal number.
This pads each batch with a wait time to throttle the rate.
Set <code>requests_per_second</code> to <code>-1</code> to turn off throttling.
</p>
<p>
Throttling uses a wait time between batches so that the internal scroll requests can be given a timeout that takes the request padding into account.
The padding time is the difference between the batch size divided by the <code>requests_per_second</code> and the time spent writing.
By default the batch size is 1000, so if <code>requests_per_second</code> is set to <code>500</code>:
</p>
<pre><code class="lang-csharp">target_time = 1000 / 500 per second = 2 seconds
wait_time = target_time - write_time = 2 seconds - .5 seconds = 1.5 seconds</code></pre>
<p>
Since the batch is issued as a single _bulk request, large batch sizes cause Elasticsearch to create many requests and wait before starting the next set.
This is "bursty" instead of "smooth".
</p>
<p>
<strong>Slicing</strong>
</p>
<p>
Update by query supports sliced scroll to parallelize the update process.
This can improve efficiency and provide a convenient way to break the request down into smaller parts.
</p>
<p>
Setting <code>slices</code> to <code>auto</code> chooses a reasonable number for most data streams and indices.
This setting will use one slice per shard, up to a certain limit.
If there are multiple source data streams or indices, it will choose the number of slices based on the index or backing index with the smallest number of shards.
</p>
<p>
Adding <code>slices</code> to <code>_update_by_query</code> just automates the manual process of creating sub-requests, which means it has some quirks:
</p>
<ul><li>
<p>
You can see these requests in the tasks APIs. These sub-requests are "child" tasks of the task for the request with slices.
</p>
</li><li>
<p>
Fetching the status of the task for the request with <code>slices</code> only contains the status of completed slices.
</p>
</li><li>
<p>
These sub-requests are individually addressable for things like cancellation and rethrottling.
</p>
</li><li>
<p>
Rethrottling the request with <code>slices</code> will rethrottle the unfinished sub-request proportionally.
</p>
</li><li>
<p>
Canceling the request with slices will cancel each sub-request.
</p>
</li><li>
<p>
Due to the nature of slices each sub-request won't get a perfectly even portion of the documents. All documents will be addressed, but some slices may be larger than others. Expect larger slices to have a more even distribution.
</p>
</li><li>
<p>
Parameters like <code>requests_per_second</code> and <code>max_docs</code> on a request with slices are distributed proportionally to each sub-request. Combine that with the point above about distribution being uneven and you should conclude that using <code>max_docs</code> with <code>slices</code> might not result in exactly <code>max_docs</code> documents being updated.
</p>
</li><li>
<p>
Each sub-request gets a slightly different snapshot of the source data stream or index though these are all taken at approximately the same time.
</p>
</li></ul>
<p>
If you're slicing manually or otherwise tuning automatic slicing, keep in mind that:
</p>
<ul><li>
<p>
Query performance is most efficient when the number of slices is equal to the number of shards in the index or backing index. If that number is large (for example, 500), choose a lower number as too many slices hurts performance. Setting slices higher than the number of shards generally does not improve efficiency and adds overhead.
</p>
</li><li>
<p>
Update performance scales linearly across available resources with the number of slices.
</p>
</li></ul>
<p>
Whether query or update performance dominates the runtime depends on the documents being reindexed and cluster resources.
</p>
<p>
<strong>Update the document source</strong>
</p>
<p>
Update by query supports scripts to update the document source.
As with the update API, you can set <code>ctx.op</code> to change the operation that is performed.
</p>
<p>
Set <code>ctx.op = "noop"</code> if your script decides that it doesn't have to make any changes.
The update by query operation skips updating the document and increments the <code>noop</code> counter.
</p>
<p>
Set <code>ctx.op = "delete"</code> if your script decides that the document should be deleted.
The update by query operation deletes the document and increments the <code>deleted</code> counter.
</p>
<p>
Update by query supports only <code>index</code>, <code>noop</code>, and <code>delete</code>.
Setting <code>ctx.op</code> to anything else is an error.
Setting any other field in <code>ctx</code> is an error.
This API enables you to only modify the source of matching documents; you cannot move them.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-update-by-query.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual UpdateByQueryResponse UpdateByQuery(Indices indices)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>indices</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Indices.html">Indices</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.UpdateByQueryResponse.html">UpdateByQueryResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_UpdateByQuery_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.UpdateByQuery*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_UpdateByQuery_Elastic_Clients_Elasticsearch_Indices_System_Action_Elastic_Clients_Elasticsearch_UpdateByQueryRequestDescriptor__" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.UpdateByQuery(Elastic.Clients.Elasticsearch.Indices,System.Action{Elastic.Clients.Elasticsearch.UpdateByQueryRequestDescriptor})">
  UpdateByQuery(Indices, Action&lt;UpdateByQueryRequestDescriptor&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L41270"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Update documents.
Updates documents that match the specified query.
If no query is specified, performs an update on every document in the data stream or index without modifying the source, which is useful for picking up mapping changes.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or alias:
</p>
<ul><li>
<p>
<code>read</code>
</p>
</li><li>
<p>
<code>index</code> or <code>write</code>
</p>
</li></ul>
<p>
You can specify the query criteria in the request URI or the request body using the same syntax as the search API.
</p>
<p>
When you submit an update by query request, Elasticsearch gets a snapshot of the data stream or index when it begins processing the request and updates matching documents using internal versioning.
When the versions match, the document is updated and the version number is incremented.
If a document changes between the time that the snapshot is taken and the update operation is processed, it results in a version conflict and the operation fails.
You can opt to count version conflicts instead of halting and returning by setting <code>conflicts</code> to <code>proceed</code>.
Note that if you opt to count version conflicts, the operation could attempt to update more documents from the source than <code>max_docs</code> until it has successfully updated <code>max_docs</code> documents or it has gone through every document in the source query.
</p>
<p>
NOTE: Documents with a version equal to 0 cannot be updated using update by query because internal versioning does not support 0 as a valid version number.
</p>
<p>
While processing an update by query request, Elasticsearch performs multiple search requests sequentially to find all of the matching documents.
A bulk update request is performed for each batch of matching documents.
Any query or update failures cause the update by query request to fail and the failures are shown in the response.
Any update requests that completed successfully still stick, they are not rolled back.
</p>
<p>
<strong>Throttling update requests</strong>
</p>
<p>
To control the rate at which update by query issues batches of update operations, you can set <code>requests_per_second</code> to any positive decimal number.
This pads each batch with a wait time to throttle the rate.
Set <code>requests_per_second</code> to <code>-1</code> to turn off throttling.
</p>
<p>
Throttling uses a wait time between batches so that the internal scroll requests can be given a timeout that takes the request padding into account.
The padding time is the difference between the batch size divided by the <code>requests_per_second</code> and the time spent writing.
By default the batch size is 1000, so if <code>requests_per_second</code> is set to <code>500</code>:
</p>
<pre><code class="lang-csharp">target_time = 1000 / 500 per second = 2 seconds
wait_time = target_time - write_time = 2 seconds - .5 seconds = 1.5 seconds</code></pre>
<p>
Since the batch is issued as a single _bulk request, large batch sizes cause Elasticsearch to create many requests and wait before starting the next set.
This is "bursty" instead of "smooth".
</p>
<p>
<strong>Slicing</strong>
</p>
<p>
Update by query supports sliced scroll to parallelize the update process.
This can improve efficiency and provide a convenient way to break the request down into smaller parts.
</p>
<p>
Setting <code>slices</code> to <code>auto</code> chooses a reasonable number for most data streams and indices.
This setting will use one slice per shard, up to a certain limit.
If there are multiple source data streams or indices, it will choose the number of slices based on the index or backing index with the smallest number of shards.
</p>
<p>
Adding <code>slices</code> to <code>_update_by_query</code> just automates the manual process of creating sub-requests, which means it has some quirks:
</p>
<ul><li>
<p>
You can see these requests in the tasks APIs. These sub-requests are "child" tasks of the task for the request with slices.
</p>
</li><li>
<p>
Fetching the status of the task for the request with <code>slices</code> only contains the status of completed slices.
</p>
</li><li>
<p>
These sub-requests are individually addressable for things like cancellation and rethrottling.
</p>
</li><li>
<p>
Rethrottling the request with <code>slices</code> will rethrottle the unfinished sub-request proportionally.
</p>
</li><li>
<p>
Canceling the request with slices will cancel each sub-request.
</p>
</li><li>
<p>
Due to the nature of slices each sub-request won't get a perfectly even portion of the documents. All documents will be addressed, but some slices may be larger than others. Expect larger slices to have a more even distribution.
</p>
</li><li>
<p>
Parameters like <code>requests_per_second</code> and <code>max_docs</code> on a request with slices are distributed proportionally to each sub-request. Combine that with the point above about distribution being uneven and you should conclude that using <code>max_docs</code> with <code>slices</code> might not result in exactly <code>max_docs</code> documents being updated.
</p>
</li><li>
<p>
Each sub-request gets a slightly different snapshot of the source data stream or index though these are all taken at approximately the same time.
</p>
</li></ul>
<p>
If you're slicing manually or otherwise tuning automatic slicing, keep in mind that:
</p>
<ul><li>
<p>
Query performance is most efficient when the number of slices is equal to the number of shards in the index or backing index. If that number is large (for example, 500), choose a lower number as too many slices hurts performance. Setting slices higher than the number of shards generally does not improve efficiency and adds overhead.
</p>
</li><li>
<p>
Update performance scales linearly across available resources with the number of slices.
</p>
</li></ul>
<p>
Whether query or update performance dominates the runtime depends on the documents being reindexed and cluster resources.
</p>
<p>
<strong>Update the document source</strong>
</p>
<p>
Update by query supports scripts to update the document source.
As with the update API, you can set <code>ctx.op</code> to change the operation that is performed.
</p>
<p>
Set <code>ctx.op = "noop"</code> if your script decides that it doesn't have to make any changes.
The update by query operation skips updating the document and increments the <code>noop</code> counter.
</p>
<p>
Set <code>ctx.op = "delete"</code> if your script decides that the document should be deleted.
The update by query operation deletes the document and increments the <code>deleted</code> counter.
</p>
<p>
Update by query supports only <code>index</code>, <code>noop</code>, and <code>delete</code>.
Setting <code>ctx.op</code> to anything else is an error.
Setting any other field in <code>ctx</code> is an error.
This API enables you to only modify the source of matching documents; you cannot move them.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-update-by-query.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual UpdateByQueryResponse UpdateByQuery(Indices indices, Action&lt;UpdateByQueryRequestDescriptor&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>indices</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Indices.html">Indices</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.UpdateByQueryRequestDescriptor.html">UpdateByQueryRequestDescriptor</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.UpdateByQueryResponse.html">UpdateByQueryResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_UpdateByQuery_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.UpdateByQuery*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_UpdateByQuery_Elastic_Clients_Elasticsearch_UpdateByQueryRequest_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.UpdateByQuery(Elastic.Clients.Elasticsearch.UpdateByQueryRequest)">
  UpdateByQuery(UpdateByQueryRequest)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L39770"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Update documents.
Updates documents that match the specified query.
If no query is specified, performs an update on every document in the data stream or index without modifying the source, which is useful for picking up mapping changes.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or alias:
</p>
<ul><li>
<p>
<code>read</code>
</p>
</li><li>
<p>
<code>index</code> or <code>write</code>
</p>
</li></ul>
<p>
You can specify the query criteria in the request URI or the request body using the same syntax as the search API.
</p>
<p>
When you submit an update by query request, Elasticsearch gets a snapshot of the data stream or index when it begins processing the request and updates matching documents using internal versioning.
When the versions match, the document is updated and the version number is incremented.
If a document changes between the time that the snapshot is taken and the update operation is processed, it results in a version conflict and the operation fails.
You can opt to count version conflicts instead of halting and returning by setting <code>conflicts</code> to <code>proceed</code>.
Note that if you opt to count version conflicts, the operation could attempt to update more documents from the source than <code>max_docs</code> until it has successfully updated <code>max_docs</code> documents or it has gone through every document in the source query.
</p>
<p>
NOTE: Documents with a version equal to 0 cannot be updated using update by query because internal versioning does not support 0 as a valid version number.
</p>
<p>
While processing an update by query request, Elasticsearch performs multiple search requests sequentially to find all of the matching documents.
A bulk update request is performed for each batch of matching documents.
Any query or update failures cause the update by query request to fail and the failures are shown in the response.
Any update requests that completed successfully still stick, they are not rolled back.
</p>
<p>
<strong>Throttling update requests</strong>
</p>
<p>
To control the rate at which update by query issues batches of update operations, you can set <code>requests_per_second</code> to any positive decimal number.
This pads each batch with a wait time to throttle the rate.
Set <code>requests_per_second</code> to <code>-1</code> to turn off throttling.
</p>
<p>
Throttling uses a wait time between batches so that the internal scroll requests can be given a timeout that takes the request padding into account.
The padding time is the difference between the batch size divided by the <code>requests_per_second</code> and the time spent writing.
By default the batch size is 1000, so if <code>requests_per_second</code> is set to <code>500</code>:
</p>
<pre><code class="lang-csharp">target_time = 1000 / 500 per second = 2 seconds
wait_time = target_time - write_time = 2 seconds - .5 seconds = 1.5 seconds</code></pre>
<p>
Since the batch is issued as a single _bulk request, large batch sizes cause Elasticsearch to create many requests and wait before starting the next set.
This is "bursty" instead of "smooth".
</p>
<p>
<strong>Slicing</strong>
</p>
<p>
Update by query supports sliced scroll to parallelize the update process.
This can improve efficiency and provide a convenient way to break the request down into smaller parts.
</p>
<p>
Setting <code>slices</code> to <code>auto</code> chooses a reasonable number for most data streams and indices.
This setting will use one slice per shard, up to a certain limit.
If there are multiple source data streams or indices, it will choose the number of slices based on the index or backing index with the smallest number of shards.
</p>
<p>
Adding <code>slices</code> to <code>_update_by_query</code> just automates the manual process of creating sub-requests, which means it has some quirks:
</p>
<ul><li>
<p>
You can see these requests in the tasks APIs. These sub-requests are "child" tasks of the task for the request with slices.
</p>
</li><li>
<p>
Fetching the status of the task for the request with <code>slices</code> only contains the status of completed slices.
</p>
</li><li>
<p>
These sub-requests are individually addressable for things like cancellation and rethrottling.
</p>
</li><li>
<p>
Rethrottling the request with <code>slices</code> will rethrottle the unfinished sub-request proportionally.
</p>
</li><li>
<p>
Canceling the request with slices will cancel each sub-request.
</p>
</li><li>
<p>
Due to the nature of slices each sub-request won't get a perfectly even portion of the documents. All documents will be addressed, but some slices may be larger than others. Expect larger slices to have a more even distribution.
</p>
</li><li>
<p>
Parameters like <code>requests_per_second</code> and <code>max_docs</code> on a request with slices are distributed proportionally to each sub-request. Combine that with the point above about distribution being uneven and you should conclude that using <code>max_docs</code> with <code>slices</code> might not result in exactly <code>max_docs</code> documents being updated.
</p>
</li><li>
<p>
Each sub-request gets a slightly different snapshot of the source data stream or index though these are all taken at approximately the same time.
</p>
</li></ul>
<p>
If you're slicing manually or otherwise tuning automatic slicing, keep in mind that:
</p>
<ul><li>
<p>
Query performance is most efficient when the number of slices is equal to the number of shards in the index or backing index. If that number is large (for example, 500), choose a lower number as too many slices hurts performance. Setting slices higher than the number of shards generally does not improve efficiency and adds overhead.
</p>
</li><li>
<p>
Update performance scales linearly across available resources with the number of slices.
</p>
</li></ul>
<p>
Whether query or update performance dominates the runtime depends on the documents being reindexed and cluster resources.
</p>
<p>
<strong>Update the document source</strong>
</p>
<p>
Update by query supports scripts to update the document source.
As with the update API, you can set <code>ctx.op</code> to change the operation that is performed.
</p>
<p>
Set <code>ctx.op = "noop"</code> if your script decides that it doesn't have to make any changes.
The update by query operation skips updating the document and increments the <code>noop</code> counter.
</p>
<p>
Set <code>ctx.op = "delete"</code> if your script decides that the document should be deleted.
The update by query operation deletes the document and increments the <code>deleted</code> counter.
</p>
<p>
Update by query supports only <code>index</code>, <code>noop</code>, and <code>delete</code>.
Setting <code>ctx.op</code> to anything else is an error.
Setting any other field in <code>ctx</code> is an error.
This API enables you to only modify the source of matching documents; you cannot move them.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-update-by-query.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual UpdateByQueryResponse UpdateByQuery(UpdateByQueryRequest request)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.UpdateByQueryRequest.html">UpdateByQueryRequest</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.UpdateByQueryResponse.html">UpdateByQueryResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_UpdateByQuery_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.UpdateByQuery*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_UpdateByQuery_Elastic_Clients_Elasticsearch_UpdateByQueryRequestDescriptor_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.UpdateByQuery(Elastic.Clients.Elasticsearch.UpdateByQueryRequestDescriptor)">
  UpdateByQuery(UpdateByQueryRequestDescriptor)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L40937"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Update documents.
Updates documents that match the specified query.
If no query is specified, performs an update on every document in the data stream or index without modifying the source, which is useful for picking up mapping changes.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or alias:
</p>
<ul><li>
<p>
<code>read</code>
</p>
</li><li>
<p>
<code>index</code> or <code>write</code>
</p>
</li></ul>
<p>
You can specify the query criteria in the request URI or the request body using the same syntax as the search API.
</p>
<p>
When you submit an update by query request, Elasticsearch gets a snapshot of the data stream or index when it begins processing the request and updates matching documents using internal versioning.
When the versions match, the document is updated and the version number is incremented.
If a document changes between the time that the snapshot is taken and the update operation is processed, it results in a version conflict and the operation fails.
You can opt to count version conflicts instead of halting and returning by setting <code>conflicts</code> to <code>proceed</code>.
Note that if you opt to count version conflicts, the operation could attempt to update more documents from the source than <code>max_docs</code> until it has successfully updated <code>max_docs</code> documents or it has gone through every document in the source query.
</p>
<p>
NOTE: Documents with a version equal to 0 cannot be updated using update by query because internal versioning does not support 0 as a valid version number.
</p>
<p>
While processing an update by query request, Elasticsearch performs multiple search requests sequentially to find all of the matching documents.
A bulk update request is performed for each batch of matching documents.
Any query or update failures cause the update by query request to fail and the failures are shown in the response.
Any update requests that completed successfully still stick, they are not rolled back.
</p>
<p>
<strong>Throttling update requests</strong>
</p>
<p>
To control the rate at which update by query issues batches of update operations, you can set <code>requests_per_second</code> to any positive decimal number.
This pads each batch with a wait time to throttle the rate.
Set <code>requests_per_second</code> to <code>-1</code> to turn off throttling.
</p>
<p>
Throttling uses a wait time between batches so that the internal scroll requests can be given a timeout that takes the request padding into account.
The padding time is the difference between the batch size divided by the <code>requests_per_second</code> and the time spent writing.
By default the batch size is 1000, so if <code>requests_per_second</code> is set to <code>500</code>:
</p>
<pre><code class="lang-csharp">target_time = 1000 / 500 per second = 2 seconds
wait_time = target_time - write_time = 2 seconds - .5 seconds = 1.5 seconds</code></pre>
<p>
Since the batch is issued as a single _bulk request, large batch sizes cause Elasticsearch to create many requests and wait before starting the next set.
This is "bursty" instead of "smooth".
</p>
<p>
<strong>Slicing</strong>
</p>
<p>
Update by query supports sliced scroll to parallelize the update process.
This can improve efficiency and provide a convenient way to break the request down into smaller parts.
</p>
<p>
Setting <code>slices</code> to <code>auto</code> chooses a reasonable number for most data streams and indices.
This setting will use one slice per shard, up to a certain limit.
If there are multiple source data streams or indices, it will choose the number of slices based on the index or backing index with the smallest number of shards.
</p>
<p>
Adding <code>slices</code> to <code>_update_by_query</code> just automates the manual process of creating sub-requests, which means it has some quirks:
</p>
<ul><li>
<p>
You can see these requests in the tasks APIs. These sub-requests are "child" tasks of the task for the request with slices.
</p>
</li><li>
<p>
Fetching the status of the task for the request with <code>slices</code> only contains the status of completed slices.
</p>
</li><li>
<p>
These sub-requests are individually addressable for things like cancellation and rethrottling.
</p>
</li><li>
<p>
Rethrottling the request with <code>slices</code> will rethrottle the unfinished sub-request proportionally.
</p>
</li><li>
<p>
Canceling the request with slices will cancel each sub-request.
</p>
</li><li>
<p>
Due to the nature of slices each sub-request won't get a perfectly even portion of the documents. All documents will be addressed, but some slices may be larger than others. Expect larger slices to have a more even distribution.
</p>
</li><li>
<p>
Parameters like <code>requests_per_second</code> and <code>max_docs</code> on a request with slices are distributed proportionally to each sub-request. Combine that with the point above about distribution being uneven and you should conclude that using <code>max_docs</code> with <code>slices</code> might not result in exactly <code>max_docs</code> documents being updated.
</p>
</li><li>
<p>
Each sub-request gets a slightly different snapshot of the source data stream or index though these are all taken at approximately the same time.
</p>
</li></ul>
<p>
If you're slicing manually or otherwise tuning automatic slicing, keep in mind that:
</p>
<ul><li>
<p>
Query performance is most efficient when the number of slices is equal to the number of shards in the index or backing index. If that number is large (for example, 500), choose a lower number as too many slices hurts performance. Setting slices higher than the number of shards generally does not improve efficiency and adds overhead.
</p>
</li><li>
<p>
Update performance scales linearly across available resources with the number of slices.
</p>
</li></ul>
<p>
Whether query or update performance dominates the runtime depends on the documents being reindexed and cluster resources.
</p>
<p>
<strong>Update the document source</strong>
</p>
<p>
Update by query supports scripts to update the document source.
As with the update API, you can set <code>ctx.op</code> to change the operation that is performed.
</p>
<p>
Set <code>ctx.op = "noop"</code> if your script decides that it doesn't have to make any changes.
The update by query operation skips updating the document and increments the <code>noop</code> counter.
</p>
<p>
Set <code>ctx.op = "delete"</code> if your script decides that the document should be deleted.
The update by query operation deletes the document and increments the <code>deleted</code> counter.
</p>
<p>
Update by query supports only <code>index</code>, <code>noop</code>, and <code>delete</code>.
Setting <code>ctx.op</code> to anything else is an error.
Setting any other field in <code>ctx</code> is an error.
This API enables you to only modify the source of matching documents; you cannot move them.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-update-by-query.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual UpdateByQueryResponse UpdateByQuery(UpdateByQueryRequestDescriptor descriptor)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.UpdateByQueryRequestDescriptor.html">UpdateByQueryRequestDescriptor</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.UpdateByQueryResponse.html">UpdateByQueryResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_UpdateByQueryAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.UpdateByQueryAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_UpdateByQueryAsync_Elastic_Clients_Elasticsearch_Indices_System_Action_Elastic_Clients_Elasticsearch_UpdateByQueryRequestDescriptor__System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.UpdateByQueryAsync(Elastic.Clients.Elasticsearch.Indices,System.Action{Elastic.Clients.Elasticsearch.UpdateByQueryRequestDescriptor},System.Threading.CancellationToken)">
  UpdateByQueryAsync(Indices, Action&lt;UpdateByQueryRequestDescriptor&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L42600"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Update documents.
Updates documents that match the specified query.
If no query is specified, performs an update on every document in the data stream or index without modifying the source, which is useful for picking up mapping changes.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or alias:
</p>
<ul><li>
<p>
<code>read</code>
</p>
</li><li>
<p>
<code>index</code> or <code>write</code>
</p>
</li></ul>
<p>
You can specify the query criteria in the request URI or the request body using the same syntax as the search API.
</p>
<p>
When you submit an update by query request, Elasticsearch gets a snapshot of the data stream or index when it begins processing the request and updates matching documents using internal versioning.
When the versions match, the document is updated and the version number is incremented.
If a document changes between the time that the snapshot is taken and the update operation is processed, it results in a version conflict and the operation fails.
You can opt to count version conflicts instead of halting and returning by setting <code>conflicts</code> to <code>proceed</code>.
Note that if you opt to count version conflicts, the operation could attempt to update more documents from the source than <code>max_docs</code> until it has successfully updated <code>max_docs</code> documents or it has gone through every document in the source query.
</p>
<p>
NOTE: Documents with a version equal to 0 cannot be updated using update by query because internal versioning does not support 0 as a valid version number.
</p>
<p>
While processing an update by query request, Elasticsearch performs multiple search requests sequentially to find all of the matching documents.
A bulk update request is performed for each batch of matching documents.
Any query or update failures cause the update by query request to fail and the failures are shown in the response.
Any update requests that completed successfully still stick, they are not rolled back.
</p>
<p>
<strong>Throttling update requests</strong>
</p>
<p>
To control the rate at which update by query issues batches of update operations, you can set <code>requests_per_second</code> to any positive decimal number.
This pads each batch with a wait time to throttle the rate.
Set <code>requests_per_second</code> to <code>-1</code> to turn off throttling.
</p>
<p>
Throttling uses a wait time between batches so that the internal scroll requests can be given a timeout that takes the request padding into account.
The padding time is the difference between the batch size divided by the <code>requests_per_second</code> and the time spent writing.
By default the batch size is 1000, so if <code>requests_per_second</code> is set to <code>500</code>:
</p>
<pre><code class="lang-csharp">target_time = 1000 / 500 per second = 2 seconds
wait_time = target_time - write_time = 2 seconds - .5 seconds = 1.5 seconds</code></pre>
<p>
Since the batch is issued as a single _bulk request, large batch sizes cause Elasticsearch to create many requests and wait before starting the next set.
This is "bursty" instead of "smooth".
</p>
<p>
<strong>Slicing</strong>
</p>
<p>
Update by query supports sliced scroll to parallelize the update process.
This can improve efficiency and provide a convenient way to break the request down into smaller parts.
</p>
<p>
Setting <code>slices</code> to <code>auto</code> chooses a reasonable number for most data streams and indices.
This setting will use one slice per shard, up to a certain limit.
If there are multiple source data streams or indices, it will choose the number of slices based on the index or backing index with the smallest number of shards.
</p>
<p>
Adding <code>slices</code> to <code>_update_by_query</code> just automates the manual process of creating sub-requests, which means it has some quirks:
</p>
<ul><li>
<p>
You can see these requests in the tasks APIs. These sub-requests are "child" tasks of the task for the request with slices.
</p>
</li><li>
<p>
Fetching the status of the task for the request with <code>slices</code> only contains the status of completed slices.
</p>
</li><li>
<p>
These sub-requests are individually addressable for things like cancellation and rethrottling.
</p>
</li><li>
<p>
Rethrottling the request with <code>slices</code> will rethrottle the unfinished sub-request proportionally.
</p>
</li><li>
<p>
Canceling the request with slices will cancel each sub-request.
</p>
</li><li>
<p>
Due to the nature of slices each sub-request won't get a perfectly even portion of the documents. All documents will be addressed, but some slices may be larger than others. Expect larger slices to have a more even distribution.
</p>
</li><li>
<p>
Parameters like <code>requests_per_second</code> and <code>max_docs</code> on a request with slices are distributed proportionally to each sub-request. Combine that with the point above about distribution being uneven and you should conclude that using <code>max_docs</code> with <code>slices</code> might not result in exactly <code>max_docs</code> documents being updated.
</p>
</li><li>
<p>
Each sub-request gets a slightly different snapshot of the source data stream or index though these are all taken at approximately the same time.
</p>
</li></ul>
<p>
If you're slicing manually or otherwise tuning automatic slicing, keep in mind that:
</p>
<ul><li>
<p>
Query performance is most efficient when the number of slices is equal to the number of shards in the index or backing index. If that number is large (for example, 500), choose a lower number as too many slices hurts performance. Setting slices higher than the number of shards generally does not improve efficiency and adds overhead.
</p>
</li><li>
<p>
Update performance scales linearly across available resources with the number of slices.
</p>
</li></ul>
<p>
Whether query or update performance dominates the runtime depends on the documents being reindexed and cluster resources.
</p>
<p>
<strong>Update the document source</strong>
</p>
<p>
Update by query supports scripts to update the document source.
As with the update API, you can set <code>ctx.op</code> to change the operation that is performed.
</p>
<p>
Set <code>ctx.op = "noop"</code> if your script decides that it doesn't have to make any changes.
The update by query operation skips updating the document and increments the <code>noop</code> counter.
</p>
<p>
Set <code>ctx.op = "delete"</code> if your script decides that the document should be deleted.
The update by query operation deletes the document and increments the <code>deleted</code> counter.
</p>
<p>
Update by query supports only <code>index</code>, <code>noop</code>, and <code>delete</code>.
Setting <code>ctx.op</code> to anything else is an error.
Setting any other field in <code>ctx</code> is an error.
This API enables you to only modify the source of matching documents; you cannot move them.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-update-by-query.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;UpdateByQueryResponse&gt; UpdateByQueryAsync(Indices indices, Action&lt;UpdateByQueryRequestDescriptor&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>indices</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Indices.html">Indices</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.UpdateByQueryRequestDescriptor.html">UpdateByQueryRequestDescriptor</a>&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.UpdateByQueryResponse.html">UpdateByQueryResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_UpdateByQueryAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.UpdateByQueryAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_UpdateByQueryAsync_Elastic_Clients_Elasticsearch_Indices_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.UpdateByQueryAsync(Elastic.Clients.Elasticsearch.Indices,System.Threading.CancellationToken)">
  UpdateByQueryAsync(Indices, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L42434"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Update documents.
Updates documents that match the specified query.
If no query is specified, performs an update on every document in the data stream or index without modifying the source, which is useful for picking up mapping changes.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or alias:
</p>
<ul><li>
<p>
<code>read</code>
</p>
</li><li>
<p>
<code>index</code> or <code>write</code>
</p>
</li></ul>
<p>
You can specify the query criteria in the request URI or the request body using the same syntax as the search API.
</p>
<p>
When you submit an update by query request, Elasticsearch gets a snapshot of the data stream or index when it begins processing the request and updates matching documents using internal versioning.
When the versions match, the document is updated and the version number is incremented.
If a document changes between the time that the snapshot is taken and the update operation is processed, it results in a version conflict and the operation fails.
You can opt to count version conflicts instead of halting and returning by setting <code>conflicts</code> to <code>proceed</code>.
Note that if you opt to count version conflicts, the operation could attempt to update more documents from the source than <code>max_docs</code> until it has successfully updated <code>max_docs</code> documents or it has gone through every document in the source query.
</p>
<p>
NOTE: Documents with a version equal to 0 cannot be updated using update by query because internal versioning does not support 0 as a valid version number.
</p>
<p>
While processing an update by query request, Elasticsearch performs multiple search requests sequentially to find all of the matching documents.
A bulk update request is performed for each batch of matching documents.
Any query or update failures cause the update by query request to fail and the failures are shown in the response.
Any update requests that completed successfully still stick, they are not rolled back.
</p>
<p>
<strong>Throttling update requests</strong>
</p>
<p>
To control the rate at which update by query issues batches of update operations, you can set <code>requests_per_second</code> to any positive decimal number.
This pads each batch with a wait time to throttle the rate.
Set <code>requests_per_second</code> to <code>-1</code> to turn off throttling.
</p>
<p>
Throttling uses a wait time between batches so that the internal scroll requests can be given a timeout that takes the request padding into account.
The padding time is the difference between the batch size divided by the <code>requests_per_second</code> and the time spent writing.
By default the batch size is 1000, so if <code>requests_per_second</code> is set to <code>500</code>:
</p>
<pre><code class="lang-csharp">target_time = 1000 / 500 per second = 2 seconds
wait_time = target_time - write_time = 2 seconds - .5 seconds = 1.5 seconds</code></pre>
<p>
Since the batch is issued as a single _bulk request, large batch sizes cause Elasticsearch to create many requests and wait before starting the next set.
This is "bursty" instead of "smooth".
</p>
<p>
<strong>Slicing</strong>
</p>
<p>
Update by query supports sliced scroll to parallelize the update process.
This can improve efficiency and provide a convenient way to break the request down into smaller parts.
</p>
<p>
Setting <code>slices</code> to <code>auto</code> chooses a reasonable number for most data streams and indices.
This setting will use one slice per shard, up to a certain limit.
If there are multiple source data streams or indices, it will choose the number of slices based on the index or backing index with the smallest number of shards.
</p>
<p>
Adding <code>slices</code> to <code>_update_by_query</code> just automates the manual process of creating sub-requests, which means it has some quirks:
</p>
<ul><li>
<p>
You can see these requests in the tasks APIs. These sub-requests are "child" tasks of the task for the request with slices.
</p>
</li><li>
<p>
Fetching the status of the task for the request with <code>slices</code> only contains the status of completed slices.
</p>
</li><li>
<p>
These sub-requests are individually addressable for things like cancellation and rethrottling.
</p>
</li><li>
<p>
Rethrottling the request with <code>slices</code> will rethrottle the unfinished sub-request proportionally.
</p>
</li><li>
<p>
Canceling the request with slices will cancel each sub-request.
</p>
</li><li>
<p>
Due to the nature of slices each sub-request won't get a perfectly even portion of the documents. All documents will be addressed, but some slices may be larger than others. Expect larger slices to have a more even distribution.
</p>
</li><li>
<p>
Parameters like <code>requests_per_second</code> and <code>max_docs</code> on a request with slices are distributed proportionally to each sub-request. Combine that with the point above about distribution being uneven and you should conclude that using <code>max_docs</code> with <code>slices</code> might not result in exactly <code>max_docs</code> documents being updated.
</p>
</li><li>
<p>
Each sub-request gets a slightly different snapshot of the source data stream or index though these are all taken at approximately the same time.
</p>
</li></ul>
<p>
If you're slicing manually or otherwise tuning automatic slicing, keep in mind that:
</p>
<ul><li>
<p>
Query performance is most efficient when the number of slices is equal to the number of shards in the index or backing index. If that number is large (for example, 500), choose a lower number as too many slices hurts performance. Setting slices higher than the number of shards generally does not improve efficiency and adds overhead.
</p>
</li><li>
<p>
Update performance scales linearly across available resources with the number of slices.
</p>
</li></ul>
<p>
Whether query or update performance dominates the runtime depends on the documents being reindexed and cluster resources.
</p>
<p>
<strong>Update the document source</strong>
</p>
<p>
Update by query supports scripts to update the document source.
As with the update API, you can set <code>ctx.op</code> to change the operation that is performed.
</p>
<p>
Set <code>ctx.op = "noop"</code> if your script decides that it doesn't have to make any changes.
The update by query operation skips updating the document and increments the <code>noop</code> counter.
</p>
<p>
Set <code>ctx.op = "delete"</code> if your script decides that the document should be deleted.
The update by query operation deletes the document and increments the <code>deleted</code> counter.
</p>
<p>
Update by query supports only <code>index</code>, <code>noop</code>, and <code>delete</code>.
Setting <code>ctx.op</code> to anything else is an error.
Setting any other field in <code>ctx</code> is an error.
This API enables you to only modify the source of matching documents; you cannot move them.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-update-by-query.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;UpdateByQueryResponse&gt; UpdateByQueryAsync(Indices indices, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>indices</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Indices.html">Indices</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.UpdateByQueryResponse.html">UpdateByQueryResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_UpdateByQueryAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.UpdateByQueryAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_UpdateByQueryAsync_Elastic_Clients_Elasticsearch_UpdateByQueryRequest_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.UpdateByQueryAsync(Elastic.Clients.Elasticsearch.UpdateByQueryRequest,System.Threading.CancellationToken)">
  UpdateByQueryAsync(UpdateByQueryRequest, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L39936"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Update documents.
Updates documents that match the specified query.
If no query is specified, performs an update on every document in the data stream or index without modifying the source, which is useful for picking up mapping changes.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or alias:
</p>
<ul><li>
<p>
<code>read</code>
</p>
</li><li>
<p>
<code>index</code> or <code>write</code>
</p>
</li></ul>
<p>
You can specify the query criteria in the request URI or the request body using the same syntax as the search API.
</p>
<p>
When you submit an update by query request, Elasticsearch gets a snapshot of the data stream or index when it begins processing the request and updates matching documents using internal versioning.
When the versions match, the document is updated and the version number is incremented.
If a document changes between the time that the snapshot is taken and the update operation is processed, it results in a version conflict and the operation fails.
You can opt to count version conflicts instead of halting and returning by setting <code>conflicts</code> to <code>proceed</code>.
Note that if you opt to count version conflicts, the operation could attempt to update more documents from the source than <code>max_docs</code> until it has successfully updated <code>max_docs</code> documents or it has gone through every document in the source query.
</p>
<p>
NOTE: Documents with a version equal to 0 cannot be updated using update by query because internal versioning does not support 0 as a valid version number.
</p>
<p>
While processing an update by query request, Elasticsearch performs multiple search requests sequentially to find all of the matching documents.
A bulk update request is performed for each batch of matching documents.
Any query or update failures cause the update by query request to fail and the failures are shown in the response.
Any update requests that completed successfully still stick, they are not rolled back.
</p>
<p>
<strong>Throttling update requests</strong>
</p>
<p>
To control the rate at which update by query issues batches of update operations, you can set <code>requests_per_second</code> to any positive decimal number.
This pads each batch with a wait time to throttle the rate.
Set <code>requests_per_second</code> to <code>-1</code> to turn off throttling.
</p>
<p>
Throttling uses a wait time between batches so that the internal scroll requests can be given a timeout that takes the request padding into account.
The padding time is the difference between the batch size divided by the <code>requests_per_second</code> and the time spent writing.
By default the batch size is 1000, so if <code>requests_per_second</code> is set to <code>500</code>:
</p>
<pre><code class="lang-csharp">target_time = 1000 / 500 per second = 2 seconds
wait_time = target_time - write_time = 2 seconds - .5 seconds = 1.5 seconds</code></pre>
<p>
Since the batch is issued as a single _bulk request, large batch sizes cause Elasticsearch to create many requests and wait before starting the next set.
This is "bursty" instead of "smooth".
</p>
<p>
<strong>Slicing</strong>
</p>
<p>
Update by query supports sliced scroll to parallelize the update process.
This can improve efficiency and provide a convenient way to break the request down into smaller parts.
</p>
<p>
Setting <code>slices</code> to <code>auto</code> chooses a reasonable number for most data streams and indices.
This setting will use one slice per shard, up to a certain limit.
If there are multiple source data streams or indices, it will choose the number of slices based on the index or backing index with the smallest number of shards.
</p>
<p>
Adding <code>slices</code> to <code>_update_by_query</code> just automates the manual process of creating sub-requests, which means it has some quirks:
</p>
<ul><li>
<p>
You can see these requests in the tasks APIs. These sub-requests are "child" tasks of the task for the request with slices.
</p>
</li><li>
<p>
Fetching the status of the task for the request with <code>slices</code> only contains the status of completed slices.
</p>
</li><li>
<p>
These sub-requests are individually addressable for things like cancellation and rethrottling.
</p>
</li><li>
<p>
Rethrottling the request with <code>slices</code> will rethrottle the unfinished sub-request proportionally.
</p>
</li><li>
<p>
Canceling the request with slices will cancel each sub-request.
</p>
</li><li>
<p>
Due to the nature of slices each sub-request won't get a perfectly even portion of the documents. All documents will be addressed, but some slices may be larger than others. Expect larger slices to have a more even distribution.
</p>
</li><li>
<p>
Parameters like <code>requests_per_second</code> and <code>max_docs</code> on a request with slices are distributed proportionally to each sub-request. Combine that with the point above about distribution being uneven and you should conclude that using <code>max_docs</code> with <code>slices</code> might not result in exactly <code>max_docs</code> documents being updated.
</p>
</li><li>
<p>
Each sub-request gets a slightly different snapshot of the source data stream or index though these are all taken at approximately the same time.
</p>
</li></ul>
<p>
If you're slicing manually or otherwise tuning automatic slicing, keep in mind that:
</p>
<ul><li>
<p>
Query performance is most efficient when the number of slices is equal to the number of shards in the index or backing index. If that number is large (for example, 500), choose a lower number as too many slices hurts performance. Setting slices higher than the number of shards generally does not improve efficiency and adds overhead.
</p>
</li><li>
<p>
Update performance scales linearly across available resources with the number of slices.
</p>
</li></ul>
<p>
Whether query or update performance dominates the runtime depends on the documents being reindexed and cluster resources.
</p>
<p>
<strong>Update the document source</strong>
</p>
<p>
Update by query supports scripts to update the document source.
As with the update API, you can set <code>ctx.op</code> to change the operation that is performed.
</p>
<p>
Set <code>ctx.op = "noop"</code> if your script decides that it doesn't have to make any changes.
The update by query operation skips updating the document and increments the <code>noop</code> counter.
</p>
<p>
Set <code>ctx.op = "delete"</code> if your script decides that the document should be deleted.
The update by query operation deletes the document and increments the <code>deleted</code> counter.
</p>
<p>
Update by query supports only <code>index</code>, <code>noop</code>, and <code>delete</code>.
Setting <code>ctx.op</code> to anything else is an error.
Setting any other field in <code>ctx</code> is an error.
This API enables you to only modify the source of matching documents; you cannot move them.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-update-by-query.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;UpdateByQueryResponse&gt; UpdateByQueryAsync(UpdateByQueryRequest request, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.UpdateByQueryRequest.html">UpdateByQueryRequest</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.UpdateByQueryResponse.html">UpdateByQueryResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_UpdateByQueryAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.UpdateByQueryAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_UpdateByQueryAsync_Elastic_Clients_Elasticsearch_UpdateByQueryRequestDescriptor_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.UpdateByQueryAsync(Elastic.Clients.Elasticsearch.UpdateByQueryRequestDescriptor,System.Threading.CancellationToken)">
  UpdateByQueryAsync(UpdateByQueryRequestDescriptor, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L42269"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Update documents.
Updates documents that match the specified query.
If no query is specified, performs an update on every document in the data stream or index without modifying the source, which is useful for picking up mapping changes.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or alias:
</p>
<ul><li>
<p>
<code>read</code>
</p>
</li><li>
<p>
<code>index</code> or <code>write</code>
</p>
</li></ul>
<p>
You can specify the query criteria in the request URI or the request body using the same syntax as the search API.
</p>
<p>
When you submit an update by query request, Elasticsearch gets a snapshot of the data stream or index when it begins processing the request and updates matching documents using internal versioning.
When the versions match, the document is updated and the version number is incremented.
If a document changes between the time that the snapshot is taken and the update operation is processed, it results in a version conflict and the operation fails.
You can opt to count version conflicts instead of halting and returning by setting <code>conflicts</code> to <code>proceed</code>.
Note that if you opt to count version conflicts, the operation could attempt to update more documents from the source than <code>max_docs</code> until it has successfully updated <code>max_docs</code> documents or it has gone through every document in the source query.
</p>
<p>
NOTE: Documents with a version equal to 0 cannot be updated using update by query because internal versioning does not support 0 as a valid version number.
</p>
<p>
While processing an update by query request, Elasticsearch performs multiple search requests sequentially to find all of the matching documents.
A bulk update request is performed for each batch of matching documents.
Any query or update failures cause the update by query request to fail and the failures are shown in the response.
Any update requests that completed successfully still stick, they are not rolled back.
</p>
<p>
<strong>Throttling update requests</strong>
</p>
<p>
To control the rate at which update by query issues batches of update operations, you can set <code>requests_per_second</code> to any positive decimal number.
This pads each batch with a wait time to throttle the rate.
Set <code>requests_per_second</code> to <code>-1</code> to turn off throttling.
</p>
<p>
Throttling uses a wait time between batches so that the internal scroll requests can be given a timeout that takes the request padding into account.
The padding time is the difference between the batch size divided by the <code>requests_per_second</code> and the time spent writing.
By default the batch size is 1000, so if <code>requests_per_second</code> is set to <code>500</code>:
</p>
<pre><code class="lang-csharp">target_time = 1000 / 500 per second = 2 seconds
wait_time = target_time - write_time = 2 seconds - .5 seconds = 1.5 seconds</code></pre>
<p>
Since the batch is issued as a single _bulk request, large batch sizes cause Elasticsearch to create many requests and wait before starting the next set.
This is "bursty" instead of "smooth".
</p>
<p>
<strong>Slicing</strong>
</p>
<p>
Update by query supports sliced scroll to parallelize the update process.
This can improve efficiency and provide a convenient way to break the request down into smaller parts.
</p>
<p>
Setting <code>slices</code> to <code>auto</code> chooses a reasonable number for most data streams and indices.
This setting will use one slice per shard, up to a certain limit.
If there are multiple source data streams or indices, it will choose the number of slices based on the index or backing index with the smallest number of shards.
</p>
<p>
Adding <code>slices</code> to <code>_update_by_query</code> just automates the manual process of creating sub-requests, which means it has some quirks:
</p>
<ul><li>
<p>
You can see these requests in the tasks APIs. These sub-requests are "child" tasks of the task for the request with slices.
</p>
</li><li>
<p>
Fetching the status of the task for the request with <code>slices</code> only contains the status of completed slices.
</p>
</li><li>
<p>
These sub-requests are individually addressable for things like cancellation and rethrottling.
</p>
</li><li>
<p>
Rethrottling the request with <code>slices</code> will rethrottle the unfinished sub-request proportionally.
</p>
</li><li>
<p>
Canceling the request with slices will cancel each sub-request.
</p>
</li><li>
<p>
Due to the nature of slices each sub-request won't get a perfectly even portion of the documents. All documents will be addressed, but some slices may be larger than others. Expect larger slices to have a more even distribution.
</p>
</li><li>
<p>
Parameters like <code>requests_per_second</code> and <code>max_docs</code> on a request with slices are distributed proportionally to each sub-request. Combine that with the point above about distribution being uneven and you should conclude that using <code>max_docs</code> with <code>slices</code> might not result in exactly <code>max_docs</code> documents being updated.
</p>
</li><li>
<p>
Each sub-request gets a slightly different snapshot of the source data stream or index though these are all taken at approximately the same time.
</p>
</li></ul>
<p>
If you're slicing manually or otherwise tuning automatic slicing, keep in mind that:
</p>
<ul><li>
<p>
Query performance is most efficient when the number of slices is equal to the number of shards in the index or backing index. If that number is large (for example, 500), choose a lower number as too many slices hurts performance. Setting slices higher than the number of shards generally does not improve efficiency and adds overhead.
</p>
</li><li>
<p>
Update performance scales linearly across available resources with the number of slices.
</p>
</li></ul>
<p>
Whether query or update performance dominates the runtime depends on the documents being reindexed and cluster resources.
</p>
<p>
<strong>Update the document source</strong>
</p>
<p>
Update by query supports scripts to update the document source.
As with the update API, you can set <code>ctx.op</code> to change the operation that is performed.
</p>
<p>
Set <code>ctx.op = "noop"</code> if your script decides that it doesn't have to make any changes.
The update by query operation skips updating the document and increments the <code>noop</code> counter.
</p>
<p>
Set <code>ctx.op = "delete"</code> if your script decides that the document should be deleted.
The update by query operation deletes the document and increments the <code>deleted</code> counter.
</p>
<p>
Update by query supports only <code>index</code>, <code>noop</code>, and <code>delete</code>.
Setting <code>ctx.op</code> to anything else is an error.
Setting any other field in <code>ctx</code> is an error.
This API enables you to only modify the source of matching documents; you cannot move them.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-update-by-query.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;UpdateByQueryResponse&gt; UpdateByQueryAsync(UpdateByQueryRequestDescriptor descriptor, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.UpdateByQueryRequestDescriptor.html">UpdateByQueryRequestDescriptor</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.UpdateByQueryResponse.html">UpdateByQueryResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_UpdateByQueryAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.UpdateByQueryAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_UpdateByQueryAsync__1_Elastic_Clients_Elasticsearch_Indices_System_Action_Elastic_Clients_Elasticsearch_UpdateByQueryRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.UpdateByQueryAsync``1(Elastic.Clients.Elasticsearch.Indices,System.Action{Elastic.Clients.Elasticsearch.UpdateByQueryRequestDescriptor{``0}},System.Threading.CancellationToken)">
  UpdateByQueryAsync&lt;TDocument&gt;(Indices, Action&lt;UpdateByQueryRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L41769"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Update documents.
Updates documents that match the specified query.
If no query is specified, performs an update on every document in the data stream or index without modifying the source, which is useful for picking up mapping changes.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or alias:
</p>
<ul><li>
<p>
<code>read</code>
</p>
</li><li>
<p>
<code>index</code> or <code>write</code>
</p>
</li></ul>
<p>
You can specify the query criteria in the request URI or the request body using the same syntax as the search API.
</p>
<p>
When you submit an update by query request, Elasticsearch gets a snapshot of the data stream or index when it begins processing the request and updates matching documents using internal versioning.
When the versions match, the document is updated and the version number is incremented.
If a document changes between the time that the snapshot is taken and the update operation is processed, it results in a version conflict and the operation fails.
You can opt to count version conflicts instead of halting and returning by setting <code>conflicts</code> to <code>proceed</code>.
Note that if you opt to count version conflicts, the operation could attempt to update more documents from the source than <code>max_docs</code> until it has successfully updated <code>max_docs</code> documents or it has gone through every document in the source query.
</p>
<p>
NOTE: Documents with a version equal to 0 cannot be updated using update by query because internal versioning does not support 0 as a valid version number.
</p>
<p>
While processing an update by query request, Elasticsearch performs multiple search requests sequentially to find all of the matching documents.
A bulk update request is performed for each batch of matching documents.
Any query or update failures cause the update by query request to fail and the failures are shown in the response.
Any update requests that completed successfully still stick, they are not rolled back.
</p>
<p>
<strong>Throttling update requests</strong>
</p>
<p>
To control the rate at which update by query issues batches of update operations, you can set <code>requests_per_second</code> to any positive decimal number.
This pads each batch with a wait time to throttle the rate.
Set <code>requests_per_second</code> to <code>-1</code> to turn off throttling.
</p>
<p>
Throttling uses a wait time between batches so that the internal scroll requests can be given a timeout that takes the request padding into account.
The padding time is the difference between the batch size divided by the <code>requests_per_second</code> and the time spent writing.
By default the batch size is 1000, so if <code>requests_per_second</code> is set to <code>500</code>:
</p>
<pre><code class="lang-csharp">target_time = 1000 / 500 per second = 2 seconds
wait_time = target_time - write_time = 2 seconds - .5 seconds = 1.5 seconds</code></pre>
<p>
Since the batch is issued as a single _bulk request, large batch sizes cause Elasticsearch to create many requests and wait before starting the next set.
This is "bursty" instead of "smooth".
</p>
<p>
<strong>Slicing</strong>
</p>
<p>
Update by query supports sliced scroll to parallelize the update process.
This can improve efficiency and provide a convenient way to break the request down into smaller parts.
</p>
<p>
Setting <code>slices</code> to <code>auto</code> chooses a reasonable number for most data streams and indices.
This setting will use one slice per shard, up to a certain limit.
If there are multiple source data streams or indices, it will choose the number of slices based on the index or backing index with the smallest number of shards.
</p>
<p>
Adding <code>slices</code> to <code>_update_by_query</code> just automates the manual process of creating sub-requests, which means it has some quirks:
</p>
<ul><li>
<p>
You can see these requests in the tasks APIs. These sub-requests are "child" tasks of the task for the request with slices.
</p>
</li><li>
<p>
Fetching the status of the task for the request with <code>slices</code> only contains the status of completed slices.
</p>
</li><li>
<p>
These sub-requests are individually addressable for things like cancellation and rethrottling.
</p>
</li><li>
<p>
Rethrottling the request with <code>slices</code> will rethrottle the unfinished sub-request proportionally.
</p>
</li><li>
<p>
Canceling the request with slices will cancel each sub-request.
</p>
</li><li>
<p>
Due to the nature of slices each sub-request won't get a perfectly even portion of the documents. All documents will be addressed, but some slices may be larger than others. Expect larger slices to have a more even distribution.
</p>
</li><li>
<p>
Parameters like <code>requests_per_second</code> and <code>max_docs</code> on a request with slices are distributed proportionally to each sub-request. Combine that with the point above about distribution being uneven and you should conclude that using <code>max_docs</code> with <code>slices</code> might not result in exactly <code>max_docs</code> documents being updated.
</p>
</li><li>
<p>
Each sub-request gets a slightly different snapshot of the source data stream or index though these are all taken at approximately the same time.
</p>
</li></ul>
<p>
If you're slicing manually or otherwise tuning automatic slicing, keep in mind that:
</p>
<ul><li>
<p>
Query performance is most efficient when the number of slices is equal to the number of shards in the index or backing index. If that number is large (for example, 500), choose a lower number as too many slices hurts performance. Setting slices higher than the number of shards generally does not improve efficiency and adds overhead.
</p>
</li><li>
<p>
Update performance scales linearly across available resources with the number of slices.
</p>
</li></ul>
<p>
Whether query or update performance dominates the runtime depends on the documents being reindexed and cluster resources.
</p>
<p>
<strong>Update the document source</strong>
</p>
<p>
Update by query supports scripts to update the document source.
As with the update API, you can set <code>ctx.op</code> to change the operation that is performed.
</p>
<p>
Set <code>ctx.op = "noop"</code> if your script decides that it doesn't have to make any changes.
The update by query operation skips updating the document and increments the <code>noop</code> counter.
</p>
<p>
Set <code>ctx.op = "delete"</code> if your script decides that the document should be deleted.
The update by query operation deletes the document and increments the <code>deleted</code> counter.
</p>
<p>
Update by query supports only <code>index</code>, <code>noop</code>, and <code>delete</code>.
Setting <code>ctx.op</code> to anything else is an error.
Setting any other field in <code>ctx</code> is an error.
This API enables you to only modify the source of matching documents; you cannot move them.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-update-by-query.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;UpdateByQueryResponse&gt; UpdateByQueryAsync&lt;TDocument&gt;(Indices indices, Action&lt;UpdateByQueryRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>indices</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Indices.html">Indices</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.UpdateByQueryRequestDescriptor-1.html">UpdateByQueryRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.UpdateByQueryResponse.html">UpdateByQueryResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_UpdateByQueryAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.UpdateByQueryAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_UpdateByQueryAsync__1_Elastic_Clients_Elasticsearch_Indices_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.UpdateByQueryAsync``1(Elastic.Clients.Elasticsearch.Indices,System.Threading.CancellationToken)">
  UpdateByQueryAsync&lt;TDocument&gt;(Indices, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L41603"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Update documents.
Updates documents that match the specified query.
If no query is specified, performs an update on every document in the data stream or index without modifying the source, which is useful for picking up mapping changes.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or alias:
</p>
<ul><li>
<p>
<code>read</code>
</p>
</li><li>
<p>
<code>index</code> or <code>write</code>
</p>
</li></ul>
<p>
You can specify the query criteria in the request URI or the request body using the same syntax as the search API.
</p>
<p>
When you submit an update by query request, Elasticsearch gets a snapshot of the data stream or index when it begins processing the request and updates matching documents using internal versioning.
When the versions match, the document is updated and the version number is incremented.
If a document changes between the time that the snapshot is taken and the update operation is processed, it results in a version conflict and the operation fails.
You can opt to count version conflicts instead of halting and returning by setting <code>conflicts</code> to <code>proceed</code>.
Note that if you opt to count version conflicts, the operation could attempt to update more documents from the source than <code>max_docs</code> until it has successfully updated <code>max_docs</code> documents or it has gone through every document in the source query.
</p>
<p>
NOTE: Documents with a version equal to 0 cannot be updated using update by query because internal versioning does not support 0 as a valid version number.
</p>
<p>
While processing an update by query request, Elasticsearch performs multiple search requests sequentially to find all of the matching documents.
A bulk update request is performed for each batch of matching documents.
Any query or update failures cause the update by query request to fail and the failures are shown in the response.
Any update requests that completed successfully still stick, they are not rolled back.
</p>
<p>
<strong>Throttling update requests</strong>
</p>
<p>
To control the rate at which update by query issues batches of update operations, you can set <code>requests_per_second</code> to any positive decimal number.
This pads each batch with a wait time to throttle the rate.
Set <code>requests_per_second</code> to <code>-1</code> to turn off throttling.
</p>
<p>
Throttling uses a wait time between batches so that the internal scroll requests can be given a timeout that takes the request padding into account.
The padding time is the difference between the batch size divided by the <code>requests_per_second</code> and the time spent writing.
By default the batch size is 1000, so if <code>requests_per_second</code> is set to <code>500</code>:
</p>
<pre><code class="lang-csharp">target_time = 1000 / 500 per second = 2 seconds
wait_time = target_time - write_time = 2 seconds - .5 seconds = 1.5 seconds</code></pre>
<p>
Since the batch is issued as a single _bulk request, large batch sizes cause Elasticsearch to create many requests and wait before starting the next set.
This is "bursty" instead of "smooth".
</p>
<p>
<strong>Slicing</strong>
</p>
<p>
Update by query supports sliced scroll to parallelize the update process.
This can improve efficiency and provide a convenient way to break the request down into smaller parts.
</p>
<p>
Setting <code>slices</code> to <code>auto</code> chooses a reasonable number for most data streams and indices.
This setting will use one slice per shard, up to a certain limit.
If there are multiple source data streams or indices, it will choose the number of slices based on the index or backing index with the smallest number of shards.
</p>
<p>
Adding <code>slices</code> to <code>_update_by_query</code> just automates the manual process of creating sub-requests, which means it has some quirks:
</p>
<ul><li>
<p>
You can see these requests in the tasks APIs. These sub-requests are "child" tasks of the task for the request with slices.
</p>
</li><li>
<p>
Fetching the status of the task for the request with <code>slices</code> only contains the status of completed slices.
</p>
</li><li>
<p>
These sub-requests are individually addressable for things like cancellation and rethrottling.
</p>
</li><li>
<p>
Rethrottling the request with <code>slices</code> will rethrottle the unfinished sub-request proportionally.
</p>
</li><li>
<p>
Canceling the request with slices will cancel each sub-request.
</p>
</li><li>
<p>
Due to the nature of slices each sub-request won't get a perfectly even portion of the documents. All documents will be addressed, but some slices may be larger than others. Expect larger slices to have a more even distribution.
</p>
</li><li>
<p>
Parameters like <code>requests_per_second</code> and <code>max_docs</code> on a request with slices are distributed proportionally to each sub-request. Combine that with the point above about distribution being uneven and you should conclude that using <code>max_docs</code> with <code>slices</code> might not result in exactly <code>max_docs</code> documents being updated.
</p>
</li><li>
<p>
Each sub-request gets a slightly different snapshot of the source data stream or index though these are all taken at approximately the same time.
</p>
</li></ul>
<p>
If you're slicing manually or otherwise tuning automatic slicing, keep in mind that:
</p>
<ul><li>
<p>
Query performance is most efficient when the number of slices is equal to the number of shards in the index or backing index. If that number is large (for example, 500), choose a lower number as too many slices hurts performance. Setting slices higher than the number of shards generally does not improve efficiency and adds overhead.
</p>
</li><li>
<p>
Update performance scales linearly across available resources with the number of slices.
</p>
</li></ul>
<p>
Whether query or update performance dominates the runtime depends on the documents being reindexed and cluster resources.
</p>
<p>
<strong>Update the document source</strong>
</p>
<p>
Update by query supports scripts to update the document source.
As with the update API, you can set <code>ctx.op</code> to change the operation that is performed.
</p>
<p>
Set <code>ctx.op = "noop"</code> if your script decides that it doesn't have to make any changes.
The update by query operation skips updating the document and increments the <code>noop</code> counter.
</p>
<p>
Set <code>ctx.op = "delete"</code> if your script decides that the document should be deleted.
The update by query operation deletes the document and increments the <code>deleted</code> counter.
</p>
<p>
Update by query supports only <code>index</code>, <code>noop</code>, and <code>delete</code>.
Setting <code>ctx.op</code> to anything else is an error.
Setting any other field in <code>ctx</code> is an error.
This API enables you to only modify the source of matching documents; you cannot move them.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-update-by-query.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;UpdateByQueryResponse&gt; UpdateByQueryAsync&lt;TDocument&gt;(Indices indices, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>indices</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Indices.html">Indices</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.UpdateByQueryResponse.html">UpdateByQueryResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_UpdateByQueryAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.UpdateByQueryAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_UpdateByQueryAsync__1_Elastic_Clients_Elasticsearch_UpdateByQueryRequestDescriptor___0__System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.UpdateByQueryAsync``1(Elastic.Clients.Elasticsearch.UpdateByQueryRequestDescriptor{``0},System.Threading.CancellationToken)">
  UpdateByQueryAsync&lt;TDocument&gt;(UpdateByQueryRequestDescriptor&lt;TDocument&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L41438"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Update documents.
Updates documents that match the specified query.
If no query is specified, performs an update on every document in the data stream or index without modifying the source, which is useful for picking up mapping changes.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or alias:
</p>
<ul><li>
<p>
<code>read</code>
</p>
</li><li>
<p>
<code>index</code> or <code>write</code>
</p>
</li></ul>
<p>
You can specify the query criteria in the request URI or the request body using the same syntax as the search API.
</p>
<p>
When you submit an update by query request, Elasticsearch gets a snapshot of the data stream or index when it begins processing the request and updates matching documents using internal versioning.
When the versions match, the document is updated and the version number is incremented.
If a document changes between the time that the snapshot is taken and the update operation is processed, it results in a version conflict and the operation fails.
You can opt to count version conflicts instead of halting and returning by setting <code>conflicts</code> to <code>proceed</code>.
Note that if you opt to count version conflicts, the operation could attempt to update more documents from the source than <code>max_docs</code> until it has successfully updated <code>max_docs</code> documents or it has gone through every document in the source query.
</p>
<p>
NOTE: Documents with a version equal to 0 cannot be updated using update by query because internal versioning does not support 0 as a valid version number.
</p>
<p>
While processing an update by query request, Elasticsearch performs multiple search requests sequentially to find all of the matching documents.
A bulk update request is performed for each batch of matching documents.
Any query or update failures cause the update by query request to fail and the failures are shown in the response.
Any update requests that completed successfully still stick, they are not rolled back.
</p>
<p>
<strong>Throttling update requests</strong>
</p>
<p>
To control the rate at which update by query issues batches of update operations, you can set <code>requests_per_second</code> to any positive decimal number.
This pads each batch with a wait time to throttle the rate.
Set <code>requests_per_second</code> to <code>-1</code> to turn off throttling.
</p>
<p>
Throttling uses a wait time between batches so that the internal scroll requests can be given a timeout that takes the request padding into account.
The padding time is the difference between the batch size divided by the <code>requests_per_second</code> and the time spent writing.
By default the batch size is 1000, so if <code>requests_per_second</code> is set to <code>500</code>:
</p>
<pre><code class="lang-csharp">target_time = 1000 / 500 per second = 2 seconds
wait_time = target_time - write_time = 2 seconds - .5 seconds = 1.5 seconds</code></pre>
<p>
Since the batch is issued as a single _bulk request, large batch sizes cause Elasticsearch to create many requests and wait before starting the next set.
This is "bursty" instead of "smooth".
</p>
<p>
<strong>Slicing</strong>
</p>
<p>
Update by query supports sliced scroll to parallelize the update process.
This can improve efficiency and provide a convenient way to break the request down into smaller parts.
</p>
<p>
Setting <code>slices</code> to <code>auto</code> chooses a reasonable number for most data streams and indices.
This setting will use one slice per shard, up to a certain limit.
If there are multiple source data streams or indices, it will choose the number of slices based on the index or backing index with the smallest number of shards.
</p>
<p>
Adding <code>slices</code> to <code>_update_by_query</code> just automates the manual process of creating sub-requests, which means it has some quirks:
</p>
<ul><li>
<p>
You can see these requests in the tasks APIs. These sub-requests are "child" tasks of the task for the request with slices.
</p>
</li><li>
<p>
Fetching the status of the task for the request with <code>slices</code> only contains the status of completed slices.
</p>
</li><li>
<p>
These sub-requests are individually addressable for things like cancellation and rethrottling.
</p>
</li><li>
<p>
Rethrottling the request with <code>slices</code> will rethrottle the unfinished sub-request proportionally.
</p>
</li><li>
<p>
Canceling the request with slices will cancel each sub-request.
</p>
</li><li>
<p>
Due to the nature of slices each sub-request won't get a perfectly even portion of the documents. All documents will be addressed, but some slices may be larger than others. Expect larger slices to have a more even distribution.
</p>
</li><li>
<p>
Parameters like <code>requests_per_second</code> and <code>max_docs</code> on a request with slices are distributed proportionally to each sub-request. Combine that with the point above about distribution being uneven and you should conclude that using <code>max_docs</code> with <code>slices</code> might not result in exactly <code>max_docs</code> documents being updated.
</p>
</li><li>
<p>
Each sub-request gets a slightly different snapshot of the source data stream or index though these are all taken at approximately the same time.
</p>
</li></ul>
<p>
If you're slicing manually or otherwise tuning automatic slicing, keep in mind that:
</p>
<ul><li>
<p>
Query performance is most efficient when the number of slices is equal to the number of shards in the index or backing index. If that number is large (for example, 500), choose a lower number as too many slices hurts performance. Setting slices higher than the number of shards generally does not improve efficiency and adds overhead.
</p>
</li><li>
<p>
Update performance scales linearly across available resources with the number of slices.
</p>
</li></ul>
<p>
Whether query or update performance dominates the runtime depends on the documents being reindexed and cluster resources.
</p>
<p>
<strong>Update the document source</strong>
</p>
<p>
Update by query supports scripts to update the document source.
As with the update API, you can set <code>ctx.op</code> to change the operation that is performed.
</p>
<p>
Set <code>ctx.op = "noop"</code> if your script decides that it doesn't have to make any changes.
The update by query operation skips updating the document and increments the <code>noop</code> counter.
</p>
<p>
Set <code>ctx.op = "delete"</code> if your script decides that the document should be deleted.
The update by query operation deletes the document and increments the <code>deleted</code> counter.
</p>
<p>
Update by query supports only <code>index</code>, <code>noop</code>, and <code>delete</code>.
Setting <code>ctx.op</code> to anything else is an error.
Setting any other field in <code>ctx</code> is an error.
This API enables you to only modify the source of matching documents; you cannot move them.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-update-by-query.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;UpdateByQueryResponse&gt; UpdateByQueryAsync&lt;TDocument&gt;(UpdateByQueryRequestDescriptor&lt;TDocument&gt; descriptor, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.UpdateByQueryRequestDescriptor-1.html">UpdateByQueryRequestDescriptor</a>&lt;TDocument&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.UpdateByQueryResponse.html">UpdateByQueryResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_UpdateByQueryAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.UpdateByQueryAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_UpdateByQueryAsync__1_System_Action_Elastic_Clients_Elasticsearch_UpdateByQueryRequestDescriptor___0___System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.UpdateByQueryAsync``1(System.Action{Elastic.Clients.Elasticsearch.UpdateByQueryRequestDescriptor{``0}},System.Threading.CancellationToken)">
  UpdateByQueryAsync&lt;TDocument&gt;(Action&lt;UpdateByQueryRequestDescriptor&lt;TDocument&gt;&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L42102"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Update documents.
Updates documents that match the specified query.
If no query is specified, performs an update on every document in the data stream or index without modifying the source, which is useful for picking up mapping changes.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or alias:
</p>
<ul><li>
<p>
<code>read</code>
</p>
</li><li>
<p>
<code>index</code> or <code>write</code>
</p>
</li></ul>
<p>
You can specify the query criteria in the request URI or the request body using the same syntax as the search API.
</p>
<p>
When you submit an update by query request, Elasticsearch gets a snapshot of the data stream or index when it begins processing the request and updates matching documents using internal versioning.
When the versions match, the document is updated and the version number is incremented.
If a document changes between the time that the snapshot is taken and the update operation is processed, it results in a version conflict and the operation fails.
You can opt to count version conflicts instead of halting and returning by setting <code>conflicts</code> to <code>proceed</code>.
Note that if you opt to count version conflicts, the operation could attempt to update more documents from the source than <code>max_docs</code> until it has successfully updated <code>max_docs</code> documents or it has gone through every document in the source query.
</p>
<p>
NOTE: Documents with a version equal to 0 cannot be updated using update by query because internal versioning does not support 0 as a valid version number.
</p>
<p>
While processing an update by query request, Elasticsearch performs multiple search requests sequentially to find all of the matching documents.
A bulk update request is performed for each batch of matching documents.
Any query or update failures cause the update by query request to fail and the failures are shown in the response.
Any update requests that completed successfully still stick, they are not rolled back.
</p>
<p>
<strong>Throttling update requests</strong>
</p>
<p>
To control the rate at which update by query issues batches of update operations, you can set <code>requests_per_second</code> to any positive decimal number.
This pads each batch with a wait time to throttle the rate.
Set <code>requests_per_second</code> to <code>-1</code> to turn off throttling.
</p>
<p>
Throttling uses a wait time between batches so that the internal scroll requests can be given a timeout that takes the request padding into account.
The padding time is the difference between the batch size divided by the <code>requests_per_second</code> and the time spent writing.
By default the batch size is 1000, so if <code>requests_per_second</code> is set to <code>500</code>:
</p>
<pre><code class="lang-csharp">target_time = 1000 / 500 per second = 2 seconds
wait_time = target_time - write_time = 2 seconds - .5 seconds = 1.5 seconds</code></pre>
<p>
Since the batch is issued as a single _bulk request, large batch sizes cause Elasticsearch to create many requests and wait before starting the next set.
This is "bursty" instead of "smooth".
</p>
<p>
<strong>Slicing</strong>
</p>
<p>
Update by query supports sliced scroll to parallelize the update process.
This can improve efficiency and provide a convenient way to break the request down into smaller parts.
</p>
<p>
Setting <code>slices</code> to <code>auto</code> chooses a reasonable number for most data streams and indices.
This setting will use one slice per shard, up to a certain limit.
If there are multiple source data streams or indices, it will choose the number of slices based on the index or backing index with the smallest number of shards.
</p>
<p>
Adding <code>slices</code> to <code>_update_by_query</code> just automates the manual process of creating sub-requests, which means it has some quirks:
</p>
<ul><li>
<p>
You can see these requests in the tasks APIs. These sub-requests are "child" tasks of the task for the request with slices.
</p>
</li><li>
<p>
Fetching the status of the task for the request with <code>slices</code> only contains the status of completed slices.
</p>
</li><li>
<p>
These sub-requests are individually addressable for things like cancellation and rethrottling.
</p>
</li><li>
<p>
Rethrottling the request with <code>slices</code> will rethrottle the unfinished sub-request proportionally.
</p>
</li><li>
<p>
Canceling the request with slices will cancel each sub-request.
</p>
</li><li>
<p>
Due to the nature of slices each sub-request won't get a perfectly even portion of the documents. All documents will be addressed, but some slices may be larger than others. Expect larger slices to have a more even distribution.
</p>
</li><li>
<p>
Parameters like <code>requests_per_second</code> and <code>max_docs</code> on a request with slices are distributed proportionally to each sub-request. Combine that with the point above about distribution being uneven and you should conclude that using <code>max_docs</code> with <code>slices</code> might not result in exactly <code>max_docs</code> documents being updated.
</p>
</li><li>
<p>
Each sub-request gets a slightly different snapshot of the source data stream or index though these are all taken at approximately the same time.
</p>
</li></ul>
<p>
If you're slicing manually or otherwise tuning automatic slicing, keep in mind that:
</p>
<ul><li>
<p>
Query performance is most efficient when the number of slices is equal to the number of shards in the index or backing index. If that number is large (for example, 500), choose a lower number as too many slices hurts performance. Setting slices higher than the number of shards generally does not improve efficiency and adds overhead.
</p>
</li><li>
<p>
Update performance scales linearly across available resources with the number of slices.
</p>
</li></ul>
<p>
Whether query or update performance dominates the runtime depends on the documents being reindexed and cluster resources.
</p>
<p>
<strong>Update the document source</strong>
</p>
<p>
Update by query supports scripts to update the document source.
As with the update API, you can set <code>ctx.op</code> to change the operation that is performed.
</p>
<p>
Set <code>ctx.op = "noop"</code> if your script decides that it doesn't have to make any changes.
The update by query operation skips updating the document and increments the <code>noop</code> counter.
</p>
<p>
Set <code>ctx.op = "delete"</code> if your script decides that the document should be deleted.
The update by query operation deletes the document and increments the <code>deleted</code> counter.
</p>
<p>
Update by query supports only <code>index</code>, <code>noop</code>, and <code>delete</code>.
Setting <code>ctx.op</code> to anything else is an error.
Setting any other field in <code>ctx</code> is an error.
This API enables you to only modify the source of matching documents; you cannot move them.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-update-by-query.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;UpdateByQueryResponse&gt; UpdateByQueryAsync&lt;TDocument&gt;(Action&lt;UpdateByQueryRequestDescriptor&lt;TDocument&gt;&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.UpdateByQueryRequestDescriptor-1.html">UpdateByQueryRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.UpdateByQueryResponse.html">UpdateByQueryResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_UpdateByQueryAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.UpdateByQueryAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_UpdateByQueryAsync__1_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.UpdateByQueryAsync``1(System.Threading.CancellationToken)">
  UpdateByQueryAsync&lt;TDocument&gt;(CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L41936"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Update documents.
Updates documents that match the specified query.
If no query is specified, performs an update on every document in the data stream or index without modifying the source, which is useful for picking up mapping changes.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or alias:
</p>
<ul><li>
<p>
<code>read</code>
</p>
</li><li>
<p>
<code>index</code> or <code>write</code>
</p>
</li></ul>
<p>
You can specify the query criteria in the request URI or the request body using the same syntax as the search API.
</p>
<p>
When you submit an update by query request, Elasticsearch gets a snapshot of the data stream or index when it begins processing the request and updates matching documents using internal versioning.
When the versions match, the document is updated and the version number is incremented.
If a document changes between the time that the snapshot is taken and the update operation is processed, it results in a version conflict and the operation fails.
You can opt to count version conflicts instead of halting and returning by setting <code>conflicts</code> to <code>proceed</code>.
Note that if you opt to count version conflicts, the operation could attempt to update more documents from the source than <code>max_docs</code> until it has successfully updated <code>max_docs</code> documents or it has gone through every document in the source query.
</p>
<p>
NOTE: Documents with a version equal to 0 cannot be updated using update by query because internal versioning does not support 0 as a valid version number.
</p>
<p>
While processing an update by query request, Elasticsearch performs multiple search requests sequentially to find all of the matching documents.
A bulk update request is performed for each batch of matching documents.
Any query or update failures cause the update by query request to fail and the failures are shown in the response.
Any update requests that completed successfully still stick, they are not rolled back.
</p>
<p>
<strong>Throttling update requests</strong>
</p>
<p>
To control the rate at which update by query issues batches of update operations, you can set <code>requests_per_second</code> to any positive decimal number.
This pads each batch with a wait time to throttle the rate.
Set <code>requests_per_second</code> to <code>-1</code> to turn off throttling.
</p>
<p>
Throttling uses a wait time between batches so that the internal scroll requests can be given a timeout that takes the request padding into account.
The padding time is the difference between the batch size divided by the <code>requests_per_second</code> and the time spent writing.
By default the batch size is 1000, so if <code>requests_per_second</code> is set to <code>500</code>:
</p>
<pre><code class="lang-csharp">target_time = 1000 / 500 per second = 2 seconds
wait_time = target_time - write_time = 2 seconds - .5 seconds = 1.5 seconds</code></pre>
<p>
Since the batch is issued as a single _bulk request, large batch sizes cause Elasticsearch to create many requests and wait before starting the next set.
This is "bursty" instead of "smooth".
</p>
<p>
<strong>Slicing</strong>
</p>
<p>
Update by query supports sliced scroll to parallelize the update process.
This can improve efficiency and provide a convenient way to break the request down into smaller parts.
</p>
<p>
Setting <code>slices</code> to <code>auto</code> chooses a reasonable number for most data streams and indices.
This setting will use one slice per shard, up to a certain limit.
If there are multiple source data streams or indices, it will choose the number of slices based on the index or backing index with the smallest number of shards.
</p>
<p>
Adding <code>slices</code> to <code>_update_by_query</code> just automates the manual process of creating sub-requests, which means it has some quirks:
</p>
<ul><li>
<p>
You can see these requests in the tasks APIs. These sub-requests are "child" tasks of the task for the request with slices.
</p>
</li><li>
<p>
Fetching the status of the task for the request with <code>slices</code> only contains the status of completed slices.
</p>
</li><li>
<p>
These sub-requests are individually addressable for things like cancellation and rethrottling.
</p>
</li><li>
<p>
Rethrottling the request with <code>slices</code> will rethrottle the unfinished sub-request proportionally.
</p>
</li><li>
<p>
Canceling the request with slices will cancel each sub-request.
</p>
</li><li>
<p>
Due to the nature of slices each sub-request won't get a perfectly even portion of the documents. All documents will be addressed, but some slices may be larger than others. Expect larger slices to have a more even distribution.
</p>
</li><li>
<p>
Parameters like <code>requests_per_second</code> and <code>max_docs</code> on a request with slices are distributed proportionally to each sub-request. Combine that with the point above about distribution being uneven and you should conclude that using <code>max_docs</code> with <code>slices</code> might not result in exactly <code>max_docs</code> documents being updated.
</p>
</li><li>
<p>
Each sub-request gets a slightly different snapshot of the source data stream or index though these are all taken at approximately the same time.
</p>
</li></ul>
<p>
If you're slicing manually or otherwise tuning automatic slicing, keep in mind that:
</p>
<ul><li>
<p>
Query performance is most efficient when the number of slices is equal to the number of shards in the index or backing index. If that number is large (for example, 500), choose a lower number as too many slices hurts performance. Setting slices higher than the number of shards generally does not improve efficiency and adds overhead.
</p>
</li><li>
<p>
Update performance scales linearly across available resources with the number of slices.
</p>
</li></ul>
<p>
Whether query or update performance dominates the runtime depends on the documents being reindexed and cluster resources.
</p>
<p>
<strong>Update the document source</strong>
</p>
<p>
Update by query supports scripts to update the document source.
As with the update API, you can set <code>ctx.op</code> to change the operation that is performed.
</p>
<p>
Set <code>ctx.op = "noop"</code> if your script decides that it doesn't have to make any changes.
The update by query operation skips updating the document and increments the <code>noop</code> counter.
</p>
<p>
Set <code>ctx.op = "delete"</code> if your script decides that the document should be deleted.
The update by query operation deletes the document and increments the <code>deleted</code> counter.
</p>
<p>
Update by query supports only <code>index</code>, <code>noop</code>, and <code>delete</code>.
Setting <code>ctx.op</code> to anything else is an error.
Setting any other field in <code>ctx</code> is an error.
This API enables you to only modify the source of matching documents; you cannot move them.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-update-by-query.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;UpdateByQueryResponse&gt; UpdateByQueryAsync&lt;TDocument&gt;(CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.UpdateByQueryResponse.html">UpdateByQueryResponse</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_UpdateByQueryRethrottle_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.UpdateByQueryRethrottle*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_UpdateByQueryRethrottle_Elastic_Clients_Elasticsearch_Id_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.UpdateByQueryRethrottle(Elastic.Clients.Elasticsearch.Id)">
  UpdateByQueryRethrottle(Id)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L42668"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Throttle an update by query operation.
</p>
<p>
Change the number of requests per second for a particular update by query operation.
Rethrottling that speeds up the query takes effect immediately but rethrotting that slows down the query takes effect after completing the current batch to prevent scroll timeouts.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-update-by-query.html#docs-update-by-query-rethrottle">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual UpdateByQueryRethrottleResponse UpdateByQueryRethrottle(Id taskId)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>taskId</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.UpdateByQueryRethrottleResponse.html">UpdateByQueryRethrottleResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_UpdateByQueryRethrottle_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.UpdateByQueryRethrottle*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_UpdateByQueryRethrottle_Elastic_Clients_Elasticsearch_Id_System_Action_Elastic_Clients_Elasticsearch_UpdateByQueryRethrottleRequestDescriptor__" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.UpdateByQueryRethrottle(Elastic.Clients.Elasticsearch.Id,System.Action{Elastic.Clients.Elasticsearch.UpdateByQueryRethrottleRequestDescriptor})">
  UpdateByQueryRethrottle(Id, Action&lt;UpdateByQueryRethrottleRequestDescriptor&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L42686"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Throttle an update by query operation.
</p>
<p>
Change the number of requests per second for a particular update by query operation.
Rethrottling that speeds up the query takes effect immediately but rethrotting that slows down the query takes effect after completing the current batch to prevent scroll timeouts.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-update-by-query.html#docs-update-by-query-rethrottle">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual UpdateByQueryRethrottleResponse UpdateByQueryRethrottle(Id taskId, Action&lt;UpdateByQueryRethrottleRequestDescriptor&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>taskId</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.UpdateByQueryRethrottleRequestDescriptor.html">UpdateByQueryRethrottleRequestDescriptor</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.UpdateByQueryRethrottleResponse.html">UpdateByQueryRethrottleResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_UpdateByQueryRethrottle_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.UpdateByQueryRethrottle*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_UpdateByQueryRethrottle_Elastic_Clients_Elasticsearch_UpdateByQueryRethrottleRequest_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.UpdateByQueryRethrottle(Elastic.Clients.Elasticsearch.UpdateByQueryRethrottleRequest)">
  UpdateByQueryRethrottle(UpdateByQueryRethrottleRequest)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L42618"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Throttle an update by query operation.
</p>
<p>
Change the number of requests per second for a particular update by query operation.
Rethrottling that speeds up the query takes effect immediately but rethrotting that slows down the query takes effect after completing the current batch to prevent scroll timeouts.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-update-by-query.html#docs-update-by-query-rethrottle">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual UpdateByQueryRethrottleResponse UpdateByQueryRethrottle(UpdateByQueryRethrottleRequest request)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.UpdateByQueryRethrottleRequest.html">UpdateByQueryRethrottleRequest</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.UpdateByQueryRethrottleResponse.html">UpdateByQueryRethrottleResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_UpdateByQueryRethrottle_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.UpdateByQueryRethrottle*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_UpdateByQueryRethrottle_Elastic_Clients_Elasticsearch_UpdateByQueryRethrottleRequestDescriptor_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.UpdateByQueryRethrottle(Elastic.Clients.Elasticsearch.UpdateByQueryRethrottleRequestDescriptor)">
  UpdateByQueryRethrottle(UpdateByQueryRethrottleRequestDescriptor)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L42651"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Throttle an update by query operation.
</p>
<p>
Change the number of requests per second for a particular update by query operation.
Rethrottling that speeds up the query takes effect immediately but rethrotting that slows down the query takes effect after completing the current batch to prevent scroll timeouts.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-update-by-query.html#docs-update-by-query-rethrottle">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual UpdateByQueryRethrottleResponse UpdateByQueryRethrottle(UpdateByQueryRethrottleRequestDescriptor descriptor)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.UpdateByQueryRethrottleRequestDescriptor.html">UpdateByQueryRethrottleRequestDescriptor</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.UpdateByQueryRethrottleResponse.html">UpdateByQueryRethrottleResponse</a></dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_UpdateByQueryRethrottleAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.UpdateByQueryRethrottleAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_UpdateByQueryRethrottleAsync_Elastic_Clients_Elasticsearch_Id_System_Action_Elastic_Clients_Elasticsearch_UpdateByQueryRethrottleRequestDescriptor__System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.UpdateByQueryRethrottleAsync(Elastic.Clients.Elasticsearch.Id,System.Action{Elastic.Clients.Elasticsearch.UpdateByQueryRethrottleRequestDescriptor},System.Threading.CancellationToken)">
  UpdateByQueryRethrottleAsync(Id, Action&lt;UpdateByQueryRethrottleRequestDescriptor&gt;, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L42738"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Throttle an update by query operation.
</p>
<p>
Change the number of requests per second for a particular update by query operation.
Rethrottling that speeds up the query takes effect immediately but rethrotting that slows down the query takes effect after completing the current batch to prevent scroll timeouts.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-update-by-query.html#docs-update-by-query-rethrottle">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;UpdateByQueryRethrottleResponse&gt; UpdateByQueryRethrottleAsync(Id taskId, Action&lt;UpdateByQueryRethrottleRequestDescriptor&gt; configureRequest, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>taskId</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.UpdateByQueryRethrottleRequestDescriptor.html">UpdateByQueryRethrottleRequestDescriptor</a>&gt;</dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.UpdateByQueryRethrottleResponse.html">UpdateByQueryRethrottleResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_UpdateByQueryRethrottleAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.UpdateByQueryRethrottleAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_UpdateByQueryRethrottleAsync_Elastic_Clients_Elasticsearch_Id_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.UpdateByQueryRethrottleAsync(Elastic.Clients.Elasticsearch.Id,System.Threading.CancellationToken)">
  UpdateByQueryRethrottleAsync(Id, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L42721"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Throttle an update by query operation.
</p>
<p>
Change the number of requests per second for a particular update by query operation.
Rethrottling that speeds up the query takes effect immediately but rethrotting that slows down the query takes effect after completing the current batch to prevent scroll timeouts.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-update-by-query.html#docs-update-by-query-rethrottle">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;UpdateByQueryRethrottleResponse&gt; UpdateByQueryRethrottleAsync(Id taskId, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>taskId</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.UpdateByQueryRethrottleResponse.html">UpdateByQueryRethrottleResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_UpdateByQueryRethrottleAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.UpdateByQueryRethrottleAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_UpdateByQueryRethrottleAsync_Elastic_Clients_Elasticsearch_UpdateByQueryRethrottleRequest_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.UpdateByQueryRethrottleAsync(Elastic.Clients.Elasticsearch.UpdateByQueryRethrottleRequest,System.Threading.CancellationToken)">
  UpdateByQueryRethrottleAsync(UpdateByQueryRethrottleRequest, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L42635"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Throttle an update by query operation.
</p>
<p>
Change the number of requests per second for a particular update by query operation.
Rethrottling that speeds up the query takes effect immediately but rethrotting that slows down the query takes effect after completing the current batch to prevent scroll timeouts.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-update-by-query.html#docs-update-by-query-rethrottle">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;UpdateByQueryRethrottleResponse&gt; UpdateByQueryRethrottleAsync(UpdateByQueryRethrottleRequest request, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.UpdateByQueryRethrottleRequest.html">UpdateByQueryRethrottleRequest</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.UpdateByQueryRethrottleResponse.html">UpdateByQueryRethrottleResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_UpdateByQueryRethrottleAsync_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.UpdateByQueryRethrottleAsync*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_UpdateByQueryRethrottleAsync_Elastic_Clients_Elasticsearch_UpdateByQueryRethrottleRequestDescriptor_System_Threading_CancellationToken_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.UpdateByQueryRethrottleAsync(Elastic.Clients.Elasticsearch.UpdateByQueryRethrottleRequestDescriptor,System.Threading.CancellationToken)">
  UpdateByQueryRethrottleAsync(UpdateByQueryRethrottleRequestDescriptor, CancellationToken)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L42705"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Throttle an update by query operation.
</p>
<p>
Change the number of requests per second for a particular update by query operation.
Rethrottling that speeds up the query takes effect immediately but rethrotting that slows down the query takes effect after completing the current batch to prevent scroll timeouts.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-update-by-query.html#docs-update-by-query-rethrottle">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public virtual Task&lt;UpdateByQueryRethrottleResponse&gt; UpdateByQueryRethrottleAsync(UpdateByQueryRethrottleRequestDescriptor descriptor, CancellationToken cancellationToken = default)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.UpdateByQueryRethrottleRequestDescriptor.html">UpdateByQueryRethrottleRequestDescriptor</a></dt>
    <dd></dd>
    <dt><code>cancellationToken</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.cancellationtoken">CancellationToken</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1">Task</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.UpdateByQueryRethrottleResponse.html">UpdateByQueryRethrottleResponse</a>&gt;</dt>
    <dd></dd>
  </dl>











  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_UpdateByQuery_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.UpdateByQuery*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_UpdateByQuery__1" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.UpdateByQuery``1">
  UpdateByQuery&lt;TDocument&gt;()
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L40602"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Update documents.
Updates documents that match the specified query.
If no query is specified, performs an update on every document in the data stream or index without modifying the source, which is useful for picking up mapping changes.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or alias:
</p>
<ul><li>
<p>
<code>read</code>
</p>
</li><li>
<p>
<code>index</code> or <code>write</code>
</p>
</li></ul>
<p>
You can specify the query criteria in the request URI or the request body using the same syntax as the search API.
</p>
<p>
When you submit an update by query request, Elasticsearch gets a snapshot of the data stream or index when it begins processing the request and updates matching documents using internal versioning.
When the versions match, the document is updated and the version number is incremented.
If a document changes between the time that the snapshot is taken and the update operation is processed, it results in a version conflict and the operation fails.
You can opt to count version conflicts instead of halting and returning by setting <code>conflicts</code> to <code>proceed</code>.
Note that if you opt to count version conflicts, the operation could attempt to update more documents from the source than <code>max_docs</code> until it has successfully updated <code>max_docs</code> documents or it has gone through every document in the source query.
</p>
<p>
NOTE: Documents with a version equal to 0 cannot be updated using update by query because internal versioning does not support 0 as a valid version number.
</p>
<p>
While processing an update by query request, Elasticsearch performs multiple search requests sequentially to find all of the matching documents.
A bulk update request is performed for each batch of matching documents.
Any query or update failures cause the update by query request to fail and the failures are shown in the response.
Any update requests that completed successfully still stick, they are not rolled back.
</p>
<p>
<strong>Throttling update requests</strong>
</p>
<p>
To control the rate at which update by query issues batches of update operations, you can set <code>requests_per_second</code> to any positive decimal number.
This pads each batch with a wait time to throttle the rate.
Set <code>requests_per_second</code> to <code>-1</code> to turn off throttling.
</p>
<p>
Throttling uses a wait time between batches so that the internal scroll requests can be given a timeout that takes the request padding into account.
The padding time is the difference between the batch size divided by the <code>requests_per_second</code> and the time spent writing.
By default the batch size is 1000, so if <code>requests_per_second</code> is set to <code>500</code>:
</p>
<pre><code class="lang-csharp">target_time = 1000 / 500 per second = 2 seconds
wait_time = target_time - write_time = 2 seconds - .5 seconds = 1.5 seconds</code></pre>
<p>
Since the batch is issued as a single _bulk request, large batch sizes cause Elasticsearch to create many requests and wait before starting the next set.
This is "bursty" instead of "smooth".
</p>
<p>
<strong>Slicing</strong>
</p>
<p>
Update by query supports sliced scroll to parallelize the update process.
This can improve efficiency and provide a convenient way to break the request down into smaller parts.
</p>
<p>
Setting <code>slices</code> to <code>auto</code> chooses a reasonable number for most data streams and indices.
This setting will use one slice per shard, up to a certain limit.
If there are multiple source data streams or indices, it will choose the number of slices based on the index or backing index with the smallest number of shards.
</p>
<p>
Adding <code>slices</code> to <code>_update_by_query</code> just automates the manual process of creating sub-requests, which means it has some quirks:
</p>
<ul><li>
<p>
You can see these requests in the tasks APIs. These sub-requests are "child" tasks of the task for the request with slices.
</p>
</li><li>
<p>
Fetching the status of the task for the request with <code>slices</code> only contains the status of completed slices.
</p>
</li><li>
<p>
These sub-requests are individually addressable for things like cancellation and rethrottling.
</p>
</li><li>
<p>
Rethrottling the request with <code>slices</code> will rethrottle the unfinished sub-request proportionally.
</p>
</li><li>
<p>
Canceling the request with slices will cancel each sub-request.
</p>
</li><li>
<p>
Due to the nature of slices each sub-request won't get a perfectly even portion of the documents. All documents will be addressed, but some slices may be larger than others. Expect larger slices to have a more even distribution.
</p>
</li><li>
<p>
Parameters like <code>requests_per_second</code> and <code>max_docs</code> on a request with slices are distributed proportionally to each sub-request. Combine that with the point above about distribution being uneven and you should conclude that using <code>max_docs</code> with <code>slices</code> might not result in exactly <code>max_docs</code> documents being updated.
</p>
</li><li>
<p>
Each sub-request gets a slightly different snapshot of the source data stream or index though these are all taken at approximately the same time.
</p>
</li></ul>
<p>
If you're slicing manually or otherwise tuning automatic slicing, keep in mind that:
</p>
<ul><li>
<p>
Query performance is most efficient when the number of slices is equal to the number of shards in the index or backing index. If that number is large (for example, 500), choose a lower number as too many slices hurts performance. Setting slices higher than the number of shards generally does not improve efficiency and adds overhead.
</p>
</li><li>
<p>
Update performance scales linearly across available resources with the number of slices.
</p>
</li></ul>
<p>
Whether query or update performance dominates the runtime depends on the documents being reindexed and cluster resources.
</p>
<p>
<strong>Update the document source</strong>
</p>
<p>
Update by query supports scripts to update the document source.
As with the update API, you can set <code>ctx.op</code> to change the operation that is performed.
</p>
<p>
Set <code>ctx.op = "noop"</code> if your script decides that it doesn't have to make any changes.
The update by query operation skips updating the document and increments the <code>noop</code> counter.
</p>
<p>
Set <code>ctx.op = "delete"</code> if your script decides that the document should be deleted.
The update by query operation deletes the document and increments the <code>deleted</code> counter.
</p>
<p>
Update by query supports only <code>index</code>, <code>noop</code>, and <code>delete</code>.
Setting <code>ctx.op</code> to anything else is an error.
Setting any other field in <code>ctx</code> is an error.
This API enables you to only modify the source of matching documents; you cannot move them.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-update-by-query.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual UpdateByQueryResponse UpdateByQuery&lt;TDocument&gt;()</code></pre>
  </div>


  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.UpdateByQueryResponse.html">UpdateByQueryResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_UpdateByQuery_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.UpdateByQuery*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_UpdateByQuery__1_Elastic_Clients_Elasticsearch_Indices_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.UpdateByQuery``1(Elastic.Clients.Elasticsearch.Indices)">
  UpdateByQuery&lt;TDocument&gt;(Indices)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L40267"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Update documents.
Updates documents that match the specified query.
If no query is specified, performs an update on every document in the data stream or index without modifying the source, which is useful for picking up mapping changes.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or alias:
</p>
<ul><li>
<p>
<code>read</code>
</p>
</li><li>
<p>
<code>index</code> or <code>write</code>
</p>
</li></ul>
<p>
You can specify the query criteria in the request URI or the request body using the same syntax as the search API.
</p>
<p>
When you submit an update by query request, Elasticsearch gets a snapshot of the data stream or index when it begins processing the request and updates matching documents using internal versioning.
When the versions match, the document is updated and the version number is incremented.
If a document changes between the time that the snapshot is taken and the update operation is processed, it results in a version conflict and the operation fails.
You can opt to count version conflicts instead of halting and returning by setting <code>conflicts</code> to <code>proceed</code>.
Note that if you opt to count version conflicts, the operation could attempt to update more documents from the source than <code>max_docs</code> until it has successfully updated <code>max_docs</code> documents or it has gone through every document in the source query.
</p>
<p>
NOTE: Documents with a version equal to 0 cannot be updated using update by query because internal versioning does not support 0 as a valid version number.
</p>
<p>
While processing an update by query request, Elasticsearch performs multiple search requests sequentially to find all of the matching documents.
A bulk update request is performed for each batch of matching documents.
Any query or update failures cause the update by query request to fail and the failures are shown in the response.
Any update requests that completed successfully still stick, they are not rolled back.
</p>
<p>
<strong>Throttling update requests</strong>
</p>
<p>
To control the rate at which update by query issues batches of update operations, you can set <code>requests_per_second</code> to any positive decimal number.
This pads each batch with a wait time to throttle the rate.
Set <code>requests_per_second</code> to <code>-1</code> to turn off throttling.
</p>
<p>
Throttling uses a wait time between batches so that the internal scroll requests can be given a timeout that takes the request padding into account.
The padding time is the difference between the batch size divided by the <code>requests_per_second</code> and the time spent writing.
By default the batch size is 1000, so if <code>requests_per_second</code> is set to <code>500</code>:
</p>
<pre><code class="lang-csharp">target_time = 1000 / 500 per second = 2 seconds
wait_time = target_time - write_time = 2 seconds - .5 seconds = 1.5 seconds</code></pre>
<p>
Since the batch is issued as a single _bulk request, large batch sizes cause Elasticsearch to create many requests and wait before starting the next set.
This is "bursty" instead of "smooth".
</p>
<p>
<strong>Slicing</strong>
</p>
<p>
Update by query supports sliced scroll to parallelize the update process.
This can improve efficiency and provide a convenient way to break the request down into smaller parts.
</p>
<p>
Setting <code>slices</code> to <code>auto</code> chooses a reasonable number for most data streams and indices.
This setting will use one slice per shard, up to a certain limit.
If there are multiple source data streams or indices, it will choose the number of slices based on the index or backing index with the smallest number of shards.
</p>
<p>
Adding <code>slices</code> to <code>_update_by_query</code> just automates the manual process of creating sub-requests, which means it has some quirks:
</p>
<ul><li>
<p>
You can see these requests in the tasks APIs. These sub-requests are "child" tasks of the task for the request with slices.
</p>
</li><li>
<p>
Fetching the status of the task for the request with <code>slices</code> only contains the status of completed slices.
</p>
</li><li>
<p>
These sub-requests are individually addressable for things like cancellation and rethrottling.
</p>
</li><li>
<p>
Rethrottling the request with <code>slices</code> will rethrottle the unfinished sub-request proportionally.
</p>
</li><li>
<p>
Canceling the request with slices will cancel each sub-request.
</p>
</li><li>
<p>
Due to the nature of slices each sub-request won't get a perfectly even portion of the documents. All documents will be addressed, but some slices may be larger than others. Expect larger slices to have a more even distribution.
</p>
</li><li>
<p>
Parameters like <code>requests_per_second</code> and <code>max_docs</code> on a request with slices are distributed proportionally to each sub-request. Combine that with the point above about distribution being uneven and you should conclude that using <code>max_docs</code> with <code>slices</code> might not result in exactly <code>max_docs</code> documents being updated.
</p>
</li><li>
<p>
Each sub-request gets a slightly different snapshot of the source data stream or index though these are all taken at approximately the same time.
</p>
</li></ul>
<p>
If you're slicing manually or otherwise tuning automatic slicing, keep in mind that:
</p>
<ul><li>
<p>
Query performance is most efficient when the number of slices is equal to the number of shards in the index or backing index. If that number is large (for example, 500), choose a lower number as too many slices hurts performance. Setting slices higher than the number of shards generally does not improve efficiency and adds overhead.
</p>
</li><li>
<p>
Update performance scales linearly across available resources with the number of slices.
</p>
</li></ul>
<p>
Whether query or update performance dominates the runtime depends on the documents being reindexed and cluster resources.
</p>
<p>
<strong>Update the document source</strong>
</p>
<p>
Update by query supports scripts to update the document source.
As with the update API, you can set <code>ctx.op</code> to change the operation that is performed.
</p>
<p>
Set <code>ctx.op = "noop"</code> if your script decides that it doesn't have to make any changes.
The update by query operation skips updating the document and increments the <code>noop</code> counter.
</p>
<p>
Set <code>ctx.op = "delete"</code> if your script decides that the document should be deleted.
The update by query operation deletes the document and increments the <code>deleted</code> counter.
</p>
<p>
Update by query supports only <code>index</code>, <code>noop</code>, and <code>delete</code>.
Setting <code>ctx.op</code> to anything else is an error.
Setting any other field in <code>ctx</code> is an error.
This API enables you to only modify the source of matching documents; you cannot move them.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-update-by-query.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual UpdateByQueryResponse UpdateByQuery&lt;TDocument&gt;(Indices indices)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>indices</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Indices.html">Indices</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.UpdateByQueryResponse.html">UpdateByQueryResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_UpdateByQuery_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.UpdateByQuery*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_UpdateByQuery__1_Elastic_Clients_Elasticsearch_Indices_System_Action_Elastic_Clients_Elasticsearch_UpdateByQueryRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.UpdateByQuery``1(Elastic.Clients.Elasticsearch.Indices,System.Action{Elastic.Clients.Elasticsearch.UpdateByQueryRequestDescriptor{``0}})">
  UpdateByQuery&lt;TDocument&gt;(Indices, Action&lt;UpdateByQueryRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L40434"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Update documents.
Updates documents that match the specified query.
If no query is specified, performs an update on every document in the data stream or index without modifying the source, which is useful for picking up mapping changes.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or alias:
</p>
<ul><li>
<p>
<code>read</code>
</p>
</li><li>
<p>
<code>index</code> or <code>write</code>
</p>
</li></ul>
<p>
You can specify the query criteria in the request URI or the request body using the same syntax as the search API.
</p>
<p>
When you submit an update by query request, Elasticsearch gets a snapshot of the data stream or index when it begins processing the request and updates matching documents using internal versioning.
When the versions match, the document is updated and the version number is incremented.
If a document changes between the time that the snapshot is taken and the update operation is processed, it results in a version conflict and the operation fails.
You can opt to count version conflicts instead of halting and returning by setting <code>conflicts</code> to <code>proceed</code>.
Note that if you opt to count version conflicts, the operation could attempt to update more documents from the source than <code>max_docs</code> until it has successfully updated <code>max_docs</code> documents or it has gone through every document in the source query.
</p>
<p>
NOTE: Documents with a version equal to 0 cannot be updated using update by query because internal versioning does not support 0 as a valid version number.
</p>
<p>
While processing an update by query request, Elasticsearch performs multiple search requests sequentially to find all of the matching documents.
A bulk update request is performed for each batch of matching documents.
Any query or update failures cause the update by query request to fail and the failures are shown in the response.
Any update requests that completed successfully still stick, they are not rolled back.
</p>
<p>
<strong>Throttling update requests</strong>
</p>
<p>
To control the rate at which update by query issues batches of update operations, you can set <code>requests_per_second</code> to any positive decimal number.
This pads each batch with a wait time to throttle the rate.
Set <code>requests_per_second</code> to <code>-1</code> to turn off throttling.
</p>
<p>
Throttling uses a wait time between batches so that the internal scroll requests can be given a timeout that takes the request padding into account.
The padding time is the difference between the batch size divided by the <code>requests_per_second</code> and the time spent writing.
By default the batch size is 1000, so if <code>requests_per_second</code> is set to <code>500</code>:
</p>
<pre><code class="lang-csharp">target_time = 1000 / 500 per second = 2 seconds
wait_time = target_time - write_time = 2 seconds - .5 seconds = 1.5 seconds</code></pre>
<p>
Since the batch is issued as a single _bulk request, large batch sizes cause Elasticsearch to create many requests and wait before starting the next set.
This is "bursty" instead of "smooth".
</p>
<p>
<strong>Slicing</strong>
</p>
<p>
Update by query supports sliced scroll to parallelize the update process.
This can improve efficiency and provide a convenient way to break the request down into smaller parts.
</p>
<p>
Setting <code>slices</code> to <code>auto</code> chooses a reasonable number for most data streams and indices.
This setting will use one slice per shard, up to a certain limit.
If there are multiple source data streams or indices, it will choose the number of slices based on the index or backing index with the smallest number of shards.
</p>
<p>
Adding <code>slices</code> to <code>_update_by_query</code> just automates the manual process of creating sub-requests, which means it has some quirks:
</p>
<ul><li>
<p>
You can see these requests in the tasks APIs. These sub-requests are "child" tasks of the task for the request with slices.
</p>
</li><li>
<p>
Fetching the status of the task for the request with <code>slices</code> only contains the status of completed slices.
</p>
</li><li>
<p>
These sub-requests are individually addressable for things like cancellation and rethrottling.
</p>
</li><li>
<p>
Rethrottling the request with <code>slices</code> will rethrottle the unfinished sub-request proportionally.
</p>
</li><li>
<p>
Canceling the request with slices will cancel each sub-request.
</p>
</li><li>
<p>
Due to the nature of slices each sub-request won't get a perfectly even portion of the documents. All documents will be addressed, but some slices may be larger than others. Expect larger slices to have a more even distribution.
</p>
</li><li>
<p>
Parameters like <code>requests_per_second</code> and <code>max_docs</code> on a request with slices are distributed proportionally to each sub-request. Combine that with the point above about distribution being uneven and you should conclude that using <code>max_docs</code> with <code>slices</code> might not result in exactly <code>max_docs</code> documents being updated.
</p>
</li><li>
<p>
Each sub-request gets a slightly different snapshot of the source data stream or index though these are all taken at approximately the same time.
</p>
</li></ul>
<p>
If you're slicing manually or otherwise tuning automatic slicing, keep in mind that:
</p>
<ul><li>
<p>
Query performance is most efficient when the number of slices is equal to the number of shards in the index or backing index. If that number is large (for example, 500), choose a lower number as too many slices hurts performance. Setting slices higher than the number of shards generally does not improve efficiency and adds overhead.
</p>
</li><li>
<p>
Update performance scales linearly across available resources with the number of slices.
</p>
</li></ul>
<p>
Whether query or update performance dominates the runtime depends on the documents being reindexed and cluster resources.
</p>
<p>
<strong>Update the document source</strong>
</p>
<p>
Update by query supports scripts to update the document source.
As with the update API, you can set <code>ctx.op</code> to change the operation that is performed.
</p>
<p>
Set <code>ctx.op = "noop"</code> if your script decides that it doesn't have to make any changes.
The update by query operation skips updating the document and increments the <code>noop</code> counter.
</p>
<p>
Set <code>ctx.op = "delete"</code> if your script decides that the document should be deleted.
The update by query operation deletes the document and increments the <code>deleted</code> counter.
</p>
<p>
Update by query supports only <code>index</code>, <code>noop</code>, and <code>delete</code>.
Setting <code>ctx.op</code> to anything else is an error.
Setting any other field in <code>ctx</code> is an error.
This API enables you to only modify the source of matching documents; you cannot move them.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-update-by-query.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual UpdateByQueryResponse UpdateByQuery&lt;TDocument&gt;(Indices indices, Action&lt;UpdateByQueryRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>indices</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Indices.html">Indices</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.UpdateByQueryRequestDescriptor-1.html">UpdateByQueryRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.UpdateByQueryResponse.html">UpdateByQueryResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_UpdateByQuery_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.UpdateByQuery*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_UpdateByQuery__1_Elastic_Clients_Elasticsearch_UpdateByQueryRequestDescriptor___0__" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.UpdateByQuery``1(Elastic.Clients.Elasticsearch.UpdateByQueryRequestDescriptor{``0})">
  UpdateByQuery&lt;TDocument&gt;(UpdateByQueryRequestDescriptor&lt;TDocument&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L40101"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Update documents.
Updates documents that match the specified query.
If no query is specified, performs an update on every document in the data stream or index without modifying the source, which is useful for picking up mapping changes.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or alias:
</p>
<ul><li>
<p>
<code>read</code>
</p>
</li><li>
<p>
<code>index</code> or <code>write</code>
</p>
</li></ul>
<p>
You can specify the query criteria in the request URI or the request body using the same syntax as the search API.
</p>
<p>
When you submit an update by query request, Elasticsearch gets a snapshot of the data stream or index when it begins processing the request and updates matching documents using internal versioning.
When the versions match, the document is updated and the version number is incremented.
If a document changes between the time that the snapshot is taken and the update operation is processed, it results in a version conflict and the operation fails.
You can opt to count version conflicts instead of halting and returning by setting <code>conflicts</code> to <code>proceed</code>.
Note that if you opt to count version conflicts, the operation could attempt to update more documents from the source than <code>max_docs</code> until it has successfully updated <code>max_docs</code> documents or it has gone through every document in the source query.
</p>
<p>
NOTE: Documents with a version equal to 0 cannot be updated using update by query because internal versioning does not support 0 as a valid version number.
</p>
<p>
While processing an update by query request, Elasticsearch performs multiple search requests sequentially to find all of the matching documents.
A bulk update request is performed for each batch of matching documents.
Any query or update failures cause the update by query request to fail and the failures are shown in the response.
Any update requests that completed successfully still stick, they are not rolled back.
</p>
<p>
<strong>Throttling update requests</strong>
</p>
<p>
To control the rate at which update by query issues batches of update operations, you can set <code>requests_per_second</code> to any positive decimal number.
This pads each batch with a wait time to throttle the rate.
Set <code>requests_per_second</code> to <code>-1</code> to turn off throttling.
</p>
<p>
Throttling uses a wait time between batches so that the internal scroll requests can be given a timeout that takes the request padding into account.
The padding time is the difference between the batch size divided by the <code>requests_per_second</code> and the time spent writing.
By default the batch size is 1000, so if <code>requests_per_second</code> is set to <code>500</code>:
</p>
<pre><code class="lang-csharp">target_time = 1000 / 500 per second = 2 seconds
wait_time = target_time - write_time = 2 seconds - .5 seconds = 1.5 seconds</code></pre>
<p>
Since the batch is issued as a single _bulk request, large batch sizes cause Elasticsearch to create many requests and wait before starting the next set.
This is "bursty" instead of "smooth".
</p>
<p>
<strong>Slicing</strong>
</p>
<p>
Update by query supports sliced scroll to parallelize the update process.
This can improve efficiency and provide a convenient way to break the request down into smaller parts.
</p>
<p>
Setting <code>slices</code> to <code>auto</code> chooses a reasonable number for most data streams and indices.
This setting will use one slice per shard, up to a certain limit.
If there are multiple source data streams or indices, it will choose the number of slices based on the index or backing index with the smallest number of shards.
</p>
<p>
Adding <code>slices</code> to <code>_update_by_query</code> just automates the manual process of creating sub-requests, which means it has some quirks:
</p>
<ul><li>
<p>
You can see these requests in the tasks APIs. These sub-requests are "child" tasks of the task for the request with slices.
</p>
</li><li>
<p>
Fetching the status of the task for the request with <code>slices</code> only contains the status of completed slices.
</p>
</li><li>
<p>
These sub-requests are individually addressable for things like cancellation and rethrottling.
</p>
</li><li>
<p>
Rethrottling the request with <code>slices</code> will rethrottle the unfinished sub-request proportionally.
</p>
</li><li>
<p>
Canceling the request with slices will cancel each sub-request.
</p>
</li><li>
<p>
Due to the nature of slices each sub-request won't get a perfectly even portion of the documents. All documents will be addressed, but some slices may be larger than others. Expect larger slices to have a more even distribution.
</p>
</li><li>
<p>
Parameters like <code>requests_per_second</code> and <code>max_docs</code> on a request with slices are distributed proportionally to each sub-request. Combine that with the point above about distribution being uneven and you should conclude that using <code>max_docs</code> with <code>slices</code> might not result in exactly <code>max_docs</code> documents being updated.
</p>
</li><li>
<p>
Each sub-request gets a slightly different snapshot of the source data stream or index though these are all taken at approximately the same time.
</p>
</li></ul>
<p>
If you're slicing manually or otherwise tuning automatic slicing, keep in mind that:
</p>
<ul><li>
<p>
Query performance is most efficient when the number of slices is equal to the number of shards in the index or backing index. If that number is large (for example, 500), choose a lower number as too many slices hurts performance. Setting slices higher than the number of shards generally does not improve efficiency and adds overhead.
</p>
</li><li>
<p>
Update performance scales linearly across available resources with the number of slices.
</p>
</li></ul>
<p>
Whether query or update performance dominates the runtime depends on the documents being reindexed and cluster resources.
</p>
<p>
<strong>Update the document source</strong>
</p>
<p>
Update by query supports scripts to update the document source.
As with the update API, you can set <code>ctx.op</code> to change the operation that is performed.
</p>
<p>
Set <code>ctx.op = "noop"</code> if your script decides that it doesn't have to make any changes.
The update by query operation skips updating the document and increments the <code>noop</code> counter.
</p>
<p>
Set <code>ctx.op = "delete"</code> if your script decides that the document should be deleted.
The update by query operation deletes the document and increments the <code>deleted</code> counter.
</p>
<p>
Update by query supports only <code>index</code>, <code>noop</code>, and <code>delete</code>.
Setting <code>ctx.op</code> to anything else is an error.
Setting any other field in <code>ctx</code> is an error.
This API enables you to only modify the source of matching documents; you cannot move them.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-update-by-query.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual UpdateByQueryResponse UpdateByQuery&lt;TDocument&gt;(UpdateByQueryRequestDescriptor&lt;TDocument&gt; descriptor)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.UpdateByQueryRequestDescriptor-1.html">UpdateByQueryRequestDescriptor</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.UpdateByQueryResponse.html">UpdateByQueryResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_UpdateByQuery_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.UpdateByQuery*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_UpdateByQuery__1_System_Action_Elastic_Clients_Elasticsearch_UpdateByQueryRequestDescriptor___0___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.UpdateByQuery``1(System.Action{Elastic.Clients.Elasticsearch.UpdateByQueryRequestDescriptor{``0}})">
  UpdateByQuery&lt;TDocument&gt;(Action&lt;UpdateByQueryRequestDescriptor&lt;TDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L40769"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Update documents.
Updates documents that match the specified query.
If no query is specified, performs an update on every document in the data stream or index without modifying the source, which is useful for picking up mapping changes.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or alias:
</p>
<ul><li>
<p>
<code>read</code>
</p>
</li><li>
<p>
<code>index</code> or <code>write</code>
</p>
</li></ul>
<p>
You can specify the query criteria in the request URI or the request body using the same syntax as the search API.
</p>
<p>
When you submit an update by query request, Elasticsearch gets a snapshot of the data stream or index when it begins processing the request and updates matching documents using internal versioning.
When the versions match, the document is updated and the version number is incremented.
If a document changes between the time that the snapshot is taken and the update operation is processed, it results in a version conflict and the operation fails.
You can opt to count version conflicts instead of halting and returning by setting <code>conflicts</code> to <code>proceed</code>.
Note that if you opt to count version conflicts, the operation could attempt to update more documents from the source than <code>max_docs</code> until it has successfully updated <code>max_docs</code> documents or it has gone through every document in the source query.
</p>
<p>
NOTE: Documents with a version equal to 0 cannot be updated using update by query because internal versioning does not support 0 as a valid version number.
</p>
<p>
While processing an update by query request, Elasticsearch performs multiple search requests sequentially to find all of the matching documents.
A bulk update request is performed for each batch of matching documents.
Any query or update failures cause the update by query request to fail and the failures are shown in the response.
Any update requests that completed successfully still stick, they are not rolled back.
</p>
<p>
<strong>Throttling update requests</strong>
</p>
<p>
To control the rate at which update by query issues batches of update operations, you can set <code>requests_per_second</code> to any positive decimal number.
This pads each batch with a wait time to throttle the rate.
Set <code>requests_per_second</code> to <code>-1</code> to turn off throttling.
</p>
<p>
Throttling uses a wait time between batches so that the internal scroll requests can be given a timeout that takes the request padding into account.
The padding time is the difference between the batch size divided by the <code>requests_per_second</code> and the time spent writing.
By default the batch size is 1000, so if <code>requests_per_second</code> is set to <code>500</code>:
</p>
<pre><code class="lang-csharp">target_time = 1000 / 500 per second = 2 seconds
wait_time = target_time - write_time = 2 seconds - .5 seconds = 1.5 seconds</code></pre>
<p>
Since the batch is issued as a single _bulk request, large batch sizes cause Elasticsearch to create many requests and wait before starting the next set.
This is "bursty" instead of "smooth".
</p>
<p>
<strong>Slicing</strong>
</p>
<p>
Update by query supports sliced scroll to parallelize the update process.
This can improve efficiency and provide a convenient way to break the request down into smaller parts.
</p>
<p>
Setting <code>slices</code> to <code>auto</code> chooses a reasonable number for most data streams and indices.
This setting will use one slice per shard, up to a certain limit.
If there are multiple source data streams or indices, it will choose the number of slices based on the index or backing index with the smallest number of shards.
</p>
<p>
Adding <code>slices</code> to <code>_update_by_query</code> just automates the manual process of creating sub-requests, which means it has some quirks:
</p>
<ul><li>
<p>
You can see these requests in the tasks APIs. These sub-requests are "child" tasks of the task for the request with slices.
</p>
</li><li>
<p>
Fetching the status of the task for the request with <code>slices</code> only contains the status of completed slices.
</p>
</li><li>
<p>
These sub-requests are individually addressable for things like cancellation and rethrottling.
</p>
</li><li>
<p>
Rethrottling the request with <code>slices</code> will rethrottle the unfinished sub-request proportionally.
</p>
</li><li>
<p>
Canceling the request with slices will cancel each sub-request.
</p>
</li><li>
<p>
Due to the nature of slices each sub-request won't get a perfectly even portion of the documents. All documents will be addressed, but some slices may be larger than others. Expect larger slices to have a more even distribution.
</p>
</li><li>
<p>
Parameters like <code>requests_per_second</code> and <code>max_docs</code> on a request with slices are distributed proportionally to each sub-request. Combine that with the point above about distribution being uneven and you should conclude that using <code>max_docs</code> with <code>slices</code> might not result in exactly <code>max_docs</code> documents being updated.
</p>
</li><li>
<p>
Each sub-request gets a slightly different snapshot of the source data stream or index though these are all taken at approximately the same time.
</p>
</li></ul>
<p>
If you're slicing manually or otherwise tuning automatic slicing, keep in mind that:
</p>
<ul><li>
<p>
Query performance is most efficient when the number of slices is equal to the number of shards in the index or backing index. If that number is large (for example, 500), choose a lower number as too many slices hurts performance. Setting slices higher than the number of shards generally does not improve efficiency and adds overhead.
</p>
</li><li>
<p>
Update performance scales linearly across available resources with the number of slices.
</p>
</li></ul>
<p>
Whether query or update performance dominates the runtime depends on the documents being reindexed and cluster resources.
</p>
<p>
<strong>Update the document source</strong>
</p>
<p>
Update by query supports scripts to update the document source.
As with the update API, you can set <code>ctx.op</code> to change the operation that is performed.
</p>
<p>
Set <code>ctx.op = "noop"</code> if your script decides that it doesn't have to make any changes.
The update by query operation skips updating the document and increments the <code>noop</code> counter.
</p>
<p>
Set <code>ctx.op = "delete"</code> if your script decides that the document should be deleted.
The update by query operation deletes the document and increments the <code>deleted</code> counter.
</p>
<p>
Update by query supports only <code>index</code>, <code>noop</code>, and <code>delete</code>.
Setting <code>ctx.op</code> to anything else is an error.
Setting any other field in <code>ctx</code> is an error.
This API enables you to only modify the source of matching documents; you cannot move them.
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-update-by-query.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual UpdateByQueryResponse UpdateByQuery&lt;TDocument&gt;(Action&lt;UpdateByQueryRequestDescriptor&lt;TDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.UpdateByQueryRequestDescriptor-1.html">UpdateByQueryRequestDescriptor</a>&lt;TDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.UpdateByQueryResponse.html">UpdateByQueryResponse</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Update_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Update*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Update__2_Elastic_Clients_Elasticsearch_Id_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Update``2(Elastic.Clients.Elasticsearch.Id)">
  Update&lt;TDocument, TPartialDocument&gt;(Id)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L39009"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Update a document.
</p>
<p>
Update a document by running a script or passing a partial document.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the <code>index</code> or <code>write</code> index privilege for the target index or index alias.
</p>
<p>
The script can update, delete, or skip modifying the document.
The API also supports passing a partial document, which is merged into the existing document.
To fully replace an existing document, use the index API.
This operation:
</p>
<ul><li>
<p>
Gets the document (collocated with the shard) from the index.
</p>
</li><li>
<p>
Runs the specified script.
</p>
</li><li>
<p>
Indexes the result.
</p>
</li></ul>
<p>
The document must still be reindexed, but using this API removes some network roundtrips and reduces chances of version conflicts between the GET and the index operation.
</p>
<p>
The <code>_source</code> field must be enabled to use this API.
In addition to <code>_source</code>, you can access the following variables through the <code>ctx</code> map: <code>_index</code>, <code>_type</code>, <code>_id</code>, <code>_version</code>, <code>_routing</code>, and <code>_now</code> (the current timestamp).
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-update.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual UpdateResponse&lt;TDocument&gt; Update&lt;TDocument, TPartialDocument&gt;(Id id)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.UpdateResponse-1.html">UpdateResponse</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
    <dt><code>TPartialDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Update_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Update*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Update__2_Elastic_Clients_Elasticsearch_Id_System_Action_Elastic_Clients_Elasticsearch_UpdateRequestDescriptor___0___1___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Update``2(Elastic.Clients.Elasticsearch.Id,System.Action{Elastic.Clients.Elasticsearch.UpdateRequestDescriptor{``0,``1}})">
  Update&lt;TDocument, TPartialDocument&gt;(Id, Action&lt;UpdateRequestDescriptor&lt;TDocument, TPartialDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L39059"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Update a document.
</p>
<p>
Update a document by running a script or passing a partial document.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the <code>index</code> or <code>write</code> index privilege for the target index or index alias.
</p>
<p>
The script can update, delete, or skip modifying the document.
The API also supports passing a partial document, which is merged into the existing document.
To fully replace an existing document, use the index API.
This operation:
</p>
<ul><li>
<p>
Gets the document (collocated with the shard) from the index.
</p>
</li><li>
<p>
Runs the specified script.
</p>
</li><li>
<p>
Indexes the result.
</p>
</li></ul>
<p>
The document must still be reindexed, but using this API removes some network roundtrips and reduces chances of version conflicts between the GET and the index operation.
</p>
<p>
The <code>_source</code> field must be enabled to use this API.
In addition to <code>_source</code>, you can access the following variables through the <code>ctx</code> map: <code>_index</code>, <code>_type</code>, <code>_id</code>, <code>_version</code>, <code>_routing</code>, and <code>_now</code> (the current timestamp).
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-update.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual UpdateResponse&lt;TDocument&gt; Update&lt;TDocument, TPartialDocument&gt;(Id id, Action&lt;UpdateRequestDescriptor&lt;TDocument, TPartialDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.UpdateRequestDescriptor-2.html">UpdateRequestDescriptor</a>&lt;TDocument, TPartialDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.UpdateResponse-1.html">UpdateResponse</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
    <dt><code>TPartialDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Update_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Update*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Update__2_Elastic_Clients_Elasticsearch_IndexName_Elastic_Clients_Elasticsearch_Id_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Update``2(Elastic.Clients.Elasticsearch.IndexName,Elastic.Clients.Elasticsearch.Id)">
  Update&lt;TDocument, TPartialDocument&gt;(IndexName, Id)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L38605"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Update a document.
</p>
<p>
Update a document by running a script or passing a partial document.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the <code>index</code> or <code>write</code> index privilege for the target index or index alias.
</p>
<p>
The script can update, delete, or skip modifying the document.
The API also supports passing a partial document, which is merged into the existing document.
To fully replace an existing document, use the index API.
This operation:
</p>
<ul><li>
<p>
Gets the document (collocated with the shard) from the index.
</p>
</li><li>
<p>
Runs the specified script.
</p>
</li><li>
<p>
Indexes the result.
</p>
</li></ul>
<p>
The document must still be reindexed, but using this API removes some network roundtrips and reduces chances of version conflicts between the GET and the index operation.
</p>
<p>
The <code>_source</code> field must be enabled to use this API.
In addition to <code>_source</code>, you can access the following variables through the <code>ctx</code> map: <code>_index</code>, <code>_type</code>, <code>_id</code>, <code>_version</code>, <code>_routing</code>, and <code>_now</code> (the current timestamp).
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-update.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual UpdateResponse&lt;TDocument&gt; Update&lt;TDocument, TPartialDocument&gt;(IndexName index, Id id)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.UpdateResponse-1.html">UpdateResponse</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
    <dt><code>TPartialDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Update_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Update*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Update__2_Elastic_Clients_Elasticsearch_IndexName_Elastic_Clients_Elasticsearch_Id_System_Action_Elastic_Clients_Elasticsearch_UpdateRequestDescriptor___0___1___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Update``2(Elastic.Clients.Elasticsearch.IndexName,Elastic.Clients.Elasticsearch.Id,System.Action{Elastic.Clients.Elasticsearch.UpdateRequestDescriptor{``0,``1}})">
  Update&lt;TDocument, TPartialDocument&gt;(IndexName, Id, Action&lt;UpdateRequestDescriptor&lt;TDocument, TPartialDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L38655"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Update a document.
</p>
<p>
Update a document by running a script or passing a partial document.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the <code>index</code> or <code>write</code> index privilege for the target index or index alias.
</p>
<p>
The script can update, delete, or skip modifying the document.
The API also supports passing a partial document, which is merged into the existing document.
To fully replace an existing document, use the index API.
This operation:
</p>
<ul><li>
<p>
Gets the document (collocated with the shard) from the index.
</p>
</li><li>
<p>
Runs the specified script.
</p>
</li><li>
<p>
Indexes the result.
</p>
</li></ul>
<p>
The document must still be reindexed, but using this API removes some network roundtrips and reduces chances of version conflicts between the GET and the index operation.
</p>
<p>
The <code>_source</code> field must be enabled to use this API.
In addition to <code>_source</code>, you can access the following variables through the <code>ctx</code> map: <code>_index</code>, <code>_type</code>, <code>_id</code>, <code>_version</code>, <code>_routing</code>, and <code>_now</code> (the current timestamp).
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-update.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual UpdateResponse&lt;TDocument&gt; Update&lt;TDocument, TPartialDocument&gt;(IndexName index, Id id, Action&lt;UpdateRequestDescriptor&lt;TDocument, TPartialDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.UpdateRequestDescriptor-2.html">UpdateRequestDescriptor</a>&lt;TDocument, TPartialDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.UpdateResponse-1.html">UpdateResponse</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
    <dt><code>TPartialDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Update_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Update*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Update__2_Elastic_Clients_Elasticsearch_UpdateRequestDescriptor___0___1__" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Update``2(Elastic.Clients.Elasticsearch.UpdateRequestDescriptor{``0,``1})">
  Update&lt;TDocument, TPartialDocument&gt;(UpdateRequestDescriptor&lt;TDocument, TPartialDocument&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L38556"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Update a document.
</p>
<p>
Update a document by running a script or passing a partial document.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the <code>index</code> or <code>write</code> index privilege for the target index or index alias.
</p>
<p>
The script can update, delete, or skip modifying the document.
The API also supports passing a partial document, which is merged into the existing document.
To fully replace an existing document, use the index API.
This operation:
</p>
<ul><li>
<p>
Gets the document (collocated with the shard) from the index.
</p>
</li><li>
<p>
Runs the specified script.
</p>
</li><li>
<p>
Indexes the result.
</p>
</li></ul>
<p>
The document must still be reindexed, but using this API removes some network roundtrips and reduces chances of version conflicts between the GET and the index operation.
</p>
<p>
The <code>_source</code> field must be enabled to use this API.
In addition to <code>_source</code>, you can access the following variables through the <code>ctx</code> map: <code>_index</code>, <code>_type</code>, <code>_id</code>, <code>_version</code>, <code>_routing</code>, and <code>_now</code> (the current timestamp).
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-update.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual UpdateResponse&lt;TDocument&gt; Update&lt;TDocument, TPartialDocument&gt;(UpdateRequestDescriptor&lt;TDocument, TPartialDocument&gt; descriptor)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>descriptor</code> <a class="xref" href="Elastic.Clients.Elasticsearch.UpdateRequestDescriptor-2.html">UpdateRequestDescriptor</a>&lt;TDocument, TPartialDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.UpdateResponse-1.html">UpdateResponse</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
    <dt><code>TPartialDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Update_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Update*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Update__2_Elastic_Clients_Elasticsearch_UpdateRequest___0___1__" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Update``2(Elastic.Clients.Elasticsearch.UpdateRequest{``0,``1})">
  Update&lt;TDocument, TPartialDocument&gt;(UpdateRequest&lt;TDocument, TPartialDocument&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L38459"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Update a document.
</p>
<p>
Update a document by running a script or passing a partial document.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the <code>index</code> or <code>write</code> index privilege for the target index or index alias.
</p>
<p>
The script can update, delete, or skip modifying the document.
The API also supports passing a partial document, which is merged into the existing document.
To fully replace an existing document, use the index API.
This operation:
</p>
<ul><li>
<p>
Gets the document (collocated with the shard) from the index.
</p>
</li><li>
<p>
Runs the specified script.
</p>
</li><li>
<p>
Indexes the result.
</p>
</li></ul>
<p>
The document must still be reindexed, but using this API removes some network roundtrips and reduces chances of version conflicts between the GET and the index operation.
</p>
<p>
The <code>_source</code> field must be enabled to use this API.
In addition to <code>_source</code>, you can access the following variables through the <code>ctx</code> map: <code>_index</code>, <code>_type</code>, <code>_id</code>, <code>_version</code>, <code>_routing</code>, and <code>_now</code> (the current timestamp).
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-update.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual UpdateResponse&lt;TDocument&gt; Update&lt;TDocument, TPartialDocument&gt;(UpdateRequest&lt;TDocument, TPartialDocument&gt; request)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>request</code> <a class="xref" href="Elastic.Clients.Elasticsearch.UpdateRequest-2.html">UpdateRequest</a>&lt;TDocument, TPartialDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.UpdateResponse-1.html">UpdateResponse</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
    <dt><code>TPartialDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Update_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Update*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Update__2___0_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Update``2(``0)">
  Update&lt;TDocument, TPartialDocument&gt;(TDocument)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L38706"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Update a document.
</p>
<p>
Update a document by running a script or passing a partial document.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the <code>index</code> or <code>write</code> index privilege for the target index or index alias.
</p>
<p>
The script can update, delete, or skip modifying the document.
The API also supports passing a partial document, which is merged into the existing document.
To fully replace an existing document, use the index API.
This operation:
</p>
<ul><li>
<p>
Gets the document (collocated with the shard) from the index.
</p>
</li><li>
<p>
Runs the specified script.
</p>
</li><li>
<p>
Indexes the result.
</p>
</li></ul>
<p>
The document must still be reindexed, but using this API removes some network roundtrips and reduces chances of version conflicts between the GET and the index operation.
</p>
<p>
The <code>_source</code> field must be enabled to use this API.
In addition to <code>_source</code>, you can access the following variables through the <code>ctx</code> map: <code>_index</code>, <code>_type</code>, <code>_id</code>, <code>_version</code>, <code>_routing</code>, and <code>_now</code> (the current timestamp).
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-update.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual UpdateResponse&lt;TDocument&gt; Update&lt;TDocument, TPartialDocument&gt;(TDocument document)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.UpdateResponse-1.html">UpdateResponse</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
    <dt><code>TPartialDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Update_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Update*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Update__2___0_Elastic_Clients_Elasticsearch_Id_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Update``2(``0,Elastic.Clients.Elasticsearch.Id)">
  Update&lt;TDocument, TPartialDocument&gt;(TDocument, Id)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L38908"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Update a document.
</p>
<p>
Update a document by running a script or passing a partial document.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the <code>index</code> or <code>write</code> index privilege for the target index or index alias.
</p>
<p>
The script can update, delete, or skip modifying the document.
The API also supports passing a partial document, which is merged into the existing document.
To fully replace an existing document, use the index API.
This operation:
</p>
<ul><li>
<p>
Gets the document (collocated with the shard) from the index.
</p>
</li><li>
<p>
Runs the specified script.
</p>
</li><li>
<p>
Indexes the result.
</p>
</li></ul>
<p>
The document must still be reindexed, but using this API removes some network roundtrips and reduces chances of version conflicts between the GET and the index operation.
</p>
<p>
The <code>_source</code> field must be enabled to use this API.
In addition to <code>_source</code>, you can access the following variables through the <code>ctx</code> map: <code>_index</code>, <code>_type</code>, <code>_id</code>, <code>_version</code>, <code>_routing</code>, and <code>_now</code> (the current timestamp).
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-update.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual UpdateResponse&lt;TDocument&gt; Update&lt;TDocument, TPartialDocument&gt;(TDocument document, Id id)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.UpdateResponse-1.html">UpdateResponse</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
    <dt><code>TPartialDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Update_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Update*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Update__2___0_Elastic_Clients_Elasticsearch_Id_System_Action_Elastic_Clients_Elasticsearch_UpdateRequestDescriptor___0___1___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Update``2(``0,Elastic.Clients.Elasticsearch.Id,System.Action{Elastic.Clients.Elasticsearch.UpdateRequestDescriptor{``0,``1}})">
  Update&lt;TDocument, TPartialDocument&gt;(TDocument, Id, Action&lt;UpdateRequestDescriptor&lt;TDocument, TPartialDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L38958"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Update a document.
</p>
<p>
Update a document by running a script or passing a partial document.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the <code>index</code> or <code>write</code> index privilege for the target index or index alias.
</p>
<p>
The script can update, delete, or skip modifying the document.
The API also supports passing a partial document, which is merged into the existing document.
To fully replace an existing document, use the index API.
This operation:
</p>
<ul><li>
<p>
Gets the document (collocated with the shard) from the index.
</p>
</li><li>
<p>
Runs the specified script.
</p>
</li><li>
<p>
Indexes the result.
</p>
</li></ul>
<p>
The document must still be reindexed, but using this API removes some network roundtrips and reduces chances of version conflicts between the GET and the index operation.
</p>
<p>
The <code>_source</code> field must be enabled to use this API.
In addition to <code>_source</code>, you can access the following variables through the <code>ctx</code> map: <code>_index</code>, <code>_type</code>, <code>_id</code>, <code>_version</code>, <code>_routing</code>, and <code>_now</code> (the current timestamp).
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-update.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual UpdateResponse&lt;TDocument&gt; Update&lt;TDocument, TPartialDocument&gt;(TDocument document, Id id, Action&lt;UpdateRequestDescriptor&lt;TDocument, TPartialDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.UpdateRequestDescriptor-2.html">UpdateRequestDescriptor</a>&lt;TDocument, TPartialDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.UpdateResponse-1.html">UpdateResponse</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
    <dt><code>TPartialDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Update_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Update*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Update__2___0_Elastic_Clients_Elasticsearch_IndexName_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Update``2(``0,Elastic.Clients.Elasticsearch.IndexName)">
  Update&lt;TDocument, TPartialDocument&gt;(TDocument, IndexName)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L38807"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Update a document.
</p>
<p>
Update a document by running a script or passing a partial document.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the <code>index</code> or <code>write</code> index privilege for the target index or index alias.
</p>
<p>
The script can update, delete, or skip modifying the document.
The API also supports passing a partial document, which is merged into the existing document.
To fully replace an existing document, use the index API.
This operation:
</p>
<ul><li>
<p>
Gets the document (collocated with the shard) from the index.
</p>
</li><li>
<p>
Runs the specified script.
</p>
</li><li>
<p>
Indexes the result.
</p>
</li></ul>
<p>
The document must still be reindexed, but using this API removes some network roundtrips and reduces chances of version conflicts between the GET and the index operation.
</p>
<p>
The <code>_source</code> field must be enabled to use this API.
In addition to <code>_source</code>, you can access the following variables through the <code>ctx</code> map: <code>_index</code>, <code>_type</code>, <code>_id</code>, <code>_version</code>, <code>_routing</code>, and <code>_now</code> (the current timestamp).
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-update.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual UpdateResponse&lt;TDocument&gt; Update&lt;TDocument, TPartialDocument&gt;(TDocument document, IndexName index)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.UpdateResponse-1.html">UpdateResponse</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
    <dt><code>TPartialDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Update_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Update*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Update__2___0_Elastic_Clients_Elasticsearch_IndexName_System_Action_Elastic_Clients_Elasticsearch_UpdateRequestDescriptor___0___1___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Update``2(``0,Elastic.Clients.Elasticsearch.IndexName,System.Action{Elastic.Clients.Elasticsearch.UpdateRequestDescriptor{``0,``1}})">
  Update&lt;TDocument, TPartialDocument&gt;(TDocument, IndexName, Action&lt;UpdateRequestDescriptor&lt;TDocument, TPartialDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L38857"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Update a document.
</p>
<p>
Update a document by running a script or passing a partial document.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the <code>index</code> or <code>write</code> index privilege for the target index or index alias.
</p>
<p>
The script can update, delete, or skip modifying the document.
The API also supports passing a partial document, which is merged into the existing document.
To fully replace an existing document, use the index API.
This operation:
</p>
<ul><li>
<p>
Gets the document (collocated with the shard) from the index.
</p>
</li><li>
<p>
Runs the specified script.
</p>
</li><li>
<p>
Indexes the result.
</p>
</li></ul>
<p>
The document must still be reindexed, but using this API removes some network roundtrips and reduces chances of version conflicts between the GET and the index operation.
</p>
<p>
The <code>_source</code> field must be enabled to use this API.
In addition to <code>_source</code>, you can access the following variables through the <code>ctx</code> map: <code>_index</code>, <code>_type</code>, <code>_id</code>, <code>_version</code>, <code>_routing</code>, and <code>_now</code> (the current timestamp).
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-update.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual UpdateResponse&lt;TDocument&gt; Update&lt;TDocument, TPartialDocument&gt;(TDocument document, IndexName index, Action&lt;UpdateRequestDescriptor&lt;TDocument, TPartialDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.UpdateRequestDescriptor-2.html">UpdateRequestDescriptor</a>&lt;TDocument, TPartialDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.UpdateResponse-1.html">UpdateResponse</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
    <dt><code>TPartialDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Update_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Update*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Update__2___0_System_Action_Elastic_Clients_Elasticsearch_UpdateRequestDescriptor___0___1___" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Update``2(``0,System.Action{Elastic.Clients.Elasticsearch.UpdateRequestDescriptor{``0,``1}})">
  Update&lt;TDocument, TPartialDocument&gt;(TDocument, Action&lt;UpdateRequestDescriptor&lt;TDocument, TPartialDocument&gt;&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Generated/Client/ElasticsearchClient.g.cs/#L38756"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Update a document.
</p>
<p>
Update a document by running a script or passing a partial document.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the <code>index</code> or <code>write</code> index privilege for the target index or index alias.
</p>
<p>
The script can update, delete, or skip modifying the document.
The API also supports passing a partial document, which is merged into the existing document.
To fully replace an existing document, use the index API.
This operation:
</p>
<ul><li>
<p>
Gets the document (collocated with the shard) from the index.
</p>
</li><li>
<p>
Runs the specified script.
</p>
</li><li>
<p>
Indexes the result.
</p>
</li></ul>
<p>
The document must still be reindexed, but using this API removes some network roundtrips and reduces chances of version conflicts between the GET and the index operation.
</p>
<p>
The <code>_source</code> field must be enabled to use this API.
In addition to <code>_source</code>, you can access the following variables through the <code>ctx</code> map: <code>_index</code>, <code>_type</code>, <code>_id</code>, <code>_version</code>, <code>_routing</code>, and <code>_now</code> (the current timestamp).
</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.18/docs-update.html">Learn more about this API in the Elasticsearch documentation.</a></p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual UpdateResponse&lt;TDocument&gt; Update&lt;TDocument, TPartialDocument&gt;(TDocument document, Action&lt;UpdateRequestDescriptor&lt;TDocument, TPartialDocument&gt;&gt; configureRequest)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>configureRequest</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.action-1">Action</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.UpdateRequestDescriptor-2.html">UpdateRequestDescriptor</a>&lt;TDocument, TPartialDocument&gt;&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.UpdateResponse-1.html">UpdateResponse</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
    <dt><code>TPartialDocument</code></dt>
    <dd></dd>
  </dl>










  <a id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Update_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Update*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ElasticsearchClient_Update__2___0___1_Elastic_Clients_Elasticsearch_IndexName_Elastic_Clients_Elasticsearch_Id_" data-uid="Elastic.Clients.Elasticsearch.ElasticsearchClient.Update``2(``0,``1,Elastic.Clients.Elasticsearch.IndexName,Elastic.Clients.Elasticsearch.Id)">
  Update&lt;TDocument, TPartialDocument&gt;(TDocument, TPartialDocument, IndexName, Id)
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.18.3/src/Elastic.Clients.Elasticsearch/_Shared/Client/ElasticsearchClient-Manual.cs/#L13"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"></div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Obsolete(&quot;Synchronous methods are deprecated and could be removed in the future.&quot;)]
public virtual UpdateResponse&lt;TDocument&gt; Update&lt;TDocument, TPartialDocument&gt;(TDocument document, TPartialDocument partialDocument, IndexName index, Id id)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>document</code> <span class="xref">TDocument</span></dt>
    <dd></dd>
    <dt><code>partialDocument</code> <span class="xref">TPartialDocument</span></dt>
    <dd></dd>
    <dt><code>index</code> <a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
    <dd></dd>
    <dt><code>id</code> <a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.UpdateResponse-1.html">UpdateResponse</a>&lt;TDocument&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Type Parameters</h4>
  <dl class="parameters">
    <dt><code>TDocument</code></dt>
    <dd></dd>
    <dt><code>TPartialDocument</code></dt>
    <dd></dd>
  </dl>











</article>



      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
