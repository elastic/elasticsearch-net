:ref_current: https://www.elastic.co/guide/en/elasticsearch/reference/6.1

:github: https://github.com/elastic/elasticsearch-net

:nuget: https://www.nuget.org/packages

////
IMPORTANT NOTE
==============
This file has been generated from https://github.com/elastic/elasticsearch-net/tree/master/src/Tests/CodeStandards/Responses.doc.cs. 
If you wish to submit a PR for any spelling mistakes, typos or grammatical errors for this file,
please modify the original csharp file found at the link and submit the PR with that change. Thanks!
////

[[responses]]
=== Responses

Every collection property on a Response type should be either IReadOnlyCollection or IReadOnlyDictionary

[source,csharp]
----
var exceptions = new HashSet<PropertyInfo>
{
    typeof(ITypeMapping).GetProperty(nameof(ITypeMapping.DynamicDateFormats)),
    typeof(ITypeMapping).GetProperty(nameof(ITypeMapping.Meta)),
    typeof(TypeMapping).GetProperty(nameof(TypeMapping.DynamicDateFormats)),
    typeof(TypeMapping).GetProperty(nameof(TypeMapping.Meta)),
    typeof(IBulkResponse).GetProperty(nameof(IBulkResponse.ItemsWithErrors)),
    typeof(IFieldCapabilitiesResponse).GetProperty(nameof(IFieldCapabilitiesResponse.Fields)),
    typeof(IMultiSearchResponse).GetProperty(nameof(IMultiSearchResponse.AllResponses)),
};

var responseInterfaceTypes = from t in typeof(IResponse).Assembly().Types()
                    where t.IsInterface() && typeof(IResponse).IsAssignableFrom(t)
                    select t;

var ruleBreakers = new List<string>();
var seenTypes = new HashSet<Type>();
foreach (var responseType in responseInterfaceTypes)
{
    FindPropertiesBreakingRule(responseType, exceptions, seenTypes, ruleBreakers);
}

ruleBreakers.Should().BeEmpty();

if (!seenTypes.Add(type)) return;

var properties = type.GetProperties();
foreach (var propertyInfo in properties)
{
    if (exceptions.Contains(propertyInfo))
        continue;

    if (typeof(IDictionary).IsAssignableFrom(propertyInfo.PropertyType) ||
        typeof(ICollection).IsAssignableFrom(propertyInfo.PropertyType))
    {
        ruleBreakers.Add($"{type.FullName}.{propertyInfo.Name} is of type {propertyInfo.PropertyType.Name}");
    }
    else if (propertyInfo.PropertyType.IsGenericType())
    {
        var genericTypeDefinition = propertyInfo.PropertyType.GetGenericTypeDefinition();
        if (genericTypeDefinition == typeof(IDictionary<,>) ||
            genericTypeDefinition == typeof(Dictionary<,>) ||
            genericTypeDefinition == typeof(IEnumerable<>) ||
            genericTypeDefinition == typeof(IList<>) ||
            genericTypeDefinition == typeof(ICollection<>))
        {
            ruleBreakers.Add($"{type.FullName}.{propertyInfo.Name} is of type {propertyInfo.PropertyType.Name}");
        }
    }
    else if (propertyInfo.PropertyType.IsClass() &&
             (propertyInfo.PropertyType.Namespace.StartsWith("Nest") || propertyInfo.PropertyType.Namespace.StartsWith("Elasticsearch.Net"))
             //Do not traverse known response dictionaries
             && !ResponseDictionaries.Contains(propertyInfo.PropertyType)
    )
    {
        FindPropertiesBreakingRule(propertyInfo.PropertyType, exceptions, seenTypes, ruleBreakers);
    }
}
----

