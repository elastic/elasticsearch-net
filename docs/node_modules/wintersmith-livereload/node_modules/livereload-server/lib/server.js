// Generated by CoffeeScript 1.3.3
(function() {
  var DefaultWebSocketPort, EventEmitter, LRWebSocketConnection, LRWebSocketServer, Url, debug, fs, http, wsio,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  debug = require('debug')('livereload:server');

  wsio = require('websocket.io');

  http = require('http');

  Url = require('url');

  fs = require('fs');

  EventEmitter = require('events').EventEmitter;

  LRWebSocketConnection = require('./connection');

  DefaultWebSocketPort = parseInt(process.env['LRPortOverride'], 10) || 35729;

  LRWebSocketServer = (function(_super) {

    __extends(LRWebSocketServer, _super);

    function LRWebSocketServer(options) {
      var _base, _ref;
      this.options = options;
      if (!this.options.id) {
        throw new Error("ERR_INVALID_ARG: id is required");
      }
      if (!this.options.name) {
        throw new Error("ERR_INVALID_ARG: name is required");
      }
      if (!this.options.version) {
        throw new Error("ERR_INVALID_ARG: version is required");
      }
      this.port = this.options.port || DefaultWebSocketPort;
      this.connections = {};
      this.activeConnections = 0;
      this.nextConnectionId = 1;
      if ((_ref = (_base = this.options).protocols) == null) {
        _base.protocols = {};
      }
    }

    LRWebSocketServer.prototype.listen = function(callback) {
      var callbackCalled,
        _this = this;
      callbackCalled = false;
      this.httpServer = http.createServer();
      try {
        this.httpServer.on('error', function(err) {
          if (!callbackCalled) {
            callbackCalled = true;
            return callback(err);
          } else {
            throw err;
          }
        });
        return this.httpServer.listen(this.port, function(err) {
          if (err) {
            callbackCalled = true;
            return callback(err);
          }
          _this.httpServer.on('request', function(request, response) {
            request.on('data', function() {});
            return request.on('end', function() {
              var url;
              url = Url.parse(request.url, true);
              if (url.pathname === '/livereload.js' || url.pathname === '/xlivereload.js') {
                return _this.emit('livereload.js', request, response);
              } else {
                return _this.emit('httprequest', url, request, response);
              }
            });
          });
          _this.wsserver = wsio.attach(_this.httpServer);
          _this.wsserver.on('connection', function(socket) {
            return _this._createConnection(socket);
          });
          return callback(null);
        });
      } catch (e) {
        return callback(e);
      }
    };

    LRWebSocketServer.prototype.close = function() {
      var connection, _, _ref;
      this.httpServer.close();
      _ref = this.connections;
      for (_ in _ref) {
        if (!__hasProp.call(_ref, _)) continue;
        connection = _ref[_];
        connection.close();
      }
    };

    LRWebSocketServer.prototype.monitoringConnections = function() {
      var connection, dummy, _ref, _results;
      _ref = this.connections;
      _results = [];
      for (dummy in _ref) {
        if (!__hasProp.call(_ref, dummy)) continue;
        connection = _ref[dummy];
        if (connection.isMonitoring()) {
          _results.push(connection);
        }
      }
      return _results;
    };

    LRWebSocketServer.prototype.monitoringConnectionCount = function() {
      return this.monitoringConnections().length;
    };

    LRWebSocketServer.prototype._createConnection = function(socket) {
      var connection,
        _this = this;
      connection = new LRWebSocketConnection(socket, "C" + (this.nextConnectionId++), this.options);
      connection.on('connected', function() {
        _this.connections[connection.id] = connection;
        return _this.emit('connected', connection);
      });
      connection.on('disconnected', function() {
        delete _this.connections[connection.id];
        return _this.emit('disconnected', connection);
      });
      connection.on('command', function(command) {
        return _this.emit('command', connection, command);
      });
      connection.on('error', function(err) {
        return _this.emit('error', err, connection);
      });
      return connection;
    };

    return LRWebSocketServer;

  })(EventEmitter);

  module.exports = LRWebSocketServer;

}).call(this);
