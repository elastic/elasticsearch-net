Abstract class names should end with a `Base` suffix

[source, csharp]
----
var exceptions = new[]
			{
				typeof(DateMath)
			};
var abstractClasses = typeof(IRequest).Assembly().GetTypes()
				.Where(t => t.IsClass() && t.IsAbstract() && !t.IsSealed() && !exceptions.Contains(t))
				.Where(t => !t.Name.Split('`')[0].EndsWith("Base"))
				.Select(t => t.Name.Split('`')[0])
				.ToList();
abstractClasses.Should().BeEmpty();
var exceptions = new[] { typeof(DateMath) };
var baseClassesNotAbstract = typeof(IRequest).Assembly().GetTypes()
				.Where(t => t.IsClass() && !exceptions.Contains(t))
				.Where(t => t.Name.Split('`')[0].EndsWith("Base"))
				.Where(t => !t.IsAbstractClass())
				.Select(t => t.Name.Split('`')[0])
				.ToList();
baseClassesNotAbstract.Should().BeEmpty();
----
Request class names should end with "Request"

[source, csharp]
----
var types = typeof(IRequest).Assembly().GetTypes();
var requests = types
				.Where(t => typeof(IRequest).IsAssignableFrom(t) && !t.IsAbstract())
				.Where(t => !typeof(IDescriptor).IsAssignableFrom(t))
				.Where(t => !t.Name.Split('`')[0].EndsWith("Request"))
				.Select(t => t.Name.Split('`')[0])
				.ToList();
requests.Should().BeEmpty();
----
Response class names should end with "Response"

[source, csharp]
----
var types = typeof(IRequest).Assembly().GetTypes();
var responses = types
				.Where(t => typeof(IResponse).IsAssignableFrom(t) && !t.IsAbstract())
				.Where(t => !t.Name.Split('`')[0].EndsWith("Response"))
				.Select(t => t.Name.Split('`')[0])
				.ToList();
responses.Should().BeEmpty();
----
Request and Response class names should be one to one in *most* cases.
e.g. ValidateRequest => ValidateResponse, and not ValidateQueryRequest => ValidateResponse

[source, csharp]
----
var exceptions = new[]
			{
				typeof(CatAliasesRequest),
				typeof(CatAllocationRequest),
				typeof(CatCountRequest),
				typeof(CatFielddataRequest),
				typeof(CatHealthRequest),
				typeof(CatHelpRequest),
				typeof(CatIndicesRequest),
				typeof(CatMasterRequest),
				typeof(CatNodesRequest),
				typeof(CatPendingTasksRequest),
				typeof(CatPluginsRequest),
				typeof(CatRecoveryRequest),
				typeof(CatSegmentsRequest),
				typeof(CatShardsRequest),
				typeof(CatThreadPoolRequest),
				typeof(DocumentExistsRequest),
				typeof(DocumentExistsRequest<>),
				typeof(AliasExistsRequest),
				typeof(IndexExistsRequest),
				typeof(TypeExistsRequest),
				typeof(IndexTemplateExistsRequest),
				typeof(SearchExistsRequest),
				typeof(SearchExistsRequest<>),
				typeof(SearchTemplateRequest),
				typeof(SearchTemplateRequest<>),
				typeof(ScrollRequest),
				typeof(SourceRequest),
				typeof(SourceRequest<>),

				typeof(ValidateQueryRequest<>),

				typeof(GetAliasRequest),
				typeof(CatNodeattrsRequest),
				typeof(IndicesShardStoresRequest),
				typeof(RenderSearchTemplateRequest)
			};
var types = typeof(IRequest).Assembly().GetTypes();
var requests = new HashSet<string>(types
				.Where(t =>
					t.IsClass() &&
					!t.IsAbstract() &&
					typeof(IRequest).IsAssignableFrom(t) &&
					!typeof(IDescriptor).IsAssignableFrom(t)
					&& !exceptions.Contains(t))
				.Select(t => t.Name.Split('`')[0].Replace("Request", ""))
			);
var responses = types
				.Where(t => t.IsClass() && !t.IsAbstract() && typeof(IResponse).IsAssignableFrom(t))
				.Select(t => t.Name.Split('`')[0].Replace("Response", ""));
requests.Except(responses).Should().BeEmpty();
----
