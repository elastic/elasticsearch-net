:ref_current: https://www.elastic.co/guide/en/elasticsearch/reference/current

:github: https://github.com/elastic/elasticsearch-net

:imagesdir: ../../../images

== Filters Aggregation

Defines a multi bucket aggregations where each bucket is associated with a filter. 
Each bucket will collect all documents that match its associated filter. For documents
that do not match any filter, these will be collected in the other bucket.

Be sure to read the elasticsearch documentation {ref_current}/search-aggregations-bucket-filters-aggregation.html[on this subject here]

== Named filters 

[source,javascript,method-name="expectjson"]
.Example json output
----
{
  "aggs": {
    "projects_by_state": {
      "filters": {
        "other_bucket": true,
        "other_bucket_key": "other_states_of_being",
        "filters": {
          "belly_up": {
            "term": {
              "state": {
                "value": "BellyUp"
              }
            }
          },
          "stable": {
            "term": {
              "state": {
                "value": "Stable"
              }
            }
          },
          "very_active": {
            "term": {
              "state": {
                "value": "VeryActive"
              }
            }
          }
        }
      },
      "aggs": {
        "project_tags": {
          "terms": {
            "field": "curatedTags.name"
          }
        }
      }
    }
  }
}
----

=== Fluent DSL Example

[source,csharp,method-name="fluent"]
----
s => s
.Aggregations(aggs => aggs
	.Filters("projects_by_state", agg => agg
		.OtherBucket()
		.OtherBucketKey("other_states_of_being")
		.NamedFilters(filters => filters
			.Filter("belly_up", f => f.Term(p => p.State, StateOfBeing.BellyUp))
			.Filter("stable", f => f.Term(p => p.State, StateOfBeing.Stable))
			.Filter("very_active", f => f.Term(p => p.State, StateOfBeing.VeryActive))
		)
		.Aggregations(childAggs => childAggs
			.Terms("project_tags", avg => avg.Field(p => p.CuratedTags.First().Name))
		)
	)
)
----

=== Object Initializer Syntax Example

[source,csharp,method-name="initializer"]
----
new SearchRequest<Project>
{
	Aggregations = new FiltersAggregation("projects_by_state")
	{
		OtherBucket = true,
		OtherBucketKey = "other_states_of_being",
		Filters = new NamedFiltersContainer
		{
				{ "belly_up", Query<Project>.Term(p=>p.State, StateOfBeing.BellyUp) },
				{ "stable", Query<Project>.Term(p=>p.State, StateOfBeing.Stable) },
				{ "very_active", Query<Project>.Term(p=>p.State, StateOfBeing.VeryActive) }
		},
		Aggregations =
			new TermsAggregation("project_tags") { Field = Field<Project>(p => p.CuratedTags.First().Name) }
	}
}
----

=== Handling Responses

Using the `.Agg` aggregation helper we can fetch our aggregation results easily 
in the correct type. [Be sure to read more about `.Agg` vs `.Aggregations` on the response here]()

[source,csharp,method-name="expectresponse"]
----
response.IsValid.Should().BeTrue();

var filterAgg = response.Aggs.Filters("projects_by_state");
filterAgg.Should().NotBeNull();
var namedResult = filterAgg.NamedBucket("belly_up");
namedResult.Should().NotBeNull();
namedResult.DocCount.Should().BeGreaterThan(0);
namedResult = filterAgg.NamedBucket("stable");
namedResult.Should().NotBeNull();
namedResult.DocCount.Should().BeGreaterThan(0);
namedResult = filterAgg.NamedBucket("very_active");
namedResult.Should().NotBeNull();
namedResult.DocCount.Should().BeGreaterThan(0);
namedResult = filterAgg.NamedBucket("other_states_of_being");
namedResult.Should().NotBeNull();
namedResult.DocCount.Should().Be(0);
----

== Anonymous filters 

[source,javascript,method-name="expectjson"]
.Example json output
----
{
  "aggs": {
    "projects_by_state": {
      "filters": {
        "other_bucket": true,
        "filters": [
          {
            "term": {
              "state": {
                "value": "BellyUp"
              }
            }
          },
          {
            "term": {
              "state": {
                "value": "Stable"
              }
            }
          },
          {
            "term": {
              "state": {
                "value": "VeryActive"
              }
            }
          }
        ]
      },
      "aggs": {
        "project_tags": {
          "terms": {
            "field": "curatedTags.name"
          }
        }
      }
    }
  }
}
----

=== Fluent DSL Example

[source,csharp,method-name="fluent"]
----
s => s
.Aggregations(aggs => aggs
	.Filters("projects_by_state", agg => agg
		.OtherBucket()
		.AnonymousFilters(
			f => f.Term(p => p.State, StateOfBeing.BellyUp),
			f => f.Term(p => p.State, StateOfBeing.Stable),
			f => f.Term(p => p.State, StateOfBeing.VeryActive)
		)
		.Aggregations(childAggs => childAggs
			.Terms("project_tags", avg => avg.Field(p => p.CuratedTags.First().Name))
		)
	)
)
----

=== Object Initializer Syntax Example

[source,csharp,method-name="initializer"]
----
new SearchRequest<Project>
{
	Aggregations = new FiltersAggregation("projects_by_state")
	{
		OtherBucket = true,
		Filters = new List<QueryContainer>
		{
			Query<Project>.Term(p=>p.State, StateOfBeing.BellyUp) ,
			Query<Project>.Term(p=>p.State, StateOfBeing.Stable) ,
			Query<Project>.Term(p=>p.State, StateOfBeing.VeryActive)
		},
		Aggregations =
			new TermsAggregation("project_tags")
			{
				Field = Field<Project>(p => p.CuratedTags.First().Name)
			}
	}
}
----

=== Handling Responses

Using the `.Agg` aggregation helper we can fetch our aggregation results easily 
in the correct type. [Be sure to read more about `.Agg` vs `.Aggregations` on the response here]()

[source,csharp,method-name="expectresponse"]
----
response.IsValid.Should().BeTrue();

var filterAgg = response.Aggs.Filters("projects_by_state");
filterAgg.Should().NotBeNull();
var results = filterAgg.AnonymousBuckets();
results.Count.Should().Be(4);
singleBucket.DocCount.Should().BeGreaterThan(0);
results.Last().DocCount.Should().Be(0);
----

== Empty Filters 

[source,javascript,method-name="expectjson"]
.Example json output
----
{
  "aggs": {
    "empty_filters": {
      "filters": {
        "filters": []
      }
    }
  }
}
----

=== Fluent DSL Example

[source,csharp,method-name="fluent"]
----
s => s
.Aggregations(aggs => aggs
	.Filters("empty_filters", agg => agg
		.AnonymousFilters()
	)
)
----

=== Object Initializer Syntax Example

[source,csharp,method-name="initializer"]
----
new SearchRequest<Project>
{
	Aggregations = new FiltersAggregation("empty_filters")
	{
		Filters = new List<QueryContainer>()
	}
}
----

=== Handling Responses

[source,csharp,method-name="expectresponse"]
----
response.IsValid.Should().BeTrue();
response.Aggs.Filters("empty_filters").Buckets.Should().BeEmpty();
----

== Conditionless Filters 

[source,javascript,method-name="expectjson"]
.Example json output
----
{
  "aggs": {
    "conditionless_filters": {
      "filters": {
        "filters": []
      }
    }
  }
}
----

=== Fluent DSL Example

[source,csharp,method-name="fluent"]
----
s => s
.Aggregations(aggs => aggs
	.Filters("conditionless_filters", agg => agg
		.AnonymousFilters(
			q => new QueryContainer()
		)
	)
)
----

=== Object Initializer Syntax Example

[source,csharp,method-name="initializer"]
----
new SearchRequest<Project>
{
	Aggregations = new FiltersAggregation("conditionless_filters")
	{
		Filters = new List<QueryContainer>
		{
			new QueryContainer()
		}
	}
}
----

=== Handling Responses

[source,csharp,method-name="expectresponse"]
----
response.IsValid.Should().BeTrue();
response.Aggs.Filters("conditionless_filters").Buckets.Should().BeEmpty();
----

