:ref_current: https://www.elastic.co/guide/en/elasticsearch/reference/current

:github: https://github.com/elastic/elasticsearch-net

:nuget: https://www.nuget.org/packages

[[filters-aggregation-usage]]
== Filters Aggregation Usage

Defines a multi bucket aggregations where each bucket is associated with a filter. 
Each bucket will collect all documents that match its associated filter. For documents
that do not match any filter, these will be collected in the _other bucket_.

Be sure to read the Elasticsearch documentation {ref_current}/search-aggregations-bucket-filters-aggregation.html[Filters Aggregation]

[[named-filters]]
[float]
== Named filters 

=== Fluent DSL Example

[source,csharp]
----
s => s
.Aggregations(aggs => aggs
    .Filters("projects_by_state", agg => agg
        .OtherBucket()
        .OtherBucketKey("other_states_of_being")
        .NamedFilters(filters => filters
            .Filter("belly_up", f => f.Term(p => p.State, StateOfBeing.BellyUp))
            .Filter("stable", f => f.Term(p => p.State, StateOfBeing.Stable))
            .Filter("very_active", f => f.Term(p => p.State, StateOfBeing.VeryActive))
        )
        .Aggregations(childAggs => childAggs
            .Terms("project_tags", avg => avg.Field(p => p.CuratedTags.First().Name))
        )
    )
)
----

=== Object Initializer Syntax Example

[source,csharp]
----
new SearchRequest<Project>
{
    Aggregations = new FiltersAggregation("projects_by_state")
    {
        OtherBucket = true,
        OtherBucketKey = "other_states_of_being",
        Filters = new NamedFiltersContainer
        {
            { "belly_up", Query<Project>.Term(p=>p.State, StateOfBeing.BellyUp) },
            { "stable", Query<Project>.Term(p=>p.State, StateOfBeing.Stable) },
            { "very_active", Query<Project>.Term(p=>p.State, StateOfBeing.VeryActive) }
        },
        Aggregations =
            new TermsAggregation("project_tags") { Field = Field<Project>(p => p.CuratedTags.First().Name) }
    }
}
----

[source,javascript]
.Example json output
----
{
  "aggs": {
    "projects_by_state": {
      "filters": {
        "other_bucket": true,
        "other_bucket_key": "other_states_of_being",
        "filters": {
          "belly_up": {
            "term": {
              "state": {
                "value": "BellyUp"
              }
            }
          },
          "stable": {
            "term": {
              "state": {
                "value": "Stable"
              }
            }
          },
          "very_active": {
            "term": {
              "state": {
                "value": "VeryActive"
              }
            }
          }
        }
      },
      "aggs": {
        "project_tags": {
          "terms": {
            "field": "curatedTags.name"
          }
        }
      }
    }
  }
}
----

=== Handling Responses

Using the `.Agg` aggregation helper we can fetch our aggregation results easily 
in the correct type. <<aggs-vs-aggregations, Be sure to read more about .Aggs vs .Aggregations>>

[source,csharp]
----
response.IsValid.Should().BeTrue();

var filterAgg = response.Aggs.Filters("projects_by_state");
filterAgg.Should().NotBeNull();
var namedResult = filterAgg.NamedBucket("belly_up");
namedResult.Should().NotBeNull();
namedResult.DocCount.Should().BeGreaterThan(0);
namedResult = filterAgg.NamedBucket("stable");
namedResult.Should().NotBeNull();
namedResult.DocCount.Should().BeGreaterThan(0);
namedResult = filterAgg.NamedBucket("very_active");
namedResult.Should().NotBeNull();
namedResult.DocCount.Should().BeGreaterThan(0);
namedResult = filterAgg.NamedBucket("other_states_of_being");
namedResult.Should().NotBeNull();
namedResult.DocCount.Should().Be(0);
----

[[anonymous-filters]]
[float]
== Anonymous filters 

=== Fluent DSL Example

[source,csharp]
----
s => s
.Aggregations(aggs => aggs
    .Filters("projects_by_state", agg => agg
        .OtherBucket()
        .AnonymousFilters(
            f => f.Term(p => p.State, StateOfBeing.BellyUp),
            f => f.Term(p => p.State, StateOfBeing.Stable),
            f => f.Term(p => p.State, StateOfBeing.VeryActive)
        )
        .Aggregations(childAggs => childAggs
            .Terms("project_tags", avg => avg.Field(p => p.CuratedTags.First().Name))
        )
    )
)
----

=== Object Initializer Syntax Example

[source,csharp]
----
new SearchRequest<Project>
{
    Aggregations = new FiltersAggregation("projects_by_state")
    {
        OtherBucket = true,
        Filters = new List<QueryContainer>
        {
            Query<Project>.Term(p=>p.State, StateOfBeing.BellyUp) ,
            Query<Project>.Term(p=>p.State, StateOfBeing.Stable) ,
            Query<Project>.Term(p=>p.State, StateOfBeing.VeryActive)
        },
        Aggregations =
            new TermsAggregation("project_tags")
            {
                Field = Field<Project>(p => p.CuratedTags.First().Name)
            }
    }
}
----

[source,javascript]
.Example json output
----
{
  "aggs": {
    "projects_by_state": {
      "filters": {
        "other_bucket": true,
        "filters": [
          {
            "term": {
              "state": {
                "value": "BellyUp"
              }
            }
          },
          {
            "term": {
              "state": {
                "value": "Stable"
              }
            }
          },
          {
            "term": {
              "state": {
                "value": "VeryActive"
              }
            }
          }
        ]
      },
      "aggs": {
        "project_tags": {
          "terms": {
            "field": "curatedTags.name"
          }
        }
      }
    }
  }
}
----

=== Handling Responses

Using the `.Agg` aggregation helper we can fetch our aggregation results easily 
in the correct type. <<aggs-vs-aggregations, Be sure to read more about .Aggs vs .Aggregations>>

[source,csharp]
----
response.IsValid.Should().BeTrue();

var filterAgg = response.Aggs.Filters("projects_by_state");
filterAgg.Should().NotBeNull();
var results = filterAgg.AnonymousBuckets();
results.Count.Should().Be(4);
singleBucket.DocCount.Should().BeGreaterThan(0);
results.Last().DocCount.Should().Be(0); <1>
----
<1> The last bucket is the _other bucket_

[[empty-filters]]
[float]
== Empty Filters 

=== Fluent DSL Example

[source,csharp]
----
s => s
.Aggregations(aggs => aggs
    .Filters("empty_filters", agg => agg
        .AnonymousFilters()
    )
)
----

=== Object Initializer Syntax Example

[source,csharp]
----
new SearchRequest<Project>
{
    Aggregations = new FiltersAggregation("empty_filters")
    {
        Filters = new List<QueryContainer>()
    }
}
----

[source,javascript]
.Example json output
----
{
  "aggs": {
    "empty_filters": {
      "filters": {
        "filters": []
      }
    }
  }
}
----

=== Handling Responses

[source,csharp]
----
response.IsValid.Should().BeTrue();
response.Aggs.Filters("empty_filters").Buckets.Should().BeEmpty();
----

[[conditionless-filters]]
[float]
== Conditionless Filters 

=== Fluent DSL Example

[source,csharp]
----
s => s
.Aggregations(aggs => aggs
    .Filters("conditionless_filters", agg => agg
        .AnonymousFilters(
            q => new QueryContainer()
        )
    )
)
----

=== Object Initializer Syntax Example

[source,csharp]
----
new SearchRequest<Project>
{
    Aggregations = new FiltersAggregation("conditionless_filters")
    {
        Filters = new List<QueryContainer>
        {
            new QueryContainer()
        }
    }
}
----

[source,javascript]
.Example json output
----
{
  "aggs": {
    "conditionless_filters": {
      "filters": {
        "filters": []
      }
    }
  }
}
----

=== Handling Responses

[source,csharp]
----
response.IsValid.Should().BeTrue();
response.Aggs.Filters("conditionless_filters").Buckets.Should().BeEmpty();
----

