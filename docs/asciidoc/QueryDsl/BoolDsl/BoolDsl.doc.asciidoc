Writing boolean queries can grow rather verbose rather quickly using the querydsl e.g

[source, csharp]
----
var searchResults = this.Client.Search<Project>(s => s
				.Query(q => q
					.Bool(b => b
						.Should(
							bs => bs.Term(p => p.Name, "x"),
							bs => bs.Term(p => p.Name, "y")
						)
					)
				)
			);
----
now this is just a single bool with only two clauses, imagine multiple nested bools this quickly becomes an excersise in
hadouken indenting
[[indent]]
.hadouken indenting example
image::http://i.imgur.com/BtjZedW.jpg[dead indent]
For this reason NEST introduces operator overloading so complex bool queries become easier to write, the previous example will become.

[source, csharp]
----
var searchResults = this.Client.Search<Project>(s => s
				.Query(q => q.Term(p => p.Name, "x") || q.Term(p => p.Name, "y"))
			);
----
Or using the object initializer syntax 

[source, csharp]
----
searchResults = this.Client.Search<Project>(new SearchRequest<Project>
{
	Query = new TermQuery { Field = "name", Value= "x" } 
		|| new TermQuery { Field = Field<Project>(p=>p.Name), Value = "y" }
});
----
A naive implementation of operator overloading would rewrite
`term&&term&&term` to
bool
must
term
bool
must
term
term
As you can image this becomes unwieldy quite fast the more complex a query becomes NEST can spot these and
join them together to become a single bool query
bool
must
term
term
term

The bool DSL offers also a short hand notation to mark a query as a must_not using !

And to mark a query as a filter using +

Both of these can be combined with ands to a single bool query

When combining multiple queries some or all possibly marked as must_not or filter NEST still combines to a single bool query
bool
must
term
term
term
must_not
term

[source, csharp]
----
Assert(
				q => q.Query() && q.Query() && q.Query() && !q.Query(),
				Query && Query && Query && !Query,
				c=>
				{
					c.Bool.Must.Should().HaveCount(3);
					c.Bool.MustNot.Should().HaveCount(1);
				});
c.Bool.Must.Should().HaveCount(3);
c.Bool.MustNot.Should().HaveCount(1);
----
Even more involved `term&&term&&term&&!term&&+term&&+term` still only results in a single bool query:
bool
must
term
term
term
must_not
term
filter
term
term

You can still mix and match actual bool queries with the bool dsl e.g
`bool(must=term, term, term)&&!term`
it would still merge into a single bool query.

[source, csharp]
----
c.Bool.Should.Should().HaveCount(2);
var nestedBool = c.Bool.Should.Cast<IQueryContainer>().First(b=>!string.IsNullOrEmpty(b.Bool?.Name));
nestedBool.Bool.Should.Should().HaveCount(1);
nestedBool.Bool.Name.Should().Be(firstName);
assert(fluent.InvokeQuery(new QueryContainerDescriptor<Project>()));
assert((QueryContainer)ois);
----
