[[nest-basics]]
== Search

[float]
=== From / Size

Pagination can be done using `From()` and `Size()`:

[source,csharp]
----
.From(0)
.Size(50)
----

Alternatively,

[source,csharp]
----
.Skip(0)
.Take(50)
----

can also be used.

[float]
=== Indices / Types

NEST will automatically infer the index to search based on the type specified:

[source,csharp]
----
client.Search<MyObject>(s => s
    ...
)
----

If `MyObject` has not been mapped to an index, then the default index will be used.

You can override type inferrence by explicitly specifying the index to search on:

[source,csharp]
----
client.Search<MyObject>(s => s.
    .Index("Index_A")
    ...
)
----

Remember that since Elasticsearch 0.19.8 you can also specify wildcards on index names:

[source,csharp]
----
client.Search<MyObject>(s => s
    .Index("Index_*")
    ...
)
.Types(new [] { typeof(ElasticSearchProject)})
----

You can also tell NEST to search multiple indices:

[source,csharp]
----
client.Search<MyObject>(s => s
    .Indices(new [] {"Index_A", "Index_B"})
    ...
)
----

Or you can search across all indices

[source,csharp]
----
client.Search<MyObject>(s => s
    .AllIndices()
    ...
)
----

[float]
=== Covariance

You can make C# covariance work for you by typing the search to a common base class (can be `object`)

i.e:

[source,csharp]
----
.Search<object>(s => s
    .Types(typeof(Product), typeof(Category), typeof(Manufacturer))
    .Query(q => ...)
);
----

This will search on `/yourdefaultindex/products,categories,manufacturers/_search` and setup a 
default `ConcreteTypeSelector` that understands what type each returned document is.

Using 

[source,csharp]
----
.ConcreteTypeSelector(Func<dynamic, Hit<dynamic>, Type>)
----

you can manually specify the type of each hit based on some JSON value (on dynamic) or on the hit metadata.

[float]
=== Routing

You can specify the routing for the search request using 

[source,csharp]
----
.Routing("routevalue")
----

