<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Namespace Elastic.Clients.Elasticsearch | Elasticsearch.NET </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Namespace Elastic.Clients.Elasticsearch | Elasticsearch.NET ">
      
      
      <link rel="icon" href="../favicon.ico">
      <link rel="stylesheet" href="../public/docfx.min.css">
      <link rel="stylesheet" href="../public/main.css">
      <meta name="docfx:navrel" content="../toc.html">
      <meta name="docfx:tocrel" content="toc.html">
      
      <meta name="docfx:rel" content="../">
      
      
      
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="ManagedReference">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../index.html">
            <img id="logo" class="svg" src="../images/logo.svg" alt="Elasticsearch.NET">
            Elasticsearch.NET
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="Elastic.Clients.Elasticsearch">

  <h1 id="Elastic_Clients_Elasticsearch" data-uid="Elastic.Clients.Elasticsearch" class="text-break">Namespace Elastic.Clients.Elasticsearch</h1>
  <div class="markdown level0 summary"></div>
  <div class="markdown level0 conceptual"></div>
  <div class="markdown level0 remarks"></div>

    <h3 id="classes">
Classes
</h3>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.BlockingSubscribeExtensions.html">BlockingSubscribeExtensions</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.BulkAllObservable-1.html">BulkAllObservable&lt;T&gt;</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.BulkAllObserver.html">BulkAllObserver</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.BulkAllRequestDescriptor-1.html">BulkAllRequestDescriptor&lt;T&gt;</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.BulkAllRequest-1.html">BulkAllRequest&lt;T&gt;</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.BulkAllResponse.html">BulkAllResponse</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.BulkIndexByScrollFailure.html">BulkIndexByScrollFailure</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.BulkRequest.html">BulkRequest</a></dt>
      <dd><p>
Bulk index or delete documents.
Perform multiple <code>index</code>, <code>create</code>, <code>delete</code>, and <code>update</code> actions in a single request.
This reduces overhead and can greatly increase indexing speed.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or index alias:
</p>
<ul><li>
<p>
To use the <code>create</code> action, you must have the <code>create_doc</code>, <code>create</code>, <code>index</code>, or <code>write</code> index privilege. Data streams support only the <code>create</code> action.
</p>
</li><li>
<p>
To use the <code>index</code> action, you must have the <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To use the <code>delete</code> action, you must have the <code>delete</code> or <code>write</code> index privilege.
</p>
</li><li>
<p>
To use the <code>update</code> action, you must have the <code>index</code> or <code>write</code> index privilege.
</p>
</li><li>
<p>
To automatically create a data stream or index with a bulk API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege.
</p>
</li><li>
<p>
To make the result of a bulk operation visible to search using the <code>refresh</code> parameter, you must have the <code>maintenance</code> or <code>manage</code> index privilege.
</p>
</li></ul>
<p>
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
The actions are specified in the request body using a newline delimited JSON (NDJSON) structure:
</p>
<pre><code class="lang-csharp">action_and_meta_data\n
optional_source\n
action_and_meta_data\n
optional_source\n
....
action_and_meta_data\n
optional_source\n</code></pre>
<p>
The <code>index</code> and <code>create</code> actions expect a source on the next line and have the same semantics as the <code>op_type</code> parameter in the standard index API.
A <code>create</code> action fails if a document with the same ID already exists in the target
An <code>index</code> action adds or replaces a document as necessary.
</p>
<p>
NOTE: Data streams support only the <code>create</code> action.
To update or delete a document in a data stream, you must target the backing index containing the document.
</p>
<p>
An <code>update</code> action expects that the partial doc, upsert, and script and its options are specified on the next line.
</p>
<p>
A <code>delete</code> action does not expect a source on the next line and has the same semantics as the standard delete API.
</p>
<p>
NOTE: The final line of data must end with a newline character (<code>\n</code>).
Each newline character may be preceded by a carriage return (<code>\r</code>).
When sending NDJSON data to the <code>_bulk</code> endpoint, use a <code>Content-Type</code> header of <code>application/json</code> or <code>application/x-ndjson</code>.
Because this format uses literal newline characters (<code>\n</code>) as delimiters, make sure that the JSON actions and sources are not pretty printed.
</p>
<p>
If you provide a target in the request path, it is used for any actions that don't explicitly specify an <code>_index</code> argument.
</p>
<p>
A note on the format: the idea here is to make processing as fast as possible.
As some of the actions are redirected to other shards on other nodes, only <code>action_meta_data</code> is parsed on the receiving node side.
</p>
<p>
Client libraries using this protocol should try and strive to do something similar on the client side, and reduce buffering as much as possible.
</p>
<p>
There is no "correct" number of actions to perform in a single bulk request.
Experiment with different settings to find the optimal size for your particular workload.
Note that Elasticsearch limits the maximum size of a HTTP request to 100mb by default so clients must ensure that no request exceeds this size.
It is not possible to index a single document that exceeds the size limit, so you must pre-process any such documents into smaller pieces before sending them to Elasticsearch.
For instance, split documents into pages or chapters before indexing them, or store raw binary data in a system outside Elasticsearch and replace the raw data with a link to the external system in the documents that you send to Elasticsearch.
</p>
<p>
<strong>Client suppport for bulk requests</strong>
</p>
<p>
Some of the officially supported clients provide helpers to assist with bulk requests and reindexing:
</p>
<ul><li>
<p>
Go: Check out <code>esutil.BulkIndexer</code>
</p>
</li><li>
<p>
Perl: Check out <code>Search::Elasticsearch::Client::5_0::Bulk</code> and <code>Search::Elasticsearch::Client::5_0::Scroll</code>
</p>
</li><li>
<p>
Python: Check out <code>elasticsearch.helpers.*</code>
</p>
</li><li>
<p>
JavaScript: Check out <code>client.helpers.*</code>
</p>
</li><li>
<p>
.NET: Check out <code>BulkAllObservable</code>
</p>
</li><li>
<p>
PHP: Check out bulk indexing.
</p>
</li></ul>
<p>
<strong>Submitting bulk requests with cURL</strong>
</p>
<p>
If you're providing text file input to <code>curl</code>, you must use the <code>--data-binary</code> flag instead of plain <code>-d</code>.
The latter doesn't preserve newlines. For example:
</p>
<pre><code class="lang-csharp">$ cat requests
{ "index" : { "_index" : "test", "_id" : "1" } }
{ "field1" : "value1" }
$ curl -s -H "Content-Type: application/x-ndjson" -XPOST localhost:9200/_bulk --data-binary "@requests"; echo
{"took":7, "errors": false, "items":[{"index":{"_index":"test","_id":"1","_version":1,"result":"created","forced_refresh":false}}]}</code></pre>
<p>
<strong>Optimistic concurrency control</strong>
</p>
<p>
Each <code>index</code> and <code>delete</code> action within a bulk API call may include the <code>if_seq_no</code> and <code>if_primary_term</code> parameters in their respective action and meta data lines.
The <code>if_seq_no</code> and <code>if_primary_term</code> parameters control how operations are run, based on the last modification to existing documents. See Optimistic concurrency control for more details.
</p>
<p>
<strong>Versioning</strong>
</p>
<p>
Each bulk item can include the version value using the <code>version</code> field.
It automatically follows the behavior of the index or delete operation based on the <code>_version</code> mapping.
It also support the <code>version_type</code>.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
Each bulk item can include the routing value using the <code>routing</code> field.
It automatically follows the behavior of the index or delete operation based on the <code>_routing</code> mapping.
</p>
<p>
NOTE: Data streams do not support custom routing unless they were created with the <code>allow_custom_routing</code> setting enabled in the template.
</p>
<p>
<strong>Wait for active shards</strong>
</p>
<p>
When making bulk calls, you can set the <code>wait_for_active_shards</code> parameter to require a minimum number of shard copies to be active before starting to process the bulk request.
</p>
<p>
<strong>Refresh</strong>
</p>
<p>
Control when the changes made by this request are visible to search.
</p>
<p>
NOTE: Only the shards that receive the bulk request will be affected by refresh.
Imagine a <code>_bulk?refresh=wait_for</code> request with three documents in it that happen to be routed to different shards in an index with five shards.
The request will only wait for those three shards to refresh.
The other two shards that make up the index do not participate in the <code>_bulk</code> request at all.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.BulkRequestParameters.html">BulkRequestParameters</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.BulkResponse.html">BulkResponse</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.BulkStats.html">BulkStats</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ByteSize.html">ByteSize</a></dt>
      <dd><p><a href="https://www.elastic.co/docs/reference/elasticsearch/rest-apis/api-conventions#byte-units">Learn more about this API in the Elasticsearch documentation.</a></p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ClearScrollRequest.html">ClearScrollRequest</a></dt>
      <dd><p>
Clear a scrolling search.
Clear the search context and results for a scrolling search.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ClearScrollRequestParameters.html">ClearScrollRequestParameters</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ClearScrollResponse.html">ClearScrollResponse</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ClosePointInTimeRequest.html">ClosePointInTimeRequest</a></dt>
      <dd><p>
Close a point in time.
A point in time must be opened explicitly before being used in search requests.
The <code>keep_alive</code> parameter tells Elasticsearch how long it should persist.
A point in time is automatically closed when the <code>keep_alive</code> period has elapsed.
However, keeping points in time has a cost; close them as soon as they are no longer required for search requests.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ClosePointInTimeRequestParameters.html">ClosePointInTimeRequestParameters</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ClosePointInTimeResponse.html">ClosePointInTimeResponse</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ClrTypeMapping.html">ClrTypeMapping</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ClrTypeMappingDescriptor.html">ClrTypeMappingDescriptor</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ClrTypeMappingDescriptor-1.html">ClrTypeMappingDescriptor&lt;TDocument&gt;</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ClrTypeMapping-1.html">ClrTypeMapping&lt;TDocument&gt;</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ClusterDetails.html">ClusterDetails</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ClusterStatistics.html">ClusterStatistics</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.CompletionStats.html">CompletionStats</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ConnectionConfiguration.html">ConnectionConfiguration</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.CoordinatedRequestObserverBase-1.html">CoordinatedRequestObserverBase&lt;T&gt;</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.CoordsGeoBounds.html">CoordsGeoBounds</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.CountRequest.html">CountRequest</a></dt>
      <dd><p>
Count search results.
Get the number of documents matching a query.
</p>
<p>
The query can be provided either by using a simple query string as a parameter, or by defining Query DSL within the request body.
The query is optional. When no query is provided, the API uses <code>match_all</code> to count all the documents.
</p>
<p>
The count API supports multi-target syntax. You can run a single count API search across multiple data streams and indices.
</p>
<p>
The operation is broadcast across all shards.
For each shard ID group, a replica is chosen and the search is run against it.
This means that replicas increase the scalability of the count.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.CountRequestParameters.html">CountRequestParameters</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.CountRequest-1.html">CountRequest&lt;TDocument&gt;</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.CountResponse.html">CountResponse</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.CreateRequestParameters.html">CreateRequestParameters</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.CreateRequest-1.html">CreateRequest&lt;TDocument&gt;</a></dt>
      <dd><p>
Create a new document in the index.
</p>
<p>
You can index a new JSON document with the <code>/&lt;target&gt;/_doc/</code> or <code>/&lt;target&gt;/_create/&lt;_id&gt;</code> APIs
Using <code>_create</code> guarantees that the document is indexed only if it does not already exist.
It returns a 409 response when a document with a same ID already exists in the index.
To update an existing document, you must use the <code>/&lt;target&gt;/_doc/</code> API.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or index alias:
</p>
<ul><li>
<p>
To add a document using the <code>PUT /&lt;target&gt;/_create/&lt;_id&gt;</code> or <code>POST /&lt;target&gt;/_create/&lt;_id&gt;</code> request formats, you must have the <code>create_doc</code>, <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To automatically create a data stream or index with this API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege.
</p>
</li></ul>
<p>
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
<strong>Automatically create data streams and indices</strong>
</p>
<p>
If the request's target doesn't exist and matches an index template with a <code>data_stream</code> definition, the index operation automatically creates the data stream.
</p>
<p>
If the target doesn't exist and doesn't match a data stream template, the operation automatically creates the index and applies any matching index templates.
</p>
<p>
NOTE: Elasticsearch includes several built-in index templates. To avoid naming collisions with these templates, refer to index pattern documentation.
</p>
<p>
If no mapping exists, the index operation creates a dynamic mapping.
By default, new fields and objects are automatically added to the mapping if needed.
</p>
<p>
Automatic index creation is controlled by the <code>action.auto_create_index</code> setting.
If it is <code>true</code>, any index can be created automatically.
You can modify this setting to explicitly allow or block automatic creation of indices that match specified patterns or set it to <code>false</code> to turn off automatic index creation entirely.
Specify a comma-separated list of patterns you want to allow or prefix each pattern with <code>+</code> or <code>-</code> to indicate whether it should be allowed or blocked.
When a list is specified, the default behaviour is to disallow.
</p>
<p>
NOTE: The <code>action.auto_create_index</code> setting affects the automatic creation of indices only.
It does not affect the creation of data streams.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
By default, shard placement — or routing — is controlled by using a hash of the document's ID value.
For more explicit control, the value fed into the hash function used by the router can be directly specified on a per-operation basis using the <code>routing</code> parameter.
</p>
<p>
When setting up explicit mapping, you can also use the <code>_routing</code> field to direct the index operation to extract the routing value from the document itself.
This does come at the (very minimal) cost of an additional document parsing pass.
If the <code>_routing</code> mapping is defined and set to be required, the index operation will fail if no routing value is provided or extracted.
</p>
<p>
NOTE: Data streams do not support custom routing unless they were created with the <code>allow_custom_routing</code> setting enabled in the template.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The index operation is directed to the primary shard based on its route and performed on the actual node containing this shard.
After the primary shard completes the operation, if needed, the update is distributed to applicable replicas.
</p>
<p>
<strong>Active shards</strong>
</p>
<p>
To improve the resiliency of writes to the system, indexing operations can be configured to wait for a certain number of active shard copies before proceeding with the operation.
If the requisite number of active shard copies are not available, then the write operation must wait and retry, until either the requisite shard copies have started or a timeout occurs.
By default, write operations only wait for the primary shards to be active before proceeding (that is to say <code>wait_for_active_shards</code> is <code>1</code>).
This default can be overridden in the index settings dynamically by setting <code>index.write.wait_for_active_shards</code>.
To alter this behavior per operation, use the <code>wait_for_active_shards request</code> parameter.
</p>
<p>
Valid values are all or any positive integer up to the total number of configured copies per shard in the index (which is <code>number_of_replicas</code>+1).
Specifying a negative value or a number greater than the number of shard copies will throw an error.
</p>
<p>
For example, suppose you have a cluster of three nodes, A, B, and C and you create an index index with the number of replicas set to 3 (resulting in 4 shard copies, one more copy than there are nodes).
If you attempt an indexing operation, by default the operation will only ensure the primary copy of each shard is available before proceeding.
This means that even if B and C went down and A hosted the primary shard copies, the indexing operation would still proceed with only one copy of the data.
If <code>wait_for_active_shards</code> is set on the request to <code>3</code> (and all three nodes are up), the indexing operation will require 3 active shard copies before proceeding.
This requirement should be met because there are 3 active nodes in the cluster, each one holding a copy of the shard.
However, if you set <code>wait_for_active_shards</code> to <code>all</code> (or to <code>4</code>, which is the same in this situation), the indexing operation will not proceed as you do not have all 4 copies of each shard active in the index.
The operation will timeout unless a new node is brought up in the cluster to host the fourth copy of the shard.
</p>
<p>
It is important to note that this setting greatly reduces the chances of the write operation not writing to the requisite number of shard copies, but it does not completely eliminate the possibility, because this check occurs before the write operation starts.
After the write operation is underway, it is still possible for replication to fail on any number of shard copies but still succeed on the primary.
The <code>_shards</code> section of the API response reveals the number of shard copies on which replication succeeded and failed.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.CreateResponse.html">CreateResponse</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.DataStreamName.html">DataStreamName</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.DataStreamNames.html">DataStreamNames</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.DateMath.html">DateMath</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.DateMathExpression.html">DateMathExpression</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.DateMathOperationExtensions.html">DateMathOperationExtensions</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.DateMathTime.html">DateMathTime</a></dt>
      <dd><p>A time representation for use within <a class="xref" href="Elastic.Clients.Elasticsearch.DateMath.html">DateMath</a> expressions.</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.DateMathTimeUnitExtensions.html">DateMathTimeUnitExtensions</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.DefaultPropertyMappingProvider.html">DefaultPropertyMappingProvider</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.DeleteByQueryRequest.html">DeleteByQueryRequest</a></dt>
      <dd><p>
Delete documents.
</p>
<p>
Deletes documents that match the specified query.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or alias:
</p>
<ul><li>
<p>
<code>read</code>
</p>
</li><li>
<p>
<code>delete</code> or <code>write</code>
</p>
</li></ul>
<p>
You can specify the query criteria in the request URI or the request body using the same syntax as the search API.
When you submit a delete by query request, Elasticsearch gets a snapshot of the data stream or index when it begins processing the request and deletes matching documents using internal versioning.
If a document changes between the time that the snapshot is taken and the delete operation is processed, it results in a version conflict and the delete operation fails.
</p>
<p>
NOTE: Documents with a version equal to 0 cannot be deleted using delete by query because internal versioning does not support 0 as a valid version number.
</p>
<p>
While processing a delete by query request, Elasticsearch performs multiple search requests sequentially to find all of the matching documents to delete.
A bulk delete request is performed for each batch of matching documents.
If a search or bulk request is rejected, the requests are retried up to 10 times, with exponential back off.
If the maximum retry limit is reached, processing halts and all failed requests are returned in the response.
Any delete requests that completed successfully still stick, they are not rolled back.
</p>
<p>
You can opt to count version conflicts instead of halting and returning by setting <code>conflicts</code> to <code>proceed</code>.
Note that if you opt to count version conflicts the operation could attempt to delete more documents from the source than <code>max_docs</code> until it has successfully deleted <code>max_docs documents</code>, or it has gone through every document in the source query.
</p>
<p>
<strong>Throttling delete requests</strong>
</p>
<p>
To control the rate at which delete by query issues batches of delete operations, you can set <code>requests_per_second</code> to any positive decimal number.
This pads each batch with a wait time to throttle the rate.
Set <code>requests_per_second</code> to <code>-1</code> to disable throttling.
</p>
<p>
Throttling uses a wait time between batches so that the internal scroll requests can be given a timeout that takes the request padding into account.
The padding time is the difference between the batch size divided by the <code>requests_per_second</code> and the time spent writing.
By default the batch size is <code>1000</code>, so if <code>requests_per_second</code> is set to <code>500</code>:
</p>
<pre><code class="lang-csharp">target_time = 1000 / 500 per second = 2 seconds
wait_time = target_time - write_time = 2 seconds - .5 seconds = 1.5 seconds</code></pre>
<p>
Since the batch is issued as a single <code>_bulk</code> request, large batch sizes cause Elasticsearch to create many requests and wait before starting the next set.
This is "bursty" instead of "smooth".
</p>
<p>
<strong>Slicing</strong>
</p>
<p>
Delete by query supports sliced scroll to parallelize the delete process.
This can improve efficiency and provide a convenient way to break the request down into smaller parts.
</p>
<p>
Setting <code>slices</code> to <code>auto</code> lets Elasticsearch choose the number of slices to use.
This setting will use one slice per shard, up to a certain limit.
If there are multiple source data streams or indices, it will choose the number of slices based on the index or backing index with the smallest number of shards.
Adding slices to the delete by query operation creates sub-requests which means it has some quirks:
</p>
<ul><li>
<p>
You can see these requests in the tasks APIs. These sub-requests are "child" tasks of the task for the request with slices.
</p>
</li><li>
<p>
Fetching the status of the task for the request with slices only contains the status of completed slices.
</p>
</li><li>
<p>
These sub-requests are individually addressable for things like cancellation and rethrottling.
</p>
</li><li>
<p>
Rethrottling the request with <code>slices</code> will rethrottle the unfinished sub-request proportionally.
</p>
</li><li>
<p>
Canceling the request with <code>slices</code> will cancel each sub-request.
</p>
</li><li>
<p>
Due to the nature of <code>slices</code> each sub-request won't get a perfectly even portion of the documents. All documents will be addressed, but some slices may be larger than others. Expect larger slices to have a more even distribution.
</p>
</li><li>
<p>
Parameters like <code>requests_per_second</code> and <code>max_docs</code> on a request with <code>slices</code> are distributed proportionally to each sub-request. Combine that with the earlier point about distribution being uneven and you should conclude that using <code>max_docs</code> with <code>slices</code> might not result in exactly <code>max_docs</code> documents being deleted.
</p>
</li><li>
<p>
Each sub-request gets a slightly different snapshot of the source data stream or index though these are all taken at approximately the same time.
</p>
</li></ul>
<p>
If you're slicing manually or otherwise tuning automatic slicing, keep in mind that:
</p>
<ul><li>
<p>
Query performance is most efficient when the number of slices is equal to the number of shards in the index or backing index. If that number is large (for example, 500), choose a lower number as too many <code>slices</code> hurts performance. Setting <code>slices</code> higher than the number of shards generally does not improve efficiency and adds overhead.
</p>
</li><li>
<p>
Delete performance scales linearly across available resources with the number of slices.
</p>
</li></ul>
<p>
Whether query or delete performance dominates the runtime depends on the documents being reindexed and cluster resources.
</p>
<p>
<strong>Cancel a delete by query operation</strong>
</p>
<p>
Any delete by query can be canceled using the task cancel API. For example:
</p>
<pre><code class="lang-csharp">POST _tasks/r1A2WoRbTwKZ516z6NEs5A:36619/_cancel</code></pre>
<p>
The task ID can be found by using the get tasks API.
</p>
<p>
Cancellation should happen quickly but might take a few seconds.
The get task status API will continue to list the delete by query task until this task checks that it has been cancelled and terminates itself.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.DeleteByQueryRequestParameters.html">DeleteByQueryRequestParameters</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.DeleteByQueryResponse.html">DeleteByQueryResponse</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.DeleteByQueryRethrottleRequest.html">DeleteByQueryRethrottleRequest</a></dt>
      <dd><p>
Throttle a delete by query operation.
</p>
<p>
Change the number of requests per second for a particular delete by query operation.
Rethrottling that speeds up the query takes effect immediately but rethrotting that slows down the query takes effect after completing the current batch to prevent scroll timeouts.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.DeleteByQueryRethrottleRequestParameters.html">DeleteByQueryRethrottleRequestParameters</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.DeleteByQueryRethrottleResponse.html">DeleteByQueryRethrottleResponse</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.DeleteRequest.html">DeleteRequest</a></dt>
      <dd><p>
Delete a document.
</p>
<p>
Remove a JSON document from the specified index.
</p>
<p>
NOTE: You cannot send deletion requests directly to a data stream.
To delete a document in a data stream, you must target the backing index containing the document.
</p>
<p>
<strong>Optimistic concurrency control</strong>
</p>
<p>
Delete operations can be made conditional and only be performed if the last modification to the document was assigned the sequence number and primary term specified by the <code>if_seq_no</code> and <code>if_primary_term</code> parameters.
If a mismatch is detected, the operation will result in a <code>VersionConflictException</code> and a status code of <code>409</code>.
</p>
<p>
<strong>Versioning</strong>
</p>
<p>
Each document indexed is versioned.
When deleting a document, the version can be specified to make sure the relevant document you are trying to delete is actually being deleted and it has not changed in the meantime.
Every write operation run on a document, deletes included, causes its version to be incremented.
The version number of a deleted document remains available for a short time after deletion to allow for control of concurrent operations.
The length of time for which a deleted document's version remains available is determined by the <code>index.gc_deletes</code> index setting.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
If routing is used during indexing, the routing value also needs to be specified to delete a document.
</p>
<p>
If the <code>_routing</code> mapping is set to <code>required</code> and no routing value is specified, the delete API throws a <code>RoutingMissingException</code> and rejects the request.
</p>
<p>
For example:
</p>
<pre><code class="lang-csharp">DELETE /my-index-000001/_doc/1?routing=shard-1</code></pre>
<p>
This request deletes the document with ID 1, but it is routed based on the user.
The document is not deleted if the correct routing is not specified.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The delete operation gets hashed into a specific shard ID.
It then gets redirected into the primary shard within that ID group and replicated (if needed) to shard replicas within that ID group.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.DeleteRequestParameters.html">DeleteRequestParameters</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.DeleteRequest-1.html">DeleteRequest&lt;TDocument&gt;</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.DeleteResponse.html">DeleteResponse</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.DeleteScriptRequest.html">DeleteScriptRequest</a></dt>
      <dd><p>
Delete a script or search template.
Deletes a stored script or search template.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.DeleteScriptRequestParameters.html">DeleteScriptRequestParameters</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.DeleteScriptResponse.html">DeleteScriptResponse</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.DocStats.html">DocStats</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.Duration.html">Duration</a></dt>
      <dd><p>Represents a duration value.</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ElasticsearchClient.html">ElasticsearchClient</a></dt>
      <dd><p>A strongly-typed client for communicating with Elasticsearch server endpoints.</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ElasticsearchClientSettings.html">ElasticsearchClientSettings</a></dt>
      <dd><p>Provides the connection settings for Elastic.Clients.Elasticsearch's high level <a class="xref" href="Elastic.Clients.Elasticsearch.ElasticsearchClient.html">ElasticsearchClient</a></p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ElasticsearchResponseExtensions.html">ElasticsearchResponseExtensions</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ElasticsearchVersionInfo.html">ElasticsearchVersionInfo</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ElasticsearchVersionMinInfo.html">ElasticsearchVersionMinInfo</a></dt>
      <dd><p>
Reduced (minimal) info ElasticsearchVersion
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.EmptyObject.html">EmptyObject</a></dt>
      <dd><p>
For empty Class assignments
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ErrorCause.html">ErrorCause</a></dt>
      <dd><p>
Cause and details about a request failure. This class defines the properties common to all error types.
Additional details are also provided, that depend on the error type.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ErrorResponseBase.html">ErrorResponseBase</a></dt>
      <dd><p>
The response returned by Elasticsearch when request execution did not succeed.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ExistsRequest.html">ExistsRequest</a></dt>
      <dd><p>
Check a document.
</p>
<p>
Verify that a document exists.
For example, check to see if a document with the <code>_id</code> 0 exists:
</p>
<pre><code class="lang-csharp">HEAD my-index-000001/_doc/0</code></pre>
<p>
If the document exists, the API returns a status code of <code>200 - OK</code>.
If the document doesn’t exist, the API returns <code>404 - Not Found</code>.
</p>
<p>
<strong>Versioning support</strong>
</p>
<p>
You can use the <code>version</code> parameter to check the document only if its current version is equal to the specified one.
</p>
<p>
Internally, Elasticsearch has marked the old document as deleted and added an entirely new document.
The old version of the document doesn't disappear immediately, although you won't be able to access it.
Elasticsearch cleans up deleted documents in the background as you continue to index more data.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ExistsRequestParameters.html">ExistsRequestParameters</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ExistsResponse.html">ExistsResponse</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ExistsSourceRequest.html">ExistsSourceRequest</a></dt>
      <dd><p>
Check for a document source.
</p>
<p>
Check whether a document source exists in an index.
For example:
</p>
<pre><code class="lang-csharp">HEAD my-index-000001/_source/1</code></pre>
<p>
A document's source is not available if it is disabled in the mapping.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ExistsSourceRequestParameters.html">ExistsSourceRequestParameters</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ExistsSourceResponse.html">ExistsSourceResponse</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ExperimentalSettings.html">ExperimentalSettings</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ExplainRequest.html">ExplainRequest</a></dt>
      <dd><p>
Explain a document match result.
Get information about why a specific document matches, or doesn't match, a query.
It computes a score explanation for a query and a specific document.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ExplainRequestParameters.html">ExplainRequestParameters</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ExplainResponse-1.html">ExplainResponse&lt;TDocument&gt;</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ExpressionExtensions.html">ExpressionExtensions</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.Field.html">Field</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.FieldCapsRequest.html">FieldCapsRequest</a></dt>
      <dd><p>
Get the field capabilities.
</p>
<p>
Get information about the capabilities of fields among multiple indices.
</p>
<p>
For data streams, the API returns field capabilities among the stream’s backing indices.
It returns runtime fields like any other field.
For example, a runtime field with a type of keyword is returned the same as any other field that belongs to the <code>keyword</code> family.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.FieldCapsRequestParameters.html">FieldCapsRequestParameters</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.FieldCapsResponse.html">FieldCapsResponse</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.FieldMemoryUsage.html">FieldMemoryUsage</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.FieldSizeUsage.html">FieldSizeUsage</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.FieldSort.html">FieldSort</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.FielddataStats.html">FielddataStats</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.Fields.html">Fields</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.FluentDictionary-2.html">FluentDictionary&lt;TKey, TValue&gt;</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.FlushStats.html">FlushStats</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.Fuzziness.html">Fuzziness</a></dt>
      <dd><p><a href="https://www.elastic.co/docs/reference/elasticsearch/rest-apis/common-options#fuzziness">Learn more about this API in the Elasticsearch documentation.</a></p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.GeoBounds.html">GeoBounds</a></dt>
      <dd><p>
A geo bounding box. It can be represented in various ways:
</p>
<ul><li>
<p>
as 4 top/bottom/left/right coordinates
</p>
</li><li>
<p>
as 2 top_left / bottom_right points
</p>
</li><li>
<p>
as 2 top_right / bottom_left points
</p>
</li><li>
<p>
as a WKT bounding box
</p>
</li></ul>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.GeoDistanceSort.html">GeoDistanceSort</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.GeoHashLocation.html">GeoHashLocation</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.GeoLine.html">GeoLine</a></dt>
      <dd><p>
A GeoJson GeoLine.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.GeoLocation.html">GeoLocation</a></dt>
      <dd><p>
A latitude/longitude as a 2 dimensional point. It can be represented in various ways:
</p>
<ul><li>
<p>
as a <code>{lat, long}</code> object
</p>
</li><li>
<p>
as a geo hash value
</p>
</li><li>
<p>
as a <code>[lon, lat]</code> array
</p>
</li><li>
<p>
as a string in <code>"&lt;lat&gt;, &lt;lon&gt;"</code> or WKT point formats
</p>
</li></ul>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.GeohashPrecision.html">GeohashPrecision</a></dt>
      <dd><p>
A precision that can be expressed as a geohash length between 1 and 12, or a distance measure like "1km", "10m".
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.GetRequest.html">GetRequest</a></dt>
      <dd><p>
Get a document by its ID.
</p>
<p>
Get a document and its source or stored fields from an index.
</p>
<p>
By default, this API is realtime and is not affected by the refresh rate of the index (when data will become visible for search).
In the case where stored fields are requested with the <code>stored_fields</code> parameter and the document has been updated but is not yet refreshed, the API will have to parse and analyze the source to extract the stored fields.
To turn off realtime behavior, set the <code>realtime</code> parameter to false.
</p>
<p>
<strong>Source filtering</strong>
</p>
<p>
By default, the API returns the contents of the <code>_source</code> field unless you have used the <code>stored_fields</code> parameter or the <code>_source</code> field is turned off.
You can turn off <code>_source</code> retrieval by using the <code>_source</code> parameter:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/0?_source=false</code></pre>
<p>
If you only need one or two fields from the <code>_source</code>, use the <code>_source_includes</code> or <code>_source_excludes</code> parameters to include or filter out particular fields.
This can be helpful with large documents where partial retrieval can save on network overhead
Both parameters take a comma separated list of fields or wildcard expressions.
For example:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/0?_source_includes=*.id&amp;_source_excludes=entities</code></pre>
<p>
If you only want to specify includes, you can use a shorter notation:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/0?_source=*.id</code></pre>
<p>
<strong>Routing</strong>
</p>
<p>
If routing is used during indexing, the routing value also needs to be specified to retrieve a document.
For example:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/2?routing=user1</code></pre>
<p>
This request gets the document with ID 2, but it is routed based on the user.
The document is not fetched if the correct routing is not specified.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The GET operation is hashed into a specific shard ID.
It is then redirected to one of the replicas within that shard ID and returns the result.
The replicas are the primary shard and its replicas within that shard ID group.
This means that the more replicas you have, the better your GET scaling will be.
</p>
<p>
<strong>Versioning support</strong>
</p>
<p>
You can use the <code>version</code> parameter to retrieve the document only if its current version is equal to the specified one.
</p>
<p>
Internally, Elasticsearch has marked the old document as deleted and added an entirely new document.
The old version of the document doesn't disappear immediately, although you won't be able to access it.
Elasticsearch cleans up deleted documents in the background as you continue to index more data.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.GetRequestParameters.html">GetRequestParameters</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.GetResponse-1.html">GetResponse&lt;TDocument&gt;</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.GetScriptContextRequest.html">GetScriptContextRequest</a></dt>
      <dd><p>
Get script contexts.
</p>
<p>
Get a list of supported script contexts and their methods.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.GetScriptContextRequestParameters.html">GetScriptContextRequestParameters</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.GetScriptContextResponse.html">GetScriptContextResponse</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.GetScriptLanguagesRequest.html">GetScriptLanguagesRequest</a></dt>
      <dd><p>
Get script languages.
</p>
<p>
Get a list of available script types, languages, and contexts.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.GetScriptLanguagesRequestParameters.html">GetScriptLanguagesRequestParameters</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.GetScriptLanguagesResponse.html">GetScriptLanguagesResponse</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.GetScriptRequest.html">GetScriptRequest</a></dt>
      <dd><p>
Get a script or search template.
Retrieves a stored script or search template.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.GetScriptRequestParameters.html">GetScriptRequestParameters</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.GetScriptResponse.html">GetScriptResponse</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.GetSourceRequest.html">GetSourceRequest</a></dt>
      <dd><p>
Get a document's source.
</p>
<p>
Get the source of a document.
For example:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_source/1</code></pre>
<p>
You can use the source filtering parameters to control which parts of the <code>_source</code> are returned:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_source/1/?_source_includes=*.id&amp;_source_excludes=entities</code></pre>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.GetSourceRequestParameters.html">GetSourceRequestParameters</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.GetSourceResponse-1.html">GetSourceResponse&lt;TDocument&gt;</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.GetStats.html">GetStats</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.HealthReportRequest.html">HealthReportRequest</a></dt>
      <dd><p>
Get the cluster health.
Get a report with the health status of an Elasticsearch cluster.
The report contains a list of indicators that compose Elasticsearch functionality.
</p>
<p>
Each indicator has a health status of: green, unknown, yellow or red.
The indicator will provide an explanation and metadata describing the reason for its current health status.
</p>
<p>
The cluster’s status is controlled by the worst indicator status.
</p>
<p>
In the event that an indicator’s status is non-green, a list of impacts may be present in the indicator result which detail the functionalities that are negatively affected by the health issue.
Each impact carries with it a severity level, an area of the system that is affected, and a simple description of the impact on the system.
</p>
<p>
Some health indicators can determine the root cause of a health problem and prescribe a set of steps that can be performed in order to improve the health of the system.
The root cause and remediation steps are encapsulated in a diagnosis.
A diagnosis contains a cause detailing a root cause analysis, an action containing a brief description of the steps to take to fix the problem, the list of affected resources (if applicable), and a detailed step-by-step troubleshooting guide to fix the diagnosed problem.
</p>
<p>
NOTE: The health indicators perform root cause analysis of non-green health statuses. This can be computationally expensive when called frequently.
When setting up automated polling of the API for health status, set verbose to false to disable the more expensive analysis logic.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.HealthReportRequestParameters.html">HealthReportRequestParameters</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.HealthReportResponse.html">HealthReportResponse</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.Id.html">Id</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.IdResolver.html">IdResolver</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.Ids.html">Ids</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.IndexAlias.html">IndexAlias</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.IndexManyExtensions.html">IndexManyExtensions</a></dt>
      <dd><p>Provides GetMany extensions that make it easier to get many documents given a list of ids</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.IndexName.html">IndexName</a></dt>
      <dd><p>Represents the name of an index, which may be inferred from a <span class="xref">Elastic.Clients.Elasticsearch.IndexName.Type</span>.</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.IndexRequestParameters.html">IndexRequestParameters</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.IndexRequest-1.html">IndexRequest&lt;TDocument&gt;</a></dt>
      <dd><p>
Create or update a document in an index.
</p>
<p>
Add a JSON document to the specified data stream or index and make it searchable.
If the target is an index and the document already exists, the request updates the document and increments its version.
</p>
<p>
NOTE: You cannot use this API to send update requests for existing documents in a data stream.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or index alias:
</p>
<ul><li>
<p>
To add or overwrite a document using the <code>PUT /&lt;target&gt;/_doc/&lt;_id&gt;</code> request format, you must have the <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To add a document using the <code>POST /&lt;target&gt;/_doc/</code> request format, you must have the <code>create_doc</code>, <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To automatically create a data stream or index with this API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege.
</p>
</li></ul>
<p>
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
NOTE: Replica shards might not all be started when an indexing operation returns successfully.
By default, only the primary is required. Set <code>wait_for_active_shards</code> to change this default behavior.
</p>
<p>
<strong>Automatically create data streams and indices</strong>
</p>
<p>
If the request's target doesn't exist and matches an index template with a <code>data_stream</code> definition, the index operation automatically creates the data stream.
</p>
<p>
If the target doesn't exist and doesn't match a data stream template, the operation automatically creates the index and applies any matching index templates.
</p>
<p>
NOTE: Elasticsearch includes several built-in index templates. To avoid naming collisions with these templates, refer to index pattern documentation.
</p>
<p>
If no mapping exists, the index operation creates a dynamic mapping.
By default, new fields and objects are automatically added to the mapping if needed.
</p>
<p>
Automatic index creation is controlled by the <code>action.auto_create_index</code> setting.
If it is <code>true</code>, any index can be created automatically.
You can modify this setting to explicitly allow or block automatic creation of indices that match specified patterns or set it to <code>false</code> to turn off automatic index creation entirely.
Specify a comma-separated list of patterns you want to allow or prefix each pattern with <code>+</code> or <code>-</code> to indicate whether it should be allowed or blocked.
When a list is specified, the default behaviour is to disallow.
</p>
<p>
NOTE: The <code>action.auto_create_index</code> setting affects the automatic creation of indices only.
It does not affect the creation of data streams.
</p>
<p>
<strong>Optimistic concurrency control</strong>
</p>
<p>
Index operations can be made conditional and only be performed if the last modification to the document was assigned the sequence number and primary term specified by the <code>if_seq_no</code> and <code>if_primary_term</code> parameters.
If a mismatch is detected, the operation will result in a <code>VersionConflictException</code> and a status code of <code>409</code>.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
By default, shard placement — or routing — is controlled by using a hash of the document's ID value.
For more explicit control, the value fed into the hash function used by the router can be directly specified on a per-operation basis using the <code>routing</code> parameter.
</p>
<p>
When setting up explicit mapping, you can also use the <code>_routing</code> field to direct the index operation to extract the routing value from the document itself.
This does come at the (very minimal) cost of an additional document parsing pass.
If the <code>_routing</code> mapping is defined and set to be required, the index operation will fail if no routing value is provided or extracted.
</p>
<p>
NOTE: Data streams do not support custom routing unless they were created with the <code>allow_custom_routing</code> setting enabled in the template.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The index operation is directed to the primary shard based on its route and performed on the actual node containing this shard.
After the primary shard completes the operation, if needed, the update is distributed to applicable replicas.
</p>
<p>
<strong>Active shards</strong>
</p>
<p>
To improve the resiliency of writes to the system, indexing operations can be configured to wait for a certain number of active shard copies before proceeding with the operation.
If the requisite number of active shard copies are not available, then the write operation must wait and retry, until either the requisite shard copies have started or a timeout occurs.
By default, write operations only wait for the primary shards to be active before proceeding (that is to say <code>wait_for_active_shards</code> is <code>1</code>).
This default can be overridden in the index settings dynamically by setting <code>index.write.wait_for_active_shards</code>.
To alter this behavior per operation, use the <code>wait_for_active_shards request</code> parameter.
</p>
<p>
Valid values are all or any positive integer up to the total number of configured copies per shard in the index (which is <code>number_of_replicas</code>+1).
Specifying a negative value or a number greater than the number of shard copies will throw an error.
</p>
<p>
For example, suppose you have a cluster of three nodes, A, B, and C and you create an index index with the number of replicas set to 3 (resulting in 4 shard copies, one more copy than there are nodes).
If you attempt an indexing operation, by default the operation will only ensure the primary copy of each shard is available before proceeding.
This means that even if B and C went down and A hosted the primary shard copies, the indexing operation would still proceed with only one copy of the data.
If <code>wait_for_active_shards</code> is set on the request to <code>3</code> (and all three nodes are up), the indexing operation will require 3 active shard copies before proceeding.
This requirement should be met because there are 3 active nodes in the cluster, each one holding a copy of the shard.
However, if you set <code>wait_for_active_shards</code> to <code>all</code> (or to <code>4</code>, which is the same in this situation), the indexing operation will not proceed as you do not have all 4 copies of each shard active in the index.
The operation will timeout unless a new node is brought up in the cluster to host the fourth copy of the shard.
</p>
<p>
It is important to note that this setting greatly reduces the chances of the write operation not writing to the requisite number of shard copies, but it does not completely eliminate the possibility, because this check occurs before the write operation starts.
After the write operation is underway, it is still possible for replication to fail on any number of shard copies but still succeed on the primary.
The <code>_shards</code> section of the API response reveals the number of shard copies on which replication succeeded and failed.
</p>
<p>
<strong>No operation (noop) updates</strong>
</p>
<p>
When updating a document by using this API, a new version of the document is always created even if the document hasn't changed.
If this isn't acceptable use the <code>_update</code> API with <code>detect_noop</code> set to <code>true</code>.
The <code>detect_noop</code> option isn't available on this API because it doesn’t fetch the old source and isn't able to compare it against the new source.
</p>
<p>
There isn't a definitive rule for when noop updates aren't acceptable.
It's a combination of lots of factors like how frequently your data source sends updates that are actually noops and how many queries per second Elasticsearch runs on the shard receiving the updates.
</p>
<p>
<strong>Versioning</strong>
</p>
<p>
Each indexed document is given a version number.
By default, internal versioning is used that starts at 1 and increments with each update, deletes included.
Optionally, the version number can be set to an external value (for example, if maintained in a database).
To enable this functionality, <code>version_type</code> should be set to <code>external</code>.
The value provided must be a numeric, long value greater than or equal to 0, and less than around <code>9.2e+18</code>.
</p>
<p>
NOTE: Versioning is completely real time, and is not affected by the near real time aspects of search operations.
If no version is provided, the operation runs without any version checks.
</p>
<p>
When using the external version type, the system checks to see if the version number passed to the index request is greater than the version of the currently stored document.
If true, the document will be indexed and the new version number used.
If the value provided is less than or equal to the stored document's version number, a version conflict will occur and the index operation will fail. For example:
</p>
<pre><code class="lang-csharp">PUT my-index-000001/_doc/1?version=2&amp;version_type=external
{
  "user": {
    "id": "elkbee"
  }
}

In this example, the operation will succeed since the supplied version of 2 is higher than the current document version of 1.
If the document was already updated and its version was set to 2 or higher, the indexing command will fail and result in a conflict (409 HTTP status code).

A nice side effect is that there is no need to maintain strict ordering of async indexing operations run as a result of changes to a source database, as long as version numbers from the source database are used.
Even the simple case of updating the Elasticsearch index using data from a database is simplified if external versioning is used, as only the latest version will be used if the index operations arrive out of order.</code></pre>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.IndexResponse.html">IndexResponse</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.IndexUuid.html">IndexUuid</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.IndexingStats.html">IndexingStats</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.Indices.html">Indices</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.IndicesOptions.html">IndicesOptions</a></dt>
      <dd><p>
Controls how to deal with unavailable concrete indices (closed or missing), how wildcard expressions are expanded
to actual indices (all, closed or open indices) and how to deal with wildcard expressions that resolve to no indices.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.Infer.html">Infer</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.Inferrer.html">Inferrer</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.InfoRequest.html">InfoRequest</a></dt>
      <dd><p>
Get cluster info.
Get basic build, version, and cluster information.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.InfoRequestParameters.html">InfoRequestParameters</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.InfoResponse.html">InfoResponse</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.InlineGet-1.html">InlineGet&lt;TDocument&gt;</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.IsADictionary-2.html">IsADictionary&lt;TKey, TValue&gt;</a></dt>
      <dd><p>A base dictionary type for internally tagged unions.</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.IsAReadOnlyDictionary-2.html">IsAReadOnlyDictionary&lt;TKey, TValue&gt;</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.JoinField.html">JoinField</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.JoinField.Child.html">JoinField.Child</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.JoinField.Parent.html">JoinField.Parent</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.KnnQuery.html">KnnQuery</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.KnnRetriever.html">KnnRetriever</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.KnnSearch.html">KnnSearch</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.LatLonGeoLocation.html">LatLonGeoLocation</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.MemberInfoResolver.html">MemberInfoResolver</a></dt>
      <dd><p>Resolves member infos in an expression, instance may NOT be shared.</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.MergesStats.html">MergesStats</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.Metrics.html">Metrics</a></dt>
      <dd><p>Represents a collection of unique metric names to be included in URL paths to limit the request.</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.MinimumShouldMatch.html">MinimumShouldMatch</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.MultiGetRequest.html">MultiGetRequest</a></dt>
      <dd><p>
Get multiple documents.
</p>
<p>
Get multiple JSON documents by ID from one or more indices.
If you specify an index in the request URI, you only need to specify the document IDs in the request body.
To ensure fast responses, this multi get (mget) API responds with partial results if one or more shards fail.
</p>
<p>
<strong>Filter source fields</strong>
</p>
<p>
By default, the <code>_source</code> field is returned for every document (if stored).
Use the <code>_source</code> and <code>_source_include</code> or <code>source_exclude</code> attributes to filter what fields are returned for a particular document.
You can include the <code>_source</code>, <code>_source_includes</code>, and <code>_source_excludes</code> query parameters in the request URI to specify the defaults to use when there are no per-document instructions.
</p>
<p>
<strong>Get stored fields</strong>
</p>
<p>
Use the <code>stored_fields</code> attribute to specify the set of stored fields you want to retrieve.
Any requested fields that are not stored are ignored.
You can include the <code>stored_fields</code> query parameter in the request URI to specify the defaults to use when there are no per-document instructions.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.MultiGetRequestParameters.html">MultiGetRequestParameters</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.MultiGetResponse-1.html">MultiGetResponse&lt;TDocument&gt;</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.MultiSearchRequest.html">MultiSearchRequest</a></dt>
      <dd><p>
Run multiple searches.
</p>
<p>
The format of the request is similar to the bulk API format and makes use of the newline delimited JSON (NDJSON) format.
The structure is as follows:
</p>
<pre><code class="lang-csharp">header\n
body\n
header\n
body\n</code></pre>
<p>
This structure is specifically optimized to reduce parsing if a specific search ends up redirected to another node.
</p>
<p>
IMPORTANT: The final line of data must end with a newline character <code>\n</code>.
Each newline character may be preceded by a carriage return <code>\r</code>.
When sending requests to this endpoint the <code>Content-Type</code> header should be set to <code>application/x-ndjson</code>.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.MultiSearchRequestParameters.html">MultiSearchRequestParameters</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.MultiSearchResponse-1.html">MultiSearchResponse&lt;TDocument&gt;</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.MultiSearchTemplateRequest.html">MultiSearchTemplateRequest</a></dt>
      <dd><p>
Run multiple templated searches.
</p>
<p>
Run multiple templated searches with a single request.
If you are providing a text file or text input to <code>curl</code>, use the <code>--data-binary</code> flag instead of <code>-d</code> to preserve newlines.
For example:
</p>
<pre><code class="lang-csharp">$ cat requests
{ "index": "my-index" }
{ "id": "my-search-template", "params": { "query_string": "hello world", "from": 0, "size": 10 }}
{ "index": "my-other-index" }
{ "id": "my-other-search-template", "params": { "query_type": "match_all" }}

$ curl -H "Content-Type: application/x-ndjson" -XGET localhost:9200/_msearch/template --data-binary "@requests"; echo</code></pre>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.MultiSearchTemplateRequestParameters.html">MultiSearchTemplateRequestParameters</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.MultiSearchTemplateResponse-1.html">MultiSearchTemplateResponse&lt;TDocument&gt;</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.MultiTermVectorsRequest.html">MultiTermVectorsRequest</a></dt>
      <dd><p>
Get multiple term vectors.
</p>
<p>
Get multiple term vectors with a single request.
You can specify existing documents by index and ID or provide artificial documents in the body of the request.
You can specify the index in the request body or request URI.
The response contains a <code>docs</code> array with all the fetched termvectors.
Each element has the structure provided by the termvectors API.
</p>
<p>
<strong>Artificial documents</strong>
</p>
<p>
You can also use <code>mtermvectors</code> to generate term vectors for artificial documents provided in the body of the request.
The mapping used is determined by the specified <code>_index</code>.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.MultiTermVectorsRequestParameters.html">MultiTermVectorsRequestParameters</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.MultiTermVectorsResponse.html">MultiTermVectorsResponse</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.Name.html">Name</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.Names.html">Names</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.NamespacedClientProxy.html">NamespacedClientProxy</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.NestedSortValue.html">NestedSortValue</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.NodeAttributes.html">NodeAttributes</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.NodeIds.html">NodeIds</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.NodeShard.html">NodeShard</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.NodeStatistics.html">NodeStatistics</a></dt>
      <dd><p>
Contains statistics about the number of nodes selected by the request.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.OpenPointInTimeRequest.html">OpenPointInTimeRequest</a></dt>
      <dd><p>
Open a point in time.
</p>
<p>
A search request by default runs against the most recent visible data of the target indices,
which is called point in time. Elasticsearch pit (point in time) is a lightweight view into the
state of the data as it existed when initiated. In some cases, it’s preferred to perform multiple
search requests using the same point in time. For example, if refreshes happen between
<code>search_after</code> requests, then the results of those requests might not be consistent as changes happening
between searches are only visible to the more recent point in time.
</p>
<p>
A point in time must be opened explicitly before being used in search requests.
</p>
<p>
A subsequent search request with the <code>pit</code> parameter must not specify <code>index</code>, <code>routing</code>, or <code>preference</code> values as these parameters are copied from the point in time.
</p>
<p>
Just like regular searches, you can use <code>from</code> and <code>size</code> to page through point in time search results, up to the first 10,000 hits.
If you want to retrieve more hits, use PIT with <code>search_after</code>.
</p>
<p>
IMPORTANT: The open point in time request and each subsequent search request can return different identifiers; always use the most recently received ID for the next search request.
</p>
<p>
When a PIT that contains shard failures is used in a search request, the missing are always reported in the search response as a <code>NoShardAvailableActionException</code> exception.
To get rid of these exceptions, a new PIT needs to be created so that shards missing from the previous PIT can be handled, assuming they become available in the meantime.
</p>
<p>
<strong>Keeping point in time alive</strong>
</p>
<p>
The <code>keep_alive</code> parameter, which is passed to a open point in time request and search request, extends the time to live of the corresponding point in time.
The value does not need to be long enough to process all data — it just needs to be long enough for the next request.
</p>
<p>
Normally, the background merge process optimizes the index by merging together smaller segments to create new, bigger segments.
Once the smaller segments are no longer needed they are deleted.
However, open point-in-times prevent the old segments from being deleted since they are still in use.
</p>
<p>
TIP: Keeping older segments alive means that more disk space and file handles are needed.
Ensure that you have configured your nodes to have ample free file handles.
</p>
<p>
Additionally, if a segment contains deleted or updated documents then the point in time must keep track of whether each document in the segment was live at the time of the initial search request.
Ensure that your nodes have sufficient heap space if you have many open point-in-times on an index that is subject to ongoing deletes or updates.
Note that a point-in-time doesn't prevent its associated indices from being deleted.
You can check how many point-in-times (that is, search contexts) are open with the nodes stats API.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.OpenPointInTimeRequestParameters.html">OpenPointInTimeRequestParameters</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.OpenPointInTimeResponse.html">OpenPointInTimeResponse</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.Percentage.html">Percentage</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.PingRequest.html">PingRequest</a></dt>
      <dd><p>
Ping the cluster.
Get information about whether the cluster is running.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.PingRequestParameters.html">PingRequestParameters</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.PingResponse.html">PingResponse</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.PluginStats.html">PluginStats</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ProducerConsumerBackPressure.html">ProducerConsumerBackPressure</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.PropertyName.html">PropertyName</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.PutScriptRequest.html">PutScriptRequest</a></dt>
      <dd><p>
Create or update a script or search template.
Creates or updates a stored script or search template.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.PutScriptRequestParameters.html">PutScriptRequestParameters</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.PutScriptResponse.html">PutScriptResponse</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.QueryCacheStats.html">QueryCacheStats</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.QueryVectorBuilder.html">QueryVectorBuilder</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.RRFRetriever.html">RRFRetriever</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.Rank.html">Rank</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.RankEvalRequest.html">RankEvalRequest</a></dt>
      <dd><p>
Evaluate ranked search results.
</p>
<p>
Evaluate the quality of ranked search results over a set of typical search queries.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.RankEvalRequestParameters.html">RankEvalRequestParameters</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.RankEvalResponse.html">RankEvalResponse</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.RecoveryStats.html">RecoveryStats</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.RefreshStats.html">RefreshStats</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ReindexRequest.html">ReindexRequest</a></dt>
      <dd><p>
Reindex documents.
</p>
<p>
Copy documents from a source to a destination.
You can copy all documents to the destination index or reindex a subset of the documents.
The source can be any existing index, alias, or data stream.
The destination must differ from the source.
For example, you cannot reindex a data stream into itself.
</p>
<p>
IMPORTANT: Reindex requires <code>_source</code> to be enabled for all documents in the source.
The destination should be configured as wanted before calling the reindex API.
Reindex does not copy the settings from the source or its associated template.
Mappings, shard counts, and replicas, for example, must be configured ahead of time.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following security privileges:
</p>
<ul><li>
<p>
The <code>read</code> index privilege for the source data stream, index, or alias.
</p>
</li><li>
<p>
The <code>write</code> index privilege for the destination data stream, index, or index alias.
</p>
</li><li>
<p>
To automatically create a data stream or index with a reindex API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege for the destination data stream, index, or alias.
</p>
</li><li>
<p>
If reindexing from a remote cluster, the <code>source.remote.user</code> must have the <code>monitor</code> cluster privilege and the <code>read</code> index privilege for the source data stream, index, or alias.
</p>
</li></ul>
<p>
If reindexing from a remote cluster, you must explicitly allow the remote host in the <code>reindex.remote.whitelist</code> setting.
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
The <code>dest</code> element can be configured like the index API to control optimistic concurrency control.
Omitting <code>version_type</code> or setting it to <code>internal</code> causes Elasticsearch to blindly dump documents into the destination, overwriting any that happen to have the same ID.
</p>
<p>
Setting <code>version_type</code> to <code>external</code> causes Elasticsearch to preserve the <code>version</code> from the source, create any documents that are missing, and update any documents that have an older version in the destination than they do in the source.
</p>
<p>
Setting <code>op_type</code> to <code>create</code> causes the reindex API to create only missing documents in the destination.
All existing documents will cause a version conflict.
</p>
<p>
IMPORTANT: Because data streams are append-only, any reindex request to a destination data stream must have an <code>op_type</code> of <code>create</code>.
A reindex can only add new documents to a destination data stream.
It cannot update existing documents in a destination data stream.
</p>
<p>
By default, version conflicts abort the reindex process.
To continue reindexing if there are conflicts, set the <code>conflicts</code> request body property to <code>proceed</code>.
In this case, the response includes a count of the version conflicts that were encountered.
Note that the handling of other error types is unaffected by the <code>conflicts</code> property.
Additionally, if you opt to count version conflicts, the operation could attempt to reindex more documents from the source than <code>max_docs</code> until it has successfully indexed <code>max_docs</code> documents into the target or it has gone through every document in the source query.
</p>
<p>
NOTE: The reindex API makes no effort to handle ID collisions.
The last document written will "win" but the order isn't usually predictable so it is not a good idea to rely on this behavior.
Instead, make sure that IDs are unique by using a script.
</p>
<p>
<strong>Running reindex asynchronously</strong>
</p>
<p>
If the request contains <code>wait_for_completion=false</code>, Elasticsearch performs some preflight checks, launches the request, and returns a task you can use to cancel or get the status of the task.
Elasticsearch creates a record of this task as a document at <code>_tasks/&lt;task_id&gt;</code>.
</p>
<p>
<strong>Reindex from multiple sources</strong>
</p>
<p>
If you have many sources to reindex it is generally better to reindex them one at a time rather than using a glob pattern to pick up multiple sources.
That way you can resume the process if there are any errors by removing the partially completed source and starting over.
It also makes parallelizing the process fairly simple: split the list of sources to reindex and run each list in parallel.
</p>
<p>
For example, you can use a bash script like this:
</p>
<pre><code class="lang-csharp">for index in i1 i2 i3 i4 i5; do
  curl -HContent-Type:application/json -XPOST localhost:9200/_reindex?pretty -d'{
    "source": {
      "index": "'$index'"
    },
    "dest": {
      "index": "'$index'-reindexed"
    }
  }'
done</code></pre>
<p>
<strong>Throttling</strong>
</p>
<p>
Set <code>requests_per_second</code> to any positive decimal number (<code>1.4</code>, <code>6</code>, <code>1000</code>, for example) to throttle the rate at which reindex issues batches of index operations.
Requests are throttled by padding each batch with a wait time.
To turn off throttling, set <code>requests_per_second</code> to <code>-1</code>.
</p>
<p>
The throttling is done by waiting between batches so that the scroll that reindex uses internally can be given a timeout that takes into account the padding.
The padding time is the difference between the batch size divided by the <code>requests_per_second</code> and the time spent writing.
By default the batch size is <code>1000</code>, so if <code>requests_per_second</code> is set to <code>500</code>:
</p>
<pre><code class="lang-csharp">target_time = 1000 / 500 per second = 2 seconds
wait_time = target_time - write_time = 2 seconds - .5 seconds = 1.5 seconds</code></pre>
<p>
Since the batch is issued as a single bulk request, large batch sizes cause Elasticsearch to create many requests and then wait for a while before starting the next set.
This is "bursty" instead of "smooth".
</p>
<p>
<strong>Slicing</strong>
</p>
<p>
Reindex supports sliced scroll to parallelize the reindexing process.
This parallelization can improve efficiency and provide a convenient way to break the request down into smaller parts.
</p>
<p>
NOTE: Reindexing from remote clusters does not support manual or automatic slicing.
</p>
<p>
You can slice a reindex request manually by providing a slice ID and total number of slices to each request.
You can also let reindex automatically parallelize by using sliced scroll to slice on <code>_id</code>.
The <code>slices</code> parameter specifies the number of slices to use.
</p>
<p>
Adding <code>slices</code> to the reindex request just automates the manual process, creating sub-requests which means it has some quirks:
</p>
<ul><li>
<p>
You can see these requests in the tasks API. These sub-requests are "child" tasks of the task for the request with slices.
</p>
</li><li>
<p>
Fetching the status of the task for the request with <code>slices</code> only contains the status of completed slices.
</p>
</li><li>
<p>
These sub-requests are individually addressable for things like cancellation and rethrottling.
</p>
</li><li>
<p>
Rethrottling the request with <code>slices</code> will rethrottle the unfinished sub-request proportionally.
</p>
</li><li>
<p>
Canceling the request with <code>slices</code> will cancel each sub-request.
</p>
</li><li>
<p>
Due to the nature of <code>slices</code>, each sub-request won't get a perfectly even portion of the documents. All documents will be addressed, but some slices may be larger than others. Expect larger slices to have a more even distribution.
</p>
</li><li>
<p>
Parameters like <code>requests_per_second</code> and <code>max_docs</code> on a request with <code>slices</code> are distributed proportionally to each sub-request. Combine that with the previous point about distribution being uneven and you should conclude that using <code>max_docs</code> with <code>slices</code> might not result in exactly <code>max_docs</code> documents being reindexed.
</p>
</li><li>
<p>
Each sub-request gets a slightly different snapshot of the source, though these are all taken at approximately the same time.
</p>
</li></ul>
<p>
If slicing automatically, setting <code>slices</code> to <code>auto</code> will choose a reasonable number for most indices.
If slicing manually or otherwise tuning automatic slicing, use the following guidelines.
</p>
<p>
Query performance is most efficient when the number of slices is equal to the number of shards in the index.
If that number is large (for example, <code>500</code>), choose a lower number as too many slices will hurt performance.
Setting slices higher than the number of shards generally does not improve efficiency and adds overhead.
</p>
<p>
Indexing performance scales linearly across available resources with the number of slices.
</p>
<p>
Whether query or indexing performance dominates the runtime depends on the documents being reindexed and cluster resources.
</p>
<p>
<strong>Modify documents during reindexing</strong>
</p>
<p>
Like <code>_update_by_query</code>, reindex operations support a script that modifies the document.
Unlike <code>_update_by_query</code>, the script is allowed to modify the document's metadata.
</p>
<p>
Just as in <code>_update_by_query</code>, you can set <code>ctx.op</code> to change the operation that is run on the destination.
For example, set <code>ctx.op</code> to <code>noop</code> if your script decides that the document doesn’t have to be indexed in the destination. This "no operation" will be reported in the <code>noop</code> counter in the response body.
Set <code>ctx.op</code> to <code>delete</code> if your script decides that the document must be deleted from the destination.
The deletion will be reported in the <code>deleted</code> counter in the response body.
Setting <code>ctx.op</code> to anything else will return an error, as will setting any other field in <code>ctx</code>.
</p>
<p>
Think of the possibilities! Just be careful; you are able to change:
</p>
<ul><li>
<p>
<code>_id</code>
</p>
</li><li>
<p>
<code>_index</code>
</p>
</li><li>
<p>
<code>_version</code>
</p>
</li><li>
<p>
<code>_routing</code>
</p>
</li></ul>
<p>
Setting <code>_version</code> to <code>null</code> or clearing it from the <code>ctx</code> map is just like not sending the version in an indexing request.
It will cause the document to be overwritten in the destination regardless of the version on the target or the version type you use in the reindex API.
</p>
<p>
<strong>Reindex from remote</strong>
</p>
<p>
Reindex supports reindexing from a remote Elasticsearch cluster.
The <code>host</code> parameter must contain a scheme, host, port, and optional path.
The <code>username</code> and <code>password</code> parameters are optional and when they are present the reindex operation will connect to the remote Elasticsearch node using basic authentication.
Be sure to use HTTPS when using basic authentication or the password will be sent in plain text.
There are a range of settings available to configure the behavior of the HTTPS connection.
</p>
<p>
When using Elastic Cloud, it is also possible to authenticate against the remote cluster through the use of a valid API key.
Remote hosts must be explicitly allowed with the <code>reindex.remote.whitelist</code> setting.
It can be set to a comma delimited list of allowed remote host and port combinations.
Scheme is ignored; only the host and port are used.
For example:
</p>
<pre><code class="lang-csharp">reindex.remote.whitelist: [otherhost:9200, another:9200, 127.0.10.*:9200, localhost:*"]</code></pre>
<p>
The list of allowed hosts must be configured on any nodes that will coordinate the reindex.
This feature should work with remote clusters of any version of Elasticsearch.
This should enable you to upgrade from any version of Elasticsearch to the current version by reindexing from a cluster of the old version.
</p>
<p>
WARNING: Elasticsearch does not support forward compatibility across major versions.
For example, you cannot reindex from a 7.x cluster into a 6.x cluster.
</p>
<p>
To enable queries sent to older versions of Elasticsearch, the <code>query</code> parameter is sent directly to the remote host without validation or modification.
</p>
<p>
NOTE: Reindexing from remote clusters does not support manual or automatic slicing.
</p>
<p>
Reindexing from a remote server uses an on-heap buffer that defaults to a maximum size of 100mb.
If the remote index includes very large documents you'll need to use a smaller batch size.
It is also possible to set the socket read timeout on the remote connection with the <code>socket_timeout</code> field and the connection timeout with the <code>connect_timeout</code> field.
Both default to 30 seconds.
</p>
<p>
<strong>Configuring SSL parameters</strong>
</p>
<p>
Reindex from remote supports configurable SSL settings.
These must be specified in the <code>elasticsearch.yml</code> file, with the exception of the secure settings, which you add in the Elasticsearch keystore.
It is not possible to configure SSL in the body of the reindex request.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ReindexRequestParameters.html">ReindexRequestParameters</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ReindexResponse.html">ReindexResponse</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ReindexRethrottleRequest.html">ReindexRethrottleRequest</a></dt>
      <dd><p>
Throttle a reindex operation.
</p>
<p>
Change the number of requests per second for a particular reindex operation.
For example:
</p>
<pre><code class="lang-csharp">POST _reindex/r1A2WoRbTwKZ516z6NEs5A:36619/_rethrottle?requests_per_second=-1</code></pre>
<p>
Rethrottling that speeds up the query takes effect immediately.
Rethrottling that slows down the query will take effect after completing the current batch.
This behavior prevents scroll timeouts.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ReindexRethrottleRequestParameters.html">ReindexRethrottleRequestParameters</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ReindexRethrottleResponse.html">ReindexRethrottleResponse</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.RelationName.html">RelationName</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.RelocationFailureInfo.html">RelocationFailureInfo</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.RenderSearchTemplateRequest.html">RenderSearchTemplateRequest</a></dt>
      <dd><p>
Render a search template.
</p>
<p>
Render a search template as a search request body.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.RenderSearchTemplateRequestParameters.html">RenderSearchTemplateRequestParameters</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.RenderSearchTemplateResponse.html">RenderSearchTemplateResponse</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.RequestCacheStats.html">RequestCacheStats</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.RescoreVector.html">RescoreVector</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.Retries.html">Retries</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.Retriever.html">Retriever</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.Routing.html">Routing</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.RoutingResolver.html">RoutingResolver</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.RrfRank.html">RrfRank</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.RuleRetriever.html">RuleRetriever</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ScoreSort.html">ScoreSort</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.Script.html">Script</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ScriptField.html">ScriptField</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ScriptSort.html">ScriptSort</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ScriptsPainlessExecuteRequest.html">ScriptsPainlessExecuteRequest</a></dt>
      <dd><p>
Run a script.
</p>
<p>
Runs a script and returns a result.
Use this API to build and test scripts, such as when defining a script for a runtime field.
This API requires very few dependencies and is especially useful if you don't have permissions to write documents on a cluster.
</p>
<p>
The API uses several <em>contexts</em>, which control how scripts are run, what variables are available at runtime, and what the return type is.
</p>
<p>
Each context requires a script, but additional parameters depend on the context you're using for that script.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ScriptsPainlessExecuteRequestParameters.html">ScriptsPainlessExecuteRequestParameters</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ScriptsPainlessExecuteResponse-1.html">ScriptsPainlessExecuteResponse&lt;TResult&gt;</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ScrollId.html">ScrollId</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ScrollIds.html">ScrollIds</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ScrollRequest.html">ScrollRequest</a></dt>
      <dd><p>
Run a scrolling search.
</p>
<p>
IMPORTANT: The scroll API is no longer recommend for deep pagination. If you need to preserve the index state while paging through more than 10,000 hits, use the <code>search_after</code> parameter with a point in time (PIT).
</p>
<p>
The scroll API gets large sets of results from a single scrolling search request.
To get the necessary scroll ID, submit a search API request that includes an argument for the <code>scroll</code> query parameter.
The <code>scroll</code> parameter indicates how long Elasticsearch should retain the search context for the request.
The search response returns a scroll ID in the <code>_scroll_id</code> response body parameter.
You can then use the scroll ID with the scroll API to retrieve the next batch of results for the request.
If the Elasticsearch security features are enabled, the access to the results of a specific scroll ID is restricted to the user or API key that submitted the search.
</p>
<p>
You can also use the scroll API to specify a new scroll parameter that extends or shortens the retention period for the search context.
</p>
<p>
IMPORTANT: Results from a scrolling search reflect the state of the index at the time of the initial search request. Subsequent indexing or document changes only affect later search and scroll requests.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ScrollRequestParameters.html">ScrollRequestParameters</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ScrollResponse-1.html">ScrollResponse&lt;TDocument&gt;</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.SearchMvtRequest.html">SearchMvtRequest</a></dt>
      <dd><p>
Search a vector tile.
</p>
<p>
Search a vector tile for geospatial values.
Before using this API, you should be familiar with the Mapbox vector tile specification.
The API returns results as a binary mapbox vector tile.
</p>
<p>
Internally, Elasticsearch translates a vector tile search API request into a search containing:
</p>
<ul><li>
<p>
A <code>geo_bounding_box</code> query on the <code>&lt;field&gt;</code>. The query uses the <code>&lt;zoom&gt;/&lt;x&gt;/&lt;y&gt;</code> tile as a bounding box.
</p>
</li><li>
<p>
A <code>geotile_grid</code> or <code>geohex_grid</code> aggregation on the <code>&lt;field&gt;</code>. The <code>grid_agg</code> parameter determines the aggregation type. The aggregation uses the <code>&lt;zoom&gt;/&lt;x&gt;/&lt;y&gt;</code> tile as a bounding box.
</p>
</li><li>
<p>
Optionally, a <code>geo_bounds</code> aggregation on the <code>&lt;field&gt;</code>. The search only includes this aggregation if the <code>exact_bounds</code> parameter is <code>true</code>.
</p>
</li><li>
<p>
If the optional parameter <code>with_labels</code> is <code>true</code>, the internal search will include a dynamic runtime field that calls the <code>getLabelPosition</code> function of the geometry doc value. This enables the generation of new point features containing suggested geometry labels, so that, for example, multi-polygons will have only one label.
</p>
</li></ul>
<p>
For example, Elasticsearch may translate a vector tile search API request with a <code>grid_agg</code> argument of <code>geotile</code> and an <code>exact_bounds</code> argument of <code>true</code> into the following search
</p>
<pre><code class="lang-csharp">GET my-index/_search
{
  "size": 10000,
  "query": {
    "geo_bounding_box": {
      "my-geo-field": {
        "top_left": {
          "lat": -40.979898069620134,
          "lon": -45
        },
        "bottom_right": {
          "lat": -66.51326044311186,
          "lon": 0
        }
      }
    }
  },
  "aggregations": {
    "grid": {
      "geotile_grid": {
        "field": "my-geo-field",
        "precision": 11,
        "size": 65536,
        "bounds": {
          "top_left": {
            "lat": -40.979898069620134,
            "lon": -45
          },
          "bottom_right": {
            "lat": -66.51326044311186,
            "lon": 0
          }
        }
      }
    },
    "bounds": {
      "geo_bounds": {
        "field": "my-geo-field",
        "wrap_longitude": false
      }
    }
  }
}</code></pre>
<p>
The API returns results as a binary Mapbox vector tile.
Mapbox vector tiles are encoded as Google Protobufs (PBF). By default, the tile contains three layers:
</p>
<ul><li>
<p>
A <code>hits</code> layer containing a feature for each <code>&lt;field&gt;</code> value matching the <code>geo_bounding_box</code> query.
</p>
</li><li>
<p>
An <code>aggs</code> layer containing a feature for each cell of the <code>geotile_grid</code> or <code>geohex_grid</code>. The layer only contains features for cells with matching data.
</p>
</li><li>
<p>
A meta layer containing:
</p>
<ul><li>
<p>
A feature containing a bounding box. By default, this is the bounding box of the tile.
</p>
</li><li>
<p>
Value ranges for any sub-aggregations on the <code>geotile_grid</code> or <code>geohex_grid</code>.
</p>
</li><li>
<p>
Metadata for the search.
</p>
</li></ul>
</li></ul>
<p>
The API only returns features that can display at its zoom level.
For example, if a polygon feature has no area at its zoom level, the API omits it.
The API returns errors as UTF-8 encoded JSON.
</p>
<p>
IMPORTANT: You can specify several options for this API as either a query parameter or request body parameter.
If you specify both parameters, the query parameter takes precedence.
</p>
<p>
<strong>Grid precision for geotile</strong>
</p>
<p>
For a <code>grid_agg</code> of <code>geotile</code>, you can use cells in the <code>aggs</code> layer as tiles for lower zoom levels.
<code>grid_precision</code> represents the additional zoom levels available through these cells. The final precision is computed by as follows: <code>&lt;zoom&gt; + grid_precision</code>.
For example, if <code>&lt;zoom&gt;</code> is 7 and <code>grid_precision</code> is 8, then the <code>geotile_grid</code> aggregation will use a precision of 15.
The maximum final precision is 29.
The <code>grid_precision</code> also determines the number of cells for the grid as follows: <code>(2^grid_precision) x (2^grid_precision)</code>.
For example, a value of 8 divides the tile into a grid of 256 x 256 cells.
The <code>aggs</code> layer only contains features for cells with matching data.
</p>
<p>
<strong>Grid precision for geohex</strong>
</p>
<p>
For a <code>grid_agg</code> of <code>geohex</code>, Elasticsearch uses <code>&lt;zoom&gt;</code> and <code>grid_precision</code> to calculate a final precision as follows: <code>&lt;zoom&gt; + grid_precision</code>.
</p>
<p>
This precision determines the H3 resolution of the hexagonal cells produced by the <code>geohex</code> aggregation.
The following table maps the H3 resolution for each precision.
For example, if <code>&lt;zoom&gt;</code> is 3 and <code>grid_precision</code> is 3, the precision is 6.
At a precision of 6, hexagonal cells have an H3 resolution of 2.
If <code>&lt;zoom&gt;</code> is 3 and <code>grid_precision</code> is 4, the precision is 7.
At a precision of 7, hexagonal cells have an H3 resolution of 3.
</p>
<p>
| Precision | Unique tile bins | H3 resolution | Unique hex bins |	Ratio |
| --------- | ---------------- | ------------- | ----------------| ----- |
| 1  | 4                  | 0  | 122             | 30.5           |
| 2  | 16                 | 0  | 122             | 7.625          |
| 3  | 64                 | 1  | 842             | 13.15625       |
| 4  | 256                | 1  | 842             | 3.2890625      |
| 5  | 1024               | 2  | 5882            | 5.744140625    |
| 6  | 4096               | 2  | 5882            | 1.436035156    |
| 7  | 16384              | 3  | 41162           | 2.512329102    |
| 8  | 65536              | 3  | 41162           | 0.6280822754   |
| 9  | 262144             | 4  | 288122          | 1.099098206    |
| 10 | 1048576            | 4  | 288122          | 0.2747745514   |
| 11 | 4194304            | 5  | 2016842         | 0.4808526039   |
| 12 | 16777216           | 6  | 14117882        | 0.8414913416   |
| 13 | 67108864           | 6  | 14117882        | 0.2103728354   |
| 14 | 268435456          | 7  | 98825162        | 0.3681524172   |
| 15 | 1073741824         | 8  | 691776122       | 0.644266719    |
| 16 | 4294967296         | 8  | 691776122       | 0.1610666797   |
| 17 | 17179869184        | 9  | 4842432842      | 0.2818666889   |
| 18 | 68719476736        | 10 | 33897029882     | 0.4932667053   |
| 19 | 274877906944       | 11 | 237279209162    | 0.8632167343   |
| 20 | 1099511627776      | 11 | 237279209162    | 0.2158041836   |
| 21 | 4398046511104      | 12 | 1660954464122   | 0.3776573213   |
| 22 | 17592186044416     | 13 | 11626681248842  | 0.6609003122   |
| 23 | 70368744177664     | 13 | 11626681248842  | 0.165225078    |
| 24 | 281474976710656    | 14 | 81386768741882  | 0.2891438866   |
| 25 | 1125899906842620   | 15 | 569707381193162 | 0.5060018015   |
| 26 | 4503599627370500   | 15 | 569707381193162 | 0.1265004504   |
| 27 | 18014398509482000  | 15 | 569707381193162 | 0.03162511259  |
| 28 | 72057594037927900  | 15 | 569707381193162 | 0.007906278149 |
| 29 | 288230376151712000 | 15 | 569707381193162 | 0.001976569537 |
</p>
<p>
Hexagonal cells don't align perfectly on a vector tile.
Some cells may intersect more than one vector tile.
To compute the H3 resolution for each precision, Elasticsearch compares the average density of hexagonal bins at each resolution with the average density of tile bins at each zoom level.
Elasticsearch uses the H3 resolution that is closest to the corresponding geotile density.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.SearchMvtRequestParameters.html">SearchMvtRequestParameters</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.SearchMvtResponse.html">SearchMvtResponse</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.SearchRequest.html">SearchRequest</a></dt>
      <dd><p>
Run a search.
</p>
<p>
Get search hits that match the query defined in the request.
You can provide search queries using the <code>q</code> query string parameter or the request body.
If both are specified, only the query parameter is used.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the read index privilege for the target data stream, index, or alias. For cross-cluster search, refer to the documentation about configuring CCS privileges.
To search a point in time (PIT) for an alias, you must have the <code>read</code> index privilege for the alias's data streams or indices.
</p>
<p>
<strong>Search slicing</strong>
</p>
<p>
When paging through a large number of documents, it can be helpful to split the search into multiple slices to consume them independently with the <code>slice</code> and <code>pit</code> properties.
By default the splitting is done first on the shards, then locally on each shard.
The local splitting partitions the shard into contiguous ranges based on Lucene document IDs.
</p>
<p>
For instance if the number of shards is equal to 2 and you request 4 slices, the slices 0 and 2 are assigned to the first shard and the slices 1 and 3 are assigned to the second shard.
</p>
<p>
IMPORTANT: The same point-in-time ID should be used for all slices.
If different PIT IDs are used, slices can overlap and miss documents.
This situation can occur because the splitting criterion is based on Lucene document IDs, which are not stable across changes to the index.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.SearchRequestParameters.html">SearchRequestParameters</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.SearchRequest-1.html">SearchRequest&lt;TInferDocument&gt;</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.SearchResponse-1.html">SearchResponse&lt;TDocument&gt;</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.SearchShardsRequest.html">SearchShardsRequest</a></dt>
      <dd><p>
Get the search shards.
</p>
<p>
Get the indices and shards that a search request would be run against.
This information can be useful for working out issues or planning optimizations with routing and shard preferences.
When filtered aliases are used, the filter is returned as part of the <code>indices</code> section.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the <code>view_index_metadata</code> or <code>manage</code> index privilege for the target data stream, index, or alias.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.SearchShardsRequestParameters.html">SearchShardsRequestParameters</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.SearchShardsResponse.html">SearchShardsResponse</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.SearchStats.html">SearchStats</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.SearchTemplateRequest.html">SearchTemplateRequest</a></dt>
      <dd><p>
Run a search with a search template.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.SearchTemplateRequestParameters.html">SearchTemplateRequestParameters</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.SearchTemplateResponse-1.html">SearchTemplateResponse&lt;TDocument&gt;</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.SegmentsStats.html">SegmentsStats</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ShardFailure.html">ShardFailure</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ShardStatistics.html">ShardStatistics</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.SlicedScroll.html">SlicedScroll</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.Slices.html">Slices</a></dt>
      <dd><p>
Slices configuration used to parallelize a process.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.SortOptions.html">SortOptions</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.StandardRetriever.html">StandardRetriever</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.StoreStats.html">StoreStats</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.StoredScript.html">StoredScript</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.SuffixExtensions.html">SuffixExtensions</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.TaskFailure.html">TaskFailure</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.TaskId.html">TaskId</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.TermVectorsRequestParameters.html">TermVectorsRequestParameters</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.TermVectorsRequest-1.html">TermVectorsRequest&lt;TDocument&gt;</a></dt>
      <dd><p>
Get term vector information.
</p>
<p>
Get information and statistics about terms in the fields of a particular document.
</p>
<p>
You can retrieve term vectors for documents stored in the index or for artificial documents passed in the body of the request.
You can specify the fields you are interested in through the <code>fields</code> parameter or by adding the fields to the request body.
For example:
</p>
<pre><code class="lang-csharp">GET /my-index-000001/_termvectors/1?fields=message</code></pre>
<p>
Fields can be specified using wildcards, similar to the multi match query.
</p>
<p>
Term vectors are real-time by default, not near real-time.
This can be changed by setting <code>realtime</code> parameter to <code>false</code>.
</p>
<p>
You can request three types of values: <em>term information</em>, <em>term statistics</em>, and <em>field statistics</em>.
By default, all term information and field statistics are returned for all fields but term statistics are excluded.
</p>
<p>
<strong>Term information</strong>
</p>
<ul><li>
<p>
term frequency in the field (always returned)
</p>
</li><li>
<p>
term positions (<code>positions: true</code>)
</p>
</li><li>
<p>
start and end offsets (<code>offsets: true</code>)
</p>
</li><li>
<p>
term payloads (<code>payloads: true</code>), as base64 encoded bytes
</p>
</li></ul>
<p>
If the requested information wasn't stored in the index, it will be computed on the fly if possible.
Additionally, term vectors could be computed for documents not even existing in the index, but instead provided by the user.
</p>
<p>
warn
Start and end offsets assume UTF-16 encoding is being used. If you want to use these offsets in order to get the original text that produced this token, you should make sure that the string you are taking a sub-string of is also encoded using UTF-16.
</p>
<p>
<strong>Behaviour</strong>
</p>
<p>
The term and field statistics are not accurate.
Deleted documents are not taken into account.
The information is only retrieved for the shard the requested document resides in.
The term and field statistics are therefore only useful as relative measures whereas the absolute numbers have no meaning in this context.
By default, when requesting term vectors of artificial documents, a shard to get the statistics from is randomly selected.
Use <code>routing</code> only to hit a particular shard.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.TermVectorsResponse.html">TermVectorsResponse</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.TermsEnumRequest.html">TermsEnumRequest</a></dt>
      <dd><p>
Get terms in an index.
</p>
<p>
Discover terms that match a partial string in an index.
This API is designed for low-latency look-ups used in auto-complete scenarios.
</p>
<p>
info
The terms enum API may return terms from deleted documents. Deleted documents are initially only marked as deleted. It is not until their segments are merged that documents are actually deleted. Until that happens, the terms enum API will return terms from these documents.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.TermsEnumRequestParameters.html">TermsEnumRequestParameters</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.TermsEnumResponse.html">TermsEnumResponse</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.TextEmbedding.html">TextEmbedding</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.TextSimilarityReranker.html">TextSimilarityReranker</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.TimeUnitExtensions.html">TimeUnitExtensions</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.TopLeftBottomRightGeoBounds.html">TopLeftBottomRightGeoBounds</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.TopRightBottomLeftGeoBounds.html">TopRightBottomLeftGeoBounds</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.TranslogStats.html">TranslogStats</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.Union-2.html">Union&lt;T1, T2&gt;</a></dt>
      <dd><p>Represents the union of two types, <code class="typeparamref">T1</code> and <code class="typeparamref">T2</code>.</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.UnsupportedProductException.html">UnsupportedProductException</a></dt>
      <dd><p>Thrown when the client pre-flight check determines that the server is not a supported Elasticsearch product.</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.UpdateByQueryRequest.html">UpdateByQueryRequest</a></dt>
      <dd><p>
Update documents.
Updates documents that match the specified query.
If no query is specified, performs an update on every document in the data stream or index without modifying the source, which is useful for picking up mapping changes.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or alias:
</p>
<ul><li>
<p>
<code>read</code>
</p>
</li><li>
<p>
<code>index</code> or <code>write</code>
</p>
</li></ul>
<p>
You can specify the query criteria in the request URI or the request body using the same syntax as the search API.
</p>
<p>
When you submit an update by query request, Elasticsearch gets a snapshot of the data stream or index when it begins processing the request and updates matching documents using internal versioning.
When the versions match, the document is updated and the version number is incremented.
If a document changes between the time that the snapshot is taken and the update operation is processed, it results in a version conflict and the operation fails.
You can opt to count version conflicts instead of halting and returning by setting <code>conflicts</code> to <code>proceed</code>.
Note that if you opt to count version conflicts, the operation could attempt to update more documents from the source than <code>max_docs</code> until it has successfully updated <code>max_docs</code> documents or it has gone through every document in the source query.
</p>
<p>
NOTE: Documents with a version equal to 0 cannot be updated using update by query because internal versioning does not support 0 as a valid version number.
</p>
<p>
While processing an update by query request, Elasticsearch performs multiple search requests sequentially to find all of the matching documents.
A bulk update request is performed for each batch of matching documents.
Any query or update failures cause the update by query request to fail and the failures are shown in the response.
Any update requests that completed successfully still stick, they are not rolled back.
</p>
<p>
<strong>Throttling update requests</strong>
</p>
<p>
To control the rate at which update by query issues batches of update operations, you can set <code>requests_per_second</code> to any positive decimal number.
This pads each batch with a wait time to throttle the rate.
Set <code>requests_per_second</code> to <code>-1</code> to turn off throttling.
</p>
<p>
Throttling uses a wait time between batches so that the internal scroll requests can be given a timeout that takes the request padding into account.
The padding time is the difference between the batch size divided by the <code>requests_per_second</code> and the time spent writing.
By default the batch size is 1000, so if <code>requests_per_second</code> is set to <code>500</code>:
</p>
<pre><code class="lang-csharp">target_time = 1000 / 500 per second = 2 seconds
wait_time = target_time - write_time = 2 seconds - .5 seconds = 1.5 seconds</code></pre>
<p>
Since the batch is issued as a single _bulk request, large batch sizes cause Elasticsearch to create many requests and wait before starting the next set.
This is "bursty" instead of "smooth".
</p>
<p>
<strong>Slicing</strong>
</p>
<p>
Update by query supports sliced scroll to parallelize the update process.
This can improve efficiency and provide a convenient way to break the request down into smaller parts.
</p>
<p>
Setting <code>slices</code> to <code>auto</code> chooses a reasonable number for most data streams and indices.
This setting will use one slice per shard, up to a certain limit.
If there are multiple source data streams or indices, it will choose the number of slices based on the index or backing index with the smallest number of shards.
</p>
<p>
Adding <code>slices</code> to <code>_update_by_query</code> just automates the manual process of creating sub-requests, which means it has some quirks:
</p>
<ul><li>
<p>
You can see these requests in the tasks APIs. These sub-requests are "child" tasks of the task for the request with slices.
</p>
</li><li>
<p>
Fetching the status of the task for the request with <code>slices</code> only contains the status of completed slices.
</p>
</li><li>
<p>
These sub-requests are individually addressable for things like cancellation and rethrottling.
</p>
</li><li>
<p>
Rethrottling the request with <code>slices</code> will rethrottle the unfinished sub-request proportionally.
</p>
</li><li>
<p>
Canceling the request with slices will cancel each sub-request.
</p>
</li><li>
<p>
Due to the nature of slices each sub-request won't get a perfectly even portion of the documents. All documents will be addressed, but some slices may be larger than others. Expect larger slices to have a more even distribution.
</p>
</li><li>
<p>
Parameters like <code>requests_per_second</code> and <code>max_docs</code> on a request with slices are distributed proportionally to each sub-request. Combine that with the point above about distribution being uneven and you should conclude that using <code>max_docs</code> with <code>slices</code> might not result in exactly <code>max_docs</code> documents being updated.
</p>
</li><li>
<p>
Each sub-request gets a slightly different snapshot of the source data stream or index though these are all taken at approximately the same time.
</p>
</li></ul>
<p>
If you're slicing manually or otherwise tuning automatic slicing, keep in mind that:
</p>
<ul><li>
<p>
Query performance is most efficient when the number of slices is equal to the number of shards in the index or backing index. If that number is large (for example, 500), choose a lower number as too many slices hurts performance. Setting slices higher than the number of shards generally does not improve efficiency and adds overhead.
</p>
</li><li>
<p>
Update performance scales linearly across available resources with the number of slices.
</p>
</li></ul>
<p>
Whether query or update performance dominates the runtime depends on the documents being reindexed and cluster resources.
</p>
<p>
<strong>Update the document source</strong>
</p>
<p>
Update by query supports scripts to update the document source.
As with the update API, you can set <code>ctx.op</code> to change the operation that is performed.
</p>
<p>
Set <code>ctx.op = "noop"</code> if your script decides that it doesn't have to make any changes.
The update by query operation skips updating the document and increments the <code>noop</code> counter.
</p>
<p>
Set <code>ctx.op = "delete"</code> if your script decides that the document should be deleted.
The update by query operation deletes the document and increments the <code>deleted</code> counter.
</p>
<p>
Update by query supports only <code>index</code>, <code>noop</code>, and <code>delete</code>.
Setting <code>ctx.op</code> to anything else is an error.
Setting any other field in <code>ctx</code> is an error.
This API enables you to only modify the source of matching documents; you cannot move them.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.UpdateByQueryRequestParameters.html">UpdateByQueryRequestParameters</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.UpdateByQueryResponse.html">UpdateByQueryResponse</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.UpdateByQueryRethrottleRequest.html">UpdateByQueryRethrottleRequest</a></dt>
      <dd><p>
Throttle an update by query operation.
</p>
<p>
Change the number of requests per second for a particular update by query operation.
Rethrottling that speeds up the query takes effect immediately but rethrotting that slows down the query takes effect after completing the current batch to prevent scroll timeouts.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.UpdateByQueryRethrottleRequestParameters.html">UpdateByQueryRethrottleRequestParameters</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.UpdateByQueryRethrottleResponse.html">UpdateByQueryRethrottleResponse</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.UpdateRequestParameters.html">UpdateRequestParameters</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.UpdateRequest-2.html">UpdateRequest&lt;TDocument, TPartialDocument&gt;</a></dt>
      <dd><p>
Update a document.
</p>
<p>
Update a document by running a script or passing a partial document.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the <code>index</code> or <code>write</code> index privilege for the target index or index alias.
</p>
<p>
The script can update, delete, or skip modifying the document.
The API also supports passing a partial document, which is merged into the existing document.
To fully replace an existing document, use the index API.
This operation:
</p>
<ul><li>
<p>
Gets the document (collocated with the shard) from the index.
</p>
</li><li>
<p>
Runs the specified script.
</p>
</li><li>
<p>
Indexes the result.
</p>
</li></ul>
<p>
The document must still be reindexed, but using this API removes some network roundtrips and reduces chances of version conflicts between the GET and the index operation.
</p>
<p>
The <code>_source</code> field must be enabled to use this API.
In addition to <code>_source</code>, you can access the following variables through the <code>ctx</code> map: <code>_index</code>, <code>_type</code>, <code>_id</code>, <code>_version</code>, <code>_routing</code>, and <code>_now</code> (the current timestamp).
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.UpdateResponse-1.html">UpdateResponse&lt;TDocument&gt;</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.Username.html">Username</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.WarmerStats.html">WarmerStats</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.WktGeoBounds.html">WktGeoBounds</a></dt>
      <dd></dd>
    </dl>
    <h3 id="structs">
Structs
</h3>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.BulkRequestDescriptor.html">BulkRequestDescriptor</a></dt>
      <dd><p>
Bulk index or delete documents.
Perform multiple <code>index</code>, <code>create</code>, <code>delete</code>, and <code>update</code> actions in a single request.
This reduces overhead and can greatly increase indexing speed.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or index alias:
</p>
<ul><li>
<p>
To use the <code>create</code> action, you must have the <code>create_doc</code>, <code>create</code>, <code>index</code>, or <code>write</code> index privilege. Data streams support only the <code>create</code> action.
</p>
</li><li>
<p>
To use the <code>index</code> action, you must have the <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To use the <code>delete</code> action, you must have the <code>delete</code> or <code>write</code> index privilege.
</p>
</li><li>
<p>
To use the <code>update</code> action, you must have the <code>index</code> or <code>write</code> index privilege.
</p>
</li><li>
<p>
To automatically create a data stream or index with a bulk API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege.
</p>
</li><li>
<p>
To make the result of a bulk operation visible to search using the <code>refresh</code> parameter, you must have the <code>maintenance</code> or <code>manage</code> index privilege.
</p>
</li></ul>
<p>
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
The actions are specified in the request body using a newline delimited JSON (NDJSON) structure:
</p>
<pre><code class="lang-csharp">action_and_meta_data\n
optional_source\n
action_and_meta_data\n
optional_source\n
....
action_and_meta_data\n
optional_source\n</code></pre>
<p>
The <code>index</code> and <code>create</code> actions expect a source on the next line and have the same semantics as the <code>op_type</code> parameter in the standard index API.
A <code>create</code> action fails if a document with the same ID already exists in the target
An <code>index</code> action adds or replaces a document as necessary.
</p>
<p>
NOTE: Data streams support only the <code>create</code> action.
To update or delete a document in a data stream, you must target the backing index containing the document.
</p>
<p>
An <code>update</code> action expects that the partial doc, upsert, and script and its options are specified on the next line.
</p>
<p>
A <code>delete</code> action does not expect a source on the next line and has the same semantics as the standard delete API.
</p>
<p>
NOTE: The final line of data must end with a newline character (<code>\n</code>).
Each newline character may be preceded by a carriage return (<code>\r</code>).
When sending NDJSON data to the <code>_bulk</code> endpoint, use a <code>Content-Type</code> header of <code>application/json</code> or <code>application/x-ndjson</code>.
Because this format uses literal newline characters (<code>\n</code>) as delimiters, make sure that the JSON actions and sources are not pretty printed.
</p>
<p>
If you provide a target in the request path, it is used for any actions that don't explicitly specify an <code>_index</code> argument.
</p>
<p>
A note on the format: the idea here is to make processing as fast as possible.
As some of the actions are redirected to other shards on other nodes, only <code>action_meta_data</code> is parsed on the receiving node side.
</p>
<p>
Client libraries using this protocol should try and strive to do something similar on the client side, and reduce buffering as much as possible.
</p>
<p>
There is no "correct" number of actions to perform in a single bulk request.
Experiment with different settings to find the optimal size for your particular workload.
Note that Elasticsearch limits the maximum size of a HTTP request to 100mb by default so clients must ensure that no request exceeds this size.
It is not possible to index a single document that exceeds the size limit, so you must pre-process any such documents into smaller pieces before sending them to Elasticsearch.
For instance, split documents into pages or chapters before indexing them, or store raw binary data in a system outside Elasticsearch and replace the raw data with a link to the external system in the documents that you send to Elasticsearch.
</p>
<p>
<strong>Client suppport for bulk requests</strong>
</p>
<p>
Some of the officially supported clients provide helpers to assist with bulk requests and reindexing:
</p>
<ul><li>
<p>
Go: Check out <code>esutil.BulkIndexer</code>
</p>
</li><li>
<p>
Perl: Check out <code>Search::Elasticsearch::Client::5_0::Bulk</code> and <code>Search::Elasticsearch::Client::5_0::Scroll</code>
</p>
</li><li>
<p>
Python: Check out <code>elasticsearch.helpers.*</code>
</p>
</li><li>
<p>
JavaScript: Check out <code>client.helpers.*</code>
</p>
</li><li>
<p>
.NET: Check out <code>BulkAllObservable</code>
</p>
</li><li>
<p>
PHP: Check out bulk indexing.
</p>
</li></ul>
<p>
<strong>Submitting bulk requests with cURL</strong>
</p>
<p>
If you're providing text file input to <code>curl</code>, you must use the <code>--data-binary</code> flag instead of plain <code>-d</code>.
The latter doesn't preserve newlines. For example:
</p>
<pre><code class="lang-csharp">$ cat requests
{ "index" : { "_index" : "test", "_id" : "1" } }
{ "field1" : "value1" }
$ curl -s -H "Content-Type: application/x-ndjson" -XPOST localhost:9200/_bulk --data-binary "@requests"; echo
{"took":7, "errors": false, "items":[{"index":{"_index":"test","_id":"1","_version":1,"result":"created","forced_refresh":false}}]}</code></pre>
<p>
<strong>Optimistic concurrency control</strong>
</p>
<p>
Each <code>index</code> and <code>delete</code> action within a bulk API call may include the <code>if_seq_no</code> and <code>if_primary_term</code> parameters in their respective action and meta data lines.
The <code>if_seq_no</code> and <code>if_primary_term</code> parameters control how operations are run, based on the last modification to existing documents. See Optimistic concurrency control for more details.
</p>
<p>
<strong>Versioning</strong>
</p>
<p>
Each bulk item can include the version value using the <code>version</code> field.
It automatically follows the behavior of the index or delete operation based on the <code>_version</code> mapping.
It also support the <code>version_type</code>.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
Each bulk item can include the routing value using the <code>routing</code> field.
It automatically follows the behavior of the index or delete operation based on the <code>_routing</code> mapping.
</p>
<p>
NOTE: Data streams do not support custom routing unless they were created with the <code>allow_custom_routing</code> setting enabled in the template.
</p>
<p>
<strong>Wait for active shards</strong>
</p>
<p>
When making bulk calls, you can set the <code>wait_for_active_shards</code> parameter to require a minimum number of shard copies to be active before starting to process the bulk request.
</p>
<p>
<strong>Refresh</strong>
</p>
<p>
Control when the changes made by this request are visible to search.
</p>
<p>
NOTE: Only the shards that receive the bulk request will be affected by refresh.
Imagine a <code>_bulk?refresh=wait_for</code> request with three documents in it that happen to be routed to different shards in an index with five shards.
The request will only wait for those three shards to refresh.
The other two shards that make up the index do not participate in the <code>_bulk</code> request at all.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.BulkRequestDescriptor-1.html">BulkRequestDescriptor&lt;TDocument&gt;</a></dt>
      <dd><p>
Bulk index or delete documents.
Perform multiple <code>index</code>, <code>create</code>, <code>delete</code>, and <code>update</code> actions in a single request.
This reduces overhead and can greatly increase indexing speed.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or index alias:
</p>
<ul><li>
<p>
To use the <code>create</code> action, you must have the <code>create_doc</code>, <code>create</code>, <code>index</code>, or <code>write</code> index privilege. Data streams support only the <code>create</code> action.
</p>
</li><li>
<p>
To use the <code>index</code> action, you must have the <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To use the <code>delete</code> action, you must have the <code>delete</code> or <code>write</code> index privilege.
</p>
</li><li>
<p>
To use the <code>update</code> action, you must have the <code>index</code> or <code>write</code> index privilege.
</p>
</li><li>
<p>
To automatically create a data stream or index with a bulk API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege.
</p>
</li><li>
<p>
To make the result of a bulk operation visible to search using the <code>refresh</code> parameter, you must have the <code>maintenance</code> or <code>manage</code> index privilege.
</p>
</li></ul>
<p>
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
The actions are specified in the request body using a newline delimited JSON (NDJSON) structure:
</p>
<pre><code class="lang-csharp">action_and_meta_data\n
optional_source\n
action_and_meta_data\n
optional_source\n
....
action_and_meta_data\n
optional_source\n</code></pre>
<p>
The <code>index</code> and <code>create</code> actions expect a source on the next line and have the same semantics as the <code>op_type</code> parameter in the standard index API.
A <code>create</code> action fails if a document with the same ID already exists in the target
An <code>index</code> action adds or replaces a document as necessary.
</p>
<p>
NOTE: Data streams support only the <code>create</code> action.
To update or delete a document in a data stream, you must target the backing index containing the document.
</p>
<p>
An <code>update</code> action expects that the partial doc, upsert, and script and its options are specified on the next line.
</p>
<p>
A <code>delete</code> action does not expect a source on the next line and has the same semantics as the standard delete API.
</p>
<p>
NOTE: The final line of data must end with a newline character (<code>\n</code>).
Each newline character may be preceded by a carriage return (<code>\r</code>).
When sending NDJSON data to the <code>_bulk</code> endpoint, use a <code>Content-Type</code> header of <code>application/json</code> or <code>application/x-ndjson</code>.
Because this format uses literal newline characters (<code>\n</code>) as delimiters, make sure that the JSON actions and sources are not pretty printed.
</p>
<p>
If you provide a target in the request path, it is used for any actions that don't explicitly specify an <code>_index</code> argument.
</p>
<p>
A note on the format: the idea here is to make processing as fast as possible.
As some of the actions are redirected to other shards on other nodes, only <code>action_meta_data</code> is parsed on the receiving node side.
</p>
<p>
Client libraries using this protocol should try and strive to do something similar on the client side, and reduce buffering as much as possible.
</p>
<p>
There is no "correct" number of actions to perform in a single bulk request.
Experiment with different settings to find the optimal size for your particular workload.
Note that Elasticsearch limits the maximum size of a HTTP request to 100mb by default so clients must ensure that no request exceeds this size.
It is not possible to index a single document that exceeds the size limit, so you must pre-process any such documents into smaller pieces before sending them to Elasticsearch.
For instance, split documents into pages or chapters before indexing them, or store raw binary data in a system outside Elasticsearch and replace the raw data with a link to the external system in the documents that you send to Elasticsearch.
</p>
<p>
<strong>Client suppport for bulk requests</strong>
</p>
<p>
Some of the officially supported clients provide helpers to assist with bulk requests and reindexing:
</p>
<ul><li>
<p>
Go: Check out <code>esutil.BulkIndexer</code>
</p>
</li><li>
<p>
Perl: Check out <code>Search::Elasticsearch::Client::5_0::Bulk</code> and <code>Search::Elasticsearch::Client::5_0::Scroll</code>
</p>
</li><li>
<p>
Python: Check out <code>elasticsearch.helpers.*</code>
</p>
</li><li>
<p>
JavaScript: Check out <code>client.helpers.*</code>
</p>
</li><li>
<p>
.NET: Check out <code>BulkAllObservable</code>
</p>
</li><li>
<p>
PHP: Check out bulk indexing.
</p>
</li></ul>
<p>
<strong>Submitting bulk requests with cURL</strong>
</p>
<p>
If you're providing text file input to <code>curl</code>, you must use the <code>--data-binary</code> flag instead of plain <code>-d</code>.
The latter doesn't preserve newlines. For example:
</p>
<pre><code class="lang-csharp">$ cat requests
{ "index" : { "_index" : "test", "_id" : "1" } }
{ "field1" : "value1" }
$ curl -s -H "Content-Type: application/x-ndjson" -XPOST localhost:9200/_bulk --data-binary "@requests"; echo
{"took":7, "errors": false, "items":[{"index":{"_index":"test","_id":"1","_version":1,"result":"created","forced_refresh":false}}]}</code></pre>
<p>
<strong>Optimistic concurrency control</strong>
</p>
<p>
Each <code>index</code> and <code>delete</code> action within a bulk API call may include the <code>if_seq_no</code> and <code>if_primary_term</code> parameters in their respective action and meta data lines.
The <code>if_seq_no</code> and <code>if_primary_term</code> parameters control how operations are run, based on the last modification to existing documents. See Optimistic concurrency control for more details.
</p>
<p>
<strong>Versioning</strong>
</p>
<p>
Each bulk item can include the version value using the <code>version</code> field.
It automatically follows the behavior of the index or delete operation based on the <code>_version</code> mapping.
It also support the <code>version_type</code>.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
Each bulk item can include the routing value using the <code>routing</code> field.
It automatically follows the behavior of the index or delete operation based on the <code>_routing</code> mapping.
</p>
<p>
NOTE: Data streams do not support custom routing unless they were created with the <code>allow_custom_routing</code> setting enabled in the template.
</p>
<p>
<strong>Wait for active shards</strong>
</p>
<p>
When making bulk calls, you can set the <code>wait_for_active_shards</code> parameter to require a minimum number of shard copies to be active before starting to process the bulk request.
</p>
<p>
<strong>Refresh</strong>
</p>
<p>
Control when the changes made by this request are visible to search.
</p>
<p>
NOTE: Only the shards that receive the bulk request will be affected by refresh.
Imagine a <code>_bulk?refresh=wait_for</code> request with three documents in it that happen to be routed to different shards in an index with five shards.
The request will only wait for those three shards to refresh.
The other two shards that make up the index do not participate in the <code>_bulk</code> request at all.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ByteSizeFactory.html">ByteSizeFactory</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ClearScrollRequestDescriptor.html">ClearScrollRequestDescriptor</a></dt>
      <dd><p>
Clear a scrolling search.
Clear the search context and results for a scrolling search.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ClosePointInTimeRequestDescriptor.html">ClosePointInTimeRequestDescriptor</a></dt>
      <dd><p>
Close a point in time.
A point in time must be opened explicitly before being used in search requests.
The <code>keep_alive</code> parameter tells Elasticsearch how long it should persist.
A point in time is automatically closed when the <code>keep_alive</code> period has elapsed.
However, keeping points in time has a cost; close them as soon as they are no longer required for search requests.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.CoordsGeoBoundsDescriptor.html">CoordsGeoBoundsDescriptor</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.CountRequestDescriptor.html">CountRequestDescriptor</a></dt>
      <dd><p>
Count search results.
Get the number of documents matching a query.
</p>
<p>
The query can be provided either by using a simple query string as a parameter, or by defining Query DSL within the request body.
The query is optional. When no query is provided, the API uses <code>match_all</code> to count all the documents.
</p>
<p>
The count API supports multi-target syntax. You can run a single count API search across multiple data streams and indices.
</p>
<p>
The operation is broadcast across all shards.
For each shard ID group, a replica is chosen and the search is run against it.
This means that replicas increase the scalability of the count.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.CountRequestDescriptor-1.html">CountRequestDescriptor&lt;TDocument&gt;</a></dt>
      <dd><p>
Count search results.
Get the number of documents matching a query.
</p>
<p>
The query can be provided either by using a simple query string as a parameter, or by defining Query DSL within the request body.
The query is optional. When no query is provided, the API uses <code>match_all</code> to count all the documents.
</p>
<p>
The count API supports multi-target syntax. You can run a single count API search across multiple data streams and indices.
</p>
<p>
The operation is broadcast across all shards.
For each shard ID group, a replica is chosen and the search is run against it.
This means that replicas increase the scalability of the count.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.CreateRequestDescriptor-1.html">CreateRequestDescriptor&lt;TDocument&gt;</a></dt>
      <dd><p>
Create a new document in the index.
</p>
<p>
You can index a new JSON document with the <code>/&lt;target&gt;/_doc/</code> or <code>/&lt;target&gt;/_create/&lt;_id&gt;</code> APIs
Using <code>_create</code> guarantees that the document is indexed only if it does not already exist.
It returns a 409 response when a document with a same ID already exists in the index.
To update an existing document, you must use the <code>/&lt;target&gt;/_doc/</code> API.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or index alias:
</p>
<ul><li>
<p>
To add a document using the <code>PUT /&lt;target&gt;/_create/&lt;_id&gt;</code> or <code>POST /&lt;target&gt;/_create/&lt;_id&gt;</code> request formats, you must have the <code>create_doc</code>, <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To automatically create a data stream or index with this API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege.
</p>
</li></ul>
<p>
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
<strong>Automatically create data streams and indices</strong>
</p>
<p>
If the request's target doesn't exist and matches an index template with a <code>data_stream</code> definition, the index operation automatically creates the data stream.
</p>
<p>
If the target doesn't exist and doesn't match a data stream template, the operation automatically creates the index and applies any matching index templates.
</p>
<p>
NOTE: Elasticsearch includes several built-in index templates. To avoid naming collisions with these templates, refer to index pattern documentation.
</p>
<p>
If no mapping exists, the index operation creates a dynamic mapping.
By default, new fields and objects are automatically added to the mapping if needed.
</p>
<p>
Automatic index creation is controlled by the <code>action.auto_create_index</code> setting.
If it is <code>true</code>, any index can be created automatically.
You can modify this setting to explicitly allow or block automatic creation of indices that match specified patterns or set it to <code>false</code> to turn off automatic index creation entirely.
Specify a comma-separated list of patterns you want to allow or prefix each pattern with <code>+</code> or <code>-</code> to indicate whether it should be allowed or blocked.
When a list is specified, the default behaviour is to disallow.
</p>
<p>
NOTE: The <code>action.auto_create_index</code> setting affects the automatic creation of indices only.
It does not affect the creation of data streams.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
By default, shard placement — or routing — is controlled by using a hash of the document's ID value.
For more explicit control, the value fed into the hash function used by the router can be directly specified on a per-operation basis using the <code>routing</code> parameter.
</p>
<p>
When setting up explicit mapping, you can also use the <code>_routing</code> field to direct the index operation to extract the routing value from the document itself.
This does come at the (very minimal) cost of an additional document parsing pass.
If the <code>_routing</code> mapping is defined and set to be required, the index operation will fail if no routing value is provided or extracted.
</p>
<p>
NOTE: Data streams do not support custom routing unless they were created with the <code>allow_custom_routing</code> setting enabled in the template.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The index operation is directed to the primary shard based on its route and performed on the actual node containing this shard.
After the primary shard completes the operation, if needed, the update is distributed to applicable replicas.
</p>
<p>
<strong>Active shards</strong>
</p>
<p>
To improve the resiliency of writes to the system, indexing operations can be configured to wait for a certain number of active shard copies before proceeding with the operation.
If the requisite number of active shard copies are not available, then the write operation must wait and retry, until either the requisite shard copies have started or a timeout occurs.
By default, write operations only wait for the primary shards to be active before proceeding (that is to say <code>wait_for_active_shards</code> is <code>1</code>).
This default can be overridden in the index settings dynamically by setting <code>index.write.wait_for_active_shards</code>.
To alter this behavior per operation, use the <code>wait_for_active_shards request</code> parameter.
</p>
<p>
Valid values are all or any positive integer up to the total number of configured copies per shard in the index (which is <code>number_of_replicas</code>+1).
Specifying a negative value or a number greater than the number of shard copies will throw an error.
</p>
<p>
For example, suppose you have a cluster of three nodes, A, B, and C and you create an index index with the number of replicas set to 3 (resulting in 4 shard copies, one more copy than there are nodes).
If you attempt an indexing operation, by default the operation will only ensure the primary copy of each shard is available before proceeding.
This means that even if B and C went down and A hosted the primary shard copies, the indexing operation would still proceed with only one copy of the data.
If <code>wait_for_active_shards</code> is set on the request to <code>3</code> (and all three nodes are up), the indexing operation will require 3 active shard copies before proceeding.
This requirement should be met because there are 3 active nodes in the cluster, each one holding a copy of the shard.
However, if you set <code>wait_for_active_shards</code> to <code>all</code> (or to <code>4</code>, which is the same in this situation), the indexing operation will not proceed as you do not have all 4 copies of each shard active in the index.
The operation will timeout unless a new node is brought up in the cluster to host the fourth copy of the shard.
</p>
<p>
It is important to note that this setting greatly reduces the chances of the write operation not writing to the requisite number of shard copies, but it does not completely eliminate the possibility, because this check occurs before the write operation starts.
After the write operation is underway, it is still possible for replication to fail on any number of shard copies but still succeed on the primary.
The <code>_shards</code> section of the API response reveals the number of shard copies on which replication succeeded and failed.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.DeleteByQueryRequestDescriptor.html">DeleteByQueryRequestDescriptor</a></dt>
      <dd><p>
Delete documents.
</p>
<p>
Deletes documents that match the specified query.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or alias:
</p>
<ul><li>
<p>
<code>read</code>
</p>
</li><li>
<p>
<code>delete</code> or <code>write</code>
</p>
</li></ul>
<p>
You can specify the query criteria in the request URI or the request body using the same syntax as the search API.
When you submit a delete by query request, Elasticsearch gets a snapshot of the data stream or index when it begins processing the request and deletes matching documents using internal versioning.
If a document changes between the time that the snapshot is taken and the delete operation is processed, it results in a version conflict and the delete operation fails.
</p>
<p>
NOTE: Documents with a version equal to 0 cannot be deleted using delete by query because internal versioning does not support 0 as a valid version number.
</p>
<p>
While processing a delete by query request, Elasticsearch performs multiple search requests sequentially to find all of the matching documents to delete.
A bulk delete request is performed for each batch of matching documents.
If a search or bulk request is rejected, the requests are retried up to 10 times, with exponential back off.
If the maximum retry limit is reached, processing halts and all failed requests are returned in the response.
Any delete requests that completed successfully still stick, they are not rolled back.
</p>
<p>
You can opt to count version conflicts instead of halting and returning by setting <code>conflicts</code> to <code>proceed</code>.
Note that if you opt to count version conflicts the operation could attempt to delete more documents from the source than <code>max_docs</code> until it has successfully deleted <code>max_docs documents</code>, or it has gone through every document in the source query.
</p>
<p>
<strong>Throttling delete requests</strong>
</p>
<p>
To control the rate at which delete by query issues batches of delete operations, you can set <code>requests_per_second</code> to any positive decimal number.
This pads each batch with a wait time to throttle the rate.
Set <code>requests_per_second</code> to <code>-1</code> to disable throttling.
</p>
<p>
Throttling uses a wait time between batches so that the internal scroll requests can be given a timeout that takes the request padding into account.
The padding time is the difference between the batch size divided by the <code>requests_per_second</code> and the time spent writing.
By default the batch size is <code>1000</code>, so if <code>requests_per_second</code> is set to <code>500</code>:
</p>
<pre><code class="lang-csharp">target_time = 1000 / 500 per second = 2 seconds
wait_time = target_time - write_time = 2 seconds - .5 seconds = 1.5 seconds</code></pre>
<p>
Since the batch is issued as a single <code>_bulk</code> request, large batch sizes cause Elasticsearch to create many requests and wait before starting the next set.
This is "bursty" instead of "smooth".
</p>
<p>
<strong>Slicing</strong>
</p>
<p>
Delete by query supports sliced scroll to parallelize the delete process.
This can improve efficiency and provide a convenient way to break the request down into smaller parts.
</p>
<p>
Setting <code>slices</code> to <code>auto</code> lets Elasticsearch choose the number of slices to use.
This setting will use one slice per shard, up to a certain limit.
If there are multiple source data streams or indices, it will choose the number of slices based on the index or backing index with the smallest number of shards.
Adding slices to the delete by query operation creates sub-requests which means it has some quirks:
</p>
<ul><li>
<p>
You can see these requests in the tasks APIs. These sub-requests are "child" tasks of the task for the request with slices.
</p>
</li><li>
<p>
Fetching the status of the task for the request with slices only contains the status of completed slices.
</p>
</li><li>
<p>
These sub-requests are individually addressable for things like cancellation and rethrottling.
</p>
</li><li>
<p>
Rethrottling the request with <code>slices</code> will rethrottle the unfinished sub-request proportionally.
</p>
</li><li>
<p>
Canceling the request with <code>slices</code> will cancel each sub-request.
</p>
</li><li>
<p>
Due to the nature of <code>slices</code> each sub-request won't get a perfectly even portion of the documents. All documents will be addressed, but some slices may be larger than others. Expect larger slices to have a more even distribution.
</p>
</li><li>
<p>
Parameters like <code>requests_per_second</code> and <code>max_docs</code> on a request with <code>slices</code> are distributed proportionally to each sub-request. Combine that with the earlier point about distribution being uneven and you should conclude that using <code>max_docs</code> with <code>slices</code> might not result in exactly <code>max_docs</code> documents being deleted.
</p>
</li><li>
<p>
Each sub-request gets a slightly different snapshot of the source data stream or index though these are all taken at approximately the same time.
</p>
</li></ul>
<p>
If you're slicing manually or otherwise tuning automatic slicing, keep in mind that:
</p>
<ul><li>
<p>
Query performance is most efficient when the number of slices is equal to the number of shards in the index or backing index. If that number is large (for example, 500), choose a lower number as too many <code>slices</code> hurts performance. Setting <code>slices</code> higher than the number of shards generally does not improve efficiency and adds overhead.
</p>
</li><li>
<p>
Delete performance scales linearly across available resources with the number of slices.
</p>
</li></ul>
<p>
Whether query or delete performance dominates the runtime depends on the documents being reindexed and cluster resources.
</p>
<p>
<strong>Cancel a delete by query operation</strong>
</p>
<p>
Any delete by query can be canceled using the task cancel API. For example:
</p>
<pre><code class="lang-csharp">POST _tasks/r1A2WoRbTwKZ516z6NEs5A:36619/_cancel</code></pre>
<p>
The task ID can be found by using the get tasks API.
</p>
<p>
Cancellation should happen quickly but might take a few seconds.
The get task status API will continue to list the delete by query task until this task checks that it has been cancelled and terminates itself.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.DeleteByQueryRequestDescriptor-1.html">DeleteByQueryRequestDescriptor&lt;TDocument&gt;</a></dt>
      <dd><p>
Delete documents.
</p>
<p>
Deletes documents that match the specified query.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or alias:
</p>
<ul><li>
<p>
<code>read</code>
</p>
</li><li>
<p>
<code>delete</code> or <code>write</code>
</p>
</li></ul>
<p>
You can specify the query criteria in the request URI or the request body using the same syntax as the search API.
When you submit a delete by query request, Elasticsearch gets a snapshot of the data stream or index when it begins processing the request and deletes matching documents using internal versioning.
If a document changes between the time that the snapshot is taken and the delete operation is processed, it results in a version conflict and the delete operation fails.
</p>
<p>
NOTE: Documents with a version equal to 0 cannot be deleted using delete by query because internal versioning does not support 0 as a valid version number.
</p>
<p>
While processing a delete by query request, Elasticsearch performs multiple search requests sequentially to find all of the matching documents to delete.
A bulk delete request is performed for each batch of matching documents.
If a search or bulk request is rejected, the requests are retried up to 10 times, with exponential back off.
If the maximum retry limit is reached, processing halts and all failed requests are returned in the response.
Any delete requests that completed successfully still stick, they are not rolled back.
</p>
<p>
You can opt to count version conflicts instead of halting and returning by setting <code>conflicts</code> to <code>proceed</code>.
Note that if you opt to count version conflicts the operation could attempt to delete more documents from the source than <code>max_docs</code> until it has successfully deleted <code>max_docs documents</code>, or it has gone through every document in the source query.
</p>
<p>
<strong>Throttling delete requests</strong>
</p>
<p>
To control the rate at which delete by query issues batches of delete operations, you can set <code>requests_per_second</code> to any positive decimal number.
This pads each batch with a wait time to throttle the rate.
Set <code>requests_per_second</code> to <code>-1</code> to disable throttling.
</p>
<p>
Throttling uses a wait time between batches so that the internal scroll requests can be given a timeout that takes the request padding into account.
The padding time is the difference between the batch size divided by the <code>requests_per_second</code> and the time spent writing.
By default the batch size is <code>1000</code>, so if <code>requests_per_second</code> is set to <code>500</code>:
</p>
<pre><code class="lang-csharp">target_time = 1000 / 500 per second = 2 seconds
wait_time = target_time - write_time = 2 seconds - .5 seconds = 1.5 seconds</code></pre>
<p>
Since the batch is issued as a single <code>_bulk</code> request, large batch sizes cause Elasticsearch to create many requests and wait before starting the next set.
This is "bursty" instead of "smooth".
</p>
<p>
<strong>Slicing</strong>
</p>
<p>
Delete by query supports sliced scroll to parallelize the delete process.
This can improve efficiency and provide a convenient way to break the request down into smaller parts.
</p>
<p>
Setting <code>slices</code> to <code>auto</code> lets Elasticsearch choose the number of slices to use.
This setting will use one slice per shard, up to a certain limit.
If there are multiple source data streams or indices, it will choose the number of slices based on the index or backing index with the smallest number of shards.
Adding slices to the delete by query operation creates sub-requests which means it has some quirks:
</p>
<ul><li>
<p>
You can see these requests in the tasks APIs. These sub-requests are "child" tasks of the task for the request with slices.
</p>
</li><li>
<p>
Fetching the status of the task for the request with slices only contains the status of completed slices.
</p>
</li><li>
<p>
These sub-requests are individually addressable for things like cancellation and rethrottling.
</p>
</li><li>
<p>
Rethrottling the request with <code>slices</code> will rethrottle the unfinished sub-request proportionally.
</p>
</li><li>
<p>
Canceling the request with <code>slices</code> will cancel each sub-request.
</p>
</li><li>
<p>
Due to the nature of <code>slices</code> each sub-request won't get a perfectly even portion of the documents. All documents will be addressed, but some slices may be larger than others. Expect larger slices to have a more even distribution.
</p>
</li><li>
<p>
Parameters like <code>requests_per_second</code> and <code>max_docs</code> on a request with <code>slices</code> are distributed proportionally to each sub-request. Combine that with the earlier point about distribution being uneven and you should conclude that using <code>max_docs</code> with <code>slices</code> might not result in exactly <code>max_docs</code> documents being deleted.
</p>
</li><li>
<p>
Each sub-request gets a slightly different snapshot of the source data stream or index though these are all taken at approximately the same time.
</p>
</li></ul>
<p>
If you're slicing manually or otherwise tuning automatic slicing, keep in mind that:
</p>
<ul><li>
<p>
Query performance is most efficient when the number of slices is equal to the number of shards in the index or backing index. If that number is large (for example, 500), choose a lower number as too many <code>slices</code> hurts performance. Setting <code>slices</code> higher than the number of shards generally does not improve efficiency and adds overhead.
</p>
</li><li>
<p>
Delete performance scales linearly across available resources with the number of slices.
</p>
</li></ul>
<p>
Whether query or delete performance dominates the runtime depends on the documents being reindexed and cluster resources.
</p>
<p>
<strong>Cancel a delete by query operation</strong>
</p>
<p>
Any delete by query can be canceled using the task cancel API. For example:
</p>
<pre><code class="lang-csharp">POST _tasks/r1A2WoRbTwKZ516z6NEs5A:36619/_cancel</code></pre>
<p>
The task ID can be found by using the get tasks API.
</p>
<p>
Cancellation should happen quickly but might take a few seconds.
The get task status API will continue to list the delete by query task until this task checks that it has been cancelled and terminates itself.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.DeleteByQueryRethrottleRequestDescriptor.html">DeleteByQueryRethrottleRequestDescriptor</a></dt>
      <dd><p>
Throttle a delete by query operation.
</p>
<p>
Change the number of requests per second for a particular delete by query operation.
Rethrottling that speeds up the query takes effect immediately but rethrotting that slows down the query takes effect after completing the current batch to prevent scroll timeouts.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.DeleteRequestDescriptor.html">DeleteRequestDescriptor</a></dt>
      <dd><p>
Delete a document.
</p>
<p>
Remove a JSON document from the specified index.
</p>
<p>
NOTE: You cannot send deletion requests directly to a data stream.
To delete a document in a data stream, you must target the backing index containing the document.
</p>
<p>
<strong>Optimistic concurrency control</strong>
</p>
<p>
Delete operations can be made conditional and only be performed if the last modification to the document was assigned the sequence number and primary term specified by the <code>if_seq_no</code> and <code>if_primary_term</code> parameters.
If a mismatch is detected, the operation will result in a <code>VersionConflictException</code> and a status code of <code>409</code>.
</p>
<p>
<strong>Versioning</strong>
</p>
<p>
Each document indexed is versioned.
When deleting a document, the version can be specified to make sure the relevant document you are trying to delete is actually being deleted and it has not changed in the meantime.
Every write operation run on a document, deletes included, causes its version to be incremented.
The version number of a deleted document remains available for a short time after deletion to allow for control of concurrent operations.
The length of time for which a deleted document's version remains available is determined by the <code>index.gc_deletes</code> index setting.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
If routing is used during indexing, the routing value also needs to be specified to delete a document.
</p>
<p>
If the <code>_routing</code> mapping is set to <code>required</code> and no routing value is specified, the delete API throws a <code>RoutingMissingException</code> and rejects the request.
</p>
<p>
For example:
</p>
<pre><code class="lang-csharp">DELETE /my-index-000001/_doc/1?routing=shard-1</code></pre>
<p>
This request deletes the document with ID 1, but it is routed based on the user.
The document is not deleted if the correct routing is not specified.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The delete operation gets hashed into a specific shard ID.
It then gets redirected into the primary shard within that ID group and replicated (if needed) to shard replicas within that ID group.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.DeleteRequestDescriptor-1.html">DeleteRequestDescriptor&lt;TDocument&gt;</a></dt>
      <dd><p>
Delete a document.
</p>
<p>
Remove a JSON document from the specified index.
</p>
<p>
NOTE: You cannot send deletion requests directly to a data stream.
To delete a document in a data stream, you must target the backing index containing the document.
</p>
<p>
<strong>Optimistic concurrency control</strong>
</p>
<p>
Delete operations can be made conditional and only be performed if the last modification to the document was assigned the sequence number and primary term specified by the <code>if_seq_no</code> and <code>if_primary_term</code> parameters.
If a mismatch is detected, the operation will result in a <code>VersionConflictException</code> and a status code of <code>409</code>.
</p>
<p>
<strong>Versioning</strong>
</p>
<p>
Each document indexed is versioned.
When deleting a document, the version can be specified to make sure the relevant document you are trying to delete is actually being deleted and it has not changed in the meantime.
Every write operation run on a document, deletes included, causes its version to be incremented.
The version number of a deleted document remains available for a short time after deletion to allow for control of concurrent operations.
The length of time for which a deleted document's version remains available is determined by the <code>index.gc_deletes</code> index setting.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
If routing is used during indexing, the routing value also needs to be specified to delete a document.
</p>
<p>
If the <code>_routing</code> mapping is set to <code>required</code> and no routing value is specified, the delete API throws a <code>RoutingMissingException</code> and rejects the request.
</p>
<p>
For example:
</p>
<pre><code class="lang-csharp">DELETE /my-index-000001/_doc/1?routing=shard-1</code></pre>
<p>
This request deletes the document with ID 1, but it is routed based on the user.
The document is not deleted if the correct routing is not specified.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The delete operation gets hashed into a specific shard ID.
It then gets redirected into the primary shard within that ID group and replicated (if needed) to shard replicas within that ID group.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.DeleteScriptRequestDescriptor.html">DeleteScriptRequestDescriptor</a></dt>
      <dd><p>
Delete a script or search template.
Deletes a stored script or search template.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.EmptyObjectDescriptor.html">EmptyObjectDescriptor</a></dt>
      <dd><p>
For empty Class assignments
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ExistsRequestDescriptor.html">ExistsRequestDescriptor</a></dt>
      <dd><p>
Check a document.
</p>
<p>
Verify that a document exists.
For example, check to see if a document with the <code>_id</code> 0 exists:
</p>
<pre><code class="lang-csharp">HEAD my-index-000001/_doc/0</code></pre>
<p>
If the document exists, the API returns a status code of <code>200 - OK</code>.
If the document doesn’t exist, the API returns <code>404 - Not Found</code>.
</p>
<p>
<strong>Versioning support</strong>
</p>
<p>
You can use the <code>version</code> parameter to check the document only if its current version is equal to the specified one.
</p>
<p>
Internally, Elasticsearch has marked the old document as deleted and added an entirely new document.
The old version of the document doesn't disappear immediately, although you won't be able to access it.
Elasticsearch cleans up deleted documents in the background as you continue to index more data.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ExistsRequestDescriptor-1.html">ExistsRequestDescriptor&lt;TDocument&gt;</a></dt>
      <dd><p>
Check a document.
</p>
<p>
Verify that a document exists.
For example, check to see if a document with the <code>_id</code> 0 exists:
</p>
<pre><code class="lang-csharp">HEAD my-index-000001/_doc/0</code></pre>
<p>
If the document exists, the API returns a status code of <code>200 - OK</code>.
If the document doesn’t exist, the API returns <code>404 - Not Found</code>.
</p>
<p>
<strong>Versioning support</strong>
</p>
<p>
You can use the <code>version</code> parameter to check the document only if its current version is equal to the specified one.
</p>
<p>
Internally, Elasticsearch has marked the old document as deleted and added an entirely new document.
The old version of the document doesn't disappear immediately, although you won't be able to access it.
Elasticsearch cleans up deleted documents in the background as you continue to index more data.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ExistsSourceRequestDescriptor.html">ExistsSourceRequestDescriptor</a></dt>
      <dd><p>
Check for a document source.
</p>
<p>
Check whether a document source exists in an index.
For example:
</p>
<pre><code class="lang-csharp">HEAD my-index-000001/_source/1</code></pre>
<p>
A document's source is not available if it is disabled in the mapping.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ExistsSourceRequestDescriptor-1.html">ExistsSourceRequestDescriptor&lt;TDocument&gt;</a></dt>
      <dd><p>
Check for a document source.
</p>
<p>
Check whether a document source exists in an index.
For example:
</p>
<pre><code class="lang-csharp">HEAD my-index-000001/_source/1</code></pre>
<p>
A document's source is not available if it is disabled in the mapping.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ExplainRequestDescriptor.html">ExplainRequestDescriptor</a></dt>
      <dd><p>
Explain a document match result.
Get information about why a specific document matches, or doesn't match, a query.
It computes a score explanation for a query and a specific document.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ExplainRequestDescriptor-1.html">ExplainRequestDescriptor&lt;TDocument&gt;</a></dt>
      <dd><p>
Explain a document match result.
Get information about why a specific document matches, or doesn't match, a query.
It computes a score explanation for a query and a specific document.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.FieldCapsRequestDescriptor.html">FieldCapsRequestDescriptor</a></dt>
      <dd><p>
Get the field capabilities.
</p>
<p>
Get information about the capabilities of fields among multiple indices.
</p>
<p>
For data streams, the API returns field capabilities among the stream’s backing indices.
It returns runtime fields like any other field.
For example, a runtime field with a type of keyword is returned the same as any other field that belongs to the <code>keyword</code> family.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.FieldCapsRequestDescriptor-1.html">FieldCapsRequestDescriptor&lt;TDocument&gt;</a></dt>
      <dd><p>
Get the field capabilities.
</p>
<p>
Get information about the capabilities of fields among multiple indices.
</p>
<p>
For data streams, the API returns field capabilities among the stream’s backing indices.
It returns runtime fields like any other field.
For example, a runtime field with a type of keyword is returned the same as any other field that belongs to the <code>keyword</code> family.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.FieldSortDescriptor.html">FieldSortDescriptor</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.FieldSortDescriptor-1.html">FieldSortDescriptor&lt;TDocument&gt;</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.FieldValue.html">FieldValue</a></dt>
      <dd><p>Represents a value for a field which depends on the field mapping and is only known at runtime,
therefore cannot be specifically typed.</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.FieldValues.html">FieldValues</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.FuzzinessFactory.html">FuzzinessFactory</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.GeoBoundsFactory.html">GeoBoundsFactory</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.GeoDistanceSortDescriptor.html">GeoDistanceSortDescriptor</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.GeoDistanceSortDescriptor-1.html">GeoDistanceSortDescriptor&lt;TDocument&gt;</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.GeoHashLocationDescriptor.html">GeoHashLocationDescriptor</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.GeoLocationFactory.html">GeoLocationFactory</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.GeohashPrecisionFactory.html">GeohashPrecisionFactory</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.GetRequestDescriptor.html">GetRequestDescriptor</a></dt>
      <dd><p>
Get a document by its ID.
</p>
<p>
Get a document and its source or stored fields from an index.
</p>
<p>
By default, this API is realtime and is not affected by the refresh rate of the index (when data will become visible for search).
In the case where stored fields are requested with the <code>stored_fields</code> parameter and the document has been updated but is not yet refreshed, the API will have to parse and analyze the source to extract the stored fields.
To turn off realtime behavior, set the <code>realtime</code> parameter to false.
</p>
<p>
<strong>Source filtering</strong>
</p>
<p>
By default, the API returns the contents of the <code>_source</code> field unless you have used the <code>stored_fields</code> parameter or the <code>_source</code> field is turned off.
You can turn off <code>_source</code> retrieval by using the <code>_source</code> parameter:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/0?_source=false</code></pre>
<p>
If you only need one or two fields from the <code>_source</code>, use the <code>_source_includes</code> or <code>_source_excludes</code> parameters to include or filter out particular fields.
This can be helpful with large documents where partial retrieval can save on network overhead
Both parameters take a comma separated list of fields or wildcard expressions.
For example:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/0?_source_includes=*.id&amp;_source_excludes=entities</code></pre>
<p>
If you only want to specify includes, you can use a shorter notation:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/0?_source=*.id</code></pre>
<p>
<strong>Routing</strong>
</p>
<p>
If routing is used during indexing, the routing value also needs to be specified to retrieve a document.
For example:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/2?routing=user1</code></pre>
<p>
This request gets the document with ID 2, but it is routed based on the user.
The document is not fetched if the correct routing is not specified.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The GET operation is hashed into a specific shard ID.
It is then redirected to one of the replicas within that shard ID and returns the result.
The replicas are the primary shard and its replicas within that shard ID group.
This means that the more replicas you have, the better your GET scaling will be.
</p>
<p>
<strong>Versioning support</strong>
</p>
<p>
You can use the <code>version</code> parameter to retrieve the document only if its current version is equal to the specified one.
</p>
<p>
Internally, Elasticsearch has marked the old document as deleted and added an entirely new document.
The old version of the document doesn't disappear immediately, although you won't be able to access it.
Elasticsearch cleans up deleted documents in the background as you continue to index more data.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.GetRequestDescriptor-1.html">GetRequestDescriptor&lt;TDocument&gt;</a></dt>
      <dd><p>
Get a document by its ID.
</p>
<p>
Get a document and its source or stored fields from an index.
</p>
<p>
By default, this API is realtime and is not affected by the refresh rate of the index (when data will become visible for search).
In the case where stored fields are requested with the <code>stored_fields</code> parameter and the document has been updated but is not yet refreshed, the API will have to parse and analyze the source to extract the stored fields.
To turn off realtime behavior, set the <code>realtime</code> parameter to false.
</p>
<p>
<strong>Source filtering</strong>
</p>
<p>
By default, the API returns the contents of the <code>_source</code> field unless you have used the <code>stored_fields</code> parameter or the <code>_source</code> field is turned off.
You can turn off <code>_source</code> retrieval by using the <code>_source</code> parameter:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/0?_source=false</code></pre>
<p>
If you only need one or two fields from the <code>_source</code>, use the <code>_source_includes</code> or <code>_source_excludes</code> parameters to include or filter out particular fields.
This can be helpful with large documents where partial retrieval can save on network overhead
Both parameters take a comma separated list of fields or wildcard expressions.
For example:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/0?_source_includes=*.id&amp;_source_excludes=entities</code></pre>
<p>
If you only want to specify includes, you can use a shorter notation:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/0?_source=*.id</code></pre>
<p>
<strong>Routing</strong>
</p>
<p>
If routing is used during indexing, the routing value also needs to be specified to retrieve a document.
For example:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_doc/2?routing=user1</code></pre>
<p>
This request gets the document with ID 2, but it is routed based on the user.
The document is not fetched if the correct routing is not specified.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The GET operation is hashed into a specific shard ID.
It is then redirected to one of the replicas within that shard ID and returns the result.
The replicas are the primary shard and its replicas within that shard ID group.
This means that the more replicas you have, the better your GET scaling will be.
</p>
<p>
<strong>Versioning support</strong>
</p>
<p>
You can use the <code>version</code> parameter to retrieve the document only if its current version is equal to the specified one.
</p>
<p>
Internally, Elasticsearch has marked the old document as deleted and added an entirely new document.
The old version of the document doesn't disappear immediately, although you won't be able to access it.
Elasticsearch cleans up deleted documents in the background as you continue to index more data.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.GetScriptContextRequestDescriptor.html">GetScriptContextRequestDescriptor</a></dt>
      <dd><p>
Get script contexts.
</p>
<p>
Get a list of supported script contexts and their methods.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.GetScriptLanguagesRequestDescriptor.html">GetScriptLanguagesRequestDescriptor</a></dt>
      <dd><p>
Get script languages.
</p>
<p>
Get a list of available script types, languages, and contexts.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.GetScriptRequestDescriptor.html">GetScriptRequestDescriptor</a></dt>
      <dd><p>
Get a script or search template.
Retrieves a stored script or search template.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.GetSourceRequestDescriptor.html">GetSourceRequestDescriptor</a></dt>
      <dd><p>
Get a document's source.
</p>
<p>
Get the source of a document.
For example:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_source/1</code></pre>
<p>
You can use the source filtering parameters to control which parts of the <code>_source</code> are returned:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_source/1/?_source_includes=*.id&amp;_source_excludes=entities</code></pre>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.GetSourceRequestDescriptor-1.html">GetSourceRequestDescriptor&lt;TDocument&gt;</a></dt>
      <dd><p>
Get a document's source.
</p>
<p>
Get the source of a document.
For example:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_source/1</code></pre>
<p>
You can use the source filtering parameters to control which parts of the <code>_source</code> are returned:
</p>
<pre><code class="lang-csharp">GET my-index-000001/_source/1/?_source_includes=*.id&amp;_source_excludes=entities</code></pre>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.HealthReportRequestDescriptor.html">HealthReportRequestDescriptor</a></dt>
      <dd><p>
Get the cluster health.
Get a report with the health status of an Elasticsearch cluster.
The report contains a list of indicators that compose Elasticsearch functionality.
</p>
<p>
Each indicator has a health status of: green, unknown, yellow or red.
The indicator will provide an explanation and metadata describing the reason for its current health status.
</p>
<p>
The cluster’s status is controlled by the worst indicator status.
</p>
<p>
In the event that an indicator’s status is non-green, a list of impacts may be present in the indicator result which detail the functionalities that are negatively affected by the health issue.
Each impact carries with it a severity level, an area of the system that is affected, and a simple description of the impact on the system.
</p>
<p>
Some health indicators can determine the root cause of a health problem and prescribe a set of steps that can be performed in order to improve the health of the system.
The root cause and remediation steps are encapsulated in a diagnosis.
A diagnosis contains a cause detailing a root cause analysis, an action containing a brief description of the steps to take to fix the problem, the list of affected resources (if applicable), and a detailed step-by-step troubleshooting guide to fix the diagnosed problem.
</p>
<p>
NOTE: The health indicators perform root cause analysis of non-green health statuses. This can be computationally expensive when called frequently.
When setting up automated polling of the API for health status, set verbose to false to disable the more expensive analysis logic.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.IndexRequestDescriptor-1.html">IndexRequestDescriptor&lt;TDocument&gt;</a></dt>
      <dd><p>
Create or update a document in an index.
</p>
<p>
Add a JSON document to the specified data stream or index and make it searchable.
If the target is an index and the document already exists, the request updates the document and increments its version.
</p>
<p>
NOTE: You cannot use this API to send update requests for existing documents in a data stream.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or index alias:
</p>
<ul><li>
<p>
To add or overwrite a document using the <code>PUT /&lt;target&gt;/_doc/&lt;_id&gt;</code> request format, you must have the <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To add a document using the <code>POST /&lt;target&gt;/_doc/</code> request format, you must have the <code>create_doc</code>, <code>create</code>, <code>index</code>, or <code>write</code> index privilege.
</p>
</li><li>
<p>
To automatically create a data stream or index with this API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege.
</p>
</li></ul>
<p>
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
NOTE: Replica shards might not all be started when an indexing operation returns successfully.
By default, only the primary is required. Set <code>wait_for_active_shards</code> to change this default behavior.
</p>
<p>
<strong>Automatically create data streams and indices</strong>
</p>
<p>
If the request's target doesn't exist and matches an index template with a <code>data_stream</code> definition, the index operation automatically creates the data stream.
</p>
<p>
If the target doesn't exist and doesn't match a data stream template, the operation automatically creates the index and applies any matching index templates.
</p>
<p>
NOTE: Elasticsearch includes several built-in index templates. To avoid naming collisions with these templates, refer to index pattern documentation.
</p>
<p>
If no mapping exists, the index operation creates a dynamic mapping.
By default, new fields and objects are automatically added to the mapping if needed.
</p>
<p>
Automatic index creation is controlled by the <code>action.auto_create_index</code> setting.
If it is <code>true</code>, any index can be created automatically.
You can modify this setting to explicitly allow or block automatic creation of indices that match specified patterns or set it to <code>false</code> to turn off automatic index creation entirely.
Specify a comma-separated list of patterns you want to allow or prefix each pattern with <code>+</code> or <code>-</code> to indicate whether it should be allowed or blocked.
When a list is specified, the default behaviour is to disallow.
</p>
<p>
NOTE: The <code>action.auto_create_index</code> setting affects the automatic creation of indices only.
It does not affect the creation of data streams.
</p>
<p>
<strong>Optimistic concurrency control</strong>
</p>
<p>
Index operations can be made conditional and only be performed if the last modification to the document was assigned the sequence number and primary term specified by the <code>if_seq_no</code> and <code>if_primary_term</code> parameters.
If a mismatch is detected, the operation will result in a <code>VersionConflictException</code> and a status code of <code>409</code>.
</p>
<p>
<strong>Routing</strong>
</p>
<p>
By default, shard placement — or routing — is controlled by using a hash of the document's ID value.
For more explicit control, the value fed into the hash function used by the router can be directly specified on a per-operation basis using the <code>routing</code> parameter.
</p>
<p>
When setting up explicit mapping, you can also use the <code>_routing</code> field to direct the index operation to extract the routing value from the document itself.
This does come at the (very minimal) cost of an additional document parsing pass.
If the <code>_routing</code> mapping is defined and set to be required, the index operation will fail if no routing value is provided or extracted.
</p>
<p>
NOTE: Data streams do not support custom routing unless they were created with the <code>allow_custom_routing</code> setting enabled in the template.
</p>
<p>
<strong>Distributed</strong>
</p>
<p>
The index operation is directed to the primary shard based on its route and performed on the actual node containing this shard.
After the primary shard completes the operation, if needed, the update is distributed to applicable replicas.
</p>
<p>
<strong>Active shards</strong>
</p>
<p>
To improve the resiliency of writes to the system, indexing operations can be configured to wait for a certain number of active shard copies before proceeding with the operation.
If the requisite number of active shard copies are not available, then the write operation must wait and retry, until either the requisite shard copies have started or a timeout occurs.
By default, write operations only wait for the primary shards to be active before proceeding (that is to say <code>wait_for_active_shards</code> is <code>1</code>).
This default can be overridden in the index settings dynamically by setting <code>index.write.wait_for_active_shards</code>.
To alter this behavior per operation, use the <code>wait_for_active_shards request</code> parameter.
</p>
<p>
Valid values are all or any positive integer up to the total number of configured copies per shard in the index (which is <code>number_of_replicas</code>+1).
Specifying a negative value or a number greater than the number of shard copies will throw an error.
</p>
<p>
For example, suppose you have a cluster of three nodes, A, B, and C and you create an index index with the number of replicas set to 3 (resulting in 4 shard copies, one more copy than there are nodes).
If you attempt an indexing operation, by default the operation will only ensure the primary copy of each shard is available before proceeding.
This means that even if B and C went down and A hosted the primary shard copies, the indexing operation would still proceed with only one copy of the data.
If <code>wait_for_active_shards</code> is set on the request to <code>3</code> (and all three nodes are up), the indexing operation will require 3 active shard copies before proceeding.
This requirement should be met because there are 3 active nodes in the cluster, each one holding a copy of the shard.
However, if you set <code>wait_for_active_shards</code> to <code>all</code> (or to <code>4</code>, which is the same in this situation), the indexing operation will not proceed as you do not have all 4 copies of each shard active in the index.
The operation will timeout unless a new node is brought up in the cluster to host the fourth copy of the shard.
</p>
<p>
It is important to note that this setting greatly reduces the chances of the write operation not writing to the requisite number of shard copies, but it does not completely eliminate the possibility, because this check occurs before the write operation starts.
After the write operation is underway, it is still possible for replication to fail on any number of shard copies but still succeed on the primary.
The <code>_shards</code> section of the API response reveals the number of shard copies on which replication succeeded and failed.
</p>
<p>
<strong>No operation (noop) updates</strong>
</p>
<p>
When updating a document by using this API, a new version of the document is always created even if the document hasn't changed.
If this isn't acceptable use the <code>_update</code> API with <code>detect_noop</code> set to <code>true</code>.
The <code>detect_noop</code> option isn't available on this API because it doesn’t fetch the old source and isn't able to compare it against the new source.
</p>
<p>
There isn't a definitive rule for when noop updates aren't acceptable.
It's a combination of lots of factors like how frequently your data source sends updates that are actually noops and how many queries per second Elasticsearch runs on the shard receiving the updates.
</p>
<p>
<strong>Versioning</strong>
</p>
<p>
Each indexed document is given a version number.
By default, internal versioning is used that starts at 1 and increments with each update, deletes included.
Optionally, the version number can be set to an external value (for example, if maintained in a database).
To enable this functionality, <code>version_type</code> should be set to <code>external</code>.
The value provided must be a numeric, long value greater than or equal to 0, and less than around <code>9.2e+18</code>.
</p>
<p>
NOTE: Versioning is completely real time, and is not affected by the near real time aspects of search operations.
If no version is provided, the operation runs without any version checks.
</p>
<p>
When using the external version type, the system checks to see if the version number passed to the index request is greater than the version of the currently stored document.
If true, the document will be indexed and the new version number used.
If the value provided is less than or equal to the stored document's version number, a version conflict will occur and the index operation will fail. For example:
</p>
<pre><code class="lang-csharp">PUT my-index-000001/_doc/1?version=2&amp;version_type=external
{
  "user": {
    "id": "elkbee"
  }
}

In this example, the operation will succeed since the supplied version of 2 is higher than the current document version of 1.
If the document was already updated and its version was set to 2 or higher, the indexing command will fail and result in a conflict (409 HTTP status code).

A nice side effect is that there is no need to maintain strict ordering of async indexing operations run as a result of changes to a source database, as long as version numbers from the source database are used.
Even the simple case of updating the Elasticsearch index using data from a database is simplified if external versioning is used, as only the latest version will be used if the index operations arrive out of order.</code></pre>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.IndicesOptionsDescriptor.html">IndicesOptionsDescriptor</a></dt>
      <dd><p>
Controls how to deal with unavailable concrete indices (closed or missing), how wildcard expressions are expanded
to actual indices (all, closed or open indices) and how to deal with wildcard expressions that resolve to no indices.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.InfoRequestDescriptor.html">InfoRequestDescriptor</a></dt>
      <dd><p>
Get cluster info.
Get basic build, version, and cluster information.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.KnnQueryDescriptor.html">KnnQueryDescriptor</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.KnnQueryDescriptor-1.html">KnnQueryDescriptor&lt;TDocument&gt;</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.KnnRetrieverDescriptor.html">KnnRetrieverDescriptor</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.KnnRetrieverDescriptor-1.html">KnnRetrieverDescriptor&lt;TDocument&gt;</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.KnnSearchDescriptor.html">KnnSearchDescriptor</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.KnnSearchDescriptor-1.html">KnnSearchDescriptor&lt;TDocument&gt;</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.LatLonGeoLocationDescriptor.html">LatLonGeoLocationDescriptor</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.LazyJson.html">LazyJson</a></dt>
      <dd><p>Lazily deserializable JSON.</p>
<p>Holds raw JSON bytes which can be lazily deserialized to a specific <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.type">Type</a> using the source serializer at a later time.</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.MultiGetRequestDescriptor.html">MultiGetRequestDescriptor</a></dt>
      <dd><p>
Get multiple documents.
</p>
<p>
Get multiple JSON documents by ID from one or more indices.
If you specify an index in the request URI, you only need to specify the document IDs in the request body.
To ensure fast responses, this multi get (mget) API responds with partial results if one or more shards fail.
</p>
<p>
<strong>Filter source fields</strong>
</p>
<p>
By default, the <code>_source</code> field is returned for every document (if stored).
Use the <code>_source</code> and <code>_source_include</code> or <code>source_exclude</code> attributes to filter what fields are returned for a particular document.
You can include the <code>_source</code>, <code>_source_includes</code>, and <code>_source_excludes</code> query parameters in the request URI to specify the defaults to use when there are no per-document instructions.
</p>
<p>
<strong>Get stored fields</strong>
</p>
<p>
Use the <code>stored_fields</code> attribute to specify the set of stored fields you want to retrieve.
Any requested fields that are not stored are ignored.
You can include the <code>stored_fields</code> query parameter in the request URI to specify the defaults to use when there are no per-document instructions.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.MultiGetRequestDescriptor-1.html">MultiGetRequestDescriptor&lt;TDocument&gt;</a></dt>
      <dd><p>
Get multiple documents.
</p>
<p>
Get multiple JSON documents by ID from one or more indices.
If you specify an index in the request URI, you only need to specify the document IDs in the request body.
To ensure fast responses, this multi get (mget) API responds with partial results if one or more shards fail.
</p>
<p>
<strong>Filter source fields</strong>
</p>
<p>
By default, the <code>_source</code> field is returned for every document (if stored).
Use the <code>_source</code> and <code>_source_include</code> or <code>source_exclude</code> attributes to filter what fields are returned for a particular document.
You can include the <code>_source</code>, <code>_source_includes</code>, and <code>_source_excludes</code> query parameters in the request URI to specify the defaults to use when there are no per-document instructions.
</p>
<p>
<strong>Get stored fields</strong>
</p>
<p>
Use the <code>stored_fields</code> attribute to specify the set of stored fields you want to retrieve.
Any requested fields that are not stored are ignored.
You can include the <code>stored_fields</code> query parameter in the request URI to specify the defaults to use when there are no per-document instructions.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.MultiSearchRequestDescriptor.html">MultiSearchRequestDescriptor</a></dt>
      <dd><p>
Run multiple searches.
</p>
<p>
The format of the request is similar to the bulk API format and makes use of the newline delimited JSON (NDJSON) format.
The structure is as follows:
</p>
<pre><code class="lang-csharp">header\n
body\n
header\n
body\n</code></pre>
<p>
This structure is specifically optimized to reduce parsing if a specific search ends up redirected to another node.
</p>
<p>
IMPORTANT: The final line of data must end with a newline character <code>\n</code>.
Each newline character may be preceded by a carriage return <code>\r</code>.
When sending requests to this endpoint the <code>Content-Type</code> header should be set to <code>application/x-ndjson</code>.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.MultiSearchRequestDescriptor-1.html">MultiSearchRequestDescriptor&lt;TDocument&gt;</a></dt>
      <dd><p>
Run multiple searches.
</p>
<p>
The format of the request is similar to the bulk API format and makes use of the newline delimited JSON (NDJSON) format.
The structure is as follows:
</p>
<pre><code class="lang-csharp">header\n
body\n
header\n
body\n</code></pre>
<p>
This structure is specifically optimized to reduce parsing if a specific search ends up redirected to another node.
</p>
<p>
IMPORTANT: The final line of data must end with a newline character <code>\n</code>.
Each newline character may be preceded by a carriage return <code>\r</code>.
When sending requests to this endpoint the <code>Content-Type</code> header should be set to <code>application/x-ndjson</code>.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.MultiSearchTemplateRequestDescriptor.html">MultiSearchTemplateRequestDescriptor</a></dt>
      <dd><p>
Run multiple templated searches.
</p>
<p>
Run multiple templated searches with a single request.
If you are providing a text file or text input to <code>curl</code>, use the <code>--data-binary</code> flag instead of <code>-d</code> to preserve newlines.
For example:
</p>
<pre><code class="lang-csharp">$ cat requests
{ "index": "my-index" }
{ "id": "my-search-template", "params": { "query_string": "hello world", "from": 0, "size": 10 }}
{ "index": "my-other-index" }
{ "id": "my-other-search-template", "params": { "query_type": "match_all" }}

$ curl -H "Content-Type: application/x-ndjson" -XGET localhost:9200/_msearch/template --data-binary "@requests"; echo</code></pre>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.MultiSearchTemplateRequestDescriptor-1.html">MultiSearchTemplateRequestDescriptor&lt;TDocument&gt;</a></dt>
      <dd><p>
Run multiple templated searches.
</p>
<p>
Run multiple templated searches with a single request.
If you are providing a text file or text input to <code>curl</code>, use the <code>--data-binary</code> flag instead of <code>-d</code> to preserve newlines.
For example:
</p>
<pre><code class="lang-csharp">$ cat requests
{ "index": "my-index" }
{ "id": "my-search-template", "params": { "query_string": "hello world", "from": 0, "size": 10 }}
{ "index": "my-other-index" }
{ "id": "my-other-search-template", "params": { "query_type": "match_all" }}

$ curl -H "Content-Type: application/x-ndjson" -XGET localhost:9200/_msearch/template --data-binary "@requests"; echo</code></pre>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.MultiTermVectorsRequestDescriptor.html">MultiTermVectorsRequestDescriptor</a></dt>
      <dd><p>
Get multiple term vectors.
</p>
<p>
Get multiple term vectors with a single request.
You can specify existing documents by index and ID or provide artificial documents in the body of the request.
You can specify the index in the request body or request URI.
The response contains a <code>docs</code> array with all the fetched termvectors.
Each element has the structure provided by the termvectors API.
</p>
<p>
<strong>Artificial documents</strong>
</p>
<p>
You can also use <code>mtermvectors</code> to generate term vectors for artificial documents provided in the body of the request.
The mapping used is determined by the specified <code>_index</code>.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.MultiTermVectorsRequestDescriptor-1.html">MultiTermVectorsRequestDescriptor&lt;TDocument&gt;</a></dt>
      <dd><p>
Get multiple term vectors.
</p>
<p>
Get multiple term vectors with a single request.
You can specify existing documents by index and ID or provide artificial documents in the body of the request.
You can specify the index in the request body or request URI.
The response contains a <code>docs</code> array with all the fetched termvectors.
Each element has the structure provided by the termvectors API.
</p>
<p>
<strong>Artificial documents</strong>
</p>
<p>
You can also use <code>mtermvectors</code> to generate term vectors for artificial documents provided in the body of the request.
The mapping used is determined by the specified <code>_index</code>.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.NestedSortValueDescriptor.html">NestedSortValueDescriptor</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.NestedSortValueDescriptor-1.html">NestedSortValueDescriptor&lt;TDocument&gt;</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.Number.html">Number</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.OpenPointInTimeRequestDescriptor.html">OpenPointInTimeRequestDescriptor</a></dt>
      <dd><p>
Open a point in time.
</p>
<p>
A search request by default runs against the most recent visible data of the target indices,
which is called point in time. Elasticsearch pit (point in time) is a lightweight view into the
state of the data as it existed when initiated. In some cases, it’s preferred to perform multiple
search requests using the same point in time. For example, if refreshes happen between
<code>search_after</code> requests, then the results of those requests might not be consistent as changes happening
between searches are only visible to the more recent point in time.
</p>
<p>
A point in time must be opened explicitly before being used in search requests.
</p>
<p>
A subsequent search request with the <code>pit</code> parameter must not specify <code>index</code>, <code>routing</code>, or <code>preference</code> values as these parameters are copied from the point in time.
</p>
<p>
Just like regular searches, you can use <code>from</code> and <code>size</code> to page through point in time search results, up to the first 10,000 hits.
If you want to retrieve more hits, use PIT with <code>search_after</code>.
</p>
<p>
IMPORTANT: The open point in time request and each subsequent search request can return different identifiers; always use the most recently received ID for the next search request.
</p>
<p>
When a PIT that contains shard failures is used in a search request, the missing are always reported in the search response as a <code>NoShardAvailableActionException</code> exception.
To get rid of these exceptions, a new PIT needs to be created so that shards missing from the previous PIT can be handled, assuming they become available in the meantime.
</p>
<p>
<strong>Keeping point in time alive</strong>
</p>
<p>
The <code>keep_alive</code> parameter, which is passed to a open point in time request and search request, extends the time to live of the corresponding point in time.
The value does not need to be long enough to process all data — it just needs to be long enough for the next request.
</p>
<p>
Normally, the background merge process optimizes the index by merging together smaller segments to create new, bigger segments.
Once the smaller segments are no longer needed they are deleted.
However, open point-in-times prevent the old segments from being deleted since they are still in use.
</p>
<p>
TIP: Keeping older segments alive means that more disk space and file handles are needed.
Ensure that you have configured your nodes to have ample free file handles.
</p>
<p>
Additionally, if a segment contains deleted or updated documents then the point in time must keep track of whether each document in the segment was live at the time of the initial search request.
Ensure that your nodes have sufficient heap space if you have many open point-in-times on an index that is subject to ongoing deletes or updates.
Note that a point-in-time doesn't prevent its associated indices from being deleted.
You can check how many point-in-times (that is, search contexts) are open with the nodes stats API.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.OpenPointInTimeRequestDescriptor-1.html">OpenPointInTimeRequestDescriptor&lt;TDocument&gt;</a></dt>
      <dd><p>
Open a point in time.
</p>
<p>
A search request by default runs against the most recent visible data of the target indices,
which is called point in time. Elasticsearch pit (point in time) is a lightweight view into the
state of the data as it existed when initiated. In some cases, it’s preferred to perform multiple
search requests using the same point in time. For example, if refreshes happen between
<code>search_after</code> requests, then the results of those requests might not be consistent as changes happening
between searches are only visible to the more recent point in time.
</p>
<p>
A point in time must be opened explicitly before being used in search requests.
</p>
<p>
A subsequent search request with the <code>pit</code> parameter must not specify <code>index</code>, <code>routing</code>, or <code>preference</code> values as these parameters are copied from the point in time.
</p>
<p>
Just like regular searches, you can use <code>from</code> and <code>size</code> to page through point in time search results, up to the first 10,000 hits.
If you want to retrieve more hits, use PIT with <code>search_after</code>.
</p>
<p>
IMPORTANT: The open point in time request and each subsequent search request can return different identifiers; always use the most recently received ID for the next search request.
</p>
<p>
When a PIT that contains shard failures is used in a search request, the missing are always reported in the search response as a <code>NoShardAvailableActionException</code> exception.
To get rid of these exceptions, a new PIT needs to be created so that shards missing from the previous PIT can be handled, assuming they become available in the meantime.
</p>
<p>
<strong>Keeping point in time alive</strong>
</p>
<p>
The <code>keep_alive</code> parameter, which is passed to a open point in time request and search request, extends the time to live of the corresponding point in time.
The value does not need to be long enough to process all data — it just needs to be long enough for the next request.
</p>
<p>
Normally, the background merge process optimizes the index by merging together smaller segments to create new, bigger segments.
Once the smaller segments are no longer needed they are deleted.
However, open point-in-times prevent the old segments from being deleted since they are still in use.
</p>
<p>
TIP: Keeping older segments alive means that more disk space and file handles are needed.
Ensure that you have configured your nodes to have ample free file handles.
</p>
<p>
Additionally, if a segment contains deleted or updated documents then the point in time must keep track of whether each document in the segment was live at the time of the initial search request.
Ensure that your nodes have sufficient heap space if you have many open point-in-times on an index that is subject to ongoing deletes or updates.
Note that a point-in-time doesn't prevent its associated indices from being deleted.
You can check how many point-in-times (that is, search contexts) are open with the nodes stats API.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.PercentageFactory.html">PercentageFactory</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.PingRequestDescriptor.html">PingRequestDescriptor</a></dt>
      <dd><p>
Ping the cluster.
Get information about whether the cluster is running.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.PropertyMapping.html">PropertyMapping</a></dt>
      <dd><p>Represents meta data about a property which may be used by inferrence and during serialization.</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.PutScriptRequestDescriptor.html">PutScriptRequestDescriptor</a></dt>
      <dd><p>
Create or update a script or search template.
Creates or updates a stored script or search template.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.QueryVectorBuilderDescriptor.html">QueryVectorBuilderDescriptor</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.RankDescriptor.html">RankDescriptor</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.RankEvalRequestDescriptor.html">RankEvalRequestDescriptor</a></dt>
      <dd><p>
Evaluate ranked search results.
</p>
<p>
Evaluate the quality of ranked search results over a set of typical search queries.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.RankEvalRequestDescriptor-1.html">RankEvalRequestDescriptor&lt;TDocument&gt;</a></dt>
      <dd><p>
Evaluate ranked search results.
</p>
<p>
Evaluate the quality of ranked search results over a set of typical search queries.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ReindexRequestDescriptor.html">ReindexRequestDescriptor</a></dt>
      <dd><p>
Reindex documents.
</p>
<p>
Copy documents from a source to a destination.
You can copy all documents to the destination index or reindex a subset of the documents.
The source can be any existing index, alias, or data stream.
The destination must differ from the source.
For example, you cannot reindex a data stream into itself.
</p>
<p>
IMPORTANT: Reindex requires <code>_source</code> to be enabled for all documents in the source.
The destination should be configured as wanted before calling the reindex API.
Reindex does not copy the settings from the source or its associated template.
Mappings, shard counts, and replicas, for example, must be configured ahead of time.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following security privileges:
</p>
<ul><li>
<p>
The <code>read</code> index privilege for the source data stream, index, or alias.
</p>
</li><li>
<p>
The <code>write</code> index privilege for the destination data stream, index, or index alias.
</p>
</li><li>
<p>
To automatically create a data stream or index with a reindex API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege for the destination data stream, index, or alias.
</p>
</li><li>
<p>
If reindexing from a remote cluster, the <code>source.remote.user</code> must have the <code>monitor</code> cluster privilege and the <code>read</code> index privilege for the source data stream, index, or alias.
</p>
</li></ul>
<p>
If reindexing from a remote cluster, you must explicitly allow the remote host in the <code>reindex.remote.whitelist</code> setting.
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
The <code>dest</code> element can be configured like the index API to control optimistic concurrency control.
Omitting <code>version_type</code> or setting it to <code>internal</code> causes Elasticsearch to blindly dump documents into the destination, overwriting any that happen to have the same ID.
</p>
<p>
Setting <code>version_type</code> to <code>external</code> causes Elasticsearch to preserve the <code>version</code> from the source, create any documents that are missing, and update any documents that have an older version in the destination than they do in the source.
</p>
<p>
Setting <code>op_type</code> to <code>create</code> causes the reindex API to create only missing documents in the destination.
All existing documents will cause a version conflict.
</p>
<p>
IMPORTANT: Because data streams are append-only, any reindex request to a destination data stream must have an <code>op_type</code> of <code>create</code>.
A reindex can only add new documents to a destination data stream.
It cannot update existing documents in a destination data stream.
</p>
<p>
By default, version conflicts abort the reindex process.
To continue reindexing if there are conflicts, set the <code>conflicts</code> request body property to <code>proceed</code>.
In this case, the response includes a count of the version conflicts that were encountered.
Note that the handling of other error types is unaffected by the <code>conflicts</code> property.
Additionally, if you opt to count version conflicts, the operation could attempt to reindex more documents from the source than <code>max_docs</code> until it has successfully indexed <code>max_docs</code> documents into the target or it has gone through every document in the source query.
</p>
<p>
NOTE: The reindex API makes no effort to handle ID collisions.
The last document written will "win" but the order isn't usually predictable so it is not a good idea to rely on this behavior.
Instead, make sure that IDs are unique by using a script.
</p>
<p>
<strong>Running reindex asynchronously</strong>
</p>
<p>
If the request contains <code>wait_for_completion=false</code>, Elasticsearch performs some preflight checks, launches the request, and returns a task you can use to cancel or get the status of the task.
Elasticsearch creates a record of this task as a document at <code>_tasks/&lt;task_id&gt;</code>.
</p>
<p>
<strong>Reindex from multiple sources</strong>
</p>
<p>
If you have many sources to reindex it is generally better to reindex them one at a time rather than using a glob pattern to pick up multiple sources.
That way you can resume the process if there are any errors by removing the partially completed source and starting over.
It also makes parallelizing the process fairly simple: split the list of sources to reindex and run each list in parallel.
</p>
<p>
For example, you can use a bash script like this:
</p>
<pre><code class="lang-csharp">for index in i1 i2 i3 i4 i5; do
  curl -HContent-Type:application/json -XPOST localhost:9200/_reindex?pretty -d'{
    "source": {
      "index": "'$index'"
    },
    "dest": {
      "index": "'$index'-reindexed"
    }
  }'
done</code></pre>
<p>
<strong>Throttling</strong>
</p>
<p>
Set <code>requests_per_second</code> to any positive decimal number (<code>1.4</code>, <code>6</code>, <code>1000</code>, for example) to throttle the rate at which reindex issues batches of index operations.
Requests are throttled by padding each batch with a wait time.
To turn off throttling, set <code>requests_per_second</code> to <code>-1</code>.
</p>
<p>
The throttling is done by waiting between batches so that the scroll that reindex uses internally can be given a timeout that takes into account the padding.
The padding time is the difference between the batch size divided by the <code>requests_per_second</code> and the time spent writing.
By default the batch size is <code>1000</code>, so if <code>requests_per_second</code> is set to <code>500</code>:
</p>
<pre><code class="lang-csharp">target_time = 1000 / 500 per second = 2 seconds
wait_time = target_time - write_time = 2 seconds - .5 seconds = 1.5 seconds</code></pre>
<p>
Since the batch is issued as a single bulk request, large batch sizes cause Elasticsearch to create many requests and then wait for a while before starting the next set.
This is "bursty" instead of "smooth".
</p>
<p>
<strong>Slicing</strong>
</p>
<p>
Reindex supports sliced scroll to parallelize the reindexing process.
This parallelization can improve efficiency and provide a convenient way to break the request down into smaller parts.
</p>
<p>
NOTE: Reindexing from remote clusters does not support manual or automatic slicing.
</p>
<p>
You can slice a reindex request manually by providing a slice ID and total number of slices to each request.
You can also let reindex automatically parallelize by using sliced scroll to slice on <code>_id</code>.
The <code>slices</code> parameter specifies the number of slices to use.
</p>
<p>
Adding <code>slices</code> to the reindex request just automates the manual process, creating sub-requests which means it has some quirks:
</p>
<ul><li>
<p>
You can see these requests in the tasks API. These sub-requests are "child" tasks of the task for the request with slices.
</p>
</li><li>
<p>
Fetching the status of the task for the request with <code>slices</code> only contains the status of completed slices.
</p>
</li><li>
<p>
These sub-requests are individually addressable for things like cancellation and rethrottling.
</p>
</li><li>
<p>
Rethrottling the request with <code>slices</code> will rethrottle the unfinished sub-request proportionally.
</p>
</li><li>
<p>
Canceling the request with <code>slices</code> will cancel each sub-request.
</p>
</li><li>
<p>
Due to the nature of <code>slices</code>, each sub-request won't get a perfectly even portion of the documents. All documents will be addressed, but some slices may be larger than others. Expect larger slices to have a more even distribution.
</p>
</li><li>
<p>
Parameters like <code>requests_per_second</code> and <code>max_docs</code> on a request with <code>slices</code> are distributed proportionally to each sub-request. Combine that with the previous point about distribution being uneven and you should conclude that using <code>max_docs</code> with <code>slices</code> might not result in exactly <code>max_docs</code> documents being reindexed.
</p>
</li><li>
<p>
Each sub-request gets a slightly different snapshot of the source, though these are all taken at approximately the same time.
</p>
</li></ul>
<p>
If slicing automatically, setting <code>slices</code> to <code>auto</code> will choose a reasonable number for most indices.
If slicing manually or otherwise tuning automatic slicing, use the following guidelines.
</p>
<p>
Query performance is most efficient when the number of slices is equal to the number of shards in the index.
If that number is large (for example, <code>500</code>), choose a lower number as too many slices will hurt performance.
Setting slices higher than the number of shards generally does not improve efficiency and adds overhead.
</p>
<p>
Indexing performance scales linearly across available resources with the number of slices.
</p>
<p>
Whether query or indexing performance dominates the runtime depends on the documents being reindexed and cluster resources.
</p>
<p>
<strong>Modify documents during reindexing</strong>
</p>
<p>
Like <code>_update_by_query</code>, reindex operations support a script that modifies the document.
Unlike <code>_update_by_query</code>, the script is allowed to modify the document's metadata.
</p>
<p>
Just as in <code>_update_by_query</code>, you can set <code>ctx.op</code> to change the operation that is run on the destination.
For example, set <code>ctx.op</code> to <code>noop</code> if your script decides that the document doesn’t have to be indexed in the destination. This "no operation" will be reported in the <code>noop</code> counter in the response body.
Set <code>ctx.op</code> to <code>delete</code> if your script decides that the document must be deleted from the destination.
The deletion will be reported in the <code>deleted</code> counter in the response body.
Setting <code>ctx.op</code> to anything else will return an error, as will setting any other field in <code>ctx</code>.
</p>
<p>
Think of the possibilities! Just be careful; you are able to change:
</p>
<ul><li>
<p>
<code>_id</code>
</p>
</li><li>
<p>
<code>_index</code>
</p>
</li><li>
<p>
<code>_version</code>
</p>
</li><li>
<p>
<code>_routing</code>
</p>
</li></ul>
<p>
Setting <code>_version</code> to <code>null</code> or clearing it from the <code>ctx</code> map is just like not sending the version in an indexing request.
It will cause the document to be overwritten in the destination regardless of the version on the target or the version type you use in the reindex API.
</p>
<p>
<strong>Reindex from remote</strong>
</p>
<p>
Reindex supports reindexing from a remote Elasticsearch cluster.
The <code>host</code> parameter must contain a scheme, host, port, and optional path.
The <code>username</code> and <code>password</code> parameters are optional and when they are present the reindex operation will connect to the remote Elasticsearch node using basic authentication.
Be sure to use HTTPS when using basic authentication or the password will be sent in plain text.
There are a range of settings available to configure the behavior of the HTTPS connection.
</p>
<p>
When using Elastic Cloud, it is also possible to authenticate against the remote cluster through the use of a valid API key.
Remote hosts must be explicitly allowed with the <code>reindex.remote.whitelist</code> setting.
It can be set to a comma delimited list of allowed remote host and port combinations.
Scheme is ignored; only the host and port are used.
For example:
</p>
<pre><code class="lang-csharp">reindex.remote.whitelist: [otherhost:9200, another:9200, 127.0.10.*:9200, localhost:*"]</code></pre>
<p>
The list of allowed hosts must be configured on any nodes that will coordinate the reindex.
This feature should work with remote clusters of any version of Elasticsearch.
This should enable you to upgrade from any version of Elasticsearch to the current version by reindexing from a cluster of the old version.
</p>
<p>
WARNING: Elasticsearch does not support forward compatibility across major versions.
For example, you cannot reindex from a 7.x cluster into a 6.x cluster.
</p>
<p>
To enable queries sent to older versions of Elasticsearch, the <code>query</code> parameter is sent directly to the remote host without validation or modification.
</p>
<p>
NOTE: Reindexing from remote clusters does not support manual or automatic slicing.
</p>
<p>
Reindexing from a remote server uses an on-heap buffer that defaults to a maximum size of 100mb.
If the remote index includes very large documents you'll need to use a smaller batch size.
It is also possible to set the socket read timeout on the remote connection with the <code>socket_timeout</code> field and the connection timeout with the <code>connect_timeout</code> field.
Both default to 30 seconds.
</p>
<p>
<strong>Configuring SSL parameters</strong>
</p>
<p>
Reindex from remote supports configurable SSL settings.
These must be specified in the <code>elasticsearch.yml</code> file, with the exception of the secure settings, which you add in the Elasticsearch keystore.
It is not possible to configure SSL in the body of the reindex request.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ReindexRequestDescriptor-1.html">ReindexRequestDescriptor&lt;TDocument&gt;</a></dt>
      <dd><p>
Reindex documents.
</p>
<p>
Copy documents from a source to a destination.
You can copy all documents to the destination index or reindex a subset of the documents.
The source can be any existing index, alias, or data stream.
The destination must differ from the source.
For example, you cannot reindex a data stream into itself.
</p>
<p>
IMPORTANT: Reindex requires <code>_source</code> to be enabled for all documents in the source.
The destination should be configured as wanted before calling the reindex API.
Reindex does not copy the settings from the source or its associated template.
Mappings, shard counts, and replicas, for example, must be configured ahead of time.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following security privileges:
</p>
<ul><li>
<p>
The <code>read</code> index privilege for the source data stream, index, or alias.
</p>
</li><li>
<p>
The <code>write</code> index privilege for the destination data stream, index, or index alias.
</p>
</li><li>
<p>
To automatically create a data stream or index with a reindex API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege for the destination data stream, index, or alias.
</p>
</li><li>
<p>
If reindexing from a remote cluster, the <code>source.remote.user</code> must have the <code>monitor</code> cluster privilege and the <code>read</code> index privilege for the source data stream, index, or alias.
</p>
</li></ul>
<p>
If reindexing from a remote cluster, you must explicitly allow the remote host in the <code>reindex.remote.whitelist</code> setting.
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
The <code>dest</code> element can be configured like the index API to control optimistic concurrency control.
Omitting <code>version_type</code> or setting it to <code>internal</code> causes Elasticsearch to blindly dump documents into the destination, overwriting any that happen to have the same ID.
</p>
<p>
Setting <code>version_type</code> to <code>external</code> causes Elasticsearch to preserve the <code>version</code> from the source, create any documents that are missing, and update any documents that have an older version in the destination than they do in the source.
</p>
<p>
Setting <code>op_type</code> to <code>create</code> causes the reindex API to create only missing documents in the destination.
All existing documents will cause a version conflict.
</p>
<p>
IMPORTANT: Because data streams are append-only, any reindex request to a destination data stream must have an <code>op_type</code> of <code>create</code>.
A reindex can only add new documents to a destination data stream.
It cannot update existing documents in a destination data stream.
</p>
<p>
By default, version conflicts abort the reindex process.
To continue reindexing if there are conflicts, set the <code>conflicts</code> request body property to <code>proceed</code>.
In this case, the response includes a count of the version conflicts that were encountered.
Note that the handling of other error types is unaffected by the <code>conflicts</code> property.
Additionally, if you opt to count version conflicts, the operation could attempt to reindex more documents from the source than <code>max_docs</code> until it has successfully indexed <code>max_docs</code> documents into the target or it has gone through every document in the source query.
</p>
<p>
NOTE: The reindex API makes no effort to handle ID collisions.
The last document written will "win" but the order isn't usually predictable so it is not a good idea to rely on this behavior.
Instead, make sure that IDs are unique by using a script.
</p>
<p>
<strong>Running reindex asynchronously</strong>
</p>
<p>
If the request contains <code>wait_for_completion=false</code>, Elasticsearch performs some preflight checks, launches the request, and returns a task you can use to cancel or get the status of the task.
Elasticsearch creates a record of this task as a document at <code>_tasks/&lt;task_id&gt;</code>.
</p>
<p>
<strong>Reindex from multiple sources</strong>
</p>
<p>
If you have many sources to reindex it is generally better to reindex them one at a time rather than using a glob pattern to pick up multiple sources.
That way you can resume the process if there are any errors by removing the partially completed source and starting over.
It also makes parallelizing the process fairly simple: split the list of sources to reindex and run each list in parallel.
</p>
<p>
For example, you can use a bash script like this:
</p>
<pre><code class="lang-csharp">for index in i1 i2 i3 i4 i5; do
  curl -HContent-Type:application/json -XPOST localhost:9200/_reindex?pretty -d'{
    "source": {
      "index": "'$index'"
    },
    "dest": {
      "index": "'$index'-reindexed"
    }
  }'
done</code></pre>
<p>
<strong>Throttling</strong>
</p>
<p>
Set <code>requests_per_second</code> to any positive decimal number (<code>1.4</code>, <code>6</code>, <code>1000</code>, for example) to throttle the rate at which reindex issues batches of index operations.
Requests are throttled by padding each batch with a wait time.
To turn off throttling, set <code>requests_per_second</code> to <code>-1</code>.
</p>
<p>
The throttling is done by waiting between batches so that the scroll that reindex uses internally can be given a timeout that takes into account the padding.
The padding time is the difference between the batch size divided by the <code>requests_per_second</code> and the time spent writing.
By default the batch size is <code>1000</code>, so if <code>requests_per_second</code> is set to <code>500</code>:
</p>
<pre><code class="lang-csharp">target_time = 1000 / 500 per second = 2 seconds
wait_time = target_time - write_time = 2 seconds - .5 seconds = 1.5 seconds</code></pre>
<p>
Since the batch is issued as a single bulk request, large batch sizes cause Elasticsearch to create many requests and then wait for a while before starting the next set.
This is "bursty" instead of "smooth".
</p>
<p>
<strong>Slicing</strong>
</p>
<p>
Reindex supports sliced scroll to parallelize the reindexing process.
This parallelization can improve efficiency and provide a convenient way to break the request down into smaller parts.
</p>
<p>
NOTE: Reindexing from remote clusters does not support manual or automatic slicing.
</p>
<p>
You can slice a reindex request manually by providing a slice ID and total number of slices to each request.
You can also let reindex automatically parallelize by using sliced scroll to slice on <code>_id</code>.
The <code>slices</code> parameter specifies the number of slices to use.
</p>
<p>
Adding <code>slices</code> to the reindex request just automates the manual process, creating sub-requests which means it has some quirks:
</p>
<ul><li>
<p>
You can see these requests in the tasks API. These sub-requests are "child" tasks of the task for the request with slices.
</p>
</li><li>
<p>
Fetching the status of the task for the request with <code>slices</code> only contains the status of completed slices.
</p>
</li><li>
<p>
These sub-requests are individually addressable for things like cancellation and rethrottling.
</p>
</li><li>
<p>
Rethrottling the request with <code>slices</code> will rethrottle the unfinished sub-request proportionally.
</p>
</li><li>
<p>
Canceling the request with <code>slices</code> will cancel each sub-request.
</p>
</li><li>
<p>
Due to the nature of <code>slices</code>, each sub-request won't get a perfectly even portion of the documents. All documents will be addressed, but some slices may be larger than others. Expect larger slices to have a more even distribution.
</p>
</li><li>
<p>
Parameters like <code>requests_per_second</code> and <code>max_docs</code> on a request with <code>slices</code> are distributed proportionally to each sub-request. Combine that with the previous point about distribution being uneven and you should conclude that using <code>max_docs</code> with <code>slices</code> might not result in exactly <code>max_docs</code> documents being reindexed.
</p>
</li><li>
<p>
Each sub-request gets a slightly different snapshot of the source, though these are all taken at approximately the same time.
</p>
</li></ul>
<p>
If slicing automatically, setting <code>slices</code> to <code>auto</code> will choose a reasonable number for most indices.
If slicing manually or otherwise tuning automatic slicing, use the following guidelines.
</p>
<p>
Query performance is most efficient when the number of slices is equal to the number of shards in the index.
If that number is large (for example, <code>500</code>), choose a lower number as too many slices will hurt performance.
Setting slices higher than the number of shards generally does not improve efficiency and adds overhead.
</p>
<p>
Indexing performance scales linearly across available resources with the number of slices.
</p>
<p>
Whether query or indexing performance dominates the runtime depends on the documents being reindexed and cluster resources.
</p>
<p>
<strong>Modify documents during reindexing</strong>
</p>
<p>
Like <code>_update_by_query</code>, reindex operations support a script that modifies the document.
Unlike <code>_update_by_query</code>, the script is allowed to modify the document's metadata.
</p>
<p>
Just as in <code>_update_by_query</code>, you can set <code>ctx.op</code> to change the operation that is run on the destination.
For example, set <code>ctx.op</code> to <code>noop</code> if your script decides that the document doesn’t have to be indexed in the destination. This "no operation" will be reported in the <code>noop</code> counter in the response body.
Set <code>ctx.op</code> to <code>delete</code> if your script decides that the document must be deleted from the destination.
The deletion will be reported in the <code>deleted</code> counter in the response body.
Setting <code>ctx.op</code> to anything else will return an error, as will setting any other field in <code>ctx</code>.
</p>
<p>
Think of the possibilities! Just be careful; you are able to change:
</p>
<ul><li>
<p>
<code>_id</code>
</p>
</li><li>
<p>
<code>_index</code>
</p>
</li><li>
<p>
<code>_version</code>
</p>
</li><li>
<p>
<code>_routing</code>
</p>
</li></ul>
<p>
Setting <code>_version</code> to <code>null</code> or clearing it from the <code>ctx</code> map is just like not sending the version in an indexing request.
It will cause the document to be overwritten in the destination regardless of the version on the target or the version type you use in the reindex API.
</p>
<p>
<strong>Reindex from remote</strong>
</p>
<p>
Reindex supports reindexing from a remote Elasticsearch cluster.
The <code>host</code> parameter must contain a scheme, host, port, and optional path.
The <code>username</code> and <code>password</code> parameters are optional and when they are present the reindex operation will connect to the remote Elasticsearch node using basic authentication.
Be sure to use HTTPS when using basic authentication or the password will be sent in plain text.
There are a range of settings available to configure the behavior of the HTTPS connection.
</p>
<p>
When using Elastic Cloud, it is also possible to authenticate against the remote cluster through the use of a valid API key.
Remote hosts must be explicitly allowed with the <code>reindex.remote.whitelist</code> setting.
It can be set to a comma delimited list of allowed remote host and port combinations.
Scheme is ignored; only the host and port are used.
For example:
</p>
<pre><code class="lang-csharp">reindex.remote.whitelist: [otherhost:9200, another:9200, 127.0.10.*:9200, localhost:*"]</code></pre>
<p>
The list of allowed hosts must be configured on any nodes that will coordinate the reindex.
This feature should work with remote clusters of any version of Elasticsearch.
This should enable you to upgrade from any version of Elasticsearch to the current version by reindexing from a cluster of the old version.
</p>
<p>
WARNING: Elasticsearch does not support forward compatibility across major versions.
For example, you cannot reindex from a 7.x cluster into a 6.x cluster.
</p>
<p>
To enable queries sent to older versions of Elasticsearch, the <code>query</code> parameter is sent directly to the remote host without validation or modification.
</p>
<p>
NOTE: Reindexing from remote clusters does not support manual or automatic slicing.
</p>
<p>
Reindexing from a remote server uses an on-heap buffer that defaults to a maximum size of 100mb.
If the remote index includes very large documents you'll need to use a smaller batch size.
It is also possible to set the socket read timeout on the remote connection with the <code>socket_timeout</code> field and the connection timeout with the <code>connect_timeout</code> field.
Both default to 30 seconds.
</p>
<p>
<strong>Configuring SSL parameters</strong>
</p>
<p>
Reindex from remote supports configurable SSL settings.
These must be specified in the <code>elasticsearch.yml</code> file, with the exception of the secure settings, which you add in the Elasticsearch keystore.
It is not possible to configure SSL in the body of the reindex request.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ReindexRethrottleRequestDescriptor.html">ReindexRethrottleRequestDescriptor</a></dt>
      <dd><p>
Throttle a reindex operation.
</p>
<p>
Change the number of requests per second for a particular reindex operation.
For example:
</p>
<pre><code class="lang-csharp">POST _reindex/r1A2WoRbTwKZ516z6NEs5A:36619/_rethrottle?requests_per_second=-1</code></pre>
<p>
Rethrottling that speeds up the query takes effect immediately.
Rethrottling that slows down the query will take effect after completing the current batch.
This behavior prevents scroll timeouts.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.RenderSearchTemplateRequestDescriptor.html">RenderSearchTemplateRequestDescriptor</a></dt>
      <dd><p>
Render a search template.
</p>
<p>
Render a search template as a search request body.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.RescoreVectorDescriptor.html">RescoreVectorDescriptor</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.RetrieverDescriptor.html">RetrieverDescriptor</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.RetrieverDescriptor-1.html">RetrieverDescriptor&lt;TDocument&gt;</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.RrfRankDescriptor.html">RrfRankDescriptor</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.RrfRetrieverDescriptor.html">RrfRetrieverDescriptor</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.RrfRetrieverDescriptor-1.html">RrfRetrieverDescriptor&lt;TDocument&gt;</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.RuleRetrieverDescriptor.html">RuleRetrieverDescriptor</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.RuleRetrieverDescriptor-1.html">RuleRetrieverDescriptor&lt;TDocument&gt;</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ScoreSortDescriptor.html">ScoreSortDescriptor</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ScriptDescriptor.html">ScriptDescriptor</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ScriptFieldDescriptor.html">ScriptFieldDescriptor</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ScriptLanguage.html">ScriptLanguage</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ScriptSortDescriptor.html">ScriptSortDescriptor</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ScriptSortDescriptor-1.html">ScriptSortDescriptor&lt;TDocument&gt;</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ScriptsPainlessExecuteRequestDescriptor.html">ScriptsPainlessExecuteRequestDescriptor</a></dt>
      <dd><p>
Run a script.
</p>
<p>
Runs a script and returns a result.
Use this API to build and test scripts, such as when defining a script for a runtime field.
This API requires very few dependencies and is especially useful if you don't have permissions to write documents on a cluster.
</p>
<p>
The API uses several <em>contexts</em>, which control how scripts are run, what variables are available at runtime, and what the return type is.
</p>
<p>
Each context requires a script, but additional parameters depend on the context you're using for that script.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ScriptsPainlessExecuteRequestDescriptor-1.html">ScriptsPainlessExecuteRequestDescriptor&lt;TDocument&gt;</a></dt>
      <dd><p>
Run a script.
</p>
<p>
Runs a script and returns a result.
Use this API to build and test scripts, such as when defining a script for a runtime field.
This API requires very few dependencies and is especially useful if you don't have permissions to write documents on a cluster.
</p>
<p>
The API uses several <em>contexts</em>, which control how scripts are run, what variables are available at runtime, and what the return type is.
</p>
<p>
Each context requires a script, but additional parameters depend on the context you're using for that script.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ScrollRequestDescriptor.html">ScrollRequestDescriptor</a></dt>
      <dd><p>
Run a scrolling search.
</p>
<p>
IMPORTANT: The scroll API is no longer recommend for deep pagination. If you need to preserve the index state while paging through more than 10,000 hits, use the <code>search_after</code> parameter with a point in time (PIT).
</p>
<p>
The scroll API gets large sets of results from a single scrolling search request.
To get the necessary scroll ID, submit a search API request that includes an argument for the <code>scroll</code> query parameter.
The <code>scroll</code> parameter indicates how long Elasticsearch should retain the search context for the request.
The search response returns a scroll ID in the <code>_scroll_id</code> response body parameter.
You can then use the scroll ID with the scroll API to retrieve the next batch of results for the request.
If the Elasticsearch security features are enabled, the access to the results of a specific scroll ID is restricted to the user or API key that submitted the search.
</p>
<p>
You can also use the scroll API to specify a new scroll parameter that extends or shortens the retention period for the search context.
</p>
<p>
IMPORTANT: Results from a scrolling search reflect the state of the index at the time of the initial search request. Subsequent indexing or document changes only affect later search and scroll requests.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.SearchMvtRequestDescriptor.html">SearchMvtRequestDescriptor</a></dt>
      <dd><p>
Search a vector tile.
</p>
<p>
Search a vector tile for geospatial values.
Before using this API, you should be familiar with the Mapbox vector tile specification.
The API returns results as a binary mapbox vector tile.
</p>
<p>
Internally, Elasticsearch translates a vector tile search API request into a search containing:
</p>
<ul><li>
<p>
A <code>geo_bounding_box</code> query on the <code>&lt;field&gt;</code>. The query uses the <code>&lt;zoom&gt;/&lt;x&gt;/&lt;y&gt;</code> tile as a bounding box.
</p>
</li><li>
<p>
A <code>geotile_grid</code> or <code>geohex_grid</code> aggregation on the <code>&lt;field&gt;</code>. The <code>grid_agg</code> parameter determines the aggregation type. The aggregation uses the <code>&lt;zoom&gt;/&lt;x&gt;/&lt;y&gt;</code> tile as a bounding box.
</p>
</li><li>
<p>
Optionally, a <code>geo_bounds</code> aggregation on the <code>&lt;field&gt;</code>. The search only includes this aggregation if the <code>exact_bounds</code> parameter is <code>true</code>.
</p>
</li><li>
<p>
If the optional parameter <code>with_labels</code> is <code>true</code>, the internal search will include a dynamic runtime field that calls the <code>getLabelPosition</code> function of the geometry doc value. This enables the generation of new point features containing suggested geometry labels, so that, for example, multi-polygons will have only one label.
</p>
</li></ul>
<p>
For example, Elasticsearch may translate a vector tile search API request with a <code>grid_agg</code> argument of <code>geotile</code> and an <code>exact_bounds</code> argument of <code>true</code> into the following search
</p>
<pre><code class="lang-csharp">GET my-index/_search
{
  "size": 10000,
  "query": {
    "geo_bounding_box": {
      "my-geo-field": {
        "top_left": {
          "lat": -40.979898069620134,
          "lon": -45
        },
        "bottom_right": {
          "lat": -66.51326044311186,
          "lon": 0
        }
      }
    }
  },
  "aggregations": {
    "grid": {
      "geotile_grid": {
        "field": "my-geo-field",
        "precision": 11,
        "size": 65536,
        "bounds": {
          "top_left": {
            "lat": -40.979898069620134,
            "lon": -45
          },
          "bottom_right": {
            "lat": -66.51326044311186,
            "lon": 0
          }
        }
      }
    },
    "bounds": {
      "geo_bounds": {
        "field": "my-geo-field",
        "wrap_longitude": false
      }
    }
  }
}</code></pre>
<p>
The API returns results as a binary Mapbox vector tile.
Mapbox vector tiles are encoded as Google Protobufs (PBF). By default, the tile contains three layers:
</p>
<ul><li>
<p>
A <code>hits</code> layer containing a feature for each <code>&lt;field&gt;</code> value matching the <code>geo_bounding_box</code> query.
</p>
</li><li>
<p>
An <code>aggs</code> layer containing a feature for each cell of the <code>geotile_grid</code> or <code>geohex_grid</code>. The layer only contains features for cells with matching data.
</p>
</li><li>
<p>
A meta layer containing:
</p>
<ul><li>
<p>
A feature containing a bounding box. By default, this is the bounding box of the tile.
</p>
</li><li>
<p>
Value ranges for any sub-aggregations on the <code>geotile_grid</code> or <code>geohex_grid</code>.
</p>
</li><li>
<p>
Metadata for the search.
</p>
</li></ul>
</li></ul>
<p>
The API only returns features that can display at its zoom level.
For example, if a polygon feature has no area at its zoom level, the API omits it.
The API returns errors as UTF-8 encoded JSON.
</p>
<p>
IMPORTANT: You can specify several options for this API as either a query parameter or request body parameter.
If you specify both parameters, the query parameter takes precedence.
</p>
<p>
<strong>Grid precision for geotile</strong>
</p>
<p>
For a <code>grid_agg</code> of <code>geotile</code>, you can use cells in the <code>aggs</code> layer as tiles for lower zoom levels.
<code>grid_precision</code> represents the additional zoom levels available through these cells. The final precision is computed by as follows: <code>&lt;zoom&gt; + grid_precision</code>.
For example, if <code>&lt;zoom&gt;</code> is 7 and <code>grid_precision</code> is 8, then the <code>geotile_grid</code> aggregation will use a precision of 15.
The maximum final precision is 29.
The <code>grid_precision</code> also determines the number of cells for the grid as follows: <code>(2^grid_precision) x (2^grid_precision)</code>.
For example, a value of 8 divides the tile into a grid of 256 x 256 cells.
The <code>aggs</code> layer only contains features for cells with matching data.
</p>
<p>
<strong>Grid precision for geohex</strong>
</p>
<p>
For a <code>grid_agg</code> of <code>geohex</code>, Elasticsearch uses <code>&lt;zoom&gt;</code> and <code>grid_precision</code> to calculate a final precision as follows: <code>&lt;zoom&gt; + grid_precision</code>.
</p>
<p>
This precision determines the H3 resolution of the hexagonal cells produced by the <code>geohex</code> aggregation.
The following table maps the H3 resolution for each precision.
For example, if <code>&lt;zoom&gt;</code> is 3 and <code>grid_precision</code> is 3, the precision is 6.
At a precision of 6, hexagonal cells have an H3 resolution of 2.
If <code>&lt;zoom&gt;</code> is 3 and <code>grid_precision</code> is 4, the precision is 7.
At a precision of 7, hexagonal cells have an H3 resolution of 3.
</p>
<p>
| Precision | Unique tile bins | H3 resolution | Unique hex bins |	Ratio |
| --------- | ---------------- | ------------- | ----------------| ----- |
| 1  | 4                  | 0  | 122             | 30.5           |
| 2  | 16                 | 0  | 122             | 7.625          |
| 3  | 64                 | 1  | 842             | 13.15625       |
| 4  | 256                | 1  | 842             | 3.2890625      |
| 5  | 1024               | 2  | 5882            | 5.744140625    |
| 6  | 4096               | 2  | 5882            | 1.436035156    |
| 7  | 16384              | 3  | 41162           | 2.512329102    |
| 8  | 65536              | 3  | 41162           | 0.6280822754   |
| 9  | 262144             | 4  | 288122          | 1.099098206    |
| 10 | 1048576            | 4  | 288122          | 0.2747745514   |
| 11 | 4194304            | 5  | 2016842         | 0.4808526039   |
| 12 | 16777216           | 6  | 14117882        | 0.8414913416   |
| 13 | 67108864           | 6  | 14117882        | 0.2103728354   |
| 14 | 268435456          | 7  | 98825162        | 0.3681524172   |
| 15 | 1073741824         | 8  | 691776122       | 0.644266719    |
| 16 | 4294967296         | 8  | 691776122       | 0.1610666797   |
| 17 | 17179869184        | 9  | 4842432842      | 0.2818666889   |
| 18 | 68719476736        | 10 | 33897029882     | 0.4932667053   |
| 19 | 274877906944       | 11 | 237279209162    | 0.8632167343   |
| 20 | 1099511627776      | 11 | 237279209162    | 0.2158041836   |
| 21 | 4398046511104      | 12 | 1660954464122   | 0.3776573213   |
| 22 | 17592186044416     | 13 | 11626681248842  | 0.6609003122   |
| 23 | 70368744177664     | 13 | 11626681248842  | 0.165225078    |
| 24 | 281474976710656    | 14 | 81386768741882  | 0.2891438866   |
| 25 | 1125899906842620   | 15 | 569707381193162 | 0.5060018015   |
| 26 | 4503599627370500   | 15 | 569707381193162 | 0.1265004504   |
| 27 | 18014398509482000  | 15 | 569707381193162 | 0.03162511259  |
| 28 | 72057594037927900  | 15 | 569707381193162 | 0.007906278149 |
| 29 | 288230376151712000 | 15 | 569707381193162 | 0.001976569537 |
</p>
<p>
Hexagonal cells don't align perfectly on a vector tile.
Some cells may intersect more than one vector tile.
To compute the H3 resolution for each precision, Elasticsearch compares the average density of hexagonal bins at each resolution with the average density of tile bins at each zoom level.
Elasticsearch uses the H3 resolution that is closest to the corresponding geotile density.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.SearchMvtRequestDescriptor-1.html">SearchMvtRequestDescriptor&lt;TDocument&gt;</a></dt>
      <dd><p>
Search a vector tile.
</p>
<p>
Search a vector tile for geospatial values.
Before using this API, you should be familiar with the Mapbox vector tile specification.
The API returns results as a binary mapbox vector tile.
</p>
<p>
Internally, Elasticsearch translates a vector tile search API request into a search containing:
</p>
<ul><li>
<p>
A <code>geo_bounding_box</code> query on the <code>&lt;field&gt;</code>. The query uses the <code>&lt;zoom&gt;/&lt;x&gt;/&lt;y&gt;</code> tile as a bounding box.
</p>
</li><li>
<p>
A <code>geotile_grid</code> or <code>geohex_grid</code> aggregation on the <code>&lt;field&gt;</code>. The <code>grid_agg</code> parameter determines the aggregation type. The aggregation uses the <code>&lt;zoom&gt;/&lt;x&gt;/&lt;y&gt;</code> tile as a bounding box.
</p>
</li><li>
<p>
Optionally, a <code>geo_bounds</code> aggregation on the <code>&lt;field&gt;</code>. The search only includes this aggregation if the <code>exact_bounds</code> parameter is <code>true</code>.
</p>
</li><li>
<p>
If the optional parameter <code>with_labels</code> is <code>true</code>, the internal search will include a dynamic runtime field that calls the <code>getLabelPosition</code> function of the geometry doc value. This enables the generation of new point features containing suggested geometry labels, so that, for example, multi-polygons will have only one label.
</p>
</li></ul>
<p>
For example, Elasticsearch may translate a vector tile search API request with a <code>grid_agg</code> argument of <code>geotile</code> and an <code>exact_bounds</code> argument of <code>true</code> into the following search
</p>
<pre><code class="lang-csharp">GET my-index/_search
{
  "size": 10000,
  "query": {
    "geo_bounding_box": {
      "my-geo-field": {
        "top_left": {
          "lat": -40.979898069620134,
          "lon": -45
        },
        "bottom_right": {
          "lat": -66.51326044311186,
          "lon": 0
        }
      }
    }
  },
  "aggregations": {
    "grid": {
      "geotile_grid": {
        "field": "my-geo-field",
        "precision": 11,
        "size": 65536,
        "bounds": {
          "top_left": {
            "lat": -40.979898069620134,
            "lon": -45
          },
          "bottom_right": {
            "lat": -66.51326044311186,
            "lon": 0
          }
        }
      }
    },
    "bounds": {
      "geo_bounds": {
        "field": "my-geo-field",
        "wrap_longitude": false
      }
    }
  }
}</code></pre>
<p>
The API returns results as a binary Mapbox vector tile.
Mapbox vector tiles are encoded as Google Protobufs (PBF). By default, the tile contains three layers:
</p>
<ul><li>
<p>
A <code>hits</code> layer containing a feature for each <code>&lt;field&gt;</code> value matching the <code>geo_bounding_box</code> query.
</p>
</li><li>
<p>
An <code>aggs</code> layer containing a feature for each cell of the <code>geotile_grid</code> or <code>geohex_grid</code>. The layer only contains features for cells with matching data.
</p>
</li><li>
<p>
A meta layer containing:
</p>
<ul><li>
<p>
A feature containing a bounding box. By default, this is the bounding box of the tile.
</p>
</li><li>
<p>
Value ranges for any sub-aggregations on the <code>geotile_grid</code> or <code>geohex_grid</code>.
</p>
</li><li>
<p>
Metadata for the search.
</p>
</li></ul>
</li></ul>
<p>
The API only returns features that can display at its zoom level.
For example, if a polygon feature has no area at its zoom level, the API omits it.
The API returns errors as UTF-8 encoded JSON.
</p>
<p>
IMPORTANT: You can specify several options for this API as either a query parameter or request body parameter.
If you specify both parameters, the query parameter takes precedence.
</p>
<p>
<strong>Grid precision for geotile</strong>
</p>
<p>
For a <code>grid_agg</code> of <code>geotile</code>, you can use cells in the <code>aggs</code> layer as tiles for lower zoom levels.
<code>grid_precision</code> represents the additional zoom levels available through these cells. The final precision is computed by as follows: <code>&lt;zoom&gt; + grid_precision</code>.
For example, if <code>&lt;zoom&gt;</code> is 7 and <code>grid_precision</code> is 8, then the <code>geotile_grid</code> aggregation will use a precision of 15.
The maximum final precision is 29.
The <code>grid_precision</code> also determines the number of cells for the grid as follows: <code>(2^grid_precision) x (2^grid_precision)</code>.
For example, a value of 8 divides the tile into a grid of 256 x 256 cells.
The <code>aggs</code> layer only contains features for cells with matching data.
</p>
<p>
<strong>Grid precision for geohex</strong>
</p>
<p>
For a <code>grid_agg</code> of <code>geohex</code>, Elasticsearch uses <code>&lt;zoom&gt;</code> and <code>grid_precision</code> to calculate a final precision as follows: <code>&lt;zoom&gt; + grid_precision</code>.
</p>
<p>
This precision determines the H3 resolution of the hexagonal cells produced by the <code>geohex</code> aggregation.
The following table maps the H3 resolution for each precision.
For example, if <code>&lt;zoom&gt;</code> is 3 and <code>grid_precision</code> is 3, the precision is 6.
At a precision of 6, hexagonal cells have an H3 resolution of 2.
If <code>&lt;zoom&gt;</code> is 3 and <code>grid_precision</code> is 4, the precision is 7.
At a precision of 7, hexagonal cells have an H3 resolution of 3.
</p>
<p>
| Precision | Unique tile bins | H3 resolution | Unique hex bins |	Ratio |
| --------- | ---------------- | ------------- | ----------------| ----- |
| 1  | 4                  | 0  | 122             | 30.5           |
| 2  | 16                 | 0  | 122             | 7.625          |
| 3  | 64                 | 1  | 842             | 13.15625       |
| 4  | 256                | 1  | 842             | 3.2890625      |
| 5  | 1024               | 2  | 5882            | 5.744140625    |
| 6  | 4096               | 2  | 5882            | 1.436035156    |
| 7  | 16384              | 3  | 41162           | 2.512329102    |
| 8  | 65536              | 3  | 41162           | 0.6280822754   |
| 9  | 262144             | 4  | 288122          | 1.099098206    |
| 10 | 1048576            | 4  | 288122          | 0.2747745514   |
| 11 | 4194304            | 5  | 2016842         | 0.4808526039   |
| 12 | 16777216           | 6  | 14117882        | 0.8414913416   |
| 13 | 67108864           | 6  | 14117882        | 0.2103728354   |
| 14 | 268435456          | 7  | 98825162        | 0.3681524172   |
| 15 | 1073741824         | 8  | 691776122       | 0.644266719    |
| 16 | 4294967296         | 8  | 691776122       | 0.1610666797   |
| 17 | 17179869184        | 9  | 4842432842      | 0.2818666889   |
| 18 | 68719476736        | 10 | 33897029882     | 0.4932667053   |
| 19 | 274877906944       | 11 | 237279209162    | 0.8632167343   |
| 20 | 1099511627776      | 11 | 237279209162    | 0.2158041836   |
| 21 | 4398046511104      | 12 | 1660954464122   | 0.3776573213   |
| 22 | 17592186044416     | 13 | 11626681248842  | 0.6609003122   |
| 23 | 70368744177664     | 13 | 11626681248842  | 0.165225078    |
| 24 | 281474976710656    | 14 | 81386768741882  | 0.2891438866   |
| 25 | 1125899906842620   | 15 | 569707381193162 | 0.5060018015   |
| 26 | 4503599627370500   | 15 | 569707381193162 | 0.1265004504   |
| 27 | 18014398509482000  | 15 | 569707381193162 | 0.03162511259  |
| 28 | 72057594037927900  | 15 | 569707381193162 | 0.007906278149 |
| 29 | 288230376151712000 | 15 | 569707381193162 | 0.001976569537 |
</p>
<p>
Hexagonal cells don't align perfectly on a vector tile.
Some cells may intersect more than one vector tile.
To compute the H3 resolution for each precision, Elasticsearch compares the average density of hexagonal bins at each resolution with the average density of tile bins at each zoom level.
Elasticsearch uses the H3 resolution that is closest to the corresponding geotile density.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.SearchRequestDescriptor.html">SearchRequestDescriptor</a></dt>
      <dd><p>
Run a search.
</p>
<p>
Get search hits that match the query defined in the request.
You can provide search queries using the <code>q</code> query string parameter or the request body.
If both are specified, only the query parameter is used.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the read index privilege for the target data stream, index, or alias. For cross-cluster search, refer to the documentation about configuring CCS privileges.
To search a point in time (PIT) for an alias, you must have the <code>read</code> index privilege for the alias's data streams or indices.
</p>
<p>
<strong>Search slicing</strong>
</p>
<p>
When paging through a large number of documents, it can be helpful to split the search into multiple slices to consume them independently with the <code>slice</code> and <code>pit</code> properties.
By default the splitting is done first on the shards, then locally on each shard.
The local splitting partitions the shard into contiguous ranges based on Lucene document IDs.
</p>
<p>
For instance if the number of shards is equal to 2 and you request 4 slices, the slices 0 and 2 are assigned to the first shard and the slices 1 and 3 are assigned to the second shard.
</p>
<p>
IMPORTANT: The same point-in-time ID should be used for all slices.
If different PIT IDs are used, slices can overlap and miss documents.
This situation can occur because the splitting criterion is based on Lucene document IDs, which are not stable across changes to the index.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.SearchRequestDescriptor-1.html">SearchRequestDescriptor&lt;TDocument&gt;</a></dt>
      <dd><p>
Run a search.
</p>
<p>
Get search hits that match the query defined in the request.
You can provide search queries using the <code>q</code> query string parameter or the request body.
If both are specified, only the query parameter is used.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the read index privilege for the target data stream, index, or alias. For cross-cluster search, refer to the documentation about configuring CCS privileges.
To search a point in time (PIT) for an alias, you must have the <code>read</code> index privilege for the alias's data streams or indices.
</p>
<p>
<strong>Search slicing</strong>
</p>
<p>
When paging through a large number of documents, it can be helpful to split the search into multiple slices to consume them independently with the <code>slice</code> and <code>pit</code> properties.
By default the splitting is done first on the shards, then locally on each shard.
The local splitting partitions the shard into contiguous ranges based on Lucene document IDs.
</p>
<p>
For instance if the number of shards is equal to 2 and you request 4 slices, the slices 0 and 2 are assigned to the first shard and the slices 1 and 3 are assigned to the second shard.
</p>
<p>
IMPORTANT: The same point-in-time ID should be used for all slices.
If different PIT IDs are used, slices can overlap and miss documents.
This situation can occur because the splitting criterion is based on Lucene document IDs, which are not stable across changes to the index.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.SearchShardsRequestDescriptor.html">SearchShardsRequestDescriptor</a></dt>
      <dd><p>
Get the search shards.
</p>
<p>
Get the indices and shards that a search request would be run against.
This information can be useful for working out issues or planning optimizations with routing and shard preferences.
When filtered aliases are used, the filter is returned as part of the <code>indices</code> section.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the <code>view_index_metadata</code> or <code>manage</code> index privilege for the target data stream, index, or alias.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.SearchShardsRequestDescriptor-1.html">SearchShardsRequestDescriptor&lt;TDocument&gt;</a></dt>
      <dd><p>
Get the search shards.
</p>
<p>
Get the indices and shards that a search request would be run against.
This information can be useful for working out issues or planning optimizations with routing and shard preferences.
When filtered aliases are used, the filter is returned as part of the <code>indices</code> section.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the <code>view_index_metadata</code> or <code>manage</code> index privilege for the target data stream, index, or alias.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.SearchTemplateRequestDescriptor.html">SearchTemplateRequestDescriptor</a></dt>
      <dd><p>
Run a search with a search template.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.SearchTemplateRequestDescriptor-1.html">SearchTemplateRequestDescriptor&lt;TDocument&gt;</a></dt>
      <dd><p>
Run a search with a search template.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.SlicedScrollDescriptor.html">SlicedScrollDescriptor</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.SlicedScrollDescriptor-1.html">SlicedScrollDescriptor&lt;TDocument&gt;</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.SlicesFactory.html">SlicesFactory</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.SortOptionsDescriptor.html">SortOptionsDescriptor</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.SortOptionsDescriptor-1.html">SortOptionsDescriptor&lt;TDocument&gt;</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.StandardRetrieverDescriptor.html">StandardRetrieverDescriptor</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.StandardRetrieverDescriptor-1.html">StandardRetrieverDescriptor&lt;TDocument&gt;</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.StoredScriptDescriptor.html">StoredScriptDescriptor</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.TermVectorsRequestDescriptor-1.html">TermVectorsRequestDescriptor&lt;TDocument&gt;</a></dt>
      <dd><p>
Get term vector information.
</p>
<p>
Get information and statistics about terms in the fields of a particular document.
</p>
<p>
You can retrieve term vectors for documents stored in the index or for artificial documents passed in the body of the request.
You can specify the fields you are interested in through the <code>fields</code> parameter or by adding the fields to the request body.
For example:
</p>
<pre><code class="lang-csharp">GET /my-index-000001/_termvectors/1?fields=message</code></pre>
<p>
Fields can be specified using wildcards, similar to the multi match query.
</p>
<p>
Term vectors are real-time by default, not near real-time.
This can be changed by setting <code>realtime</code> parameter to <code>false</code>.
</p>
<p>
You can request three types of values: <em>term information</em>, <em>term statistics</em>, and <em>field statistics</em>.
By default, all term information and field statistics are returned for all fields but term statistics are excluded.
</p>
<p>
<strong>Term information</strong>
</p>
<ul><li>
<p>
term frequency in the field (always returned)
</p>
</li><li>
<p>
term positions (<code>positions: true</code>)
</p>
</li><li>
<p>
start and end offsets (<code>offsets: true</code>)
</p>
</li><li>
<p>
term payloads (<code>payloads: true</code>), as base64 encoded bytes
</p>
</li></ul>
<p>
If the requested information wasn't stored in the index, it will be computed on the fly if possible.
Additionally, term vectors could be computed for documents not even existing in the index, but instead provided by the user.
</p>
<p>
warn
Start and end offsets assume UTF-16 encoding is being used. If you want to use these offsets in order to get the original text that produced this token, you should make sure that the string you are taking a sub-string of is also encoded using UTF-16.
</p>
<p>
<strong>Behaviour</strong>
</p>
<p>
The term and field statistics are not accurate.
Deleted documents are not taken into account.
The information is only retrieved for the shard the requested document resides in.
The term and field statistics are therefore only useful as relative measures whereas the absolute numbers have no meaning in this context.
By default, when requesting term vectors of artificial documents, a shard to get the statistics from is randomly selected.
Use <code>routing</code> only to hit a particular shard.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.TermsEnumRequestDescriptor.html">TermsEnumRequestDescriptor</a></dt>
      <dd><p>
Get terms in an index.
</p>
<p>
Discover terms that match a partial string in an index.
This API is designed for low-latency look-ups used in auto-complete scenarios.
</p>
<p>
info
The terms enum API may return terms from deleted documents. Deleted documents are initially only marked as deleted. It is not until their segments are merged that documents are actually deleted. Until that happens, the terms enum API will return terms from these documents.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.TermsEnumRequestDescriptor-1.html">TermsEnumRequestDescriptor&lt;TDocument&gt;</a></dt>
      <dd><p>
Get terms in an index.
</p>
<p>
Discover terms that match a partial string in an index.
This API is designed for low-latency look-ups used in auto-complete scenarios.
</p>
<p>
info
The terms enum API may return terms from deleted documents. Deleted documents are initially only marked as deleted. It is not until their segments are merged that documents are actually deleted. Until that happens, the terms enum API will return terms from these documents.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.TextEmbeddingDescriptor.html">TextEmbeddingDescriptor</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.TextSimilarityRerankerDescriptor.html">TextSimilarityRerankerDescriptor</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.TextSimilarityRerankerDescriptor-1.html">TextSimilarityRerankerDescriptor&lt;TDocument&gt;</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.TopLeftBottomRightGeoBoundsDescriptor.html">TopLeftBottomRightGeoBoundsDescriptor</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.TopRightBottomLeftGeoBoundsDescriptor.html">TopRightBottomLeftGeoBoundsDescriptor</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.UpdateByQueryRequestDescriptor.html">UpdateByQueryRequestDescriptor</a></dt>
      <dd><p>
Update documents.
Updates documents that match the specified query.
If no query is specified, performs an update on every document in the data stream or index without modifying the source, which is useful for picking up mapping changes.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or alias:
</p>
<ul><li>
<p>
<code>read</code>
</p>
</li><li>
<p>
<code>index</code> or <code>write</code>
</p>
</li></ul>
<p>
You can specify the query criteria in the request URI or the request body using the same syntax as the search API.
</p>
<p>
When you submit an update by query request, Elasticsearch gets a snapshot of the data stream or index when it begins processing the request and updates matching documents using internal versioning.
When the versions match, the document is updated and the version number is incremented.
If a document changes between the time that the snapshot is taken and the update operation is processed, it results in a version conflict and the operation fails.
You can opt to count version conflicts instead of halting and returning by setting <code>conflicts</code> to <code>proceed</code>.
Note that if you opt to count version conflicts, the operation could attempt to update more documents from the source than <code>max_docs</code> until it has successfully updated <code>max_docs</code> documents or it has gone through every document in the source query.
</p>
<p>
NOTE: Documents with a version equal to 0 cannot be updated using update by query because internal versioning does not support 0 as a valid version number.
</p>
<p>
While processing an update by query request, Elasticsearch performs multiple search requests sequentially to find all of the matching documents.
A bulk update request is performed for each batch of matching documents.
Any query or update failures cause the update by query request to fail and the failures are shown in the response.
Any update requests that completed successfully still stick, they are not rolled back.
</p>
<p>
<strong>Throttling update requests</strong>
</p>
<p>
To control the rate at which update by query issues batches of update operations, you can set <code>requests_per_second</code> to any positive decimal number.
This pads each batch with a wait time to throttle the rate.
Set <code>requests_per_second</code> to <code>-1</code> to turn off throttling.
</p>
<p>
Throttling uses a wait time between batches so that the internal scroll requests can be given a timeout that takes the request padding into account.
The padding time is the difference between the batch size divided by the <code>requests_per_second</code> and the time spent writing.
By default the batch size is 1000, so if <code>requests_per_second</code> is set to <code>500</code>:
</p>
<pre><code class="lang-csharp">target_time = 1000 / 500 per second = 2 seconds
wait_time = target_time - write_time = 2 seconds - .5 seconds = 1.5 seconds</code></pre>
<p>
Since the batch is issued as a single _bulk request, large batch sizes cause Elasticsearch to create many requests and wait before starting the next set.
This is "bursty" instead of "smooth".
</p>
<p>
<strong>Slicing</strong>
</p>
<p>
Update by query supports sliced scroll to parallelize the update process.
This can improve efficiency and provide a convenient way to break the request down into smaller parts.
</p>
<p>
Setting <code>slices</code> to <code>auto</code> chooses a reasonable number for most data streams and indices.
This setting will use one slice per shard, up to a certain limit.
If there are multiple source data streams or indices, it will choose the number of slices based on the index or backing index with the smallest number of shards.
</p>
<p>
Adding <code>slices</code> to <code>_update_by_query</code> just automates the manual process of creating sub-requests, which means it has some quirks:
</p>
<ul><li>
<p>
You can see these requests in the tasks APIs. These sub-requests are "child" tasks of the task for the request with slices.
</p>
</li><li>
<p>
Fetching the status of the task for the request with <code>slices</code> only contains the status of completed slices.
</p>
</li><li>
<p>
These sub-requests are individually addressable for things like cancellation and rethrottling.
</p>
</li><li>
<p>
Rethrottling the request with <code>slices</code> will rethrottle the unfinished sub-request proportionally.
</p>
</li><li>
<p>
Canceling the request with slices will cancel each sub-request.
</p>
</li><li>
<p>
Due to the nature of slices each sub-request won't get a perfectly even portion of the documents. All documents will be addressed, but some slices may be larger than others. Expect larger slices to have a more even distribution.
</p>
</li><li>
<p>
Parameters like <code>requests_per_second</code> and <code>max_docs</code> on a request with slices are distributed proportionally to each sub-request. Combine that with the point above about distribution being uneven and you should conclude that using <code>max_docs</code> with <code>slices</code> might not result in exactly <code>max_docs</code> documents being updated.
</p>
</li><li>
<p>
Each sub-request gets a slightly different snapshot of the source data stream or index though these are all taken at approximately the same time.
</p>
</li></ul>
<p>
If you're slicing manually or otherwise tuning automatic slicing, keep in mind that:
</p>
<ul><li>
<p>
Query performance is most efficient when the number of slices is equal to the number of shards in the index or backing index. If that number is large (for example, 500), choose a lower number as too many slices hurts performance. Setting slices higher than the number of shards generally does not improve efficiency and adds overhead.
</p>
</li><li>
<p>
Update performance scales linearly across available resources with the number of slices.
</p>
</li></ul>
<p>
Whether query or update performance dominates the runtime depends on the documents being reindexed and cluster resources.
</p>
<p>
<strong>Update the document source</strong>
</p>
<p>
Update by query supports scripts to update the document source.
As with the update API, you can set <code>ctx.op</code> to change the operation that is performed.
</p>
<p>
Set <code>ctx.op = "noop"</code> if your script decides that it doesn't have to make any changes.
The update by query operation skips updating the document and increments the <code>noop</code> counter.
</p>
<p>
Set <code>ctx.op = "delete"</code> if your script decides that the document should be deleted.
The update by query operation deletes the document and increments the <code>deleted</code> counter.
</p>
<p>
Update by query supports only <code>index</code>, <code>noop</code>, and <code>delete</code>.
Setting <code>ctx.op</code> to anything else is an error.
Setting any other field in <code>ctx</code> is an error.
This API enables you to only modify the source of matching documents; you cannot move them.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.UpdateByQueryRequestDescriptor-1.html">UpdateByQueryRequestDescriptor&lt;TDocument&gt;</a></dt>
      <dd><p>
Update documents.
Updates documents that match the specified query.
If no query is specified, performs an update on every document in the data stream or index without modifying the source, which is useful for picking up mapping changes.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or alias:
</p>
<ul><li>
<p>
<code>read</code>
</p>
</li><li>
<p>
<code>index</code> or <code>write</code>
</p>
</li></ul>
<p>
You can specify the query criteria in the request URI or the request body using the same syntax as the search API.
</p>
<p>
When you submit an update by query request, Elasticsearch gets a snapshot of the data stream or index when it begins processing the request and updates matching documents using internal versioning.
When the versions match, the document is updated and the version number is incremented.
If a document changes between the time that the snapshot is taken and the update operation is processed, it results in a version conflict and the operation fails.
You can opt to count version conflicts instead of halting and returning by setting <code>conflicts</code> to <code>proceed</code>.
Note that if you opt to count version conflicts, the operation could attempt to update more documents from the source than <code>max_docs</code> until it has successfully updated <code>max_docs</code> documents or it has gone through every document in the source query.
</p>
<p>
NOTE: Documents with a version equal to 0 cannot be updated using update by query because internal versioning does not support 0 as a valid version number.
</p>
<p>
While processing an update by query request, Elasticsearch performs multiple search requests sequentially to find all of the matching documents.
A bulk update request is performed for each batch of matching documents.
Any query or update failures cause the update by query request to fail and the failures are shown in the response.
Any update requests that completed successfully still stick, they are not rolled back.
</p>
<p>
<strong>Throttling update requests</strong>
</p>
<p>
To control the rate at which update by query issues batches of update operations, you can set <code>requests_per_second</code> to any positive decimal number.
This pads each batch with a wait time to throttle the rate.
Set <code>requests_per_second</code> to <code>-1</code> to turn off throttling.
</p>
<p>
Throttling uses a wait time between batches so that the internal scroll requests can be given a timeout that takes the request padding into account.
The padding time is the difference between the batch size divided by the <code>requests_per_second</code> and the time spent writing.
By default the batch size is 1000, so if <code>requests_per_second</code> is set to <code>500</code>:
</p>
<pre><code class="lang-csharp">target_time = 1000 / 500 per second = 2 seconds
wait_time = target_time - write_time = 2 seconds - .5 seconds = 1.5 seconds</code></pre>
<p>
Since the batch is issued as a single _bulk request, large batch sizes cause Elasticsearch to create many requests and wait before starting the next set.
This is "bursty" instead of "smooth".
</p>
<p>
<strong>Slicing</strong>
</p>
<p>
Update by query supports sliced scroll to parallelize the update process.
This can improve efficiency and provide a convenient way to break the request down into smaller parts.
</p>
<p>
Setting <code>slices</code> to <code>auto</code> chooses a reasonable number for most data streams and indices.
This setting will use one slice per shard, up to a certain limit.
If there are multiple source data streams or indices, it will choose the number of slices based on the index or backing index with the smallest number of shards.
</p>
<p>
Adding <code>slices</code> to <code>_update_by_query</code> just automates the manual process of creating sub-requests, which means it has some quirks:
</p>
<ul><li>
<p>
You can see these requests in the tasks APIs. These sub-requests are "child" tasks of the task for the request with slices.
</p>
</li><li>
<p>
Fetching the status of the task for the request with <code>slices</code> only contains the status of completed slices.
</p>
</li><li>
<p>
These sub-requests are individually addressable for things like cancellation and rethrottling.
</p>
</li><li>
<p>
Rethrottling the request with <code>slices</code> will rethrottle the unfinished sub-request proportionally.
</p>
</li><li>
<p>
Canceling the request with slices will cancel each sub-request.
</p>
</li><li>
<p>
Due to the nature of slices each sub-request won't get a perfectly even portion of the documents. All documents will be addressed, but some slices may be larger than others. Expect larger slices to have a more even distribution.
</p>
</li><li>
<p>
Parameters like <code>requests_per_second</code> and <code>max_docs</code> on a request with slices are distributed proportionally to each sub-request. Combine that with the point above about distribution being uneven and you should conclude that using <code>max_docs</code> with <code>slices</code> might not result in exactly <code>max_docs</code> documents being updated.
</p>
</li><li>
<p>
Each sub-request gets a slightly different snapshot of the source data stream or index though these are all taken at approximately the same time.
</p>
</li></ul>
<p>
If you're slicing manually or otherwise tuning automatic slicing, keep in mind that:
</p>
<ul><li>
<p>
Query performance is most efficient when the number of slices is equal to the number of shards in the index or backing index. If that number is large (for example, 500), choose a lower number as too many slices hurts performance. Setting slices higher than the number of shards generally does not improve efficiency and adds overhead.
</p>
</li><li>
<p>
Update performance scales linearly across available resources with the number of slices.
</p>
</li></ul>
<p>
Whether query or update performance dominates the runtime depends on the documents being reindexed and cluster resources.
</p>
<p>
<strong>Update the document source</strong>
</p>
<p>
Update by query supports scripts to update the document source.
As with the update API, you can set <code>ctx.op</code> to change the operation that is performed.
</p>
<p>
Set <code>ctx.op = "noop"</code> if your script decides that it doesn't have to make any changes.
The update by query operation skips updating the document and increments the <code>noop</code> counter.
</p>
<p>
Set <code>ctx.op = "delete"</code> if your script decides that the document should be deleted.
The update by query operation deletes the document and increments the <code>deleted</code> counter.
</p>
<p>
Update by query supports only <code>index</code>, <code>noop</code>, and <code>delete</code>.
Setting <code>ctx.op</code> to anything else is an error.
Setting any other field in <code>ctx</code> is an error.
This API enables you to only modify the source of matching documents; you cannot move them.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.UpdateByQueryRethrottleRequestDescriptor.html">UpdateByQueryRethrottleRequestDescriptor</a></dt>
      <dd><p>
Throttle an update by query operation.
</p>
<p>
Change the number of requests per second for a particular update by query operation.
Rethrottling that speeds up the query takes effect immediately but rethrotting that slows down the query takes effect after completing the current batch to prevent scroll timeouts.
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.UpdateRequestDescriptor-2.html">UpdateRequestDescriptor&lt;TDocument, TPartialDocument&gt;</a></dt>
      <dd><p>
Update a document.
</p>
<p>
Update a document by running a script or passing a partial document.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the <code>index</code> or <code>write</code> index privilege for the target index or index alias.
</p>
<p>
The script can update, delete, or skip modifying the document.
The API also supports passing a partial document, which is merged into the existing document.
To fully replace an existing document, use the index API.
This operation:
</p>
<ul><li>
<p>
Gets the document (collocated with the shard) from the index.
</p>
</li><li>
<p>
Runs the specified script.
</p>
</li><li>
<p>
Indexes the result.
</p>
</li></ul>
<p>
The document must still be reindexed, but using this API removes some network roundtrips and reduces chances of version conflicts between the GET and the index operation.
</p>
<p>
The <code>_source</code> field must be enabled to use this API.
In addition to <code>_source</code>, you can access the following variables through the <code>ctx</code> map: <code>_index</code>, <code>_type</code>, <code>_id</code>, <code>_version</code>, <code>_routing</code>, and <code>_now</code> (the current timestamp).
</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.WaitForActiveShards.html">WaitForActiveShards</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.WktGeoBoundsDescriptor.html">WktGeoBoundsDescriptor</a></dt>
      <dd></dd>
    </dl>
    <h3 id="interfaces">
Interfaces
</h3>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.IBulkAllRequest-1.html">IBulkAllRequest&lt;T&gt;</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.IElasticsearchClientSettings.html">IElasticsearchClientSettings</a></dt>
      <dd><p>Provides the connection settings for Elastic.Clients.Elasticsearch's high level <a class="xref" href="Elastic.Clients.Elasticsearch.ElasticsearchClient.html">ElasticsearchClient</a></p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.IIsADictionary.html">IIsADictionary</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.IIsADictionary-2.html">IIsADictionary&lt;TKey, TValue&gt;</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.IIsAReadOnlyDictionary.html">IIsAReadOnlyDictionary</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.IIsAReadOnlyDictionary-2.html">IIsAReadOnlyDictionary&lt;TKey, TValue&gt;</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.IPropertyMappingProvider.html">IPropertyMappingProvider</a></dt>
      <dd><p>Provides mappings for CLR types.</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.TransportClientConfigurationValues.html">TransportClientConfigurationValues</a></dt>
      <dd></dd>
    </dl>
    <h3 id="enums">
Enums
</h3>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ClusterInfoTarget.html">ClusterInfoTarget</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ClusterSearchStatus.html">ClusterSearchStatus</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.Conflicts.html">Conflicts</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.DFIIndependenceMeasure.html">DFIIndependenceMeasure</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.DFRAfterEffect.html">DFRAfterEffect</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.DFRBasicModel.html">DFRBasicModel</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.DateMathOperation.html">DateMathOperation</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.DateMathTimeUnit.html">DateMathTimeUnit</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.DistanceUnit.html">DistanceUnit</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ExpandWildcard.html">ExpandWildcard</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.FieldSortNumericType.html">FieldSortNumericType</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.FieldValue.ValueKind.html">FieldValue.ValueKind</a></dt>
      <dd><p>An enumeration of the possible value kinds that the <a class="xref" href="Elastic.Clients.Elasticsearch.FieldValue.html">FieldValue</a> may contain.</p>
</dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.GeoBounds.Kind.html">GeoBounds.Kind</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.GeoDistanceType.html">GeoDistanceType</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.GeoLocation.Kind.html">GeoLocation.Kind</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.GeoShapeRelation.html">GeoShapeRelation</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.HealthStatus.html">HealthStatus</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.IBDistribution.html">IBDistribution</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.IBLambda.html">IBLambda</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.Level.html">Level</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.LifecycleOperationMode.html">LifecycleOperationMode</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.NodeRole.html">NodeRole</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.Normalization.html">Normalization</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.OpType.html">OpType</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.Refresh.html">Refresh</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.Result.html">Result</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ScriptSortType.html">ScriptSortType</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.SearchType.html">SearchType</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.SlicesCalculation.html">SlicesCalculation</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.SortMode.html">SortMode</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.SortOrder.html">SortOrder</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.SuggestMode.html">SuggestMode</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ThreadType.html">ThreadType</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.TimeUnit.html">TimeUnit</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.UnionTag.html">UnionTag</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.VersionType.html">VersionType</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.WaitForActiveShardOptions.html">WaitForActiveShardOptions</a></dt>
      <dd></dd>
    </dl>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.WaitForEvents.html">WaitForEvents</a></dt>
      <dd></dd>
    </dl>
    <h3 id="delegates">
Delegates
</h3>
    <dl class="jumplist">
      <dt><a class="xref" href="Elastic.Clients.Elasticsearch.ElasticsearchClientSettings.SourceSerializerFactory.html">ElasticsearchClientSettings.SourceSerializerFactory</a></dt>
      <dd><p>A delegate used to construct a serializer to serialize CLR types representing documents and other types related to
documents.
By default, the internal serializer will be used to serializer all types.</p>
</dd>
    </dl>


</article>



      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
