namespace Scripts

open System
open System.Diagnostics
open System.IO
open FSharp.Data 

open Fake 
open Commandline
open SemVerHelper
open Paths

module Versioning = 
    // We used to rely on AssemblyInfo.cs from NEST to read and write the current version.
    // Since that file is now generated by the dotnet tooling and GitVersion and similar tooling all still have
    // active issues related to dotnet core, we now just burn this info in global.json

    //Versions in form of e.g 6.1.0 is inferred as datetime so we bake the json shape into the provider like this
    type private GlobalJson = JsonProvider<""" { "sdk": { "version":"x" }, "version": "x" } """ >
    let globalJson = GlobalJson.Load("../../global.json");
    let writeVersionIntoGlobalJson version = 
        let newGlobalJson = GlobalJson.Root (GlobalJson.Sdk(globalJson.Sdk.Version), version.ToString())
        use tw = new StreamWriter("global.json")
        newGlobalJson.JsonValue.WriteTo(tw, JsonSaveOptions.None)
        tracefn "Written (%s) to global.json as the current version will use this version from now on as current in the build" (version.ToString()) 

    let GlobalJsonVersion = parse(globalJson.Version)

    let CurrentVersion =
        Commandline.parse()
        let currentVersion = GlobalJsonVersion
        let bv = getBuildParam "version"
        let buildVersion = if (isNullOrEmpty bv) then None else Some(parse(bv)) 
        match (getBuildParam "target", buildVersion) with
        | ("release", None) -> failwithf "cannot run release because no explicit version number was passed on the command line"
        | ("release", Some v) -> 
            // Warn if version is same as current version
            if (currentVersion >= v) then traceImportant (sprintf "creating release %s when current version is already at %s" (v.ToString()) (currentVersion.ToString()))
            writeVersionIntoGlobalJson v
            v
        | ("canary", Some v) -> failwithf "cannot run canary release, expected no version number to specified but received %s" (v.ToString())
        | ("canary", None) -> 
            let timestampedVersion = (sprintf "ci%s" (DateTime.UtcNow.ToString("yyyyMMddTHHmmss")))
            tracefn "Canary suffix %s " timestampedVersion
            let canaryVersion = parse ((sprintf "%d.%d.0-%s" currentVersion.Major (currentVersion.Minor + 1) timestampedVersion).Trim())
            tracefn "Canary build increased currentVersion (%s) to (%s) " (currentVersion.ToString()) (canaryVersion.ToString())
            canaryVersion
        | _ -> 
            tracefn "Not running 'release' or 'canary' target so using version in global.json (%s) as current" (currentVersion.ToString())
            currentVersion
    
    let CurrentAssemblyVersion = parse (sprintf "%s.0.0" (CurrentVersion.Major.ToString()))
    let CurrentAssemblyFileVersion = parse (sprintf "%s.%s.%s.0" (CurrentVersion.Major.ToString()) (CurrentVersion.Minor.ToString()) (CurrentVersion.Patch.ToString()))

    let private sn = if isMono then "sn" else Paths.CheckedInTool("sn/sn.exe")
    let private oficialToken = "96c599bbe3e70f5d"

    let private validate dll name = 
        let out = (ExecProcessAndReturnMessages(fun p ->
                    p.FileName <- sn
                    p.Arguments <- sprintf @"-v %s" dll
                  ) (TimeSpan.FromMinutes 5.0))
        
        let valid = (out.ExitCode, out.Messages.FindIndex(fun s -> s.Contains("is valid")))
        match valid with
        | (0, i) when i >= 0 -> trace (sprintf "%s was signed correctly" name) 
        | (_, _) -> failwithf "{0} was not validly signed"
        
        let out = (ExecProcessAndReturnMessages(fun p ->
                    p.FileName <- sn
                    p.Arguments <- sprintf @"-T %s" dll
                  ) (TimeSpan.FromMinutes 5.0))
        
        let tokenMessage = (out.Messages.Find(fun s -> s.Contains("Public key token is")));
        let token = (tokenMessage.Replace("Public key token is", "")).Trim();
    
        let valid = (out.ExitCode, token)
        match valid with
        | (0, t) when t = oficialToken  -> 
          trace (sprintf "%s was signed with official key token %s" name t) 
        | (_, t) -> traceFAKE "%s was not signed with the official token: %s but %s" name oficialToken t
        
    let private validateDllStrongName dll name =
        match fileExists dll with
        | true -> validate dll name 
        | _ -> failwithf "Attemped to verify signature of %s but it was not found!" dll

    let ValidateArtifacts() =
        let fileVersion = CurrentVersion
        let assemblyVersion = parse (sprintf "%i.0.0" fileVersion.Major)
        let tmp = "build/output/_packages/tmp"
        !! "build/output/_packages/*.nupkg"
        |> Seq.iter(fun f -> 
           Unzip tmp f
           !! (sprintf "%s/**/*.dll" tmp)
           |> Seq.iter(fun f -> 
                let fv = FileVersionInfo.GetVersionInfo(f)
                let a = GetAssemblyVersion f
                traceFAKE "Assembly: %A File: %s Product: %s => %s" a fv.FileVersion fv.ProductVersion f
                if (a.Minor > 0 || a.Revision > 0 || a.Build > 0) then failwith (sprintf "%s assembly version is not sticky to its major component" f)
                if (parse (fv.ProductVersion) <> fileVersion) then failwith (sprintf "Expected product info %s to match new version %s " fv.ProductVersion (fileVersion.ToString()))

                validateDllStrongName f f
           )
           DeleteDir tmp
        )