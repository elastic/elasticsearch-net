<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Class ReindexRequest | Elasticsearch.NET </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Class ReindexRequest | Elasticsearch.NET ">
      
      <meta name="description" content="Reindex documents.   Copy documents from a source to a destination. You can copy all documents to the destination index or reindex a subset of the documents. The source can be any existing index, alias, or data stream. The destination must differ from the source. For example, you cannot reindex a data stream into itself.   IMPORTANT: Reindex requires _source to be enabled for all documents in the source. The destination should be configured as wanted before calling the reindex API. Reindex does not copy the settings from the source or its associated template. Mappings, shard counts, and replicas, for example, must be configured ahead of time.   If the Elasticsearch security features are enabled, you must have the following security privileges:    The read index privilege for the source data stream, index, or alias.    The write index privilege for the destination data stream, index, or index alias.    To automatically create a data stream or index with a reindex API request, you must have the auto_configure, create_index, or manage index privilege for the destination data stream, index, or alias.    If reindexing from a remote cluster, the source.remote.user must have the monitor cluster privilege and the read index privilege for the source data stream, index, or alias.    If reindexing from a remote cluster, you must explicitly allow the remote host in the reindex.remote.whitelist setting. Automatic data stream creation requires a matching index template with data stream enabled.   The dest element can be configured like the index API to control optimistic concurrency control. Omitting version_type or setting it to internal causes Elasticsearch to blindly dump documents into the destination, overwriting any that happen to have the same ID.   Setting version_type to external causes Elasticsearch to preserve the version from the source, create any documents that are missing, and update any documents that have an older version in the destination than they do in the source.   Setting op_type to create causes the reindex API to create only missing documents in the destination. All existing documents will cause a version conflict.   IMPORTANT: Because data streams are append-only, any reindex request to a destination data stream must have an op_type of create. A reindex can only add new documents to a destination data stream. It cannot update existing documents in a destination data stream.   By default, version conflicts abort the reindex process. To continue reindexing if there are conflicts, set the conflicts request body property to proceed. In this case, the response includes a count of the version conflicts that were encountered. Note that the handling of other error types is unaffected by the conflicts property. Additionally, if you opt to count version conflicts, the operation could attempt to reindex more documents from the source than max_docs until it has successfully indexed max_docs documents into the target or it has gone through every document in the source query.   NOTE: The reindex API makes no effort to handle ID collisions. The last document written will &quot;win&quot; but the order isn&#39;t usually predictable so it is not a good idea to rely on this behavior. Instead, make sure that IDs are unique by using a script.   Running reindex asynchronously   If the request contains wait_for_completion=false, Elasticsearch performs some preflight checks, launches the request, and returns a task you can use to cancel or get the status of the task. Elasticsearch creates a record of this task as a document at _tasks/&amp;lt;task_id&amp;gt;.   Reindex from multiple sources   If you have many sources to reindex it is generally better to reindex them one at a time rather than using a glob pattern to pick up multiple sources. That way you can resume the process if there are any errors by removing the partially completed source and starting over. It also makes parallelizing the process fairly simple: split the list of sources to reindex and run each list in parallel.   For example, you can use a bash script like this:  for index in i1 i2 i3 i4 i5; do   curl -HContent-Type:application/json -XPOST localhost:9200/_reindex?pretty -d&#39;{     &quot;source&quot;: {       &quot;index&quot;: &quot;&#39;$index&#39;&quot;     },     &quot;dest&quot;: {       &quot;index&quot;: &quot;&#39;$index&#39;-reindexed&quot;     }   }&#39; done  ** Throttling**   Set requests_per_second to any positive decimal number (1.4, 6, 1000, for example) to throttle the rate at which reindex issues batches of index operations. Requests are throttled by padding each batch with a wait time. To turn off throttling, set requests_per_second to -1.   The throttling is done by waiting between batches so that the scroll that reindex uses internally can be given a timeout that takes into account the padding. The padding time is the difference between the batch size divided by the requests_per_second and the time spent writing. By default the batch size is 1000, so if requests_per_second is set to 500:  target_time = 1000 / 500 per second = 2 seconds wait_time = target_time - write_time = 2 seconds - .5 seconds = 1.5 seconds  Since the batch is issued as a single bulk request, large batch sizes cause Elasticsearch to create many requests and then wait for a while before starting the next set. This is &quot;bursty&quot; instead of &quot;smooth&quot;.   Slicing   Reindex supports sliced scroll to parallelize the reindexing process. This parallelization can improve efficiency and provide a convenient way to break the request down into smaller parts.   NOTE: Reindexing from remote clusters does not support manual or automatic slicing.   You can slice a reindex request manually by providing a slice ID and total number of slices to each request. You can also let reindex automatically parallelize by using sliced scroll to slice on _id. The slices parameter specifies the number of slices to use.   Adding slices to the reindex request just automates the manual process, creating sub-requests which means it has some quirks:    You can see these requests in the tasks API. These sub-requests are &quot;child&quot; tasks of the task for the request with slices.    Fetching the status of the task for the request with slices only contains the status of completed slices.    These sub-requests are individually addressable for things like cancellation and rethrottling.    Rethrottling the request with slices will rethrottle the unfinished sub-request proportionally.    Canceling the request with slices will cancel each sub-request.    Due to the nature of slices, each sub-request won&#39;t get a perfectly even portion of the documents. All documents will be addressed, but some slices may be larger than others. Expect larger slices to have a more even distribution.    Parameters like requests_per_second and max_docs on a request with slices are distributed proportionally to each sub-request. Combine that with the previous point about distribution being uneven and you should conclude that using max_docs with slices might not result in exactly max_docs documents being reindexed.    Each sub-request gets a slightly different snapshot of the source, though these are all taken at approximately the same time.    If slicing automatically, setting slices to auto will choose a reasonable number for most indices. If slicing manually or otherwise tuning automatic slicing, use the following guidelines.   Query performance is most efficient when the number of slices is equal to the number of shards in the index. If that number is large (for example, 500), choose a lower number as too many slices will hurt performance. Setting slices higher than the number of shards generally does not improve efficiency and adds overhead.   Indexing performance scales linearly across available resources with the number of slices.   Whether query or indexing performance dominates the runtime depends on the documents being reindexed and cluster resources.   Modify documents during reindexing   Like _update_by_query, reindex operations support a script that modifies the document. Unlike _update_by_query, the script is allowed to modify the document&#39;s metadata.   Just as in _update_by_query, you can set ctx.op to change the operation that is run on the destination. For example, set ctx.op to noop if your script decides that the document doesn’t have to be indexed in the destination. This &quot;no operation&quot; will be reported in the noop counter in the response body. Set ctx.op to delete if your script decides that the document must be deleted from the destination. The deletion will be reported in the deleted counter in the response body. Setting ctx.op to anything else will return an error, as will setting any other field in ctx.   Think of the possibilities! Just be careful; you are able to change:    _id    _index    _version    _routing    Setting _version to null or clearing it from the ctx map is just like not sending the version in an indexing request. It will cause the document to be overwritten in the destination regardless of the version on the target or the version type you use in the reindex API.   Reindex from remote   Reindex supports reindexing from a remote Elasticsearch cluster. The host parameter must contain a scheme, host, port, and optional path. The username and password parameters are optional and when they are present the reindex operation will connect to the remote Elasticsearch node using basic authentication. Be sure to use HTTPS when using basic authentication or the password will be sent in plain text. There are a range of settings available to configure the behavior of the HTTPS connection.   When using Elastic Cloud, it is also possible to authenticate against the remote cluster through the use of a valid API key. Remote hosts must be explicitly allowed with the reindex.remote.whitelist setting. It can be set to a comma delimited list of allowed remote host and port combinations. Scheme is ignored; only the host and port are used. For example:  reindex.remote.whitelist: [otherhost:9200, another:9200, 127.0.10.*:9200, localhost:*&quot;]  The list of allowed hosts must be configured on any nodes that will coordinate the reindex. This feature should work with remote clusters of any version of Elasticsearch. This should enable you to upgrade from any version of Elasticsearch to the current version by reindexing from a cluster of the old version.   WARNING: Elasticsearch does not support forward compatibility across major versions. For example, you cannot reindex from a 7.x cluster into a 6.x cluster.   To enable queries sent to older versions of Elasticsearch, the query parameter is sent directly to the remote host without validation or modification.   NOTE: Reindexing from remote clusters does not support manual or automatic slicing.   Reindexing from a remote server uses an on-heap buffer that defaults to a maximum size of 100mb. If the remote index includes very large documents you&#39;ll need to use a smaller batch size. It is also possible to set the socket read timeout on the remote connection with the socket_timeout field and the connection timeout with the connect_timeout field. Both default to 30 seconds.   Configuring SSL parameters   Reindex from remote supports configurable SSL settings. These must be specified in the elasticsearch.yml file, with the exception of the secure settings, which you add in the Elasticsearch keystore. It is not possible to configure SSL in the body of the reindex request.">
      <link rel="icon" href="../favicon.ico">
      <link rel="stylesheet" href="../public/docfx.min.css">
      <link rel="stylesheet" href="../public/main.css">
      <meta name="docfx:navrel" content="../toc.html">
      <meta name="docfx:tocrel" content="toc.html">
      
      <meta name="docfx:rel" content="../">
      
      
      <meta name="docfx:docurl" content="https://github.com/elastic/elasticsearch-net/new/8.17.4/apiSpec/new?filename=Elastic_Clients_Elasticsearch_ReindexRequest.md&amp;value=---%0Auid%3A%20Elastic.Clients.Elasticsearch.ReindexRequest%0Asummary%3A%20&#39;*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax&#39;%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="ManagedReference">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../index.html">
            <img id="logo" class="svg" src="../images/logo.svg" alt="Elasticsearch.NET">
            Elasticsearch.NET
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="Elastic.Clients.Elasticsearch.ReindexRequest">



  <h1 id="Elastic_Clients_Elasticsearch_ReindexRequest" data-uid="Elastic.Clients.Elasticsearch.ReindexRequest" class="text-break">
Class ReindexRequest  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.17.4/src/Elastic.Clients.Elasticsearch/_Generated/Api/ReindexRequest.g.cs/#L403"><i class="bi bi-code-slash"></i></a>
  </h1>

  <div class="facts text-secondary">
    <dl><dt>Namespace</dt><dd><a class="xref" href="Elastic.html">Elastic</a>.<a class="xref" href="Elastic.Clients.html">Clients</a>.<a class="xref" href="Elastic.Clients.Elasticsearch.html">Elasticsearch</a></dd></dl>
  <dl><dt>Assembly</dt><dd>Elastic.Clients.Elasticsearch.dll</dd></dl>
  </div>

  <div class="markdown summary"><p>
Reindex documents.
</p>
<p>
Copy documents from a source to a destination.
You can copy all documents to the destination index or reindex a subset of the documents.
The source can be any existing index, alias, or data stream.
The destination must differ from the source.
For example, you cannot reindex a data stream into itself.
</p>
<p>
IMPORTANT: Reindex requires <code>_source</code> to be enabled for all documents in the source.
The destination should be configured as wanted before calling the reindex API.
Reindex does not copy the settings from the source or its associated template.
Mappings, shard counts, and replicas, for example, must be configured ahead of time.
</p>
<p>
If the Elasticsearch security features are enabled, you must have the following security privileges:
</p>
<ul><li>
<p>
The <code>read</code> index privilege for the source data stream, index, or alias.
</p>
</li><li>
<p>
The <code>write</code> index privilege for the destination data stream, index, or index alias.
</p>
</li><li>
<p>
To automatically create a data stream or index with a reindex API request, you must have the <code>auto_configure</code>, <code>create_index</code>, or <code>manage</code> index privilege for the destination data stream, index, or alias.
</p>
</li><li>
<p>
If reindexing from a remote cluster, the <code>source.remote.user</code> must have the <code>monitor</code> cluster privilege and the <code>read</code> index privilege for the source data stream, index, or alias.
</p>
</li></ul>
<p>
If reindexing from a remote cluster, you must explicitly allow the remote host in the <code>reindex.remote.whitelist</code> setting.
Automatic data stream creation requires a matching index template with data stream enabled.
</p>
<p>
The <code>dest</code> element can be configured like the index API to control optimistic concurrency control.
Omitting <code>version_type</code> or setting it to <code>internal</code> causes Elasticsearch to blindly dump documents into the destination, overwriting any that happen to have the same ID.
</p>
<p>
Setting <code>version_type</code> to <code>external</code> causes Elasticsearch to preserve the <code>version</code> from the source, create any documents that are missing, and update any documents that have an older version in the destination than they do in the source.
</p>
<p>
Setting <code>op_type</code> to <code>create</code> causes the reindex API to create only missing documents in the destination.
All existing documents will cause a version conflict.
</p>
<p>
IMPORTANT: Because data streams are append-only, any reindex request to a destination data stream must have an <code>op_type</code> of <code>create</code>.
A reindex can only add new documents to a destination data stream.
It cannot update existing documents in a destination data stream.
</p>
<p>
By default, version conflicts abort the reindex process.
To continue reindexing if there are conflicts, set the <code>conflicts</code> request body property to <code>proceed</code>.
In this case, the response includes a count of the version conflicts that were encountered.
Note that the handling of other error types is unaffected by the <code>conflicts</code> property.
Additionally, if you opt to count version conflicts, the operation could attempt to reindex more documents from the source than <code>max_docs</code> until it has successfully indexed <code>max_docs</code> documents into the target or it has gone through every document in the source query.
</p>
<p>
NOTE: The reindex API makes no effort to handle ID collisions.
The last document written will "win" but the order isn't usually predictable so it is not a good idea to rely on this behavior.
Instead, make sure that IDs are unique by using a script.
</p>
<p>
<strong>Running reindex asynchronously</strong>
</p>
<p>
If the request contains <code>wait_for_completion=false</code>, Elasticsearch performs some preflight checks, launches the request, and returns a task you can use to cancel or get the status of the task.
Elasticsearch creates a record of this task as a document at <code>_tasks/&lt;task_id&gt;</code>.
</p>
<p>
<strong>Reindex from multiple sources</strong>
</p>
<p>
If you have many sources to reindex it is generally better to reindex them one at a time rather than using a glob pattern to pick up multiple sources.
That way you can resume the process if there are any errors by removing the partially completed source and starting over.
It also makes parallelizing the process fairly simple: split the list of sources to reindex and run each list in parallel.
</p>
<p>
For example, you can use a bash script like this:
</p>
<pre><code class="lang-csharp">for index in i1 i2 i3 i4 i5; do
  curl -HContent-Type:application/json -XPOST localhost:9200/_reindex?pretty -d'{
    "source": {
      "index": "'$index'"
    },
    "dest": {
      "index": "'$index'-reindexed"
    }
  }'
done</code></pre>
<p>
** Throttling**
</p>
<p>
Set <code>requests_per_second</code> to any positive decimal number (<code>1.4</code>, <code>6</code>, <code>1000</code>, for example) to throttle the rate at which reindex issues batches of index operations.
Requests are throttled by padding each batch with a wait time.
To turn off throttling, set <code>requests_per_second</code> to <code>-1</code>.
</p>
<p>
The throttling is done by waiting between batches so that the scroll that reindex uses internally can be given a timeout that takes into account the padding.
The padding time is the difference between the batch size divided by the <code>requests_per_second</code> and the time spent writing.
By default the batch size is <code>1000</code>, so if <code>requests_per_second</code> is set to <code>500</code>:
</p>
<pre><code class="lang-csharp">target_time = 1000 / 500 per second = 2 seconds
wait_time = target_time - write_time = 2 seconds - .5 seconds = 1.5 seconds</code></pre>
<p>
Since the batch is issued as a single bulk request, large batch sizes cause Elasticsearch to create many requests and then wait for a while before starting the next set.
This is "bursty" instead of "smooth".
</p>
<p>
<strong>Slicing</strong>
</p>
<p>
Reindex supports sliced scroll to parallelize the reindexing process.
This parallelization can improve efficiency and provide a convenient way to break the request down into smaller parts.
</p>
<p>
NOTE: Reindexing from remote clusters does not support manual or automatic slicing.
</p>
<p>
You can slice a reindex request manually by providing a slice ID and total number of slices to each request.
You can also let reindex automatically parallelize by using sliced scroll to slice on <code>_id</code>.
The <code>slices</code> parameter specifies the number of slices to use.
</p>
<p>
Adding <code>slices</code> to the reindex request just automates the manual process, creating sub-requests which means it has some quirks:
</p>
<ul><li>
<p>
You can see these requests in the tasks API. These sub-requests are "child" tasks of the task for the request with slices.
</p>
</li><li>
<p>
Fetching the status of the task for the request with <code>slices</code> only contains the status of completed slices.
</p>
</li><li>
<p>
These sub-requests are individually addressable for things like cancellation and rethrottling.
</p>
</li><li>
<p>
Rethrottling the request with <code>slices</code> will rethrottle the unfinished sub-request proportionally.
</p>
</li><li>
<p>
Canceling the request with <code>slices</code> will cancel each sub-request.
</p>
</li><li>
<p>
Due to the nature of <code>slices</code>, each sub-request won't get a perfectly even portion of the documents. All documents will be addressed, but some slices may be larger than others. Expect larger slices to have a more even distribution.
</p>
</li><li>
<p>
Parameters like <code>requests_per_second</code> and <code>max_docs</code> on a request with <code>slices</code> are distributed proportionally to each sub-request. Combine that with the previous point about distribution being uneven and you should conclude that using <code>max_docs</code> with <code>slices</code> might not result in exactly <code>max_docs</code> documents being reindexed.
</p>
</li><li>
<p>
Each sub-request gets a slightly different snapshot of the source, though these are all taken at approximately the same time.
</p>
</li></ul>
<p>
If slicing automatically, setting <code>slices</code> to <code>auto</code> will choose a reasonable number for most indices.
If slicing manually or otherwise tuning automatic slicing, use the following guidelines.
</p>
<p>
Query performance is most efficient when the number of slices is equal to the number of shards in the index.
If that number is large (for example, <code>500</code>), choose a lower number as too many slices will hurt performance.
Setting slices higher than the number of shards generally does not improve efficiency and adds overhead.
</p>
<p>
Indexing performance scales linearly across available resources with the number of slices.
</p>
<p>
Whether query or indexing performance dominates the runtime depends on the documents being reindexed and cluster resources.
</p>
<p>
<strong>Modify documents during reindexing</strong>
</p>
<p>
Like <code>_update_by_query</code>, reindex operations support a script that modifies the document.
Unlike <code>_update_by_query</code>, the script is allowed to modify the document's metadata.
</p>
<p>
Just as in <code>_update_by_query</code>, you can set <code>ctx.op</code> to change the operation that is run on the destination.
For example, set <code>ctx.op</code> to <code>noop</code> if your script decides that the document doesn’t have to be indexed in the destination. This "no operation" will be reported in the <code>noop</code> counter in the response body.
Set <code>ctx.op</code> to <code>delete</code> if your script decides that the document must be deleted from the destination.
The deletion will be reported in the <code>deleted</code> counter in the response body.
Setting <code>ctx.op</code> to anything else will return an error, as will setting any other field in <code>ctx</code>.
</p>
<p>
Think of the possibilities! Just be careful; you are able to change:
</p>
<ul><li>
<p>
<code>_id</code>
</p>
</li><li>
<p>
<code>_index</code>
</p>
</li><li>
<p>
<code>_version</code>
</p>
</li><li>
<p>
<code>_routing</code>
</p>
</li></ul>
<p>
Setting <code>_version</code> to <code>null</code> or clearing it from the <code>ctx</code> map is just like not sending the version in an indexing request.
It will cause the document to be overwritten in the destination regardless of the version on the target or the version type you use in the reindex API.
</p>
<p>
<strong>Reindex from remote</strong>
</p>
<p>
Reindex supports reindexing from a remote Elasticsearch cluster.
The <code>host</code> parameter must contain a scheme, host, port, and optional path.
The <code>username</code> and <code>password</code> parameters are optional and when they are present the reindex operation will connect to the remote Elasticsearch node using basic authentication.
Be sure to use HTTPS when using basic authentication or the password will be sent in plain text.
There are a range of settings available to configure the behavior of the HTTPS connection.
</p>
<p>
When using Elastic Cloud, it is also possible to authenticate against the remote cluster through the use of a valid API key.
Remote hosts must be explicitly allowed with the <code>reindex.remote.whitelist</code> setting.
It can be set to a comma delimited list of allowed remote host and port combinations.
Scheme is ignored; only the host and port are used.
For example:
</p>
<pre><code class="lang-csharp">reindex.remote.whitelist: [otherhost:9200, another:9200, 127.0.10.*:9200, localhost:*"]</code></pre>
<p>
The list of allowed hosts must be configured on any nodes that will coordinate the reindex.
This feature should work with remote clusters of any version of Elasticsearch.
This should enable you to upgrade from any version of Elasticsearch to the current version by reindexing from a cluster of the old version.
</p>
<p>
WARNING: Elasticsearch does not support forward compatibility across major versions.
For example, you cannot reindex from a 7.x cluster into a 6.x cluster.
</p>
<p>
To enable queries sent to older versions of Elasticsearch, the <code>query</code> parameter is sent directly to the remote host without validation or modification.
</p>
<p>
NOTE: Reindexing from remote clusters does not support manual or automatic slicing.
</p>
<p>
Reindexing from a remote server uses an on-heap buffer that defaults to a maximum size of 100mb.
If the remote index includes very large documents you'll need to use a smaller batch size.
It is also possible to set the socket read timeout on the remote connection with the <code>socket_timeout</code> field and the connection timeout with the <code>connect_timeout</code> field.
Both default to 30 seconds.
</p>
<p>
<strong>Configuring SSL parameters</strong>
</p>
<p>
Reindex from remote supports configurable SSL settings.
These must be specified in the <code>elasticsearch.yml</code> file, with the exception of the secure settings, which you add in the Elasticsearch keystore.
It is not possible to configure SSL in the body of the reindex request.
</p>
</div>
  <div class="markdown conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public sealed class ReindexRequest : PlainRequest&lt;ReindexRequestParameters&gt;</code></pre>
  </div>




  <dl class="typelist inheritance">
    <dt>Inheritance</dt>
    <dd>
      <div><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.object">object</a></div>
      <div><a class="xref" href="Elastic.Clients.Elasticsearch.Requests.Request.html">Request</a></div>
      <div><a class="xref" href="Elastic.Clients.Elasticsearch.Requests.Request-1.html">Request</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ReindexRequestParameters.html">ReindexRequestParameters</a>&gt;</div>
      <div><a class="xref" href="Elastic.Clients.Elasticsearch.Requests.PlainRequest-1.html">PlainRequest</a>&lt;<a class="xref" href="Elastic.Clients.Elasticsearch.ReindexRequestParameters.html">ReindexRequestParameters</a>&gt;</div>
      <div><span class="xref">ReindexRequest</span></div>
    </dd>
  </dl>



  <dl class="typelist inheritedMembers">
    <dt>Inherited Members</dt>
    <dd>
    <div>
      <a class="xref" href="Elastic.Clients.Elasticsearch.Requests.PlainRequest-1.html#Elastic_Clients_Elasticsearch_Requests_PlainRequest_1_ErrorTrace">PlainRequest&lt;ReindexRequestParameters&gt;.ErrorTrace</a>
    </div>
    <div>
      <a class="xref" href="Elastic.Clients.Elasticsearch.Requests.PlainRequest-1.html#Elastic_Clients_Elasticsearch_Requests_PlainRequest_1_FilterPath">PlainRequest&lt;ReindexRequestParameters&gt;.FilterPath</a>
    </div>
    <div>
      <a class="xref" href="Elastic.Clients.Elasticsearch.Requests.PlainRequest-1.html#Elastic_Clients_Elasticsearch_Requests_PlainRequest_1_Human">PlainRequest&lt;ReindexRequestParameters&gt;.Human</a>
    </div>
    <div>
      <a class="xref" href="Elastic.Clients.Elasticsearch.Requests.PlainRequest-1.html#Elastic_Clients_Elasticsearch_Requests_PlainRequest_1_Pretty">PlainRequest&lt;ReindexRequestParameters&gt;.Pretty</a>
    </div>
    <div>
      <a class="xref" href="Elastic.Clients.Elasticsearch.Requests.PlainRequest-1.html#Elastic_Clients_Elasticsearch_Requests_PlainRequest_1_SourceQueryString">PlainRequest&lt;ReindexRequestParameters&gt;.SourceQueryString</a>
    </div>
    <div>
      <a class="xref" href="Elastic.Clients.Elasticsearch.Requests.PlainRequest-1.html#Elastic_Clients_Elasticsearch_Requests_PlainRequest_1_RequestConfiguration">PlainRequest&lt;ReindexRequestParameters&gt;.RequestConfiguration</a>
    </div>
    <div>
      <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.object.equals#system-object-equals(system-object)">object.Equals(object)</a>
    </div>
    <div>
      <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.object.equals#system-object-equals(system-object-system-object)">object.Equals(object, object)</a>
    </div>
    <div>
      <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.object.gethashcode">object.GetHashCode()</a>
    </div>
    <div>
      <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.object.gettype">object.GetType()</a>
    </div>
    <div>
      <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.object.referenceequals">object.ReferenceEquals(object, object)</a>
    </div>
    <div>
      <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.object.tostring">object.ToString()</a>
    </div>
  </dd></dl>

  <dl class="typelist extensionMethods">
    <dt>Extension Methods</dt>
    <dd>
  <div>
      <a class="xref" href="Elastic.Clients.Elasticsearch.SuffixExtensions.html#Elastic_Clients_Elasticsearch_SuffixExtensions_Suffix_System_Object_System_String_">SuffixExtensions.Suffix(object, string)</a>
  </div>
  </dd></dl>





  <h2 class="section" id="properties">Properties
</h2>


  <a id="Elastic_Clients_Elasticsearch_ReindexRequest_Conflicts_" data-uid="Elastic.Clients.Elasticsearch.ReindexRequest.Conflicts*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ReindexRequest_Conflicts" data-uid="Elastic.Clients.Elasticsearch.ReindexRequest.Conflicts">
  Conflicts
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.17.4/src/Elastic.Clients.Elasticsearch/_Generated/Api/ReindexRequest.g.cs/#L500"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
Indicates whether to continue reindexing even when there are conflicts.
</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[JsonInclude]
[JsonPropertyName(&quot;conflicts&quot;)]
public Conflicts? Conflicts { get; set; }</code></pre>
  </div>





  <h4 class="section">Property Value</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.Conflicts.html">Conflicts</a>?</dt>
    <dd></dd>
  </dl>








  <a id="Elastic_Clients_Elasticsearch_ReindexRequest_Dest_" data-uid="Elastic.Clients.Elasticsearch.ReindexRequest.Dest*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ReindexRequest_Dest" data-uid="Elastic.Clients.Elasticsearch.ReindexRequest.Dest">
  Dest
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.17.4/src/Elastic.Clients.Elasticsearch/_Generated/Api/ReindexRequest.g.cs/#L508"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
The destination you are copying to.
</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[JsonInclude]
[JsonPropertyName(&quot;dest&quot;)]
public Destination Dest { get; set; }</code></pre>
  </div>





  <h4 class="section">Property Value</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.Core.Reindex.Destination.html">Destination</a></dt>
    <dd></dd>
  </dl>








  <a id="Elastic_Clients_Elasticsearch_ReindexRequest_MaxDocs_" data-uid="Elastic.Clients.Elasticsearch.ReindexRequest.MaxDocs*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ReindexRequest_MaxDocs" data-uid="Elastic.Clients.Elasticsearch.ReindexRequest.MaxDocs">
  MaxDocs
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.17.4/src/Elastic.Clients.Elasticsearch/_Generated/Api/ReindexRequest.g.cs/#L521"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
The maximum number of documents to reindex.
By default, all documents are reindexed.
If it is a value less then or equal to <code>scroll_size</code>, a scroll will not be used to retrieve the results for the operation.
</p>
<p>
If <code>conflicts</code> is set to <code>proceed</code>, the reindex operation could attempt to reindex more documents from the source than <code>max_docs</code> until it has successfully indexed <code>max_docs</code> documents into the target or it has gone through every document in the source query.
</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[JsonInclude]
[JsonPropertyName(&quot;max_docs&quot;)]
public long? MaxDocs { get; set; }</code></pre>
  </div>





  <h4 class="section">Property Value</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int64">long</a>?</dt>
    <dd></dd>
  </dl>








  <a id="Elastic_Clients_Elasticsearch_ReindexRequest_Refresh_" data-uid="Elastic.Clients.Elasticsearch.ReindexRequest.Refresh*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ReindexRequest_Refresh" data-uid="Elastic.Clients.Elasticsearch.ReindexRequest.Refresh">
  Refresh
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.17.4/src/Elastic.Clients.Elasticsearch/_Generated/Api/ReindexRequest.g.cs/#L418"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
If <code>true</code>, the request refreshes affected shards to make this operation visible to search.
</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[JsonIgnore]
public bool? Refresh { get; set; }</code></pre>
  </div>





  <h4 class="section">Property Value</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.boolean">bool</a>?</dt>
    <dd></dd>
  </dl>








  <a id="Elastic_Clients_Elasticsearch_ReindexRequest_RequestsPerSecond_" data-uid="Elastic.Clients.Elasticsearch.ReindexRequest.RequestsPerSecond*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ReindexRequest_RequestsPerSecond" data-uid="Elastic.Clients.Elasticsearch.ReindexRequest.RequestsPerSecond">
  RequestsPerSecond
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.17.4/src/Elastic.Clients.Elasticsearch/_Generated/Api/ReindexRequest.g.cs/#L427"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
The throttle for this request in sub-requests per second.
By default, there is no throttle.
</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[JsonIgnore]
public float? RequestsPerSecond { get; set; }</code></pre>
  </div>





  <h4 class="section">Property Value</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.single">float</a>?</dt>
    <dd></dd>
  </dl>








  <a id="Elastic_Clients_Elasticsearch_ReindexRequest_RequireAlias_" data-uid="Elastic.Clients.Elasticsearch.ReindexRequest.RequireAlias*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ReindexRequest_RequireAlias" data-uid="Elastic.Clients.Elasticsearch.ReindexRequest.RequireAlias">
  RequireAlias
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.17.4/src/Elastic.Clients.Elasticsearch/_Generated/Api/ReindexRequest.g.cs/#L435"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
If <code>true</code>, the destination must be an index alias.
</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[JsonIgnore]
public bool? RequireAlias { get; set; }</code></pre>
  </div>





  <h4 class="section">Property Value</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.boolean">bool</a>?</dt>
    <dd></dd>
  </dl>








  <a id="Elastic_Clients_Elasticsearch_ReindexRequest_Script_" data-uid="Elastic.Clients.Elasticsearch.ReindexRequest.Script*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ReindexRequest_Script" data-uid="Elastic.Clients.Elasticsearch.ReindexRequest.Script">
  Script
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.17.4/src/Elastic.Clients.Elasticsearch/_Generated/Api/ReindexRequest.g.cs/#L529"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
The script to run to update the document source or metadata when reindexing.
</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[JsonInclude]
[JsonPropertyName(&quot;script&quot;)]
public Script? Script { get; set; }</code></pre>
  </div>





  <h4 class="section">Property Value</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.Script.html">Script</a></dt>
    <dd></dd>
  </dl>








  <a id="Elastic_Clients_Elasticsearch_ReindexRequest_Scroll_" data-uid="Elastic.Clients.Elasticsearch.ReindexRequest.Scroll*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ReindexRequest_Scroll" data-uid="Elastic.Clients.Elasticsearch.ReindexRequest.Scroll">
  Scroll
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.17.4/src/Elastic.Clients.Elasticsearch/_Generated/Api/ReindexRequest.g.cs/#L443"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
The period of time that a consistent view of the index should be maintained for scrolled search.
</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[JsonIgnore]
public Duration? Scroll { get; set; }</code></pre>
  </div>





  <h4 class="section">Property Value</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.Duration.html">Duration</a></dt>
    <dd></dd>
  </dl>








  <a id="Elastic_Clients_Elasticsearch_ReindexRequest_Size_" data-uid="Elastic.Clients.Elasticsearch.ReindexRequest.Size*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ReindexRequest_Size" data-uid="Elastic.Clients.Elasticsearch.ReindexRequest.Size">
  Size
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.17.4/src/Elastic.Clients.Elasticsearch/_Generated/Api/ReindexRequest.g.cs/#L531"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"></div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[JsonInclude]
[JsonPropertyName(&quot;size&quot;)]
public long? Size { get; set; }</code></pre>
  </div>





  <h4 class="section">Property Value</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int64">long</a>?</dt>
    <dd></dd>
  </dl>








  <a id="Elastic_Clients_Elasticsearch_ReindexRequest_Slices_" data-uid="Elastic.Clients.Elasticsearch.ReindexRequest.Slices*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ReindexRequest_Slices" data-uid="Elastic.Clients.Elasticsearch.ReindexRequest.Slices">
  Slices
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.17.4/src/Elastic.Clients.Elasticsearch/_Generated/Api/ReindexRequest.g.cs/#L464"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
The number of slices this task should be divided into.
It defaults to one slice, which means the task isn't sliced into subtasks.
</p>
<p>
Reindex supports sliced scroll to parallelize the reindexing process.
This parallelization can improve efficiency and provide a convenient way to break the request down into smaller parts.
</p>
<p>
NOTE: Reindexing from remote clusters does not support manual or automatic slicing.
</p>
<p>
If set to <code>auto</code>, Elasticsearch chooses the number of slices to use.
This setting will use one slice per shard, up to a certain limit.
If there are multiple sources, it will choose the number of slices based on the index or backing index with the smallest number of shards.
</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[JsonIgnore]
public Slices? Slices { get; set; }</code></pre>
  </div>





  <h4 class="section">Property Value</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.Slices.html">Slices</a></dt>
    <dd></dd>
  </dl>








  <a id="Elastic_Clients_Elasticsearch_ReindexRequest_Source_" data-uid="Elastic.Clients.Elasticsearch.ReindexRequest.Source*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ReindexRequest_Source" data-uid="Elastic.Clients.Elasticsearch.ReindexRequest.Source">
  Source
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.17.4/src/Elastic.Clients.Elasticsearch/_Generated/Api/ReindexRequest.g.cs/#L539"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
The source you are copying from.
</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[JsonInclude]
[JsonPropertyName(&quot;source&quot;)]
public Source Source { get; set; }</code></pre>
  </div>





  <h4 class="section">Property Value</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.Core.Reindex.Source.html">Source</a></dt>
    <dd></dd>
  </dl>








  <a id="Elastic_Clients_Elasticsearch_ReindexRequest_StaticHttpMethod_" data-uid="Elastic.Clients.Elasticsearch.ReindexRequest.StaticHttpMethod*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ReindexRequest_StaticHttpMethod" data-uid="Elastic.Clients.Elasticsearch.ReindexRequest.StaticHttpMethod">
  StaticHttpMethod
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.17.4/src/Elastic.Clients.Elasticsearch/_Generated/Api/ReindexRequest.g.cs/#L407"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>The default HTTP method for the request which is based on the Elasticsearch Specification endpoint definition.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">protected override HttpMethod StaticHttpMethod { get; }</code></pre>
  </div>





  <h4 class="section">Property Value</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://github.com/elastic/elastic-transport-net/blob/8.17.4/src/Elastic.Transport/Components/TransportClient/HttpMethod.cs">HttpMethod</a></dt>
    <dd></dd>
  </dl>








  <a id="Elastic_Clients_Elasticsearch_ReindexRequest_Timeout_" data-uid="Elastic.Clients.Elasticsearch.ReindexRequest.Timeout*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ReindexRequest_Timeout" data-uid="Elastic.Clients.Elasticsearch.ReindexRequest.Timeout">
  Timeout
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.17.4/src/Elastic.Clients.Elasticsearch/_Generated/Api/ReindexRequest.g.cs/#L474"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
The period each indexing waits for automatic index creation, dynamic mapping updates, and waiting for active shards.
By default, Elasticsearch waits for at least one minute before failing.
The actual wait time could be longer, particularly when multiple waits occur.
</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[JsonIgnore]
public Duration? Timeout { get; set; }</code></pre>
  </div>





  <h4 class="section">Property Value</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.Duration.html">Duration</a></dt>
    <dd></dd>
  </dl>








  <a id="Elastic_Clients_Elasticsearch_ReindexRequest_WaitForActiveShards_" data-uid="Elastic.Clients.Elasticsearch.ReindexRequest.WaitForActiveShards*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ReindexRequest_WaitForActiveShards" data-uid="Elastic.Clients.Elasticsearch.ReindexRequest.WaitForActiveShards">
  WaitForActiveShards
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.17.4/src/Elastic.Clients.Elasticsearch/_Generated/Api/ReindexRequest.g.cs/#L484"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
The number of shard copies that must be active before proceeding with the operation.
Set it to <code>all</code> or any positive integer up to the total number of shards in the index (<code>number_of_replicas+1</code>).
The default value is one, which means it waits for each primary shard to be active.
</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[JsonIgnore]
public WaitForActiveShards? WaitForActiveShards { get; set; }</code></pre>
  </div>





  <h4 class="section">Property Value</h4>
  <dl class="parameters">
    <dt><a class="xref" href="Elastic.Clients.Elasticsearch.WaitForActiveShards.html">WaitForActiveShards</a>?</dt>
    <dd></dd>
  </dl>








  <a id="Elastic_Clients_Elasticsearch_ReindexRequest_WaitForCompletion_" data-uid="Elastic.Clients.Elasticsearch.ReindexRequest.WaitForCompletion*"></a>

  <h3 id="Elastic_Clients_Elasticsearch_ReindexRequest_WaitForCompletion" data-uid="Elastic.Clients.Elasticsearch.ReindexRequest.WaitForCompletion">
  WaitForCompletion
  <a class="header-action link-secondary" title="View source" href="https://github.com/elastic/elasticsearch-net/blob/8.17.4/src/Elastic.Clients.Elasticsearch/_Generated/Api/ReindexRequest.g.cs/#L492"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>
If <code>true</code>, the request blocks until the operation is complete.
</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[JsonIgnore]
public bool? WaitForCompletion { get; set; }</code></pre>
  </div>





  <h4 class="section">Property Value</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.boolean">bool</a>?</dt>
    <dd></dd>
  </dl>









</article>



      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
