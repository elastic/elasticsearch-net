// Licensed to Elasticsearch B.V under one or more agreements.
// Elasticsearch B.V licenses this file to you under the Apache 2.0 License.
// See the LICENSE file in the project root for more information.
//
// ███╗   ██╗ ██████╗ ████████╗██╗ ██████╗███████╗
// ████╗  ██║██╔═══██╗╚══██╔══╝██║██╔════╝██╔════╝
// ██╔██╗ ██║██║   ██║   ██║   ██║██║     █████╗
// ██║╚██╗██║██║   ██║   ██║   ██║██║     ██╔══╝
// ██║ ╚████║╚██████╔╝   ██║   ██║╚██████╗███████╗
// ╚═╝  ╚═══╝ ╚═════╝    ╚═╝   ╚═╝ ╚═════╝╚══════╝
// ------------------------------------------------
//
// This file is automatically generated.
// Please do not edit these files manually.
//
// ------------------------------------------------

#nullable restore

using Elastic.Clients.Elasticsearch.Serverless.Core;
using Elastic.Clients.Elasticsearch.Serverless.Serialization;
using Elastic.Transport;
using System;
using System.Runtime.Serialization;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace Elastic.Clients.Elasticsearch.Serverless.Aggregations;

[JsonConverter(typeof(CalendarIntervalConverter))]
public enum CalendarInterval
{
	[EnumMember(Value = "year")]
	Year,
	[EnumMember(Value = "week")]
	Week,
	[EnumMember(Value = "second")]
	Second,
	[EnumMember(Value = "quarter")]
	Quarter,
	[EnumMember(Value = "month")]
	Month,
	[EnumMember(Value = "minute")]
	Minute,
	[EnumMember(Value = "hour")]
	Hour,
	[EnumMember(Value = "day")]
	Day
}

internal sealed class CalendarIntervalConverter : JsonConverter<CalendarInterval>
{
	public override CalendarInterval Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
	{
		var enumString = reader.GetString();
		switch (enumString)
		{
			case "year":
			case "1y":
				return CalendarInterval.Year;
			case "week":
			case "1w":
				return CalendarInterval.Week;
			case "second":
			case "1s":
				return CalendarInterval.Second;
			case "quarter":
			case "1q":
				return CalendarInterval.Quarter;
			case "month":
			case "1M":
				return CalendarInterval.Month;
			case "minute":
			case "1m":
				return CalendarInterval.Minute;
			case "hour":
			case "1h":
				return CalendarInterval.Hour;
			case "day":
			case "1d":
				return CalendarInterval.Day;
		}

		ThrowHelper.ThrowJsonException();
		return default;
	}

	public override void Write(Utf8JsonWriter writer, CalendarInterval value, JsonSerializerOptions options)
	{
		switch (value)
		{
			case CalendarInterval.Year:
				writer.WriteStringValue("year");
				return;
			case CalendarInterval.Week:
				writer.WriteStringValue("week");
				return;
			case CalendarInterval.Second:
				writer.WriteStringValue("second");
				return;
			case CalendarInterval.Quarter:
				writer.WriteStringValue("quarter");
				return;
			case CalendarInterval.Month:
				writer.WriteStringValue("month");
				return;
			case CalendarInterval.Minute:
				writer.WriteStringValue("minute");
				return;
			case CalendarInterval.Hour:
				writer.WriteStringValue("hour");
				return;
			case CalendarInterval.Day:
				writer.WriteStringValue("day");
				return;
		}

		writer.WriteNullValue();
	}
}

[JsonConverter(typeof(CardinalityExecutionModeConverter))]
public enum CardinalityExecutionMode
{
	/// <summary>
	/// <para>Run the aggregation by using segment ordinal values and resolving those values after each segment.</para>
	/// </summary>
	[EnumMember(Value = "segment_ordinals")]
	SegmentOrdinals,
	/// <summary>
	/// <para>Heuristic-based mode, default in Elasticsearch 8.4 and later.</para>
	/// </summary>
	[EnumMember(Value = "save_time_heuristic")]
	SaveTimeHeuristic,
	/// <summary>
	/// <para>Heuristic-based mode, default in Elasticsearch 8.3 and earlier.</para>
	/// </summary>
	[EnumMember(Value = "save_memory_heuristic")]
	SaveMemoryHeuristic,
	/// <summary>
	/// <para>Run the aggregation by using global ordinals of the field and resolving those values after finishing a shard.</para>
	/// </summary>
	[EnumMember(Value = "global_ordinals")]
	GlobalOrdinals,
	/// <summary>
	/// <para>Run the aggregation by using field values directly.</para>
	/// </summary>
	[EnumMember(Value = "direct")]
	Direct
}

internal sealed class CardinalityExecutionModeConverter : JsonConverter<CardinalityExecutionMode>
{
	public override CardinalityExecutionMode Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
	{
		var enumString = reader.GetString();
		switch (enumString)
		{
			case "segment_ordinals":
				return CardinalityExecutionMode.SegmentOrdinals;
			case "save_time_heuristic":
				return CardinalityExecutionMode.SaveTimeHeuristic;
			case "save_memory_heuristic":
				return CardinalityExecutionMode.SaveMemoryHeuristic;
			case "global_ordinals":
				return CardinalityExecutionMode.GlobalOrdinals;
			case "direct":
				return CardinalityExecutionMode.Direct;
		}

		ThrowHelper.ThrowJsonException();
		return default;
	}

	public override void Write(Utf8JsonWriter writer, CardinalityExecutionMode value, JsonSerializerOptions options)
	{
		switch (value)
		{
			case CardinalityExecutionMode.SegmentOrdinals:
				writer.WriteStringValue("segment_ordinals");
				return;
			case CardinalityExecutionMode.SaveTimeHeuristic:
				writer.WriteStringValue("save_time_heuristic");
				return;
			case CardinalityExecutionMode.SaveMemoryHeuristic:
				writer.WriteStringValue("save_memory_heuristic");
				return;
			case CardinalityExecutionMode.GlobalOrdinals:
				writer.WriteStringValue("global_ordinals");
				return;
			case CardinalityExecutionMode.Direct:
				writer.WriteStringValue("direct");
				return;
		}

		writer.WriteNullValue();
	}
}

[JsonConverter(typeof(GapPolicyConverter))]
public enum GapPolicy
{
	/// <summary>
	/// <para>Treats missing data as if the bucket does not exist. It will skip the bucket and<br/>continue calculating using the next available value.</para>
	/// </summary>
	[EnumMember(Value = "skip")]
	Skip,
	/// <summary>
	/// <para>Similar to skip, except if the metric provides a non-null, non-NaN value this value is used,<br/>otherwise the empty bucket is skipped.</para>
	/// </summary>
	[EnumMember(Value = "keep_values")]
	KeepValues,
	/// <summary>
	/// <para>Replace missing values with a zero (0) and pipeline aggregation computation will proceed as normal.</para>
	/// </summary>
	[EnumMember(Value = "insert_zeros")]
	InsertZeros
}

internal sealed class GapPolicyConverter : JsonConverter<GapPolicy>
{
	public override GapPolicy Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
	{
		var enumString = reader.GetString();
		switch (enumString)
		{
			case "skip":
				return GapPolicy.Skip;
			case "keep_values":
				return GapPolicy.KeepValues;
			case "insert_zeros":
				return GapPolicy.InsertZeros;
		}

		ThrowHelper.ThrowJsonException();
		return default;
	}

	public override void Write(Utf8JsonWriter writer, GapPolicy value, JsonSerializerOptions options)
	{
		switch (value)
		{
			case GapPolicy.Skip:
				writer.WriteStringValue("skip");
				return;
			case GapPolicy.KeepValues:
				writer.WriteStringValue("keep_values");
				return;
			case GapPolicy.InsertZeros:
				writer.WriteStringValue("insert_zeros");
				return;
		}

		writer.WriteNullValue();
	}
}

[JsonConverter(typeof(MinimumIntervalConverter))]
public enum MinimumInterval
{
	[EnumMember(Value = "year")]
	Year,
	[EnumMember(Value = "second")]
	Second,
	[EnumMember(Value = "month")]
	Month,
	[EnumMember(Value = "minute")]
	Minute,
	[EnumMember(Value = "hour")]
	Hour,
	[EnumMember(Value = "day")]
	Day
}

internal sealed class MinimumIntervalConverter : JsonConverter<MinimumInterval>
{
	public override MinimumInterval Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
	{
		var enumString = reader.GetString();
		switch (enumString)
		{
			case "year":
				return MinimumInterval.Year;
			case "second":
				return MinimumInterval.Second;
			case "month":
				return MinimumInterval.Month;
			case "minute":
				return MinimumInterval.Minute;
			case "hour":
				return MinimumInterval.Hour;
			case "day":
				return MinimumInterval.Day;
		}

		ThrowHelper.ThrowJsonException();
		return default;
	}

	public override void Write(Utf8JsonWriter writer, MinimumInterval value, JsonSerializerOptions options)
	{
		switch (value)
		{
			case MinimumInterval.Year:
				writer.WriteStringValue("year");
				return;
			case MinimumInterval.Second:
				writer.WriteStringValue("second");
				return;
			case MinimumInterval.Month:
				writer.WriteStringValue("month");
				return;
			case MinimumInterval.Minute:
				writer.WriteStringValue("minute");
				return;
			case MinimumInterval.Hour:
				writer.WriteStringValue("hour");
				return;
			case MinimumInterval.Day:
				writer.WriteStringValue("day");
				return;
		}

		writer.WriteNullValue();
	}
}

[JsonConverter(typeof(MissingOrderConverter))]
public enum MissingOrder
{
	[EnumMember(Value = "last")]
	Last,
	[EnumMember(Value = "first")]
	First,
	[EnumMember(Value = "default")]
	Default
}

internal sealed class MissingOrderConverter : JsonConverter<MissingOrder>
{
	public override MissingOrder Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
	{
		var enumString = reader.GetString();
		switch (enumString)
		{
			case "last":
				return MissingOrder.Last;
			case "first":
				return MissingOrder.First;
			case "default":
				return MissingOrder.Default;
		}

		ThrowHelper.ThrowJsonException();
		return default;
	}

	public override void Write(Utf8JsonWriter writer, MissingOrder value, JsonSerializerOptions options)
	{
		switch (value)
		{
			case MissingOrder.Last:
				writer.WriteStringValue("last");
				return;
			case MissingOrder.First:
				writer.WriteStringValue("first");
				return;
			case MissingOrder.Default:
				writer.WriteStringValue("default");
				return;
		}

		writer.WriteNullValue();
	}
}

[JsonConverter(typeof(NormalizeMethodConverter))]
public enum NormalizeMethod
{
	/// <summary>
	/// <para>This method normalizes such that each value represents how far it is from the mean relative to the standard deviation.</para>
	/// </summary>
	[EnumMember(Value = "z-score")]
	ZScore,
	/// <summary>
	/// <para>This method normalizes such that each value is exponentiated and relative to the sum of the exponents of the original values.</para>
	/// </summary>
	[EnumMember(Value = "softmax")]
	Softmax,
	/// <summary>
	/// <para>This method rescales the data such that the minimum number is 0, and the maximum number is 100, with the rest normalized linearly in-between.</para>
	/// </summary>
	[EnumMember(Value = "rescale_0_100")]
	Rescale0100,
	/// <summary>
	/// <para>This method rescales the data such that the minimum number is 0, and the maximum number is 1, with the rest normalized linearly in-between.</para>
	/// </summary>
	[EnumMember(Value = "rescale_0_1")]
	Rescale01,
	/// <summary>
	/// <para>This method normalizes each value so that it represents a percentage of the total sum it attributes to.</para>
	/// </summary>
	[EnumMember(Value = "percent_of_sum")]
	PercentOfSum,
	/// <summary>
	/// <para>This method normalizes such that each value is normalized by how much it differs from the average.</para>
	/// </summary>
	[EnumMember(Value = "mean")]
	Mean
}

internal sealed class NormalizeMethodConverter : JsonConverter<NormalizeMethod>
{
	public override NormalizeMethod Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
	{
		var enumString = reader.GetString();
		switch (enumString)
		{
			case "z-score":
				return NormalizeMethod.ZScore;
			case "softmax":
				return NormalizeMethod.Softmax;
			case "rescale_0_100":
				return NormalizeMethod.Rescale0100;
			case "rescale_0_1":
				return NormalizeMethod.Rescale01;
			case "percent_of_sum":
				return NormalizeMethod.PercentOfSum;
			case "mean":
				return NormalizeMethod.Mean;
		}

		ThrowHelper.ThrowJsonException();
		return default;
	}

	public override void Write(Utf8JsonWriter writer, NormalizeMethod value, JsonSerializerOptions options)
	{
		switch (value)
		{
			case NormalizeMethod.ZScore:
				writer.WriteStringValue("z-score");
				return;
			case NormalizeMethod.Softmax:
				writer.WriteStringValue("softmax");
				return;
			case NormalizeMethod.Rescale0100:
				writer.WriteStringValue("rescale_0_100");
				return;
			case NormalizeMethod.Rescale01:
				writer.WriteStringValue("rescale_0_1");
				return;
			case NormalizeMethod.PercentOfSum:
				writer.WriteStringValue("percent_of_sum");
				return;
			case NormalizeMethod.Mean:
				writer.WriteStringValue("mean");
				return;
		}

		writer.WriteNullValue();
	}
}

[JsonConverter(typeof(RateModeConverter))]
public enum RateMode
{
	/// <summary>
	/// <para>Uses the number of values of the field.</para>
	/// </summary>
	[EnumMember(Value = "value_count")]
	ValueCount,
	/// <summary>
	/// <para>Calculates the sum of all values of the field.</para>
	/// </summary>
	[EnumMember(Value = "sum")]
	Sum
}

internal sealed class RateModeConverter : JsonConverter<RateMode>
{
	public override RateMode Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
	{
		var enumString = reader.GetString();
		switch (enumString)
		{
			case "value_count":
				return RateMode.ValueCount;
			case "sum":
				return RateMode.Sum;
		}

		ThrowHelper.ThrowJsonException();
		return default;
	}

	public override void Write(Utf8JsonWriter writer, RateMode value, JsonSerializerOptions options)
	{
		switch (value)
		{
			case RateMode.ValueCount:
				writer.WriteStringValue("value_count");
				return;
			case RateMode.Sum:
				writer.WriteStringValue("sum");
				return;
		}

		writer.WriteNullValue();
	}
}

[JsonConverter(typeof(SamplerAggregationExecutionHintConverter))]
public enum SamplerAggregationExecutionHint
{
	/// <summary>
	/// <para>Hold field values directly.</para>
	/// </summary>
	[EnumMember(Value = "map")]
	Map,
	/// <summary>
	/// <para>Hold ordinals of the field as determined by the Lucene index.</para>
	/// </summary>
	[EnumMember(Value = "global_ordinals")]
	GlobalOrdinals,
	/// <summary>
	/// <para>Hold hashes of the field values - with potential for hash collisions.</para>
	/// </summary>
	[EnumMember(Value = "bytes_hash")]
	BytesHash
}

internal sealed class SamplerAggregationExecutionHintConverter : JsonConverter<SamplerAggregationExecutionHint>
{
	public override SamplerAggregationExecutionHint Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
	{
		var enumString = reader.GetString();
		switch (enumString)
		{
			case "map":
				return SamplerAggregationExecutionHint.Map;
			case "global_ordinals":
				return SamplerAggregationExecutionHint.GlobalOrdinals;
			case "bytes_hash":
				return SamplerAggregationExecutionHint.BytesHash;
		}

		ThrowHelper.ThrowJsonException();
		return default;
	}

	public override void Write(Utf8JsonWriter writer, SamplerAggregationExecutionHint value, JsonSerializerOptions options)
	{
		switch (value)
		{
			case SamplerAggregationExecutionHint.Map:
				writer.WriteStringValue("map");
				return;
			case SamplerAggregationExecutionHint.GlobalOrdinals:
				writer.WriteStringValue("global_ordinals");
				return;
			case SamplerAggregationExecutionHint.BytesHash:
				writer.WriteStringValue("bytes_hash");
				return;
		}

		writer.WriteNullValue();
	}
}

[JsonConverter(typeof(TermsAggregationCollectModeConverter))]
public enum TermsAggregationCollectMode
{
	/// <summary>
	/// <para>Expands all branches of the aggregation tree in one depth-first pass, before any pruning occurs.</para>
	/// </summary>
	[EnumMember(Value = "depth_first")]
	DepthFirst,
	/// <summary>
	/// <para>Caches the set of documents that fall into the uppermost buckets for subsequent replay.</para>
	/// </summary>
	[EnumMember(Value = "breadth_first")]
	BreadthFirst
}

internal sealed class TermsAggregationCollectModeConverter : JsonConverter<TermsAggregationCollectMode>
{
	public override TermsAggregationCollectMode Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
	{
		var enumString = reader.GetString();
		switch (enumString)
		{
			case "depth_first":
				return TermsAggregationCollectMode.DepthFirst;
			case "breadth_first":
				return TermsAggregationCollectMode.BreadthFirst;
		}

		ThrowHelper.ThrowJsonException();
		return default;
	}

	public override void Write(Utf8JsonWriter writer, TermsAggregationCollectMode value, JsonSerializerOptions options)
	{
		switch (value)
		{
			case TermsAggregationCollectMode.DepthFirst:
				writer.WriteStringValue("depth_first");
				return;
			case TermsAggregationCollectMode.BreadthFirst:
				writer.WriteStringValue("breadth_first");
				return;
		}

		writer.WriteNullValue();
	}
}

[JsonConverter(typeof(TermsAggregationExecutionHintConverter))]
public enum TermsAggregationExecutionHint
{
	[EnumMember(Value = "map")]
	Map,
	[EnumMember(Value = "global_ordinals_low_cardinality")]
	GlobalOrdinalsLowCardinality,
	[EnumMember(Value = "global_ordinals_hash")]
	GlobalOrdinalsHash,
	[EnumMember(Value = "global_ordinals")]
	GlobalOrdinals
}

internal sealed class TermsAggregationExecutionHintConverter : JsonConverter<TermsAggregationExecutionHint>
{
	public override TermsAggregationExecutionHint Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
	{
		var enumString = reader.GetString();
		switch (enumString)
		{
			case "map":
				return TermsAggregationExecutionHint.Map;
			case "global_ordinals_low_cardinality":
				return TermsAggregationExecutionHint.GlobalOrdinalsLowCardinality;
			case "global_ordinals_hash":
				return TermsAggregationExecutionHint.GlobalOrdinalsHash;
			case "global_ordinals":
				return TermsAggregationExecutionHint.GlobalOrdinals;
		}

		ThrowHelper.ThrowJsonException();
		return default;
	}

	public override void Write(Utf8JsonWriter writer, TermsAggregationExecutionHint value, JsonSerializerOptions options)
	{
		switch (value)
		{
			case TermsAggregationExecutionHint.Map:
				writer.WriteStringValue("map");
				return;
			case TermsAggregationExecutionHint.GlobalOrdinalsLowCardinality:
				writer.WriteStringValue("global_ordinals_low_cardinality");
				return;
			case TermsAggregationExecutionHint.GlobalOrdinalsHash:
				writer.WriteStringValue("global_ordinals_hash");
				return;
			case TermsAggregationExecutionHint.GlobalOrdinals:
				writer.WriteStringValue("global_ordinals");
				return;
		}

		writer.WriteNullValue();
	}
}

[JsonConverter(typeof(TTestTypeConverter))]
public enum TTestType
{
	/// <summary>
	/// <para>Performs paired t-test.</para>
	/// </summary>
	[EnumMember(Value = "paired")]
	Paired,
	/// <summary>
	/// <para>Performs two-sample equal variance test.</para>
	/// </summary>
	[EnumMember(Value = "homoscedastic")]
	Homoscedastic,
	/// <summary>
	/// <para>Performs two-sample unequal variance test.</para>
	/// </summary>
	[EnumMember(Value = "heteroscedastic")]
	Heteroscedastic
}

internal sealed class TTestTypeConverter : JsonConverter<TTestType>
{
	public override TTestType Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
	{
		var enumString = reader.GetString();
		switch (enumString)
		{
			case "paired":
				return TTestType.Paired;
			case "homoscedastic":
				return TTestType.Homoscedastic;
			case "heteroscedastic":
				return TTestType.Heteroscedastic;
		}

		ThrowHelper.ThrowJsonException();
		return default;
	}

	public override void Write(Utf8JsonWriter writer, TTestType value, JsonSerializerOptions options)
	{
		switch (value)
		{
			case TTestType.Paired:
				writer.WriteStringValue("paired");
				return;
			case TTestType.Homoscedastic:
				writer.WriteStringValue("homoscedastic");
				return;
			case TTestType.Heteroscedastic:
				writer.WriteStringValue("heteroscedastic");
				return;
		}

		writer.WriteNullValue();
	}
}

[JsonConverter(typeof(ValueTypeConverter))]
public enum ValueType
{
	[EnumMember(Value = "string")]
	String,
	[EnumMember(Value = "numeric")]
	Numeric,
	[EnumMember(Value = "number")]
	Number,
	[EnumMember(Value = "long")]
	Long,
	[EnumMember(Value = "ip")]
	Ip,
	[EnumMember(Value = "geo_point")]
	GeoPoint,
	[EnumMember(Value = "double")]
	Double,
	[EnumMember(Value = "date_nanos")]
	DateNanos,
	[EnumMember(Value = "date")]
	Date,
	[EnumMember(Value = "boolean")]
	Boolean
}

internal sealed class ValueTypeConverter : JsonConverter<ValueType>
{
	public override ValueType Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
	{
		var enumString = reader.GetString();
		switch (enumString)
		{
			case "string":
				return ValueType.String;
			case "numeric":
				return ValueType.Numeric;
			case "number":
				return ValueType.Number;
			case "long":
				return ValueType.Long;
			case "ip":
				return ValueType.Ip;
			case "geo_point":
				return ValueType.GeoPoint;
			case "double":
				return ValueType.Double;
			case "date_nanos":
				return ValueType.DateNanos;
			case "date":
				return ValueType.Date;
			case "boolean":
				return ValueType.Boolean;
		}

		ThrowHelper.ThrowJsonException();
		return default;
	}

	public override void Write(Utf8JsonWriter writer, ValueType value, JsonSerializerOptions options)
	{
		switch (value)
		{
			case ValueType.String:
				writer.WriteStringValue("string");
				return;
			case ValueType.Numeric:
				writer.WriteStringValue("numeric");
				return;
			case ValueType.Number:
				writer.WriteStringValue("number");
				return;
			case ValueType.Long:
				writer.WriteStringValue("long");
				return;
			case ValueType.Ip:
				writer.WriteStringValue("ip");
				return;
			case ValueType.GeoPoint:
				writer.WriteStringValue("geo_point");
				return;
			case ValueType.Double:
				writer.WriteStringValue("double");
				return;
			case ValueType.DateNanos:
				writer.WriteStringValue("date_nanos");
				return;
			case ValueType.Date:
				writer.WriteStringValue("date");
				return;
			case ValueType.Boolean:
				writer.WriteStringValue("boolean");
				return;
		}

		writer.WriteNullValue();
	}
}