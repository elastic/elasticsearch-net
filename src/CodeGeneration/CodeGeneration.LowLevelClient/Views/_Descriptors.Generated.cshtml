@using System.Collections.Generic
@using System.Linq
@using CsQuery.ExtensionMethods.Internal
@using CodeGeneration.LowLevelClient.Domain
@using CodeGeneration.LowLevelClient
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Linq.Expressions;
using Elasticsearch.Net;

//This file lays the base for all the descriptors based on the query string parameters in the spec for IElasticClient.
//This file is automatically generated from https://github.com/elasticsearch/elasticsearch-rest-api-spec
//Generated of commit @Model.Commit

namespace Nest
{
	@foreach (CsharpMethod method in Model.CsharpMethodsWithQueryStringInfo)
	{
		var type = method.DescriptorType + method.DescriptorTypeGeneric;
	<text>
	///<summary>descriptor for @method.FullName <pre>@method.Documentation</pre></summary>
	public partial class @Raw(type) @(Raw(string.Format(" : RequestDescriptorBase<{0},{1}, {2}>, {2}", type, method.QueryStringParamName, method.InterfaceType)))
	{ 
	@foreach (ApiUrlPart part in method.AllParts.Where(p=>!ApiUrl.BlackListRouteValues.Contains(p.Name)))
	{
	<text>	@(Raw(part.ClrTypeName)) @(Raw(method.InterfaceType)).@(part.InterfaceName) => Self.RouteValues.Get@(Raw(string.Format("<{0}>",part.ClrTypeName)))("@(part.Name)");</text>
	}
	@foreach (Constructor c in method.DescriptorConstructors())
    {
	<text>	@(Raw(c.Description))
		@(Raw(c.Generated))
		@(Raw(c.AdditionalCode))
</text>
    }
	@foreach (FluentRouteSetter c in method.GetFluentRouteSetters())
    {
	<text>	@(Raw(c.XmlDoc))
		@(Raw(c.Code))
</text>
    }
	</text>foreach (KeyValuePair<string, ApiQueryParameters> kv in method.Url.Params)
	{
        if (method.Url.Parts != null && method.Url.Parts.ContainsKey(kv.Key))
        {
			continue;
        }
		var t = @kv.Value.HighLevelType(kv.Key);
		var tMethod = t == "Time" ? ".ToTimeSpan()" : "";
		var tSuffix = (t == "bool") ? " = true" : "";
		var m = kv.Key.ToPascalCase();
		var mm = (m != "Type" && m != "Index" && m != "Script") ? m : m + "QueryString";
		var typed = !method.DescriptorTypeGeneric.IsNullOrEmpty();
		var g = typed ? method.DescriptorTypeGeneric.Replace("<", "").Replace(">", "") : "T";
		var mml = mm.ToLowerInvariant();
		var fieldMethod = (mml.Contains("fields") || mml.Contains("sourceinclude") || mml.Contains("sourceexclude") ) && t.Contains("string");
		<text>
		///<summary>@kv.Value.Description</summary>
		@if (!string.IsNullOrWhiteSpace(kv.Value.DeprecatedInFavorOf))
		{<text>
		[Obsolete("Scheduled to be removed in 2.0, use @kv.Value.DeprecatedInFavorOf instead")]
		</text>}
		public @Raw(type) @(mm)(@t @kv.Key@tSuffix) => AssignParam(p=>p.@(m)(@kv.Key@tMethod));</text>
		if (fieldMethod)
		{
			<text>
		///<summary>@kv.Value.Description</summary>
		public @Raw(type) @mm@(Raw(typed ? "" : "<T>"))(params @Raw("Expression<Func<" + g + ", object>>[]") fields) @Raw(typed ? "" : "where "+ g + " : class") =>
			AssignParam(p=>p._@(mm)(fields));</text>
		}
		else if (mm.ToLowerInvariant().Contains("field") && t.Contains("string"))
		{<text>
		///<summary>@kv.Value.Description</summary>
		public @Raw(type) @mm@(Raw(typed ? "" : "<T>"))(@Raw("Expression<Func<"+ g +", object>>") field) @Raw(typed ? "" : "where " + g + " : class") =>
			AssignParam(p=>p._@(mm)(field));</text>
		}
	}
	if (method.Unmapped)
	{<text>
		//TODO THIS METHOD IS UNMAPPED!
		</text>
	}	
	<text>
	}</text>
	}
}