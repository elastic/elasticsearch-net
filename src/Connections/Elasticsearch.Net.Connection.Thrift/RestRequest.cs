/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */

using System;
using System.Collections.Generic;
using System.Text;
using Elasticsearch.Net.Connection.Thrift.Protocol;

namespace Elasticsearch.Net.Connection.Thrift
{
	[Serializable]
	internal class RestRequest : TBase
	{
		public Isset __isset;
		private byte[] body;
		private Dictionary<string, string> headers;
		private Method method;
		private Dictionary<string, string> parameters;
		private Uri uri;

		public Method Method
		{
			get { return method; }
			set
			{
				__isset.method = true;
				method = value;
			}
		}

		public Uri Uri
		{
			get { return uri; }
			set
			{
				__isset.uri = true;
				uri = value;
			}
		}

		public Dictionary<string, string> Parameters
		{
			get { return parameters; }
			set
			{
				__isset.parameters = true;
				parameters = value;
			}
		}

		public Dictionary<string, string> Headers
		{
			get { return headers; }
			set
			{
				__isset.headers = true;
				headers = value;
			}
		}

		public byte[] Body
		{
			get { return body; }
			set
			{
				__isset.body = true;
				body = value;
			}
		}

		#region TBase Members

		public void Read(TProtocol iprot)
		{
			TField field;
			iprot.ReadStructBegin();
			while (true)
			{
				field = iprot.ReadFieldBegin();
				if (field.Type == TType.Stop)
				{
					break;
				}
				switch (field.ID)
				{
					case 1:
						if (field.Type == TType.I32)
						{
							method = (Method) iprot.ReadI32();
							__isset.method = true;
						}
						else
						{
							TProtocolUtil.Skip(iprot, field.Type);
						}
						break;
					case 2:
						if (field.Type == TType.String)
						{
							uri = new Uri(iprot.ReadString());
							__isset.uri = true;
						}
						else
						{
							TProtocolUtil.Skip(iprot, field.Type);
						}
						break;
					case 3:
						if (field.Type == TType.Map)
						{
							{
								parameters = new Dictionary<string, string>();
								TMap _map0 = iprot.ReadMapBegin();
								for (int _i1 = 0; _i1 < _map0.Count; ++_i1)
								{
									string _key2;
									string _val3;
									_key2 = iprot.ReadString();
									_val3 = iprot.ReadString();
									parameters[_key2] = _val3;
								}
								iprot.ReadMapEnd();
							}
							__isset.parameters = true;
						}
						else
						{
							TProtocolUtil.Skip(iprot, field.Type);
						}
						break;
					case 4:
						if (field.Type == TType.Map)
						{
							{
								headers = new Dictionary<string, string>();
								TMap _map4 = iprot.ReadMapBegin();
								for (int _i5 = 0; _i5 < _map4.Count; ++_i5)
								{
									string _key6;
									string _val7;
									_key6 = iprot.ReadString();
									_val7 = iprot.ReadString();
									headers[_key6] = _val7;
								}
								iprot.ReadMapEnd();
							}
							__isset.headers = true;
						}
						else
						{
							TProtocolUtil.Skip(iprot, field.Type);
						}
						break;
					case 5:
						if (field.Type == TType.String)
						{
							body = iprot.ReadBinary();
							__isset.body = true;
						}
						else
						{
							TProtocolUtil.Skip(iprot, field.Type);
						}
						break;
					default:
						TProtocolUtil.Skip(iprot, field.Type);
						break;
				}
				iprot.ReadFieldEnd();
			}
			iprot.ReadStructEnd();
		}

		public void Write(TProtocol oprot)
		{
			var struc = new TStruct("RestRequest");
			oprot.WriteStructBegin(struc);
			var field = new TField();
			if (__isset.method)
			{
				field.Name = "method";
				field.Type = TType.I32;
				field.ID = 1;
				oprot.WriteFieldBegin(field);
				oprot.WriteI32((int) method);
				oprot.WriteFieldEnd();
			}
			if (uri != null && __isset.uri)
			{
				field.Name = "uri";
				field.Type = TType.String;
				field.ID = 2;
				oprot.WriteFieldBegin(field);
				oprot.WriteString(uri.PathAndQuery);
				oprot.WriteFieldEnd();
			}
			if (parameters != null && __isset.parameters)
			{
				field.Name = "parameters";
				field.Type = TType.Map;
				field.ID = 3;
				oprot.WriteFieldBegin(field);
				{
					oprot.WriteMapBegin(new TMap(TType.String, TType.String, parameters.Count));
					foreach (string _iter8 in parameters.Keys)
					{
						oprot.WriteString(_iter8);
						oprot.WriteString(parameters[_iter8]);
						oprot.WriteMapEnd();
					}
				}
				oprot.WriteFieldEnd();
			}
			if (headers != null && __isset.headers)
			{
				field.Name = "headers";
				field.Type = TType.Map;
				field.ID = 4;
				oprot.WriteFieldBegin(field);
				{
					oprot.WriteMapBegin(new TMap(TType.String, TType.String, headers.Count));
					foreach (string _iter9 in headers.Keys)
					{
						oprot.WriteString(_iter9);
						oprot.WriteString(headers[_iter9]);
						oprot.WriteMapEnd();
					}
				}
				oprot.WriteFieldEnd();
			}
			if (body != null && __isset.body)
			{
				field.Name = "body";
				field.Type = TType.String;
				field.ID = 5;
				oprot.WriteFieldBegin(field);
				oprot.WriteBinary(body);
				oprot.WriteFieldEnd();
			}
			oprot.WriteFieldStop();
			oprot.WriteStructEnd();
		}

		#endregion

		public override string ToString()
		{
			var sb = new StringBuilder("RestRequest(");
			sb.Append("method: ");
			sb.Append(method);
			sb.Append(",uri: ");
			sb.Append(uri);
			sb.Append(",parameters: ");
			sb.Append(parameters);
			sb.Append(",headers: ");
			sb.Append(headers);
			sb.Append(",body: ");
			sb.Append(body);
			sb.Append(")");
			return sb.ToString();
		}

		#region Nested type: Isset

		[Serializable]
		public struct Isset
		{
			public bool body;
			public bool headers;
			public bool method;
			public bool parameters;
			public bool uri;
		}

		#endregion
	}
}