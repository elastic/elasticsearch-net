// ███╗   ██╗ ██████╗ ████████╗██╗ ██████╗███████╗
// ████╗  ██║██╔═══██╗╚══██╔══╝██║██╔════╝██╔════╝
// ██╔██╗ ██║██║   ██║   ██║   ██║██║     █████╗  
// ██║╚██╗██║██║   ██║   ██║   ██║██║     ██╔══╝  
// ██║ ╚████║╚██████╔╝   ██║   ██║╚██████╗███████╗
// ╚═╝  ╚═══╝ ╚═════╝    ╚═╝   ╚═╝ ╚═════╝╚══════╝
// -----------------------------------------------
//  
// This file is automatically generated 
// Please do not edit these files manually
// Run the following in the root of the repos:
//
// 		*NIX 		:	./build.sh codegen
// 		Windows 	:	build.bat codegen
//
// -----------------------------------------------
// ReSharper disable RedundantUsingDirective
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Linq.Expressions;

// ReSharper disable once CheckNamespace
namespace Elasticsearch.Net.Specification.AsyncSearchApi
{
	///<summary>Request options for Delete <para>https://www.elastic.co/guide/en/elasticsearch/reference/current/async-search.html</para></summary>
	public class AsyncSearchDeleteRequestParameters : RequestParameters<AsyncSearchDeleteRequestParameters>
	{
		public override HttpMethod DefaultHttpMethod => HttpMethod.DELETE;
		public override bool SupportsBody => false;
	}

	///<summary>Request options for Get <para>https://www.elastic.co/guide/en/elasticsearch/reference/current/async-search.html</para></summary>
	public class AsyncSearchGetRequestParameters : RequestParameters<AsyncSearchGetRequestParameters>
	{
		public override HttpMethod DefaultHttpMethod => HttpMethod.GET;
		public override bool SupportsBody => false;
		///<summary>Specify the time interval in which the results (partial or final) for this search will be available</summary>
		public TimeSpan KeepAlive
		{
			get => Q<TimeSpan>("keep_alive");
			set => Q("keep_alive", value);
		}

		///<summary>Specify whether aggregation and suggester names should be prefixed by their respective types in the response</summary>
		public bool? TypedKeys
		{
			get => Q<bool? >("typed_keys");
			set => Q("typed_keys", value);
		}

		///<summary>Specify the time that the request should block waiting for the final response</summary>
		public TimeSpan WaitForCompletionTimeout
		{
			get => Q<TimeSpan>("wait_for_completion_timeout");
			set => Q("wait_for_completion_timeout", value);
		}
	}

	///<summary>Request options for Submit <para>https://www.elastic.co/guide/en/elasticsearch/reference/current/async-search.html</para></summary>
	public class AsyncSearchSubmitRequestParameters : RequestParameters<AsyncSearchSubmitRequestParameters>
	{
		public override HttpMethod DefaultHttpMethod => HttpMethod.POST;
		public override bool SupportsBody => true;
		///<summary>
		/// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have
		/// been specified)
		///</summary>
		public bool? AllowNoIndices
		{
			get => Q<bool? >("allow_no_indices");
			set => Q("allow_no_indices", value);
		}

		///<summary>Indicate if an error should be returned if there is a partial search failure or timeout</summary>
		public bool? AllowPartialSearchResults
		{
			get => Q<bool? >("allow_partial_search_results");
			set => Q("allow_partial_search_results", value);
		}

		///<summary>Specify whether wildcard and prefix queries should be analyzed (default: false)</summary>
		public bool? AnalyzeWildcard
		{
			get => Q<bool? >("analyze_wildcard");
			set => Q("analyze_wildcard", value);
		}

		///<summary>The analyzer to use for the query string</summary>
		public string Analyzer
		{
			get => Q<string>("analyzer");
			set => Q("analyzer", value);
		}

		///<summary>
		/// The number of shard results that should be reduced at once on the coordinating node. This value should be used as the granularity at which
		/// progress results will be made available.
		///</summary>
		public long? BatchedReduceSize
		{
			get => Q<long? >("batched_reduce_size");
			set => Q("batched_reduce_size", value);
		}

		///<summary>The default operator for query string query (AND or OR)</summary>
		public DefaultOperator? DefaultOperator
		{
			get => Q<DefaultOperator? >("default_operator");
			set => Q("default_operator", value);
		}

		///<summary>The field to use as default where no field prefix is given in the query string</summary>
		public string Df
		{
			get => Q<string>("df");
			set => Q("df", value);
		}

		///<summary>A comma-separated list of fields to return as the docvalue representation of a field for each hit</summary>
		public string[] DocValueFields
		{
			get => Q<string[]>("docvalue_fields");
			set => Q("docvalue_fields", value);
		}

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ExpandWildcards? ExpandWildcards
		{
			get => Q<ExpandWildcards? >("expand_wildcards");
			set => Q("expand_wildcards", value);
		}

		///<summary>Whether specified concrete, expanded or aliased indices should be ignored when throttled</summary>
		public bool? IgnoreThrottled
		{
			get => Q<bool? >("ignore_throttled");
			set => Q("ignore_throttled", value);
		}

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public bool? IgnoreUnavailable
		{
			get => Q<bool? >("ignore_unavailable");
			set => Q("ignore_unavailable", value);
		}

		///<summary>Update the time interval in which the results (partial or final) for this search will be available</summary>
		public TimeSpan KeepAlive
		{
			get => Q<TimeSpan>("keep_alive");
			set => Q("keep_alive", value);
		}

		///<summary>
		/// Control whether the response should be stored in the cluster if it completed within the provided [wait_for_completion] time (default:
		/// false)
		///</summary>
		public bool? KeepOnCompletion
		{
			get => Q<bool? >("keep_on_completion");
			set => Q("keep_on_completion", value);
		}

		///<summary>Specify whether format-based query failures (such as providing text to a numeric field) should be ignored</summary>
		public bool? Lenient
		{
			get => Q<bool? >("lenient");
			set => Q("lenient", value);
		}

		///<summary>
		/// The number of concurrent shard requests per node this search executes concurrently. This value should be used to limit the impact of the
		/// search on the cluster in order to limit the number of concurrent shard requests
		///</summary>
		public long? MaxConcurrentShardRequests
		{
			get => Q<long? >("max_concurrent_shard_requests");
			set => Q("max_concurrent_shard_requests", value);
		}

		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public string Preference
		{
			get => Q<string>("preference");
			set => Q("preference", value);
		}

		///<summary>Query in the Lucene query string syntax</summary>
		public string QueryOnQueryString
		{
			get => Q<string>("q");
			set => Q("q", value);
		}

		///<summary>Specify if request cache should be used for this request or not, defaults to true</summary>
		public bool? RequestCache
		{
			get => Q<bool? >("request_cache");
			set => Q("request_cache", value);
		}

		///<summary>A comma-separated list of specific routing values</summary>
		public string[] Routing
		{
			get => Q<string[]>("routing");
			set => Q("routing", value);
		}

		///<summary>Search operation type</summary>
		public SearchType? SearchType
		{
			get => Q<SearchType? >("search_type");
			set => Q("search_type", value);
		}

		///<summary>Specify whether to return sequence number and primary term of the last modification of each hit</summary>
		public bool? SequenceNumberPrimaryTerm
		{
			get => Q<bool? >("seq_no_primary_term");
			set => Q("seq_no_primary_term", value);
		}

		///<summary>Specific 'tag' of the request for logging and statistical purposes</summary>
		public string[] Stats
		{
			get => Q<string[]>("stats");
			set => Q("stats", value);
		}

		///<summary>A comma-separated list of stored fields to return as part of a hit</summary>
		public string[] StoredFields
		{
			get => Q<string[]>("stored_fields");
			set => Q("stored_fields", value);
		}

		///<summary>Specify which field to use for suggestions</summary>
		public string SuggestField
		{
			get => Q<string>("suggest_field");
			set => Q("suggest_field", value);
		}

		///<summary>Specify suggest mode</summary>
		public SuggestMode? SuggestMode
		{
			get => Q<SuggestMode? >("suggest_mode");
			set => Q("suggest_mode", value);
		}

		///<summary>How many suggestions to return in response</summary>
		public long? SuggestSize
		{
			get => Q<long? >("suggest_size");
			set => Q("suggest_size", value);
		}

		///<summary>The source text for which the suggestions should be returned</summary>
		public string SuggestText
		{
			get => Q<string>("suggest_text");
			set => Q("suggest_text", value);
		}

		///<summary>
		/// Indicate if the number of documents that match the query should be tracked. A number can also be specified, to accurately track the total
		/// hit count up to the number.
		///</summary>
		public bool? TrackTotalHits
		{
			get => Q<bool? >("track_total_hits");
			set => Q("track_total_hits", value);
		}

		///<summary>Specify whether aggregation and suggester names should be prefixed by their respective types in the response</summary>
		public bool? TypedKeys
		{
			get => Q<bool? >("typed_keys");
			set => Q("typed_keys", value);
		}

		///<summary>Specify the time that the request should block waiting for the final response</summary>
		public TimeSpan WaitForCompletionTimeout
		{
			get => Q<TimeSpan>("wait_for_completion_timeout");
			set => Q("wait_for_completion_timeout", value);
		}
	}
}