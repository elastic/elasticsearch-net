// Licensed to Elasticsearch B.V under one or more agreements.
// Elasticsearch B.V licenses this file to you under the Apache 2.0 License.
// See the LICENSE file in the project root for more information.
//
// ███╗   ██╗ ██████╗ ████████╗██╗ ██████╗███████╗
// ████╗  ██║██╔═══██╗╚══██╔══╝██║██╔════╝██╔════╝
// ██╔██╗ ██║██║   ██║   ██║   ██║██║     █████╗
// ██║╚██╗██║██║   ██║   ██║   ██║██║     ██╔══╝
// ██║ ╚████║╚██████╔╝   ██║   ██║╚██████╗███████╗
// ╚═╝  ╚═══╝ ╚═════╝    ╚═╝   ╚═╝ ╚═════╝╚══════╝
// ------------------------------------------------
//
// This file is automatically generated.
// Please do not edit these files manually.
//
// ------------------------------------------------

#nullable restore

using Elastic.Clients.Elasticsearch.Fluent;
using Elastic.Clients.Elasticsearch.Requests;
using Elastic.Clients.Elasticsearch.Serialization;
using Elastic.Transport;
using Elastic.Transport.Extensions;
using System;
using System.Collections.Generic;
using System.Linq.Expressions;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace Elastic.Clients.Elasticsearch;

public sealed partial class SearchRequestParameters : RequestParameters
{
	/// <summary>
	/// <para>
	/// If <c>false</c>, the request returns an error if any wildcard expression, index alias, or <c>_all</c> value targets only missing or closed indices.
	/// This behavior applies even if the request targets other open indices.
	/// For example, a request targeting <c>foo*,bar*</c> returns an error if an index starts with <c>foo</c> but no index starts with <c>bar</c>.
	/// </para>
	/// </summary>
	public bool? AllowNoIndices { get => Q<bool?>("allow_no_indices"); set => Q("allow_no_indices", value); }

	/// <summary>
	/// <para>
	/// If true, returns partial results if there are shard request timeouts or shard failures. If false, returns an error with no partial results.
	/// </para>
	/// </summary>
	public bool? AllowPartialSearchResults { get => Q<bool?>("allow_partial_search_results"); set => Q("allow_partial_search_results", value); }

	/// <summary>
	/// <para>
	/// Analyzer to use for the query string.
	/// This parameter can only be used when the q query string parameter is specified.
	/// </para>
	/// </summary>
	public string? Analyzer { get => Q<string?>("analyzer"); set => Q("analyzer", value); }

	/// <summary>
	/// <para>
	/// If true, wildcard and prefix queries are analyzed.
	/// This parameter can only be used when the q query string parameter is specified.
	/// </para>
	/// </summary>
	public bool? AnalyzeWildcard { get => Q<bool?>("analyze_wildcard"); set => Q("analyze_wildcard", value); }

	/// <summary>
	/// <para>
	/// The number of shard results that should be reduced at once on the coordinating node.
	/// This value should be used as a protection mechanism to reduce the memory overhead per search request if the potential number of shards in the request can be large.
	/// </para>
	/// </summary>
	public long? BatchedReduceSize { get => Q<long?>("batched_reduce_size"); set => Q("batched_reduce_size", value); }

	/// <summary>
	/// <para>
	/// If true, network round-trips between the coordinating node and the remote clusters are minimized when executing cross-cluster search (CCS) requests.
	/// </para>
	/// </summary>
	public bool? CcsMinimizeRoundtrips { get => Q<bool?>("ccs_minimize_roundtrips"); set => Q("ccs_minimize_roundtrips", value); }

	/// <summary>
	/// <para>
	/// The default operator for query string query: AND or OR.
	/// This parameter can only be used when the <c>q</c> query string parameter is specified.
	/// </para>
	/// </summary>
	public Elastic.Clients.Elasticsearch.QueryDsl.Operator? DefaultOperator { get => Q<Elastic.Clients.Elasticsearch.QueryDsl.Operator?>("default_operator"); set => Q("default_operator", value); }

	/// <summary>
	/// <para>
	/// Field to use as default where no field prefix is given in the query string.
	/// This parameter can only be used when the q query string parameter is specified.
	/// </para>
	/// </summary>
	public string? Df { get => Q<string?>("df"); set => Q("df", value); }

	/// <summary>
	/// <para>
	/// Type of index that wildcard patterns can match.
	/// If the request can target data streams, this argument determines whether wildcard expressions match hidden data streams.
	/// Supports comma-separated values, such as <c>open,hidden</c>.
	/// </para>
	/// </summary>
	public ICollection<Elastic.Clients.Elasticsearch.ExpandWildcard>? ExpandWildcards { get => Q<ICollection<Elastic.Clients.Elasticsearch.ExpandWildcard>?>("expand_wildcards"); set => Q("expand_wildcards", value); }

	/// <summary>
	/// <para>
	/// Should this request force synthetic _source?
	/// Use this to test if the mapping supports synthetic _source and to get a sense of the worst case performance.
	/// Fetches with this enabled will be slower the enabling synthetic source natively in the index.
	/// </para>
	/// </summary>
	public bool? ForceSyntheticSource { get => Q<bool?>("force_synthetic_source"); set => Q("force_synthetic_source", value); }

	/// <summary>
	/// <para>
	/// If <c>true</c>, concrete, expanded or aliased indices will be ignored when frozen.
	/// </para>
	/// </summary>
	public bool? IgnoreThrottled { get => Q<bool?>("ignore_throttled"); set => Q("ignore_throttled", value); }

	/// <summary>
	/// <para>
	/// If <c>false</c>, the request returns an error if it targets a missing or closed index.
	/// </para>
	/// </summary>
	public bool? IgnoreUnavailable { get => Q<bool?>("ignore_unavailable"); set => Q("ignore_unavailable", value); }

	/// <summary>
	/// <para>
	/// If <c>true</c>, format-based query failures (such as providing text to a numeric field) in the query string will be ignored.
	/// This parameter can only be used when the <c>q</c> query string parameter is specified.
	/// </para>
	/// </summary>
	public bool? Lenient { get => Q<bool?>("lenient"); set => Q("lenient", value); }

	/// <summary>
	/// <para>
	/// Defines the number of concurrent shard requests per node this search executes concurrently.
	/// This value should be used to limit the impact of the search on the cluster in order to limit the number of concurrent shard requests.
	/// </para>
	/// </summary>
	public long? MaxConcurrentShardRequests { get => Q<long?>("max_concurrent_shard_requests"); set => Q("max_concurrent_shard_requests", value); }

	/// <summary>
	/// <para>
	/// The minimum version of the node that can handle the request
	/// Any handling node with a lower version will fail the request.
	/// </para>
	/// </summary>
	public string? MinCompatibleShardNode { get => Q<string?>("min_compatible_shard_node"); set => Q("min_compatible_shard_node", value); }

	/// <summary>
	/// <para>
	/// Nodes and shards used for the search.
	/// By default, Elasticsearch selects from eligible nodes and shards using adaptive replica selection, accounting for allocation awareness. Valid values are:
	/// <c>_only_local</c> to run the search only on shards on the local node;
	/// <c>_local</c> to, if possible, run the search on shards on the local node, or if not, select shards using the default method;
	/// <c>_only_nodes:&lt;node-id>,&lt;node-id></c> to run the search on only the specified nodes IDs, where, if suitable shards exist on more than one selected node, use shards on those nodes using the default method, or if none of the specified nodes are available, select shards from any available node using the default method;
	/// <c>_prefer_nodes:&lt;node-id>,&lt;node-id></c> to if possible, run the search on the specified nodes IDs, or if not, select shards using the default method;
	/// <c>_shards:&lt;shard>,&lt;shard></c> to run the search only on the specified shards;
	/// <c>&lt;custom-string></c> (any string that does not start with <c>_</c>) to route searches with the same <c>&lt;custom-string></c> to the same shards in the same order.
	/// </para>
	/// </summary>
	public string? Preference { get => Q<string?>("preference"); set => Q("preference", value); }

	/// <summary>
	/// <para>
	/// Defines a threshold that enforces a pre-filter roundtrip to prefilter search shards based on query rewriting if the number of shards the search request expands to exceeds the threshold.
	/// This filter roundtrip can limit the number of shards significantly if for instance a shard can not match any documents based on its rewrite method (if date filters are mandatory to match but the shard bounds and the query are disjoint).
	/// When unspecified, the pre-filter phase is executed if any of these conditions is met:
	/// the request targets more than 128 shards;
	/// the request targets one or more read-only index;
	/// the primary sort of the query targets an indexed field.
	/// </para>
	/// </summary>
	public long? PreFilterShardSize { get => Q<long?>("pre_filter_shard_size"); set => Q("pre_filter_shard_size", value); }

	/// <summary>
	/// <para>
	/// Query in the Lucene query string syntax using query parameter search.
	/// Query parameter searches do not support the full Elasticsearch Query DSL but are handy for testing.
	/// </para>
	/// </summary>
	public string? QueryLuceneSyntax { get => Q<string?>("q"); set => Q("q", value); }

	/// <summary>
	/// <para>
	/// If <c>true</c>, the caching of search results is enabled for requests where <c>size</c> is <c>0</c>.
	/// Defaults to index level settings.
	/// </para>
	/// </summary>
	public bool? RequestCache { get => Q<bool?>("request_cache"); set => Q("request_cache", value); }

	/// <summary>
	/// <para>
	/// Indicates whether <c>hits.total</c> should be rendered as an integer or an object in the rest search response.
	/// </para>
	/// </summary>
	public bool? RestTotalHitsAsInt { get => Q<bool?>("rest_total_hits_as_int"); set => Q("rest_total_hits_as_int", value); }

	/// <summary>
	/// <para>
	/// Custom value used to route operations to a specific shard.
	/// </para>
	/// </summary>
	public Elastic.Clients.Elasticsearch.Routing? Routing { get => Q<Elastic.Clients.Elasticsearch.Routing?>("routing"); set => Q("routing", value); }

	/// <summary>
	/// <para>
	/// Period to retain the search context for scrolling. See Scroll search results.
	/// By default, this value cannot exceed <c>1d</c> (24 hours).
	/// You can change this limit using the <c>search.max_keep_alive</c> cluster-level setting.
	/// </para>
	/// </summary>
	public Elastic.Clients.Elasticsearch.Duration? Scroll { get => Q<Elastic.Clients.Elasticsearch.Duration?>("scroll"); set => Q("scroll", value); }

	/// <summary>
	/// <para>
	/// How distributed term frequencies are calculated for relevance scoring.
	/// </para>
	/// </summary>
	public Elastic.Clients.Elasticsearch.SearchType? SearchType { get => Q<Elastic.Clients.Elasticsearch.SearchType?>("search_type"); set => Q("search_type", value); }

	/// <summary>
	/// <para>
	/// A comma-separated list of source fields to exclude from the response.
	/// You can also use this parameter to exclude fields from the subset specified in <c>_source_includes</c> query parameter.
	/// If the <c>_source</c> parameter is <c>false</c>, this parameter is ignored.
	/// </para>
	/// </summary>
	public Elastic.Clients.Elasticsearch.Fields? SourceExcludes { get => Q<Elastic.Clients.Elasticsearch.Fields?>("_source_excludes"); set => Q("_source_excludes", value); }

	/// <summary>
	/// <para>
	/// A comma-separated list of source fields to include in the response.
	/// If this parameter is specified, only these source fields are returned.
	/// You can exclude fields from this subset using the <c>_source_excludes</c> query parameter.
	/// If the <c>_source</c> parameter is <c>false</c>, this parameter is ignored.
	/// </para>
	/// </summary>
	public Elastic.Clients.Elasticsearch.Fields? SourceIncludes { get => Q<Elastic.Clients.Elasticsearch.Fields?>("_source_includes"); set => Q("_source_includes", value); }

	/// <summary>
	/// <para>
	/// Specifies which field to use for suggestions.
	/// </para>
	/// </summary>
	public Elastic.Clients.Elasticsearch.Field? SuggestField { get => Q<Elastic.Clients.Elasticsearch.Field?>("suggest_field"); set => Q("suggest_field", value); }

	/// <summary>
	/// <para>
	/// Specifies the suggest mode.
	/// This parameter can only be used when the <c>suggest_field</c> and <c>suggest_text</c> query string parameters are specified.
	/// </para>
	/// </summary>
	public Elastic.Clients.Elasticsearch.SuggestMode? SuggestMode { get => Q<Elastic.Clients.Elasticsearch.SuggestMode?>("suggest_mode"); set => Q("suggest_mode", value); }

	/// <summary>
	/// <para>
	/// Number of suggestions to return.
	/// This parameter can only be used when the <c>suggest_field</c> and <c>suggest_text</c> query string parameters are specified.
	/// </para>
	/// </summary>
	public long? SuggestSize { get => Q<long?>("suggest_size"); set => Q("suggest_size", value); }

	/// <summary>
	/// <para>
	/// The source text for which the suggestions should be returned.
	/// This parameter can only be used when the <c>suggest_field</c> and <c>suggest_text</c> query string parameters are specified.
	/// </para>
	/// </summary>
	public string? SuggestText { get => Q<string?>("suggest_text"); set => Q("suggest_text", value); }

	/// <summary>
	/// <para>
	/// If <c>true</c>, aggregation and suggester names are be prefixed by their respective types in the response.
	/// </para>
	/// </summary>
	public bool? TypedKeys { get => Q<bool?>("typed_keys"); set => Q("typed_keys", value); }
}

internal sealed partial class SearchRequestConverter : JsonConverter<SearchRequest>
{
	public override SearchRequest Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
	{
		if (reader.TokenType != JsonTokenType.StartObject)
			throw new JsonException("Unexpected JSON detected.");
		var variant = new SearchRequest();
		while (reader.Read() && reader.TokenType != JsonTokenType.EndObject)
		{
			if (reader.TokenType == JsonTokenType.PropertyName)
			{
				var property = reader.GetString();
				if (property == "aggregations" || property == "aggs")
				{
					variant.Aggregations = JsonSerializer.Deserialize<IDictionary<string, Elastic.Clients.Elasticsearch.Aggregations.Aggregation>?>(ref reader, options);
					continue;
				}

				if (property == "collapse")
				{
					variant.Collapse = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Core.Search.FieldCollapse?>(ref reader, options);
					continue;
				}

				if (property == "docvalue_fields")
				{
					variant.DocvalueFields = JsonSerializer.Deserialize<ICollection<Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormat>?>(ref reader, options);
					continue;
				}

				if (property == "explain")
				{
					variant.Explain = JsonSerializer.Deserialize<bool?>(ref reader, options);
					continue;
				}

				if (property == "ext")
				{
					variant.Ext = JsonSerializer.Deserialize<IDictionary<string, object>?>(ref reader, options);
					continue;
				}

				if (property == "fields")
				{
					variant.Fields = JsonSerializer.Deserialize<ICollection<Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormat>?>(ref reader, options);
					continue;
				}

				if (property == "from")
				{
					variant.From = JsonSerializer.Deserialize<int?>(ref reader, options);
					continue;
				}

				if (property == "highlight")
				{
					variant.Highlight = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Core.Search.Highlight?>(ref reader, options);
					continue;
				}

				if (property == "indices_boost")
				{
					variant.IndicesBoost = JsonSerializer.Deserialize<ICollection<IDictionary<Elastic.Clients.Elasticsearch.IndexName, double>>?>(ref reader, options);
					continue;
				}

				if (property == "knn")
				{
					variant.Knn = JsonSerializer.Deserialize<ICollection<Elastic.Clients.Elasticsearch.KnnSearch>?>(ref reader, options);
					continue;
				}

				if (property == "min_score")
				{
					variant.MinScore = JsonSerializer.Deserialize<double?>(ref reader, options);
					continue;
				}

				if (property == "pit")
				{
					variant.Pit = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Core.Search.PointInTimeReference?>(ref reader, options);
					continue;
				}

				if (property == "post_filter")
				{
					variant.PostFilter = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.Query?>(ref reader, options);
					continue;
				}

				if (property == "profile")
				{
					variant.Profile = JsonSerializer.Deserialize<bool?>(ref reader, options);
					continue;
				}

				if (property == "query")
				{
					variant.Query = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.Query?>(ref reader, options);
					continue;
				}

				if (property == "rank")
				{
					variant.Rank = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Rank?>(ref reader, options);
					continue;
				}

				if (property == "rescore")
				{
					variant.Rescore = JsonSerializer.Deserialize<ICollection<Elastic.Clients.Elasticsearch.Core.Search.Rescore>?>(ref reader, options);
					continue;
				}

				if (property == "retriever")
				{
					variant.Retriever = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Retriever?>(ref reader, options);
					continue;
				}

				if (property == "runtime_mappings")
				{
					variant.RuntimeMappings = JsonSerializer.Deserialize<IDictionary<Elastic.Clients.Elasticsearch.Field, Elastic.Clients.Elasticsearch.Mapping.RuntimeField>?>(ref reader, options);
					continue;
				}

				if (property == "script_fields")
				{
					variant.ScriptFields = JsonSerializer.Deserialize<IDictionary<string, Elastic.Clients.Elasticsearch.ScriptField>?>(ref reader, options);
					continue;
				}

				if (property == "search_after")
				{
					variant.SearchAfter = JsonSerializer.Deserialize<ICollection<Elastic.Clients.Elasticsearch.FieldValue>?>(ref reader, options);
					continue;
				}

				if (property == "seq_no_primary_term")
				{
					variant.SeqNoPrimaryTerm = JsonSerializer.Deserialize<bool?>(ref reader, options);
					continue;
				}

				if (property == "size")
				{
					variant.Size = JsonSerializer.Deserialize<int?>(ref reader, options);
					continue;
				}

				if (property == "slice")
				{
					variant.Slice = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.SlicedScroll?>(ref reader, options);
					continue;
				}

				if (property == "sort")
				{
					variant.Sort = JsonSerializer.Deserialize<ICollection<Elastic.Clients.Elasticsearch.SortOptions>?>(ref reader, options);
					continue;
				}

				if (property == "_source")
				{
					variant.Source = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Core.Search.SourceConfig?>(ref reader, options);
					continue;
				}

				if (property == "stats")
				{
					variant.Stats = JsonSerializer.Deserialize<ICollection<string>?>(ref reader, options);
					continue;
				}

				if (property == "stored_fields")
				{
					variant.StoredFields = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Fields?>(ref reader, options);
					continue;
				}

				if (property == "suggest")
				{
					variant.Suggest = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Core.Search.Suggester?>(ref reader, options);
					continue;
				}

				if (property == "terminate_after")
				{
					variant.TerminateAfter = JsonSerializer.Deserialize<long?>(ref reader, options);
					continue;
				}

				if (property == "timeout")
				{
					variant.Timeout = JsonSerializer.Deserialize<string?>(ref reader, options);
					continue;
				}

				if (property == "track_scores")
				{
					variant.TrackScores = JsonSerializer.Deserialize<bool?>(ref reader, options);
					continue;
				}

				if (property == "track_total_hits")
				{
					variant.TrackTotalHits = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Core.Search.TrackHits?>(ref reader, options);
					continue;
				}

				if (property == "version")
				{
					variant.Version = JsonSerializer.Deserialize<bool?>(ref reader, options);
					continue;
				}
			}
		}

		return variant;
	}

	public override void Write(Utf8JsonWriter writer, SearchRequest value, JsonSerializerOptions options)
	{
		writer.WriteStartObject();
		if (value.Aggregations is not null)
		{
			writer.WritePropertyName("aggregations");
			JsonSerializer.Serialize(writer, value.Aggregations, options);
		}

		if (value.Collapse is not null)
		{
			writer.WritePropertyName("collapse");
			JsonSerializer.Serialize(writer, value.Collapse, options);
		}

		if (value.DocvalueFields is not null)
		{
			writer.WritePropertyName("docvalue_fields");
			JsonSerializer.Serialize(writer, value.DocvalueFields, options);
		}

		if (value.Explain.HasValue)
		{
			writer.WritePropertyName("explain");
			writer.WriteBooleanValue(value.Explain.Value);
		}

		if (value.Ext is not null)
		{
			writer.WritePropertyName("ext");
			JsonSerializer.Serialize(writer, value.Ext, options);
		}

		if (value.Fields is not null)
		{
			writer.WritePropertyName("fields");
			JsonSerializer.Serialize(writer, value.Fields, options);
		}

		if (value.From.HasValue)
		{
			writer.WritePropertyName("from");
			writer.WriteNumberValue(value.From.Value);
		}

		if (value.Highlight is not null)
		{
			writer.WritePropertyName("highlight");
			JsonSerializer.Serialize(writer, value.Highlight, options);
		}

		if (value.IndicesBoost is not null)
		{
			writer.WritePropertyName("indices_boost");
			JsonSerializer.Serialize(writer, value.IndicesBoost, options);
		}

		if (value.Knn is not null)
		{
			writer.WritePropertyName("knn");
			JsonSerializer.Serialize(writer, value.Knn, options);
		}

		if (value.MinScore.HasValue)
		{
			writer.WritePropertyName("min_score");
			writer.WriteNumberValue(value.MinScore.Value);
		}

		if (value.Pit is not null)
		{
			writer.WritePropertyName("pit");
			JsonSerializer.Serialize(writer, value.Pit, options);
		}

		if (value.PostFilter is not null)
		{
			writer.WritePropertyName("post_filter");
			JsonSerializer.Serialize(writer, value.PostFilter, options);
		}

		if (value.Profile.HasValue)
		{
			writer.WritePropertyName("profile");
			writer.WriteBooleanValue(value.Profile.Value);
		}

		if (value.Query is not null)
		{
			writer.WritePropertyName("query");
			JsonSerializer.Serialize(writer, value.Query, options);
		}

		if (value.Rank is not null)
		{
			writer.WritePropertyName("rank");
			JsonSerializer.Serialize(writer, value.Rank, options);
		}

		if (value.Rescore is not null)
		{
			writer.WritePropertyName("rescore");
			JsonSerializer.Serialize(writer, value.Rescore, options);
		}

		if (value.Retriever is not null)
		{
			writer.WritePropertyName("retriever");
			JsonSerializer.Serialize(writer, value.Retriever, options);
		}

		if (value.RuntimeMappings is not null)
		{
			writer.WritePropertyName("runtime_mappings");
			JsonSerializer.Serialize(writer, value.RuntimeMappings, options);
		}

		if (value.ScriptFields is not null)
		{
			writer.WritePropertyName("script_fields");
			JsonSerializer.Serialize(writer, value.ScriptFields, options);
		}

		if (value.SearchAfter is not null)
		{
			writer.WritePropertyName("search_after");
			JsonSerializer.Serialize(writer, value.SearchAfter, options);
		}

		if (value.SeqNoPrimaryTerm.HasValue)
		{
			writer.WritePropertyName("seq_no_primary_term");
			writer.WriteBooleanValue(value.SeqNoPrimaryTerm.Value);
		}

		if (value.Size.HasValue)
		{
			writer.WritePropertyName("size");
			writer.WriteNumberValue(value.Size.Value);
		}

		if (value.Slice is not null)
		{
			writer.WritePropertyName("slice");
			JsonSerializer.Serialize(writer, value.Slice, options);
		}

		if (value.Sort is not null)
		{
			writer.WritePropertyName("sort");
			JsonSerializer.Serialize(writer, value.Sort, options);
		}

		if (value.Source is not null)
		{
			writer.WritePropertyName("_source");
			JsonSerializer.Serialize(writer, value.Source, options);
		}

		if (value.Stats is not null)
		{
			writer.WritePropertyName("stats");
			JsonSerializer.Serialize(writer, value.Stats, options);
		}

		if (value.StoredFields is not null)
		{
			writer.WritePropertyName("stored_fields");
			new FieldsConverter().Write(writer, value.StoredFields, options);
		}

		if (value.Suggest is not null)
		{
			writer.WritePropertyName("suggest");
			JsonSerializer.Serialize(writer, value.Suggest, options);
		}

		if (value.TerminateAfter.HasValue)
		{
			writer.WritePropertyName("terminate_after");
			writer.WriteNumberValue(value.TerminateAfter.Value);
		}

		if (!string.IsNullOrEmpty(value.Timeout))
		{
			writer.WritePropertyName("timeout");
			writer.WriteStringValue(value.Timeout);
		}

		if (value.TrackScores.HasValue)
		{
			writer.WritePropertyName("track_scores");
			writer.WriteBooleanValue(value.TrackScores.Value);
		}

		if (value.TrackTotalHits is not null)
		{
			writer.WritePropertyName("track_total_hits");
			JsonSerializer.Serialize(writer, value.TrackTotalHits, options);
		}

		if (value.Version.HasValue)
		{
			writer.WritePropertyName("version");
			writer.WriteBooleanValue(value.Version.Value);
		}

		writer.WriteEndObject();
	}
}

/// <summary>
/// <para>
/// Returns search hits that match the query defined in the request.
/// You can provide search queries using the <c>q</c> query string parameter or the request body.
/// If both are specified, only the query parameter is used.
/// </para>
/// </summary>
[JsonConverter(typeof(SearchRequestConverter))]
public partial class SearchRequest : PlainRequest<SearchRequestParameters>
{
	public SearchRequest()
	{
	}

	public SearchRequest(Elastic.Clients.Elasticsearch.Indices? indices) : base(r => r.Optional("index", indices))
	{
	}

	internal override ApiUrls ApiUrls => ApiUrlLookup.NoNamespaceSearch;

	protected override HttpMethod StaticHttpMethod => HttpMethod.POST;

	internal override bool SupportsBody => true;

	internal override string OperationName => "search";

	/// <summary>
	/// <para>
	/// If <c>false</c>, the request returns an error if any wildcard expression, index alias, or <c>_all</c> value targets only missing or closed indices.
	/// This behavior applies even if the request targets other open indices.
	/// For example, a request targeting <c>foo*,bar*</c> returns an error if an index starts with <c>foo</c> but no index starts with <c>bar</c>.
	/// </para>
	/// </summary>
	[JsonIgnore]
	public bool? AllowNoIndices { get => Q<bool?>("allow_no_indices"); set => Q("allow_no_indices", value); }

	/// <summary>
	/// <para>
	/// If true, returns partial results if there are shard request timeouts or shard failures. If false, returns an error with no partial results.
	/// </para>
	/// </summary>
	[JsonIgnore]
	public bool? AllowPartialSearchResults { get => Q<bool?>("allow_partial_search_results"); set => Q("allow_partial_search_results", value); }

	/// <summary>
	/// <para>
	/// Analyzer to use for the query string.
	/// This parameter can only be used when the q query string parameter is specified.
	/// </para>
	/// </summary>
	[JsonIgnore]
	public string? Analyzer { get => Q<string?>("analyzer"); set => Q("analyzer", value); }

	/// <summary>
	/// <para>
	/// If true, wildcard and prefix queries are analyzed.
	/// This parameter can only be used when the q query string parameter is specified.
	/// </para>
	/// </summary>
	[JsonIgnore]
	public bool? AnalyzeWildcard { get => Q<bool?>("analyze_wildcard"); set => Q("analyze_wildcard", value); }

	/// <summary>
	/// <para>
	/// The number of shard results that should be reduced at once on the coordinating node.
	/// This value should be used as a protection mechanism to reduce the memory overhead per search request if the potential number of shards in the request can be large.
	/// </para>
	/// </summary>
	[JsonIgnore]
	public long? BatchedReduceSize { get => Q<long?>("batched_reduce_size"); set => Q("batched_reduce_size", value); }

	/// <summary>
	/// <para>
	/// If true, network round-trips between the coordinating node and the remote clusters are minimized when executing cross-cluster search (CCS) requests.
	/// </para>
	/// </summary>
	[JsonIgnore]
	public bool? CcsMinimizeRoundtrips { get => Q<bool?>("ccs_minimize_roundtrips"); set => Q("ccs_minimize_roundtrips", value); }

	/// <summary>
	/// <para>
	/// The default operator for query string query: AND or OR.
	/// This parameter can only be used when the <c>q</c> query string parameter is specified.
	/// </para>
	/// </summary>
	[JsonIgnore]
	public Elastic.Clients.Elasticsearch.QueryDsl.Operator? DefaultOperator { get => Q<Elastic.Clients.Elasticsearch.QueryDsl.Operator?>("default_operator"); set => Q("default_operator", value); }

	/// <summary>
	/// <para>
	/// Field to use as default where no field prefix is given in the query string.
	/// This parameter can only be used when the q query string parameter is specified.
	/// </para>
	/// </summary>
	[JsonIgnore]
	public string? Df { get => Q<string?>("df"); set => Q("df", value); }

	/// <summary>
	/// <para>
	/// Type of index that wildcard patterns can match.
	/// If the request can target data streams, this argument determines whether wildcard expressions match hidden data streams.
	/// Supports comma-separated values, such as <c>open,hidden</c>.
	/// </para>
	/// </summary>
	[JsonIgnore]
	public ICollection<Elastic.Clients.Elasticsearch.ExpandWildcard>? ExpandWildcards { get => Q<ICollection<Elastic.Clients.Elasticsearch.ExpandWildcard>?>("expand_wildcards"); set => Q("expand_wildcards", value); }

	/// <summary>
	/// <para>
	/// Should this request force synthetic _source?
	/// Use this to test if the mapping supports synthetic _source and to get a sense of the worst case performance.
	/// Fetches with this enabled will be slower the enabling synthetic source natively in the index.
	/// </para>
	/// </summary>
	[JsonIgnore]
	public bool? ForceSyntheticSource { get => Q<bool?>("force_synthetic_source"); set => Q("force_synthetic_source", value); }

	/// <summary>
	/// <para>
	/// If <c>true</c>, concrete, expanded or aliased indices will be ignored when frozen.
	/// </para>
	/// </summary>
	[JsonIgnore]
	public bool? IgnoreThrottled { get => Q<bool?>("ignore_throttled"); set => Q("ignore_throttled", value); }

	/// <summary>
	/// <para>
	/// If <c>false</c>, the request returns an error if it targets a missing or closed index.
	/// </para>
	/// </summary>
	[JsonIgnore]
	public bool? IgnoreUnavailable { get => Q<bool?>("ignore_unavailable"); set => Q("ignore_unavailable", value); }

	/// <summary>
	/// <para>
	/// If <c>true</c>, format-based query failures (such as providing text to a numeric field) in the query string will be ignored.
	/// This parameter can only be used when the <c>q</c> query string parameter is specified.
	/// </para>
	/// </summary>
	[JsonIgnore]
	public bool? Lenient { get => Q<bool?>("lenient"); set => Q("lenient", value); }

	/// <summary>
	/// <para>
	/// Defines the number of concurrent shard requests per node this search executes concurrently.
	/// This value should be used to limit the impact of the search on the cluster in order to limit the number of concurrent shard requests.
	/// </para>
	/// </summary>
	[JsonIgnore]
	public long? MaxConcurrentShardRequests { get => Q<long?>("max_concurrent_shard_requests"); set => Q("max_concurrent_shard_requests", value); }

	/// <summary>
	/// <para>
	/// The minimum version of the node that can handle the request
	/// Any handling node with a lower version will fail the request.
	/// </para>
	/// </summary>
	[JsonIgnore]
	public string? MinCompatibleShardNode { get => Q<string?>("min_compatible_shard_node"); set => Q("min_compatible_shard_node", value); }

	/// <summary>
	/// <para>
	/// Nodes and shards used for the search.
	/// By default, Elasticsearch selects from eligible nodes and shards using adaptive replica selection, accounting for allocation awareness. Valid values are:
	/// <c>_only_local</c> to run the search only on shards on the local node;
	/// <c>_local</c> to, if possible, run the search on shards on the local node, or if not, select shards using the default method;
	/// <c>_only_nodes:&lt;node-id>,&lt;node-id></c> to run the search on only the specified nodes IDs, where, if suitable shards exist on more than one selected node, use shards on those nodes using the default method, or if none of the specified nodes are available, select shards from any available node using the default method;
	/// <c>_prefer_nodes:&lt;node-id>,&lt;node-id></c> to if possible, run the search on the specified nodes IDs, or if not, select shards using the default method;
	/// <c>_shards:&lt;shard>,&lt;shard></c> to run the search only on the specified shards;
	/// <c>&lt;custom-string></c> (any string that does not start with <c>_</c>) to route searches with the same <c>&lt;custom-string></c> to the same shards in the same order.
	/// </para>
	/// </summary>
	[JsonIgnore]
	public string? Preference { get => Q<string?>("preference"); set => Q("preference", value); }

	/// <summary>
	/// <para>
	/// Defines a threshold that enforces a pre-filter roundtrip to prefilter search shards based on query rewriting if the number of shards the search request expands to exceeds the threshold.
	/// This filter roundtrip can limit the number of shards significantly if for instance a shard can not match any documents based on its rewrite method (if date filters are mandatory to match but the shard bounds and the query are disjoint).
	/// When unspecified, the pre-filter phase is executed if any of these conditions is met:
	/// the request targets more than 128 shards;
	/// the request targets one or more read-only index;
	/// the primary sort of the query targets an indexed field.
	/// </para>
	/// </summary>
	[JsonIgnore]
	public long? PreFilterShardSize { get => Q<long?>("pre_filter_shard_size"); set => Q("pre_filter_shard_size", value); }

	/// <summary>
	/// <para>
	/// Query in the Lucene query string syntax using query parameter search.
	/// Query parameter searches do not support the full Elasticsearch Query DSL but are handy for testing.
	/// </para>
	/// </summary>
	[JsonIgnore]
	public string? QueryLuceneSyntax { get => Q<string?>("q"); set => Q("q", value); }

	/// <summary>
	/// <para>
	/// If <c>true</c>, the caching of search results is enabled for requests where <c>size</c> is <c>0</c>.
	/// Defaults to index level settings.
	/// </para>
	/// </summary>
	[JsonIgnore]
	public bool? RequestCache { get => Q<bool?>("request_cache"); set => Q("request_cache", value); }

	/// <summary>
	/// <para>
	/// Indicates whether <c>hits.total</c> should be rendered as an integer or an object in the rest search response.
	/// </para>
	/// </summary>
	[JsonIgnore]
	public bool? RestTotalHitsAsInt { get => Q<bool?>("rest_total_hits_as_int"); set => Q("rest_total_hits_as_int", value); }

	/// <summary>
	/// <para>
	/// Custom value used to route operations to a specific shard.
	/// </para>
	/// </summary>
	[JsonIgnore]
	public Elastic.Clients.Elasticsearch.Routing? Routing { get => Q<Elastic.Clients.Elasticsearch.Routing?>("routing"); set => Q("routing", value); }

	/// <summary>
	/// <para>
	/// Period to retain the search context for scrolling. See Scroll search results.
	/// By default, this value cannot exceed <c>1d</c> (24 hours).
	/// You can change this limit using the <c>search.max_keep_alive</c> cluster-level setting.
	/// </para>
	/// </summary>
	[JsonIgnore]
	public Elastic.Clients.Elasticsearch.Duration? Scroll { get => Q<Elastic.Clients.Elasticsearch.Duration?>("scroll"); set => Q("scroll", value); }

	/// <summary>
	/// <para>
	/// How distributed term frequencies are calculated for relevance scoring.
	/// </para>
	/// </summary>
	[JsonIgnore]
	public Elastic.Clients.Elasticsearch.SearchType? SearchType { get => Q<Elastic.Clients.Elasticsearch.SearchType?>("search_type"); set => Q("search_type", value); }

	/// <summary>
	/// <para>
	/// A comma-separated list of source fields to exclude from the response.
	/// You can also use this parameter to exclude fields from the subset specified in <c>_source_includes</c> query parameter.
	/// If the <c>_source</c> parameter is <c>false</c>, this parameter is ignored.
	/// </para>
	/// </summary>
	[JsonIgnore]
	public Elastic.Clients.Elasticsearch.Fields? SourceExcludes { get => Q<Elastic.Clients.Elasticsearch.Fields?>("_source_excludes"); set => Q("_source_excludes", value); }

	/// <summary>
	/// <para>
	/// A comma-separated list of source fields to include in the response.
	/// If this parameter is specified, only these source fields are returned.
	/// You can exclude fields from this subset using the <c>_source_excludes</c> query parameter.
	/// If the <c>_source</c> parameter is <c>false</c>, this parameter is ignored.
	/// </para>
	/// </summary>
	[JsonIgnore]
	public Elastic.Clients.Elasticsearch.Fields? SourceIncludes { get => Q<Elastic.Clients.Elasticsearch.Fields?>("_source_includes"); set => Q("_source_includes", value); }

	/// <summary>
	/// <para>
	/// Specifies which field to use for suggestions.
	/// </para>
	/// </summary>
	[JsonIgnore]
	public Elastic.Clients.Elasticsearch.Field? SuggestField { get => Q<Elastic.Clients.Elasticsearch.Field?>("suggest_field"); set => Q("suggest_field", value); }

	/// <summary>
	/// <para>
	/// Specifies the suggest mode.
	/// This parameter can only be used when the <c>suggest_field</c> and <c>suggest_text</c> query string parameters are specified.
	/// </para>
	/// </summary>
	[JsonIgnore]
	public Elastic.Clients.Elasticsearch.SuggestMode? SuggestMode { get => Q<Elastic.Clients.Elasticsearch.SuggestMode?>("suggest_mode"); set => Q("suggest_mode", value); }

	/// <summary>
	/// <para>
	/// Number of suggestions to return.
	/// This parameter can only be used when the <c>suggest_field</c> and <c>suggest_text</c> query string parameters are specified.
	/// </para>
	/// </summary>
	[JsonIgnore]
	public long? SuggestSize { get => Q<long?>("suggest_size"); set => Q("suggest_size", value); }

	/// <summary>
	/// <para>
	/// The source text for which the suggestions should be returned.
	/// This parameter can only be used when the <c>suggest_field</c> and <c>suggest_text</c> query string parameters are specified.
	/// </para>
	/// </summary>
	[JsonIgnore]
	public string? SuggestText { get => Q<string?>("suggest_text"); set => Q("suggest_text", value); }

	/// <summary>
	/// <para>
	/// If <c>true</c>, aggregation and suggester names are be prefixed by their respective types in the response.
	/// </para>
	/// </summary>
	[JsonIgnore]
	public bool? TypedKeys { get => Q<bool?>("typed_keys"); set => Q("typed_keys", value); }

	/// <summary>
	/// <para>
	/// Defines the aggregations that are run as part of the search request.
	/// </para>
	/// </summary>
	[JsonInclude, JsonPropertyName("aggregations")]
	public IDictionary<string, Elastic.Clients.Elasticsearch.Aggregations.Aggregation>? Aggregations { get; set; }

	/// <summary>
	/// <para>
	/// Collapses search results the values of the specified field.
	/// </para>
	/// </summary>
	[JsonInclude, JsonPropertyName("collapse")]
	public Elastic.Clients.Elasticsearch.Core.Search.FieldCollapse? Collapse { get; set; }

	/// <summary>
	/// <para>
	/// Array of wildcard (<c>*</c>) patterns.
	/// The request returns doc values for field names matching these patterns in the <c>hits.fields</c> property of the response.
	/// </para>
	/// </summary>
	[JsonInclude, JsonPropertyName("docvalue_fields")]
	public ICollection<Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormat>? DocvalueFields { get; set; }

	/// <summary>
	/// <para>
	/// If true, returns detailed information about score computation as part of a hit.
	/// </para>
	/// </summary>
	[JsonInclude, JsonPropertyName("explain")]
	public bool? Explain { get; set; }

	/// <summary>
	/// <para>
	/// Configuration of search extensions defined by Elasticsearch plugins.
	/// </para>
	/// </summary>
	[JsonInclude, JsonPropertyName("ext")]
	public IDictionary<string, object>? Ext { get; set; }

	/// <summary>
	/// <para>
	/// Array of wildcard (<c>*</c>) patterns.
	/// The request returns values for field names matching these patterns in the <c>hits.fields</c> property of the response.
	/// </para>
	/// </summary>
	[JsonInclude, JsonPropertyName("fields")]
	public ICollection<Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormat>? Fields { get; set; }

	/// <summary>
	/// <para>
	/// Starting document offset.
	/// Needs to be non-negative.
	/// By default, you cannot page through more than 10,000 hits using the <c>from</c> and <c>size</c> parameters.
	/// To page through more hits, use the <c>search_after</c> parameter.
	/// </para>
	/// </summary>
	[JsonInclude, JsonPropertyName("from")]
	public int? From { get; set; }

	/// <summary>
	/// <para>
	/// Specifies the highlighter to use for retrieving highlighted snippets from one or more fields in your search results.
	/// </para>
	/// </summary>
	[JsonInclude, JsonPropertyName("highlight")]
	public Elastic.Clients.Elasticsearch.Core.Search.Highlight? Highlight { get; set; }

	/// <summary>
	/// <para>
	/// Boosts the _score of documents from specified indices.
	/// </para>
	/// </summary>
	[JsonInclude, JsonPropertyName("indices_boost")]
	public ICollection<IDictionary<Elastic.Clients.Elasticsearch.IndexName, double>>? IndicesBoost { get; set; }

	/// <summary>
	/// <para>
	/// Defines the approximate kNN search to run.
	/// </para>
	/// </summary>
	[JsonInclude, JsonPropertyName("knn")]
	[SingleOrManyCollectionConverter(typeof(Elastic.Clients.Elasticsearch.KnnSearch))]
	public ICollection<Elastic.Clients.Elasticsearch.KnnSearch>? Knn { get; set; }

	/// <summary>
	/// <para>
	/// Minimum <c>_score</c> for matching documents.
	/// Documents with a lower <c>_score</c> are not included in the search results.
	/// </para>
	/// </summary>
	[JsonInclude, JsonPropertyName("min_score")]
	public double? MinScore { get; set; }

	/// <summary>
	/// <para>
	/// Limits the search to a point in time (PIT).
	/// If you provide a PIT, you cannot specify an <c>&lt;index></c> in the request path.
	/// </para>
	/// </summary>
	[JsonInclude, JsonPropertyName("pit")]
	public Elastic.Clients.Elasticsearch.Core.Search.PointInTimeReference? Pit { get; set; }

	/// <summary>
	/// <para>
	/// Use the <c>post_filter</c> parameter to filter search results.
	/// The search hits are filtered after the aggregations are calculated.
	/// A post filter has no impact on the aggregation results.
	/// </para>
	/// </summary>
	[JsonInclude, JsonPropertyName("post_filter")]
	public Elastic.Clients.Elasticsearch.QueryDsl.Query? PostFilter { get; set; }

	/// <summary>
	/// <para>
	/// Set to <c>true</c> to return detailed timing information about the execution of individual components in a search request.
	/// NOTE: This is a debugging tool and adds significant overhead to search execution.
	/// </para>
	/// </summary>
	[JsonInclude, JsonPropertyName("profile")]
	public bool? Profile { get; set; }

	/// <summary>
	/// <para>
	/// Defines the search definition using the Query DSL.
	/// </para>
	/// </summary>
	[JsonInclude, JsonPropertyName("query")]
	public Elastic.Clients.Elasticsearch.QueryDsl.Query? Query { get; set; }

	/// <summary>
	/// <para>
	/// Defines the Reciprocal Rank Fusion (RRF) to use.
	/// </para>
	/// </summary>
	[JsonInclude, JsonPropertyName("rank")]
	public Elastic.Clients.Elasticsearch.Rank? Rank { get; set; }

	/// <summary>
	/// <para>
	/// Can be used to improve precision by reordering just the top (for example 100 - 500) documents returned by the <c>query</c> and <c>post_filter</c> phases.
	/// </para>
	/// </summary>
	[JsonInclude, JsonPropertyName("rescore")]
	[SingleOrManyCollectionConverter(typeof(Elastic.Clients.Elasticsearch.Core.Search.Rescore))]
	public ICollection<Elastic.Clients.Elasticsearch.Core.Search.Rescore>? Rescore { get; set; }

	/// <summary>
	/// <para>
	/// A retriever is a specification to describe top documents returned from a search. A retriever replaces other elements of the search API that also return top documents such as query and knn.
	/// </para>
	/// </summary>
	[JsonInclude, JsonPropertyName("retriever")]
	public Elastic.Clients.Elasticsearch.Retriever? Retriever { get; set; }

	/// <summary>
	/// <para>
	/// Defines one or more runtime fields in the search request.
	/// These fields take precedence over mapped fields with the same name.
	/// </para>
	/// </summary>
	[JsonInclude, JsonPropertyName("runtime_mappings")]
	public IDictionary<Elastic.Clients.Elasticsearch.Field, Elastic.Clients.Elasticsearch.Mapping.RuntimeField>? RuntimeMappings { get; set; }

	/// <summary>
	/// <para>
	/// Retrieve a script evaluation (based on different fields) for each hit.
	/// </para>
	/// </summary>
	[JsonInclude, JsonPropertyName("script_fields")]
	public IDictionary<string, Elastic.Clients.Elasticsearch.ScriptField>? ScriptFields { get; set; }

	/// <summary>
	/// <para>
	/// Used to retrieve the next page of hits using a set of sort values from the previous page.
	/// </para>
	/// </summary>
	[JsonInclude, JsonPropertyName("search_after")]
	public ICollection<Elastic.Clients.Elasticsearch.FieldValue>? SearchAfter { get; set; }

	/// <summary>
	/// <para>
	/// If <c>true</c>, returns sequence number and primary term of the last modification of each hit.
	/// </para>
	/// </summary>
	[JsonInclude, JsonPropertyName("seq_no_primary_term")]
	public bool? SeqNoPrimaryTerm { get; set; }

	/// <summary>
	/// <para>
	/// The number of hits to return.
	/// By default, you cannot page through more than 10,000 hits using the <c>from</c> and <c>size</c> parameters.
	/// To page through more hits, use the <c>search_after</c> parameter.
	/// </para>
	/// </summary>
	[JsonInclude, JsonPropertyName("size")]
	public int? Size { get; set; }

	/// <summary>
	/// <para>
	/// Can be used to split a scrolled search into multiple slices that can be consumed independently.
	/// </para>
	/// </summary>
	[JsonInclude, JsonPropertyName("slice")]
	public Elastic.Clients.Elasticsearch.SlicedScroll? Slice { get; set; }

	/// <summary>
	/// <para>
	/// A comma-separated list of &lt;field>:&lt;direction> pairs.
	/// </para>
	/// </summary>
	[JsonInclude, JsonPropertyName("sort")]
	[SingleOrManyCollectionConverter(typeof(Elastic.Clients.Elasticsearch.SortOptions))]
	public ICollection<Elastic.Clients.Elasticsearch.SortOptions>? Sort { get; set; }

	/// <summary>
	/// <para>
	/// Indicates which source fields are returned for matching documents.
	/// These fields are returned in the hits._source property of the search response.
	/// </para>
	/// </summary>
	[JsonInclude, JsonPropertyName("_source")]
	public Elastic.Clients.Elasticsearch.Core.Search.SourceConfig? Source { get; set; }

	/// <summary>
	/// <para>
	/// Stats groups to associate with the search.
	/// Each group maintains a statistics aggregation for its associated searches.
	/// You can retrieve these stats using the indices stats API.
	/// </para>
	/// </summary>
	[JsonInclude, JsonPropertyName("stats")]
	public ICollection<string>? Stats { get; set; }

	/// <summary>
	/// <para>
	/// List of stored fields to return as part of a hit.
	/// If no fields are specified, no stored fields are included in the response.
	/// If this field is specified, the <c>_source</c> parameter defaults to <c>false</c>.
	/// You can pass <c>_source: true</c> to return both source fields and stored fields in the search response.
	/// </para>
	/// </summary>
	[JsonInclude, JsonPropertyName("stored_fields")]
	[JsonConverter(typeof(SingleOrManyFieldsConverter))]
	public Elastic.Clients.Elasticsearch.Fields? StoredFields { get; set; }

	/// <summary>
	/// <para>
	/// Defines a suggester that provides similar looking terms based on a provided text.
	/// </para>
	/// </summary>
	[JsonInclude, JsonPropertyName("suggest")]
	public Elastic.Clients.Elasticsearch.Core.Search.Suggester? Suggest { get; set; }

	/// <summary>
	/// <para>
	/// Maximum number of documents to collect for each shard.
	/// If a query reaches this limit, Elasticsearch terminates the query early.
	/// Elasticsearch collects documents before sorting.
	/// Use with caution.
	/// Elasticsearch applies this parameter to each shard handling the request.
	/// When possible, let Elasticsearch perform early termination automatically.
	/// Avoid specifying this parameter for requests that target data streams with backing indices across multiple data tiers.
	/// If set to <c>0</c> (default), the query does not terminate early.
	/// </para>
	/// </summary>
	[JsonInclude, JsonPropertyName("terminate_after")]
	public long? TerminateAfter { get; set; }

	/// <summary>
	/// <para>
	/// Specifies the period of time to wait for a response from each shard.
	/// If no response is received before the timeout expires, the request fails and returns an error.
	/// Defaults to no timeout.
	/// </para>
	/// </summary>
	[JsonInclude, JsonPropertyName("timeout")]
	public string? Timeout { get; set; }

	/// <summary>
	/// <para>
	/// If true, calculate and return document scores, even if the scores are not used for sorting.
	/// </para>
	/// </summary>
	[JsonInclude, JsonPropertyName("track_scores")]
	public bool? TrackScores { get; set; }

	/// <summary>
	/// <para>
	/// Number of hits matching the query to count accurately.
	/// If <c>true</c>, the exact number of hits is returned at the cost of some performance.
	/// If <c>false</c>, the  response does not include the total number of hits matching the query.
	/// </para>
	/// </summary>
	[JsonInclude, JsonPropertyName("track_total_hits")]
	public Elastic.Clients.Elasticsearch.Core.Search.TrackHits? TrackTotalHits { get; set; }

	/// <summary>
	/// <para>
	/// If true, returns document version as part of a hit.
	/// </para>
	/// </summary>
	[JsonInclude, JsonPropertyName("version")]
	public bool? Version { get; set; }
}

/// <summary>
/// <para>
/// Returns search hits that match the query defined in the request.
/// You can provide search queries using the <c>q</c> query string parameter or the request body.
/// If both are specified, only the query parameter is used.
/// </para>
/// </summary>
public sealed partial class SearchRequestDescriptor<TDocument> : RequestDescriptor<SearchRequestDescriptor<TDocument>, SearchRequestParameters>
{
	internal SearchRequestDescriptor(Action<SearchRequestDescriptor<TDocument>> configure) => configure.Invoke(this);

	public SearchRequestDescriptor(Elastic.Clients.Elasticsearch.Indices? indices) : base(r => r.Optional("index", indices))
	{
	}

	public SearchRequestDescriptor()
	{
	}

	internal override ApiUrls ApiUrls => ApiUrlLookup.NoNamespaceSearch;

	protected override HttpMethod StaticHttpMethod => HttpMethod.POST;

	internal override bool SupportsBody => true;

	internal override string OperationName => "search";

	public SearchRequestDescriptor<TDocument> AllowNoIndices(bool? allowNoIndices = true) => Qs("allow_no_indices", allowNoIndices);
	public SearchRequestDescriptor<TDocument> AllowPartialSearchResults(bool? allowPartialSearchResults = true) => Qs("allow_partial_search_results", allowPartialSearchResults);
	public SearchRequestDescriptor<TDocument> Analyzer(string? analyzer) => Qs("analyzer", analyzer);
	public SearchRequestDescriptor<TDocument> AnalyzeWildcard(bool? analyzeWildcard = true) => Qs("analyze_wildcard", analyzeWildcard);
	public SearchRequestDescriptor<TDocument> BatchedReduceSize(long? batchedReduceSize) => Qs("batched_reduce_size", batchedReduceSize);
	public SearchRequestDescriptor<TDocument> CcsMinimizeRoundtrips(bool? ccsMinimizeRoundtrips = true) => Qs("ccs_minimize_roundtrips", ccsMinimizeRoundtrips);
	public SearchRequestDescriptor<TDocument> DefaultOperator(Elastic.Clients.Elasticsearch.QueryDsl.Operator? defaultOperator) => Qs("default_operator", defaultOperator);
	public SearchRequestDescriptor<TDocument> Df(string? df) => Qs("df", df);
	public SearchRequestDescriptor<TDocument> ExpandWildcards(ICollection<Elastic.Clients.Elasticsearch.ExpandWildcard>? expandWildcards) => Qs("expand_wildcards", expandWildcards);
	public SearchRequestDescriptor<TDocument> ForceSyntheticSource(bool? forceSyntheticSource = true) => Qs("force_synthetic_source", forceSyntheticSource);
	public SearchRequestDescriptor<TDocument> IgnoreThrottled(bool? ignoreThrottled = true) => Qs("ignore_throttled", ignoreThrottled);
	public SearchRequestDescriptor<TDocument> IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
	public SearchRequestDescriptor<TDocument> Lenient(bool? lenient = true) => Qs("lenient", lenient);
	public SearchRequestDescriptor<TDocument> MaxConcurrentShardRequests(long? maxConcurrentShardRequests) => Qs("max_concurrent_shard_requests", maxConcurrentShardRequests);
	public SearchRequestDescriptor<TDocument> MinCompatibleShardNode(string? minCompatibleShardNode) => Qs("min_compatible_shard_node", minCompatibleShardNode);
	public SearchRequestDescriptor<TDocument> Preference(string? preference) => Qs("preference", preference);
	public SearchRequestDescriptor<TDocument> PreFilterShardSize(long? preFilterShardSize) => Qs("pre_filter_shard_size", preFilterShardSize);
	public SearchRequestDescriptor<TDocument> QueryLuceneSyntax(string? queryLuceneSyntax) => Qs("q", queryLuceneSyntax);
	public SearchRequestDescriptor<TDocument> RequestCache(bool? requestCache = true) => Qs("request_cache", requestCache);
	public SearchRequestDescriptor<TDocument> RestTotalHitsAsInt(bool? restTotalHitsAsInt = true) => Qs("rest_total_hits_as_int", restTotalHitsAsInt);
	public SearchRequestDescriptor<TDocument> Routing(Elastic.Clients.Elasticsearch.Routing? routing) => Qs("routing", routing);
	public SearchRequestDescriptor<TDocument> Scroll(Elastic.Clients.Elasticsearch.Duration? scroll) => Qs("scroll", scroll);
	public SearchRequestDescriptor<TDocument> SearchType(Elastic.Clients.Elasticsearch.SearchType? searchType) => Qs("search_type", searchType);
	public SearchRequestDescriptor<TDocument> SourceExcludes(Elastic.Clients.Elasticsearch.Fields? sourceExcludes) => Qs("_source_excludes", sourceExcludes);
	public SearchRequestDescriptor<TDocument> SourceIncludes(Elastic.Clients.Elasticsearch.Fields? sourceIncludes) => Qs("_source_includes", sourceIncludes);
	public SearchRequestDescriptor<TDocument> SuggestField(Elastic.Clients.Elasticsearch.Field? suggestField) => Qs("suggest_field", suggestField);
	public SearchRequestDescriptor<TDocument> SuggestMode(Elastic.Clients.Elasticsearch.SuggestMode? suggestMode) => Qs("suggest_mode", suggestMode);
	public SearchRequestDescriptor<TDocument> SuggestSize(long? suggestSize) => Qs("suggest_size", suggestSize);
	public SearchRequestDescriptor<TDocument> SuggestText(string? suggestText) => Qs("suggest_text", suggestText);
	public SearchRequestDescriptor<TDocument> TypedKeys(bool? typedKeys = true) => Qs("typed_keys", typedKeys);

	public SearchRequestDescriptor<TDocument> Indices(Elastic.Clients.Elasticsearch.Indices? indices)
	{
		RouteValues.Optional("index", indices);
		return Self;
	}

	private IDictionary<string, Elastic.Clients.Elasticsearch.Aggregations.AggregationDescriptor<TDocument>> AggregationsValue { get; set; }
	private Elastic.Clients.Elasticsearch.Core.Search.FieldCollapse? CollapseValue { get; set; }
	private Elastic.Clients.Elasticsearch.Core.Search.FieldCollapseDescriptor<TDocument> CollapseDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.Core.Search.FieldCollapseDescriptor<TDocument>> CollapseDescriptorAction { get; set; }
	private ICollection<Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormat>? DocvalueFieldsValue { get; set; }
	private Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormatDescriptor<TDocument> DocvalueFieldsDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormatDescriptor<TDocument>> DocvalueFieldsDescriptorAction { get; set; }
	private Action<Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormatDescriptor<TDocument>>[] DocvalueFieldsDescriptorActions { get; set; }
	private bool? ExplainValue { get; set; }
	private IDictionary<string, object>? ExtValue { get; set; }
	private ICollection<Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormat>? FieldsValue { get; set; }
	private Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormatDescriptor<TDocument> FieldsDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormatDescriptor<TDocument>> FieldsDescriptorAction { get; set; }
	private Action<Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormatDescriptor<TDocument>>[] FieldsDescriptorActions { get; set; }
	private int? FromValue { get; set; }
	private Elastic.Clients.Elasticsearch.Core.Search.Highlight? HighlightValue { get; set; }
	private Elastic.Clients.Elasticsearch.Core.Search.HighlightDescriptor<TDocument> HighlightDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.Core.Search.HighlightDescriptor<TDocument>> HighlightDescriptorAction { get; set; }
	private ICollection<IDictionary<Elastic.Clients.Elasticsearch.IndexName, double>>? IndicesBoostValue { get; set; }
	private ICollection<Elastic.Clients.Elasticsearch.KnnSearch>? KnnValue { get; set; }
	private Elastic.Clients.Elasticsearch.KnnSearchDescriptor<TDocument> KnnDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.KnnSearchDescriptor<TDocument>> KnnDescriptorAction { get; set; }
	private Action<Elastic.Clients.Elasticsearch.KnnSearchDescriptor<TDocument>>[] KnnDescriptorActions { get; set; }
	private double? MinScoreValue { get; set; }
	private Elastic.Clients.Elasticsearch.Core.Search.PointInTimeReference? PitValue { get; set; }
	private Elastic.Clients.Elasticsearch.Core.Search.PointInTimeReferenceDescriptor PitDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.Core.Search.PointInTimeReferenceDescriptor> PitDescriptorAction { get; set; }
	private Elastic.Clients.Elasticsearch.QueryDsl.Query? PostFilterValue { get; set; }
	private Elastic.Clients.Elasticsearch.QueryDsl.QueryDescriptor<TDocument> PostFilterDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.QueryDsl.QueryDescriptor<TDocument>> PostFilterDescriptorAction { get; set; }
	private bool? ProfileValue { get; set; }
	private Elastic.Clients.Elasticsearch.QueryDsl.Query? QueryValue { get; set; }
	private Elastic.Clients.Elasticsearch.QueryDsl.QueryDescriptor<TDocument> QueryDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.QueryDsl.QueryDescriptor<TDocument>> QueryDescriptorAction { get; set; }
	private Elastic.Clients.Elasticsearch.Rank? RankValue { get; set; }
	private Elastic.Clients.Elasticsearch.RankDescriptor RankDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.RankDescriptor> RankDescriptorAction { get; set; }
	private ICollection<Elastic.Clients.Elasticsearch.Core.Search.Rescore>? RescoreValue { get; set; }
	private Elastic.Clients.Elasticsearch.Core.Search.RescoreDescriptor<TDocument> RescoreDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.Core.Search.RescoreDescriptor<TDocument>> RescoreDescriptorAction { get; set; }
	private Action<Elastic.Clients.Elasticsearch.Core.Search.RescoreDescriptor<TDocument>>[] RescoreDescriptorActions { get; set; }
	private Elastic.Clients.Elasticsearch.Retriever? RetrieverValue { get; set; }
	private Elastic.Clients.Elasticsearch.RetrieverDescriptor<TDocument> RetrieverDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.RetrieverDescriptor<TDocument>> RetrieverDescriptorAction { get; set; }
	private IDictionary<Elastic.Clients.Elasticsearch.Field, Elastic.Clients.Elasticsearch.Mapping.RuntimeFieldDescriptor<TDocument>> RuntimeMappingsValue { get; set; }
	private IDictionary<string, Elastic.Clients.Elasticsearch.ScriptFieldDescriptor> ScriptFieldsValue { get; set; }
	private ICollection<Elastic.Clients.Elasticsearch.FieldValue>? SearchAfterValue { get; set; }
	private bool? SeqNoPrimaryTermValue { get; set; }
	private int? SizeValue { get; set; }
	private Elastic.Clients.Elasticsearch.SlicedScroll? SliceValue { get; set; }
	private Elastic.Clients.Elasticsearch.SlicedScrollDescriptor<TDocument> SliceDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.SlicedScrollDescriptor<TDocument>> SliceDescriptorAction { get; set; }
	private ICollection<Elastic.Clients.Elasticsearch.SortOptions>? SortValue { get; set; }
	private Elastic.Clients.Elasticsearch.SortOptionsDescriptor<TDocument> SortDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.SortOptionsDescriptor<TDocument>> SortDescriptorAction { get; set; }
	private Action<Elastic.Clients.Elasticsearch.SortOptionsDescriptor<TDocument>>[] SortDescriptorActions { get; set; }
	private Elastic.Clients.Elasticsearch.Core.Search.SourceConfig? SourceValue { get; set; }
	private ICollection<string>? StatsValue { get; set; }
	private Elastic.Clients.Elasticsearch.Fields? StoredFieldsValue { get; set; }
	private Elastic.Clients.Elasticsearch.Core.Search.Suggester? SuggestValue { get; set; }
	private Elastic.Clients.Elasticsearch.Core.Search.SuggesterDescriptor<TDocument> SuggestDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.Core.Search.SuggesterDescriptor<TDocument>> SuggestDescriptorAction { get; set; }
	private long? TerminateAfterValue { get; set; }
	private string? TimeoutValue { get; set; }
	private bool? TrackScoresValue { get; set; }
	private Elastic.Clients.Elasticsearch.Core.Search.TrackHits? TrackTotalHitsValue { get; set; }
	private bool? VersionValue { get; set; }

	/// <summary>
	/// <para>
	/// Defines the aggregations that are run as part of the search request.
	/// </para>
	/// </summary>
	public SearchRequestDescriptor<TDocument> Aggregations(Func<FluentDescriptorDictionary<string, Elastic.Clients.Elasticsearch.Aggregations.AggregationDescriptor<TDocument>>, FluentDescriptorDictionary<string, Elastic.Clients.Elasticsearch.Aggregations.AggregationDescriptor<TDocument>>> selector)
	{
		AggregationsValue = selector?.Invoke(new FluentDescriptorDictionary<string, Elastic.Clients.Elasticsearch.Aggregations.AggregationDescriptor<TDocument>>());
		return Self;
	}

	/// <summary>
	/// <para>
	/// Collapses search results the values of the specified field.
	/// </para>
	/// </summary>
	public SearchRequestDescriptor<TDocument> Collapse(Elastic.Clients.Elasticsearch.Core.Search.FieldCollapse? collapse)
	{
		CollapseDescriptor = null;
		CollapseDescriptorAction = null;
		CollapseValue = collapse;
		return Self;
	}

	public SearchRequestDescriptor<TDocument> Collapse(Elastic.Clients.Elasticsearch.Core.Search.FieldCollapseDescriptor<TDocument> descriptor)
	{
		CollapseValue = null;
		CollapseDescriptorAction = null;
		CollapseDescriptor = descriptor;
		return Self;
	}

	public SearchRequestDescriptor<TDocument> Collapse(Action<Elastic.Clients.Elasticsearch.Core.Search.FieldCollapseDescriptor<TDocument>> configure)
	{
		CollapseValue = null;
		CollapseDescriptor = null;
		CollapseDescriptorAction = configure;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Array of wildcard (<c>*</c>) patterns.
	/// The request returns doc values for field names matching these patterns in the <c>hits.fields</c> property of the response.
	/// </para>
	/// </summary>
	public SearchRequestDescriptor<TDocument> DocvalueFields(ICollection<Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormat>? docvalueFields)
	{
		DocvalueFieldsDescriptor = null;
		DocvalueFieldsDescriptorAction = null;
		DocvalueFieldsDescriptorActions = null;
		DocvalueFieldsValue = docvalueFields;
		return Self;
	}

	public SearchRequestDescriptor<TDocument> DocvalueFields(Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormatDescriptor<TDocument> descriptor)
	{
		DocvalueFieldsValue = null;
		DocvalueFieldsDescriptorAction = null;
		DocvalueFieldsDescriptorActions = null;
		DocvalueFieldsDescriptor = descriptor;
		return Self;
	}

	public SearchRequestDescriptor<TDocument> DocvalueFields(Action<Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormatDescriptor<TDocument>> configure)
	{
		DocvalueFieldsValue = null;
		DocvalueFieldsDescriptor = null;
		DocvalueFieldsDescriptorActions = null;
		DocvalueFieldsDescriptorAction = configure;
		return Self;
	}

	public SearchRequestDescriptor<TDocument> DocvalueFields(params Action<Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormatDescriptor<TDocument>>[] configure)
	{
		DocvalueFieldsValue = null;
		DocvalueFieldsDescriptor = null;
		DocvalueFieldsDescriptorAction = null;
		DocvalueFieldsDescriptorActions = configure;
		return Self;
	}

	/// <summary>
	/// <para>
	/// If true, returns detailed information about score computation as part of a hit.
	/// </para>
	/// </summary>
	public SearchRequestDescriptor<TDocument> Explain(bool? explain = true)
	{
		ExplainValue = explain;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Configuration of search extensions defined by Elasticsearch plugins.
	/// </para>
	/// </summary>
	public SearchRequestDescriptor<TDocument> Ext(Func<FluentDictionary<string, object>, FluentDictionary<string, object>> selector)
	{
		ExtValue = selector?.Invoke(new FluentDictionary<string, object>());
		return Self;
	}

	/// <summary>
	/// <para>
	/// Array of wildcard (<c>*</c>) patterns.
	/// The request returns values for field names matching these patterns in the <c>hits.fields</c> property of the response.
	/// </para>
	/// </summary>
	public SearchRequestDescriptor<TDocument> Fields(ICollection<Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormat>? fields)
	{
		FieldsDescriptor = null;
		FieldsDescriptorAction = null;
		FieldsDescriptorActions = null;
		FieldsValue = fields;
		return Self;
	}

	public SearchRequestDescriptor<TDocument> Fields(Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormatDescriptor<TDocument> descriptor)
	{
		FieldsValue = null;
		FieldsDescriptorAction = null;
		FieldsDescriptorActions = null;
		FieldsDescriptor = descriptor;
		return Self;
	}

	public SearchRequestDescriptor<TDocument> Fields(Action<Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormatDescriptor<TDocument>> configure)
	{
		FieldsValue = null;
		FieldsDescriptor = null;
		FieldsDescriptorActions = null;
		FieldsDescriptorAction = configure;
		return Self;
	}

	public SearchRequestDescriptor<TDocument> Fields(params Action<Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormatDescriptor<TDocument>>[] configure)
	{
		FieldsValue = null;
		FieldsDescriptor = null;
		FieldsDescriptorAction = null;
		FieldsDescriptorActions = configure;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Starting document offset.
	/// Needs to be non-negative.
	/// By default, you cannot page through more than 10,000 hits using the <c>from</c> and <c>size</c> parameters.
	/// To page through more hits, use the <c>search_after</c> parameter.
	/// </para>
	/// </summary>
	public SearchRequestDescriptor<TDocument> From(int? from)
	{
		FromValue = from;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Specifies the highlighter to use for retrieving highlighted snippets from one or more fields in your search results.
	/// </para>
	/// </summary>
	public SearchRequestDescriptor<TDocument> Highlight(Elastic.Clients.Elasticsearch.Core.Search.Highlight? highlight)
	{
		HighlightDescriptor = null;
		HighlightDescriptorAction = null;
		HighlightValue = highlight;
		return Self;
	}

	public SearchRequestDescriptor<TDocument> Highlight(Elastic.Clients.Elasticsearch.Core.Search.HighlightDescriptor<TDocument> descriptor)
	{
		HighlightValue = null;
		HighlightDescriptorAction = null;
		HighlightDescriptor = descriptor;
		return Self;
	}

	public SearchRequestDescriptor<TDocument> Highlight(Action<Elastic.Clients.Elasticsearch.Core.Search.HighlightDescriptor<TDocument>> configure)
	{
		HighlightValue = null;
		HighlightDescriptor = null;
		HighlightDescriptorAction = configure;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Boosts the _score of documents from specified indices.
	/// </para>
	/// </summary>
	public SearchRequestDescriptor<TDocument> IndicesBoost(ICollection<IDictionary<Elastic.Clients.Elasticsearch.IndexName, double>>? indicesBoost)
	{
		IndicesBoostValue = indicesBoost;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Defines the approximate kNN search to run.
	/// </para>
	/// </summary>
	public SearchRequestDescriptor<TDocument> Knn(ICollection<Elastic.Clients.Elasticsearch.KnnSearch>? knn)
	{
		KnnDescriptor = null;
		KnnDescriptorAction = null;
		KnnDescriptorActions = null;
		KnnValue = knn;
		return Self;
	}

	public SearchRequestDescriptor<TDocument> Knn(Elastic.Clients.Elasticsearch.KnnSearchDescriptor<TDocument> descriptor)
	{
		KnnValue = null;
		KnnDescriptorAction = null;
		KnnDescriptorActions = null;
		KnnDescriptor = descriptor;
		return Self;
	}

	public SearchRequestDescriptor<TDocument> Knn(Action<Elastic.Clients.Elasticsearch.KnnSearchDescriptor<TDocument>> configure)
	{
		KnnValue = null;
		KnnDescriptor = null;
		KnnDescriptorActions = null;
		KnnDescriptorAction = configure;
		return Self;
	}

	public SearchRequestDescriptor<TDocument> Knn(params Action<Elastic.Clients.Elasticsearch.KnnSearchDescriptor<TDocument>>[] configure)
	{
		KnnValue = null;
		KnnDescriptor = null;
		KnnDescriptorAction = null;
		KnnDescriptorActions = configure;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Minimum <c>_score</c> for matching documents.
	/// Documents with a lower <c>_score</c> are not included in the search results.
	/// </para>
	/// </summary>
	public SearchRequestDescriptor<TDocument> MinScore(double? minScore)
	{
		MinScoreValue = minScore;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Limits the search to a point in time (PIT).
	/// If you provide a PIT, you cannot specify an <c>&lt;index></c> in the request path.
	/// </para>
	/// </summary>
	public SearchRequestDescriptor<TDocument> Pit(Elastic.Clients.Elasticsearch.Core.Search.PointInTimeReference? pit)
	{
		PitDescriptor = null;
		PitDescriptorAction = null;
		PitValue = pit;
		return Self;
	}

	public SearchRequestDescriptor<TDocument> Pit(Elastic.Clients.Elasticsearch.Core.Search.PointInTimeReferenceDescriptor descriptor)
	{
		PitValue = null;
		PitDescriptorAction = null;
		PitDescriptor = descriptor;
		return Self;
	}

	public SearchRequestDescriptor<TDocument> Pit(Action<Elastic.Clients.Elasticsearch.Core.Search.PointInTimeReferenceDescriptor> configure)
	{
		PitValue = null;
		PitDescriptor = null;
		PitDescriptorAction = configure;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Use the <c>post_filter</c> parameter to filter search results.
	/// The search hits are filtered after the aggregations are calculated.
	/// A post filter has no impact on the aggregation results.
	/// </para>
	/// </summary>
	public SearchRequestDescriptor<TDocument> PostFilter(Elastic.Clients.Elasticsearch.QueryDsl.Query? postFilter)
	{
		PostFilterDescriptor = null;
		PostFilterDescriptorAction = null;
		PostFilterValue = postFilter;
		return Self;
	}

	public SearchRequestDescriptor<TDocument> PostFilter(Elastic.Clients.Elasticsearch.QueryDsl.QueryDescriptor<TDocument> descriptor)
	{
		PostFilterValue = null;
		PostFilterDescriptorAction = null;
		PostFilterDescriptor = descriptor;
		return Self;
	}

	public SearchRequestDescriptor<TDocument> PostFilter(Action<Elastic.Clients.Elasticsearch.QueryDsl.QueryDescriptor<TDocument>> configure)
	{
		PostFilterValue = null;
		PostFilterDescriptor = null;
		PostFilterDescriptorAction = configure;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Set to <c>true</c> to return detailed timing information about the execution of individual components in a search request.
	/// NOTE: This is a debugging tool and adds significant overhead to search execution.
	/// </para>
	/// </summary>
	public SearchRequestDescriptor<TDocument> Profile(bool? profile = true)
	{
		ProfileValue = profile;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Defines the search definition using the Query DSL.
	/// </para>
	/// </summary>
	public SearchRequestDescriptor<TDocument> Query(Elastic.Clients.Elasticsearch.QueryDsl.Query? query)
	{
		QueryDescriptor = null;
		QueryDescriptorAction = null;
		QueryValue = query;
		return Self;
	}

	public SearchRequestDescriptor<TDocument> Query(Elastic.Clients.Elasticsearch.QueryDsl.QueryDescriptor<TDocument> descriptor)
	{
		QueryValue = null;
		QueryDescriptorAction = null;
		QueryDescriptor = descriptor;
		return Self;
	}

	public SearchRequestDescriptor<TDocument> Query(Action<Elastic.Clients.Elasticsearch.QueryDsl.QueryDescriptor<TDocument>> configure)
	{
		QueryValue = null;
		QueryDescriptor = null;
		QueryDescriptorAction = configure;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Defines the Reciprocal Rank Fusion (RRF) to use.
	/// </para>
	/// </summary>
	public SearchRequestDescriptor<TDocument> Rank(Elastic.Clients.Elasticsearch.Rank? rank)
	{
		RankDescriptor = null;
		RankDescriptorAction = null;
		RankValue = rank;
		return Self;
	}

	public SearchRequestDescriptor<TDocument> Rank(Elastic.Clients.Elasticsearch.RankDescriptor descriptor)
	{
		RankValue = null;
		RankDescriptorAction = null;
		RankDescriptor = descriptor;
		return Self;
	}

	public SearchRequestDescriptor<TDocument> Rank(Action<Elastic.Clients.Elasticsearch.RankDescriptor> configure)
	{
		RankValue = null;
		RankDescriptor = null;
		RankDescriptorAction = configure;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Can be used to improve precision by reordering just the top (for example 100 - 500) documents returned by the <c>query</c> and <c>post_filter</c> phases.
	/// </para>
	/// </summary>
	public SearchRequestDescriptor<TDocument> Rescore(ICollection<Elastic.Clients.Elasticsearch.Core.Search.Rescore>? rescore)
	{
		RescoreDescriptor = null;
		RescoreDescriptorAction = null;
		RescoreDescriptorActions = null;
		RescoreValue = rescore;
		return Self;
	}

	public SearchRequestDescriptor<TDocument> Rescore(Elastic.Clients.Elasticsearch.Core.Search.RescoreDescriptor<TDocument> descriptor)
	{
		RescoreValue = null;
		RescoreDescriptorAction = null;
		RescoreDescriptorActions = null;
		RescoreDescriptor = descriptor;
		return Self;
	}

	public SearchRequestDescriptor<TDocument> Rescore(Action<Elastic.Clients.Elasticsearch.Core.Search.RescoreDescriptor<TDocument>> configure)
	{
		RescoreValue = null;
		RescoreDescriptor = null;
		RescoreDescriptorActions = null;
		RescoreDescriptorAction = configure;
		return Self;
	}

	public SearchRequestDescriptor<TDocument> Rescore(params Action<Elastic.Clients.Elasticsearch.Core.Search.RescoreDescriptor<TDocument>>[] configure)
	{
		RescoreValue = null;
		RescoreDescriptor = null;
		RescoreDescriptorAction = null;
		RescoreDescriptorActions = configure;
		return Self;
	}

	/// <summary>
	/// <para>
	/// A retriever is a specification to describe top documents returned from a search. A retriever replaces other elements of the search API that also return top documents such as query and knn.
	/// </para>
	/// </summary>
	public SearchRequestDescriptor<TDocument> Retriever(Elastic.Clients.Elasticsearch.Retriever? retriever)
	{
		RetrieverDescriptor = null;
		RetrieverDescriptorAction = null;
		RetrieverValue = retriever;
		return Self;
	}

	public SearchRequestDescriptor<TDocument> Retriever(Elastic.Clients.Elasticsearch.RetrieverDescriptor<TDocument> descriptor)
	{
		RetrieverValue = null;
		RetrieverDescriptorAction = null;
		RetrieverDescriptor = descriptor;
		return Self;
	}

	public SearchRequestDescriptor<TDocument> Retriever(Action<Elastic.Clients.Elasticsearch.RetrieverDescriptor<TDocument>> configure)
	{
		RetrieverValue = null;
		RetrieverDescriptor = null;
		RetrieverDescriptorAction = configure;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Defines one or more runtime fields in the search request.
	/// These fields take precedence over mapped fields with the same name.
	/// </para>
	/// </summary>
	public SearchRequestDescriptor<TDocument> RuntimeMappings(Func<FluentDescriptorDictionary<Elastic.Clients.Elasticsearch.Field, Elastic.Clients.Elasticsearch.Mapping.RuntimeFieldDescriptor<TDocument>>, FluentDescriptorDictionary<Elastic.Clients.Elasticsearch.Field, Elastic.Clients.Elasticsearch.Mapping.RuntimeFieldDescriptor<TDocument>>> selector)
	{
		RuntimeMappingsValue = selector?.Invoke(new FluentDescriptorDictionary<Elastic.Clients.Elasticsearch.Field, Elastic.Clients.Elasticsearch.Mapping.RuntimeFieldDescriptor<TDocument>>());
		return Self;
	}

	/// <summary>
	/// <para>
	/// Retrieve a script evaluation (based on different fields) for each hit.
	/// </para>
	/// </summary>
	public SearchRequestDescriptor<TDocument> ScriptFields(Func<FluentDescriptorDictionary<string, Elastic.Clients.Elasticsearch.ScriptFieldDescriptor>, FluentDescriptorDictionary<string, Elastic.Clients.Elasticsearch.ScriptFieldDescriptor>> selector)
	{
		ScriptFieldsValue = selector?.Invoke(new FluentDescriptorDictionary<string, Elastic.Clients.Elasticsearch.ScriptFieldDescriptor>());
		return Self;
	}

	/// <summary>
	/// <para>
	/// Used to retrieve the next page of hits using a set of sort values from the previous page.
	/// </para>
	/// </summary>
	public SearchRequestDescriptor<TDocument> SearchAfter(ICollection<Elastic.Clients.Elasticsearch.FieldValue>? searchAfter)
	{
		SearchAfterValue = searchAfter;
		return Self;
	}

	/// <summary>
	/// <para>
	/// If <c>true</c>, returns sequence number and primary term of the last modification of each hit.
	/// </para>
	/// </summary>
	public SearchRequestDescriptor<TDocument> SeqNoPrimaryTerm(bool? seqNoPrimaryTerm = true)
	{
		SeqNoPrimaryTermValue = seqNoPrimaryTerm;
		return Self;
	}

	/// <summary>
	/// <para>
	/// The number of hits to return.
	/// By default, you cannot page through more than 10,000 hits using the <c>from</c> and <c>size</c> parameters.
	/// To page through more hits, use the <c>search_after</c> parameter.
	/// </para>
	/// </summary>
	public SearchRequestDescriptor<TDocument> Size(int? size)
	{
		SizeValue = size;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Can be used to split a scrolled search into multiple slices that can be consumed independently.
	/// </para>
	/// </summary>
	public SearchRequestDescriptor<TDocument> Slice(Elastic.Clients.Elasticsearch.SlicedScroll? slice)
	{
		SliceDescriptor = null;
		SliceDescriptorAction = null;
		SliceValue = slice;
		return Self;
	}

	public SearchRequestDescriptor<TDocument> Slice(Elastic.Clients.Elasticsearch.SlicedScrollDescriptor<TDocument> descriptor)
	{
		SliceValue = null;
		SliceDescriptorAction = null;
		SliceDescriptor = descriptor;
		return Self;
	}

	public SearchRequestDescriptor<TDocument> Slice(Action<Elastic.Clients.Elasticsearch.SlicedScrollDescriptor<TDocument>> configure)
	{
		SliceValue = null;
		SliceDescriptor = null;
		SliceDescriptorAction = configure;
		return Self;
	}

	/// <summary>
	/// <para>
	/// A comma-separated list of &lt;field>:&lt;direction> pairs.
	/// </para>
	/// </summary>
	public SearchRequestDescriptor<TDocument> Sort(ICollection<Elastic.Clients.Elasticsearch.SortOptions>? sort)
	{
		SortDescriptor = null;
		SortDescriptorAction = null;
		SortDescriptorActions = null;
		SortValue = sort;
		return Self;
	}

	public SearchRequestDescriptor<TDocument> Sort(Elastic.Clients.Elasticsearch.SortOptionsDescriptor<TDocument> descriptor)
	{
		SortValue = null;
		SortDescriptorAction = null;
		SortDescriptorActions = null;
		SortDescriptor = descriptor;
		return Self;
	}

	public SearchRequestDescriptor<TDocument> Sort(Action<Elastic.Clients.Elasticsearch.SortOptionsDescriptor<TDocument>> configure)
	{
		SortValue = null;
		SortDescriptor = null;
		SortDescriptorActions = null;
		SortDescriptorAction = configure;
		return Self;
	}

	public SearchRequestDescriptor<TDocument> Sort(params Action<Elastic.Clients.Elasticsearch.SortOptionsDescriptor<TDocument>>[] configure)
	{
		SortValue = null;
		SortDescriptor = null;
		SortDescriptorAction = null;
		SortDescriptorActions = configure;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Indicates which source fields are returned for matching documents.
	/// These fields are returned in the hits._source property of the search response.
	/// </para>
	/// </summary>
	public SearchRequestDescriptor<TDocument> Source(Elastic.Clients.Elasticsearch.Core.Search.SourceConfig? source)
	{
		SourceValue = source;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Stats groups to associate with the search.
	/// Each group maintains a statistics aggregation for its associated searches.
	/// You can retrieve these stats using the indices stats API.
	/// </para>
	/// </summary>
	public SearchRequestDescriptor<TDocument> Stats(ICollection<string>? stats)
	{
		StatsValue = stats;
		return Self;
	}

	/// <summary>
	/// <para>
	/// List of stored fields to return as part of a hit.
	/// If no fields are specified, no stored fields are included in the response.
	/// If this field is specified, the <c>_source</c> parameter defaults to <c>false</c>.
	/// You can pass <c>_source: true</c> to return both source fields and stored fields in the search response.
	/// </para>
	/// </summary>
	public SearchRequestDescriptor<TDocument> StoredFields(Elastic.Clients.Elasticsearch.Fields? storedFields)
	{
		StoredFieldsValue = storedFields;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Defines a suggester that provides similar looking terms based on a provided text.
	/// </para>
	/// </summary>
	public SearchRequestDescriptor<TDocument> Suggest(Elastic.Clients.Elasticsearch.Core.Search.Suggester? suggest)
	{
		SuggestDescriptor = null;
		SuggestDescriptorAction = null;
		SuggestValue = suggest;
		return Self;
	}

	public SearchRequestDescriptor<TDocument> Suggest(Elastic.Clients.Elasticsearch.Core.Search.SuggesterDescriptor<TDocument> descriptor)
	{
		SuggestValue = null;
		SuggestDescriptorAction = null;
		SuggestDescriptor = descriptor;
		return Self;
	}

	public SearchRequestDescriptor<TDocument> Suggest(Action<Elastic.Clients.Elasticsearch.Core.Search.SuggesterDescriptor<TDocument>> configure)
	{
		SuggestValue = null;
		SuggestDescriptor = null;
		SuggestDescriptorAction = configure;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Maximum number of documents to collect for each shard.
	/// If a query reaches this limit, Elasticsearch terminates the query early.
	/// Elasticsearch collects documents before sorting.
	/// Use with caution.
	/// Elasticsearch applies this parameter to each shard handling the request.
	/// When possible, let Elasticsearch perform early termination automatically.
	/// Avoid specifying this parameter for requests that target data streams with backing indices across multiple data tiers.
	/// If set to <c>0</c> (default), the query does not terminate early.
	/// </para>
	/// </summary>
	public SearchRequestDescriptor<TDocument> TerminateAfter(long? terminateAfter)
	{
		TerminateAfterValue = terminateAfter;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Specifies the period of time to wait for a response from each shard.
	/// If no response is received before the timeout expires, the request fails and returns an error.
	/// Defaults to no timeout.
	/// </para>
	/// </summary>
	public SearchRequestDescriptor<TDocument> Timeout(string? timeout)
	{
		TimeoutValue = timeout;
		return Self;
	}

	/// <summary>
	/// <para>
	/// If true, calculate and return document scores, even if the scores are not used for sorting.
	/// </para>
	/// </summary>
	public SearchRequestDescriptor<TDocument> TrackScores(bool? trackScores = true)
	{
		TrackScoresValue = trackScores;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Number of hits matching the query to count accurately.
	/// If <c>true</c>, the exact number of hits is returned at the cost of some performance.
	/// If <c>false</c>, the  response does not include the total number of hits matching the query.
	/// </para>
	/// </summary>
	public SearchRequestDescriptor<TDocument> TrackTotalHits(Elastic.Clients.Elasticsearch.Core.Search.TrackHits? trackTotalHits)
	{
		TrackTotalHitsValue = trackTotalHits;
		return Self;
	}

	/// <summary>
	/// <para>
	/// If true, returns document version as part of a hit.
	/// </para>
	/// </summary>
	public SearchRequestDescriptor<TDocument> Version(bool? version = true)
	{
		VersionValue = version;
		return Self;
	}

	protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
	{
		writer.WriteStartObject();
		if (AggregationsValue is not null)
		{
			writer.WritePropertyName("aggregations");
			JsonSerializer.Serialize(writer, AggregationsValue, options);
		}

		if (CollapseDescriptor is not null)
		{
			writer.WritePropertyName("collapse");
			JsonSerializer.Serialize(writer, CollapseDescriptor, options);
		}
		else if (CollapseDescriptorAction is not null)
		{
			writer.WritePropertyName("collapse");
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.Core.Search.FieldCollapseDescriptor<TDocument>(CollapseDescriptorAction), options);
		}
		else if (CollapseValue is not null)
		{
			writer.WritePropertyName("collapse");
			JsonSerializer.Serialize(writer, CollapseValue, options);
		}

		if (DocvalueFieldsDescriptor is not null)
		{
			writer.WritePropertyName("docvalue_fields");
			writer.WriteStartArray();
			JsonSerializer.Serialize(writer, DocvalueFieldsDescriptor, options);
			writer.WriteEndArray();
		}
		else if (DocvalueFieldsDescriptorAction is not null)
		{
			writer.WritePropertyName("docvalue_fields");
			writer.WriteStartArray();
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormatDescriptor<TDocument>(DocvalueFieldsDescriptorAction), options);
			writer.WriteEndArray();
		}
		else if (DocvalueFieldsDescriptorActions is not null)
		{
			writer.WritePropertyName("docvalue_fields");
			writer.WriteStartArray();
			foreach (var action in DocvalueFieldsDescriptorActions)
			{
				JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormatDescriptor<TDocument>(action), options);
			}

			writer.WriteEndArray();
		}
		else if (DocvalueFieldsValue is not null)
		{
			writer.WritePropertyName("docvalue_fields");
			JsonSerializer.Serialize(writer, DocvalueFieldsValue, options);
		}

		if (ExplainValue.HasValue)
		{
			writer.WritePropertyName("explain");
			writer.WriteBooleanValue(ExplainValue.Value);
		}

		if (ExtValue is not null)
		{
			writer.WritePropertyName("ext");
			JsonSerializer.Serialize(writer, ExtValue, options);
		}

		if (FieldsDescriptor is not null)
		{
			writer.WritePropertyName("fields");
			writer.WriteStartArray();
			JsonSerializer.Serialize(writer, FieldsDescriptor, options);
			writer.WriteEndArray();
		}
		else if (FieldsDescriptorAction is not null)
		{
			writer.WritePropertyName("fields");
			writer.WriteStartArray();
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormatDescriptor<TDocument>(FieldsDescriptorAction), options);
			writer.WriteEndArray();
		}
		else if (FieldsDescriptorActions is not null)
		{
			writer.WritePropertyName("fields");
			writer.WriteStartArray();
			foreach (var action in FieldsDescriptorActions)
			{
				JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormatDescriptor<TDocument>(action), options);
			}

			writer.WriteEndArray();
		}
		else if (FieldsValue is not null)
		{
			writer.WritePropertyName("fields");
			JsonSerializer.Serialize(writer, FieldsValue, options);
		}

		if (FromValue.HasValue)
		{
			writer.WritePropertyName("from");
			writer.WriteNumberValue(FromValue.Value);
		}

		if (HighlightDescriptor is not null)
		{
			writer.WritePropertyName("highlight");
			JsonSerializer.Serialize(writer, HighlightDescriptor, options);
		}
		else if (HighlightDescriptorAction is not null)
		{
			writer.WritePropertyName("highlight");
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.Core.Search.HighlightDescriptor<TDocument>(HighlightDescriptorAction), options);
		}
		else if (HighlightValue is not null)
		{
			writer.WritePropertyName("highlight");
			JsonSerializer.Serialize(writer, HighlightValue, options);
		}

		if (IndicesBoostValue is not null)
		{
			writer.WritePropertyName("indices_boost");
			JsonSerializer.Serialize(writer, IndicesBoostValue, options);
		}

		if (KnnDescriptor is not null)
		{
			writer.WritePropertyName("knn");
			JsonSerializer.Serialize(writer, KnnDescriptor, options);
		}
		else if (KnnDescriptorAction is not null)
		{
			writer.WritePropertyName("knn");
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.KnnSearchDescriptor<TDocument>(KnnDescriptorAction), options);
		}
		else if (KnnDescriptorActions is not null)
		{
			writer.WritePropertyName("knn");
			if (KnnDescriptorActions.Length != 1)
				writer.WriteStartArray();
			foreach (var action in KnnDescriptorActions)
			{
				JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.KnnSearchDescriptor<TDocument>(action), options);
			}

			if (KnnDescriptorActions.Length != 1)
				writer.WriteEndArray();
		}
		else if (KnnValue is not null)
		{
			writer.WritePropertyName("knn");
			SingleOrManySerializationHelper.Serialize<Elastic.Clients.Elasticsearch.KnnSearch>(KnnValue, writer, options);
		}

		if (MinScoreValue.HasValue)
		{
			writer.WritePropertyName("min_score");
			writer.WriteNumberValue(MinScoreValue.Value);
		}

		if (PitDescriptor is not null)
		{
			writer.WritePropertyName("pit");
			JsonSerializer.Serialize(writer, PitDescriptor, options);
		}
		else if (PitDescriptorAction is not null)
		{
			writer.WritePropertyName("pit");
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.Core.Search.PointInTimeReferenceDescriptor(PitDescriptorAction), options);
		}
		else if (PitValue is not null)
		{
			writer.WritePropertyName("pit");
			JsonSerializer.Serialize(writer, PitValue, options);
		}

		if (PostFilterDescriptor is not null)
		{
			writer.WritePropertyName("post_filter");
			JsonSerializer.Serialize(writer, PostFilterDescriptor, options);
		}
		else if (PostFilterDescriptorAction is not null)
		{
			writer.WritePropertyName("post_filter");
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.QueryDsl.QueryDescriptor<TDocument>(PostFilterDescriptorAction), options);
		}
		else if (PostFilterValue is not null)
		{
			writer.WritePropertyName("post_filter");
			JsonSerializer.Serialize(writer, PostFilterValue, options);
		}

		if (ProfileValue.HasValue)
		{
			writer.WritePropertyName("profile");
			writer.WriteBooleanValue(ProfileValue.Value);
		}

		if (QueryDescriptor is not null)
		{
			writer.WritePropertyName("query");
			JsonSerializer.Serialize(writer, QueryDescriptor, options);
		}
		else if (QueryDescriptorAction is not null)
		{
			writer.WritePropertyName("query");
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.QueryDsl.QueryDescriptor<TDocument>(QueryDescriptorAction), options);
		}
		else if (QueryValue is not null)
		{
			writer.WritePropertyName("query");
			JsonSerializer.Serialize(writer, QueryValue, options);
		}

		if (RankDescriptor is not null)
		{
			writer.WritePropertyName("rank");
			JsonSerializer.Serialize(writer, RankDescriptor, options);
		}
		else if (RankDescriptorAction is not null)
		{
			writer.WritePropertyName("rank");
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.RankDescriptor(RankDescriptorAction), options);
		}
		else if (RankValue is not null)
		{
			writer.WritePropertyName("rank");
			JsonSerializer.Serialize(writer, RankValue, options);
		}

		if (RescoreDescriptor is not null)
		{
			writer.WritePropertyName("rescore");
			JsonSerializer.Serialize(writer, RescoreDescriptor, options);
		}
		else if (RescoreDescriptorAction is not null)
		{
			writer.WritePropertyName("rescore");
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.Core.Search.RescoreDescriptor<TDocument>(RescoreDescriptorAction), options);
		}
		else if (RescoreDescriptorActions is not null)
		{
			writer.WritePropertyName("rescore");
			if (RescoreDescriptorActions.Length != 1)
				writer.WriteStartArray();
			foreach (var action in RescoreDescriptorActions)
			{
				JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.Core.Search.RescoreDescriptor<TDocument>(action), options);
			}

			if (RescoreDescriptorActions.Length != 1)
				writer.WriteEndArray();
		}
		else if (RescoreValue is not null)
		{
			writer.WritePropertyName("rescore");
			SingleOrManySerializationHelper.Serialize<Elastic.Clients.Elasticsearch.Core.Search.Rescore>(RescoreValue, writer, options);
		}

		if (RetrieverDescriptor is not null)
		{
			writer.WritePropertyName("retriever");
			JsonSerializer.Serialize(writer, RetrieverDescriptor, options);
		}
		else if (RetrieverDescriptorAction is not null)
		{
			writer.WritePropertyName("retriever");
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.RetrieverDescriptor<TDocument>(RetrieverDescriptorAction), options);
		}
		else if (RetrieverValue is not null)
		{
			writer.WritePropertyName("retriever");
			JsonSerializer.Serialize(writer, RetrieverValue, options);
		}

		if (RuntimeMappingsValue is not null)
		{
			writer.WritePropertyName("runtime_mappings");
			JsonSerializer.Serialize(writer, RuntimeMappingsValue, options);
		}

		if (ScriptFieldsValue is not null)
		{
			writer.WritePropertyName("script_fields");
			JsonSerializer.Serialize(writer, ScriptFieldsValue, options);
		}

		if (SearchAfterValue is not null)
		{
			writer.WritePropertyName("search_after");
			JsonSerializer.Serialize(writer, SearchAfterValue, options);
		}

		if (SeqNoPrimaryTermValue.HasValue)
		{
			writer.WritePropertyName("seq_no_primary_term");
			writer.WriteBooleanValue(SeqNoPrimaryTermValue.Value);
		}

		if (SizeValue.HasValue)
		{
			writer.WritePropertyName("size");
			writer.WriteNumberValue(SizeValue.Value);
		}

		if (SliceDescriptor is not null)
		{
			writer.WritePropertyName("slice");
			JsonSerializer.Serialize(writer, SliceDescriptor, options);
		}
		else if (SliceDescriptorAction is not null)
		{
			writer.WritePropertyName("slice");
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.SlicedScrollDescriptor<TDocument>(SliceDescriptorAction), options);
		}
		else if (SliceValue is not null)
		{
			writer.WritePropertyName("slice");
			JsonSerializer.Serialize(writer, SliceValue, options);
		}

		if (SortDescriptor is not null)
		{
			writer.WritePropertyName("sort");
			JsonSerializer.Serialize(writer, SortDescriptor, options);
		}
		else if (SortDescriptorAction is not null)
		{
			writer.WritePropertyName("sort");
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.SortOptionsDescriptor<TDocument>(SortDescriptorAction), options);
		}
		else if (SortDescriptorActions is not null)
		{
			writer.WritePropertyName("sort");
			if (SortDescriptorActions.Length != 1)
				writer.WriteStartArray();
			foreach (var action in SortDescriptorActions)
			{
				JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.SortOptionsDescriptor<TDocument>(action), options);
			}

			if (SortDescriptorActions.Length != 1)
				writer.WriteEndArray();
		}
		else if (SortValue is not null)
		{
			writer.WritePropertyName("sort");
			SingleOrManySerializationHelper.Serialize<Elastic.Clients.Elasticsearch.SortOptions>(SortValue, writer, options);
		}

		if (SourceValue is not null)
		{
			writer.WritePropertyName("_source");
			JsonSerializer.Serialize(writer, SourceValue, options);
		}

		if (StatsValue is not null)
		{
			writer.WritePropertyName("stats");
			JsonSerializer.Serialize(writer, StatsValue, options);
		}

		if (StoredFieldsValue is not null)
		{
			writer.WritePropertyName("stored_fields");
			JsonSerializer.Serialize(writer, StoredFieldsValue, options);
		}

		if (SuggestDescriptor is not null)
		{
			writer.WritePropertyName("suggest");
			JsonSerializer.Serialize(writer, SuggestDescriptor, options);
		}
		else if (SuggestDescriptorAction is not null)
		{
			writer.WritePropertyName("suggest");
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.Core.Search.SuggesterDescriptor<TDocument>(SuggestDescriptorAction), options);
		}
		else if (SuggestValue is not null)
		{
			writer.WritePropertyName("suggest");
			JsonSerializer.Serialize(writer, SuggestValue, options);
		}

		if (TerminateAfterValue.HasValue)
		{
			writer.WritePropertyName("terminate_after");
			writer.WriteNumberValue(TerminateAfterValue.Value);
		}

		if (!string.IsNullOrEmpty(TimeoutValue))
		{
			writer.WritePropertyName("timeout");
			writer.WriteStringValue(TimeoutValue);
		}

		if (TrackScoresValue.HasValue)
		{
			writer.WritePropertyName("track_scores");
			writer.WriteBooleanValue(TrackScoresValue.Value);
		}

		if (TrackTotalHitsValue is not null)
		{
			writer.WritePropertyName("track_total_hits");
			JsonSerializer.Serialize(writer, TrackTotalHitsValue, options);
		}

		if (VersionValue.HasValue)
		{
			writer.WritePropertyName("version");
			writer.WriteBooleanValue(VersionValue.Value);
		}

		writer.WriteEndObject();
	}
}

/// <summary>
/// <para>
/// Returns search hits that match the query defined in the request.
/// You can provide search queries using the <c>q</c> query string parameter or the request body.
/// If both are specified, only the query parameter is used.
/// </para>
/// </summary>
public sealed partial class SearchRequestDescriptor : RequestDescriptor<SearchRequestDescriptor, SearchRequestParameters>
{
	internal SearchRequestDescriptor(Action<SearchRequestDescriptor> configure) => configure.Invoke(this);

	public SearchRequestDescriptor(Elastic.Clients.Elasticsearch.Indices? indices) : base(r => r.Optional("index", indices))
	{
	}

	public SearchRequestDescriptor()
	{
	}

	internal override ApiUrls ApiUrls => ApiUrlLookup.NoNamespaceSearch;

	protected override HttpMethod StaticHttpMethod => HttpMethod.POST;

	internal override bool SupportsBody => true;

	internal override string OperationName => "search";

	public SearchRequestDescriptor AllowNoIndices(bool? allowNoIndices = true) => Qs("allow_no_indices", allowNoIndices);
	public SearchRequestDescriptor AllowPartialSearchResults(bool? allowPartialSearchResults = true) => Qs("allow_partial_search_results", allowPartialSearchResults);
	public SearchRequestDescriptor Analyzer(string? analyzer) => Qs("analyzer", analyzer);
	public SearchRequestDescriptor AnalyzeWildcard(bool? analyzeWildcard = true) => Qs("analyze_wildcard", analyzeWildcard);
	public SearchRequestDescriptor BatchedReduceSize(long? batchedReduceSize) => Qs("batched_reduce_size", batchedReduceSize);
	public SearchRequestDescriptor CcsMinimizeRoundtrips(bool? ccsMinimizeRoundtrips = true) => Qs("ccs_minimize_roundtrips", ccsMinimizeRoundtrips);
	public SearchRequestDescriptor DefaultOperator(Elastic.Clients.Elasticsearch.QueryDsl.Operator? defaultOperator) => Qs("default_operator", defaultOperator);
	public SearchRequestDescriptor Df(string? df) => Qs("df", df);
	public SearchRequestDescriptor ExpandWildcards(ICollection<Elastic.Clients.Elasticsearch.ExpandWildcard>? expandWildcards) => Qs("expand_wildcards", expandWildcards);
	public SearchRequestDescriptor ForceSyntheticSource(bool? forceSyntheticSource = true) => Qs("force_synthetic_source", forceSyntheticSource);
	public SearchRequestDescriptor IgnoreThrottled(bool? ignoreThrottled = true) => Qs("ignore_throttled", ignoreThrottled);
	public SearchRequestDescriptor IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
	public SearchRequestDescriptor Lenient(bool? lenient = true) => Qs("lenient", lenient);
	public SearchRequestDescriptor MaxConcurrentShardRequests(long? maxConcurrentShardRequests) => Qs("max_concurrent_shard_requests", maxConcurrentShardRequests);
	public SearchRequestDescriptor MinCompatibleShardNode(string? minCompatibleShardNode) => Qs("min_compatible_shard_node", minCompatibleShardNode);
	public SearchRequestDescriptor Preference(string? preference) => Qs("preference", preference);
	public SearchRequestDescriptor PreFilterShardSize(long? preFilterShardSize) => Qs("pre_filter_shard_size", preFilterShardSize);
	public SearchRequestDescriptor QueryLuceneSyntax(string? queryLuceneSyntax) => Qs("q", queryLuceneSyntax);
	public SearchRequestDescriptor RequestCache(bool? requestCache = true) => Qs("request_cache", requestCache);
	public SearchRequestDescriptor RestTotalHitsAsInt(bool? restTotalHitsAsInt = true) => Qs("rest_total_hits_as_int", restTotalHitsAsInt);
	public SearchRequestDescriptor Routing(Elastic.Clients.Elasticsearch.Routing? routing) => Qs("routing", routing);
	public SearchRequestDescriptor Scroll(Elastic.Clients.Elasticsearch.Duration? scroll) => Qs("scroll", scroll);
	public SearchRequestDescriptor SearchType(Elastic.Clients.Elasticsearch.SearchType? searchType) => Qs("search_type", searchType);
	public SearchRequestDescriptor SourceExcludes(Elastic.Clients.Elasticsearch.Fields? sourceExcludes) => Qs("_source_excludes", sourceExcludes);
	public SearchRequestDescriptor SourceIncludes(Elastic.Clients.Elasticsearch.Fields? sourceIncludes) => Qs("_source_includes", sourceIncludes);
	public SearchRequestDescriptor SuggestField(Elastic.Clients.Elasticsearch.Field? suggestField) => Qs("suggest_field", suggestField);
	public SearchRequestDescriptor SuggestMode(Elastic.Clients.Elasticsearch.SuggestMode? suggestMode) => Qs("suggest_mode", suggestMode);
	public SearchRequestDescriptor SuggestSize(long? suggestSize) => Qs("suggest_size", suggestSize);
	public SearchRequestDescriptor SuggestText(string? suggestText) => Qs("suggest_text", suggestText);
	public SearchRequestDescriptor TypedKeys(bool? typedKeys = true) => Qs("typed_keys", typedKeys);

	public SearchRequestDescriptor Indices(Elastic.Clients.Elasticsearch.Indices? indices)
	{
		RouteValues.Optional("index", indices);
		return Self;
	}

	private IDictionary<string, Elastic.Clients.Elasticsearch.Aggregations.AggregationDescriptor> AggregationsValue { get; set; }
	private Elastic.Clients.Elasticsearch.Core.Search.FieldCollapse? CollapseValue { get; set; }
	private Elastic.Clients.Elasticsearch.Core.Search.FieldCollapseDescriptor CollapseDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.Core.Search.FieldCollapseDescriptor> CollapseDescriptorAction { get; set; }
	private ICollection<Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormat>? DocvalueFieldsValue { get; set; }
	private Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormatDescriptor DocvalueFieldsDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormatDescriptor> DocvalueFieldsDescriptorAction { get; set; }
	private Action<Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormatDescriptor>[] DocvalueFieldsDescriptorActions { get; set; }
	private bool? ExplainValue { get; set; }
	private IDictionary<string, object>? ExtValue { get; set; }
	private ICollection<Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormat>? FieldsValue { get; set; }
	private Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormatDescriptor FieldsDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormatDescriptor> FieldsDescriptorAction { get; set; }
	private Action<Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormatDescriptor>[] FieldsDescriptorActions { get; set; }
	private int? FromValue { get; set; }
	private Elastic.Clients.Elasticsearch.Core.Search.Highlight? HighlightValue { get; set; }
	private Elastic.Clients.Elasticsearch.Core.Search.HighlightDescriptor HighlightDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.Core.Search.HighlightDescriptor> HighlightDescriptorAction { get; set; }
	private ICollection<IDictionary<Elastic.Clients.Elasticsearch.IndexName, double>>? IndicesBoostValue { get; set; }
	private ICollection<Elastic.Clients.Elasticsearch.KnnSearch>? KnnValue { get; set; }
	private Elastic.Clients.Elasticsearch.KnnSearchDescriptor KnnDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.KnnSearchDescriptor> KnnDescriptorAction { get; set; }
	private Action<Elastic.Clients.Elasticsearch.KnnSearchDescriptor>[] KnnDescriptorActions { get; set; }
	private double? MinScoreValue { get; set; }
	private Elastic.Clients.Elasticsearch.Core.Search.PointInTimeReference? PitValue { get; set; }
	private Elastic.Clients.Elasticsearch.Core.Search.PointInTimeReferenceDescriptor PitDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.Core.Search.PointInTimeReferenceDescriptor> PitDescriptorAction { get; set; }
	private Elastic.Clients.Elasticsearch.QueryDsl.Query? PostFilterValue { get; set; }
	private Elastic.Clients.Elasticsearch.QueryDsl.QueryDescriptor PostFilterDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.QueryDsl.QueryDescriptor> PostFilterDescriptorAction { get; set; }
	private bool? ProfileValue { get; set; }
	private Elastic.Clients.Elasticsearch.QueryDsl.Query? QueryValue { get; set; }
	private Elastic.Clients.Elasticsearch.QueryDsl.QueryDescriptor QueryDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.QueryDsl.QueryDescriptor> QueryDescriptorAction { get; set; }
	private Elastic.Clients.Elasticsearch.Rank? RankValue { get; set; }
	private Elastic.Clients.Elasticsearch.RankDescriptor RankDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.RankDescriptor> RankDescriptorAction { get; set; }
	private ICollection<Elastic.Clients.Elasticsearch.Core.Search.Rescore>? RescoreValue { get; set; }
	private Elastic.Clients.Elasticsearch.Core.Search.RescoreDescriptor RescoreDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.Core.Search.RescoreDescriptor> RescoreDescriptorAction { get; set; }
	private Action<Elastic.Clients.Elasticsearch.Core.Search.RescoreDescriptor>[] RescoreDescriptorActions { get; set; }
	private Elastic.Clients.Elasticsearch.Retriever? RetrieverValue { get; set; }
	private Elastic.Clients.Elasticsearch.RetrieverDescriptor RetrieverDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.RetrieverDescriptor> RetrieverDescriptorAction { get; set; }
	private IDictionary<Elastic.Clients.Elasticsearch.Field, Elastic.Clients.Elasticsearch.Mapping.RuntimeFieldDescriptor> RuntimeMappingsValue { get; set; }
	private IDictionary<string, Elastic.Clients.Elasticsearch.ScriptFieldDescriptor> ScriptFieldsValue { get; set; }
	private ICollection<Elastic.Clients.Elasticsearch.FieldValue>? SearchAfterValue { get; set; }
	private bool? SeqNoPrimaryTermValue { get; set; }
	private int? SizeValue { get; set; }
	private Elastic.Clients.Elasticsearch.SlicedScroll? SliceValue { get; set; }
	private Elastic.Clients.Elasticsearch.SlicedScrollDescriptor SliceDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.SlicedScrollDescriptor> SliceDescriptorAction { get; set; }
	private ICollection<Elastic.Clients.Elasticsearch.SortOptions>? SortValue { get; set; }
	private Elastic.Clients.Elasticsearch.SortOptionsDescriptor SortDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.SortOptionsDescriptor> SortDescriptorAction { get; set; }
	private Action<Elastic.Clients.Elasticsearch.SortOptionsDescriptor>[] SortDescriptorActions { get; set; }
	private Elastic.Clients.Elasticsearch.Core.Search.SourceConfig? SourceValue { get; set; }
	private ICollection<string>? StatsValue { get; set; }
	private Elastic.Clients.Elasticsearch.Fields? StoredFieldsValue { get; set; }
	private Elastic.Clients.Elasticsearch.Core.Search.Suggester? SuggestValue { get; set; }
	private Elastic.Clients.Elasticsearch.Core.Search.SuggesterDescriptor SuggestDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.Core.Search.SuggesterDescriptor> SuggestDescriptorAction { get; set; }
	private long? TerminateAfterValue { get; set; }
	private string? TimeoutValue { get; set; }
	private bool? TrackScoresValue { get; set; }
	private Elastic.Clients.Elasticsearch.Core.Search.TrackHits? TrackTotalHitsValue { get; set; }
	private bool? VersionValue { get; set; }

	/// <summary>
	/// <para>
	/// Defines the aggregations that are run as part of the search request.
	/// </para>
	/// </summary>
	public SearchRequestDescriptor Aggregations(Func<FluentDescriptorDictionary<string, Elastic.Clients.Elasticsearch.Aggregations.AggregationDescriptor>, FluentDescriptorDictionary<string, Elastic.Clients.Elasticsearch.Aggregations.AggregationDescriptor>> selector)
	{
		AggregationsValue = selector?.Invoke(new FluentDescriptorDictionary<string, Elastic.Clients.Elasticsearch.Aggregations.AggregationDescriptor>());
		return Self;
	}

	/// <summary>
	/// <para>
	/// Collapses search results the values of the specified field.
	/// </para>
	/// </summary>
	public SearchRequestDescriptor Collapse(Elastic.Clients.Elasticsearch.Core.Search.FieldCollapse? collapse)
	{
		CollapseDescriptor = null;
		CollapseDescriptorAction = null;
		CollapseValue = collapse;
		return Self;
	}

	public SearchRequestDescriptor Collapse(Elastic.Clients.Elasticsearch.Core.Search.FieldCollapseDescriptor descriptor)
	{
		CollapseValue = null;
		CollapseDescriptorAction = null;
		CollapseDescriptor = descriptor;
		return Self;
	}

	public SearchRequestDescriptor Collapse(Action<Elastic.Clients.Elasticsearch.Core.Search.FieldCollapseDescriptor> configure)
	{
		CollapseValue = null;
		CollapseDescriptor = null;
		CollapseDescriptorAction = configure;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Array of wildcard (<c>*</c>) patterns.
	/// The request returns doc values for field names matching these patterns in the <c>hits.fields</c> property of the response.
	/// </para>
	/// </summary>
	public SearchRequestDescriptor DocvalueFields(ICollection<Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormat>? docvalueFields)
	{
		DocvalueFieldsDescriptor = null;
		DocvalueFieldsDescriptorAction = null;
		DocvalueFieldsDescriptorActions = null;
		DocvalueFieldsValue = docvalueFields;
		return Self;
	}

	public SearchRequestDescriptor DocvalueFields(Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormatDescriptor descriptor)
	{
		DocvalueFieldsValue = null;
		DocvalueFieldsDescriptorAction = null;
		DocvalueFieldsDescriptorActions = null;
		DocvalueFieldsDescriptor = descriptor;
		return Self;
	}

	public SearchRequestDescriptor DocvalueFields(Action<Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormatDescriptor> configure)
	{
		DocvalueFieldsValue = null;
		DocvalueFieldsDescriptor = null;
		DocvalueFieldsDescriptorActions = null;
		DocvalueFieldsDescriptorAction = configure;
		return Self;
	}

	public SearchRequestDescriptor DocvalueFields(params Action<Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormatDescriptor>[] configure)
	{
		DocvalueFieldsValue = null;
		DocvalueFieldsDescriptor = null;
		DocvalueFieldsDescriptorAction = null;
		DocvalueFieldsDescriptorActions = configure;
		return Self;
	}

	/// <summary>
	/// <para>
	/// If true, returns detailed information about score computation as part of a hit.
	/// </para>
	/// </summary>
	public SearchRequestDescriptor Explain(bool? explain = true)
	{
		ExplainValue = explain;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Configuration of search extensions defined by Elasticsearch plugins.
	/// </para>
	/// </summary>
	public SearchRequestDescriptor Ext(Func<FluentDictionary<string, object>, FluentDictionary<string, object>> selector)
	{
		ExtValue = selector?.Invoke(new FluentDictionary<string, object>());
		return Self;
	}

	/// <summary>
	/// <para>
	/// Array of wildcard (<c>*</c>) patterns.
	/// The request returns values for field names matching these patterns in the <c>hits.fields</c> property of the response.
	/// </para>
	/// </summary>
	public SearchRequestDescriptor Fields(ICollection<Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormat>? fields)
	{
		FieldsDescriptor = null;
		FieldsDescriptorAction = null;
		FieldsDescriptorActions = null;
		FieldsValue = fields;
		return Self;
	}

	public SearchRequestDescriptor Fields(Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormatDescriptor descriptor)
	{
		FieldsValue = null;
		FieldsDescriptorAction = null;
		FieldsDescriptorActions = null;
		FieldsDescriptor = descriptor;
		return Self;
	}

	public SearchRequestDescriptor Fields(Action<Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormatDescriptor> configure)
	{
		FieldsValue = null;
		FieldsDescriptor = null;
		FieldsDescriptorActions = null;
		FieldsDescriptorAction = configure;
		return Self;
	}

	public SearchRequestDescriptor Fields(params Action<Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormatDescriptor>[] configure)
	{
		FieldsValue = null;
		FieldsDescriptor = null;
		FieldsDescriptorAction = null;
		FieldsDescriptorActions = configure;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Starting document offset.
	/// Needs to be non-negative.
	/// By default, you cannot page through more than 10,000 hits using the <c>from</c> and <c>size</c> parameters.
	/// To page through more hits, use the <c>search_after</c> parameter.
	/// </para>
	/// </summary>
	public SearchRequestDescriptor From(int? from)
	{
		FromValue = from;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Specifies the highlighter to use for retrieving highlighted snippets from one or more fields in your search results.
	/// </para>
	/// </summary>
	public SearchRequestDescriptor Highlight(Elastic.Clients.Elasticsearch.Core.Search.Highlight? highlight)
	{
		HighlightDescriptor = null;
		HighlightDescriptorAction = null;
		HighlightValue = highlight;
		return Self;
	}

	public SearchRequestDescriptor Highlight(Elastic.Clients.Elasticsearch.Core.Search.HighlightDescriptor descriptor)
	{
		HighlightValue = null;
		HighlightDescriptorAction = null;
		HighlightDescriptor = descriptor;
		return Self;
	}

	public SearchRequestDescriptor Highlight(Action<Elastic.Clients.Elasticsearch.Core.Search.HighlightDescriptor> configure)
	{
		HighlightValue = null;
		HighlightDescriptor = null;
		HighlightDescriptorAction = configure;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Boosts the _score of documents from specified indices.
	/// </para>
	/// </summary>
	public SearchRequestDescriptor IndicesBoost(ICollection<IDictionary<Elastic.Clients.Elasticsearch.IndexName, double>>? indicesBoost)
	{
		IndicesBoostValue = indicesBoost;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Defines the approximate kNN search to run.
	/// </para>
	/// </summary>
	public SearchRequestDescriptor Knn(ICollection<Elastic.Clients.Elasticsearch.KnnSearch>? knn)
	{
		KnnDescriptor = null;
		KnnDescriptorAction = null;
		KnnDescriptorActions = null;
		KnnValue = knn;
		return Self;
	}

	public SearchRequestDescriptor Knn(Elastic.Clients.Elasticsearch.KnnSearchDescriptor descriptor)
	{
		KnnValue = null;
		KnnDescriptorAction = null;
		KnnDescriptorActions = null;
		KnnDescriptor = descriptor;
		return Self;
	}

	public SearchRequestDescriptor Knn(Action<Elastic.Clients.Elasticsearch.KnnSearchDescriptor> configure)
	{
		KnnValue = null;
		KnnDescriptor = null;
		KnnDescriptorActions = null;
		KnnDescriptorAction = configure;
		return Self;
	}

	public SearchRequestDescriptor Knn(params Action<Elastic.Clients.Elasticsearch.KnnSearchDescriptor>[] configure)
	{
		KnnValue = null;
		KnnDescriptor = null;
		KnnDescriptorAction = null;
		KnnDescriptorActions = configure;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Minimum <c>_score</c> for matching documents.
	/// Documents with a lower <c>_score</c> are not included in the search results.
	/// </para>
	/// </summary>
	public SearchRequestDescriptor MinScore(double? minScore)
	{
		MinScoreValue = minScore;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Limits the search to a point in time (PIT).
	/// If you provide a PIT, you cannot specify an <c>&lt;index></c> in the request path.
	/// </para>
	/// </summary>
	public SearchRequestDescriptor Pit(Elastic.Clients.Elasticsearch.Core.Search.PointInTimeReference? pit)
	{
		PitDescriptor = null;
		PitDescriptorAction = null;
		PitValue = pit;
		return Self;
	}

	public SearchRequestDescriptor Pit(Elastic.Clients.Elasticsearch.Core.Search.PointInTimeReferenceDescriptor descriptor)
	{
		PitValue = null;
		PitDescriptorAction = null;
		PitDescriptor = descriptor;
		return Self;
	}

	public SearchRequestDescriptor Pit(Action<Elastic.Clients.Elasticsearch.Core.Search.PointInTimeReferenceDescriptor> configure)
	{
		PitValue = null;
		PitDescriptor = null;
		PitDescriptorAction = configure;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Use the <c>post_filter</c> parameter to filter search results.
	/// The search hits are filtered after the aggregations are calculated.
	/// A post filter has no impact on the aggregation results.
	/// </para>
	/// </summary>
	public SearchRequestDescriptor PostFilter(Elastic.Clients.Elasticsearch.QueryDsl.Query? postFilter)
	{
		PostFilterDescriptor = null;
		PostFilterDescriptorAction = null;
		PostFilterValue = postFilter;
		return Self;
	}

	public SearchRequestDescriptor PostFilter(Elastic.Clients.Elasticsearch.QueryDsl.QueryDescriptor descriptor)
	{
		PostFilterValue = null;
		PostFilterDescriptorAction = null;
		PostFilterDescriptor = descriptor;
		return Self;
	}

	public SearchRequestDescriptor PostFilter(Action<Elastic.Clients.Elasticsearch.QueryDsl.QueryDescriptor> configure)
	{
		PostFilterValue = null;
		PostFilterDescriptor = null;
		PostFilterDescriptorAction = configure;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Set to <c>true</c> to return detailed timing information about the execution of individual components in a search request.
	/// NOTE: This is a debugging tool and adds significant overhead to search execution.
	/// </para>
	/// </summary>
	public SearchRequestDescriptor Profile(bool? profile = true)
	{
		ProfileValue = profile;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Defines the search definition using the Query DSL.
	/// </para>
	/// </summary>
	public SearchRequestDescriptor Query(Elastic.Clients.Elasticsearch.QueryDsl.Query? query)
	{
		QueryDescriptor = null;
		QueryDescriptorAction = null;
		QueryValue = query;
		return Self;
	}

	public SearchRequestDescriptor Query(Elastic.Clients.Elasticsearch.QueryDsl.QueryDescriptor descriptor)
	{
		QueryValue = null;
		QueryDescriptorAction = null;
		QueryDescriptor = descriptor;
		return Self;
	}

	public SearchRequestDescriptor Query(Action<Elastic.Clients.Elasticsearch.QueryDsl.QueryDescriptor> configure)
	{
		QueryValue = null;
		QueryDescriptor = null;
		QueryDescriptorAction = configure;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Defines the Reciprocal Rank Fusion (RRF) to use.
	/// </para>
	/// </summary>
	public SearchRequestDescriptor Rank(Elastic.Clients.Elasticsearch.Rank? rank)
	{
		RankDescriptor = null;
		RankDescriptorAction = null;
		RankValue = rank;
		return Self;
	}

	public SearchRequestDescriptor Rank(Elastic.Clients.Elasticsearch.RankDescriptor descriptor)
	{
		RankValue = null;
		RankDescriptorAction = null;
		RankDescriptor = descriptor;
		return Self;
	}

	public SearchRequestDescriptor Rank(Action<Elastic.Clients.Elasticsearch.RankDescriptor> configure)
	{
		RankValue = null;
		RankDescriptor = null;
		RankDescriptorAction = configure;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Can be used to improve precision by reordering just the top (for example 100 - 500) documents returned by the <c>query</c> and <c>post_filter</c> phases.
	/// </para>
	/// </summary>
	public SearchRequestDescriptor Rescore(ICollection<Elastic.Clients.Elasticsearch.Core.Search.Rescore>? rescore)
	{
		RescoreDescriptor = null;
		RescoreDescriptorAction = null;
		RescoreDescriptorActions = null;
		RescoreValue = rescore;
		return Self;
	}

	public SearchRequestDescriptor Rescore(Elastic.Clients.Elasticsearch.Core.Search.RescoreDescriptor descriptor)
	{
		RescoreValue = null;
		RescoreDescriptorAction = null;
		RescoreDescriptorActions = null;
		RescoreDescriptor = descriptor;
		return Self;
	}

	public SearchRequestDescriptor Rescore(Action<Elastic.Clients.Elasticsearch.Core.Search.RescoreDescriptor> configure)
	{
		RescoreValue = null;
		RescoreDescriptor = null;
		RescoreDescriptorActions = null;
		RescoreDescriptorAction = configure;
		return Self;
	}

	public SearchRequestDescriptor Rescore(params Action<Elastic.Clients.Elasticsearch.Core.Search.RescoreDescriptor>[] configure)
	{
		RescoreValue = null;
		RescoreDescriptor = null;
		RescoreDescriptorAction = null;
		RescoreDescriptorActions = configure;
		return Self;
	}

	/// <summary>
	/// <para>
	/// A retriever is a specification to describe top documents returned from a search. A retriever replaces other elements of the search API that also return top documents such as query and knn.
	/// </para>
	/// </summary>
	public SearchRequestDescriptor Retriever(Elastic.Clients.Elasticsearch.Retriever? retriever)
	{
		RetrieverDescriptor = null;
		RetrieverDescriptorAction = null;
		RetrieverValue = retriever;
		return Self;
	}

	public SearchRequestDescriptor Retriever(Elastic.Clients.Elasticsearch.RetrieverDescriptor descriptor)
	{
		RetrieverValue = null;
		RetrieverDescriptorAction = null;
		RetrieverDescriptor = descriptor;
		return Self;
	}

	public SearchRequestDescriptor Retriever(Action<Elastic.Clients.Elasticsearch.RetrieverDescriptor> configure)
	{
		RetrieverValue = null;
		RetrieverDescriptor = null;
		RetrieverDescriptorAction = configure;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Defines one or more runtime fields in the search request.
	/// These fields take precedence over mapped fields with the same name.
	/// </para>
	/// </summary>
	public SearchRequestDescriptor RuntimeMappings(Func<FluentDescriptorDictionary<Elastic.Clients.Elasticsearch.Field, Elastic.Clients.Elasticsearch.Mapping.RuntimeFieldDescriptor>, FluentDescriptorDictionary<Elastic.Clients.Elasticsearch.Field, Elastic.Clients.Elasticsearch.Mapping.RuntimeFieldDescriptor>> selector)
	{
		RuntimeMappingsValue = selector?.Invoke(new FluentDescriptorDictionary<Elastic.Clients.Elasticsearch.Field, Elastic.Clients.Elasticsearch.Mapping.RuntimeFieldDescriptor>());
		return Self;
	}

	/// <summary>
	/// <para>
	/// Retrieve a script evaluation (based on different fields) for each hit.
	/// </para>
	/// </summary>
	public SearchRequestDescriptor ScriptFields(Func<FluentDescriptorDictionary<string, Elastic.Clients.Elasticsearch.ScriptFieldDescriptor>, FluentDescriptorDictionary<string, Elastic.Clients.Elasticsearch.ScriptFieldDescriptor>> selector)
	{
		ScriptFieldsValue = selector?.Invoke(new FluentDescriptorDictionary<string, Elastic.Clients.Elasticsearch.ScriptFieldDescriptor>());
		return Self;
	}

	/// <summary>
	/// <para>
	/// Used to retrieve the next page of hits using a set of sort values from the previous page.
	/// </para>
	/// </summary>
	public SearchRequestDescriptor SearchAfter(ICollection<Elastic.Clients.Elasticsearch.FieldValue>? searchAfter)
	{
		SearchAfterValue = searchAfter;
		return Self;
	}

	/// <summary>
	/// <para>
	/// If <c>true</c>, returns sequence number and primary term of the last modification of each hit.
	/// </para>
	/// </summary>
	public SearchRequestDescriptor SeqNoPrimaryTerm(bool? seqNoPrimaryTerm = true)
	{
		SeqNoPrimaryTermValue = seqNoPrimaryTerm;
		return Self;
	}

	/// <summary>
	/// <para>
	/// The number of hits to return.
	/// By default, you cannot page through more than 10,000 hits using the <c>from</c> and <c>size</c> parameters.
	/// To page through more hits, use the <c>search_after</c> parameter.
	/// </para>
	/// </summary>
	public SearchRequestDescriptor Size(int? size)
	{
		SizeValue = size;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Can be used to split a scrolled search into multiple slices that can be consumed independently.
	/// </para>
	/// </summary>
	public SearchRequestDescriptor Slice(Elastic.Clients.Elasticsearch.SlicedScroll? slice)
	{
		SliceDescriptor = null;
		SliceDescriptorAction = null;
		SliceValue = slice;
		return Self;
	}

	public SearchRequestDescriptor Slice(Elastic.Clients.Elasticsearch.SlicedScrollDescriptor descriptor)
	{
		SliceValue = null;
		SliceDescriptorAction = null;
		SliceDescriptor = descriptor;
		return Self;
	}

	public SearchRequestDescriptor Slice(Action<Elastic.Clients.Elasticsearch.SlicedScrollDescriptor> configure)
	{
		SliceValue = null;
		SliceDescriptor = null;
		SliceDescriptorAction = configure;
		return Self;
	}

	/// <summary>
	/// <para>
	/// A comma-separated list of &lt;field>:&lt;direction> pairs.
	/// </para>
	/// </summary>
	public SearchRequestDescriptor Sort(ICollection<Elastic.Clients.Elasticsearch.SortOptions>? sort)
	{
		SortDescriptor = null;
		SortDescriptorAction = null;
		SortDescriptorActions = null;
		SortValue = sort;
		return Self;
	}

	public SearchRequestDescriptor Sort(Elastic.Clients.Elasticsearch.SortOptionsDescriptor descriptor)
	{
		SortValue = null;
		SortDescriptorAction = null;
		SortDescriptorActions = null;
		SortDescriptor = descriptor;
		return Self;
	}

	public SearchRequestDescriptor Sort(Action<Elastic.Clients.Elasticsearch.SortOptionsDescriptor> configure)
	{
		SortValue = null;
		SortDescriptor = null;
		SortDescriptorActions = null;
		SortDescriptorAction = configure;
		return Self;
	}

	public SearchRequestDescriptor Sort(params Action<Elastic.Clients.Elasticsearch.SortOptionsDescriptor>[] configure)
	{
		SortValue = null;
		SortDescriptor = null;
		SortDescriptorAction = null;
		SortDescriptorActions = configure;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Indicates which source fields are returned for matching documents.
	/// These fields are returned in the hits._source property of the search response.
	/// </para>
	/// </summary>
	public SearchRequestDescriptor Source(Elastic.Clients.Elasticsearch.Core.Search.SourceConfig? source)
	{
		SourceValue = source;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Stats groups to associate with the search.
	/// Each group maintains a statistics aggregation for its associated searches.
	/// You can retrieve these stats using the indices stats API.
	/// </para>
	/// </summary>
	public SearchRequestDescriptor Stats(ICollection<string>? stats)
	{
		StatsValue = stats;
		return Self;
	}

	/// <summary>
	/// <para>
	/// List of stored fields to return as part of a hit.
	/// If no fields are specified, no stored fields are included in the response.
	/// If this field is specified, the <c>_source</c> parameter defaults to <c>false</c>.
	/// You can pass <c>_source: true</c> to return both source fields and stored fields in the search response.
	/// </para>
	/// </summary>
	public SearchRequestDescriptor StoredFields(Elastic.Clients.Elasticsearch.Fields? storedFields)
	{
		StoredFieldsValue = storedFields;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Defines a suggester that provides similar looking terms based on a provided text.
	/// </para>
	/// </summary>
	public SearchRequestDescriptor Suggest(Elastic.Clients.Elasticsearch.Core.Search.Suggester? suggest)
	{
		SuggestDescriptor = null;
		SuggestDescriptorAction = null;
		SuggestValue = suggest;
		return Self;
	}

	public SearchRequestDescriptor Suggest(Elastic.Clients.Elasticsearch.Core.Search.SuggesterDescriptor descriptor)
	{
		SuggestValue = null;
		SuggestDescriptorAction = null;
		SuggestDescriptor = descriptor;
		return Self;
	}

	public SearchRequestDescriptor Suggest(Action<Elastic.Clients.Elasticsearch.Core.Search.SuggesterDescriptor> configure)
	{
		SuggestValue = null;
		SuggestDescriptor = null;
		SuggestDescriptorAction = configure;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Maximum number of documents to collect for each shard.
	/// If a query reaches this limit, Elasticsearch terminates the query early.
	/// Elasticsearch collects documents before sorting.
	/// Use with caution.
	/// Elasticsearch applies this parameter to each shard handling the request.
	/// When possible, let Elasticsearch perform early termination automatically.
	/// Avoid specifying this parameter for requests that target data streams with backing indices across multiple data tiers.
	/// If set to <c>0</c> (default), the query does not terminate early.
	/// </para>
	/// </summary>
	public SearchRequestDescriptor TerminateAfter(long? terminateAfter)
	{
		TerminateAfterValue = terminateAfter;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Specifies the period of time to wait for a response from each shard.
	/// If no response is received before the timeout expires, the request fails and returns an error.
	/// Defaults to no timeout.
	/// </para>
	/// </summary>
	public SearchRequestDescriptor Timeout(string? timeout)
	{
		TimeoutValue = timeout;
		return Self;
	}

	/// <summary>
	/// <para>
	/// If true, calculate and return document scores, even if the scores are not used for sorting.
	/// </para>
	/// </summary>
	public SearchRequestDescriptor TrackScores(bool? trackScores = true)
	{
		TrackScoresValue = trackScores;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Number of hits matching the query to count accurately.
	/// If <c>true</c>, the exact number of hits is returned at the cost of some performance.
	/// If <c>false</c>, the  response does not include the total number of hits matching the query.
	/// </para>
	/// </summary>
	public SearchRequestDescriptor TrackTotalHits(Elastic.Clients.Elasticsearch.Core.Search.TrackHits? trackTotalHits)
	{
		TrackTotalHitsValue = trackTotalHits;
		return Self;
	}

	/// <summary>
	/// <para>
	/// If true, returns document version as part of a hit.
	/// </para>
	/// </summary>
	public SearchRequestDescriptor Version(bool? version = true)
	{
		VersionValue = version;
		return Self;
	}

	protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
	{
		writer.WriteStartObject();
		if (AggregationsValue is not null)
		{
			writer.WritePropertyName("aggregations");
			JsonSerializer.Serialize(writer, AggregationsValue, options);
		}

		if (CollapseDescriptor is not null)
		{
			writer.WritePropertyName("collapse");
			JsonSerializer.Serialize(writer, CollapseDescriptor, options);
		}
		else if (CollapseDescriptorAction is not null)
		{
			writer.WritePropertyName("collapse");
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.Core.Search.FieldCollapseDescriptor(CollapseDescriptorAction), options);
		}
		else if (CollapseValue is not null)
		{
			writer.WritePropertyName("collapse");
			JsonSerializer.Serialize(writer, CollapseValue, options);
		}

		if (DocvalueFieldsDescriptor is not null)
		{
			writer.WritePropertyName("docvalue_fields");
			writer.WriteStartArray();
			JsonSerializer.Serialize(writer, DocvalueFieldsDescriptor, options);
			writer.WriteEndArray();
		}
		else if (DocvalueFieldsDescriptorAction is not null)
		{
			writer.WritePropertyName("docvalue_fields");
			writer.WriteStartArray();
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormatDescriptor(DocvalueFieldsDescriptorAction), options);
			writer.WriteEndArray();
		}
		else if (DocvalueFieldsDescriptorActions is not null)
		{
			writer.WritePropertyName("docvalue_fields");
			writer.WriteStartArray();
			foreach (var action in DocvalueFieldsDescriptorActions)
			{
				JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormatDescriptor(action), options);
			}

			writer.WriteEndArray();
		}
		else if (DocvalueFieldsValue is not null)
		{
			writer.WritePropertyName("docvalue_fields");
			JsonSerializer.Serialize(writer, DocvalueFieldsValue, options);
		}

		if (ExplainValue.HasValue)
		{
			writer.WritePropertyName("explain");
			writer.WriteBooleanValue(ExplainValue.Value);
		}

		if (ExtValue is not null)
		{
			writer.WritePropertyName("ext");
			JsonSerializer.Serialize(writer, ExtValue, options);
		}

		if (FieldsDescriptor is not null)
		{
			writer.WritePropertyName("fields");
			writer.WriteStartArray();
			JsonSerializer.Serialize(writer, FieldsDescriptor, options);
			writer.WriteEndArray();
		}
		else if (FieldsDescriptorAction is not null)
		{
			writer.WritePropertyName("fields");
			writer.WriteStartArray();
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormatDescriptor(FieldsDescriptorAction), options);
			writer.WriteEndArray();
		}
		else if (FieldsDescriptorActions is not null)
		{
			writer.WritePropertyName("fields");
			writer.WriteStartArray();
			foreach (var action in FieldsDescriptorActions)
			{
				JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormatDescriptor(action), options);
			}

			writer.WriteEndArray();
		}
		else if (FieldsValue is not null)
		{
			writer.WritePropertyName("fields");
			JsonSerializer.Serialize(writer, FieldsValue, options);
		}

		if (FromValue.HasValue)
		{
			writer.WritePropertyName("from");
			writer.WriteNumberValue(FromValue.Value);
		}

		if (HighlightDescriptor is not null)
		{
			writer.WritePropertyName("highlight");
			JsonSerializer.Serialize(writer, HighlightDescriptor, options);
		}
		else if (HighlightDescriptorAction is not null)
		{
			writer.WritePropertyName("highlight");
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.Core.Search.HighlightDescriptor(HighlightDescriptorAction), options);
		}
		else if (HighlightValue is not null)
		{
			writer.WritePropertyName("highlight");
			JsonSerializer.Serialize(writer, HighlightValue, options);
		}

		if (IndicesBoostValue is not null)
		{
			writer.WritePropertyName("indices_boost");
			JsonSerializer.Serialize(writer, IndicesBoostValue, options);
		}

		if (KnnDescriptor is not null)
		{
			writer.WritePropertyName("knn");
			JsonSerializer.Serialize(writer, KnnDescriptor, options);
		}
		else if (KnnDescriptorAction is not null)
		{
			writer.WritePropertyName("knn");
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.KnnSearchDescriptor(KnnDescriptorAction), options);
		}
		else if (KnnDescriptorActions is not null)
		{
			writer.WritePropertyName("knn");
			if (KnnDescriptorActions.Length != 1)
				writer.WriteStartArray();
			foreach (var action in KnnDescriptorActions)
			{
				JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.KnnSearchDescriptor(action), options);
			}

			if (KnnDescriptorActions.Length != 1)
				writer.WriteEndArray();
		}
		else if (KnnValue is not null)
		{
			writer.WritePropertyName("knn");
			SingleOrManySerializationHelper.Serialize<Elastic.Clients.Elasticsearch.KnnSearch>(KnnValue, writer, options);
		}

		if (MinScoreValue.HasValue)
		{
			writer.WritePropertyName("min_score");
			writer.WriteNumberValue(MinScoreValue.Value);
		}

		if (PitDescriptor is not null)
		{
			writer.WritePropertyName("pit");
			JsonSerializer.Serialize(writer, PitDescriptor, options);
		}
		else if (PitDescriptorAction is not null)
		{
			writer.WritePropertyName("pit");
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.Core.Search.PointInTimeReferenceDescriptor(PitDescriptorAction), options);
		}
		else if (PitValue is not null)
		{
			writer.WritePropertyName("pit");
			JsonSerializer.Serialize(writer, PitValue, options);
		}

		if (PostFilterDescriptor is not null)
		{
			writer.WritePropertyName("post_filter");
			JsonSerializer.Serialize(writer, PostFilterDescriptor, options);
		}
		else if (PostFilterDescriptorAction is not null)
		{
			writer.WritePropertyName("post_filter");
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.QueryDsl.QueryDescriptor(PostFilterDescriptorAction), options);
		}
		else if (PostFilterValue is not null)
		{
			writer.WritePropertyName("post_filter");
			JsonSerializer.Serialize(writer, PostFilterValue, options);
		}

		if (ProfileValue.HasValue)
		{
			writer.WritePropertyName("profile");
			writer.WriteBooleanValue(ProfileValue.Value);
		}

		if (QueryDescriptor is not null)
		{
			writer.WritePropertyName("query");
			JsonSerializer.Serialize(writer, QueryDescriptor, options);
		}
		else if (QueryDescriptorAction is not null)
		{
			writer.WritePropertyName("query");
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.QueryDsl.QueryDescriptor(QueryDescriptorAction), options);
		}
		else if (QueryValue is not null)
		{
			writer.WritePropertyName("query");
			JsonSerializer.Serialize(writer, QueryValue, options);
		}

		if (RankDescriptor is not null)
		{
			writer.WritePropertyName("rank");
			JsonSerializer.Serialize(writer, RankDescriptor, options);
		}
		else if (RankDescriptorAction is not null)
		{
			writer.WritePropertyName("rank");
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.RankDescriptor(RankDescriptorAction), options);
		}
		else if (RankValue is not null)
		{
			writer.WritePropertyName("rank");
			JsonSerializer.Serialize(writer, RankValue, options);
		}

		if (RescoreDescriptor is not null)
		{
			writer.WritePropertyName("rescore");
			JsonSerializer.Serialize(writer, RescoreDescriptor, options);
		}
		else if (RescoreDescriptorAction is not null)
		{
			writer.WritePropertyName("rescore");
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.Core.Search.RescoreDescriptor(RescoreDescriptorAction), options);
		}
		else if (RescoreDescriptorActions is not null)
		{
			writer.WritePropertyName("rescore");
			if (RescoreDescriptorActions.Length != 1)
				writer.WriteStartArray();
			foreach (var action in RescoreDescriptorActions)
			{
				JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.Core.Search.RescoreDescriptor(action), options);
			}

			if (RescoreDescriptorActions.Length != 1)
				writer.WriteEndArray();
		}
		else if (RescoreValue is not null)
		{
			writer.WritePropertyName("rescore");
			SingleOrManySerializationHelper.Serialize<Elastic.Clients.Elasticsearch.Core.Search.Rescore>(RescoreValue, writer, options);
		}

		if (RetrieverDescriptor is not null)
		{
			writer.WritePropertyName("retriever");
			JsonSerializer.Serialize(writer, RetrieverDescriptor, options);
		}
		else if (RetrieverDescriptorAction is not null)
		{
			writer.WritePropertyName("retriever");
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.RetrieverDescriptor(RetrieverDescriptorAction), options);
		}
		else if (RetrieverValue is not null)
		{
			writer.WritePropertyName("retriever");
			JsonSerializer.Serialize(writer, RetrieverValue, options);
		}

		if (RuntimeMappingsValue is not null)
		{
			writer.WritePropertyName("runtime_mappings");
			JsonSerializer.Serialize(writer, RuntimeMappingsValue, options);
		}

		if (ScriptFieldsValue is not null)
		{
			writer.WritePropertyName("script_fields");
			JsonSerializer.Serialize(writer, ScriptFieldsValue, options);
		}

		if (SearchAfterValue is not null)
		{
			writer.WritePropertyName("search_after");
			JsonSerializer.Serialize(writer, SearchAfterValue, options);
		}

		if (SeqNoPrimaryTermValue.HasValue)
		{
			writer.WritePropertyName("seq_no_primary_term");
			writer.WriteBooleanValue(SeqNoPrimaryTermValue.Value);
		}

		if (SizeValue.HasValue)
		{
			writer.WritePropertyName("size");
			writer.WriteNumberValue(SizeValue.Value);
		}

		if (SliceDescriptor is not null)
		{
			writer.WritePropertyName("slice");
			JsonSerializer.Serialize(writer, SliceDescriptor, options);
		}
		else if (SliceDescriptorAction is not null)
		{
			writer.WritePropertyName("slice");
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.SlicedScrollDescriptor(SliceDescriptorAction), options);
		}
		else if (SliceValue is not null)
		{
			writer.WritePropertyName("slice");
			JsonSerializer.Serialize(writer, SliceValue, options);
		}

		if (SortDescriptor is not null)
		{
			writer.WritePropertyName("sort");
			JsonSerializer.Serialize(writer, SortDescriptor, options);
		}
		else if (SortDescriptorAction is not null)
		{
			writer.WritePropertyName("sort");
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.SortOptionsDescriptor(SortDescriptorAction), options);
		}
		else if (SortDescriptorActions is not null)
		{
			writer.WritePropertyName("sort");
			if (SortDescriptorActions.Length != 1)
				writer.WriteStartArray();
			foreach (var action in SortDescriptorActions)
			{
				JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.SortOptionsDescriptor(action), options);
			}

			if (SortDescriptorActions.Length != 1)
				writer.WriteEndArray();
		}
		else if (SortValue is not null)
		{
			writer.WritePropertyName("sort");
			SingleOrManySerializationHelper.Serialize<Elastic.Clients.Elasticsearch.SortOptions>(SortValue, writer, options);
		}

		if (SourceValue is not null)
		{
			writer.WritePropertyName("_source");
			JsonSerializer.Serialize(writer, SourceValue, options);
		}

		if (StatsValue is not null)
		{
			writer.WritePropertyName("stats");
			JsonSerializer.Serialize(writer, StatsValue, options);
		}

		if (StoredFieldsValue is not null)
		{
			writer.WritePropertyName("stored_fields");
			JsonSerializer.Serialize(writer, StoredFieldsValue, options);
		}

		if (SuggestDescriptor is not null)
		{
			writer.WritePropertyName("suggest");
			JsonSerializer.Serialize(writer, SuggestDescriptor, options);
		}
		else if (SuggestDescriptorAction is not null)
		{
			writer.WritePropertyName("suggest");
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.Core.Search.SuggesterDescriptor(SuggestDescriptorAction), options);
		}
		else if (SuggestValue is not null)
		{
			writer.WritePropertyName("suggest");
			JsonSerializer.Serialize(writer, SuggestValue, options);
		}

		if (TerminateAfterValue.HasValue)
		{
			writer.WritePropertyName("terminate_after");
			writer.WriteNumberValue(TerminateAfterValue.Value);
		}

		if (!string.IsNullOrEmpty(TimeoutValue))
		{
			writer.WritePropertyName("timeout");
			writer.WriteStringValue(TimeoutValue);
		}

		if (TrackScoresValue.HasValue)
		{
			writer.WritePropertyName("track_scores");
			writer.WriteBooleanValue(TrackScoresValue.Value);
		}

		if (TrackTotalHitsValue is not null)
		{
			writer.WritePropertyName("track_total_hits");
			JsonSerializer.Serialize(writer, TrackTotalHitsValue, options);
		}

		if (VersionValue.HasValue)
		{
			writer.WritePropertyName("version");
			writer.WriteBooleanValue(VersionValue.Value);
		}

		writer.WriteEndObject();
	}
}