// Licensed to Elasticsearch B.V under one or more agreements.
// Elasticsearch B.V licenses this file to you under the Apache 2.0 License.
// See the LICENSE file in the project root for more information.
//
// ███╗   ██╗ ██████╗ ████████╗██╗ ██████╗███████╗
// ████╗  ██║██╔═══██╗╚══██╔══╝██║██╔════╝██╔════╝
// ██╔██╗ ██║██║   ██║   ██║   ██║██║     █████╗
// ██║╚██╗██║██║   ██║   ██║   ██║██║     ██╔══╝
// ██║ ╚████║╚██████╔╝   ██║   ██║╚██████╗███████╗
// ╚═╝  ╚═══╝ ╚═════╝    ╚═╝   ╚═╝ ╚═════╝╚══════╝
// ------------------------------------------------
//
// This file is automatically generated.
// Please do not edit these files manually.
//
// ------------------------------------------------

#nullable restore

using Elastic.Clients.Elasticsearch.Fluent;
using Elastic.Clients.Elasticsearch.Requests;
using Elastic.Clients.Elasticsearch.Serialization;
using Elastic.Transport;
using Elastic.Transport.Extensions;
using System;
using System.Collections.Generic;
using System.Linq.Expressions;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace Elastic.Clients.Elasticsearch.Simulate;

public sealed partial class IngestRequestParameters : RequestParameters
{
	/// <summary>
	/// <para>
	/// The pipeline to use as the default pipeline.
	/// This value can be used to override the default pipeline of the index.
	/// </para>
	/// </summary>
	public string? Pipeline { get => Q<string?>("pipeline"); set => Q("pipeline", value); }
}

/// <summary>
/// <para>
/// Simulate data ingestion.
/// Run ingest pipelines against a set of provided documents, optionally with substitute pipeline definitions, to simulate ingesting data into an index.
/// </para>
/// <para>
/// This API is meant to be used for troubleshooting or pipeline development, as it does not actually index any data into Elasticsearch.
/// </para>
/// <para>
/// The API runs the default and final pipeline for that index against a set of documents provided in the body of the request.
/// If a pipeline contains a reroute processor, it follows that reroute processor to the new index, running that index's pipelines as well the same way that a non-simulated ingest would.
/// No data is indexed into Elasticsearch.
/// Instead, the transformed document is returned, along with the list of pipelines that have been run and the name of the index where the document would have been indexed if this were not a simulation.
/// The transformed document is validated against the mappings that would apply to this index, and any validation error is reported in the result.
/// </para>
/// <para>
/// This API differs from the simulate pipeline API in that you specify a single pipeline for that API, and it runs only that one pipeline.
/// The simulate pipeline API is more useful for developing a single pipeline, while the simulate ingest API is more useful for troubleshooting the interaction of the various pipelines that get applied when ingesting into an index.
/// </para>
/// <para>
/// By default, the pipeline definitions that are currently in the system are used.
/// However, you can supply substitute pipeline definitions in the body of the request.
/// These will be used in place of the pipeline definitions that are already in the system. This can be used to replace existing pipeline definitions or to create new ones. The pipeline substitutions are used only within this request.
/// </para>
/// </summary>
public sealed partial class IngestRequest : PlainRequest<IngestRequestParameters>
{
	public IngestRequest()
	{
	}

	public IngestRequest(Elastic.Clients.Elasticsearch.IndexName? index) : base(r => r.Optional("index", index))
	{
	}

	internal override ApiUrls ApiUrls => ApiUrlLookup.SimulateIngest;

	protected override HttpMethod StaticHttpMethod => HttpMethod.POST;

	internal override bool SupportsBody => true;

	internal override string OperationName => "simulate.ingest";

	/// <summary>
	/// <para>
	/// The pipeline to use as the default pipeline.
	/// This value can be used to override the default pipeline of the index.
	/// </para>
	/// </summary>
	[JsonIgnore]
	public string? Pipeline { get => Q<string?>("pipeline"); set => Q("pipeline", value); }

	/// <summary>
	/// <para>
	/// A map of component template names to substitute component template definition objects.
	/// </para>
	/// </summary>
	[JsonInclude, JsonPropertyName("component_template_substitutions")]
	public IDictionary<string, Elastic.Clients.Elasticsearch.Cluster.ComponentTemplateNode>? ComponentTemplateSubstitutions { get; set; }

	/// <summary>
	/// <para>
	/// Sample documents to test in the pipeline.
	/// </para>
	/// </summary>
	[JsonInclude, JsonPropertyName("docs")]
	public ICollection<Elastic.Clients.Elasticsearch.Ingest.Document> Docs { get; set; }

	/// <summary>
	/// <para>
	/// A map of index template names to substitute index template definition objects.
	/// </para>
	/// </summary>
	[JsonInclude, JsonPropertyName("index_template_substitutions")]
	public IDictionary<string, Elastic.Clients.Elasticsearch.IndexManagement.IndexTemplate>? IndexTemplateSubstitutions { get; set; }
	[JsonInclude, JsonPropertyName("mapping_addition")]
	public Elastic.Clients.Elasticsearch.Mapping.TypeMapping? MappingAddition { get; set; }

	/// <summary>
	/// <para>
	/// Pipelines to test.
	/// If you don’t specify the <c>pipeline</c> request path parameter, this parameter is required.
	/// If you specify both this and the request path parameter, the API only uses the request path parameter.
	/// </para>
	/// </summary>
	[JsonInclude, JsonPropertyName("pipeline_substitutions")]
	public IDictionary<string, Elastic.Clients.Elasticsearch.Ingest.Pipeline>? PipelineSubstitutions { get; set; }
}

/// <summary>
/// <para>
/// Simulate data ingestion.
/// Run ingest pipelines against a set of provided documents, optionally with substitute pipeline definitions, to simulate ingesting data into an index.
/// </para>
/// <para>
/// This API is meant to be used for troubleshooting or pipeline development, as it does not actually index any data into Elasticsearch.
/// </para>
/// <para>
/// The API runs the default and final pipeline for that index against a set of documents provided in the body of the request.
/// If a pipeline contains a reroute processor, it follows that reroute processor to the new index, running that index's pipelines as well the same way that a non-simulated ingest would.
/// No data is indexed into Elasticsearch.
/// Instead, the transformed document is returned, along with the list of pipelines that have been run and the name of the index where the document would have been indexed if this were not a simulation.
/// The transformed document is validated against the mappings that would apply to this index, and any validation error is reported in the result.
/// </para>
/// <para>
/// This API differs from the simulate pipeline API in that you specify a single pipeline for that API, and it runs only that one pipeline.
/// The simulate pipeline API is more useful for developing a single pipeline, while the simulate ingest API is more useful for troubleshooting the interaction of the various pipelines that get applied when ingesting into an index.
/// </para>
/// <para>
/// By default, the pipeline definitions that are currently in the system are used.
/// However, you can supply substitute pipeline definitions in the body of the request.
/// These will be used in place of the pipeline definitions that are already in the system. This can be used to replace existing pipeline definitions or to create new ones. The pipeline substitutions are used only within this request.
/// </para>
/// </summary>
public sealed partial class IngestRequestDescriptor<TDocument> : RequestDescriptor<IngestRequestDescriptor<TDocument>, IngestRequestParameters>
{
	internal IngestRequestDescriptor(Action<IngestRequestDescriptor<TDocument>> configure) => configure.Invoke(this);

	public IngestRequestDescriptor(Elastic.Clients.Elasticsearch.IndexName? index) : base(r => r.Optional("index", index))
	{
	}

	public IngestRequestDescriptor() : this(typeof(TDocument))
	{
	}

	internal override ApiUrls ApiUrls => ApiUrlLookup.SimulateIngest;

	protected override HttpMethod StaticHttpMethod => HttpMethod.POST;

	internal override bool SupportsBody => true;

	internal override string OperationName => "simulate.ingest";

	public IngestRequestDescriptor<TDocument> Pipeline(string? pipeline) => Qs("pipeline", pipeline);

	public IngestRequestDescriptor<TDocument> Index(Elastic.Clients.Elasticsearch.IndexName? index)
	{
		RouteValues.Optional("index", index);
		return Self;
	}

	private IDictionary<string, Elastic.Clients.Elasticsearch.Cluster.ComponentTemplateNodeDescriptor<TDocument>> ComponentTemplateSubstitutionsValue { get; set; }
	private ICollection<Elastic.Clients.Elasticsearch.Ingest.Document> DocsValue { get; set; }
	private Elastic.Clients.Elasticsearch.Ingest.DocumentDescriptor DocsDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.Ingest.DocumentDescriptor> DocsDescriptorAction { get; set; }
	private Action<Elastic.Clients.Elasticsearch.Ingest.DocumentDescriptor>[] DocsDescriptorActions { get; set; }
	private IDictionary<string, Elastic.Clients.Elasticsearch.IndexManagement.IndexTemplateDescriptor<TDocument>> IndexTemplateSubstitutionsValue { get; set; }
	private Elastic.Clients.Elasticsearch.Mapping.TypeMapping? MappingAdditionValue { get; set; }
	private Elastic.Clients.Elasticsearch.Mapping.TypeMappingDescriptor<TDocument> MappingAdditionDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.Mapping.TypeMappingDescriptor<TDocument>> MappingAdditionDescriptorAction { get; set; }
	private IDictionary<string, Elastic.Clients.Elasticsearch.Ingest.PipelineDescriptor<TDocument>> PipelineSubstitutionsValue { get; set; }

	/// <summary>
	/// <para>
	/// A map of component template names to substitute component template definition objects.
	/// </para>
	/// </summary>
	public IngestRequestDescriptor<TDocument> ComponentTemplateSubstitutions(Func<FluentDescriptorDictionary<string, Elastic.Clients.Elasticsearch.Cluster.ComponentTemplateNodeDescriptor<TDocument>>, FluentDescriptorDictionary<string, Elastic.Clients.Elasticsearch.Cluster.ComponentTemplateNodeDescriptor<TDocument>>> selector)
	{
		ComponentTemplateSubstitutionsValue = selector?.Invoke(new FluentDescriptorDictionary<string, Elastic.Clients.Elasticsearch.Cluster.ComponentTemplateNodeDescriptor<TDocument>>());
		return Self;
	}

	/// <summary>
	/// <para>
	/// Sample documents to test in the pipeline.
	/// </para>
	/// </summary>
	public IngestRequestDescriptor<TDocument> Docs(ICollection<Elastic.Clients.Elasticsearch.Ingest.Document> docs)
	{
		DocsDescriptor = null;
		DocsDescriptorAction = null;
		DocsDescriptorActions = null;
		DocsValue = docs;
		return Self;
	}

	public IngestRequestDescriptor<TDocument> Docs(Elastic.Clients.Elasticsearch.Ingest.DocumentDescriptor descriptor)
	{
		DocsValue = null;
		DocsDescriptorAction = null;
		DocsDescriptorActions = null;
		DocsDescriptor = descriptor;
		return Self;
	}

	public IngestRequestDescriptor<TDocument> Docs(Action<Elastic.Clients.Elasticsearch.Ingest.DocumentDescriptor> configure)
	{
		DocsValue = null;
		DocsDescriptor = null;
		DocsDescriptorActions = null;
		DocsDescriptorAction = configure;
		return Self;
	}

	public IngestRequestDescriptor<TDocument> Docs(params Action<Elastic.Clients.Elasticsearch.Ingest.DocumentDescriptor>[] configure)
	{
		DocsValue = null;
		DocsDescriptor = null;
		DocsDescriptorAction = null;
		DocsDescriptorActions = configure;
		return Self;
	}

	/// <summary>
	/// <para>
	/// A map of index template names to substitute index template definition objects.
	/// </para>
	/// </summary>
	public IngestRequestDescriptor<TDocument> IndexTemplateSubstitutions(Func<FluentDescriptorDictionary<string, Elastic.Clients.Elasticsearch.IndexManagement.IndexTemplateDescriptor<TDocument>>, FluentDescriptorDictionary<string, Elastic.Clients.Elasticsearch.IndexManagement.IndexTemplateDescriptor<TDocument>>> selector)
	{
		IndexTemplateSubstitutionsValue = selector?.Invoke(new FluentDescriptorDictionary<string, Elastic.Clients.Elasticsearch.IndexManagement.IndexTemplateDescriptor<TDocument>>());
		return Self;
	}

	public IngestRequestDescriptor<TDocument> MappingAddition(Elastic.Clients.Elasticsearch.Mapping.TypeMapping? mappingAddition)
	{
		MappingAdditionDescriptor = null;
		MappingAdditionDescriptorAction = null;
		MappingAdditionValue = mappingAddition;
		return Self;
	}

	public IngestRequestDescriptor<TDocument> MappingAddition(Elastic.Clients.Elasticsearch.Mapping.TypeMappingDescriptor<TDocument> descriptor)
	{
		MappingAdditionValue = null;
		MappingAdditionDescriptorAction = null;
		MappingAdditionDescriptor = descriptor;
		return Self;
	}

	public IngestRequestDescriptor<TDocument> MappingAddition(Action<Elastic.Clients.Elasticsearch.Mapping.TypeMappingDescriptor<TDocument>> configure)
	{
		MappingAdditionValue = null;
		MappingAdditionDescriptor = null;
		MappingAdditionDescriptorAction = configure;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Pipelines to test.
	/// If you don’t specify the <c>pipeline</c> request path parameter, this parameter is required.
	/// If you specify both this and the request path parameter, the API only uses the request path parameter.
	/// </para>
	/// </summary>
	public IngestRequestDescriptor<TDocument> PipelineSubstitutions(Func<FluentDescriptorDictionary<string, Elastic.Clients.Elasticsearch.Ingest.PipelineDescriptor<TDocument>>, FluentDescriptorDictionary<string, Elastic.Clients.Elasticsearch.Ingest.PipelineDescriptor<TDocument>>> selector)
	{
		PipelineSubstitutionsValue = selector?.Invoke(new FluentDescriptorDictionary<string, Elastic.Clients.Elasticsearch.Ingest.PipelineDescriptor<TDocument>>());
		return Self;
	}

	protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
	{
		writer.WriteStartObject();
		if (ComponentTemplateSubstitutionsValue is not null)
		{
			writer.WritePropertyName("component_template_substitutions");
			JsonSerializer.Serialize(writer, ComponentTemplateSubstitutionsValue, options);
		}

		if (DocsDescriptor is not null)
		{
			writer.WritePropertyName("docs");
			writer.WriteStartArray();
			JsonSerializer.Serialize(writer, DocsDescriptor, options);
			writer.WriteEndArray();
		}
		else if (DocsDescriptorAction is not null)
		{
			writer.WritePropertyName("docs");
			writer.WriteStartArray();
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.Ingest.DocumentDescriptor(DocsDescriptorAction), options);
			writer.WriteEndArray();
		}
		else if (DocsDescriptorActions is not null)
		{
			writer.WritePropertyName("docs");
			writer.WriteStartArray();
			foreach (var action in DocsDescriptorActions)
			{
				JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.Ingest.DocumentDescriptor(action), options);
			}

			writer.WriteEndArray();
		}
		else
		{
			writer.WritePropertyName("docs");
			JsonSerializer.Serialize(writer, DocsValue, options);
		}

		if (IndexTemplateSubstitutionsValue is not null)
		{
			writer.WritePropertyName("index_template_substitutions");
			JsonSerializer.Serialize(writer, IndexTemplateSubstitutionsValue, options);
		}

		if (MappingAdditionDescriptor is not null)
		{
			writer.WritePropertyName("mapping_addition");
			JsonSerializer.Serialize(writer, MappingAdditionDescriptor, options);
		}
		else if (MappingAdditionDescriptorAction is not null)
		{
			writer.WritePropertyName("mapping_addition");
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.Mapping.TypeMappingDescriptor<TDocument>(MappingAdditionDescriptorAction), options);
		}
		else if (MappingAdditionValue is not null)
		{
			writer.WritePropertyName("mapping_addition");
			JsonSerializer.Serialize(writer, MappingAdditionValue, options);
		}

		if (PipelineSubstitutionsValue is not null)
		{
			writer.WritePropertyName("pipeline_substitutions");
			JsonSerializer.Serialize(writer, PipelineSubstitutionsValue, options);
		}

		writer.WriteEndObject();
	}
}

/// <summary>
/// <para>
/// Simulate data ingestion.
/// Run ingest pipelines against a set of provided documents, optionally with substitute pipeline definitions, to simulate ingesting data into an index.
/// </para>
/// <para>
/// This API is meant to be used for troubleshooting or pipeline development, as it does not actually index any data into Elasticsearch.
/// </para>
/// <para>
/// The API runs the default and final pipeline for that index against a set of documents provided in the body of the request.
/// If a pipeline contains a reroute processor, it follows that reroute processor to the new index, running that index's pipelines as well the same way that a non-simulated ingest would.
/// No data is indexed into Elasticsearch.
/// Instead, the transformed document is returned, along with the list of pipelines that have been run and the name of the index where the document would have been indexed if this were not a simulation.
/// The transformed document is validated against the mappings that would apply to this index, and any validation error is reported in the result.
/// </para>
/// <para>
/// This API differs from the simulate pipeline API in that you specify a single pipeline for that API, and it runs only that one pipeline.
/// The simulate pipeline API is more useful for developing a single pipeline, while the simulate ingest API is more useful for troubleshooting the interaction of the various pipelines that get applied when ingesting into an index.
/// </para>
/// <para>
/// By default, the pipeline definitions that are currently in the system are used.
/// However, you can supply substitute pipeline definitions in the body of the request.
/// These will be used in place of the pipeline definitions that are already in the system. This can be used to replace existing pipeline definitions or to create new ones. The pipeline substitutions are used only within this request.
/// </para>
/// </summary>
public sealed partial class IngestRequestDescriptor : RequestDescriptor<IngestRequestDescriptor, IngestRequestParameters>
{
	internal IngestRequestDescriptor(Action<IngestRequestDescriptor> configure) => configure.Invoke(this);

	public IngestRequestDescriptor(Elastic.Clients.Elasticsearch.IndexName? index) : base(r => r.Optional("index", index))
	{
	}

	public IngestRequestDescriptor()
	{
	}

	internal override ApiUrls ApiUrls => ApiUrlLookup.SimulateIngest;

	protected override HttpMethod StaticHttpMethod => HttpMethod.POST;

	internal override bool SupportsBody => true;

	internal override string OperationName => "simulate.ingest";

	public IngestRequestDescriptor Pipeline(string? pipeline) => Qs("pipeline", pipeline);

	public IngestRequestDescriptor Index(Elastic.Clients.Elasticsearch.IndexName? index)
	{
		RouteValues.Optional("index", index);
		return Self;
	}

	private IDictionary<string, Elastic.Clients.Elasticsearch.Cluster.ComponentTemplateNodeDescriptor> ComponentTemplateSubstitutionsValue { get; set; }
	private ICollection<Elastic.Clients.Elasticsearch.Ingest.Document> DocsValue { get; set; }
	private Elastic.Clients.Elasticsearch.Ingest.DocumentDescriptor DocsDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.Ingest.DocumentDescriptor> DocsDescriptorAction { get; set; }
	private Action<Elastic.Clients.Elasticsearch.Ingest.DocumentDescriptor>[] DocsDescriptorActions { get; set; }
	private IDictionary<string, Elastic.Clients.Elasticsearch.IndexManagement.IndexTemplateDescriptor> IndexTemplateSubstitutionsValue { get; set; }
	private Elastic.Clients.Elasticsearch.Mapping.TypeMapping? MappingAdditionValue { get; set; }
	private Elastic.Clients.Elasticsearch.Mapping.TypeMappingDescriptor MappingAdditionDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.Mapping.TypeMappingDescriptor> MappingAdditionDescriptorAction { get; set; }
	private IDictionary<string, Elastic.Clients.Elasticsearch.Ingest.PipelineDescriptor> PipelineSubstitutionsValue { get; set; }

	/// <summary>
	/// <para>
	/// A map of component template names to substitute component template definition objects.
	/// </para>
	/// </summary>
	public IngestRequestDescriptor ComponentTemplateSubstitutions(Func<FluentDescriptorDictionary<string, Elastic.Clients.Elasticsearch.Cluster.ComponentTemplateNodeDescriptor>, FluentDescriptorDictionary<string, Elastic.Clients.Elasticsearch.Cluster.ComponentTemplateNodeDescriptor>> selector)
	{
		ComponentTemplateSubstitutionsValue = selector?.Invoke(new FluentDescriptorDictionary<string, Elastic.Clients.Elasticsearch.Cluster.ComponentTemplateNodeDescriptor>());
		return Self;
	}

	/// <summary>
	/// <para>
	/// Sample documents to test in the pipeline.
	/// </para>
	/// </summary>
	public IngestRequestDescriptor Docs(ICollection<Elastic.Clients.Elasticsearch.Ingest.Document> docs)
	{
		DocsDescriptor = null;
		DocsDescriptorAction = null;
		DocsDescriptorActions = null;
		DocsValue = docs;
		return Self;
	}

	public IngestRequestDescriptor Docs(Elastic.Clients.Elasticsearch.Ingest.DocumentDescriptor descriptor)
	{
		DocsValue = null;
		DocsDescriptorAction = null;
		DocsDescriptorActions = null;
		DocsDescriptor = descriptor;
		return Self;
	}

	public IngestRequestDescriptor Docs(Action<Elastic.Clients.Elasticsearch.Ingest.DocumentDescriptor> configure)
	{
		DocsValue = null;
		DocsDescriptor = null;
		DocsDescriptorActions = null;
		DocsDescriptorAction = configure;
		return Self;
	}

	public IngestRequestDescriptor Docs(params Action<Elastic.Clients.Elasticsearch.Ingest.DocumentDescriptor>[] configure)
	{
		DocsValue = null;
		DocsDescriptor = null;
		DocsDescriptorAction = null;
		DocsDescriptorActions = configure;
		return Self;
	}

	/// <summary>
	/// <para>
	/// A map of index template names to substitute index template definition objects.
	/// </para>
	/// </summary>
	public IngestRequestDescriptor IndexTemplateSubstitutions(Func<FluentDescriptorDictionary<string, Elastic.Clients.Elasticsearch.IndexManagement.IndexTemplateDescriptor>, FluentDescriptorDictionary<string, Elastic.Clients.Elasticsearch.IndexManagement.IndexTemplateDescriptor>> selector)
	{
		IndexTemplateSubstitutionsValue = selector?.Invoke(new FluentDescriptorDictionary<string, Elastic.Clients.Elasticsearch.IndexManagement.IndexTemplateDescriptor>());
		return Self;
	}

	public IngestRequestDescriptor MappingAddition(Elastic.Clients.Elasticsearch.Mapping.TypeMapping? mappingAddition)
	{
		MappingAdditionDescriptor = null;
		MappingAdditionDescriptorAction = null;
		MappingAdditionValue = mappingAddition;
		return Self;
	}

	public IngestRequestDescriptor MappingAddition(Elastic.Clients.Elasticsearch.Mapping.TypeMappingDescriptor descriptor)
	{
		MappingAdditionValue = null;
		MappingAdditionDescriptorAction = null;
		MappingAdditionDescriptor = descriptor;
		return Self;
	}

	public IngestRequestDescriptor MappingAddition(Action<Elastic.Clients.Elasticsearch.Mapping.TypeMappingDescriptor> configure)
	{
		MappingAdditionValue = null;
		MappingAdditionDescriptor = null;
		MappingAdditionDescriptorAction = configure;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Pipelines to test.
	/// If you don’t specify the <c>pipeline</c> request path parameter, this parameter is required.
	/// If you specify both this and the request path parameter, the API only uses the request path parameter.
	/// </para>
	/// </summary>
	public IngestRequestDescriptor PipelineSubstitutions(Func<FluentDescriptorDictionary<string, Elastic.Clients.Elasticsearch.Ingest.PipelineDescriptor>, FluentDescriptorDictionary<string, Elastic.Clients.Elasticsearch.Ingest.PipelineDescriptor>> selector)
	{
		PipelineSubstitutionsValue = selector?.Invoke(new FluentDescriptorDictionary<string, Elastic.Clients.Elasticsearch.Ingest.PipelineDescriptor>());
		return Self;
	}

	protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
	{
		writer.WriteStartObject();
		if (ComponentTemplateSubstitutionsValue is not null)
		{
			writer.WritePropertyName("component_template_substitutions");
			JsonSerializer.Serialize(writer, ComponentTemplateSubstitutionsValue, options);
		}

		if (DocsDescriptor is not null)
		{
			writer.WritePropertyName("docs");
			writer.WriteStartArray();
			JsonSerializer.Serialize(writer, DocsDescriptor, options);
			writer.WriteEndArray();
		}
		else if (DocsDescriptorAction is not null)
		{
			writer.WritePropertyName("docs");
			writer.WriteStartArray();
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.Ingest.DocumentDescriptor(DocsDescriptorAction), options);
			writer.WriteEndArray();
		}
		else if (DocsDescriptorActions is not null)
		{
			writer.WritePropertyName("docs");
			writer.WriteStartArray();
			foreach (var action in DocsDescriptorActions)
			{
				JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.Ingest.DocumentDescriptor(action), options);
			}

			writer.WriteEndArray();
		}
		else
		{
			writer.WritePropertyName("docs");
			JsonSerializer.Serialize(writer, DocsValue, options);
		}

		if (IndexTemplateSubstitutionsValue is not null)
		{
			writer.WritePropertyName("index_template_substitutions");
			JsonSerializer.Serialize(writer, IndexTemplateSubstitutionsValue, options);
		}

		if (MappingAdditionDescriptor is not null)
		{
			writer.WritePropertyName("mapping_addition");
			JsonSerializer.Serialize(writer, MappingAdditionDescriptor, options);
		}
		else if (MappingAdditionDescriptorAction is not null)
		{
			writer.WritePropertyName("mapping_addition");
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.Mapping.TypeMappingDescriptor(MappingAdditionDescriptorAction), options);
		}
		else if (MappingAdditionValue is not null)
		{
			writer.WritePropertyName("mapping_addition");
			JsonSerializer.Serialize(writer, MappingAdditionValue, options);
		}

		if (PipelineSubstitutionsValue is not null)
		{
			writer.WritePropertyName("pipeline_substitutions");
			JsonSerializer.Serialize(writer, PipelineSubstitutionsValue, options);
		}

		writer.WriteEndObject();
	}
}