// Licensed to Elasticsearch B.V under one or more agreements.
// Elasticsearch B.V licenses this file to you under the Apache 2.0 License.
// See the LICENSE file in the project root for more information.
//
// ███╗   ██╗ ██████╗ ████████╗██╗ ██████╗███████╗
// ████╗  ██║██╔═══██╗╚══██╔══╝██║██╔════╝██╔════╝
// ██╔██╗ ██║██║   ██║   ██║   ██║██║     █████╗
// ██║╚██╗██║██║   ██║   ██║   ██║██║     ██╔══╝
// ██║ ╚████║╚██████╔╝   ██║   ██║╚██████╗███████╗
// ╚═╝  ╚═══╝ ╚═════╝    ╚═╝   ╚═╝ ╚═════╝╚══════╝
// ------------------------------------------------
//
// This file is automatically generated.
// Please do not edit these files manually.
//
// ------------------------------------------------

#nullable restore

using Elastic.Clients.Elasticsearch.Fluent;
using Elastic.Clients.Elasticsearch.Requests;
using Elastic.Clients.Elasticsearch.Serialization;
using Elastic.Transport;
using Elastic.Transport.Extensions;
using System;
using System.Collections.Generic;
using System.Linq.Expressions;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace Elastic.Clients.Elasticsearch.Security;

public sealed partial class ChangePasswordRequestParameters : RequestParameters
{
	/// <summary>
	/// <para>
	/// If <c>true</c> (the default) then refresh the affected shards to make this operation visible to search, if <c>wait_for</c> then wait for a refresh to make this operation visible to search, if <c>false</c> then do nothing with refreshes.
	/// </para>
	/// </summary>
	public Elastic.Clients.Elasticsearch.Refresh? Refresh { get => Q<Elastic.Clients.Elasticsearch.Refresh?>("refresh"); set => Q("refresh", value); }
}

/// <summary>
/// <para>
/// Change passwords.
/// </para>
/// <para>
/// Change the passwords of users in the native realm and built-in users.
/// </para>
/// </summary>
public sealed partial class ChangePasswordRequest : PlainRequest<ChangePasswordRequestParameters>
{
	[JsonConstructor]
	public ChangePasswordRequest()
	{
	}

	public ChangePasswordRequest(Elastic.Clients.Elasticsearch.Username? username) : base(r => r.Optional("username", username))
	{
	}

	internal override ApiUrls ApiUrls => ApiUrlLookup.SecurityChangePassword;

	protected override HttpMethod StaticHttpMethod => HttpMethod.PUT;

	internal override bool SupportsBody => true;

	internal override string OperationName => "security.change_password";

	/// <summary>
	/// <para>
	/// The user whose password you want to change. If you do not specify this
	/// parameter, the password is changed for the current user.
	/// </para>
	/// </summary>
	[JsonIgnore]
	public Elastic.Clients.Elasticsearch.Username? Username { get => P<Elastic.Clients.Elasticsearch.Username?>("username"); set => PO("username", value); }

	/// <summary>
	/// <para>
	/// If <c>true</c> (the default) then refresh the affected shards to make this operation visible to search, if <c>wait_for</c> then wait for a refresh to make this operation visible to search, if <c>false</c> then do nothing with refreshes.
	/// </para>
	/// </summary>
	[JsonIgnore]
	public Elastic.Clients.Elasticsearch.Refresh? Refresh { get => Q<Elastic.Clients.Elasticsearch.Refresh?>("refresh"); set => Q("refresh", value); }

	/// <summary>
	/// <para>
	/// The new password value. Passwords must be at least 6 characters long.
	/// </para>
	/// </summary>
	[JsonInclude, JsonPropertyName("password")]
	public string? Password { get; set; }

	/// <summary>
	/// <para>
	/// A hash of the new password value. This must be produced using the same
	/// hashing algorithm as has been configured for password storage. For more details,
	/// see the explanation of the <c>xpack.security.authc.password_hashing.algorithm</c>
	/// setting.
	/// </para>
	/// </summary>
	[JsonInclude, JsonPropertyName("password_hash")]
	public string? PasswordHash { get; set; }
}

/// <summary>
/// <para>
/// Change passwords.
/// </para>
/// <para>
/// Change the passwords of users in the native realm and built-in users.
/// </para>
/// </summary>
public sealed partial class ChangePasswordRequestDescriptor : RequestDescriptor<ChangePasswordRequestDescriptor, ChangePasswordRequestParameters>
{
	internal ChangePasswordRequestDescriptor(Action<ChangePasswordRequestDescriptor> configure) => configure.Invoke(this);

	public ChangePasswordRequestDescriptor(Elastic.Clients.Elasticsearch.Username? username) : base(r => r.Optional("username", username))
	{
	}

	public ChangePasswordRequestDescriptor()
	{
	}

	internal override ApiUrls ApiUrls => ApiUrlLookup.SecurityChangePassword;

	protected override HttpMethod StaticHttpMethod => HttpMethod.PUT;

	internal override bool SupportsBody => true;

	internal override string OperationName => "security.change_password";

	public ChangePasswordRequestDescriptor Refresh(Elastic.Clients.Elasticsearch.Refresh? refresh) => Qs("refresh", refresh);

	public ChangePasswordRequestDescriptor Username(Elastic.Clients.Elasticsearch.Username? username)
	{
		RouteValues.Optional("username", username);
		return Self;
	}

	private string? PasswordValue { get; set; }
	private string? PasswordHashValue { get; set; }

	/// <summary>
	/// <para>
	/// The new password value. Passwords must be at least 6 characters long.
	/// </para>
	/// </summary>
	public ChangePasswordRequestDescriptor Password(string? password)
	{
		PasswordValue = password;
		return Self;
	}

	/// <summary>
	/// <para>
	/// A hash of the new password value. This must be produced using the same
	/// hashing algorithm as has been configured for password storage. For more details,
	/// see the explanation of the <c>xpack.security.authc.password_hashing.algorithm</c>
	/// setting.
	/// </para>
	/// </summary>
	public ChangePasswordRequestDescriptor PasswordHash(string? passwordHash)
	{
		PasswordHashValue = passwordHash;
		return Self;
	}

	protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
	{
		writer.WriteStartObject();
		if (!string.IsNullOrEmpty(PasswordValue))
		{
			writer.WritePropertyName("password");
			writer.WriteStringValue(PasswordValue);
		}

		if (!string.IsNullOrEmpty(PasswordHashValue))
		{
			writer.WritePropertyName("password_hash");
			writer.WriteStringValue(PasswordHashValue);
		}

		writer.WriteEndObject();
	}
}