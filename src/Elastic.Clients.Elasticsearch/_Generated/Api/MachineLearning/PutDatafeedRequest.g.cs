// Licensed to Elasticsearch B.V under one or more agreements.
// Elasticsearch B.V licenses this file to you under the Apache 2.0 License.
// See the LICENSE file in the project root for more information.
//
// ███╗   ██╗ ██████╗ ████████╗██╗ ██████╗███████╗
// ████╗  ██║██╔═══██╗╚══██╔══╝██║██╔════╝██╔════╝
// ██╔██╗ ██║██║   ██║   ██║   ██║██║     █████╗
// ██║╚██╗██║██║   ██║   ██║   ██║██║     ██╔══╝
// ██║ ╚████║╚██████╔╝   ██║   ██║╚██████╗███████╗
// ╚═╝  ╚═══╝ ╚═════╝    ╚═╝   ╚═╝ ╚═════╝╚══════╝
// ------------------------------------------------
//
// This file is automatically generated.
// Please do not edit these files manually.
//
// ------------------------------------------------

#nullable restore

using Elastic.Clients.Elasticsearch.Fluent;
using Elastic.Clients.Elasticsearch.Requests;
using Elastic.Clients.Elasticsearch.Serialization;
using Elastic.Transport;
using Elastic.Transport.Extensions;
using System;
using System.Collections.Generic;
using System.Linq.Expressions;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace Elastic.Clients.Elasticsearch.MachineLearning;

public sealed partial class PutDatafeedRequestParameters : RequestParameters
{
	/// <summary>
	/// <para>
	/// If true, wildcard indices expressions that resolve into no concrete indices are ignored. This includes the <c>_all</c>
	/// string or when no indices are specified.
	/// </para>
	/// </summary>
	public bool? AllowNoIndices { get => Q<bool?>("allow_no_indices"); set => Q("allow_no_indices", value); }

	/// <summary>
	/// <para>
	/// Type of index that wildcard patterns can match. If the request can target data streams, this argument determines
	/// whether wildcard expressions match hidden data streams. Supports comma-separated values.
	/// </para>
	/// </summary>
	public ICollection<Elastic.Clients.Elasticsearch.ExpandWildcard>? ExpandWildcards { get => Q<ICollection<Elastic.Clients.Elasticsearch.ExpandWildcard>?>("expand_wildcards"); set => Q("expand_wildcards", value); }

	/// <summary>
	/// <para>
	/// If true, unavailable indices (missing or closed) are ignored.
	/// </para>
	/// </summary>
	public bool? IgnoreUnavailable { get => Q<bool?>("ignore_unavailable"); set => Q("ignore_unavailable", value); }
}

internal sealed partial class PutDatafeedRequestConverter : System.Text.Json.Serialization.JsonConverter<PutDatafeedRequest>
{
	private static readonly System.Text.Json.JsonEncodedText PropAggregations = System.Text.Json.JsonEncodedText.Encode("aggregations");
	private static readonly System.Text.Json.JsonEncodedText PropAggregations1 = System.Text.Json.JsonEncodedText.Encode("aggs");
	private static readonly System.Text.Json.JsonEncodedText PropChunkingConfig = System.Text.Json.JsonEncodedText.Encode("chunking_config");
	private static readonly System.Text.Json.JsonEncodedText PropDelayedDataCheckConfig = System.Text.Json.JsonEncodedText.Encode("delayed_data_check_config");
	private static readonly System.Text.Json.JsonEncodedText PropFrequency = System.Text.Json.JsonEncodedText.Encode("frequency");
	private static readonly System.Text.Json.JsonEncodedText PropHeaders = System.Text.Json.JsonEncodedText.Encode("headers");
	private static readonly System.Text.Json.JsonEncodedText PropIndices = System.Text.Json.JsonEncodedText.Encode("indices");
	private static readonly System.Text.Json.JsonEncodedText PropIndices1 = System.Text.Json.JsonEncodedText.Encode("indexes");
	private static readonly System.Text.Json.JsonEncodedText PropIndicesOptions = System.Text.Json.JsonEncodedText.Encode("indices_options");
	private static readonly System.Text.Json.JsonEncodedText PropJobId = System.Text.Json.JsonEncodedText.Encode("job_id");
	private static readonly System.Text.Json.JsonEncodedText PropMaxEmptySearches = System.Text.Json.JsonEncodedText.Encode("max_empty_searches");
	private static readonly System.Text.Json.JsonEncodedText PropQuery = System.Text.Json.JsonEncodedText.Encode("query");
	private static readonly System.Text.Json.JsonEncodedText PropQueryDelay = System.Text.Json.JsonEncodedText.Encode("query_delay");
	private static readonly System.Text.Json.JsonEncodedText PropRuntimeMappings = System.Text.Json.JsonEncodedText.Encode("runtime_mappings");
	private static readonly System.Text.Json.JsonEncodedText PropScriptFields = System.Text.Json.JsonEncodedText.Encode("script_fields");
	private static readonly System.Text.Json.JsonEncodedText PropScrollSize = System.Text.Json.JsonEncodedText.Encode("scroll_size");

	public override PutDatafeedRequest Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.StartObject);
		LocalJsonValue<IDictionary<string, Elastic.Clients.Elasticsearch.Aggregations.Aggregation>?> propAggregations = default;
		LocalJsonValue<Elastic.Clients.Elasticsearch.MachineLearning.ChunkingConfig?> propChunkingConfig = default;
		LocalJsonValue<Elastic.Clients.Elasticsearch.MachineLearning.DelayedDataCheckConfig?> propDelayedDataCheckConfig = default;
		LocalJsonValue<Elastic.Clients.Elasticsearch.Duration?> propFrequency = default;
		LocalJsonValue<IDictionary<string, Union<string, ICollection<string>>>?> propHeaders = default;
		LocalJsonValue<Elastic.Clients.Elasticsearch.Indices?> propIndices = default;
		LocalJsonValue<Elastic.Clients.Elasticsearch.IndicesOptions?> propIndicesOptions = default;
		LocalJsonValue<Elastic.Clients.Elasticsearch.Id?> propJobId = default;
		LocalJsonValue<int?> propMaxEmptySearches = default;
		LocalJsonValue<Elastic.Clients.Elasticsearch.QueryDsl.Query?> propQuery = default;
		LocalJsonValue<Elastic.Clients.Elasticsearch.Duration?> propQueryDelay = default;
		LocalJsonValue<IDictionary<Elastic.Clients.Elasticsearch.Field, Elastic.Clients.Elasticsearch.Mapping.RuntimeField>?> propRuntimeMappings = default;
		LocalJsonValue<IDictionary<string, Elastic.Clients.Elasticsearch.ScriptField>?> propScriptFields = default;
		LocalJsonValue<int?> propScrollSize = default;
		while (reader.Read() && reader.TokenType is System.Text.Json.JsonTokenType.PropertyName)
		{
			if (propAggregations.TryReadProperty(ref reader, options, PropAggregations, static IDictionary<string, Elastic.Clients.Elasticsearch.Aggregations.Aggregation>? (ref System.Text.Json.Utf8JsonReader r, System.Text.Json.JsonSerializerOptions o) => r.ReadDictionaryValue<string, Elastic.Clients.Elasticsearch.Aggregations.Aggregation>(o, null, null)) || propAggregations.TryReadProperty(ref reader, options, PropAggregations1, static IDictionary<string, Elastic.Clients.Elasticsearch.Aggregations.Aggregation>? (ref System.Text.Json.Utf8JsonReader r, System.Text.Json.JsonSerializerOptions o) => r.ReadDictionaryValue<string, Elastic.Clients.Elasticsearch.Aggregations.Aggregation>(o, null, null)))
			{
				continue;
			}

			if (propChunkingConfig.TryReadProperty(ref reader, options, PropChunkingConfig, null))
			{
				continue;
			}

			if (propDelayedDataCheckConfig.TryReadProperty(ref reader, options, PropDelayedDataCheckConfig, null))
			{
				continue;
			}

			if (propFrequency.TryReadProperty(ref reader, options, PropFrequency, null))
			{
				continue;
			}

			if (propHeaders.TryReadProperty(ref reader, options, PropHeaders, static IDictionary<string, Union<string, ICollection<string>>>? (ref System.Text.Json.Utf8JsonReader r, System.Text.Json.JsonSerializerOptions o) => r.ReadDictionaryValue<string, Union<string, ICollection<string>>>(o, null, static Union<string, ICollection<string>> (ref System.Text.Json.Utf8JsonReader r, System.Text.Json.JsonSerializerOptions o) => r.ReadUnionValue<string, ICollection<string>>(o, static (ref System.Text.Json.Utf8JsonReader r, System.Text.Json.JsonSerializerOptions o) => JsonUnionSelector.ByTokenType(ref r, o, Elastic.Clients.Elasticsearch.Serialization.JsonTokenTypes.String, Elastic.Clients.Elasticsearch.Serialization.JsonTokenTypes.StartArray), null, static ICollection<string> (ref System.Text.Json.Utf8JsonReader r, System.Text.Json.JsonSerializerOptions o) => r.ReadSingleOrManyCollectionValue<string>(o, null)!)!)))
			{
				continue;
			}

			if (propIndices.TryReadProperty(ref reader, options, PropIndices, null) || propIndices.TryReadProperty(ref reader, options, PropIndices1, null))
			{
				continue;
			}

			if (propIndicesOptions.TryReadProperty(ref reader, options, PropIndicesOptions, null))
			{
				continue;
			}

			if (propJobId.TryReadProperty(ref reader, options, PropJobId, null))
			{
				continue;
			}

			if (propMaxEmptySearches.TryReadProperty(ref reader, options, PropMaxEmptySearches, null))
			{
				continue;
			}

			if (propQuery.TryReadProperty(ref reader, options, PropQuery, null))
			{
				continue;
			}

			if (propQueryDelay.TryReadProperty(ref reader, options, PropQueryDelay, null))
			{
				continue;
			}

			if (propRuntimeMappings.TryReadProperty(ref reader, options, PropRuntimeMappings, static IDictionary<Elastic.Clients.Elasticsearch.Field, Elastic.Clients.Elasticsearch.Mapping.RuntimeField>? (ref System.Text.Json.Utf8JsonReader r, System.Text.Json.JsonSerializerOptions o) => r.ReadDictionaryValue<Elastic.Clients.Elasticsearch.Field, Elastic.Clients.Elasticsearch.Mapping.RuntimeField>(o, null, null)))
			{
				continue;
			}

			if (propScriptFields.TryReadProperty(ref reader, options, PropScriptFields, static IDictionary<string, Elastic.Clients.Elasticsearch.ScriptField>? (ref System.Text.Json.Utf8JsonReader r, System.Text.Json.JsonSerializerOptions o) => r.ReadDictionaryValue<string, Elastic.Clients.Elasticsearch.ScriptField>(o, null, null)))
			{
				continue;
			}

			if (propScrollSize.TryReadProperty(ref reader, options, PropScrollSize, null))
			{
				continue;
			}

			throw new System.Text.Json.JsonException($"Unknown JSON property '{reader.GetString()}' for type '{typeToConvert.Name}'.");
		}

		reader.ValidateToken(System.Text.Json.JsonTokenType.EndObject);
		return new PutDatafeedRequest
		{
			Aggregations = propAggregations.Value
	,
			ChunkingConfig = propChunkingConfig.Value
	,
			DelayedDataCheckConfig = propDelayedDataCheckConfig.Value
	,
			Frequency = propFrequency.Value
	,
			Headers = propHeaders.Value
	,
			Indices = propIndices.Value
	,
			IndicesOptions = propIndicesOptions.Value
	,
			JobId = propJobId.Value
	,
			MaxEmptySearches = propMaxEmptySearches.Value
	,
			Query = propQuery.Value
	,
			QueryDelay = propQueryDelay.Value
	,
			RuntimeMappings = propRuntimeMappings.Value
	,
			ScriptFields = propScriptFields.Value
	,
			ScrollSize = propScrollSize.Value
		};
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, PutDatafeedRequest value, System.Text.Json.JsonSerializerOptions options)
	{
		writer.WriteStartObject();
		writer.WriteProperty(options, PropAggregations, value.Aggregations, null, static (System.Text.Json.Utf8JsonWriter w, System.Text.Json.JsonSerializerOptions o, IDictionary<string, Elastic.Clients.Elasticsearch.Aggregations.Aggregation>? v) => w.WriteDictionaryValue<string, Elastic.Clients.Elasticsearch.Aggregations.Aggregation>(o, v, null, null));
		writer.WriteProperty(options, PropChunkingConfig, value.ChunkingConfig, null, null);
		writer.WriteProperty(options, PropDelayedDataCheckConfig, value.DelayedDataCheckConfig, null, null);
		writer.WriteProperty(options, PropFrequency, value.Frequency, null, null);
		writer.WriteProperty(options, PropHeaders, value.Headers, null, static (System.Text.Json.Utf8JsonWriter w, System.Text.Json.JsonSerializerOptions o, IDictionary<string, Union<string, ICollection<string>>>? v) => w.WriteDictionaryValue<string, Union<string, ICollection<string>>>(o, v, null, static (System.Text.Json.Utf8JsonWriter w, System.Text.Json.JsonSerializerOptions o, Union<string, ICollection<string>> v) => w.WriteUnionValue<string, ICollection<string>>(o, v, null, static (System.Text.Json.Utf8JsonWriter w, System.Text.Json.JsonSerializerOptions o, ICollection<string> v) => w.WriteSingleOrManyCollectionValue<string>(o, v, null))));
		writer.WriteProperty(options, PropIndices, value.Indices, null, null);
		writer.WriteProperty(options, PropIndicesOptions, value.IndicesOptions, null, null);
		writer.WriteProperty(options, PropJobId, value.JobId, null, null);
		writer.WriteProperty(options, PropMaxEmptySearches, value.MaxEmptySearches, null, null);
		writer.WriteProperty(options, PropQuery, value.Query, null, null);
		writer.WriteProperty(options, PropQueryDelay, value.QueryDelay, null, null);
		writer.WriteProperty(options, PropRuntimeMappings, value.RuntimeMappings, null, static (System.Text.Json.Utf8JsonWriter w, System.Text.Json.JsonSerializerOptions o, IDictionary<Elastic.Clients.Elasticsearch.Field, Elastic.Clients.Elasticsearch.Mapping.RuntimeField>? v) => w.WriteDictionaryValue<Elastic.Clients.Elasticsearch.Field, Elastic.Clients.Elasticsearch.Mapping.RuntimeField>(o, v, null, null));
		writer.WriteProperty(options, PropScriptFields, value.ScriptFields, null, static (System.Text.Json.Utf8JsonWriter w, System.Text.Json.JsonSerializerOptions o, IDictionary<string, Elastic.Clients.Elasticsearch.ScriptField>? v) => w.WriteDictionaryValue<string, Elastic.Clients.Elasticsearch.ScriptField>(o, v, null, null));
		writer.WriteProperty(options, PropScrollSize, value.ScrollSize, null, null);
		writer.WriteEndObject();
	}
}

/// <summary>
/// <para>
/// Create a datafeed.
/// Datafeeds retrieve data from Elasticsearch for analysis by an anomaly detection job.
/// You can associate only one datafeed with each anomaly detection job.
/// The datafeed contains a query that runs at a defined interval (<c>frequency</c>).
/// If you are concerned about delayed data, you can add a delay (<c>query_delay</c>) at each interval.
/// When Elasticsearch security features are enabled, your datafeed remembers which roles the user who created it had
/// at the time of creation and runs the query using those same roles. If you provide secondary authorization headers,
/// those credentials are used instead.
/// You must use Kibana, this API, or the create anomaly detection jobs API to create a datafeed. Do not add a datafeed
/// directly to the <c>.ml-config</c> index. Do not give users <c>write</c> privileges on the <c>.ml-config</c> index.
/// </para>
/// </summary>
[JsonConverter(typeof(PutDatafeedRequestConverter))]
public sealed partial class PutDatafeedRequest : PlainRequest<PutDatafeedRequestParameters>
{
	public PutDatafeedRequest(Elastic.Clients.Elasticsearch.Id datafeedId) : base(r => r.Required("datafeed_id", datafeedId))
	{
	}

	[JsonConstructor]
	internal PutDatafeedRequest()
	{
	}

	internal override ApiUrls ApiUrls => ApiUrlLookup.MachineLearningPutDatafeed;

	protected override HttpMethod StaticHttpMethod => HttpMethod.PUT;

	internal override bool SupportsBody => true;

	internal override string OperationName => "ml.put_datafeed";

	/// <summary>
	/// <para>
	/// A numerical character string that uniquely identifies the datafeed.
	/// This identifier can contain lowercase alphanumeric characters (a-z and 0-9), hyphens, and underscores.
	/// It must start and end with alphanumeric characters.
	/// </para>
	/// </summary>
	public Elastic.Clients.Elasticsearch.Id DatafeedId { get => P<Elastic.Clients.Elasticsearch.Id>("datafeed_id"); set => PR("datafeed_id", value); }

	/// <summary>
	/// <para>
	/// If true, wildcard indices expressions that resolve into no concrete indices are ignored. This includes the <c>_all</c>
	/// string or when no indices are specified.
	/// </para>
	/// </summary>
	public bool? AllowNoIndices { get => Q<bool?>("allow_no_indices"); set => Q("allow_no_indices", value); }

	/// <summary>
	/// <para>
	/// Type of index that wildcard patterns can match. If the request can target data streams, this argument determines
	/// whether wildcard expressions match hidden data streams. Supports comma-separated values.
	/// </para>
	/// </summary>
	public ICollection<Elastic.Clients.Elasticsearch.ExpandWildcard>? ExpandWildcards { get => Q<ICollection<Elastic.Clients.Elasticsearch.ExpandWildcard>?>("expand_wildcards"); set => Q("expand_wildcards", value); }

	/// <summary>
	/// <para>
	/// If true, unavailable indices (missing or closed) are ignored.
	/// </para>
	/// </summary>
	public bool? IgnoreUnavailable { get => Q<bool?>("ignore_unavailable"); set => Q("ignore_unavailable", value); }

	/// <summary>
	/// <para>
	/// If set, the datafeed performs aggregation searches.
	/// Support for aggregations is limited and should be used only with low cardinality data.
	/// </para>
	/// </summary>
	public IDictionary<string, Elastic.Clients.Elasticsearch.Aggregations.Aggregation>? Aggregations { get; set; }

	/// <summary>
	/// <para>
	/// Datafeeds might be required to search over long time periods, for several months or years.
	/// This search is split into time chunks in order to ensure the load on Elasticsearch is managed.
	/// Chunking configuration controls how the size of these time chunks are calculated;
	/// it is an advanced configuration option.
	/// </para>
	/// </summary>
	public Elastic.Clients.Elasticsearch.MachineLearning.ChunkingConfig? ChunkingConfig { get; set; }

	/// <summary>
	/// <para>
	/// Specifies whether the datafeed checks for missing data and the size of the window.
	/// The datafeed can optionally search over indices that have already been read in an effort to determine whether
	/// any data has subsequently been added to the index. If missing data is found, it is a good indication that the
	/// <c>query_delay</c> is set too low and the data is being indexed after the datafeed has passed that moment in time.
	/// This check runs only on real-time datafeeds.
	/// </para>
	/// </summary>
	public Elastic.Clients.Elasticsearch.MachineLearning.DelayedDataCheckConfig? DelayedDataCheckConfig { get; set; }

	/// <summary>
	/// <para>
	/// The interval at which scheduled queries are made while the datafeed runs in real time.
	/// The default value is either the bucket span for short bucket spans, or, for longer bucket spans, a sensible
	/// fraction of the bucket span. When <c>frequency</c> is shorter than the bucket span, interim results for the last
	/// (partial) bucket are written then eventually overwritten by the full bucket results. If the datafeed uses
	/// aggregations, this value must be divisible by the interval of the date histogram aggregation.
	/// </para>
	/// </summary>
	public Elastic.Clients.Elasticsearch.Duration? Frequency { get; set; }
	public IDictionary<string, Union<string, ICollection<string>>>? Headers { get; set; }

	/// <summary>
	/// <para>
	/// An array of index names. Wildcards are supported. If any of the indices are in remote clusters, the machine
	/// learning nodes must have the <c>remote_cluster_client</c> role.
	/// </para>
	/// </summary>
	public Elastic.Clients.Elasticsearch.Indices? Indices { get; set; }

	/// <summary>
	/// <para>
	/// Specifies index expansion options that are used during search
	/// </para>
	/// </summary>
	public Elastic.Clients.Elasticsearch.IndicesOptions? IndicesOptions { get; set; }

	/// <summary>
	/// <para>
	/// Identifier for the anomaly detection job.
	/// </para>
	/// </summary>
	public Elastic.Clients.Elasticsearch.Id? JobId { get; set; }

	/// <summary>
	/// <para>
	/// If a real-time datafeed has never seen any data (including during any initial training period), it automatically
	/// stops and closes the associated job after this many real-time searches return no documents. In other words,
	/// it stops after <c>frequency</c> times <c>max_empty_searches</c> of real-time operation. If not set, a datafeed with no
	/// end time that sees no data remains started until it is explicitly stopped. By default, it is not set.
	/// </para>
	/// </summary>
	public int? MaxEmptySearches { get; set; }

	/// <summary>
	/// <para>
	/// The Elasticsearch query domain-specific language (DSL). This value corresponds to the query object in an
	/// Elasticsearch search POST body. All the options that are supported by Elasticsearch can be used, as this
	/// object is passed verbatim to Elasticsearch.
	/// </para>
	/// </summary>
	public Elastic.Clients.Elasticsearch.QueryDsl.Query? Query { get; set; }

	/// <summary>
	/// <para>
	/// The number of seconds behind real time that data is queried. For example, if data from 10:04 a.m. might
	/// not be searchable in Elasticsearch until 10:06 a.m., set this property to 120 seconds. The default
	/// value is randomly selected between <c>60s</c> and <c>120s</c>. This randomness improves the query performance
	/// when there are multiple jobs running on the same node.
	/// </para>
	/// </summary>
	public Elastic.Clients.Elasticsearch.Duration? QueryDelay { get; set; }

	/// <summary>
	/// <para>
	/// Specifies runtime fields for the datafeed search.
	/// </para>
	/// </summary>
	public IDictionary<Elastic.Clients.Elasticsearch.Field, Elastic.Clients.Elasticsearch.Mapping.RuntimeField>? RuntimeMappings { get; set; }

	/// <summary>
	/// <para>
	/// Specifies scripts that evaluate custom expressions and returns script fields to the datafeed.
	/// The detector configuration objects in a job can contain functions that use these script fields.
	/// </para>
	/// </summary>
	public IDictionary<string, Elastic.Clients.Elasticsearch.ScriptField>? ScriptFields { get; set; }

	/// <summary>
	/// <para>
	/// The size parameter that is used in Elasticsearch searches when the datafeed does not use aggregations.
	/// The maximum value is the value of <c>index.max_result_window</c>, which is 10,000 by default.
	/// </para>
	/// </summary>
	public int? ScrollSize { get; set; }
}

/// <summary>
/// <para>
/// Create a datafeed.
/// Datafeeds retrieve data from Elasticsearch for analysis by an anomaly detection job.
/// You can associate only one datafeed with each anomaly detection job.
/// The datafeed contains a query that runs at a defined interval (<c>frequency</c>).
/// If you are concerned about delayed data, you can add a delay (<c>query_delay</c>) at each interval.
/// When Elasticsearch security features are enabled, your datafeed remembers which roles the user who created it had
/// at the time of creation and runs the query using those same roles. If you provide secondary authorization headers,
/// those credentials are used instead.
/// You must use Kibana, this API, or the create anomaly detection jobs API to create a datafeed. Do not add a datafeed
/// directly to the <c>.ml-config</c> index. Do not give users <c>write</c> privileges on the <c>.ml-config</c> index.
/// </para>
/// </summary>
public sealed partial class PutDatafeedRequestDescriptor<TDocument> : RequestDescriptor<PutDatafeedRequestDescriptor<TDocument>, PutDatafeedRequestParameters>
{
	internal PutDatafeedRequestDescriptor(Action<PutDatafeedRequestDescriptor<TDocument>> configure) => configure.Invoke(this);

	public PutDatafeedRequestDescriptor(Elastic.Clients.Elasticsearch.Id datafeedId) : base(r => r.Required("datafeed_id", datafeedId))
	{
	}

	internal override ApiUrls ApiUrls => ApiUrlLookup.MachineLearningPutDatafeed;

	protected override HttpMethod StaticHttpMethod => HttpMethod.PUT;

	internal override bool SupportsBody => true;

	internal override string OperationName => "ml.put_datafeed";

	public PutDatafeedRequestDescriptor<TDocument> AllowNoIndices(bool? allowNoIndices = true) => Qs("allow_no_indices", allowNoIndices);
	public PutDatafeedRequestDescriptor<TDocument> ExpandWildcards(ICollection<Elastic.Clients.Elasticsearch.ExpandWildcard>? expandWildcards) => Qs("expand_wildcards", expandWildcards);
	public PutDatafeedRequestDescriptor<TDocument> IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);

	public PutDatafeedRequestDescriptor<TDocument> DatafeedId(Elastic.Clients.Elasticsearch.Id datafeedId)
	{
		RouteValues.Required("datafeed_id", datafeedId);
		return Self;
	}

	private IDictionary<string, Elastic.Clients.Elasticsearch.Aggregations.AggregationDescriptor<TDocument>> AggregationsValue { get; set; }
	private Elastic.Clients.Elasticsearch.MachineLearning.ChunkingConfig? ChunkingConfigValue { get; set; }
	private Elastic.Clients.Elasticsearch.MachineLearning.ChunkingConfigDescriptor ChunkingConfigDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.MachineLearning.ChunkingConfigDescriptor> ChunkingConfigDescriptorAction { get; set; }
	private Elastic.Clients.Elasticsearch.MachineLearning.DelayedDataCheckConfig? DelayedDataCheckConfigValue { get; set; }
	private Elastic.Clients.Elasticsearch.MachineLearning.DelayedDataCheckConfigDescriptor DelayedDataCheckConfigDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.MachineLearning.DelayedDataCheckConfigDescriptor> DelayedDataCheckConfigDescriptorAction { get; set; }
	private Elastic.Clients.Elasticsearch.Duration? FrequencyValue { get; set; }
	private IDictionary<string, Union<string, ICollection<string>>>? HeadersValue { get; set; }
	private Elastic.Clients.Elasticsearch.Indices? IndicesValue { get; set; }
	private Elastic.Clients.Elasticsearch.IndicesOptions? IndicesOptionsValue { get; set; }
	private Elastic.Clients.Elasticsearch.IndicesOptionsDescriptor IndicesOptionsDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.IndicesOptionsDescriptor> IndicesOptionsDescriptorAction { get; set; }
	private Elastic.Clients.Elasticsearch.Id? JobIdValue { get; set; }
	private int? MaxEmptySearchesValue { get; set; }
	private Elastic.Clients.Elasticsearch.QueryDsl.Query? QueryValue { get; set; }
	private Elastic.Clients.Elasticsearch.QueryDsl.QueryDescriptor<TDocument> QueryDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.QueryDsl.QueryDescriptor<TDocument>> QueryDescriptorAction { get; set; }
	private Elastic.Clients.Elasticsearch.Duration? QueryDelayValue { get; set; }
	private IDictionary<Elastic.Clients.Elasticsearch.Field, Elastic.Clients.Elasticsearch.Mapping.RuntimeFieldDescriptor<TDocument>> RuntimeMappingsValue { get; set; }
	private IDictionary<string, Elastic.Clients.Elasticsearch.ScriptFieldDescriptor> ScriptFieldsValue { get; set; }
	private int? ScrollSizeValue { get; set; }

	/// <summary>
	/// <para>
	/// If set, the datafeed performs aggregation searches.
	/// Support for aggregations is limited and should be used only with low cardinality data.
	/// </para>
	/// </summary>
	public PutDatafeedRequestDescriptor<TDocument> Aggregations(Func<FluentDescriptorDictionary<string, Elastic.Clients.Elasticsearch.Aggregations.AggregationDescriptor<TDocument>>, FluentDescriptorDictionary<string, Elastic.Clients.Elasticsearch.Aggregations.AggregationDescriptor<TDocument>>> selector)
	{
		AggregationsValue = selector?.Invoke(new FluentDescriptorDictionary<string, Elastic.Clients.Elasticsearch.Aggregations.AggregationDescriptor<TDocument>>());
		return Self;
	}

	/// <summary>
	/// <para>
	/// Datafeeds might be required to search over long time periods, for several months or years.
	/// This search is split into time chunks in order to ensure the load on Elasticsearch is managed.
	/// Chunking configuration controls how the size of these time chunks are calculated;
	/// it is an advanced configuration option.
	/// </para>
	/// </summary>
	public PutDatafeedRequestDescriptor<TDocument> ChunkingConfig(Elastic.Clients.Elasticsearch.MachineLearning.ChunkingConfig? chunkingConfig)
	{
		ChunkingConfigDescriptor = null;
		ChunkingConfigDescriptorAction = null;
		ChunkingConfigValue = chunkingConfig;
		return Self;
	}

	public PutDatafeedRequestDescriptor<TDocument> ChunkingConfig(Elastic.Clients.Elasticsearch.MachineLearning.ChunkingConfigDescriptor descriptor)
	{
		ChunkingConfigValue = null;
		ChunkingConfigDescriptorAction = null;
		ChunkingConfigDescriptor = descriptor;
		return Self;
	}

	public PutDatafeedRequestDescriptor<TDocument> ChunkingConfig(Action<Elastic.Clients.Elasticsearch.MachineLearning.ChunkingConfigDescriptor> configure)
	{
		ChunkingConfigValue = null;
		ChunkingConfigDescriptor = null;
		ChunkingConfigDescriptorAction = configure;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Specifies whether the datafeed checks for missing data and the size of the window.
	/// The datafeed can optionally search over indices that have already been read in an effort to determine whether
	/// any data has subsequently been added to the index. If missing data is found, it is a good indication that the
	/// <c>query_delay</c> is set too low and the data is being indexed after the datafeed has passed that moment in time.
	/// This check runs only on real-time datafeeds.
	/// </para>
	/// </summary>
	public PutDatafeedRequestDescriptor<TDocument> DelayedDataCheckConfig(Elastic.Clients.Elasticsearch.MachineLearning.DelayedDataCheckConfig? delayedDataCheckConfig)
	{
		DelayedDataCheckConfigDescriptor = null;
		DelayedDataCheckConfigDescriptorAction = null;
		DelayedDataCheckConfigValue = delayedDataCheckConfig;
		return Self;
	}

	public PutDatafeedRequestDescriptor<TDocument> DelayedDataCheckConfig(Elastic.Clients.Elasticsearch.MachineLearning.DelayedDataCheckConfigDescriptor descriptor)
	{
		DelayedDataCheckConfigValue = null;
		DelayedDataCheckConfigDescriptorAction = null;
		DelayedDataCheckConfigDescriptor = descriptor;
		return Self;
	}

	public PutDatafeedRequestDescriptor<TDocument> DelayedDataCheckConfig(Action<Elastic.Clients.Elasticsearch.MachineLearning.DelayedDataCheckConfigDescriptor> configure)
	{
		DelayedDataCheckConfigValue = null;
		DelayedDataCheckConfigDescriptor = null;
		DelayedDataCheckConfigDescriptorAction = configure;
		return Self;
	}

	/// <summary>
	/// <para>
	/// The interval at which scheduled queries are made while the datafeed runs in real time.
	/// The default value is either the bucket span for short bucket spans, or, for longer bucket spans, a sensible
	/// fraction of the bucket span. When <c>frequency</c> is shorter than the bucket span, interim results for the last
	/// (partial) bucket are written then eventually overwritten by the full bucket results. If the datafeed uses
	/// aggregations, this value must be divisible by the interval of the date histogram aggregation.
	/// </para>
	/// </summary>
	public PutDatafeedRequestDescriptor<TDocument> Frequency(Elastic.Clients.Elasticsearch.Duration? frequency)
	{
		FrequencyValue = frequency;
		return Self;
	}

	public PutDatafeedRequestDescriptor<TDocument> Headers(Func<FluentDictionary<string, Union<string, ICollection<string>>>, FluentDictionary<string, Union<string, ICollection<string>>>> selector)
	{
		HeadersValue = selector?.Invoke(new FluentDictionary<string, Union<string, ICollection<string>>>());
		return Self;
	}

	/// <summary>
	/// <para>
	/// An array of index names. Wildcards are supported. If any of the indices are in remote clusters, the machine
	/// learning nodes must have the <c>remote_cluster_client</c> role.
	/// </para>
	/// </summary>
	public PutDatafeedRequestDescriptor<TDocument> Indices(Elastic.Clients.Elasticsearch.Indices? indices)
	{
		IndicesValue = indices;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Specifies index expansion options that are used during search
	/// </para>
	/// </summary>
	public PutDatafeedRequestDescriptor<TDocument> IndicesOptions(Elastic.Clients.Elasticsearch.IndicesOptions? indicesOptions)
	{
		IndicesOptionsDescriptor = null;
		IndicesOptionsDescriptorAction = null;
		IndicesOptionsValue = indicesOptions;
		return Self;
	}

	public PutDatafeedRequestDescriptor<TDocument> IndicesOptions(Elastic.Clients.Elasticsearch.IndicesOptionsDescriptor descriptor)
	{
		IndicesOptionsValue = null;
		IndicesOptionsDescriptorAction = null;
		IndicesOptionsDescriptor = descriptor;
		return Self;
	}

	public PutDatafeedRequestDescriptor<TDocument> IndicesOptions(Action<Elastic.Clients.Elasticsearch.IndicesOptionsDescriptor> configure)
	{
		IndicesOptionsValue = null;
		IndicesOptionsDescriptor = null;
		IndicesOptionsDescriptorAction = configure;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Identifier for the anomaly detection job.
	/// </para>
	/// </summary>
	public PutDatafeedRequestDescriptor<TDocument> JobId(Elastic.Clients.Elasticsearch.Id? jobId)
	{
		JobIdValue = jobId;
		return Self;
	}

	/// <summary>
	/// <para>
	/// If a real-time datafeed has never seen any data (including during any initial training period), it automatically
	/// stops and closes the associated job after this many real-time searches return no documents. In other words,
	/// it stops after <c>frequency</c> times <c>max_empty_searches</c> of real-time operation. If not set, a datafeed with no
	/// end time that sees no data remains started until it is explicitly stopped. By default, it is not set.
	/// </para>
	/// </summary>
	public PutDatafeedRequestDescriptor<TDocument> MaxEmptySearches(int? maxEmptySearches)
	{
		MaxEmptySearchesValue = maxEmptySearches;
		return Self;
	}

	/// <summary>
	/// <para>
	/// The Elasticsearch query domain-specific language (DSL). This value corresponds to the query object in an
	/// Elasticsearch search POST body. All the options that are supported by Elasticsearch can be used, as this
	/// object is passed verbatim to Elasticsearch.
	/// </para>
	/// </summary>
	public PutDatafeedRequestDescriptor<TDocument> Query(Elastic.Clients.Elasticsearch.QueryDsl.Query? query)
	{
		QueryDescriptor = null;
		QueryDescriptorAction = null;
		QueryValue = query;
		return Self;
	}

	public PutDatafeedRequestDescriptor<TDocument> Query(Elastic.Clients.Elasticsearch.QueryDsl.QueryDescriptor<TDocument> descriptor)
	{
		QueryValue = null;
		QueryDescriptorAction = null;
		QueryDescriptor = descriptor;
		return Self;
	}

	public PutDatafeedRequestDescriptor<TDocument> Query(Action<Elastic.Clients.Elasticsearch.QueryDsl.QueryDescriptor<TDocument>> configure)
	{
		QueryValue = null;
		QueryDescriptor = null;
		QueryDescriptorAction = configure;
		return Self;
	}

	/// <summary>
	/// <para>
	/// The number of seconds behind real time that data is queried. For example, if data from 10:04 a.m. might
	/// not be searchable in Elasticsearch until 10:06 a.m., set this property to 120 seconds. The default
	/// value is randomly selected between <c>60s</c> and <c>120s</c>. This randomness improves the query performance
	/// when there are multiple jobs running on the same node.
	/// </para>
	/// </summary>
	public PutDatafeedRequestDescriptor<TDocument> QueryDelay(Elastic.Clients.Elasticsearch.Duration? queryDelay)
	{
		QueryDelayValue = queryDelay;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Specifies runtime fields for the datafeed search.
	/// </para>
	/// </summary>
	public PutDatafeedRequestDescriptor<TDocument> RuntimeMappings(Func<FluentDescriptorDictionary<Elastic.Clients.Elasticsearch.Field, Elastic.Clients.Elasticsearch.Mapping.RuntimeFieldDescriptor<TDocument>>, FluentDescriptorDictionary<Elastic.Clients.Elasticsearch.Field, Elastic.Clients.Elasticsearch.Mapping.RuntimeFieldDescriptor<TDocument>>> selector)
	{
		RuntimeMappingsValue = selector?.Invoke(new FluentDescriptorDictionary<Elastic.Clients.Elasticsearch.Field, Elastic.Clients.Elasticsearch.Mapping.RuntimeFieldDescriptor<TDocument>>());
		return Self;
	}

	/// <summary>
	/// <para>
	/// Specifies scripts that evaluate custom expressions and returns script fields to the datafeed.
	/// The detector configuration objects in a job can contain functions that use these script fields.
	/// </para>
	/// </summary>
	public PutDatafeedRequestDescriptor<TDocument> ScriptFields(Func<FluentDescriptorDictionary<string, Elastic.Clients.Elasticsearch.ScriptFieldDescriptor>, FluentDescriptorDictionary<string, Elastic.Clients.Elasticsearch.ScriptFieldDescriptor>> selector)
	{
		ScriptFieldsValue = selector?.Invoke(new FluentDescriptorDictionary<string, Elastic.Clients.Elasticsearch.ScriptFieldDescriptor>());
		return Self;
	}

	/// <summary>
	/// <para>
	/// The size parameter that is used in Elasticsearch searches when the datafeed does not use aggregations.
	/// The maximum value is the value of <c>index.max_result_window</c>, which is 10,000 by default.
	/// </para>
	/// </summary>
	public PutDatafeedRequestDescriptor<TDocument> ScrollSize(int? scrollSize)
	{
		ScrollSizeValue = scrollSize;
		return Self;
	}

	protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
	{
		writer.WriteStartObject();
		if (AggregationsValue is not null)
		{
			writer.WritePropertyName("aggregations");
			JsonSerializer.Serialize(writer, AggregationsValue, options);
		}

		if (ChunkingConfigDescriptor is not null)
		{
			writer.WritePropertyName("chunking_config");
			JsonSerializer.Serialize(writer, ChunkingConfigDescriptor, options);
		}
		else if (ChunkingConfigDescriptorAction is not null)
		{
			writer.WritePropertyName("chunking_config");
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.MachineLearning.ChunkingConfigDescriptor(ChunkingConfigDescriptorAction), options);
		}
		else if (ChunkingConfigValue is not null)
		{
			writer.WritePropertyName("chunking_config");
			JsonSerializer.Serialize(writer, ChunkingConfigValue, options);
		}

		if (DelayedDataCheckConfigDescriptor is not null)
		{
			writer.WritePropertyName("delayed_data_check_config");
			JsonSerializer.Serialize(writer, DelayedDataCheckConfigDescriptor, options);
		}
		else if (DelayedDataCheckConfigDescriptorAction is not null)
		{
			writer.WritePropertyName("delayed_data_check_config");
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.MachineLearning.DelayedDataCheckConfigDescriptor(DelayedDataCheckConfigDescriptorAction), options);
		}
		else if (DelayedDataCheckConfigValue is not null)
		{
			writer.WritePropertyName("delayed_data_check_config");
			JsonSerializer.Serialize(writer, DelayedDataCheckConfigValue, options);
		}

		if (FrequencyValue is not null)
		{
			writer.WritePropertyName("frequency");
			JsonSerializer.Serialize(writer, FrequencyValue, options);
		}

		if (HeadersValue is not null)
		{
			writer.WritePropertyName("headers");
			JsonSerializer.Serialize(writer, HeadersValue, options);
		}

		if (IndicesValue is not null)
		{
			writer.WritePropertyName("indices");
			JsonSerializer.Serialize(writer, IndicesValue, options);
		}

		if (IndicesOptionsDescriptor is not null)
		{
			writer.WritePropertyName("indices_options");
			JsonSerializer.Serialize(writer, IndicesOptionsDescriptor, options);
		}
		else if (IndicesOptionsDescriptorAction is not null)
		{
			writer.WritePropertyName("indices_options");
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.IndicesOptionsDescriptor(IndicesOptionsDescriptorAction), options);
		}
		else if (IndicesOptionsValue is not null)
		{
			writer.WritePropertyName("indices_options");
			JsonSerializer.Serialize(writer, IndicesOptionsValue, options);
		}

		if (JobIdValue is not null)
		{
			writer.WritePropertyName("job_id");
			JsonSerializer.Serialize(writer, JobIdValue, options);
		}

		if (MaxEmptySearchesValue.HasValue)
		{
			writer.WritePropertyName("max_empty_searches");
			writer.WriteNumberValue(MaxEmptySearchesValue.Value);
		}

		if (QueryDescriptor is not null)
		{
			writer.WritePropertyName("query");
			JsonSerializer.Serialize(writer, QueryDescriptor, options);
		}
		else if (QueryDescriptorAction is not null)
		{
			writer.WritePropertyName("query");
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.QueryDsl.QueryDescriptor<TDocument>(QueryDescriptorAction), options);
		}
		else if (QueryValue is not null)
		{
			writer.WritePropertyName("query");
			JsonSerializer.Serialize(writer, QueryValue, options);
		}

		if (QueryDelayValue is not null)
		{
			writer.WritePropertyName("query_delay");
			JsonSerializer.Serialize(writer, QueryDelayValue, options);
		}

		if (RuntimeMappingsValue is not null)
		{
			writer.WritePropertyName("runtime_mappings");
			JsonSerializer.Serialize(writer, RuntimeMappingsValue, options);
		}

		if (ScriptFieldsValue is not null)
		{
			writer.WritePropertyName("script_fields");
			JsonSerializer.Serialize(writer, ScriptFieldsValue, options);
		}

		if (ScrollSizeValue.HasValue)
		{
			writer.WritePropertyName("scroll_size");
			writer.WriteNumberValue(ScrollSizeValue.Value);
		}

		writer.WriteEndObject();
	}
}

/// <summary>
/// <para>
/// Create a datafeed.
/// Datafeeds retrieve data from Elasticsearch for analysis by an anomaly detection job.
/// You can associate only one datafeed with each anomaly detection job.
/// The datafeed contains a query that runs at a defined interval (<c>frequency</c>).
/// If you are concerned about delayed data, you can add a delay (<c>query_delay</c>) at each interval.
/// When Elasticsearch security features are enabled, your datafeed remembers which roles the user who created it had
/// at the time of creation and runs the query using those same roles. If you provide secondary authorization headers,
/// those credentials are used instead.
/// You must use Kibana, this API, or the create anomaly detection jobs API to create a datafeed. Do not add a datafeed
/// directly to the <c>.ml-config</c> index. Do not give users <c>write</c> privileges on the <c>.ml-config</c> index.
/// </para>
/// </summary>
public sealed partial class PutDatafeedRequestDescriptor : RequestDescriptor<PutDatafeedRequestDescriptor, PutDatafeedRequestParameters>
{
	internal PutDatafeedRequestDescriptor(Action<PutDatafeedRequestDescriptor> configure) => configure.Invoke(this);

	public PutDatafeedRequestDescriptor(Elastic.Clients.Elasticsearch.Id datafeedId) : base(r => r.Required("datafeed_id", datafeedId))
	{
	}

	internal override ApiUrls ApiUrls => ApiUrlLookup.MachineLearningPutDatafeed;

	protected override HttpMethod StaticHttpMethod => HttpMethod.PUT;

	internal override bool SupportsBody => true;

	internal override string OperationName => "ml.put_datafeed";

	public PutDatafeedRequestDescriptor AllowNoIndices(bool? allowNoIndices = true) => Qs("allow_no_indices", allowNoIndices);
	public PutDatafeedRequestDescriptor ExpandWildcards(ICollection<Elastic.Clients.Elasticsearch.ExpandWildcard>? expandWildcards) => Qs("expand_wildcards", expandWildcards);
	public PutDatafeedRequestDescriptor IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);

	public PutDatafeedRequestDescriptor DatafeedId(Elastic.Clients.Elasticsearch.Id datafeedId)
	{
		RouteValues.Required("datafeed_id", datafeedId);
		return Self;
	}

	private IDictionary<string, Elastic.Clients.Elasticsearch.Aggregations.AggregationDescriptor> AggregationsValue { get; set; }
	private Elastic.Clients.Elasticsearch.MachineLearning.ChunkingConfig? ChunkingConfigValue { get; set; }
	private Elastic.Clients.Elasticsearch.MachineLearning.ChunkingConfigDescriptor ChunkingConfigDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.MachineLearning.ChunkingConfigDescriptor> ChunkingConfigDescriptorAction { get; set; }
	private Elastic.Clients.Elasticsearch.MachineLearning.DelayedDataCheckConfig? DelayedDataCheckConfigValue { get; set; }
	private Elastic.Clients.Elasticsearch.MachineLearning.DelayedDataCheckConfigDescriptor DelayedDataCheckConfigDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.MachineLearning.DelayedDataCheckConfigDescriptor> DelayedDataCheckConfigDescriptorAction { get; set; }
	private Elastic.Clients.Elasticsearch.Duration? FrequencyValue { get; set; }
	private IDictionary<string, Union<string, ICollection<string>>>? HeadersValue { get; set; }
	private Elastic.Clients.Elasticsearch.Indices? IndicesValue { get; set; }
	private Elastic.Clients.Elasticsearch.IndicesOptions? IndicesOptionsValue { get; set; }
	private Elastic.Clients.Elasticsearch.IndicesOptionsDescriptor IndicesOptionsDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.IndicesOptionsDescriptor> IndicesOptionsDescriptorAction { get; set; }
	private Elastic.Clients.Elasticsearch.Id? JobIdValue { get; set; }
	private int? MaxEmptySearchesValue { get; set; }
	private Elastic.Clients.Elasticsearch.QueryDsl.Query? QueryValue { get; set; }
	private Elastic.Clients.Elasticsearch.QueryDsl.QueryDescriptor QueryDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.QueryDsl.QueryDescriptor> QueryDescriptorAction { get; set; }
	private Elastic.Clients.Elasticsearch.Duration? QueryDelayValue { get; set; }
	private IDictionary<Elastic.Clients.Elasticsearch.Field, Elastic.Clients.Elasticsearch.Mapping.RuntimeFieldDescriptor> RuntimeMappingsValue { get; set; }
	private IDictionary<string, Elastic.Clients.Elasticsearch.ScriptFieldDescriptor> ScriptFieldsValue { get; set; }
	private int? ScrollSizeValue { get; set; }

	/// <summary>
	/// <para>
	/// If set, the datafeed performs aggregation searches.
	/// Support for aggregations is limited and should be used only with low cardinality data.
	/// </para>
	/// </summary>
	public PutDatafeedRequestDescriptor Aggregations(Func<FluentDescriptorDictionary<string, Elastic.Clients.Elasticsearch.Aggregations.AggregationDescriptor>, FluentDescriptorDictionary<string, Elastic.Clients.Elasticsearch.Aggregations.AggregationDescriptor>> selector)
	{
		AggregationsValue = selector?.Invoke(new FluentDescriptorDictionary<string, Elastic.Clients.Elasticsearch.Aggregations.AggregationDescriptor>());
		return Self;
	}

	/// <summary>
	/// <para>
	/// Datafeeds might be required to search over long time periods, for several months or years.
	/// This search is split into time chunks in order to ensure the load on Elasticsearch is managed.
	/// Chunking configuration controls how the size of these time chunks are calculated;
	/// it is an advanced configuration option.
	/// </para>
	/// </summary>
	public PutDatafeedRequestDescriptor ChunkingConfig(Elastic.Clients.Elasticsearch.MachineLearning.ChunkingConfig? chunkingConfig)
	{
		ChunkingConfigDescriptor = null;
		ChunkingConfigDescriptorAction = null;
		ChunkingConfigValue = chunkingConfig;
		return Self;
	}

	public PutDatafeedRequestDescriptor ChunkingConfig(Elastic.Clients.Elasticsearch.MachineLearning.ChunkingConfigDescriptor descriptor)
	{
		ChunkingConfigValue = null;
		ChunkingConfigDescriptorAction = null;
		ChunkingConfigDescriptor = descriptor;
		return Self;
	}

	public PutDatafeedRequestDescriptor ChunkingConfig(Action<Elastic.Clients.Elasticsearch.MachineLearning.ChunkingConfigDescriptor> configure)
	{
		ChunkingConfigValue = null;
		ChunkingConfigDescriptor = null;
		ChunkingConfigDescriptorAction = configure;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Specifies whether the datafeed checks for missing data and the size of the window.
	/// The datafeed can optionally search over indices that have already been read in an effort to determine whether
	/// any data has subsequently been added to the index. If missing data is found, it is a good indication that the
	/// <c>query_delay</c> is set too low and the data is being indexed after the datafeed has passed that moment in time.
	/// This check runs only on real-time datafeeds.
	/// </para>
	/// </summary>
	public PutDatafeedRequestDescriptor DelayedDataCheckConfig(Elastic.Clients.Elasticsearch.MachineLearning.DelayedDataCheckConfig? delayedDataCheckConfig)
	{
		DelayedDataCheckConfigDescriptor = null;
		DelayedDataCheckConfigDescriptorAction = null;
		DelayedDataCheckConfigValue = delayedDataCheckConfig;
		return Self;
	}

	public PutDatafeedRequestDescriptor DelayedDataCheckConfig(Elastic.Clients.Elasticsearch.MachineLearning.DelayedDataCheckConfigDescriptor descriptor)
	{
		DelayedDataCheckConfigValue = null;
		DelayedDataCheckConfigDescriptorAction = null;
		DelayedDataCheckConfigDescriptor = descriptor;
		return Self;
	}

	public PutDatafeedRequestDescriptor DelayedDataCheckConfig(Action<Elastic.Clients.Elasticsearch.MachineLearning.DelayedDataCheckConfigDescriptor> configure)
	{
		DelayedDataCheckConfigValue = null;
		DelayedDataCheckConfigDescriptor = null;
		DelayedDataCheckConfigDescriptorAction = configure;
		return Self;
	}

	/// <summary>
	/// <para>
	/// The interval at which scheduled queries are made while the datafeed runs in real time.
	/// The default value is either the bucket span for short bucket spans, or, for longer bucket spans, a sensible
	/// fraction of the bucket span. When <c>frequency</c> is shorter than the bucket span, interim results for the last
	/// (partial) bucket are written then eventually overwritten by the full bucket results. If the datafeed uses
	/// aggregations, this value must be divisible by the interval of the date histogram aggregation.
	/// </para>
	/// </summary>
	public PutDatafeedRequestDescriptor Frequency(Elastic.Clients.Elasticsearch.Duration? frequency)
	{
		FrequencyValue = frequency;
		return Self;
	}

	public PutDatafeedRequestDescriptor Headers(Func<FluentDictionary<string, Union<string, ICollection<string>>>, FluentDictionary<string, Union<string, ICollection<string>>>> selector)
	{
		HeadersValue = selector?.Invoke(new FluentDictionary<string, Union<string, ICollection<string>>>());
		return Self;
	}

	/// <summary>
	/// <para>
	/// An array of index names. Wildcards are supported. If any of the indices are in remote clusters, the machine
	/// learning nodes must have the <c>remote_cluster_client</c> role.
	/// </para>
	/// </summary>
	public PutDatafeedRequestDescriptor Indices(Elastic.Clients.Elasticsearch.Indices? indices)
	{
		IndicesValue = indices;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Specifies index expansion options that are used during search
	/// </para>
	/// </summary>
	public PutDatafeedRequestDescriptor IndicesOptions(Elastic.Clients.Elasticsearch.IndicesOptions? indicesOptions)
	{
		IndicesOptionsDescriptor = null;
		IndicesOptionsDescriptorAction = null;
		IndicesOptionsValue = indicesOptions;
		return Self;
	}

	public PutDatafeedRequestDescriptor IndicesOptions(Elastic.Clients.Elasticsearch.IndicesOptionsDescriptor descriptor)
	{
		IndicesOptionsValue = null;
		IndicesOptionsDescriptorAction = null;
		IndicesOptionsDescriptor = descriptor;
		return Self;
	}

	public PutDatafeedRequestDescriptor IndicesOptions(Action<Elastic.Clients.Elasticsearch.IndicesOptionsDescriptor> configure)
	{
		IndicesOptionsValue = null;
		IndicesOptionsDescriptor = null;
		IndicesOptionsDescriptorAction = configure;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Identifier for the anomaly detection job.
	/// </para>
	/// </summary>
	public PutDatafeedRequestDescriptor JobId(Elastic.Clients.Elasticsearch.Id? jobId)
	{
		JobIdValue = jobId;
		return Self;
	}

	/// <summary>
	/// <para>
	/// If a real-time datafeed has never seen any data (including during any initial training period), it automatically
	/// stops and closes the associated job after this many real-time searches return no documents. In other words,
	/// it stops after <c>frequency</c> times <c>max_empty_searches</c> of real-time operation. If not set, a datafeed with no
	/// end time that sees no data remains started until it is explicitly stopped. By default, it is not set.
	/// </para>
	/// </summary>
	public PutDatafeedRequestDescriptor MaxEmptySearches(int? maxEmptySearches)
	{
		MaxEmptySearchesValue = maxEmptySearches;
		return Self;
	}

	/// <summary>
	/// <para>
	/// The Elasticsearch query domain-specific language (DSL). This value corresponds to the query object in an
	/// Elasticsearch search POST body. All the options that are supported by Elasticsearch can be used, as this
	/// object is passed verbatim to Elasticsearch.
	/// </para>
	/// </summary>
	public PutDatafeedRequestDescriptor Query(Elastic.Clients.Elasticsearch.QueryDsl.Query? query)
	{
		QueryDescriptor = null;
		QueryDescriptorAction = null;
		QueryValue = query;
		return Self;
	}

	public PutDatafeedRequestDescriptor Query(Elastic.Clients.Elasticsearch.QueryDsl.QueryDescriptor descriptor)
	{
		QueryValue = null;
		QueryDescriptorAction = null;
		QueryDescriptor = descriptor;
		return Self;
	}

	public PutDatafeedRequestDescriptor Query(Action<Elastic.Clients.Elasticsearch.QueryDsl.QueryDescriptor> configure)
	{
		QueryValue = null;
		QueryDescriptor = null;
		QueryDescriptorAction = configure;
		return Self;
	}

	/// <summary>
	/// <para>
	/// The number of seconds behind real time that data is queried. For example, if data from 10:04 a.m. might
	/// not be searchable in Elasticsearch until 10:06 a.m., set this property to 120 seconds. The default
	/// value is randomly selected between <c>60s</c> and <c>120s</c>. This randomness improves the query performance
	/// when there are multiple jobs running on the same node.
	/// </para>
	/// </summary>
	public PutDatafeedRequestDescriptor QueryDelay(Elastic.Clients.Elasticsearch.Duration? queryDelay)
	{
		QueryDelayValue = queryDelay;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Specifies runtime fields for the datafeed search.
	/// </para>
	/// </summary>
	public PutDatafeedRequestDescriptor RuntimeMappings(Func<FluentDescriptorDictionary<Elastic.Clients.Elasticsearch.Field, Elastic.Clients.Elasticsearch.Mapping.RuntimeFieldDescriptor>, FluentDescriptorDictionary<Elastic.Clients.Elasticsearch.Field, Elastic.Clients.Elasticsearch.Mapping.RuntimeFieldDescriptor>> selector)
	{
		RuntimeMappingsValue = selector?.Invoke(new FluentDescriptorDictionary<Elastic.Clients.Elasticsearch.Field, Elastic.Clients.Elasticsearch.Mapping.RuntimeFieldDescriptor>());
		return Self;
	}

	/// <summary>
	/// <para>
	/// Specifies scripts that evaluate custom expressions and returns script fields to the datafeed.
	/// The detector configuration objects in a job can contain functions that use these script fields.
	/// </para>
	/// </summary>
	public PutDatafeedRequestDescriptor ScriptFields(Func<FluentDescriptorDictionary<string, Elastic.Clients.Elasticsearch.ScriptFieldDescriptor>, FluentDescriptorDictionary<string, Elastic.Clients.Elasticsearch.ScriptFieldDescriptor>> selector)
	{
		ScriptFieldsValue = selector?.Invoke(new FluentDescriptorDictionary<string, Elastic.Clients.Elasticsearch.ScriptFieldDescriptor>());
		return Self;
	}

	/// <summary>
	/// <para>
	/// The size parameter that is used in Elasticsearch searches when the datafeed does not use aggregations.
	/// The maximum value is the value of <c>index.max_result_window</c>, which is 10,000 by default.
	/// </para>
	/// </summary>
	public PutDatafeedRequestDescriptor ScrollSize(int? scrollSize)
	{
		ScrollSizeValue = scrollSize;
		return Self;
	}

	protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
	{
		writer.WriteStartObject();
		if (AggregationsValue is not null)
		{
			writer.WritePropertyName("aggregations");
			JsonSerializer.Serialize(writer, AggregationsValue, options);
		}

		if (ChunkingConfigDescriptor is not null)
		{
			writer.WritePropertyName("chunking_config");
			JsonSerializer.Serialize(writer, ChunkingConfigDescriptor, options);
		}
		else if (ChunkingConfigDescriptorAction is not null)
		{
			writer.WritePropertyName("chunking_config");
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.MachineLearning.ChunkingConfigDescriptor(ChunkingConfigDescriptorAction), options);
		}
		else if (ChunkingConfigValue is not null)
		{
			writer.WritePropertyName("chunking_config");
			JsonSerializer.Serialize(writer, ChunkingConfigValue, options);
		}

		if (DelayedDataCheckConfigDescriptor is not null)
		{
			writer.WritePropertyName("delayed_data_check_config");
			JsonSerializer.Serialize(writer, DelayedDataCheckConfigDescriptor, options);
		}
		else if (DelayedDataCheckConfigDescriptorAction is not null)
		{
			writer.WritePropertyName("delayed_data_check_config");
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.MachineLearning.DelayedDataCheckConfigDescriptor(DelayedDataCheckConfigDescriptorAction), options);
		}
		else if (DelayedDataCheckConfigValue is not null)
		{
			writer.WritePropertyName("delayed_data_check_config");
			JsonSerializer.Serialize(writer, DelayedDataCheckConfigValue, options);
		}

		if (FrequencyValue is not null)
		{
			writer.WritePropertyName("frequency");
			JsonSerializer.Serialize(writer, FrequencyValue, options);
		}

		if (HeadersValue is not null)
		{
			writer.WritePropertyName("headers");
			JsonSerializer.Serialize(writer, HeadersValue, options);
		}

		if (IndicesValue is not null)
		{
			writer.WritePropertyName("indices");
			JsonSerializer.Serialize(writer, IndicesValue, options);
		}

		if (IndicesOptionsDescriptor is not null)
		{
			writer.WritePropertyName("indices_options");
			JsonSerializer.Serialize(writer, IndicesOptionsDescriptor, options);
		}
		else if (IndicesOptionsDescriptorAction is not null)
		{
			writer.WritePropertyName("indices_options");
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.IndicesOptionsDescriptor(IndicesOptionsDescriptorAction), options);
		}
		else if (IndicesOptionsValue is not null)
		{
			writer.WritePropertyName("indices_options");
			JsonSerializer.Serialize(writer, IndicesOptionsValue, options);
		}

		if (JobIdValue is not null)
		{
			writer.WritePropertyName("job_id");
			JsonSerializer.Serialize(writer, JobIdValue, options);
		}

		if (MaxEmptySearchesValue.HasValue)
		{
			writer.WritePropertyName("max_empty_searches");
			writer.WriteNumberValue(MaxEmptySearchesValue.Value);
		}

		if (QueryDescriptor is not null)
		{
			writer.WritePropertyName("query");
			JsonSerializer.Serialize(writer, QueryDescriptor, options);
		}
		else if (QueryDescriptorAction is not null)
		{
			writer.WritePropertyName("query");
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.QueryDsl.QueryDescriptor(QueryDescriptorAction), options);
		}
		else if (QueryValue is not null)
		{
			writer.WritePropertyName("query");
			JsonSerializer.Serialize(writer, QueryValue, options);
		}

		if (QueryDelayValue is not null)
		{
			writer.WritePropertyName("query_delay");
			JsonSerializer.Serialize(writer, QueryDelayValue, options);
		}

		if (RuntimeMappingsValue is not null)
		{
			writer.WritePropertyName("runtime_mappings");
			JsonSerializer.Serialize(writer, RuntimeMappingsValue, options);
		}

		if (ScriptFieldsValue is not null)
		{
			writer.WritePropertyName("script_fields");
			JsonSerializer.Serialize(writer, ScriptFieldsValue, options);
		}

		if (ScrollSizeValue.HasValue)
		{
			writer.WritePropertyName("scroll_size");
			writer.WriteNumberValue(ScrollSizeValue.Value);
		}

		writer.WriteEndObject();
	}
}