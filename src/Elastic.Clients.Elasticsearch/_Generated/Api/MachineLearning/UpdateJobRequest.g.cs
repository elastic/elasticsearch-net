// Licensed to Elasticsearch B.V under one or more agreements.
// Elasticsearch B.V licenses this file to you under the Apache 2.0 License.
// See the LICENSE file in the project root for more information.
//
// ███╗   ██╗ ██████╗ ████████╗██╗ ██████╗███████╗
// ████╗  ██║██╔═══██╗╚══██╔══╝██║██╔════╝██╔════╝
// ██╔██╗ ██║██║   ██║   ██║   ██║██║     █████╗
// ██║╚██╗██║██║   ██║   ██║   ██║██║     ██╔══╝
// ██║ ╚████║╚██████╔╝   ██║   ██║╚██████╗███████╗
// ╚═╝  ╚═══╝ ╚═════╝    ╚═╝   ╚═╝ ╚═════╝╚══════╝
// ------------------------------------------------
//
// This file is automatically generated.
// Please do not edit these files manually.
//
// ------------------------------------------------

#nullable restore

using Elastic.Clients.Elasticsearch.Fluent;
using Elastic.Clients.Elasticsearch.Requests;
using Elastic.Clients.Elasticsearch.Serialization;
using Elastic.Transport;
using Elastic.Transport.Extensions;
using System;
using System.Collections.Generic;
using System.Linq.Expressions;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace Elastic.Clients.Elasticsearch.MachineLearning;

public sealed partial class UpdateJobRequestParameters : RequestParameters
{
}

/// <summary>
/// <para>
/// Update an anomaly detection job.
/// Updates certain properties of an anomaly detection job.
/// </para>
/// </summary>
public sealed partial class UpdateJobRequest : PlainRequest<UpdateJobRequestParameters>
{
	public UpdateJobRequest(Elastic.Clients.Elasticsearch.Id jobId) : base(r => r.Required("job_id", jobId))
	{
	}

	[JsonConstructor]
	internal UpdateJobRequest()
	{
	}

	internal override ApiUrls ApiUrls => ApiUrlLookup.MachineLearningUpdateJob;

	protected override HttpMethod StaticHttpMethod => HttpMethod.POST;

	internal override bool SupportsBody => true;

	internal override string OperationName => "ml.update_job";

	/// <summary>
	/// <para>
	/// Identifier for the job.
	/// </para>
	/// </summary>
	[JsonIgnore]
	public Elastic.Clients.Elasticsearch.Id JobId { get => P<Elastic.Clients.Elasticsearch.Id>("job_id"); set => PR("job_id", value); }

	/// <summary>
	/// <para>
	/// Advanced configuration option. Specifies whether this job can open when
	/// there is insufficient machine learning node capacity for it to be
	/// immediately assigned to a node. If <c>false</c> and a machine learning node
	/// with capacity to run the job cannot immediately be found, the open
	/// anomaly detection jobs API returns an error. However, this is also
	/// subject to the cluster-wide <c>xpack.ml.max_lazy_ml_nodes</c> setting. If this
	/// option is set to <c>true</c>, the open anomaly detection jobs API does not
	/// return an error and the job waits in the opening state until sufficient
	/// machine learning node capacity is available.
	/// </para>
	/// </summary>
	[JsonInclude, JsonPropertyName("allow_lazy_open")]
	public bool? AllowLazyOpen { get; set; }
	[JsonInclude, JsonPropertyName("analysis_limits")]
	public Elastic.Clients.Elasticsearch.MachineLearning.AnalysisMemoryLimit? AnalysisLimits { get; set; }

	/// <summary>
	/// <para>
	/// Advanced configuration option. The time between each periodic persistence
	/// of the model.
	/// The default value is a randomized value between 3 to 4 hours, which
	/// avoids all jobs persisting at exactly the same time. The smallest allowed
	/// value is 1 hour.
	/// For very large models (several GB), persistence could take 10-20 minutes,
	/// so do not set the value too low.
	/// If the job is open when you make the update, you must stop the datafeed,
	/// close the job, then reopen the job and restart the datafeed for the
	/// changes to take effect.
	/// </para>
	/// </summary>
	[JsonInclude, JsonPropertyName("background_persist_interval")]
	public Elastic.Clients.Elasticsearch.Duration? BackgroundPersistInterval { get; set; }
	[JsonInclude, JsonPropertyName("categorization_filters")]
	public ICollection<string>? CategorizationFilters { get; set; }

	/// <summary>
	/// <para>
	/// Advanced configuration option. Contains custom meta data about the job.
	/// For example, it can contain custom URL information as shown in Adding
	/// custom URLs to machine learning results.
	/// </para>
	/// </summary>
	[JsonInclude, JsonPropertyName("custom_settings")]
	public IDictionary<string, object>? CustomSettings { get; set; }

	/// <summary>
	/// <para>
	/// Advanced configuration option, which affects the automatic removal of old
	/// model snapshots for this job. It specifies a period of time (in days)
	/// after which only the first snapshot per day is retained. This period is
	/// relative to the timestamp of the most recent snapshot for this job. Valid
	/// values range from 0 to <c>model_snapshot_retention_days</c>. For jobs created
	/// before version 7.8.0, the default value matches
	/// <c>model_snapshot_retention_days</c>.
	/// </para>
	/// </summary>
	[JsonInclude, JsonPropertyName("daily_model_snapshot_retention_after_days")]
	public long? DailyModelSnapshotRetentionAfterDays { get; set; }

	/// <summary>
	/// <para>
	/// A description of the job.
	/// </para>
	/// </summary>
	[JsonInclude, JsonPropertyName("description")]
	public string? Description { get; set; }

	/// <summary>
	/// <para>
	/// An array of detector update objects.
	/// </para>
	/// </summary>
	[JsonInclude, JsonPropertyName("detectors")]
	public ICollection<Elastic.Clients.Elasticsearch.MachineLearning.DetectorUpdate>? Detectors { get; set; }

	/// <summary>
	/// <para>
	/// A list of job groups. A job can belong to no groups or many.
	/// </para>
	/// </summary>
	[JsonInclude, JsonPropertyName("groups")]
	public ICollection<string>? Groups { get; set; }
	[JsonInclude, JsonPropertyName("model_plot_config")]
	public Elastic.Clients.Elasticsearch.MachineLearning.ModelPlotConfig? ModelPlotConfig { get; set; }
	[JsonInclude, JsonPropertyName("model_prune_window")]
	public Elastic.Clients.Elasticsearch.Duration? ModelPruneWindow { get; set; }

	/// <summary>
	/// <para>
	/// Advanced configuration option, which affects the automatic removal of old
	/// model snapshots for this job. It specifies the maximum period of time (in
	/// days) that snapshots are retained. This period is relative to the
	/// timestamp of the most recent snapshot for this job.
	/// </para>
	/// </summary>
	[JsonInclude, JsonPropertyName("model_snapshot_retention_days")]
	public long? ModelSnapshotRetentionDays { get; set; }

	/// <summary>
	/// <para>
	/// Settings related to how categorization interacts with partition fields.
	/// </para>
	/// </summary>
	[JsonInclude, JsonPropertyName("per_partition_categorization")]
	public Elastic.Clients.Elasticsearch.MachineLearning.PerPartitionCategorization? PerPartitionCategorization { get; set; }

	/// <summary>
	/// <para>
	/// Advanced configuration option. The period over which adjustments to the
	/// score are applied, as new data is seen.
	/// </para>
	/// </summary>
	[JsonInclude, JsonPropertyName("renormalization_window_days")]
	public long? RenormalizationWindowDays { get; set; }

	/// <summary>
	/// <para>
	/// Advanced configuration option. The period of time (in days) that results
	/// are retained. Age is calculated relative to the timestamp of the latest
	/// bucket result. If this property has a non-null value, once per day at
	/// 00:30 (server time), results that are the specified number of days older
	/// than the latest bucket result are deleted from Elasticsearch. The default
	/// value is null, which means all results are retained.
	/// </para>
	/// </summary>
	[JsonInclude, JsonPropertyName("results_retention_days")]
	public long? ResultsRetentionDays { get; set; }
}

/// <summary>
/// <para>
/// Update an anomaly detection job.
/// Updates certain properties of an anomaly detection job.
/// </para>
/// </summary>
public sealed partial class UpdateJobRequestDescriptor<TDocument> : RequestDescriptor<UpdateJobRequestDescriptor<TDocument>, UpdateJobRequestParameters>
{
	internal UpdateJobRequestDescriptor(Action<UpdateJobRequestDescriptor<TDocument>> configure) => configure.Invoke(this);

	public UpdateJobRequestDescriptor(Elastic.Clients.Elasticsearch.Id jobId) : base(r => r.Required("job_id", jobId))
	{
	}

	internal override ApiUrls ApiUrls => ApiUrlLookup.MachineLearningUpdateJob;

	protected override HttpMethod StaticHttpMethod => HttpMethod.POST;

	internal override bool SupportsBody => true;

	internal override string OperationName => "ml.update_job";

	public UpdateJobRequestDescriptor<TDocument> JobId(Elastic.Clients.Elasticsearch.Id jobId)
	{
		RouteValues.Required("job_id", jobId);
		return Self;
	}

	private bool? AllowLazyOpenValue { get; set; }
	private Elastic.Clients.Elasticsearch.MachineLearning.AnalysisMemoryLimit? AnalysisLimitsValue { get; set; }
	private Elastic.Clients.Elasticsearch.MachineLearning.AnalysisMemoryLimitDescriptor AnalysisLimitsDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.MachineLearning.AnalysisMemoryLimitDescriptor> AnalysisLimitsDescriptorAction { get; set; }
	private Elastic.Clients.Elasticsearch.Duration? BackgroundPersistIntervalValue { get; set; }
	private ICollection<string>? CategorizationFiltersValue { get; set; }
	private IDictionary<string, object>? CustomSettingsValue { get; set; }
	private long? DailyModelSnapshotRetentionAfterDaysValue { get; set; }
	private string? DescriptionValue { get; set; }
	private ICollection<Elastic.Clients.Elasticsearch.MachineLearning.DetectorUpdate>? DetectorsValue { get; set; }
	private Elastic.Clients.Elasticsearch.MachineLearning.DetectorUpdateDescriptor<TDocument> DetectorsDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.MachineLearning.DetectorUpdateDescriptor<TDocument>> DetectorsDescriptorAction { get; set; }
	private Action<Elastic.Clients.Elasticsearch.MachineLearning.DetectorUpdateDescriptor<TDocument>>[] DetectorsDescriptorActions { get; set; }
	private ICollection<string>? GroupsValue { get; set; }
	private Elastic.Clients.Elasticsearch.MachineLearning.ModelPlotConfig? ModelPlotConfigValue { get; set; }
	private Elastic.Clients.Elasticsearch.MachineLearning.ModelPlotConfigDescriptor<TDocument> ModelPlotConfigDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.MachineLearning.ModelPlotConfigDescriptor<TDocument>> ModelPlotConfigDescriptorAction { get; set; }
	private Elastic.Clients.Elasticsearch.Duration? ModelPruneWindowValue { get; set; }
	private long? ModelSnapshotRetentionDaysValue { get; set; }
	private Elastic.Clients.Elasticsearch.MachineLearning.PerPartitionCategorization? PerPartitionCategorizationValue { get; set; }
	private Elastic.Clients.Elasticsearch.MachineLearning.PerPartitionCategorizationDescriptor PerPartitionCategorizationDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.MachineLearning.PerPartitionCategorizationDescriptor> PerPartitionCategorizationDescriptorAction { get; set; }
	private long? RenormalizationWindowDaysValue { get; set; }
	private long? ResultsRetentionDaysValue { get; set; }

	/// <summary>
	/// <para>
	/// Advanced configuration option. Specifies whether this job can open when
	/// there is insufficient machine learning node capacity for it to be
	/// immediately assigned to a node. If <c>false</c> and a machine learning node
	/// with capacity to run the job cannot immediately be found, the open
	/// anomaly detection jobs API returns an error. However, this is also
	/// subject to the cluster-wide <c>xpack.ml.max_lazy_ml_nodes</c> setting. If this
	/// option is set to <c>true</c>, the open anomaly detection jobs API does not
	/// return an error and the job waits in the opening state until sufficient
	/// machine learning node capacity is available.
	/// </para>
	/// </summary>
	public UpdateJobRequestDescriptor<TDocument> AllowLazyOpen(bool? allowLazyOpen = true)
	{
		AllowLazyOpenValue = allowLazyOpen;
		return Self;
	}

	public UpdateJobRequestDescriptor<TDocument> AnalysisLimits(Elastic.Clients.Elasticsearch.MachineLearning.AnalysisMemoryLimit? analysisLimits)
	{
		AnalysisLimitsDescriptor = null;
		AnalysisLimitsDescriptorAction = null;
		AnalysisLimitsValue = analysisLimits;
		return Self;
	}

	public UpdateJobRequestDescriptor<TDocument> AnalysisLimits(Elastic.Clients.Elasticsearch.MachineLearning.AnalysisMemoryLimitDescriptor descriptor)
	{
		AnalysisLimitsValue = null;
		AnalysisLimitsDescriptorAction = null;
		AnalysisLimitsDescriptor = descriptor;
		return Self;
	}

	public UpdateJobRequestDescriptor<TDocument> AnalysisLimits(Action<Elastic.Clients.Elasticsearch.MachineLearning.AnalysisMemoryLimitDescriptor> configure)
	{
		AnalysisLimitsValue = null;
		AnalysisLimitsDescriptor = null;
		AnalysisLimitsDescriptorAction = configure;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Advanced configuration option. The time between each periodic persistence
	/// of the model.
	/// The default value is a randomized value between 3 to 4 hours, which
	/// avoids all jobs persisting at exactly the same time. The smallest allowed
	/// value is 1 hour.
	/// For very large models (several GB), persistence could take 10-20 minutes,
	/// so do not set the value too low.
	/// If the job is open when you make the update, you must stop the datafeed,
	/// close the job, then reopen the job and restart the datafeed for the
	/// changes to take effect.
	/// </para>
	/// </summary>
	public UpdateJobRequestDescriptor<TDocument> BackgroundPersistInterval(Elastic.Clients.Elasticsearch.Duration? backgroundPersistInterval)
	{
		BackgroundPersistIntervalValue = backgroundPersistInterval;
		return Self;
	}

	public UpdateJobRequestDescriptor<TDocument> CategorizationFilters(ICollection<string>? categorizationFilters)
	{
		CategorizationFiltersValue = categorizationFilters;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Advanced configuration option. Contains custom meta data about the job.
	/// For example, it can contain custom URL information as shown in Adding
	/// custom URLs to machine learning results.
	/// </para>
	/// </summary>
	public UpdateJobRequestDescriptor<TDocument> CustomSettings(Func<FluentDictionary<string, object>, FluentDictionary<string, object>> selector)
	{
		CustomSettingsValue = selector?.Invoke(new FluentDictionary<string, object>());
		return Self;
	}

	/// <summary>
	/// <para>
	/// Advanced configuration option, which affects the automatic removal of old
	/// model snapshots for this job. It specifies a period of time (in days)
	/// after which only the first snapshot per day is retained. This period is
	/// relative to the timestamp of the most recent snapshot for this job. Valid
	/// values range from 0 to <c>model_snapshot_retention_days</c>. For jobs created
	/// before version 7.8.0, the default value matches
	/// <c>model_snapshot_retention_days</c>.
	/// </para>
	/// </summary>
	public UpdateJobRequestDescriptor<TDocument> DailyModelSnapshotRetentionAfterDays(long? dailyModelSnapshotRetentionAfterDays)
	{
		DailyModelSnapshotRetentionAfterDaysValue = dailyModelSnapshotRetentionAfterDays;
		return Self;
	}

	/// <summary>
	/// <para>
	/// A description of the job.
	/// </para>
	/// </summary>
	public UpdateJobRequestDescriptor<TDocument> Description(string? description)
	{
		DescriptionValue = description;
		return Self;
	}

	/// <summary>
	/// <para>
	/// An array of detector update objects.
	/// </para>
	/// </summary>
	public UpdateJobRequestDescriptor<TDocument> Detectors(ICollection<Elastic.Clients.Elasticsearch.MachineLearning.DetectorUpdate>? detectors)
	{
		DetectorsDescriptor = null;
		DetectorsDescriptorAction = null;
		DetectorsDescriptorActions = null;
		DetectorsValue = detectors;
		return Self;
	}

	public UpdateJobRequestDescriptor<TDocument> Detectors(Elastic.Clients.Elasticsearch.MachineLearning.DetectorUpdateDescriptor<TDocument> descriptor)
	{
		DetectorsValue = null;
		DetectorsDescriptorAction = null;
		DetectorsDescriptorActions = null;
		DetectorsDescriptor = descriptor;
		return Self;
	}

	public UpdateJobRequestDescriptor<TDocument> Detectors(Action<Elastic.Clients.Elasticsearch.MachineLearning.DetectorUpdateDescriptor<TDocument>> configure)
	{
		DetectorsValue = null;
		DetectorsDescriptor = null;
		DetectorsDescriptorActions = null;
		DetectorsDescriptorAction = configure;
		return Self;
	}

	public UpdateJobRequestDescriptor<TDocument> Detectors(params Action<Elastic.Clients.Elasticsearch.MachineLearning.DetectorUpdateDescriptor<TDocument>>[] configure)
	{
		DetectorsValue = null;
		DetectorsDescriptor = null;
		DetectorsDescriptorAction = null;
		DetectorsDescriptorActions = configure;
		return Self;
	}

	/// <summary>
	/// <para>
	/// A list of job groups. A job can belong to no groups or many.
	/// </para>
	/// </summary>
	public UpdateJobRequestDescriptor<TDocument> Groups(ICollection<string>? groups)
	{
		GroupsValue = groups;
		return Self;
	}

	public UpdateJobRequestDescriptor<TDocument> ModelPlotConfig(Elastic.Clients.Elasticsearch.MachineLearning.ModelPlotConfig? modelPlotConfig)
	{
		ModelPlotConfigDescriptor = null;
		ModelPlotConfigDescriptorAction = null;
		ModelPlotConfigValue = modelPlotConfig;
		return Self;
	}

	public UpdateJobRequestDescriptor<TDocument> ModelPlotConfig(Elastic.Clients.Elasticsearch.MachineLearning.ModelPlotConfigDescriptor<TDocument> descriptor)
	{
		ModelPlotConfigValue = null;
		ModelPlotConfigDescriptorAction = null;
		ModelPlotConfigDescriptor = descriptor;
		return Self;
	}

	public UpdateJobRequestDescriptor<TDocument> ModelPlotConfig(Action<Elastic.Clients.Elasticsearch.MachineLearning.ModelPlotConfigDescriptor<TDocument>> configure)
	{
		ModelPlotConfigValue = null;
		ModelPlotConfigDescriptor = null;
		ModelPlotConfigDescriptorAction = configure;
		return Self;
	}

	public UpdateJobRequestDescriptor<TDocument> ModelPruneWindow(Elastic.Clients.Elasticsearch.Duration? modelPruneWindow)
	{
		ModelPruneWindowValue = modelPruneWindow;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Advanced configuration option, which affects the automatic removal of old
	/// model snapshots for this job. It specifies the maximum period of time (in
	/// days) that snapshots are retained. This period is relative to the
	/// timestamp of the most recent snapshot for this job.
	/// </para>
	/// </summary>
	public UpdateJobRequestDescriptor<TDocument> ModelSnapshotRetentionDays(long? modelSnapshotRetentionDays)
	{
		ModelSnapshotRetentionDaysValue = modelSnapshotRetentionDays;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Settings related to how categorization interacts with partition fields.
	/// </para>
	/// </summary>
	public UpdateJobRequestDescriptor<TDocument> PerPartitionCategorization(Elastic.Clients.Elasticsearch.MachineLearning.PerPartitionCategorization? perPartitionCategorization)
	{
		PerPartitionCategorizationDescriptor = null;
		PerPartitionCategorizationDescriptorAction = null;
		PerPartitionCategorizationValue = perPartitionCategorization;
		return Self;
	}

	public UpdateJobRequestDescriptor<TDocument> PerPartitionCategorization(Elastic.Clients.Elasticsearch.MachineLearning.PerPartitionCategorizationDescriptor descriptor)
	{
		PerPartitionCategorizationValue = null;
		PerPartitionCategorizationDescriptorAction = null;
		PerPartitionCategorizationDescriptor = descriptor;
		return Self;
	}

	public UpdateJobRequestDescriptor<TDocument> PerPartitionCategorization(Action<Elastic.Clients.Elasticsearch.MachineLearning.PerPartitionCategorizationDescriptor> configure)
	{
		PerPartitionCategorizationValue = null;
		PerPartitionCategorizationDescriptor = null;
		PerPartitionCategorizationDescriptorAction = configure;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Advanced configuration option. The period over which adjustments to the
	/// score are applied, as new data is seen.
	/// </para>
	/// </summary>
	public UpdateJobRequestDescriptor<TDocument> RenormalizationWindowDays(long? renormalizationWindowDays)
	{
		RenormalizationWindowDaysValue = renormalizationWindowDays;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Advanced configuration option. The period of time (in days) that results
	/// are retained. Age is calculated relative to the timestamp of the latest
	/// bucket result. If this property has a non-null value, once per day at
	/// 00:30 (server time), results that are the specified number of days older
	/// than the latest bucket result are deleted from Elasticsearch. The default
	/// value is null, which means all results are retained.
	/// </para>
	/// </summary>
	public UpdateJobRequestDescriptor<TDocument> ResultsRetentionDays(long? resultsRetentionDays)
	{
		ResultsRetentionDaysValue = resultsRetentionDays;
		return Self;
	}

	protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
	{
		writer.WriteStartObject();
		if (AllowLazyOpenValue.HasValue)
		{
			writer.WritePropertyName("allow_lazy_open");
			writer.WriteBooleanValue(AllowLazyOpenValue.Value);
		}

		if (AnalysisLimitsDescriptor is not null)
		{
			writer.WritePropertyName("analysis_limits");
			JsonSerializer.Serialize(writer, AnalysisLimitsDescriptor, options);
		}
		else if (AnalysisLimitsDescriptorAction is not null)
		{
			writer.WritePropertyName("analysis_limits");
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.MachineLearning.AnalysisMemoryLimitDescriptor(AnalysisLimitsDescriptorAction), options);
		}
		else if (AnalysisLimitsValue is not null)
		{
			writer.WritePropertyName("analysis_limits");
			JsonSerializer.Serialize(writer, AnalysisLimitsValue, options);
		}

		if (BackgroundPersistIntervalValue is not null)
		{
			writer.WritePropertyName("background_persist_interval");
			JsonSerializer.Serialize(writer, BackgroundPersistIntervalValue, options);
		}

		if (CategorizationFiltersValue is not null)
		{
			writer.WritePropertyName("categorization_filters");
			JsonSerializer.Serialize(writer, CategorizationFiltersValue, options);
		}

		if (CustomSettingsValue is not null)
		{
			writer.WritePropertyName("custom_settings");
			JsonSerializer.Serialize(writer, CustomSettingsValue, options);
		}

		if (DailyModelSnapshotRetentionAfterDaysValue.HasValue)
		{
			writer.WritePropertyName("daily_model_snapshot_retention_after_days");
			writer.WriteNumberValue(DailyModelSnapshotRetentionAfterDaysValue.Value);
		}

		if (!string.IsNullOrEmpty(DescriptionValue))
		{
			writer.WritePropertyName("description");
			writer.WriteStringValue(DescriptionValue);
		}

		if (DetectorsDescriptor is not null)
		{
			writer.WritePropertyName("detectors");
			writer.WriteStartArray();
			JsonSerializer.Serialize(writer, DetectorsDescriptor, options);
			writer.WriteEndArray();
		}
		else if (DetectorsDescriptorAction is not null)
		{
			writer.WritePropertyName("detectors");
			writer.WriteStartArray();
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.MachineLearning.DetectorUpdateDescriptor<TDocument>(DetectorsDescriptorAction), options);
			writer.WriteEndArray();
		}
		else if (DetectorsDescriptorActions is not null)
		{
			writer.WritePropertyName("detectors");
			writer.WriteStartArray();
			foreach (var action in DetectorsDescriptorActions)
			{
				JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.MachineLearning.DetectorUpdateDescriptor<TDocument>(action), options);
			}

			writer.WriteEndArray();
		}
		else if (DetectorsValue is not null)
		{
			writer.WritePropertyName("detectors");
			JsonSerializer.Serialize(writer, DetectorsValue, options);
		}

		if (GroupsValue is not null)
		{
			writer.WritePropertyName("groups");
			JsonSerializer.Serialize(writer, GroupsValue, options);
		}

		if (ModelPlotConfigDescriptor is not null)
		{
			writer.WritePropertyName("model_plot_config");
			JsonSerializer.Serialize(writer, ModelPlotConfigDescriptor, options);
		}
		else if (ModelPlotConfigDescriptorAction is not null)
		{
			writer.WritePropertyName("model_plot_config");
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.MachineLearning.ModelPlotConfigDescriptor<TDocument>(ModelPlotConfigDescriptorAction), options);
		}
		else if (ModelPlotConfigValue is not null)
		{
			writer.WritePropertyName("model_plot_config");
			JsonSerializer.Serialize(writer, ModelPlotConfigValue, options);
		}

		if (ModelPruneWindowValue is not null)
		{
			writer.WritePropertyName("model_prune_window");
			JsonSerializer.Serialize(writer, ModelPruneWindowValue, options);
		}

		if (ModelSnapshotRetentionDaysValue.HasValue)
		{
			writer.WritePropertyName("model_snapshot_retention_days");
			writer.WriteNumberValue(ModelSnapshotRetentionDaysValue.Value);
		}

		if (PerPartitionCategorizationDescriptor is not null)
		{
			writer.WritePropertyName("per_partition_categorization");
			JsonSerializer.Serialize(writer, PerPartitionCategorizationDescriptor, options);
		}
		else if (PerPartitionCategorizationDescriptorAction is not null)
		{
			writer.WritePropertyName("per_partition_categorization");
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.MachineLearning.PerPartitionCategorizationDescriptor(PerPartitionCategorizationDescriptorAction), options);
		}
		else if (PerPartitionCategorizationValue is not null)
		{
			writer.WritePropertyName("per_partition_categorization");
			JsonSerializer.Serialize(writer, PerPartitionCategorizationValue, options);
		}

		if (RenormalizationWindowDaysValue.HasValue)
		{
			writer.WritePropertyName("renormalization_window_days");
			writer.WriteNumberValue(RenormalizationWindowDaysValue.Value);
		}

		if (ResultsRetentionDaysValue.HasValue)
		{
			writer.WritePropertyName("results_retention_days");
			writer.WriteNumberValue(ResultsRetentionDaysValue.Value);
		}

		writer.WriteEndObject();
	}
}

/// <summary>
/// <para>
/// Update an anomaly detection job.
/// Updates certain properties of an anomaly detection job.
/// </para>
/// </summary>
public sealed partial class UpdateJobRequestDescriptor : RequestDescriptor<UpdateJobRequestDescriptor, UpdateJobRequestParameters>
{
	internal UpdateJobRequestDescriptor(Action<UpdateJobRequestDescriptor> configure) => configure.Invoke(this);

	public UpdateJobRequestDescriptor(Elastic.Clients.Elasticsearch.Id jobId) : base(r => r.Required("job_id", jobId))
	{
	}

	internal override ApiUrls ApiUrls => ApiUrlLookup.MachineLearningUpdateJob;

	protected override HttpMethod StaticHttpMethod => HttpMethod.POST;

	internal override bool SupportsBody => true;

	internal override string OperationName => "ml.update_job";

	public UpdateJobRequestDescriptor JobId(Elastic.Clients.Elasticsearch.Id jobId)
	{
		RouteValues.Required("job_id", jobId);
		return Self;
	}

	private bool? AllowLazyOpenValue { get; set; }
	private Elastic.Clients.Elasticsearch.MachineLearning.AnalysisMemoryLimit? AnalysisLimitsValue { get; set; }
	private Elastic.Clients.Elasticsearch.MachineLearning.AnalysisMemoryLimitDescriptor AnalysisLimitsDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.MachineLearning.AnalysisMemoryLimitDescriptor> AnalysisLimitsDescriptorAction { get; set; }
	private Elastic.Clients.Elasticsearch.Duration? BackgroundPersistIntervalValue { get; set; }
	private ICollection<string>? CategorizationFiltersValue { get; set; }
	private IDictionary<string, object>? CustomSettingsValue { get; set; }
	private long? DailyModelSnapshotRetentionAfterDaysValue { get; set; }
	private string? DescriptionValue { get; set; }
	private ICollection<Elastic.Clients.Elasticsearch.MachineLearning.DetectorUpdate>? DetectorsValue { get; set; }
	private Elastic.Clients.Elasticsearch.MachineLearning.DetectorUpdateDescriptor DetectorsDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.MachineLearning.DetectorUpdateDescriptor> DetectorsDescriptorAction { get; set; }
	private Action<Elastic.Clients.Elasticsearch.MachineLearning.DetectorUpdateDescriptor>[] DetectorsDescriptorActions { get; set; }
	private ICollection<string>? GroupsValue { get; set; }
	private Elastic.Clients.Elasticsearch.MachineLearning.ModelPlotConfig? ModelPlotConfigValue { get; set; }
	private Elastic.Clients.Elasticsearch.MachineLearning.ModelPlotConfigDescriptor ModelPlotConfigDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.MachineLearning.ModelPlotConfigDescriptor> ModelPlotConfigDescriptorAction { get; set; }
	private Elastic.Clients.Elasticsearch.Duration? ModelPruneWindowValue { get; set; }
	private long? ModelSnapshotRetentionDaysValue { get; set; }
	private Elastic.Clients.Elasticsearch.MachineLearning.PerPartitionCategorization? PerPartitionCategorizationValue { get; set; }
	private Elastic.Clients.Elasticsearch.MachineLearning.PerPartitionCategorizationDescriptor PerPartitionCategorizationDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.MachineLearning.PerPartitionCategorizationDescriptor> PerPartitionCategorizationDescriptorAction { get; set; }
	private long? RenormalizationWindowDaysValue { get; set; }
	private long? ResultsRetentionDaysValue { get; set; }

	/// <summary>
	/// <para>
	/// Advanced configuration option. Specifies whether this job can open when
	/// there is insufficient machine learning node capacity for it to be
	/// immediately assigned to a node. If <c>false</c> and a machine learning node
	/// with capacity to run the job cannot immediately be found, the open
	/// anomaly detection jobs API returns an error. However, this is also
	/// subject to the cluster-wide <c>xpack.ml.max_lazy_ml_nodes</c> setting. If this
	/// option is set to <c>true</c>, the open anomaly detection jobs API does not
	/// return an error and the job waits in the opening state until sufficient
	/// machine learning node capacity is available.
	/// </para>
	/// </summary>
	public UpdateJobRequestDescriptor AllowLazyOpen(bool? allowLazyOpen = true)
	{
		AllowLazyOpenValue = allowLazyOpen;
		return Self;
	}

	public UpdateJobRequestDescriptor AnalysisLimits(Elastic.Clients.Elasticsearch.MachineLearning.AnalysisMemoryLimit? analysisLimits)
	{
		AnalysisLimitsDescriptor = null;
		AnalysisLimitsDescriptorAction = null;
		AnalysisLimitsValue = analysisLimits;
		return Self;
	}

	public UpdateJobRequestDescriptor AnalysisLimits(Elastic.Clients.Elasticsearch.MachineLearning.AnalysisMemoryLimitDescriptor descriptor)
	{
		AnalysisLimitsValue = null;
		AnalysisLimitsDescriptorAction = null;
		AnalysisLimitsDescriptor = descriptor;
		return Self;
	}

	public UpdateJobRequestDescriptor AnalysisLimits(Action<Elastic.Clients.Elasticsearch.MachineLearning.AnalysisMemoryLimitDescriptor> configure)
	{
		AnalysisLimitsValue = null;
		AnalysisLimitsDescriptor = null;
		AnalysisLimitsDescriptorAction = configure;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Advanced configuration option. The time between each periodic persistence
	/// of the model.
	/// The default value is a randomized value between 3 to 4 hours, which
	/// avoids all jobs persisting at exactly the same time. The smallest allowed
	/// value is 1 hour.
	/// For very large models (several GB), persistence could take 10-20 minutes,
	/// so do not set the value too low.
	/// If the job is open when you make the update, you must stop the datafeed,
	/// close the job, then reopen the job and restart the datafeed for the
	/// changes to take effect.
	/// </para>
	/// </summary>
	public UpdateJobRequestDescriptor BackgroundPersistInterval(Elastic.Clients.Elasticsearch.Duration? backgroundPersistInterval)
	{
		BackgroundPersistIntervalValue = backgroundPersistInterval;
		return Self;
	}

	public UpdateJobRequestDescriptor CategorizationFilters(ICollection<string>? categorizationFilters)
	{
		CategorizationFiltersValue = categorizationFilters;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Advanced configuration option. Contains custom meta data about the job.
	/// For example, it can contain custom URL information as shown in Adding
	/// custom URLs to machine learning results.
	/// </para>
	/// </summary>
	public UpdateJobRequestDescriptor CustomSettings(Func<FluentDictionary<string, object>, FluentDictionary<string, object>> selector)
	{
		CustomSettingsValue = selector?.Invoke(new FluentDictionary<string, object>());
		return Self;
	}

	/// <summary>
	/// <para>
	/// Advanced configuration option, which affects the automatic removal of old
	/// model snapshots for this job. It specifies a period of time (in days)
	/// after which only the first snapshot per day is retained. This period is
	/// relative to the timestamp of the most recent snapshot for this job. Valid
	/// values range from 0 to <c>model_snapshot_retention_days</c>. For jobs created
	/// before version 7.8.0, the default value matches
	/// <c>model_snapshot_retention_days</c>.
	/// </para>
	/// </summary>
	public UpdateJobRequestDescriptor DailyModelSnapshotRetentionAfterDays(long? dailyModelSnapshotRetentionAfterDays)
	{
		DailyModelSnapshotRetentionAfterDaysValue = dailyModelSnapshotRetentionAfterDays;
		return Self;
	}

	/// <summary>
	/// <para>
	/// A description of the job.
	/// </para>
	/// </summary>
	public UpdateJobRequestDescriptor Description(string? description)
	{
		DescriptionValue = description;
		return Self;
	}

	/// <summary>
	/// <para>
	/// An array of detector update objects.
	/// </para>
	/// </summary>
	public UpdateJobRequestDescriptor Detectors(ICollection<Elastic.Clients.Elasticsearch.MachineLearning.DetectorUpdate>? detectors)
	{
		DetectorsDescriptor = null;
		DetectorsDescriptorAction = null;
		DetectorsDescriptorActions = null;
		DetectorsValue = detectors;
		return Self;
	}

	public UpdateJobRequestDescriptor Detectors(Elastic.Clients.Elasticsearch.MachineLearning.DetectorUpdateDescriptor descriptor)
	{
		DetectorsValue = null;
		DetectorsDescriptorAction = null;
		DetectorsDescriptorActions = null;
		DetectorsDescriptor = descriptor;
		return Self;
	}

	public UpdateJobRequestDescriptor Detectors(Action<Elastic.Clients.Elasticsearch.MachineLearning.DetectorUpdateDescriptor> configure)
	{
		DetectorsValue = null;
		DetectorsDescriptor = null;
		DetectorsDescriptorActions = null;
		DetectorsDescriptorAction = configure;
		return Self;
	}

	public UpdateJobRequestDescriptor Detectors(params Action<Elastic.Clients.Elasticsearch.MachineLearning.DetectorUpdateDescriptor>[] configure)
	{
		DetectorsValue = null;
		DetectorsDescriptor = null;
		DetectorsDescriptorAction = null;
		DetectorsDescriptorActions = configure;
		return Self;
	}

	/// <summary>
	/// <para>
	/// A list of job groups. A job can belong to no groups or many.
	/// </para>
	/// </summary>
	public UpdateJobRequestDescriptor Groups(ICollection<string>? groups)
	{
		GroupsValue = groups;
		return Self;
	}

	public UpdateJobRequestDescriptor ModelPlotConfig(Elastic.Clients.Elasticsearch.MachineLearning.ModelPlotConfig? modelPlotConfig)
	{
		ModelPlotConfigDescriptor = null;
		ModelPlotConfigDescriptorAction = null;
		ModelPlotConfigValue = modelPlotConfig;
		return Self;
	}

	public UpdateJobRequestDescriptor ModelPlotConfig(Elastic.Clients.Elasticsearch.MachineLearning.ModelPlotConfigDescriptor descriptor)
	{
		ModelPlotConfigValue = null;
		ModelPlotConfigDescriptorAction = null;
		ModelPlotConfigDescriptor = descriptor;
		return Self;
	}

	public UpdateJobRequestDescriptor ModelPlotConfig(Action<Elastic.Clients.Elasticsearch.MachineLearning.ModelPlotConfigDescriptor> configure)
	{
		ModelPlotConfigValue = null;
		ModelPlotConfigDescriptor = null;
		ModelPlotConfigDescriptorAction = configure;
		return Self;
	}

	public UpdateJobRequestDescriptor ModelPruneWindow(Elastic.Clients.Elasticsearch.Duration? modelPruneWindow)
	{
		ModelPruneWindowValue = modelPruneWindow;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Advanced configuration option, which affects the automatic removal of old
	/// model snapshots for this job. It specifies the maximum period of time (in
	/// days) that snapshots are retained. This period is relative to the
	/// timestamp of the most recent snapshot for this job.
	/// </para>
	/// </summary>
	public UpdateJobRequestDescriptor ModelSnapshotRetentionDays(long? modelSnapshotRetentionDays)
	{
		ModelSnapshotRetentionDaysValue = modelSnapshotRetentionDays;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Settings related to how categorization interacts with partition fields.
	/// </para>
	/// </summary>
	public UpdateJobRequestDescriptor PerPartitionCategorization(Elastic.Clients.Elasticsearch.MachineLearning.PerPartitionCategorization? perPartitionCategorization)
	{
		PerPartitionCategorizationDescriptor = null;
		PerPartitionCategorizationDescriptorAction = null;
		PerPartitionCategorizationValue = perPartitionCategorization;
		return Self;
	}

	public UpdateJobRequestDescriptor PerPartitionCategorization(Elastic.Clients.Elasticsearch.MachineLearning.PerPartitionCategorizationDescriptor descriptor)
	{
		PerPartitionCategorizationValue = null;
		PerPartitionCategorizationDescriptorAction = null;
		PerPartitionCategorizationDescriptor = descriptor;
		return Self;
	}

	public UpdateJobRequestDescriptor PerPartitionCategorization(Action<Elastic.Clients.Elasticsearch.MachineLearning.PerPartitionCategorizationDescriptor> configure)
	{
		PerPartitionCategorizationValue = null;
		PerPartitionCategorizationDescriptor = null;
		PerPartitionCategorizationDescriptorAction = configure;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Advanced configuration option. The period over which adjustments to the
	/// score are applied, as new data is seen.
	/// </para>
	/// </summary>
	public UpdateJobRequestDescriptor RenormalizationWindowDays(long? renormalizationWindowDays)
	{
		RenormalizationWindowDaysValue = renormalizationWindowDays;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Advanced configuration option. The period of time (in days) that results
	/// are retained. Age is calculated relative to the timestamp of the latest
	/// bucket result. If this property has a non-null value, once per day at
	/// 00:30 (server time), results that are the specified number of days older
	/// than the latest bucket result are deleted from Elasticsearch. The default
	/// value is null, which means all results are retained.
	/// </para>
	/// </summary>
	public UpdateJobRequestDescriptor ResultsRetentionDays(long? resultsRetentionDays)
	{
		ResultsRetentionDaysValue = resultsRetentionDays;
		return Self;
	}

	protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
	{
		writer.WriteStartObject();
		if (AllowLazyOpenValue.HasValue)
		{
			writer.WritePropertyName("allow_lazy_open");
			writer.WriteBooleanValue(AllowLazyOpenValue.Value);
		}

		if (AnalysisLimitsDescriptor is not null)
		{
			writer.WritePropertyName("analysis_limits");
			JsonSerializer.Serialize(writer, AnalysisLimitsDescriptor, options);
		}
		else if (AnalysisLimitsDescriptorAction is not null)
		{
			writer.WritePropertyName("analysis_limits");
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.MachineLearning.AnalysisMemoryLimitDescriptor(AnalysisLimitsDescriptorAction), options);
		}
		else if (AnalysisLimitsValue is not null)
		{
			writer.WritePropertyName("analysis_limits");
			JsonSerializer.Serialize(writer, AnalysisLimitsValue, options);
		}

		if (BackgroundPersistIntervalValue is not null)
		{
			writer.WritePropertyName("background_persist_interval");
			JsonSerializer.Serialize(writer, BackgroundPersistIntervalValue, options);
		}

		if (CategorizationFiltersValue is not null)
		{
			writer.WritePropertyName("categorization_filters");
			JsonSerializer.Serialize(writer, CategorizationFiltersValue, options);
		}

		if (CustomSettingsValue is not null)
		{
			writer.WritePropertyName("custom_settings");
			JsonSerializer.Serialize(writer, CustomSettingsValue, options);
		}

		if (DailyModelSnapshotRetentionAfterDaysValue.HasValue)
		{
			writer.WritePropertyName("daily_model_snapshot_retention_after_days");
			writer.WriteNumberValue(DailyModelSnapshotRetentionAfterDaysValue.Value);
		}

		if (!string.IsNullOrEmpty(DescriptionValue))
		{
			writer.WritePropertyName("description");
			writer.WriteStringValue(DescriptionValue);
		}

		if (DetectorsDescriptor is not null)
		{
			writer.WritePropertyName("detectors");
			writer.WriteStartArray();
			JsonSerializer.Serialize(writer, DetectorsDescriptor, options);
			writer.WriteEndArray();
		}
		else if (DetectorsDescriptorAction is not null)
		{
			writer.WritePropertyName("detectors");
			writer.WriteStartArray();
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.MachineLearning.DetectorUpdateDescriptor(DetectorsDescriptorAction), options);
			writer.WriteEndArray();
		}
		else if (DetectorsDescriptorActions is not null)
		{
			writer.WritePropertyName("detectors");
			writer.WriteStartArray();
			foreach (var action in DetectorsDescriptorActions)
			{
				JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.MachineLearning.DetectorUpdateDescriptor(action), options);
			}

			writer.WriteEndArray();
		}
		else if (DetectorsValue is not null)
		{
			writer.WritePropertyName("detectors");
			JsonSerializer.Serialize(writer, DetectorsValue, options);
		}

		if (GroupsValue is not null)
		{
			writer.WritePropertyName("groups");
			JsonSerializer.Serialize(writer, GroupsValue, options);
		}

		if (ModelPlotConfigDescriptor is not null)
		{
			writer.WritePropertyName("model_plot_config");
			JsonSerializer.Serialize(writer, ModelPlotConfigDescriptor, options);
		}
		else if (ModelPlotConfigDescriptorAction is not null)
		{
			writer.WritePropertyName("model_plot_config");
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.MachineLearning.ModelPlotConfigDescriptor(ModelPlotConfigDescriptorAction), options);
		}
		else if (ModelPlotConfigValue is not null)
		{
			writer.WritePropertyName("model_plot_config");
			JsonSerializer.Serialize(writer, ModelPlotConfigValue, options);
		}

		if (ModelPruneWindowValue is not null)
		{
			writer.WritePropertyName("model_prune_window");
			JsonSerializer.Serialize(writer, ModelPruneWindowValue, options);
		}

		if (ModelSnapshotRetentionDaysValue.HasValue)
		{
			writer.WritePropertyName("model_snapshot_retention_days");
			writer.WriteNumberValue(ModelSnapshotRetentionDaysValue.Value);
		}

		if (PerPartitionCategorizationDescriptor is not null)
		{
			writer.WritePropertyName("per_partition_categorization");
			JsonSerializer.Serialize(writer, PerPartitionCategorizationDescriptor, options);
		}
		else if (PerPartitionCategorizationDescriptorAction is not null)
		{
			writer.WritePropertyName("per_partition_categorization");
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.MachineLearning.PerPartitionCategorizationDescriptor(PerPartitionCategorizationDescriptorAction), options);
		}
		else if (PerPartitionCategorizationValue is not null)
		{
			writer.WritePropertyName("per_partition_categorization");
			JsonSerializer.Serialize(writer, PerPartitionCategorizationValue, options);
		}

		if (RenormalizationWindowDaysValue.HasValue)
		{
			writer.WritePropertyName("renormalization_window_days");
			writer.WriteNumberValue(RenormalizationWindowDaysValue.Value);
		}

		if (ResultsRetentionDaysValue.HasValue)
		{
			writer.WritePropertyName("results_retention_days");
			writer.WriteNumberValue(ResultsRetentionDaysValue.Value);
		}

		writer.WriteEndObject();
	}
}