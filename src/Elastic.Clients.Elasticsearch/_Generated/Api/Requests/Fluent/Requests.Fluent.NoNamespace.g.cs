// Licensed to Elasticsearch B.V under one or more agreements.
// Elasticsearch B.V licenses this file to you under the Apache 2.0 License.
// See the LICENSE file in the project root for more information.
//
// ███╗   ██╗ ██████╗ ████████╗██╗ ██████╗███████╗
// ████╗  ██║██╔═══██╗╚══██╔══╝██║██╔════╝██╔════╝
// ██╔██╗ ██║██║   ██║   ██║   ██║██║     █████╗
// ██║╚██╗██║██║   ██║   ██║   ██║██║     ██╔══╝
// ██║ ╚████║╚██████╔╝   ██║   ██║╚██████╗███████╗
// ╚═╝  ╚═══╝ ╚═════╝    ╚═╝   ╚═╝ ╚═════╝╚══════╝
// ------------------------------------------------
//
// This file is automatically generated.
// Please do not edit these files manually.
//
// ------------------------------------------------

using Elastic.Transport;
using System.Collections.Generic;

#nullable restore
namespace Elastic.Clients.Elasticsearch
{
	public partial class BulkDescriptor<TSource> : RequestDescriptorBase<BulkDescriptor<TSource>, BulkRequestParameters, IBulkRequest<TSource>>, IBulkRequest<TSource>
	{
		internal override ApiUrls ApiUrls => ApiUrlsLookups.NoNamespaceBulk;
		protected override HttpMethod HttpMethod => HttpMethod.PUT;
		protected override bool SupportsBody => false;
		///<summary>/_bulk</summary>
        public BulkDescriptor() : base()
		{
		}

		///<summary>/{index}/_bulk</summary>
        public BulkDescriptor(Elastic.Clients.Elasticsearch.IndexName? index) : base(r => r.Optional("index", index))
		{
		}

		public BulkDescriptor<TSource> Pipeline(string? pipeline) => Qs("pipeline", pipeline);
		public BulkDescriptor<TSource> Refresh(Elastic.Clients.Elasticsearch.Refresh? refresh) => Qs("refresh", refresh);
		public BulkDescriptor<TSource> Routing(Elastic.Clients.Elasticsearch.Routing? routing) => Qs("routing", routing);
		public BulkDescriptor<TSource> Source(Union<bool, Elastic.Clients.Elasticsearch.Fields>? source) => Qs("_source", source);
		public BulkDescriptor<TSource> SourceExcludes(Elastic.Clients.Elasticsearch.Fields? sourceExcludes) => Qs("_source_excludes", sourceExcludes);
		public BulkDescriptor<TSource> SourceIncludes(Elastic.Clients.Elasticsearch.Fields? sourceIncludes) => Qs("_source_includes", sourceIncludes);
		public BulkDescriptor<TSource> Timeout(Elastic.Clients.Elasticsearch.Time? timeout) => Qs("timeout", timeout);
		public BulkDescriptor<TSource> Type(string? type) => Qs("type", type);
		public BulkDescriptor<TSource> WaitForActiveShards(Elastic.Clients.Elasticsearch.WaitForActiveShards? waitForActiveShards) => Qs("wait_for_active_shards", waitForActiveShards);
		public BulkDescriptor<TSource> RequireAlias(bool? requireAlias = true) => Qs("require_alias", requireAlias);
	}

	public partial class ClearScrollDescriptor : RequestDescriptorBase<ClearScrollDescriptor, ClearScrollRequestParameters, IClearScrollRequest>, IClearScrollRequest
	{
		internal override ApiUrls ApiUrls => ApiUrlsLookups.NoNamespaceClearScroll;
		protected override HttpMethod HttpMethod => HttpMethod.DELETE;
		protected override bool SupportsBody => false;
		///<summary>/_search/scroll</summary>
        public ClearScrollDescriptor() : base()
		{
		}
	}

	public partial class ClosePointInTimeDescriptor : RequestDescriptorBase<ClosePointInTimeDescriptor, ClosePointInTimeRequestParameters, IClosePointInTimeRequest>, IClosePointInTimeRequest
	{
		internal override ApiUrls ApiUrls => ApiUrlsLookups.NoNamespaceClosePointInTime;
		protected override HttpMethod HttpMethod => HttpMethod.DELETE;
		protected override bool SupportsBody => false;
		///<summary>/_pit</summary>
        public ClosePointInTimeDescriptor() : base()
		{
		}

		Elastic.Clients.Elasticsearch.Id IClosePointInTimeRequest.Id { get; set; }

		public ClosePointInTimeDescriptor Id(Elastic.Clients.Elasticsearch.Id id) => Assign(id, (a, v) => a.Id = v);
	}

	public partial class CountDescriptor : RequestDescriptorBase<CountDescriptor, CountRequestParameters, ICountRequest>, ICountRequest
	{
		internal override ApiUrls ApiUrls => ApiUrlsLookups.NoNamespaceCount;
		protected override HttpMethod HttpMethod => HttpMethod.POST;
		protected override bool SupportsBody => false;
		///<summary>/_count</summary>
        public CountDescriptor() : base()
		{
		}

		///<summary>/{index}/_count</summary>
        public CountDescriptor(Elastic.Clients.Elasticsearch.Indices? index) : base(r => r.Optional("index", index))
		{
		}

		Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? ICountRequest.Query { get; set; }

		public CountDescriptor AllowNoIndices(bool? allowNoIndices = true) => Qs("allow_no_indices", allowNoIndices);
		public CountDescriptor Analyzer(string? analyzer) => Qs("analyzer", analyzer);
		public CountDescriptor AnalyzeWildcard(bool? analyzeWildcard = true) => Qs("analyze_wildcard", analyzeWildcard);
		public CountDescriptor DefaultOperator(Elastic.Clients.Elasticsearch.DefaultOperator? defaultOperator) => Qs("default_operator", defaultOperator);
		public CountDescriptor Df(string? df) => Qs("df", df);
		public CountDescriptor ExpandWildcards(Elastic.Clients.Elasticsearch.ExpandWildcards? expandWildcards) => Qs("expand_wildcards", expandWildcards);
		public CountDescriptor IgnoreThrottled(bool? ignoreThrottled = true) => Qs("ignore_throttled", ignoreThrottled);
		public CountDescriptor IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
		public CountDescriptor Lenient(bool? lenient = true) => Qs("lenient", lenient);
		public CountDescriptor MinScore(double? minScore) => Qs("min_score", minScore);
		public CountDescriptor Preference(string? preference) => Qs("preference", preference);
		public CountDescriptor QueryOnQueryString(string? queryOnQueryString) => Qs("query_on_query_string", queryOnQueryString);
		public CountDescriptor Routing(Elastic.Clients.Elasticsearch.Routing? routing) => Qs("routing", routing);
		public CountDescriptor TerminateAfter(long? terminateAfter) => Qs("terminate_after", terminateAfter);
		public CountDescriptor LuceneQueryString(string? luceneQueryString) => Qs("q", luceneQueryString);
		public CountDescriptor Query(Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? query) => Assign(query, (a, v) => a.Query = v);
	}

	public partial class CreateDescriptor<TDocument> : RequestDescriptorBase<CreateDescriptor<TDocument>, CreateRequestParameters, ICreateRequest<TDocument>>, ICreateRequest<TDocument>
	{
		internal override ApiUrls ApiUrls => ApiUrlsLookups.NoNamespaceCreate;
		protected override HttpMethod HttpMethod => HttpMethod.PUT;
		protected override bool SupportsBody => false;
		///<summary>/{index}/_create/{id}</summary>
        public CreateDescriptor(Elastic.Clients.Elasticsearch.IndexName index, Elastic.Clients.Elasticsearch.Id id) : base(r => r.Required("index", index).Required("id", id))
		{
		}

		public CreateDescriptor<TDocument> Pipeline(string? pipeline) => Qs("pipeline", pipeline);
		public CreateDescriptor<TDocument> Refresh(Elastic.Clients.Elasticsearch.Refresh? refresh) => Qs("refresh", refresh);
		public CreateDescriptor<TDocument> Routing(Elastic.Clients.Elasticsearch.Routing? routing) => Qs("routing", routing);
		public CreateDescriptor<TDocument> Timeout(Elastic.Clients.Elasticsearch.Time? timeout) => Qs("timeout", timeout);
		public CreateDescriptor<TDocument> Version(Elastic.Clients.Elasticsearch.VersionNumber? version) => Qs("version", version);
		public CreateDescriptor<TDocument> VersionType(Elastic.Clients.Elasticsearch.VersionType? versionType) => Qs("version_type", versionType);
		public CreateDescriptor<TDocument> WaitForActiveShards(Elastic.Clients.Elasticsearch.WaitForActiveShards? waitForActiveShards) => Qs("wait_for_active_shards", waitForActiveShards);
	}

	public partial class DeleteDescriptor : RequestDescriptorBase<DeleteDescriptor, DeleteRequestParameters, IDeleteRequest>, IDeleteRequest
	{
		internal override ApiUrls ApiUrls => ApiUrlsLookups.NoNamespaceDelete;
		protected override HttpMethod HttpMethod => HttpMethod.DELETE;
		protected override bool SupportsBody => false;
		///<summary>/{index}/_doc/{id}</summary>
        public DeleteDescriptor(Elastic.Clients.Elasticsearch.IndexName index, Elastic.Clients.Elasticsearch.Id id) : base(r => r.Required("index", index).Required("id", id))
		{
		}

		public DeleteDescriptor IfPrimaryTerm(long? ifPrimaryTerm) => Qs("if_primary_term", ifPrimaryTerm);
		public DeleteDescriptor IfSeqNo(Elastic.Clients.Elasticsearch.SequenceNumber? ifSeqNo) => Qs("if_seq_no", ifSeqNo);
		public DeleteDescriptor Refresh(Elastic.Clients.Elasticsearch.Refresh? refresh) => Qs("refresh", refresh);
		public DeleteDescriptor Routing(Elastic.Clients.Elasticsearch.Routing? routing) => Qs("routing", routing);
		public DeleteDescriptor Timeout(Elastic.Clients.Elasticsearch.Time? timeout) => Qs("timeout", timeout);
		public DeleteDescriptor Version(Elastic.Clients.Elasticsearch.VersionNumber? version) => Qs("version", version);
		public DeleteDescriptor VersionType(Elastic.Clients.Elasticsearch.VersionType? versionType) => Qs("version_type", versionType);
		public DeleteDescriptor WaitForActiveShards(Elastic.Clients.Elasticsearch.WaitForActiveShards? waitForActiveShards) => Qs("wait_for_active_shards", waitForActiveShards);
	}

	public partial class DeleteByQueryDescriptor : RequestDescriptorBase<DeleteByQueryDescriptor, DeleteByQueryRequestParameters, IDeleteByQueryRequest>, IDeleteByQueryRequest
	{
		internal override ApiUrls ApiUrls => ApiUrlsLookups.NoNamespaceDeleteByQuery;
		protected override HttpMethod HttpMethod => HttpMethod.POST;
		protected override bool SupportsBody => false;
		///<summary>/{index}/_delete_by_query</summary>
        public DeleteByQueryDescriptor(Elastic.Clients.Elasticsearch.Indices index) : base(r => r.Required("index", index))
		{
		}

		Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? IDeleteByQueryRequest.Query { get; set; }

		Elastic.Clients.Elasticsearch.SlicedScroll? IDeleteByQueryRequest.Slice { get; set; }

		public DeleteByQueryDescriptor AllowNoIndices(bool? allowNoIndices = true) => Qs("allow_no_indices", allowNoIndices);
		public DeleteByQueryDescriptor Analyzer(string? analyzer) => Qs("analyzer", analyzer);
		public DeleteByQueryDescriptor AnalyzeWildcard(bool? analyzeWildcard = true) => Qs("analyze_wildcard", analyzeWildcard);
		public DeleteByQueryDescriptor Conflicts(Elastic.Clients.Elasticsearch.Conflicts? conflicts) => Qs("conflicts", conflicts);
		public DeleteByQueryDescriptor DefaultOperator(Elastic.Clients.Elasticsearch.DefaultOperator? defaultOperator) => Qs("default_operator", defaultOperator);
		public DeleteByQueryDescriptor Df(string? df) => Qs("df", df);
		public DeleteByQueryDescriptor ExpandWildcards(Elastic.Clients.Elasticsearch.ExpandWildcards? expandWildcards) => Qs("expand_wildcards", expandWildcards);
		public DeleteByQueryDescriptor From(long? from) => Qs("from", from);
		public DeleteByQueryDescriptor IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
		public DeleteByQueryDescriptor Lenient(bool? lenient = true) => Qs("lenient", lenient);
		public DeleteByQueryDescriptor MaxDocs(long? maxDocs) => Qs("max_docs", maxDocs);
		public DeleteByQueryDescriptor Preference(string? preference) => Qs("preference", preference);
		public DeleteByQueryDescriptor Refresh(bool? refresh = true) => Qs("refresh", refresh);
		public DeleteByQueryDescriptor RequestCache(bool? requestCache = true) => Qs("request_cache", requestCache);
		public DeleteByQueryDescriptor RequestsPerSecond(long? requestsPerSecond) => Qs("requests_per_second", requestsPerSecond);
		public DeleteByQueryDescriptor Routing(Elastic.Clients.Elasticsearch.Routing? routing) => Qs("routing", routing);
		public DeleteByQueryDescriptor LuceneQueryString(string? luceneQueryString) => Qs("q", luceneQueryString);
		public DeleteByQueryDescriptor Scroll(Elastic.Clients.Elasticsearch.Time? scroll) => Qs("scroll", scroll);
		public DeleteByQueryDescriptor ScrollSize(long? scrollSize) => Qs("scroll_size", scrollSize);
		public DeleteByQueryDescriptor SearchTimeout(Elastic.Clients.Elasticsearch.Time? searchTimeout) => Qs("search_timeout", searchTimeout);
		public DeleteByQueryDescriptor SearchType(Elastic.Clients.Elasticsearch.SearchType? searchType) => Qs("search_type", searchType);
		public DeleteByQueryDescriptor Size(long? size) => Qs("size", size);
		public DeleteByQueryDescriptor Slices(long? slices) => Qs("slices", slices);
		public DeleteByQueryDescriptor Sort(IEnumerable<string>? sort) => Qs("sort", sort);
		public DeleteByQueryDescriptor Source(Union<bool, Elastic.Clients.Elasticsearch.Fields>? source) => Qs("_source", source);
		public DeleteByQueryDescriptor SourceExcludes(Elastic.Clients.Elasticsearch.Fields? sourceExcludes) => Qs("_source_excludes", sourceExcludes);
		public DeleteByQueryDescriptor SourceIncludes(Elastic.Clients.Elasticsearch.Fields? sourceIncludes) => Qs("_source_includes", sourceIncludes);
		public DeleteByQueryDescriptor Stats(IEnumerable<string>? stats) => Qs("stats", stats);
		public DeleteByQueryDescriptor TerminateAfter(long? terminateAfter) => Qs("terminate_after", terminateAfter);
		public DeleteByQueryDescriptor Timeout(Elastic.Clients.Elasticsearch.Time? timeout) => Qs("timeout", timeout);
		public DeleteByQueryDescriptor Version(bool? version = true) => Qs("version", version);
		public DeleteByQueryDescriptor WaitForActiveShards(Elastic.Clients.Elasticsearch.WaitForActiveShards? waitForActiveShards) => Qs("wait_for_active_shards", waitForActiveShards);
		public DeleteByQueryDescriptor WaitForCompletion(bool? waitForCompletion = true) => Qs("wait_for_completion", waitForCompletion);
		public DeleteByQueryDescriptor Query(Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? query) => Assign(query, (a, v) => a.Query = v);
		public DeleteByQueryDescriptor Slice(Elastic.Clients.Elasticsearch.SlicedScroll? slice) => Assign(slice, (a, v) => a.Slice = v);
	}

	public partial class DeleteByQueryRethrottleDescriptor : RequestDescriptorBase<DeleteByQueryRethrottleDescriptor, DeleteByQueryRethrottleRequestParameters, IDeleteByQueryRethrottleRequest>, IDeleteByQueryRethrottleRequest
	{
		internal override ApiUrls ApiUrls => ApiUrlsLookups.NoNamespaceDeleteByQueryRethrottle;
		protected override HttpMethod HttpMethod => HttpMethod.POST;
		protected override bool SupportsBody => false;
		///<summary>/_delete_by_query/{task_id}/_rethrottle</summary>
        public DeleteByQueryRethrottleDescriptor(Elastic.Clients.Elasticsearch.Id task_id) : base(r => r.Required("task_id", task_id))
		{
		}

		public DeleteByQueryRethrottleDescriptor RequestsPerSecond(long? requestsPerSecond) => Qs("requests_per_second", requestsPerSecond);
	}

	public partial class DeleteScriptDescriptor : RequestDescriptorBase<DeleteScriptDescriptor, DeleteScriptRequestParameters, IDeleteScriptRequest>, IDeleteScriptRequest
	{
		internal override ApiUrls ApiUrls => ApiUrlsLookups.NoNamespaceDeleteScript;
		protected override HttpMethod HttpMethod => HttpMethod.DELETE;
		protected override bool SupportsBody => false;
		///<summary>/_scripts/{id}</summary>
        public DeleteScriptDescriptor(Elastic.Clients.Elasticsearch.Id id) : base(r => r.Required("id", id))
		{
		}

		public DeleteScriptDescriptor MasterTimeout(Elastic.Clients.Elasticsearch.Time? masterTimeout) => Qs("master_timeout", masterTimeout);
		public DeleteScriptDescriptor Timeout(Elastic.Clients.Elasticsearch.Time? timeout) => Qs("timeout", timeout);
	}

	public partial class ExistsDescriptor : RequestDescriptorBase<ExistsDescriptor, ExistsRequestParameters, IExistsRequest>, IExistsRequest
	{
		internal override ApiUrls ApiUrls => ApiUrlsLookups.NoNamespaceExists;
		protected override HttpMethod HttpMethod => HttpMethod.HEAD;
		protected override bool SupportsBody => false;
		///<summary>/{index}/_doc/{id}</summary>
        public ExistsDescriptor(Elastic.Clients.Elasticsearch.IndexName index, Elastic.Clients.Elasticsearch.Id id) : base(r => r.Required("index", index).Required("id", id))
		{
		}

		public ExistsDescriptor Preference(string? preference) => Qs("preference", preference);
		public ExistsDescriptor Realtime(bool? realtime = true) => Qs("realtime", realtime);
		public ExistsDescriptor Refresh(bool? refresh = true) => Qs("refresh", refresh);
		public ExistsDescriptor Routing(Elastic.Clients.Elasticsearch.Routing? routing) => Qs("routing", routing);
		public ExistsDescriptor Source(Union<bool, Elastic.Clients.Elasticsearch.Fields>? source) => Qs("_source", source);
		public ExistsDescriptor SourceExcludes(Elastic.Clients.Elasticsearch.Fields? sourceExcludes) => Qs("_source_excludes", sourceExcludes);
		public ExistsDescriptor SourceIncludes(Elastic.Clients.Elasticsearch.Fields? sourceIncludes) => Qs("_source_includes", sourceIncludes);
		public ExistsDescriptor StoredFields(Elastic.Clients.Elasticsearch.Fields? storedFields) => Qs("stored_fields", storedFields);
		public ExistsDescriptor Version(Elastic.Clients.Elasticsearch.VersionNumber? version) => Qs("version", version);
		public ExistsDescriptor VersionType(Elastic.Clients.Elasticsearch.VersionType? versionType) => Qs("version_type", versionType);
	}

	public partial class ExistsSourceDescriptor : RequestDescriptorBase<ExistsSourceDescriptor, ExistsSourceRequestParameters, IExistsSourceRequest>, IExistsSourceRequest
	{
		internal override ApiUrls ApiUrls => ApiUrlsLookups.NoNamespaceExistsSource;
		protected override HttpMethod HttpMethod => HttpMethod.HEAD;
		protected override bool SupportsBody => false;
		///<summary>/{index}/_source/{id}</summary>
        public ExistsSourceDescriptor(Elastic.Clients.Elasticsearch.IndexName index, Elastic.Clients.Elasticsearch.Id id) : base(r => r.Required("index", index).Required("id", id))
		{
		}

		public ExistsSourceDescriptor Preference(string? preference) => Qs("preference", preference);
		public ExistsSourceDescriptor Realtime(bool? realtime = true) => Qs("realtime", realtime);
		public ExistsSourceDescriptor Refresh(bool? refresh = true) => Qs("refresh", refresh);
		public ExistsSourceDescriptor Routing(Elastic.Clients.Elasticsearch.Routing? routing) => Qs("routing", routing);
		public ExistsSourceDescriptor Source(Union<bool, Elastic.Clients.Elasticsearch.Fields>? source) => Qs("_source", source);
		public ExistsSourceDescriptor SourceExcludes(Elastic.Clients.Elasticsearch.Fields? sourceExcludes) => Qs("_source_excludes", sourceExcludes);
		public ExistsSourceDescriptor SourceIncludes(Elastic.Clients.Elasticsearch.Fields? sourceIncludes) => Qs("_source_includes", sourceIncludes);
		public ExistsSourceDescriptor Version(Elastic.Clients.Elasticsearch.VersionNumber? version) => Qs("version", version);
		public ExistsSourceDescriptor VersionType(Elastic.Clients.Elasticsearch.VersionType? versionType) => Qs("version_type", versionType);
	}

	public partial class ExplainDescriptor : RequestDescriptorBase<ExplainDescriptor, ExplainRequestParameters, IExplainRequest>, IExplainRequest
	{
		internal override ApiUrls ApiUrls => ApiUrlsLookups.NoNamespaceExplain;
		protected override HttpMethod HttpMethod => HttpMethod.POST;
		protected override bool SupportsBody => false;
		///<summary>/{index}/_explain/{id}</summary>
        public ExplainDescriptor(Elastic.Clients.Elasticsearch.IndexName index, Elastic.Clients.Elasticsearch.Id id) : base(r => r.Required("index", index).Required("id", id))
		{
		}

		Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? IExplainRequest.Query { get; set; }

		public ExplainDescriptor Analyzer(string? analyzer) => Qs("analyzer", analyzer);
		public ExplainDescriptor AnalyzeWildcard(bool? analyzeWildcard = true) => Qs("analyze_wildcard", analyzeWildcard);
		public ExplainDescriptor DefaultOperator(Elastic.Clients.Elasticsearch.DefaultOperator? defaultOperator) => Qs("default_operator", defaultOperator);
		public ExplainDescriptor Df(string? df) => Qs("df", df);
		public ExplainDescriptor Lenient(bool? lenient = true) => Qs("lenient", lenient);
		public ExplainDescriptor Preference(string? preference) => Qs("preference", preference);
		public ExplainDescriptor QueryOnQueryString(string? queryOnQueryString) => Qs("query_on_query_string", queryOnQueryString);
		public ExplainDescriptor Routing(Elastic.Clients.Elasticsearch.Routing? routing) => Qs("routing", routing);
		public ExplainDescriptor Source(Union<bool, Elastic.Clients.Elasticsearch.Fields>? source) => Qs("_source", source);
		public ExplainDescriptor SourceExcludes(Elastic.Clients.Elasticsearch.Fields? sourceExcludes) => Qs("_source_excludes", sourceExcludes);
		public ExplainDescriptor SourceIncludes(Elastic.Clients.Elasticsearch.Fields? sourceIncludes) => Qs("_source_includes", sourceIncludes);
		public ExplainDescriptor StoredFields(Elastic.Clients.Elasticsearch.Fields? storedFields) => Qs("stored_fields", storedFields);
		public ExplainDescriptor LuceneQueryString(string? luceneQueryString) => Qs("q", luceneQueryString);
		public ExplainDescriptor Query(Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? query) => Assign(query, (a, v) => a.Query = v);
	}

	public partial class FieldCapsDescriptor : RequestDescriptorBase<FieldCapsDescriptor, FieldCapsRequestParameters, IFieldCapsRequest>, IFieldCapsRequest
	{
		internal override ApiUrls ApiUrls => ApiUrlsLookups.NoNamespaceFieldCaps;
		protected override HttpMethod HttpMethod => HttpMethod.POST;
		protected override bool SupportsBody => false;
		///<summary>/_field_caps</summary>
        public FieldCapsDescriptor() : base()
		{
		}

		///<summary>/{index}/_field_caps</summary>
        public FieldCapsDescriptor(Elastic.Clients.Elasticsearch.Indices? index) : base(r => r.Optional("index", index))
		{
		}

		Elastic.Clients.Elasticsearch.Global.FieldCaps.FieldCapabilitiesBodyIndexFilter? IFieldCapsRequest.IndexFilter { get; set; }

		public FieldCapsDescriptor AllowNoIndices(bool? allowNoIndices = true) => Qs("allow_no_indices", allowNoIndices);
		public FieldCapsDescriptor ExpandWildcards(Elastic.Clients.Elasticsearch.ExpandWildcards? expandWildcards) => Qs("expand_wildcards", expandWildcards);
		public FieldCapsDescriptor Fields(Elastic.Clients.Elasticsearch.Fields? fields) => Qs("fields", fields);
		public FieldCapsDescriptor IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
		public FieldCapsDescriptor IncludeUnmapped(bool? includeUnmapped = true) => Qs("include_unmapped", includeUnmapped);
		public FieldCapsDescriptor IndexFilter(Elastic.Clients.Elasticsearch.Global.FieldCaps.FieldCapabilitiesBodyIndexFilter? indexFilter) => Assign(indexFilter, (a, v) => a.IndexFilter = v);
	}

	public partial class GetDescriptor : RequestDescriptorBase<GetDescriptor, GetRequestParameters, IGetRequest>, IGetRequest
	{
		internal override ApiUrls ApiUrls => ApiUrlsLookups.NoNamespaceGet;
		protected override HttpMethod HttpMethod => HttpMethod.GET;
		protected override bool SupportsBody => false;
		///<summary>/{index}/_doc/{id}</summary>
        public GetDescriptor(Elastic.Clients.Elasticsearch.IndexName index, Elastic.Clients.Elasticsearch.Id id) : base(r => r.Required("index", index).Required("id", id))
		{
		}

		public GetDescriptor Preference(string? preference) => Qs("preference", preference);
		public GetDescriptor Realtime(bool? realtime = true) => Qs("realtime", realtime);
		public GetDescriptor Refresh(bool? refresh = true) => Qs("refresh", refresh);
		public GetDescriptor Routing(Elastic.Clients.Elasticsearch.Routing? routing) => Qs("routing", routing);
		public GetDescriptor Source(Union<bool, Elastic.Clients.Elasticsearch.Fields>? source) => Qs("_source", source);
		public GetDescriptor SourceExcludes(Elastic.Clients.Elasticsearch.Fields? sourceExcludes) => Qs("_source_excludes", sourceExcludes);
		public GetDescriptor SourceIncludes(Elastic.Clients.Elasticsearch.Fields? sourceIncludes) => Qs("_source_includes", sourceIncludes);
		public GetDescriptor StoredFields(Elastic.Clients.Elasticsearch.Fields? storedFields) => Qs("stored_fields", storedFields);
		public GetDescriptor Version(Elastic.Clients.Elasticsearch.VersionNumber? version) => Qs("version", version);
		public GetDescriptor VersionType(Elastic.Clients.Elasticsearch.VersionType? versionType) => Qs("version_type", versionType);
	}

	public partial class GetScriptDescriptor : RequestDescriptorBase<GetScriptDescriptor, GetScriptRequestParameters, IGetScriptRequest>, IGetScriptRequest
	{
		internal override ApiUrls ApiUrls => ApiUrlsLookups.NoNamespaceGetScript;
		protected override HttpMethod HttpMethod => HttpMethod.GET;
		protected override bool SupportsBody => false;
		///<summary>/_scripts/{id}</summary>
        public GetScriptDescriptor(Elastic.Clients.Elasticsearch.Id id) : base(r => r.Required("id", id))
		{
		}

		public GetScriptDescriptor MasterTimeout(Elastic.Clients.Elasticsearch.Time? masterTimeout) => Qs("master_timeout", masterTimeout);
	}

	public partial class GetScriptContextDescriptor : RequestDescriptorBase<GetScriptContextDescriptor, GetScriptContextRequestParameters, IGetScriptContextRequest>, IGetScriptContextRequest
	{
		internal override ApiUrls ApiUrls => ApiUrlsLookups.NoNamespaceGetScriptContext;
		protected override HttpMethod HttpMethod => HttpMethod.GET;
		protected override bool SupportsBody => false;
		///<summary>/_script_context</summary>
        public GetScriptContextDescriptor() : base()
		{
		}
	}

	public partial class GetScriptLanguagesDescriptor : RequestDescriptorBase<GetScriptLanguagesDescriptor, GetScriptLanguagesRequestParameters, IGetScriptLanguagesRequest>, IGetScriptLanguagesRequest
	{
		internal override ApiUrls ApiUrls => ApiUrlsLookups.NoNamespaceGetScriptLanguages;
		protected override HttpMethod HttpMethod => HttpMethod.GET;
		protected override bool SupportsBody => false;
		///<summary>/_script_language</summary>
        public GetScriptLanguagesDescriptor() : base()
		{
		}
	}

	public partial class GetSourceDescriptor : RequestDescriptorBase<GetSourceDescriptor, GetSourceRequestParameters, IGetSourceRequest>, IGetSourceRequest
	{
		internal override ApiUrls ApiUrls => ApiUrlsLookups.NoNamespaceGetSource;
		protected override HttpMethod HttpMethod => HttpMethod.GET;
		protected override bool SupportsBody => false;
	}

	public partial class IndexDescriptor<TDocument> : RequestDescriptorBase<IndexDescriptor<TDocument>, IndexRequestParameters, IIndexRequest<TDocument>>, IIndexRequest<TDocument>
	{
		internal override ApiUrls ApiUrls => ApiUrlsLookups.NoNamespaceIndex;
		protected override HttpMethod HttpMethod => HttpMethod.PUT;
		protected override bool SupportsBody => false;
		///<summary>/{index}/_doc/{id}</summary>
        public IndexDescriptor(Elastic.Clients.Elasticsearch.IndexName index, Elastic.Clients.Elasticsearch.Id? id) : base(r => r.Required("index", index).Optional("id", id))
		{
		}

		///<summary>/{index}/_doc</summary>
        public IndexDescriptor(Elastic.Clients.Elasticsearch.IndexName index) : base(r => r.Required("index", index))
		{
		}

		public IndexDescriptor<TDocument> IfPrimaryTerm(long? ifPrimaryTerm) => Qs("if_primary_term", ifPrimaryTerm);
		public IndexDescriptor<TDocument> IfSeqNo(Elastic.Clients.Elasticsearch.SequenceNumber? ifSeqNo) => Qs("if_seq_no", ifSeqNo);
		public IndexDescriptor<TDocument> OpType(Elastic.Clients.Elasticsearch.OpType? opType) => Qs("op_type", opType);
		public IndexDescriptor<TDocument> Pipeline(string? pipeline) => Qs("pipeline", pipeline);
		public IndexDescriptor<TDocument> Refresh(Elastic.Clients.Elasticsearch.Refresh? refresh) => Qs("refresh", refresh);
		public IndexDescriptor<TDocument> Routing(Elastic.Clients.Elasticsearch.Routing? routing) => Qs("routing", routing);
		public IndexDescriptor<TDocument> Timeout(Elastic.Clients.Elasticsearch.Time? timeout) => Qs("timeout", timeout);
		public IndexDescriptor<TDocument> Version(Elastic.Clients.Elasticsearch.VersionNumber? version) => Qs("version", version);
		public IndexDescriptor<TDocument> VersionType(Elastic.Clients.Elasticsearch.VersionType? versionType) => Qs("version_type", versionType);
		public IndexDescriptor<TDocument> WaitForActiveShards(Elastic.Clients.Elasticsearch.WaitForActiveShards? waitForActiveShards) => Qs("wait_for_active_shards", waitForActiveShards);
		public IndexDescriptor<TDocument> RequireAlias(bool? requireAlias = true) => Qs("require_alias", requireAlias);
	}

	public partial class InfoDescriptor : RequestDescriptorBase<InfoDescriptor, InfoRequestParameters, IInfoRequest>, IInfoRequest
	{
		internal override ApiUrls ApiUrls => ApiUrlsLookups.NoNamespaceInfo;
		protected override HttpMethod HttpMethod => HttpMethod.GET;
		protected override bool SupportsBody => false;
		///<summary>/</summary>
        public InfoDescriptor() : base()
		{
		}
	}

	public partial class MgetDescriptor : RequestDescriptorBase<MgetDescriptor, MgetRequestParameters, IMgetRequest>, IMgetRequest
	{
		internal override ApiUrls ApiUrls => ApiUrlsLookups.NoNamespaceMget;
		protected override HttpMethod HttpMethod => HttpMethod.POST;
		protected override bool SupportsBody => false;
		///<summary>/_mget</summary>
        public MgetDescriptor() : base()
		{
		}

		///<summary>/{index}/_mget</summary>
        public MgetDescriptor(Elastic.Clients.Elasticsearch.IndexName? index) : base(r => r.Optional("index", index))
		{
		}

		IEnumerable<Elastic.Clients.Elasticsearch.Global.Mget.Operation>? IMgetRequest.Docs { get; set; }

		IEnumerable<Elastic.Clients.Elasticsearch.Global.Mget.MultiGetId>? IMgetRequest.Ids { get; set; }

		public MgetDescriptor Preference(string? preference) => Qs("preference", preference);
		public MgetDescriptor Realtime(bool? realtime = true) => Qs("realtime", realtime);
		public MgetDescriptor Refresh(bool? refresh = true) => Qs("refresh", refresh);
		public MgetDescriptor Routing(Elastic.Clients.Elasticsearch.Routing? routing) => Qs("routing", routing);
		public MgetDescriptor Source(Union<bool, Elastic.Clients.Elasticsearch.Fields>? source) => Qs("_source", source);
		public MgetDescriptor SourceExcludes(Elastic.Clients.Elasticsearch.Fields? sourceExcludes) => Qs("_source_excludes", sourceExcludes);
		public MgetDescriptor SourceIncludes(Elastic.Clients.Elasticsearch.Fields? sourceIncludes) => Qs("_source_includes", sourceIncludes);
		public MgetDescriptor StoredFields(Elastic.Clients.Elasticsearch.Fields? storedFields) => Qs("stored_fields", storedFields);
		public MgetDescriptor Docs(IEnumerable<Elastic.Clients.Elasticsearch.Global.Mget.Operation>? docs) => Assign(docs, (a, v) => a.Docs = v);
		public MgetDescriptor Ids(IEnumerable<Elastic.Clients.Elasticsearch.Global.Mget.MultiGetId>? ids) => Assign(ids, (a, v) => a.Ids = v);
	}

	public partial class MsearchDescriptor : RequestDescriptorBase<MsearchDescriptor, MsearchRequestParameters, IMsearchRequest>, IMsearchRequest
	{
		internal override ApiUrls ApiUrls => ApiUrlsLookups.NoNamespaceMsearch;
		protected override HttpMethod HttpMethod => HttpMethod.POST;
		protected override bool SupportsBody => false;
		///<summary>/_msearch</summary>
        public MsearchDescriptor() : base()
		{
		}

		///<summary>/{index}/_msearch</summary>
        public MsearchDescriptor(Elastic.Clients.Elasticsearch.Indices? index) : base(r => r.Optional("index", index))
		{
		}

		public MsearchDescriptor AllowNoIndices(bool? allowNoIndices = true) => Qs("allow_no_indices", allowNoIndices);
		public MsearchDescriptor CcsMinimizeRoundtrips(bool? ccsMinimizeRoundtrips = true) => Qs("ccs_minimize_roundtrips", ccsMinimizeRoundtrips);
		public MsearchDescriptor ExpandWildcards(Elastic.Clients.Elasticsearch.ExpandWildcards? expandWildcards) => Qs("expand_wildcards", expandWildcards);
		public MsearchDescriptor IgnoreThrottled(bool? ignoreThrottled = true) => Qs("ignore_throttled", ignoreThrottled);
		public MsearchDescriptor IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
		public MsearchDescriptor MaxConcurrentSearches(long? maxConcurrentSearches) => Qs("max_concurrent_searches", maxConcurrentSearches);
		public MsearchDescriptor MaxConcurrentShardRequests(long? maxConcurrentShardRequests) => Qs("max_concurrent_shard_requests", maxConcurrentShardRequests);
		public MsearchDescriptor PreFilterShardSize(long? preFilterShardSize) => Qs("pre_filter_shard_size", preFilterShardSize);
		public MsearchDescriptor SearchType(Elastic.Clients.Elasticsearch.SearchType? searchType) => Qs("search_type", searchType);
		public MsearchDescriptor RestTotalHitsAsInt(bool? restTotalHitsAsInt = true) => Qs("rest_total_hits_as_int", restTotalHitsAsInt);
		public MsearchDescriptor TypedKeys(bool? typedKeys = true) => Qs("typed_keys", typedKeys);
	}

	public partial class MsearchTemplateDescriptor : RequestDescriptorBase<MsearchTemplateDescriptor, MsearchTemplateRequestParameters, IMsearchTemplateRequest>, IMsearchTemplateRequest
	{
		internal override ApiUrls ApiUrls => ApiUrlsLookups.NoNamespaceMsearchTemplate;
		protected override HttpMethod HttpMethod => HttpMethod.POST;
		protected override bool SupportsBody => false;
		///<summary>/_msearch/template</summary>
        public MsearchTemplateDescriptor() : base()
		{
		}

		///<summary>/{index}/_msearch/template</summary>
        public MsearchTemplateDescriptor(Elastic.Clients.Elasticsearch.Indices? index) : base(r => r.Optional("index", index))
		{
		}

		public MsearchTemplateDescriptor CcsMinimizeRoundtrips(bool? ccsMinimizeRoundtrips = true) => Qs("ccs_minimize_roundtrips", ccsMinimizeRoundtrips);
		public MsearchTemplateDescriptor MaxConcurrentSearches(long? maxConcurrentSearches) => Qs("max_concurrent_searches", maxConcurrentSearches);
		public MsearchTemplateDescriptor SearchType(Elastic.Clients.Elasticsearch.SearchType? searchType) => Qs("search_type", searchType);
		public MsearchTemplateDescriptor RestTotalHitsAsInt(bool? restTotalHitsAsInt = true) => Qs("rest_total_hits_as_int", restTotalHitsAsInt);
		public MsearchTemplateDescriptor TypedKeys(bool? typedKeys = true) => Qs("typed_keys", typedKeys);
	}

	public partial class MtermvectorsDescriptor : RequestDescriptorBase<MtermvectorsDescriptor, MtermvectorsRequestParameters, IMtermvectorsRequest>, IMtermvectorsRequest
	{
		internal override ApiUrls ApiUrls => ApiUrlsLookups.NoNamespaceMtermvectors;
		protected override HttpMethod HttpMethod => HttpMethod.POST;
		protected override bool SupportsBody => false;
		///<summary>/_mtermvectors</summary>
        public MtermvectorsDescriptor() : base()
		{
		}

		///<summary>/{index}/_mtermvectors</summary>
        public MtermvectorsDescriptor(Elastic.Clients.Elasticsearch.IndexName? index) : base(r => r.Optional("index", index))
		{
		}

		IEnumerable<Elastic.Clients.Elasticsearch.Global.Mtermvectors.Operation>? IMtermvectorsRequest.Docs { get; set; }

		public MtermvectorsDescriptor Ids(IEnumerable<Elastic.Clients.Elasticsearch.Id>? ids) => Qs("ids", ids);
		public MtermvectorsDescriptor Fields(Elastic.Clients.Elasticsearch.Fields? fields) => Qs("fields", fields);
		public MtermvectorsDescriptor FieldStatistics(bool? fieldStatistics = true) => Qs("field_statistics", fieldStatistics);
		public MtermvectorsDescriptor Offsets(bool? offsets = true) => Qs("offsets", offsets);
		public MtermvectorsDescriptor Payloads(bool? payloads = true) => Qs("payloads", payloads);
		public MtermvectorsDescriptor Positions(bool? positions = true) => Qs("positions", positions);
		public MtermvectorsDescriptor Preference(string? preference) => Qs("preference", preference);
		public MtermvectorsDescriptor Realtime(bool? realtime = true) => Qs("realtime", realtime);
		public MtermvectorsDescriptor Routing(Elastic.Clients.Elasticsearch.Routing? routing) => Qs("routing", routing);
		public MtermvectorsDescriptor TermStatistics(bool? termStatistics = true) => Qs("term_statistics", termStatistics);
		public MtermvectorsDescriptor Version(Elastic.Clients.Elasticsearch.VersionNumber? version) => Qs("version", version);
		public MtermvectorsDescriptor VersionType(Elastic.Clients.Elasticsearch.VersionType? versionType) => Qs("version_type", versionType);
		public MtermvectorsDescriptor Docs(IEnumerable<Elastic.Clients.Elasticsearch.Global.Mtermvectors.Operation>? docs) => Assign(docs, (a, v) => a.Docs = v);
	}

	public partial class OpenPointInTimeDescriptor : RequestDescriptorBase<OpenPointInTimeDescriptor, OpenPointInTimeRequestParameters, IOpenPointInTimeRequest>, IOpenPointInTimeRequest
	{
		internal override ApiUrls ApiUrls => ApiUrlsLookups.NoNamespaceOpenPointInTime;
		protected override HttpMethod HttpMethod => HttpMethod.POST;
		protected override bool SupportsBody => false;
		///<summary>/_pit</summary>
        public OpenPointInTimeDescriptor() : base()
		{
		}

		///<summary>/{index}/_pit</summary>
        public OpenPointInTimeDescriptor(Elastic.Clients.Elasticsearch.Indices index) : base(r => r.Required("index", index))
		{
		}

		public OpenPointInTimeDescriptor KeepAlive(Elastic.Clients.Elasticsearch.Time? keepAlive) => Qs("keep_alive", keepAlive);
	}

	public partial class PingDescriptor : RequestDescriptorBase<PingDescriptor, PingRequestParameters, IPingRequest>, IPingRequest
	{
		internal override ApiUrls ApiUrls => ApiUrlsLookups.NoNamespacePing;
		protected override HttpMethod HttpMethod => HttpMethod.HEAD;
		protected override bool SupportsBody => false;
		///<summary>/</summary>
        public PingDescriptor() : base()
		{
		}
	}

	public partial class PutScriptDescriptor : RequestDescriptorBase<PutScriptDescriptor, PutScriptRequestParameters, IPutScriptRequest>, IPutScriptRequest
	{
		internal override ApiUrls ApiUrls => ApiUrlsLookups.NoNamespacePutScript;
		protected override HttpMethod HttpMethod => HttpMethod.PUT;
		protected override bool SupportsBody => false;
		///<summary>/_scripts/{id}</summary>
        public PutScriptDescriptor(Elastic.Clients.Elasticsearch.Id id) : base(r => r.Required("id", id))
		{
		}

		///<summary>/_scripts/{id}/{context}</summary>
        public PutScriptDescriptor(Elastic.Clients.Elasticsearch.Id id, Elastic.Clients.Elasticsearch.Name? context) : base(r => r.Required("id", id).Optional("context", context))
		{
		}

		Elastic.Clients.Elasticsearch.StoredScript? IPutScriptRequest.Script { get; set; }

		public PutScriptDescriptor MasterTimeout(Elastic.Clients.Elasticsearch.Time? masterTimeout) => Qs("master_timeout", masterTimeout);
		public PutScriptDescriptor Timeout(Elastic.Clients.Elasticsearch.Time? timeout) => Qs("timeout", timeout);
		public PutScriptDescriptor Script(Elastic.Clients.Elasticsearch.StoredScript? script) => Assign(script, (a, v) => a.Script = v);
	}

	public partial class RankEvalDescriptor : RequestDescriptorBase<RankEvalDescriptor, RankEvalRequestParameters, IRankEvalRequest>, IRankEvalRequest
	{
		internal override ApiUrls ApiUrls => ApiUrlsLookups.NoNamespaceRankEval;
		protected override HttpMethod HttpMethod => HttpMethod.POST;
		protected override bool SupportsBody => false;
		///<summary>/_rank_eval</summary>
        public RankEvalDescriptor() : base()
		{
		}

		///<summary>/{index}/_rank_eval</summary>
        public RankEvalDescriptor(Elastic.Clients.Elasticsearch.Indices index) : base(r => r.Required("index", index))
		{
		}

		IEnumerable<Elastic.Clients.Elasticsearch.Global.RankEval.RankEvalRequestItem> IRankEvalRequest.Requests { get; set; }

		Elastic.Clients.Elasticsearch.Global.RankEval.RankEvalMetric? IRankEvalRequest.Metric { get; set; }

		public RankEvalDescriptor AllowNoIndices(bool? allowNoIndices = true) => Qs("allow_no_indices", allowNoIndices);
		public RankEvalDescriptor ExpandWildcards(Elastic.Clients.Elasticsearch.ExpandWildcards? expandWildcards) => Qs("expand_wildcards", expandWildcards);
		public RankEvalDescriptor IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
		public RankEvalDescriptor SearchType(string? searchType) => Qs("search_type", searchType);
		public RankEvalDescriptor Requests(IEnumerable<Elastic.Clients.Elasticsearch.Global.RankEval.RankEvalRequestItem> requests) => Assign(requests, (a, v) => a.Requests = v);
		public RankEvalDescriptor Metric(Elastic.Clients.Elasticsearch.Global.RankEval.RankEvalMetric? metric) => Assign(metric, (a, v) => a.Metric = v);
	}

	public partial class ReindexDescriptor : RequestDescriptorBase<ReindexDescriptor, ReindexRequestParameters, IReindexRequest>, IReindexRequest
	{
		internal override ApiUrls ApiUrls => ApiUrlsLookups.NoNamespaceReindex;
		protected override HttpMethod HttpMethod => HttpMethod.POST;
		protected override bool SupportsBody => false;
		///<summary>/_reindex</summary>
        public ReindexDescriptor() : base()
		{
		}

		Elastic.Clients.Elasticsearch.Conflicts? IReindexRequest.Conflicts { get; set; }

		Elastic.Clients.Elasticsearch.Global.Reindex.Destination? IReindexRequest.Dest { get; set; }

		long? IReindexRequest.MaxDocs { get; set; }

		Elastic.Clients.Elasticsearch.Script? IReindexRequest.Script { get; set; }

		long? IReindexRequest.Size { get; set; }

		Elastic.Clients.Elasticsearch.Global.Reindex.Source? IReindexRequest.Source { get; set; }

		public ReindexDescriptor Refresh(bool? refresh = true) => Qs("refresh", refresh);
		public ReindexDescriptor RequestsPerSecond(long? requestsPerSecond) => Qs("requests_per_second", requestsPerSecond);
		public ReindexDescriptor Scroll(Elastic.Clients.Elasticsearch.Time? scroll) => Qs("scroll", scroll);
		public ReindexDescriptor Slices(long? slices) => Qs("slices", slices);
		public ReindexDescriptor Timeout(Elastic.Clients.Elasticsearch.Time? timeout) => Qs("timeout", timeout);
		public ReindexDescriptor WaitForActiveShards(Elastic.Clients.Elasticsearch.WaitForActiveShards? waitForActiveShards) => Qs("wait_for_active_shards", waitForActiveShards);
		public ReindexDescriptor WaitForCompletion(bool? waitForCompletion = true) => Qs("wait_for_completion", waitForCompletion);
		public ReindexDescriptor RequireAlias(bool? requireAlias = true) => Qs("require_alias", requireAlias);
		public ReindexDescriptor Conflicts(Elastic.Clients.Elasticsearch.Conflicts? conflicts) => Assign(conflicts, (a, v) => a.Conflicts = v);
		public ReindexDescriptor Dest(Elastic.Clients.Elasticsearch.Global.Reindex.Destination? dest) => Assign(dest, (a, v) => a.Dest = v);
		public ReindexDescriptor MaxDocs(long? maxDocs) => Assign(maxDocs, (a, v) => a.MaxDocs = v);
		public ReindexDescriptor Script(Elastic.Clients.Elasticsearch.Script? script) => Assign(script, (a, v) => a.Script = v);
		public ReindexDescriptor Size(long? size) => Assign(size, (a, v) => a.Size = v);
		public ReindexDescriptor Source(Elastic.Clients.Elasticsearch.Global.Reindex.Source? source) => Assign(source, (a, v) => a.Source = v);
	}

	public partial class ReindexRethrottleDescriptor : RequestDescriptorBase<ReindexRethrottleDescriptor, ReindexRethrottleRequestParameters, IReindexRethrottleRequest>, IReindexRethrottleRequest
	{
		internal override ApiUrls ApiUrls => ApiUrlsLookups.NoNamespaceReindexRethrottle;
		protected override HttpMethod HttpMethod => HttpMethod.POST;
		protected override bool SupportsBody => false;
		///<summary>/_reindex/{task_id}/_rethrottle</summary>
        public ReindexRethrottleDescriptor(Elastic.Clients.Elasticsearch.Id task_id) : base(r => r.Required("task_id", task_id))
		{
		}

		public ReindexRethrottleDescriptor RequestsPerSecond(long? requestsPerSecond) => Qs("requests_per_second", requestsPerSecond);
	}

	public partial class RenderSearchTemplateDescriptor : RequestDescriptorBase<RenderSearchTemplateDescriptor, RenderSearchTemplateRequestParameters, IRenderSearchTemplateRequest>, IRenderSearchTemplateRequest
	{
		internal override ApiUrls ApiUrls => ApiUrlsLookups.NoNamespaceRenderSearchTemplate;
		protected override HttpMethod HttpMethod => HttpMethod.POST;
		protected override bool SupportsBody => false;
		///<summary>/_render/template</summary>
        public RenderSearchTemplateDescriptor() : base()
		{
		}

		///<summary>/_render/template/{id}</summary>
        public RenderSearchTemplateDescriptor(Elastic.Clients.Elasticsearch.Id? id) : base(r => r.Optional("id", id))
		{
		}

		string? IRenderSearchTemplateRequest.File { get; set; }

		Dictionary<string, object>? IRenderSearchTemplateRequest.Params { get; set; }

		string? IRenderSearchTemplateRequest.Source { get; set; }

		public RenderSearchTemplateDescriptor File(string? file) => Assign(file, (a, v) => a.File = v);
		public RenderSearchTemplateDescriptor Params(Dictionary<string, object>? parameters) => Assign(parameters, (a, v) => a.Params = v);
		public RenderSearchTemplateDescriptor Source(string? source) => Assign(source, (a, v) => a.Source = v);
	}

	public partial class ScriptsPainlessExecuteDescriptor : RequestDescriptorBase<ScriptsPainlessExecuteDescriptor, ScriptsPainlessExecuteRequestParameters, IScriptsPainlessExecuteRequest>, IScriptsPainlessExecuteRequest
	{
		internal override ApiUrls ApiUrls => ApiUrlsLookups.NoNamespaceScriptsPainlessExecute;
		protected override HttpMethod HttpMethod => HttpMethod.POST;
		protected override bool SupportsBody => false;
		///<summary>/_scripts/painless/_execute</summary>
        public ScriptsPainlessExecuteDescriptor() : base()
		{
		}

		string? IScriptsPainlessExecuteRequest.Context { get; set; }

		Elastic.Clients.Elasticsearch.Global.ScriptsPainlessExecute.PainlessContextSetup? IScriptsPainlessExecuteRequest.ContextSetup { get; set; }

		Elastic.Clients.Elasticsearch.InlineScript? IScriptsPainlessExecuteRequest.Script { get; set; }

		public ScriptsPainlessExecuteDescriptor Context(string? context) => Assign(context, (a, v) => a.Context = v);
		public ScriptsPainlessExecuteDescriptor ContextSetup(Elastic.Clients.Elasticsearch.Global.ScriptsPainlessExecute.PainlessContextSetup? contextSetup) => Assign(contextSetup, (a, v) => a.ContextSetup = v);
		public ScriptsPainlessExecuteDescriptor Script(Elastic.Clients.Elasticsearch.InlineScript? script) => Assign(script, (a, v) => a.Script = v);
	}

	public partial class ScrollDescriptor : RequestDescriptorBase<ScrollDescriptor, ScrollRequestParameters, IScrollRequest>, IScrollRequest
	{
		internal override ApiUrls ApiUrls => ApiUrlsLookups.NoNamespaceScroll;
		protected override HttpMethod HttpMethod => HttpMethod.POST;
		protected override bool SupportsBody => false;
		///<summary>/_search/scroll</summary>
        public ScrollDescriptor() : base()
		{
		}

		public ScrollDescriptor Scroll(Elastic.Clients.Elasticsearch.Time? scroll) => Qs("scroll", scroll);
		public ScrollDescriptor ScrollId(Elastic.Clients.Elasticsearch.ScrollId? scrollId) => Qs("scroll_id", scrollId);
		public ScrollDescriptor RestTotalHitsAsInt(bool? restTotalHitsAsInt = true) => Qs("rest_total_hits_as_int", restTotalHitsAsInt);
		public ScrollDescriptor TotalHitsAsInteger(bool? totalHitsAsInteger = true) => Qs("total_hits_as_integer", totalHitsAsInteger);
	}

	public partial class SearchDescriptor : RequestDescriptorBase<SearchDescriptor, SearchRequestParameters, ISearchRequest>, ISearchRequest
	{
		internal override ApiUrls ApiUrls => ApiUrlsLookups.NoNamespaceSearch;
		protected override HttpMethod HttpMethod => HttpMethod.POST;
		protected override bool SupportsBody => false;
		///<summary>/_search</summary>
        public SearchDescriptor() : base()
		{
		}

		///<summary>/{index}/_search</summary>
        public SearchDescriptor(Elastic.Clients.Elasticsearch.Indices? index) : base(r => r.Optional("index", index))
		{
		}

		Dictionary<string, Elastic.Clients.Elasticsearch.Aggregations.AggregationContainer>? ISearchRequest.Aggs { get; set; }

		Dictionary<string, Elastic.Clients.Elasticsearch.Aggregations.AggregationContainer>? ISearchRequest.Aggregations { get; set; }

		Elastic.Clients.Elasticsearch.Global.Search.FieldCollapse? ISearchRequest.Collapse { get; set; }

		Elastic.Clients.Elasticsearch.Global.Search.Highlight? ISearchRequest.Highlight { get; set; }

		IEnumerable<Dictionary<Elastic.Clients.Elasticsearch.IndexName, double>>? ISearchRequest.IndicesBoost { get; set; }

		double? ISearchRequest.MinScore { get; set; }

		Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? ISearchRequest.PostFilter { get; set; }

		bool? ISearchRequest.Profile { get; set; }

		Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? ISearchRequest.Query { get; set; }

		Union<Elastic.Clients.Elasticsearch.Global.Search.Rescore, IEnumerable<Elastic.Clients.Elasticsearch.Global.Search.Rescore>>? ISearchRequest.Rescore { get; set; }

		Dictionary<string, Elastic.Clients.Elasticsearch.ScriptField>? ISearchRequest.ScriptFields { get; set; }

		Elastic.Clients.Elasticsearch.Global.Search.SortResults? ISearchRequest.SearchAfter { get; set; }

		Elastic.Clients.Elasticsearch.SlicedScroll? ISearchRequest.Slice { get; set; }

		IEnumerable<Union<Elastic.Clients.Elasticsearch.Field, Elastic.Clients.Elasticsearch.DateField>>? ISearchRequest.Fields { get; set; }

		Union<Elastic.Clients.Elasticsearch.Global.Search.SuggestContainer, Dictionary<string, Elastic.Clients.Elasticsearch.Global.Search.SuggestContainer>>? ISearchRequest.Suggest { get; set; }

		Elastic.Clients.Elasticsearch.Global.Search.PointInTimeReference? ISearchRequest.Pit { get; set; }

		Elastic.Clients.Elasticsearch.Mapping.RuntimeFields? ISearchRequest.RuntimeMappings { get; set; }

		public SearchDescriptor AllowNoIndices(bool? allowNoIndices = true) => Qs("allow_no_indices", allowNoIndices);
		public SearchDescriptor AllowPartialSearchResults(bool? allowPartialSearchResults = true) => Qs("allow_partial_search_results", allowPartialSearchResults);
		public SearchDescriptor Analyzer(string? analyzer) => Qs("analyzer", analyzer);
		public SearchDescriptor AnalyzeWildcard(bool? analyzeWildcard = true) => Qs("analyze_wildcard", analyzeWildcard);
		public SearchDescriptor BatchedReduceSize(long? batchedReduceSize) => Qs("batched_reduce_size", batchedReduceSize);
		public SearchDescriptor CcsMinimizeRoundtrips(bool? ccsMinimizeRoundtrips = true) => Qs("ccs_minimize_roundtrips", ccsMinimizeRoundtrips);
		public SearchDescriptor DefaultOperator(Elastic.Clients.Elasticsearch.DefaultOperator? defaultOperator) => Qs("default_operator", defaultOperator);
		public SearchDescriptor Df(string? df) => Qs("df", df);
		public SearchDescriptor DocvalueFields(Elastic.Clients.Elasticsearch.Fields? docvalueFields) => Qs("docvalue_fields", docvalueFields);
		public SearchDescriptor ExpandWildcards(Elastic.Clients.Elasticsearch.ExpandWildcards? expandWildcards) => Qs("expand_wildcards", expandWildcards);
		public SearchDescriptor Explain(bool? explain = true) => Qs("explain", explain);
		public SearchDescriptor IgnoreThrottled(bool? ignoreThrottled = true) => Qs("ignore_throttled", ignoreThrottled);
		public SearchDescriptor IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
		public SearchDescriptor Lenient(bool? lenient = true) => Qs("lenient", lenient);
		public SearchDescriptor MaxConcurrentShardRequests(long? maxConcurrentShardRequests) => Qs("max_concurrent_shard_requests", maxConcurrentShardRequests);
		public SearchDescriptor MinCompatibleShardNode(Elastic.Clients.Elasticsearch.VersionString? minCompatibleShardNode) => Qs("min_compatible_shard_node", minCompatibleShardNode);
		public SearchDescriptor Preference(string? preference) => Qs("preference", preference);
		public SearchDescriptor PreFilterShardSize(long? preFilterShardSize) => Qs("pre_filter_shard_size", preFilterShardSize);
		public SearchDescriptor RequestCache(bool? requestCache = true) => Qs("request_cache", requestCache);
		public SearchDescriptor Routing(Elastic.Clients.Elasticsearch.Routing? routing) => Qs("routing", routing);
		public SearchDescriptor Scroll(Elastic.Clients.Elasticsearch.Time? scroll) => Qs("scroll", scroll);
		public SearchDescriptor SearchType(Elastic.Clients.Elasticsearch.SearchType? searchType) => Qs("search_type", searchType);
		public SearchDescriptor Stats(IEnumerable<string>? stats) => Qs("stats", stats);
		public SearchDescriptor StoredFields(Elastic.Clients.Elasticsearch.Fields? storedFields) => Qs("stored_fields", storedFields);
		public SearchDescriptor SuggestField(Elastic.Clients.Elasticsearch.Field? suggestField) => Qs("suggest_field", suggestField);
		public SearchDescriptor SuggestMode(Elastic.Clients.Elasticsearch.SuggestMode? suggestMode) => Qs("suggest_mode", suggestMode);
		public SearchDescriptor SuggestSize(long? suggestSize) => Qs("suggest_size", suggestSize);
		public SearchDescriptor SuggestText(string? suggestText) => Qs("suggest_text", suggestText);
		public SearchDescriptor TerminateAfter(long? terminateAfter) => Qs("terminate_after", terminateAfter);
		public SearchDescriptor Timeout(Elastic.Clients.Elasticsearch.Time? timeout) => Qs("timeout", timeout);
		public SearchDescriptor TrackTotalHits(Union<bool, int>? trackTotalHits) => Qs("track_total_hits", trackTotalHits);
		public SearchDescriptor TrackScores(bool? trackScores = true) => Qs("track_scores", trackScores);
		public SearchDescriptor TypedKeys(bool? typedKeys = true) => Qs("typed_keys", typedKeys);
		public SearchDescriptor RestTotalHitsAsInt(bool? restTotalHitsAsInt = true) => Qs("rest_total_hits_as_int", restTotalHitsAsInt);
		public SearchDescriptor Version(bool? version = true) => Qs("version", version);
		public SearchDescriptor Source(Union<bool, Elastic.Clients.Elasticsearch.Fields>? source) => Qs("_source", source);
		public SearchDescriptor SourceExcludes(Elastic.Clients.Elasticsearch.Fields? sourceExcludes) => Qs("_source_excludes", sourceExcludes);
		public SearchDescriptor SourceIncludes(Elastic.Clients.Elasticsearch.Fields? sourceIncludes) => Qs("_source_includes", sourceIncludes);
		public SearchDescriptor SeqNoPrimaryTerm(bool? seqNoPrimaryTerm = true) => Qs("seq_no_primary_term", seqNoPrimaryTerm);
		public SearchDescriptor LuceneQueryString(string? luceneQueryString) => Qs("q", luceneQueryString);
		public SearchDescriptor Size(int? size) => Qs("size", size);
		public SearchDescriptor From(int? from) => Qs("from", from);
		public SearchDescriptor Sort(Union<string, IEnumerable<string>>? sort) => Qs("sort", sort);
		public SearchDescriptor Aggs(Dictionary<string, Elastic.Clients.Elasticsearch.Aggregations.AggregationContainer>? aggs) => Assign(aggs, (a, v) => a.Aggs = v);
		public SearchDescriptor Aggregations(Dictionary<string, Elastic.Clients.Elasticsearch.Aggregations.AggregationContainer>? aggregations) => Assign(aggregations, (a, v) => a.Aggregations = v);
		public SearchDescriptor Collapse(Elastic.Clients.Elasticsearch.Global.Search.FieldCollapse? collapse) => Assign(collapse, (a, v) => a.Collapse = v);
		public SearchDescriptor Highlight(Elastic.Clients.Elasticsearch.Global.Search.Highlight? highlight) => Assign(highlight, (a, v) => a.Highlight = v);
		public SearchDescriptor IndicesBoost(IEnumerable<Dictionary<Elastic.Clients.Elasticsearch.IndexName, double>>? indicesBoost) => Assign(indicesBoost, (a, v) => a.IndicesBoost = v);
		public SearchDescriptor MinScore(double? minScore) => Assign(minScore, (a, v) => a.MinScore = v);
		public SearchDescriptor PostFilter(Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? postFilter) => Assign(postFilter, (a, v) => a.PostFilter = v);
		public SearchDescriptor Profile(bool? profile = true) => Assign(profile, (a, v) => a.Profile = v);
		public SearchDescriptor Query(Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? query) => Assign(query, (a, v) => a.Query = v);
		public SearchDescriptor Rescore(Union<Elastic.Clients.Elasticsearch.Global.Search.Rescore, IEnumerable<Elastic.Clients.Elasticsearch.Global.Search.Rescore>>? rescore) => Assign(rescore, (a, v) => a.Rescore = v);
		public SearchDescriptor ScriptFields(Dictionary<string, Elastic.Clients.Elasticsearch.ScriptField>? scriptFields) => Assign(scriptFields, (a, v) => a.ScriptFields = v);
		public SearchDescriptor SearchAfter(Elastic.Clients.Elasticsearch.Global.Search.SortResults? searchAfter) => Assign(searchAfter, (a, v) => a.SearchAfter = v);
		public SearchDescriptor Slice(Elastic.Clients.Elasticsearch.SlicedScroll? slice) => Assign(slice, (a, v) => a.Slice = v);
		public SearchDescriptor Fields(IEnumerable<Union<Elastic.Clients.Elasticsearch.Field, Elastic.Clients.Elasticsearch.DateField>>? fields) => Assign(fields, (a, v) => a.Fields = v);
		public SearchDescriptor Suggest(Union<Elastic.Clients.Elasticsearch.Global.Search.SuggestContainer, Dictionary<string, Elastic.Clients.Elasticsearch.Global.Search.SuggestContainer>>? suggest) => Assign(suggest, (a, v) => a.Suggest = v);
		public SearchDescriptor Pit(Elastic.Clients.Elasticsearch.Global.Search.PointInTimeReference? pit) => Assign(pit, (a, v) => a.Pit = v);
		public SearchDescriptor RuntimeMappings(Elastic.Clients.Elasticsearch.Mapping.RuntimeFields? runtimeMappings) => Assign(runtimeMappings, (a, v) => a.RuntimeMappings = v);
	}

	public partial class SearchShardsDescriptor : RequestDescriptorBase<SearchShardsDescriptor, SearchShardsRequestParameters, ISearchShardsRequest>, ISearchShardsRequest
	{
		internal override ApiUrls ApiUrls => ApiUrlsLookups.NoNamespaceSearchShards;
		protected override HttpMethod HttpMethod => HttpMethod.POST;
		protected override bool SupportsBody => false;
		///<summary>/_search_shards</summary>
        public SearchShardsDescriptor() : base()
		{
		}

		///<summary>/{index}/_search_shards</summary>
        public SearchShardsDescriptor(Elastic.Clients.Elasticsearch.Indices? index) : base(r => r.Optional("index", index))
		{
		}

		public SearchShardsDescriptor AllowNoIndices(bool? allowNoIndices = true) => Qs("allow_no_indices", allowNoIndices);
		public SearchShardsDescriptor ExpandWildcards(Elastic.Clients.Elasticsearch.ExpandWildcards? expandWildcards) => Qs("expand_wildcards", expandWildcards);
		public SearchShardsDescriptor IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
		public SearchShardsDescriptor Local(bool? local = true) => Qs("local", local);
		public SearchShardsDescriptor Preference(string? preference) => Qs("preference", preference);
		public SearchShardsDescriptor Routing(Elastic.Clients.Elasticsearch.Routing? routing) => Qs("routing", routing);
	}

	public partial class SearchTemplateDescriptor : RequestDescriptorBase<SearchTemplateDescriptor, SearchTemplateRequestParameters, ISearchTemplateRequest>, ISearchTemplateRequest
	{
		internal override ApiUrls ApiUrls => ApiUrlsLookups.NoNamespaceSearchTemplate;
		protected override HttpMethod HttpMethod => HttpMethod.POST;
		protected override bool SupportsBody => false;
		///<summary>/_search/template</summary>
        public SearchTemplateDescriptor() : base()
		{
		}

		///<summary>/{index}/_search/template</summary>
        public SearchTemplateDescriptor(Elastic.Clients.Elasticsearch.Indices? index) : base(r => r.Optional("index", index))
		{
		}

		Elastic.Clients.Elasticsearch.Id? ISearchTemplateRequest.Id { get; set; }

		Dictionary<string, object>? ISearchTemplateRequest.Params { get; set; }

		string? ISearchTemplateRequest.Source { get; set; }

		public SearchTemplateDescriptor AllowNoIndices(bool? allowNoIndices = true) => Qs("allow_no_indices", allowNoIndices);
		public SearchTemplateDescriptor CcsMinimizeRoundtrips(bool? ccsMinimizeRoundtrips = true) => Qs("ccs_minimize_roundtrips", ccsMinimizeRoundtrips);
		public SearchTemplateDescriptor ExpandWildcards(Elastic.Clients.Elasticsearch.ExpandWildcards? expandWildcards) => Qs("expand_wildcards", expandWildcards);
		public SearchTemplateDescriptor Explain(bool? explain = true) => Qs("explain", explain);
		public SearchTemplateDescriptor IgnoreThrottled(bool? ignoreThrottled = true) => Qs("ignore_throttled", ignoreThrottled);
		public SearchTemplateDescriptor IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
		public SearchTemplateDescriptor Preference(string? preference) => Qs("preference", preference);
		public SearchTemplateDescriptor Profile(bool? profile = true) => Qs("profile", profile);
		public SearchTemplateDescriptor Routing(Elastic.Clients.Elasticsearch.Routing? routing) => Qs("routing", routing);
		public SearchTemplateDescriptor Scroll(Elastic.Clients.Elasticsearch.Time? scroll) => Qs("scroll", scroll);
		public SearchTemplateDescriptor SearchType(Elastic.Clients.Elasticsearch.SearchType? searchType) => Qs("search_type", searchType);
		public SearchTemplateDescriptor TotalHitsAsInteger(bool? totalHitsAsInteger = true) => Qs("total_hits_as_integer", totalHitsAsInteger);
		public SearchTemplateDescriptor TypedKeys(bool? typedKeys = true) => Qs("typed_keys", typedKeys);
		public SearchTemplateDescriptor Id(Elastic.Clients.Elasticsearch.Id? id) => Assign(id, (a, v) => a.Id = v);
		public SearchTemplateDescriptor Params(Dictionary<string, object>? parameters) => Assign(parameters, (a, v) => a.Params = v);
		public SearchTemplateDescriptor Source(string? source) => Assign(source, (a, v) => a.Source = v);
	}

	public partial class TermsEnumDescriptor : RequestDescriptorBase<TermsEnumDescriptor, TermsEnumRequestParameters, ITermsEnumRequest>, ITermsEnumRequest
	{
		internal override ApiUrls ApiUrls => ApiUrlsLookups.NoNamespaceTermsEnum;
		protected override HttpMethod HttpMethod => HttpMethod.POST;
		protected override bool SupportsBody => false;
		///<summary>/{index}/_terms_enum</summary>
        public TermsEnumDescriptor(Elastic.Clients.Elasticsearch.IndexName index) : base(r => r.Required("index", index))
		{
		}

		Elastic.Clients.Elasticsearch.Field ITermsEnumRequest.Field { get; set; }

		int? ITermsEnumRequest.Size { get; set; }

		Elastic.Clients.Elasticsearch.Time? ITermsEnumRequest.Timeout { get; set; }

		bool? ITermsEnumRequest.CaseInsensitive { get; set; }

		Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? ITermsEnumRequest.IndexFilter { get; set; }

		string? ITermsEnumRequest.String { get; set; }

		string? ITermsEnumRequest.SearchAfter { get; set; }

		public TermsEnumDescriptor Field(Elastic.Clients.Elasticsearch.Field field) => Assign(field, (a, v) => a.Field = v);
		public TermsEnumDescriptor Size(int? size) => Assign(size, (a, v) => a.Size = v);
		public TermsEnumDescriptor Timeout(Elastic.Clients.Elasticsearch.Time? timeout) => Assign(timeout, (a, v) => a.Timeout = v);
		public TermsEnumDescriptor CaseInsensitive(bool? caseInsensitive = true) => Assign(caseInsensitive, (a, v) => a.CaseInsensitive = v);
		public TermsEnumDescriptor IndexFilter(Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? indexFilter) => Assign(indexFilter, (a, v) => a.IndexFilter = v);
		public TermsEnumDescriptor String(string? value) => Assign(value, (a, v) => a.String = v);
		public TermsEnumDescriptor SearchAfter(string? searchAfter) => Assign(searchAfter, (a, v) => a.SearchAfter = v);
	}

	public partial class TermvectorsDescriptor<TDocument> : RequestDescriptorBase<TermvectorsDescriptor<TDocument>, TermvectorsRequestParameters, ITermvectorsRequest<TDocument>>, ITermvectorsRequest<TDocument>
	{
		internal override ApiUrls ApiUrls => ApiUrlsLookups.NoNamespaceTermvectors;
		protected override HttpMethod HttpMethod => HttpMethod.POST;
		protected override bool SupportsBody => false;
		///<summary>/{index}/_termvectors/{id}</summary>
        public TermvectorsDescriptor(Elastic.Clients.Elasticsearch.IndexName index, Elastic.Clients.Elasticsearch.Id? id) : base(r => r.Required("index", index).Optional("id", id))
		{
		}

		///<summary>/{index}/_termvectors</summary>
        public TermvectorsDescriptor(Elastic.Clients.Elasticsearch.IndexName index) : base(r => r.Required("index", index))
		{
		}

		TDocument? ITermvectorsRequest<TDocument>.Doc { get; set; }

		Elastic.Clients.Elasticsearch.Global.Termvectors.Filter? ITermvectorsRequest<TDocument>.Filter { get; set; }

		Dictionary<Elastic.Clients.Elasticsearch.Field, string>? ITermvectorsRequest<TDocument>.PerFieldAnalyzer { get; set; }

		public TermvectorsDescriptor<TDocument> Fields(Elastic.Clients.Elasticsearch.Fields? fields) => Qs("fields", fields);
		public TermvectorsDescriptor<TDocument> FieldStatistics(bool? fieldStatistics = true) => Qs("field_statistics", fieldStatistics);
		public TermvectorsDescriptor<TDocument> Offsets(bool? offsets = true) => Qs("offsets", offsets);
		public TermvectorsDescriptor<TDocument> Payloads(bool? payloads = true) => Qs("payloads", payloads);
		public TermvectorsDescriptor<TDocument> Positions(bool? positions = true) => Qs("positions", positions);
		public TermvectorsDescriptor<TDocument> Preference(string? preference) => Qs("preference", preference);
		public TermvectorsDescriptor<TDocument> Realtime(bool? realtime = true) => Qs("realtime", realtime);
		public TermvectorsDescriptor<TDocument> Routing(Elastic.Clients.Elasticsearch.Routing? routing) => Qs("routing", routing);
		public TermvectorsDescriptor<TDocument> TermStatistics(bool? termStatistics = true) => Qs("term_statistics", termStatistics);
		public TermvectorsDescriptor<TDocument> Version(Elastic.Clients.Elasticsearch.VersionNumber? version) => Qs("version", version);
		public TermvectorsDescriptor<TDocument> VersionType(Elastic.Clients.Elasticsearch.VersionType? versionType) => Qs("version_type", versionType);
		public TermvectorsDescriptor<TDocument> Doc(TDocument? doc) => Assign(doc, (a, v) => a.Doc = v);
		public TermvectorsDescriptor<TDocument> Filter(Elastic.Clients.Elasticsearch.Global.Termvectors.Filter? filter) => Assign(filter, (a, v) => a.Filter = v);
		public TermvectorsDescriptor<TDocument> PerFieldAnalyzer(Dictionary<Elastic.Clients.Elasticsearch.Field, string>? perFieldAnalyzer) => Assign(perFieldAnalyzer, (a, v) => a.PerFieldAnalyzer = v);
	}

	public partial class UpdateDescriptor<TDocument, TPartialDocument> : RequestDescriptorBase<UpdateDescriptor<TDocument, TPartialDocument>, UpdateRequestParameters, IUpdateRequest<TDocument,TPartialDocument>>, IUpdateRequest<TDocument,TPartialDocument>
	{
		internal override ApiUrls ApiUrls => ApiUrlsLookups.NoNamespaceUpdate;
		protected override HttpMethod HttpMethod => HttpMethod.POST;
		protected override bool SupportsBody => false;
		///<summary>/{index}/_update/{id}</summary>
        public UpdateDescriptor(Elastic.Clients.Elasticsearch.IndexName index, Elastic.Clients.Elasticsearch.Id id) : base(r => r.Required("index", index).Required("id", id))
		{
		}

		bool? IUpdateRequest<TDocument,TPartialDocument>.DetectNoop { get; set; }

		TPartialDocument? IUpdateRequest<TDocument,TPartialDocument>.Doc { get; set; }

		bool? IUpdateRequest<TDocument,TPartialDocument>.DocAsUpsert { get; set; }

		Elastic.Clients.Elasticsearch.Script? IUpdateRequest<TDocument,TPartialDocument>.Script { get; set; }

		bool? IUpdateRequest<TDocument,TPartialDocument>.ScriptedUpsert { get; set; }

		TDocument? IUpdateRequest<TDocument,TPartialDocument>.Upsert { get; set; }

		public UpdateDescriptor<TDocument, TPartialDocument> IfPrimaryTerm(long? ifPrimaryTerm) => Qs("if_primary_term", ifPrimaryTerm);
		public UpdateDescriptor<TDocument, TPartialDocument> IfSeqNo(Elastic.Clients.Elasticsearch.SequenceNumber? ifSeqNo) => Qs("if_seq_no", ifSeqNo);
		public UpdateDescriptor<TDocument, TPartialDocument> Lang(string? lang) => Qs("lang", lang);
		public UpdateDescriptor<TDocument, TPartialDocument> Refresh(Elastic.Clients.Elasticsearch.Refresh? refresh) => Qs("refresh", refresh);
		public UpdateDescriptor<TDocument, TPartialDocument> RequireAlias(bool? requireAlias = true) => Qs("require_alias", requireAlias);
		public UpdateDescriptor<TDocument, TPartialDocument> RetryOnConflict(long? retryOnConflict) => Qs("retry_on_conflict", retryOnConflict);
		public UpdateDescriptor<TDocument, TPartialDocument> Routing(Elastic.Clients.Elasticsearch.Routing? routing) => Qs("routing", routing);
		public UpdateDescriptor<TDocument, TPartialDocument> Timeout(Elastic.Clients.Elasticsearch.Time? timeout) => Qs("timeout", timeout);
		public UpdateDescriptor<TDocument, TPartialDocument> WaitForActiveShards(Elastic.Clients.Elasticsearch.WaitForActiveShards? waitForActiveShards) => Qs("wait_for_active_shards", waitForActiveShards);
		public UpdateDescriptor<TDocument, TPartialDocument> Source(Union<bool, Elastic.Clients.Elasticsearch.Fields>? source) => Qs("_source", source);
		public UpdateDescriptor<TDocument, TPartialDocument> SourceExcludes(Elastic.Clients.Elasticsearch.Fields? sourceExcludes) => Qs("_source_excludes", sourceExcludes);
		public UpdateDescriptor<TDocument, TPartialDocument> SourceIncludes(Elastic.Clients.Elasticsearch.Fields? sourceIncludes) => Qs("_source_includes", sourceIncludes);
		public UpdateDescriptor<TDocument, TPartialDocument> DetectNoop(bool? detectNoop = true) => Assign(detectNoop, (a, v) => a.DetectNoop = v);
		public UpdateDescriptor<TDocument, TPartialDocument> Doc(TPartialDocument? doc) => Assign(doc, (a, v) => a.Doc = v);
		public UpdateDescriptor<TDocument, TPartialDocument> DocAsUpsert(bool? docAsUpsert = true) => Assign(docAsUpsert, (a, v) => a.DocAsUpsert = v);
		public UpdateDescriptor<TDocument, TPartialDocument> Script(Elastic.Clients.Elasticsearch.Script? script) => Assign(script, (a, v) => a.Script = v);
		public UpdateDescriptor<TDocument, TPartialDocument> ScriptedUpsert(bool? scriptedUpsert = true) => Assign(scriptedUpsert, (a, v) => a.ScriptedUpsert = v);
		public UpdateDescriptor<TDocument, TPartialDocument> Upsert(TDocument? upsert) => Assign(upsert, (a, v) => a.Upsert = v);
	}

	public partial class UpdateByQueryDescriptor : RequestDescriptorBase<UpdateByQueryDescriptor, UpdateByQueryRequestParameters, IUpdateByQueryRequest>, IUpdateByQueryRequest
	{
		internal override ApiUrls ApiUrls => ApiUrlsLookups.NoNamespaceUpdateByQuery;
		protected override HttpMethod HttpMethod => HttpMethod.POST;
		protected override bool SupportsBody => false;
		///<summary>/{index}/_update_by_query</summary>
        public UpdateByQueryDescriptor(Elastic.Clients.Elasticsearch.Indices index) : base(r => r.Required("index", index))
		{
		}

		long? IUpdateByQueryRequest.MaxDocs { get; set; }

		Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? IUpdateByQueryRequest.Query { get; set; }

		Elastic.Clients.Elasticsearch.Script? IUpdateByQueryRequest.Script { get; set; }

		Elastic.Clients.Elasticsearch.SlicedScroll? IUpdateByQueryRequest.Slice { get; set; }

		public UpdateByQueryDescriptor AllowNoIndices(bool? allowNoIndices = true) => Qs("allow_no_indices", allowNoIndices);
		public UpdateByQueryDescriptor Analyzer(string? analyzer) => Qs("analyzer", analyzer);
		public UpdateByQueryDescriptor AnalyzeWildcard(bool? analyzeWildcard = true) => Qs("analyze_wildcard", analyzeWildcard);
		public UpdateByQueryDescriptor Conflicts(Elastic.Clients.Elasticsearch.Conflicts? conflicts) => Qs("conflicts", conflicts);
		public UpdateByQueryDescriptor DefaultOperator(Elastic.Clients.Elasticsearch.DefaultOperator? defaultOperator) => Qs("default_operator", defaultOperator);
		public UpdateByQueryDescriptor Df(string? df) => Qs("df", df);
		public UpdateByQueryDescriptor ExpandWildcards(Elastic.Clients.Elasticsearch.ExpandWildcards? expandWildcards) => Qs("expand_wildcards", expandWildcards);
		public UpdateByQueryDescriptor From(long? from) => Qs("from", from);
		public UpdateByQueryDescriptor IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
		public UpdateByQueryDescriptor Lenient(bool? lenient = true) => Qs("lenient", lenient);
		public UpdateByQueryDescriptor Pipeline(string? pipeline) => Qs("pipeline", pipeline);
		public UpdateByQueryDescriptor Preference(string? preference) => Qs("preference", preference);
		public UpdateByQueryDescriptor QueryOnQueryString(string? queryOnQueryString) => Qs("query_on_query_string", queryOnQueryString);
		public UpdateByQueryDescriptor Refresh(bool? refresh = true) => Qs("refresh", refresh);
		public UpdateByQueryDescriptor RequestCache(bool? requestCache = true) => Qs("request_cache", requestCache);
		public UpdateByQueryDescriptor RequestsPerSecond(long? requestsPerSecond) => Qs("requests_per_second", requestsPerSecond);
		public UpdateByQueryDescriptor Routing(Elastic.Clients.Elasticsearch.Routing? routing) => Qs("routing", routing);
		public UpdateByQueryDescriptor Scroll(Elastic.Clients.Elasticsearch.Time? scroll) => Qs("scroll", scroll);
		public UpdateByQueryDescriptor ScrollSize(long? scrollSize) => Qs("scroll_size", scrollSize);
		public UpdateByQueryDescriptor SearchTimeout(Elastic.Clients.Elasticsearch.Time? searchTimeout) => Qs("search_timeout", searchTimeout);
		public UpdateByQueryDescriptor SearchType(Elastic.Clients.Elasticsearch.SearchType? searchType) => Qs("search_type", searchType);
		public UpdateByQueryDescriptor Size(long? size) => Qs("size", size);
		public UpdateByQueryDescriptor Slices(long? slices) => Qs("slices", slices);
		public UpdateByQueryDescriptor Sort(IEnumerable<string>? sort) => Qs("sort", sort);
		public UpdateByQueryDescriptor Source(Union<bool, Elastic.Clients.Elasticsearch.Fields>? source) => Qs("_source", source);
		public UpdateByQueryDescriptor SourceExcludes(Elastic.Clients.Elasticsearch.Fields? sourceExcludes) => Qs("_source_excludes", sourceExcludes);
		public UpdateByQueryDescriptor SourceIncludes(Elastic.Clients.Elasticsearch.Fields? sourceIncludes) => Qs("_source_includes", sourceIncludes);
		public UpdateByQueryDescriptor Stats(IEnumerable<string>? stats) => Qs("stats", stats);
		public UpdateByQueryDescriptor TerminateAfter(long? terminateAfter) => Qs("terminate_after", terminateAfter);
		public UpdateByQueryDescriptor Timeout(Elastic.Clients.Elasticsearch.Time? timeout) => Qs("timeout", timeout);
		public UpdateByQueryDescriptor Version(bool? version = true) => Qs("version", version);
		public UpdateByQueryDescriptor VersionType(bool? versionType = true) => Qs("version_type", versionType);
		public UpdateByQueryDescriptor WaitForActiveShards(Elastic.Clients.Elasticsearch.WaitForActiveShards? waitForActiveShards) => Qs("wait_for_active_shards", waitForActiveShards);
		public UpdateByQueryDescriptor WaitForCompletion(bool? waitForCompletion = true) => Qs("wait_for_completion", waitForCompletion);
		public UpdateByQueryDescriptor MaxDocs(long? maxDocs) => Assign(maxDocs, (a, v) => a.MaxDocs = v);
		public UpdateByQueryDescriptor Query(Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? query) => Assign(query, (a, v) => a.Query = v);
		public UpdateByQueryDescriptor Script(Elastic.Clients.Elasticsearch.Script? script) => Assign(script, (a, v) => a.Script = v);
		public UpdateByQueryDescriptor Slice(Elastic.Clients.Elasticsearch.SlicedScroll? slice) => Assign(slice, (a, v) => a.Slice = v);
	}

	public partial class UpdateByQueryRethrottleDescriptor : RequestDescriptorBase<UpdateByQueryRethrottleDescriptor, UpdateByQueryRethrottleRequestParameters, IUpdateByQueryRethrottleRequest>, IUpdateByQueryRethrottleRequest
	{
		internal override ApiUrls ApiUrls => ApiUrlsLookups.NoNamespaceUpdateByQueryRethrottle;
		protected override HttpMethod HttpMethod => HttpMethod.POST;
		protected override bool SupportsBody => false;
		///<summary>/_update_by_query/{task_id}/_rethrottle</summary>
        public UpdateByQueryRethrottleDescriptor(Elastic.Clients.Elasticsearch.Id task_id) : base(r => r.Required("task_id", task_id))
		{
		}

		public UpdateByQueryRethrottleDescriptor RequestsPerSecond(long? requestsPerSecond) => Qs("requests_per_second", requestsPerSecond);
	}
}