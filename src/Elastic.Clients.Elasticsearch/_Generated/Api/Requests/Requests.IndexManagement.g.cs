// Licensed to Elasticsearch B.V under one or more agreements.
// Elasticsearch B.V licenses this file to you under the Apache 2.0 License.
// See the LICENSE file in the project root for more information.
//
// ███╗   ██╗ ██████╗ ████████╗██╗ ██████╗███████╗
// ████╗  ██║██╔═══██╗╚══██╔══╝██║██╔════╝██╔════╝
// ██╔██╗ ██║██║   ██║   ██║   ██║██║     █████╗
// ██║╚██╗██║██║   ██║   ██║   ██║██║     ██╔══╝
// ██║ ╚████║╚██████╔╝   ██║   ██║╚██████╗███████╗
// ╚═╝  ╚═══╝ ╚═════╝    ╚═╝   ╚═╝ ╚═════╝╚══════╝
// ------------------------------------------------
//
// This file is automatically generated.
// Please do not edit these files manually.
//
// ------------------------------------------------

using Elastic.Transport;
using System.Collections.Generic;
using System.Text.Json.Serialization;

#nullable restore
namespace Elastic.Clients.Elasticsearch.IndexManagement
{
	[ConvertAs(typeof(AddBlockRequest))]
	public partial interface IAddBlockRequest : IRequest<AddBlockRequestParameters>
	{
	}

	public partial class AddBlockRequest : PlainRequestBase<AddBlockRequestParameters>, IAddBlockRequest
	{
		protected IAddBlockRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndexManagementAddBlock;
		protected override HttpMethod HttpMethod => HttpMethod.PUT;
		protected override bool SupportsBody => false;
		protected override bool CanBeEmpty => false;
		protected override bool IsEmpty => false;

		///<summary>/{index}/_block/{block}</summary>
        public AddBlockRequest(Elastic.Clients.Elasticsearch.IndexName index, Elastic.Clients.Elasticsearch.IndexManagement.AddBlock.IndicesBlockOptions block) : base(r => r.Required("index", index).Required("block", block))
		{
		}

		[JsonIgnore]
		public bool? AllowNoIndices { get => Q<bool?>("allow_no_indices"); set => Q("allow_no_indices", value); }

		[JsonIgnore]
		public Elastic.Clients.Elasticsearch.ExpandWildcards? ExpandWildcards { get => Q<Elastic.Clients.Elasticsearch.ExpandWildcards?>("expand_wildcards"); set => Q("expand_wildcards", value); }

		[JsonIgnore]
		public bool? IgnoreUnavailable { get => Q<bool?>("ignore_unavailable"); set => Q("ignore_unavailable", value); }

		[JsonIgnore]
		public Elastic.Clients.Elasticsearch.Time? MasterTimeout { get => Q<Elastic.Clients.Elasticsearch.Time?>("master_timeout"); set => Q("master_timeout", value); }

		[JsonIgnore]
		public Elastic.Clients.Elasticsearch.Time? Timeout { get => Q<Elastic.Clients.Elasticsearch.Time?>("timeout"); set => Q("timeout", value); }
	}

	[ConvertAs(typeof(AnalyzeRequest))]
	public partial interface IAnalyzeRequest : IRequest<AnalyzeRequestParameters>
	{
		string? Analyzer { get; set; }

		IEnumerable<string>? Attributes { get; set; }

		IEnumerable<Union<string, Elastic.Clients.Elasticsearch.Analysis.CharFilter>>? CharFilter { get; set; }

		bool? Explain { get; set; }

		Elastic.Clients.Elasticsearch.Field? Field { get; set; }

		IEnumerable<Union<string, Elastic.Clients.Elasticsearch.Analysis.TokenFilter>>? Filter { get; set; }

		string? Normalizer { get; set; }

		Elastic.Clients.Elasticsearch.IndexManagement.Analyze.TextToAnalyze? Text { get; set; }

		Union<string, Elastic.Clients.Elasticsearch.Analysis.Tokenizer>? Tokenizer { get; set; }
	}

	public partial class AnalyzeRequest : PlainRequestBase<AnalyzeRequestParameters>, IAnalyzeRequest
	{
		protected IAnalyzeRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndexManagementAnalyze;
		protected override HttpMethod HttpMethod => HttpMethod.POST;
		protected override bool SupportsBody => true;
		protected override bool CanBeEmpty => true;
		protected override bool IsEmpty => Analyzer is null && Attributes is null && Explain is null && Filter is null && Normalizer is null && Text is null;

		///<summary>/_analyze</summary>
        public AnalyzeRequest() : base()
		{
		}

		///<summary>/{index}/_analyze</summary>
        public AnalyzeRequest(Elastic.Clients.Elasticsearch.IndexName? index) : base(r => r.Optional("index", index))
		{
		}

		[JsonPropertyName("analyzer")]
		public string? Analyzer { get; set; }

		[JsonPropertyName("attributes")]
		public IEnumerable<string>? Attributes { get; set; }

		[JsonPropertyName("char_filter")]
		public IEnumerable<Union<string, Elastic.Clients.Elasticsearch.Analysis.CharFilter>>? CharFilter { get; set; }

		[JsonPropertyName("explain")]
		public bool? Explain { get; set; }

		[JsonPropertyName("field")]
		public Elastic.Clients.Elasticsearch.Field? Field { get; set; }

		[JsonPropertyName("filter")]
		public IEnumerable<Union<string, Elastic.Clients.Elasticsearch.Analysis.TokenFilter>>? Filter { get; set; }

		[JsonPropertyName("normalizer")]
		public string? Normalizer { get; set; }

		[JsonPropertyName("text")]
		public Elastic.Clients.Elasticsearch.IndexManagement.Analyze.TextToAnalyze? Text { get; set; }

		[JsonPropertyName("tokenizer")]
		public Union<string, Elastic.Clients.Elasticsearch.Analysis.Tokenizer>? Tokenizer { get; set; }
	}

	[ConvertAs(typeof(ClearCacheRequest))]
	public partial interface IClearCacheRequest : IRequest<ClearCacheRequestParameters>
	{
	}

	public partial class ClearCacheRequest : PlainRequestBase<ClearCacheRequestParameters>, IClearCacheRequest
	{
		protected IClearCacheRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndexManagementClearCache;
		protected override HttpMethod HttpMethod => HttpMethod.POST;
		protected override bool SupportsBody => false;
		protected override bool CanBeEmpty => true;
		protected override bool IsEmpty => true;

		///<summary>/_cache/clear</summary>
        public ClearCacheRequest() : base()
		{
		}

		///<summary>/{index}/_cache/clear</summary>
        public ClearCacheRequest(Elastic.Clients.Elasticsearch.Indices? index) : base(r => r.Optional("index", index))
		{
		}

		[JsonIgnore]
		public bool? AllowNoIndices { get => Q<bool?>("allow_no_indices"); set => Q("allow_no_indices", value); }

		[JsonIgnore]
		public Elastic.Clients.Elasticsearch.ExpandWildcards? ExpandWildcards { get => Q<Elastic.Clients.Elasticsearch.ExpandWildcards?>("expand_wildcards"); set => Q("expand_wildcards", value); }

		[JsonIgnore]
		public bool? Fielddata { get => Q<bool?>("fielddata"); set => Q("fielddata", value); }

		[JsonIgnore]
		public Elastic.Clients.Elasticsearch.Fields? Fields { get => Q<Elastic.Clients.Elasticsearch.Fields?>("fields"); set => Q("fields", value); }

		[JsonIgnore]
		public bool? IgnoreUnavailable { get => Q<bool?>("ignore_unavailable"); set => Q("ignore_unavailable", value); }

		[JsonIgnore]
		public bool? Query { get => Q<bool?>("query"); set => Q("query", value); }

		[JsonIgnore]
		public bool? Request { get => Q<bool?>("request"); set => Q("request", value); }
	}

	[ConvertAs(typeof(CloneRequest))]
	public partial interface ICloneRequest : IRequest<CloneRequestParameters>
	{
		Dictionary<Elastic.Clients.Elasticsearch.IndexName, Elastic.Clients.Elasticsearch.IndexManagement.Alias>? Aliases { get; set; }

		Dictionary<string, object>? Settings { get; set; }
	}

	public partial class CloneRequest : PlainRequestBase<CloneRequestParameters>, ICloneRequest
	{
		protected ICloneRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndexManagementClone;
		protected override HttpMethod HttpMethod => HttpMethod.PUT;
		protected override bool SupportsBody => true;
		protected override bool CanBeEmpty => false;
		protected override bool IsEmpty => false;

		///<summary>/{index}/_clone/{target}</summary>
        public CloneRequest(Elastic.Clients.Elasticsearch.IndexName index, Elastic.Clients.Elasticsearch.Name target) : base(r => r.Required("index", index).Required("target", target))
		{
		}

		[JsonIgnore]
		public Elastic.Clients.Elasticsearch.Time? MasterTimeout { get => Q<Elastic.Clients.Elasticsearch.Time?>("master_timeout"); set => Q("master_timeout", value); }

		[JsonIgnore]
		public Elastic.Clients.Elasticsearch.Time? Timeout { get => Q<Elastic.Clients.Elasticsearch.Time?>("timeout"); set => Q("timeout", value); }

		[JsonIgnore]
		public Elastic.Clients.Elasticsearch.WaitForActiveShards? WaitForActiveShards { get => Q<Elastic.Clients.Elasticsearch.WaitForActiveShards?>("wait_for_active_shards"); set => Q("wait_for_active_shards", value); }

		[JsonPropertyName("aliases")]
		public Dictionary<Elastic.Clients.Elasticsearch.IndexName, Elastic.Clients.Elasticsearch.IndexManagement.Alias>? Aliases { get; set; }

		[JsonPropertyName("settings")]
		public Dictionary<string, object>? Settings { get; set; }
	}

	[ConvertAs(typeof(CloseRequest))]
	public partial interface ICloseRequest : IRequest<CloseRequestParameters>
	{
	}

	public partial class CloseRequest : PlainRequestBase<CloseRequestParameters>, ICloseRequest
	{
		protected ICloseRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndexManagementClose;
		protected override HttpMethod HttpMethod => HttpMethod.POST;
		protected override bool SupportsBody => false;
		protected override bool CanBeEmpty => false;
		protected override bool IsEmpty => false;

		///<summary>/{index}/_close</summary>
        public CloseRequest(Elastic.Clients.Elasticsearch.Indices index) : base(r => r.Required("index", index))
		{
		}

		[JsonIgnore]
		public bool? AllowNoIndices { get => Q<bool?>("allow_no_indices"); set => Q("allow_no_indices", value); }

		[JsonIgnore]
		public Elastic.Clients.Elasticsearch.ExpandWildcards? ExpandWildcards { get => Q<Elastic.Clients.Elasticsearch.ExpandWildcards?>("expand_wildcards"); set => Q("expand_wildcards", value); }

		[JsonIgnore]
		public bool? IgnoreUnavailable { get => Q<bool?>("ignore_unavailable"); set => Q("ignore_unavailable", value); }

		[JsonIgnore]
		public Elastic.Clients.Elasticsearch.Time? MasterTimeout { get => Q<Elastic.Clients.Elasticsearch.Time?>("master_timeout"); set => Q("master_timeout", value); }

		[JsonIgnore]
		public Elastic.Clients.Elasticsearch.Time? Timeout { get => Q<Elastic.Clients.Elasticsearch.Time?>("timeout"); set => Q("timeout", value); }

		[JsonIgnore]
		public Elastic.Clients.Elasticsearch.WaitForActiveShards? WaitForActiveShards { get => Q<Elastic.Clients.Elasticsearch.WaitForActiveShards?>("wait_for_active_shards"); set => Q("wait_for_active_shards", value); }
	}

	[ConvertAs(typeof(CreateRequest))]
	public partial interface ICreateRequest : IRequest<CreateRequestParameters>
	{
		Dictionary<Elastic.Clients.Elasticsearch.IndexName, Elastic.Clients.Elasticsearch.IndexManagement.Alias>? Aliases { get; set; }

		Union<Dictionary<string, Elastic.Clients.Elasticsearch.Mapping.TypeMapping>, Elastic.Clients.Elasticsearch.Mapping.TypeMapping>? Mappings { get; set; }

		Dictionary<string, object>? Settings { get; set; }
	}

	public partial class CreateRequest : PlainRequestBase<CreateRequestParameters>, ICreateRequest
	{
		protected ICreateRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndexManagementCreate;
		protected override HttpMethod HttpMethod => HttpMethod.PUT;
		protected override bool SupportsBody => true;
		protected override bool CanBeEmpty => false;
		protected override bool IsEmpty => false;

		///<summary>/{index}</summary>
        public CreateRequest(Elastic.Clients.Elasticsearch.IndexName index) : base(r => r.Required("index", index))
		{
		}

		[JsonIgnore]
		public bool? IncludeTypeName { get => Q<bool?>("include_type_name"); set => Q("include_type_name", value); }

		[JsonIgnore]
		public Elastic.Clients.Elasticsearch.Time? MasterTimeout { get => Q<Elastic.Clients.Elasticsearch.Time?>("master_timeout"); set => Q("master_timeout", value); }

		[JsonIgnore]
		public Elastic.Clients.Elasticsearch.Time? Timeout { get => Q<Elastic.Clients.Elasticsearch.Time?>("timeout"); set => Q("timeout", value); }

		[JsonIgnore]
		public Elastic.Clients.Elasticsearch.WaitForActiveShards? WaitForActiveShards { get => Q<Elastic.Clients.Elasticsearch.WaitForActiveShards?>("wait_for_active_shards"); set => Q("wait_for_active_shards", value); }

		[JsonPropertyName("aliases")]
		public Dictionary<Elastic.Clients.Elasticsearch.IndexName, Elastic.Clients.Elasticsearch.IndexManagement.Alias>? Aliases { get; set; }

		[JsonPropertyName("mappings")]
		public Union<Dictionary<string, Elastic.Clients.Elasticsearch.Mapping.TypeMapping>, Elastic.Clients.Elasticsearch.Mapping.TypeMapping>? Mappings { get; set; }

		[JsonPropertyName("settings")]
		public Dictionary<string, object>? Settings { get; set; }
	}

	[ConvertAs(typeof(CreateDataStreamRequest))]
	public partial interface ICreateDataStreamRequest : IRequest<CreateDataStreamRequestParameters>
	{
	}

	public partial class CreateDataStreamRequest : PlainRequestBase<CreateDataStreamRequestParameters>, ICreateDataStreamRequest
	{
		protected ICreateDataStreamRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndexManagementCreateDataStream;
		protected override HttpMethod HttpMethod => HttpMethod.PUT;
		protected override bool SupportsBody => false;
		protected override bool CanBeEmpty => false;
		protected override bool IsEmpty => false;

		///<summary>/_data_stream/{name}</summary>
        public CreateDataStreamRequest(Elastic.Clients.Elasticsearch.DataStreamName name) : base(r => r.Required("name", name))
		{
		}
	}

	[ConvertAs(typeof(DataStreamsStatsRequest))]
	public partial interface IDataStreamsStatsRequest : IRequest<DataStreamsStatsRequestParameters>
	{
	}

	public partial class DataStreamsStatsRequest : PlainRequestBase<DataStreamsStatsRequestParameters>, IDataStreamsStatsRequest
	{
		protected IDataStreamsStatsRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndexManagementDataStreamsStats;
		protected override HttpMethod HttpMethod => HttpMethod.GET;
		protected override bool SupportsBody => false;
		protected override bool CanBeEmpty => true;
		protected override bool IsEmpty => true;

		///<summary>/_data_stream/_stats</summary>
        public DataStreamsStatsRequest() : base()
		{
		}

		///<summary>/_data_stream/{name}/_stats</summary>
        public DataStreamsStatsRequest(Elastic.Clients.Elasticsearch.IndexName? name) : base(r => r.Optional("name", name))
		{
		}

		[JsonIgnore]
		public Elastic.Clients.Elasticsearch.ExpandWildcards? ExpandWildcards { get => Q<Elastic.Clients.Elasticsearch.ExpandWildcards?>("expand_wildcards"); set => Q("expand_wildcards", value); }
	}

	[ConvertAs(typeof(DeleteRequest))]
	public partial interface IDeleteRequest : IRequest<DeleteRequestParameters>
	{
	}

	public partial class DeleteRequest : PlainRequestBase<DeleteRequestParameters>, IDeleteRequest
	{
		protected IDeleteRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndexManagementDelete;
		protected override HttpMethod HttpMethod => HttpMethod.DELETE;
		protected override bool SupportsBody => false;
		protected override bool CanBeEmpty => false;
		protected override bool IsEmpty => false;

		///<summary>/{index}</summary>
        public DeleteRequest(Elastic.Clients.Elasticsearch.Indices index) : base(r => r.Required("index", index))
		{
		}

		[JsonIgnore]
		public bool? AllowNoIndices { get => Q<bool?>("allow_no_indices"); set => Q("allow_no_indices", value); }

		[JsonIgnore]
		public Elastic.Clients.Elasticsearch.ExpandWildcards? ExpandWildcards { get => Q<Elastic.Clients.Elasticsearch.ExpandWildcards?>("expand_wildcards"); set => Q("expand_wildcards", value); }

		[JsonIgnore]
		public bool? IgnoreUnavailable { get => Q<bool?>("ignore_unavailable"); set => Q("ignore_unavailable", value); }

		[JsonIgnore]
		public Elastic.Clients.Elasticsearch.Time? MasterTimeout { get => Q<Elastic.Clients.Elasticsearch.Time?>("master_timeout"); set => Q("master_timeout", value); }

		[JsonIgnore]
		public Elastic.Clients.Elasticsearch.Time? Timeout { get => Q<Elastic.Clients.Elasticsearch.Time?>("timeout"); set => Q("timeout", value); }
	}

	[ConvertAs(typeof(DeleteAliasRequest))]
	public partial interface IDeleteAliasRequest : IRequest<DeleteAliasRequestParameters>
	{
	}

	public partial class DeleteAliasRequest : PlainRequestBase<DeleteAliasRequestParameters>, IDeleteAliasRequest
	{
		protected IDeleteAliasRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndexManagementDeleteAlias;
		protected override HttpMethod HttpMethod => HttpMethod.DELETE;
		protected override bool SupportsBody => false;
		protected override bool CanBeEmpty => false;
		protected override bool IsEmpty => false;

		///<summary>/{index}/_alias/{name}</summary>
        public DeleteAliasRequest(Elastic.Clients.Elasticsearch.Indices index, Elastic.Clients.Elasticsearch.Names name) : base(r => r.Required("index", index).Required("name", name))
		{
		}

		[JsonIgnore]
		public Elastic.Clients.Elasticsearch.Time? MasterTimeout { get => Q<Elastic.Clients.Elasticsearch.Time?>("master_timeout"); set => Q("master_timeout", value); }

		[JsonIgnore]
		public Elastic.Clients.Elasticsearch.Time? Timeout { get => Q<Elastic.Clients.Elasticsearch.Time?>("timeout"); set => Q("timeout", value); }
	}

	[ConvertAs(typeof(DeleteDataStreamRequest))]
	public partial interface IDeleteDataStreamRequest : IRequest<DeleteDataStreamRequestParameters>
	{
	}

	public partial class DeleteDataStreamRequest : PlainRequestBase<DeleteDataStreamRequestParameters>, IDeleteDataStreamRequest
	{
		protected IDeleteDataStreamRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndexManagementDeleteDataStream;
		protected override HttpMethod HttpMethod => HttpMethod.DELETE;
		protected override bool SupportsBody => false;
		protected override bool CanBeEmpty => false;
		protected override bool IsEmpty => false;

		///<summary>/_data_stream/{name}</summary>
        public DeleteDataStreamRequest(Elastic.Clients.Elasticsearch.DataStreamNames name) : base(r => r.Required("name", name))
		{
		}

		[JsonIgnore]
		public Elastic.Clients.Elasticsearch.ExpandWildcards? ExpandWildcards { get => Q<Elastic.Clients.Elasticsearch.ExpandWildcards?>("expand_wildcards"); set => Q("expand_wildcards", value); }
	}

	[ConvertAs(typeof(DeleteIndexTemplateRequest))]
	public partial interface IDeleteIndexTemplateRequest : IRequest<DeleteIndexTemplateRequestParameters>
	{
	}

	public partial class DeleteIndexTemplateRequest : PlainRequestBase<DeleteIndexTemplateRequestParameters>, IDeleteIndexTemplateRequest
	{
		protected IDeleteIndexTemplateRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndexManagementDeleteIndexTemplate;
		protected override HttpMethod HttpMethod => HttpMethod.DELETE;
		protected override bool SupportsBody => false;
		protected override bool CanBeEmpty => false;
		protected override bool IsEmpty => false;

		///<summary>/_index_template/{name}</summary>
        public DeleteIndexTemplateRequest(Elastic.Clients.Elasticsearch.Name name) : base(r => r.Required("name", name))
		{
		}
	}

	[ConvertAs(typeof(DeleteTemplateRequest))]
	public partial interface IDeleteTemplateRequest : IRequest<DeleteTemplateRequestParameters>
	{
	}

	public partial class DeleteTemplateRequest : PlainRequestBase<DeleteTemplateRequestParameters>, IDeleteTemplateRequest
	{
		protected IDeleteTemplateRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndexManagementDeleteTemplate;
		protected override HttpMethod HttpMethod => HttpMethod.DELETE;
		protected override bool SupportsBody => false;
		protected override bool CanBeEmpty => false;
		protected override bool IsEmpty => false;

		///<summary>/_template/{name}</summary>
        public DeleteTemplateRequest(Elastic.Clients.Elasticsearch.Name name) : base(r => r.Required("name", name))
		{
		}

		[JsonIgnore]
		public Elastic.Clients.Elasticsearch.Time? MasterTimeout { get => Q<Elastic.Clients.Elasticsearch.Time?>("master_timeout"); set => Q("master_timeout", value); }

		[JsonIgnore]
		public Elastic.Clients.Elasticsearch.Time? Timeout { get => Q<Elastic.Clients.Elasticsearch.Time?>("timeout"); set => Q("timeout", value); }
	}

	[ConvertAs(typeof(ExistsRequest))]
	public partial interface IExistsRequest : IRequest<ExistsRequestParameters>
	{
	}

	public partial class ExistsRequest : PlainRequestBase<ExistsRequestParameters>, IExistsRequest
	{
		protected IExistsRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndexManagementExists;
		protected override HttpMethod HttpMethod => HttpMethod.HEAD;
		protected override bool SupportsBody => false;
		protected override bool CanBeEmpty => false;
		protected override bool IsEmpty => false;

		///<summary>/{index}</summary>
        public ExistsRequest(Elastic.Clients.Elasticsearch.Indices index) : base(r => r.Required("index", index))
		{
		}

		[JsonIgnore]
		public bool? AllowNoIndices { get => Q<bool?>("allow_no_indices"); set => Q("allow_no_indices", value); }

		[JsonIgnore]
		public Elastic.Clients.Elasticsearch.ExpandWildcards? ExpandWildcards { get => Q<Elastic.Clients.Elasticsearch.ExpandWildcards?>("expand_wildcards"); set => Q("expand_wildcards", value); }

		[JsonIgnore]
		public bool? FlatSettings { get => Q<bool?>("flat_settings"); set => Q("flat_settings", value); }

		[JsonIgnore]
		public bool? IgnoreUnavailable { get => Q<bool?>("ignore_unavailable"); set => Q("ignore_unavailable", value); }

		[JsonIgnore]
		public bool? IncludeDefaults { get => Q<bool?>("include_defaults"); set => Q("include_defaults", value); }

		[JsonIgnore]
		public bool? Local { get => Q<bool?>("local"); set => Q("local", value); }
	}

	[ConvertAs(typeof(ExistsAliasRequest))]
	public partial interface IExistsAliasRequest : IRequest<ExistsAliasRequestParameters>
	{
	}

	public partial class ExistsAliasRequest : PlainRequestBase<ExistsAliasRequestParameters>, IExistsAliasRequest
	{
		protected IExistsAliasRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndexManagementExistsAlias;
		protected override HttpMethod HttpMethod => HttpMethod.HEAD;
		protected override bool SupportsBody => false;
		protected override bool CanBeEmpty => false;
		protected override bool IsEmpty => false;

		///<summary>/_alias/{name}</summary>
        public ExistsAliasRequest(Elastic.Clients.Elasticsearch.Names name) : base(r => r.Required("name", name))
		{
		}

		///<summary>/{index}/_alias/{name}</summary>
        public ExistsAliasRequest(Elastic.Clients.Elasticsearch.Indices? index, Elastic.Clients.Elasticsearch.Names name) : base(r => r.Optional("index", index).Required("name", name))
		{
		}

		[JsonIgnore]
		public bool? AllowNoIndices { get => Q<bool?>("allow_no_indices"); set => Q("allow_no_indices", value); }

		[JsonIgnore]
		public Elastic.Clients.Elasticsearch.ExpandWildcards? ExpandWildcards { get => Q<Elastic.Clients.Elasticsearch.ExpandWildcards?>("expand_wildcards"); set => Q("expand_wildcards", value); }

		[JsonIgnore]
		public bool? IgnoreUnavailable { get => Q<bool?>("ignore_unavailable"); set => Q("ignore_unavailable", value); }

		[JsonIgnore]
		public bool? Local { get => Q<bool?>("local"); set => Q("local", value); }
	}

	[ConvertAs(typeof(ExistsIndexTemplateRequest))]
	public partial interface IExistsIndexTemplateRequest : IRequest<ExistsIndexTemplateRequestParameters>
	{
	}

	public partial class ExistsIndexTemplateRequest : PlainRequestBase<ExistsIndexTemplateRequestParameters>, IExistsIndexTemplateRequest
	{
		protected IExistsIndexTemplateRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndexManagementExistsIndexTemplate;
		protected override HttpMethod HttpMethod => HttpMethod.HEAD;
		protected override bool SupportsBody => false;
		protected override bool CanBeEmpty => false;
		protected override bool IsEmpty => false;

		///<summary>/_index_template/{name}</summary>
        public ExistsIndexTemplateRequest(Elastic.Clients.Elasticsearch.Name name) : base(r => r.Required("name", name))
		{
		}

		[JsonIgnore]
		public Elastic.Clients.Elasticsearch.Time? MasterTimeout { get => Q<Elastic.Clients.Elasticsearch.Time?>("master_timeout"); set => Q("master_timeout", value); }
	}

	[ConvertAs(typeof(ExistsTemplateRequest))]
	public partial interface IExistsTemplateRequest : IRequest<ExistsTemplateRequestParameters>
	{
	}

	public partial class ExistsTemplateRequest : PlainRequestBase<ExistsTemplateRequestParameters>, IExistsTemplateRequest
	{
		protected IExistsTemplateRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndexManagementExistsTemplate;
		protected override HttpMethod HttpMethod => HttpMethod.HEAD;
		protected override bool SupportsBody => false;
		protected override bool CanBeEmpty => false;
		protected override bool IsEmpty => false;

		///<summary>/_template/{name}</summary>
        public ExistsTemplateRequest(Elastic.Clients.Elasticsearch.Names name) : base(r => r.Required("name", name))
		{
		}

		[JsonIgnore]
		public bool? FlatSettings { get => Q<bool?>("flat_settings"); set => Q("flat_settings", value); }

		[JsonIgnore]
		public bool? Local { get => Q<bool?>("local"); set => Q("local", value); }

		[JsonIgnore]
		public Elastic.Clients.Elasticsearch.Time? MasterTimeout { get => Q<Elastic.Clients.Elasticsearch.Time?>("master_timeout"); set => Q("master_timeout", value); }
	}

	[ConvertAs(typeof(FlushRequest))]
	public partial interface IFlushRequest : IRequest<FlushRequestParameters>
	{
	}

	public partial class FlushRequest : PlainRequestBase<FlushRequestParameters>, IFlushRequest
	{
		protected IFlushRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndexManagementFlush;
		protected override HttpMethod HttpMethod => HttpMethod.POST;
		protected override bool SupportsBody => false;
		protected override bool CanBeEmpty => true;
		protected override bool IsEmpty => true;

		///<summary>/_flush</summary>
        public FlushRequest() : base()
		{
		}

		///<summary>/{index}/_flush</summary>
        public FlushRequest(Elastic.Clients.Elasticsearch.Indices? index) : base(r => r.Optional("index", index))
		{
		}

		[JsonIgnore]
		public bool? AllowNoIndices { get => Q<bool?>("allow_no_indices"); set => Q("allow_no_indices", value); }

		[JsonIgnore]
		public Elastic.Clients.Elasticsearch.ExpandWildcards? ExpandWildcards { get => Q<Elastic.Clients.Elasticsearch.ExpandWildcards?>("expand_wildcards"); set => Q("expand_wildcards", value); }

		[JsonIgnore]
		public bool? Force { get => Q<bool?>("force"); set => Q("force", value); }

		[JsonIgnore]
		public bool? IgnoreUnavailable { get => Q<bool?>("ignore_unavailable"); set => Q("ignore_unavailable", value); }

		[JsonIgnore]
		public bool? WaitIfOngoing { get => Q<bool?>("wait_if_ongoing"); set => Q("wait_if_ongoing", value); }
	}

	[ConvertAs(typeof(ForcemergeRequest))]
	public partial interface IForcemergeRequest : IRequest<ForcemergeRequestParameters>
	{
	}

	public partial class ForcemergeRequest : PlainRequestBase<ForcemergeRequestParameters>, IForcemergeRequest
	{
		protected IForcemergeRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndexManagementForcemerge;
		protected override HttpMethod HttpMethod => HttpMethod.POST;
		protected override bool SupportsBody => false;
		protected override bool CanBeEmpty => true;
		protected override bool IsEmpty => true;

		///<summary>/_forcemerge</summary>
        public ForcemergeRequest() : base()
		{
		}

		///<summary>/{index}/_forcemerge</summary>
        public ForcemergeRequest(Elastic.Clients.Elasticsearch.Indices? index) : base(r => r.Optional("index", index))
		{
		}

		[JsonIgnore]
		public bool? AllowNoIndices { get => Q<bool?>("allow_no_indices"); set => Q("allow_no_indices", value); }

		[JsonIgnore]
		public Elastic.Clients.Elasticsearch.ExpandWildcards? ExpandWildcards { get => Q<Elastic.Clients.Elasticsearch.ExpandWildcards?>("expand_wildcards"); set => Q("expand_wildcards", value); }

		[JsonIgnore]
		public bool? Flush { get => Q<bool?>("flush"); set => Q("flush", value); }

		[JsonIgnore]
		public bool? IgnoreUnavailable { get => Q<bool?>("ignore_unavailable"); set => Q("ignore_unavailable", value); }

		[JsonIgnore]
		public long? MaxNumSegments { get => Q<long?>("max_num_segments"); set => Q("max_num_segments", value); }

		[JsonIgnore]
		public bool? OnlyExpungeDeletes { get => Q<bool?>("only_expunge_deletes"); set => Q("only_expunge_deletes", value); }
	}

	[ConvertAs(typeof(GetRequest))]
	public partial interface IGetRequest : IRequest<GetRequestParameters>
	{
	}

	public partial class GetRequest : PlainRequestBase<GetRequestParameters>, IGetRequest
	{
		protected IGetRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndexManagementGet;
		protected override HttpMethod HttpMethod => HttpMethod.GET;
		protected override bool SupportsBody => false;
		protected override bool CanBeEmpty => false;
		protected override bool IsEmpty => false;

		///<summary>/{index}</summary>
        public GetRequest(Elastic.Clients.Elasticsearch.Indices index) : base(r => r.Required("index", index))
		{
		}

		[JsonIgnore]
		public bool? AllowNoIndices { get => Q<bool?>("allow_no_indices"); set => Q("allow_no_indices", value); }

		[JsonIgnore]
		public Elastic.Clients.Elasticsearch.ExpandWildcards? ExpandWildcards { get => Q<Elastic.Clients.Elasticsearch.ExpandWildcards?>("expand_wildcards"); set => Q("expand_wildcards", value); }

		[JsonIgnore]
		public bool? FlatSettings { get => Q<bool?>("flat_settings"); set => Q("flat_settings", value); }

		[JsonIgnore]
		public bool? IgnoreUnavailable { get => Q<bool?>("ignore_unavailable"); set => Q("ignore_unavailable", value); }

		[JsonIgnore]
		public bool? IncludeDefaults { get => Q<bool?>("include_defaults"); set => Q("include_defaults", value); }

		[JsonIgnore]
		public bool? IncludeTypeName { get => Q<bool?>("include_type_name"); set => Q("include_type_name", value); }

		[JsonIgnore]
		public bool? Local { get => Q<bool?>("local"); set => Q("local", value); }

		[JsonIgnore]
		public Elastic.Clients.Elasticsearch.Time? MasterTimeout { get => Q<Elastic.Clients.Elasticsearch.Time?>("master_timeout"); set => Q("master_timeout", value); }
	}

	[ConvertAs(typeof(GetAliasRequest))]
	public partial interface IGetAliasRequest : IRequest<GetAliasRequestParameters>
	{
	}

	public partial class GetAliasRequest : PlainRequestBase<GetAliasRequestParameters>, IGetAliasRequest
	{
		protected IGetAliasRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndexManagementGetAlias;
		protected override HttpMethod HttpMethod => HttpMethod.GET;
		protected override bool SupportsBody => false;
		protected override bool CanBeEmpty => true;
		protected override bool IsEmpty => true;

		///<summary>/_alias</summary>
        public GetAliasRequest() : base()
		{
		}

		///<summary>/_alias/{name}</summary>
        public GetAliasRequest(Elastic.Clients.Elasticsearch.Names? name) : base(r => r.Optional("name", name))
		{
		}

		///<summary>/{index}/_alias/{name}</summary>
        public GetAliasRequest(Elastic.Clients.Elasticsearch.Indices? index, Elastic.Clients.Elasticsearch.Names? name) : base(r => r.Optional("index", index).Optional("name", name))
		{
		}

		///<summary>/{index}/_alias</summary>
        public GetAliasRequest(Elastic.Clients.Elasticsearch.Indices? index) : base(r => r.Optional("index", index))
		{
		}

		[JsonIgnore]
		public bool? AllowNoIndices { get => Q<bool?>("allow_no_indices"); set => Q("allow_no_indices", value); }

		[JsonIgnore]
		public Elastic.Clients.Elasticsearch.ExpandWildcards? ExpandWildcards { get => Q<Elastic.Clients.Elasticsearch.ExpandWildcards?>("expand_wildcards"); set => Q("expand_wildcards", value); }

		[JsonIgnore]
		public bool? IgnoreUnavailable { get => Q<bool?>("ignore_unavailable"); set => Q("ignore_unavailable", value); }

		[JsonIgnore]
		public bool? Local { get => Q<bool?>("local"); set => Q("local", value); }
	}

	[ConvertAs(typeof(GetDataStreamRequest))]
	public partial interface IGetDataStreamRequest : IRequest<GetDataStreamRequestParameters>
	{
	}

	public partial class GetDataStreamRequest : PlainRequestBase<GetDataStreamRequestParameters>, IGetDataStreamRequest
	{
		protected IGetDataStreamRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndexManagementGetDataStream;
		protected override HttpMethod HttpMethod => HttpMethod.GET;
		protected override bool SupportsBody => false;
		protected override bool CanBeEmpty => true;
		protected override bool IsEmpty => true;

		///<summary>/_data_stream</summary>
        public GetDataStreamRequest() : base()
		{
		}

		///<summary>/_data_stream/{name}</summary>
        public GetDataStreamRequest(Elastic.Clients.Elasticsearch.DataStreamNames? name) : base(r => r.Optional("name", name))
		{
		}

		[JsonIgnore]
		public Elastic.Clients.Elasticsearch.ExpandWildcards? ExpandWildcards { get => Q<Elastic.Clients.Elasticsearch.ExpandWildcards?>("expand_wildcards"); set => Q("expand_wildcards", value); }
	}

	[ConvertAs(typeof(GetFieldMappingRequest))]
	public partial interface IGetFieldMappingRequest : IRequest<GetFieldMappingRequestParameters>
	{
	}

	public partial class GetFieldMappingRequest : PlainRequestBase<GetFieldMappingRequestParameters>, IGetFieldMappingRequest
	{
		protected IGetFieldMappingRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndexManagementGetFieldMapping;
		protected override HttpMethod HttpMethod => HttpMethod.GET;
		protected override bool SupportsBody => false;
		protected override bool CanBeEmpty => false;
		protected override bool IsEmpty => false;

		///<summary>/_mapping/field/{fields}</summary>
        public GetFieldMappingRequest(Elastic.Clients.Elasticsearch.Fields fields) : base(r => r.Required("fields", fields))
		{
		}

		///<summary>/{index}/_mapping/field/{fields}</summary>
        public GetFieldMappingRequest(Elastic.Clients.Elasticsearch.Indices? index, Elastic.Clients.Elasticsearch.Fields fields) : base(r => r.Optional("index", index).Required("fields", fields))
		{
		}

		[JsonIgnore]
		public bool? AllowNoIndices { get => Q<bool?>("allow_no_indices"); set => Q("allow_no_indices", value); }

		[JsonIgnore]
		public Elastic.Clients.Elasticsearch.ExpandWildcards? ExpandWildcards { get => Q<Elastic.Clients.Elasticsearch.ExpandWildcards?>("expand_wildcards"); set => Q("expand_wildcards", value); }

		[JsonIgnore]
		public bool? IgnoreUnavailable { get => Q<bool?>("ignore_unavailable"); set => Q("ignore_unavailable", value); }

		[JsonIgnore]
		public bool? IncludeDefaults { get => Q<bool?>("include_defaults"); set => Q("include_defaults", value); }

		[JsonIgnore]
		public bool? IncludeTypeName { get => Q<bool?>("include_type_name"); set => Q("include_type_name", value); }

		[JsonIgnore]
		public bool? Local { get => Q<bool?>("local"); set => Q("local", value); }
	}

	[ConvertAs(typeof(GetIndexTemplateRequest))]
	public partial interface IGetIndexTemplateRequest : IRequest<GetIndexTemplateRequestParameters>
	{
		bool? FlatSettings { get; set; }

		bool? IncludeTypeName { get; set; }

		Elastic.Clients.Elasticsearch.Time? MasterTimeout { get; set; }
	}

	public partial class GetIndexTemplateRequest : PlainRequestBase<GetIndexTemplateRequestParameters>, IGetIndexTemplateRequest
	{
		protected IGetIndexTemplateRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndexManagementGetIndexTemplate;
		protected override HttpMethod HttpMethod => HttpMethod.GET;
		protected override bool SupportsBody => true;
		protected override bool CanBeEmpty => true;
		protected override bool IsEmpty => FlatSettings is null && IncludeTypeName is null && MasterTimeout is null;

		///<summary>/_index_template</summary>
        public GetIndexTemplateRequest() : base()
		{
		}

		///<summary>/_index_template/{name}</summary>
        public GetIndexTemplateRequest(Elastic.Clients.Elasticsearch.Name? name) : base(r => r.Optional("name", name))
		{
		}

		[JsonIgnore]
		public bool? Local { get => Q<bool?>("local"); set => Q("local", value); }

		[JsonPropertyName("flat_settings")]
		public bool? FlatSettings { get; set; }

		[JsonPropertyName("include_type_name")]
		public bool? IncludeTypeName { get; set; }

		[JsonPropertyName("master_timeout")]
		public Elastic.Clients.Elasticsearch.Time? MasterTimeout { get; set; }
	}

	[ConvertAs(typeof(GetMappingRequest))]
	public partial interface IGetMappingRequest : IRequest<GetMappingRequestParameters>
	{
	}

	public partial class GetMappingRequest : PlainRequestBase<GetMappingRequestParameters>, IGetMappingRequest
	{
		protected IGetMappingRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndexManagementGetMapping;
		protected override HttpMethod HttpMethod => HttpMethod.GET;
		protected override bool SupportsBody => false;
		protected override bool CanBeEmpty => true;
		protected override bool IsEmpty => true;

		///<summary>/_mapping</summary>
        public GetMappingRequest() : base()
		{
		}

		///<summary>/{index}/_mapping</summary>
        public GetMappingRequest(Elastic.Clients.Elasticsearch.Indices? index) : base(r => r.Optional("index", index))
		{
		}

		[JsonIgnore]
		public bool? AllowNoIndices { get => Q<bool?>("allow_no_indices"); set => Q("allow_no_indices", value); }

		[JsonIgnore]
		public Elastic.Clients.Elasticsearch.ExpandWildcards? ExpandWildcards { get => Q<Elastic.Clients.Elasticsearch.ExpandWildcards?>("expand_wildcards"); set => Q("expand_wildcards", value); }

		[JsonIgnore]
		public bool? IgnoreUnavailable { get => Q<bool?>("ignore_unavailable"); set => Q("ignore_unavailable", value); }

		[JsonIgnore]
		public bool? IncludeTypeName { get => Q<bool?>("include_type_name"); set => Q("include_type_name", value); }

		[JsonIgnore]
		public bool? Local { get => Q<bool?>("local"); set => Q("local", value); }

		[JsonIgnore]
		public Elastic.Clients.Elasticsearch.Time? MasterTimeout { get => Q<Elastic.Clients.Elasticsearch.Time?>("master_timeout"); set => Q("master_timeout", value); }
	}

	[ConvertAs(typeof(GetSettingsRequest))]
	public partial interface IGetSettingsRequest : IRequest<GetSettingsRequestParameters>
	{
	}

	public partial class GetSettingsRequest : PlainRequestBase<GetSettingsRequestParameters>, IGetSettingsRequest
	{
		protected IGetSettingsRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndexManagementGetSettings;
		protected override HttpMethod HttpMethod => HttpMethod.GET;
		protected override bool SupportsBody => false;
		protected override bool CanBeEmpty => true;
		protected override bool IsEmpty => true;

		///<summary>/_settings</summary>
        public GetSettingsRequest() : base()
		{
		}

		///<summary>/{index}/_settings</summary>
        public GetSettingsRequest(Elastic.Clients.Elasticsearch.Indices? index) : base(r => r.Optional("index", index))
		{
		}

		///<summary>/{index}/_settings/{name}</summary>
        public GetSettingsRequest(Elastic.Clients.Elasticsearch.Indices? index, Elastic.Clients.Elasticsearch.Names? name) : base(r => r.Optional("index", index).Optional("name", name))
		{
		}

		///<summary>/_settings/{name}</summary>
        public GetSettingsRequest(Elastic.Clients.Elasticsearch.Names? name) : base(r => r.Optional("name", name))
		{
		}

		[JsonIgnore]
		public bool? AllowNoIndices { get => Q<bool?>("allow_no_indices"); set => Q("allow_no_indices", value); }

		[JsonIgnore]
		public Elastic.Clients.Elasticsearch.ExpandWildcards? ExpandWildcards { get => Q<Elastic.Clients.Elasticsearch.ExpandWildcards?>("expand_wildcards"); set => Q("expand_wildcards", value); }

		[JsonIgnore]
		public bool? FlatSettings { get => Q<bool?>("flat_settings"); set => Q("flat_settings", value); }

		[JsonIgnore]
		public bool? IgnoreUnavailable { get => Q<bool?>("ignore_unavailable"); set => Q("ignore_unavailable", value); }

		[JsonIgnore]
		public bool? IncludeDefaults { get => Q<bool?>("include_defaults"); set => Q("include_defaults", value); }

		[JsonIgnore]
		public bool? Local { get => Q<bool?>("local"); set => Q("local", value); }

		[JsonIgnore]
		public Elastic.Clients.Elasticsearch.Time? MasterTimeout { get => Q<Elastic.Clients.Elasticsearch.Time?>("master_timeout"); set => Q("master_timeout", value); }
	}

	[ConvertAs(typeof(GetTemplateRequest))]
	public partial interface IGetTemplateRequest : IRequest<GetTemplateRequestParameters>
	{
	}

	public partial class GetTemplateRequest : PlainRequestBase<GetTemplateRequestParameters>, IGetTemplateRequest
	{
		protected IGetTemplateRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndexManagementGetTemplate;
		protected override HttpMethod HttpMethod => HttpMethod.GET;
		protected override bool SupportsBody => false;
		protected override bool CanBeEmpty => true;
		protected override bool IsEmpty => true;

		///<summary>/_template</summary>
        public GetTemplateRequest() : base()
		{
		}

		///<summary>/_template/{name}</summary>
        public GetTemplateRequest(Elastic.Clients.Elasticsearch.Names? name) : base(r => r.Optional("name", name))
		{
		}

		[JsonIgnore]
		public bool? FlatSettings { get => Q<bool?>("flat_settings"); set => Q("flat_settings", value); }

		[JsonIgnore]
		public bool? IncludeTypeName { get => Q<bool?>("include_type_name"); set => Q("include_type_name", value); }

		[JsonIgnore]
		public bool? Local { get => Q<bool?>("local"); set => Q("local", value); }

		[JsonIgnore]
		public Elastic.Clients.Elasticsearch.Time? MasterTimeout { get => Q<Elastic.Clients.Elasticsearch.Time?>("master_timeout"); set => Q("master_timeout", value); }
	}

	[ConvertAs(typeof(MigrateToDataStreamRequest))]
	public partial interface IMigrateToDataStreamRequest : IRequest<MigrateToDataStreamRequestParameters>
	{
	}

	public partial class MigrateToDataStreamRequest : PlainRequestBase<MigrateToDataStreamRequestParameters>, IMigrateToDataStreamRequest
	{
		protected IMigrateToDataStreamRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndexManagementMigrateToDataStream;
		protected override HttpMethod HttpMethod => HttpMethod.POST;
		protected override bool SupportsBody => false;
		protected override bool CanBeEmpty => false;
		protected override bool IsEmpty => false;

		///<summary>/_data_stream/_migrate/{name}</summary>
        public MigrateToDataStreamRequest(Elastic.Clients.Elasticsearch.IndexName name) : base(r => r.Required("name", name))
		{
		}
	}

	[ConvertAs(typeof(OpenRequest))]
	public partial interface IOpenRequest : IRequest<OpenRequestParameters>
	{
	}

	public partial class OpenRequest : PlainRequestBase<OpenRequestParameters>, IOpenRequest
	{
		protected IOpenRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndexManagementOpen;
		protected override HttpMethod HttpMethod => HttpMethod.POST;
		protected override bool SupportsBody => false;
		protected override bool CanBeEmpty => false;
		protected override bool IsEmpty => false;

		///<summary>/{index}/_open</summary>
        public OpenRequest(Elastic.Clients.Elasticsearch.Indices index) : base(r => r.Required("index", index))
		{
		}

		[JsonIgnore]
		public bool? AllowNoIndices { get => Q<bool?>("allow_no_indices"); set => Q("allow_no_indices", value); }

		[JsonIgnore]
		public Elastic.Clients.Elasticsearch.ExpandWildcards? ExpandWildcards { get => Q<Elastic.Clients.Elasticsearch.ExpandWildcards?>("expand_wildcards"); set => Q("expand_wildcards", value); }

		[JsonIgnore]
		public bool? IgnoreUnavailable { get => Q<bool?>("ignore_unavailable"); set => Q("ignore_unavailable", value); }

		[JsonIgnore]
		public Elastic.Clients.Elasticsearch.Time? MasterTimeout { get => Q<Elastic.Clients.Elasticsearch.Time?>("master_timeout"); set => Q("master_timeout", value); }

		[JsonIgnore]
		public Elastic.Clients.Elasticsearch.Time? Timeout { get => Q<Elastic.Clients.Elasticsearch.Time?>("timeout"); set => Q("timeout", value); }

		[JsonIgnore]
		public Elastic.Clients.Elasticsearch.WaitForActiveShards? WaitForActiveShards { get => Q<Elastic.Clients.Elasticsearch.WaitForActiveShards?>("wait_for_active_shards"); set => Q("wait_for_active_shards", value); }
	}

	[ConvertAs(typeof(PromoteDataStreamRequest))]
	public partial interface IPromoteDataStreamRequest : IRequest<PromoteDataStreamRequestParameters>
	{
	}

	public partial class PromoteDataStreamRequest : PlainRequestBase<PromoteDataStreamRequestParameters>, IPromoteDataStreamRequest
	{
		protected IPromoteDataStreamRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndexManagementPromoteDataStream;
		protected override HttpMethod HttpMethod => HttpMethod.POST;
		protected override bool SupportsBody => false;
		protected override bool CanBeEmpty => false;
		protected override bool IsEmpty => false;

		///<summary>/_data_stream/_promote/{name}</summary>
        public PromoteDataStreamRequest(Elastic.Clients.Elasticsearch.IndexName name) : base(r => r.Required("name", name))
		{
		}
	}

	[ConvertAs(typeof(PutAliasRequest))]
	public partial interface IPutAliasRequest : IRequest<PutAliasRequestParameters>
	{
		Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? Filter { get; set; }

		Elastic.Clients.Elasticsearch.Routing? IndexRouting { get; set; }

		bool? IsWriteIndex { get; set; }

		Elastic.Clients.Elasticsearch.Routing? Routing { get; set; }

		Elastic.Clients.Elasticsearch.Routing? SearchRouting { get; set; }
	}

	public partial class PutAliasRequest : PlainRequestBase<PutAliasRequestParameters>, IPutAliasRequest
	{
		protected IPutAliasRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndexManagementPutAlias;
		protected override HttpMethod HttpMethod => HttpMethod.PUT;
		protected override bool SupportsBody => true;
		protected override bool CanBeEmpty => false;
		protected override bool IsEmpty => false;

		///<summary>/{index}/_alias/{name}</summary>
        public PutAliasRequest(Elastic.Clients.Elasticsearch.Indices index, Elastic.Clients.Elasticsearch.Name name) : base(r => r.Required("index", index).Required("name", name))
		{
		}

		[JsonIgnore]
		public Elastic.Clients.Elasticsearch.Time? MasterTimeout { get => Q<Elastic.Clients.Elasticsearch.Time?>("master_timeout"); set => Q("master_timeout", value); }

		[JsonIgnore]
		public Elastic.Clients.Elasticsearch.Time? Timeout { get => Q<Elastic.Clients.Elasticsearch.Time?>("timeout"); set => Q("timeout", value); }

		[JsonPropertyName("filter")]
		public Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? Filter { get; set; }

		[JsonPropertyName("index_routing")]
		public Elastic.Clients.Elasticsearch.Routing? IndexRouting { get; set; }

		[JsonPropertyName("is_write_index")]
		public bool? IsWriteIndex { get; set; }

		[JsonPropertyName("routing")]
		public Elastic.Clients.Elasticsearch.Routing? Routing { get; set; }

		[JsonPropertyName("search_routing")]
		public Elastic.Clients.Elasticsearch.Routing? SearchRouting { get; set; }
	}

	[ConvertAs(typeof(PutIndexTemplateRequest))]
	public partial interface IPutIndexTemplateRequest : IRequest<PutIndexTemplateRequestParameters>
	{
		Elastic.Clients.Elasticsearch.Indices? IndexPatterns { get; set; }

		IEnumerable<Elastic.Clients.Elasticsearch.Name>? ComposedOf { get; set; }

		Elastic.Clients.Elasticsearch.IndexManagement.PutIndexTemplate.IndexTemplateMapping? Template { get; set; }

		Elastic.Clients.Elasticsearch.EmptyObject? DataStream { get; set; }

		int? Priority { get; set; }

		Elastic.Clients.Elasticsearch.VersionNumber? Version { get; set; }

		Elastic.Clients.Elasticsearch.Metadata? Meta { get; set; }
	}

	public partial class PutIndexTemplateRequest : PlainRequestBase<PutIndexTemplateRequestParameters>, IPutIndexTemplateRequest
	{
		protected IPutIndexTemplateRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndexManagementPutIndexTemplate;
		protected override HttpMethod HttpMethod => HttpMethod.PUT;
		protected override bool SupportsBody => true;
		protected override bool CanBeEmpty => false;
		protected override bool IsEmpty => false;

		///<summary>/_index_template/{name}</summary>
        public PutIndexTemplateRequest(Elastic.Clients.Elasticsearch.Name name) : base(r => r.Required("name", name))
		{
		}

		[JsonPropertyName("index_patterns")]
		public Elastic.Clients.Elasticsearch.Indices? IndexPatterns { get; set; }

		[JsonPropertyName("composed_of")]
		public IEnumerable<Elastic.Clients.Elasticsearch.Name>? ComposedOf { get; set; }

		[JsonPropertyName("template")]
		public Elastic.Clients.Elasticsearch.IndexManagement.PutIndexTemplate.IndexTemplateMapping? Template { get; set; }

		[JsonPropertyName("data_stream")]
		public Elastic.Clients.Elasticsearch.EmptyObject? DataStream { get; set; }

		[JsonPropertyName("priority")]
		public int? Priority { get; set; }

		[JsonPropertyName("version")]
		public Elastic.Clients.Elasticsearch.VersionNumber? Version { get; set; }

		[JsonPropertyName("_meta")]
		public Elastic.Clients.Elasticsearch.Metadata? Meta { get; set; }
	}

	[ConvertAs(typeof(PutMappingRequest))]
	public partial interface IPutMappingRequest : IRequest<PutMappingRequestParameters>
	{
		bool? DateDetection { get; set; }

		Union<bool, Elastic.Clients.Elasticsearch.Mapping.DynamicMapping>? Dynamic { get; set; }

		IEnumerable<string>? DynamicDateFormats { get; set; }

		Union<Dictionary<string, Elastic.Clients.Elasticsearch.Mapping.DynamicTemplate>, IEnumerable<Dictionary<string, Elastic.Clients.Elasticsearch.Mapping.DynamicTemplate>>>? DynamicTemplates { get; set; }

		Elastic.Clients.Elasticsearch.Mapping.FieldNamesField? FieldNames { get; set; }

		Dictionary<string, object>? Meta { get; set; }

		bool? NumericDetection { get; set; }

		Dictionary<Elastic.Clients.Elasticsearch.PropertyName, Elastic.Clients.Elasticsearch.Mapping.PropertyBase>? Properties { get; set; }

		Elastic.Clients.Elasticsearch.Mapping.RoutingField? Routing { get; set; }

		Elastic.Clients.Elasticsearch.Mapping.SourceField? Source { get; set; }

		Elastic.Clients.Elasticsearch.Mapping.RuntimeFields? Runtime { get; set; }
	}

	public partial class PutMappingRequest : PlainRequestBase<PutMappingRequestParameters>, IPutMappingRequest
	{
		protected IPutMappingRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndexManagementPutMapping;
		protected override HttpMethod HttpMethod => HttpMethod.PUT;
		protected override bool SupportsBody => true;
		protected override bool CanBeEmpty => false;
		protected override bool IsEmpty => false;

		///<summary>/{index}/_mapping</summary>
        public PutMappingRequest(Elastic.Clients.Elasticsearch.Indices index) : base(r => r.Required("index", index))
		{
		}

		[JsonIgnore]
		public bool? AllowNoIndices { get => Q<bool?>("allow_no_indices"); set => Q("allow_no_indices", value); }

		[JsonIgnore]
		public Elastic.Clients.Elasticsearch.ExpandWildcards? ExpandWildcards { get => Q<Elastic.Clients.Elasticsearch.ExpandWildcards?>("expand_wildcards"); set => Q("expand_wildcards", value); }

		[JsonIgnore]
		public bool? IgnoreUnavailable { get => Q<bool?>("ignore_unavailable"); set => Q("ignore_unavailable", value); }

		[JsonIgnore]
		public bool? IncludeTypeName { get => Q<bool?>("include_type_name"); set => Q("include_type_name", value); }

		[JsonIgnore]
		public Elastic.Clients.Elasticsearch.Time? MasterTimeout { get => Q<Elastic.Clients.Elasticsearch.Time?>("master_timeout"); set => Q("master_timeout", value); }

		[JsonIgnore]
		public Elastic.Clients.Elasticsearch.Time? Timeout { get => Q<Elastic.Clients.Elasticsearch.Time?>("timeout"); set => Q("timeout", value); }

		[JsonIgnore]
		public bool? WriteIndexOnly { get => Q<bool?>("write_index_only"); set => Q("write_index_only", value); }

		[JsonPropertyName("date_detection")]
		public bool? DateDetection { get; set; }

		[JsonPropertyName("dynamic")]
		public Union<bool, Elastic.Clients.Elasticsearch.Mapping.DynamicMapping>? Dynamic { get; set; }

		[JsonPropertyName("dynamic_date_formats")]
		public IEnumerable<string>? DynamicDateFormats { get; set; }

		[JsonPropertyName("dynamic_templates")]
		public Union<Dictionary<string, Elastic.Clients.Elasticsearch.Mapping.DynamicTemplate>, IEnumerable<Dictionary<string, Elastic.Clients.Elasticsearch.Mapping.DynamicTemplate>>>? DynamicTemplates { get; set; }

		[JsonPropertyName("_field_names")]
		public Elastic.Clients.Elasticsearch.Mapping.FieldNamesField? FieldNames { get; set; }

		[JsonPropertyName("_meta")]
		public Dictionary<string, object>? Meta { get; set; }

		[JsonPropertyName("numeric_detection")]
		public bool? NumericDetection { get; set; }

		[JsonPropertyName("properties")]
		public Dictionary<Elastic.Clients.Elasticsearch.PropertyName, Elastic.Clients.Elasticsearch.Mapping.PropertyBase>? Properties { get; set; }

		[JsonPropertyName("_routing")]
		public Elastic.Clients.Elasticsearch.Mapping.RoutingField? Routing { get; set; }

		[JsonPropertyName("_source")]
		public Elastic.Clients.Elasticsearch.Mapping.SourceField? Source { get; set; }

		[JsonPropertyName("runtime")]
		public Elastic.Clients.Elasticsearch.Mapping.RuntimeFields? Runtime { get; set; }
	}

	[ConvertAs(typeof(PutSettingsRequest))]
	public partial interface IPutSettingsRequest : IRequest<PutSettingsRequestParameters>
	{
	}

	public partial class PutSettingsRequest : PlainRequestBase<PutSettingsRequestParameters>, IPutSettingsRequest
	{
		protected IPutSettingsRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndexManagementPutSettings;
		protected override HttpMethod HttpMethod => HttpMethod.PUT;
		protected override bool SupportsBody => false;
		protected override bool CanBeEmpty => true;
		protected override bool IsEmpty => true;

		///<summary>/_settings</summary>
        public PutSettingsRequest() : base()
		{
		}

		///<summary>/{index}/_settings</summary>
        public PutSettingsRequest(Elastic.Clients.Elasticsearch.Indices? index) : base(r => r.Optional("index", index))
		{
		}

		[JsonIgnore]
		public bool? AllowNoIndices { get => Q<bool?>("allow_no_indices"); set => Q("allow_no_indices", value); }

		[JsonIgnore]
		public Elastic.Clients.Elasticsearch.ExpandWildcards? ExpandWildcards { get => Q<Elastic.Clients.Elasticsearch.ExpandWildcards?>("expand_wildcards"); set => Q("expand_wildcards", value); }

		[JsonIgnore]
		public bool? FlatSettings { get => Q<bool?>("flat_settings"); set => Q("flat_settings", value); }

		[JsonIgnore]
		public bool? IgnoreUnavailable { get => Q<bool?>("ignore_unavailable"); set => Q("ignore_unavailable", value); }

		[JsonIgnore]
		public Elastic.Clients.Elasticsearch.Time? MasterTimeout { get => Q<Elastic.Clients.Elasticsearch.Time?>("master_timeout"); set => Q("master_timeout", value); }

		[JsonIgnore]
		public bool? PreserveExisting { get => Q<bool?>("preserve_existing"); set => Q("preserve_existing", value); }

		[JsonIgnore]
		public Elastic.Clients.Elasticsearch.Time? Timeout { get => Q<Elastic.Clients.Elasticsearch.Time?>("timeout"); set => Q("timeout", value); }
	}

	[ConvertAs(typeof(PutTemplateRequest))]
	public partial interface IPutTemplateRequest : IRequest<PutTemplateRequestParameters>
	{
		Dictionary<Elastic.Clients.Elasticsearch.IndexName, Elastic.Clients.Elasticsearch.IndexManagement.Alias>? Aliases { get; set; }

		Union<string, IEnumerable<string>>? IndexPatterns { get; set; }

		Elastic.Clients.Elasticsearch.Mapping.TypeMapping? Mappings { get; set; }

		int? Order { get; set; }

		Dictionary<string, object>? Settings { get; set; }

		Elastic.Clients.Elasticsearch.VersionNumber? Version { get; set; }
	}

	public partial class PutTemplateRequest : PlainRequestBase<PutTemplateRequestParameters>, IPutTemplateRequest
	{
		protected IPutTemplateRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndexManagementPutTemplate;
		protected override HttpMethod HttpMethod => HttpMethod.PUT;
		protected override bool SupportsBody => true;
		protected override bool CanBeEmpty => false;
		protected override bool IsEmpty => false;

		///<summary>/_template/{name}</summary>
        public PutTemplateRequest(Elastic.Clients.Elasticsearch.Name name) : base(r => r.Required("name", name))
		{
		}

		[JsonIgnore]
		public bool? Create { get => Q<bool?>("create"); set => Q("create", value); }

		[JsonIgnore]
		public bool? FlatSettings { get => Q<bool?>("flat_settings"); set => Q("flat_settings", value); }

		[JsonIgnore]
		public bool? IncludeTypeName { get => Q<bool?>("include_type_name"); set => Q("include_type_name", value); }

		[JsonIgnore]
		public Elastic.Clients.Elasticsearch.Time? MasterTimeout { get => Q<Elastic.Clients.Elasticsearch.Time?>("master_timeout"); set => Q("master_timeout", value); }

		[JsonIgnore]
		public Elastic.Clients.Elasticsearch.Time? Timeout { get => Q<Elastic.Clients.Elasticsearch.Time?>("timeout"); set => Q("timeout", value); }

		[JsonPropertyName("aliases")]
		public Dictionary<Elastic.Clients.Elasticsearch.IndexName, Elastic.Clients.Elasticsearch.IndexManagement.Alias>? Aliases { get; set; }

		[JsonPropertyName("index_patterns")]
		public Union<string, IEnumerable<string>>? IndexPatterns { get; set; }

		[JsonPropertyName("mappings")]
		public Elastic.Clients.Elasticsearch.Mapping.TypeMapping? Mappings { get; set; }

		[JsonPropertyName("order")]
		public int? Order { get; set; }

		[JsonPropertyName("settings")]
		public Dictionary<string, object>? Settings { get; set; }

		[JsonPropertyName("version")]
		public Elastic.Clients.Elasticsearch.VersionNumber? Version { get; set; }
	}

	[ConvertAs(typeof(RecoveryRequest))]
	public partial interface IRecoveryRequest : IRequest<RecoveryRequestParameters>
	{
	}

	public partial class RecoveryRequest : PlainRequestBase<RecoveryRequestParameters>, IRecoveryRequest
	{
		protected IRecoveryRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndexManagementRecovery;
		protected override HttpMethod HttpMethod => HttpMethod.GET;
		protected override bool SupportsBody => false;
		protected override bool CanBeEmpty => true;
		protected override bool IsEmpty => true;

		///<summary>/_recovery</summary>
        public RecoveryRequest() : base()
		{
		}

		///<summary>/{index}/_recovery</summary>
        public RecoveryRequest(Elastic.Clients.Elasticsearch.Indices? index) : base(r => r.Optional("index", index))
		{
		}

		[JsonIgnore]
		public bool? ActiveOnly { get => Q<bool?>("active_only"); set => Q("active_only", value); }

		[JsonIgnore]
		public bool? Detailed { get => Q<bool?>("detailed"); set => Q("detailed", value); }
	}

	[ConvertAs(typeof(RefreshRequest))]
	public partial interface IRefreshRequest : IRequest<RefreshRequestParameters>
	{
	}

	public partial class RefreshRequest : PlainRequestBase<RefreshRequestParameters>, IRefreshRequest
	{
		protected IRefreshRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndexManagementRefresh;
		protected override HttpMethod HttpMethod => HttpMethod.POST;
		protected override bool SupportsBody => false;
		protected override bool CanBeEmpty => true;
		protected override bool IsEmpty => true;

		///<summary>/_refresh</summary>
        public RefreshRequest() : base()
		{
		}

		///<summary>/{index}/_refresh</summary>
        public RefreshRequest(Elastic.Clients.Elasticsearch.Indices? index) : base(r => r.Optional("index", index))
		{
		}

		[JsonIgnore]
		public bool? AllowNoIndices { get => Q<bool?>("allow_no_indices"); set => Q("allow_no_indices", value); }

		[JsonIgnore]
		public Elastic.Clients.Elasticsearch.ExpandWildcards? ExpandWildcards { get => Q<Elastic.Clients.Elasticsearch.ExpandWildcards?>("expand_wildcards"); set => Q("expand_wildcards", value); }

		[JsonIgnore]
		public bool? IgnoreUnavailable { get => Q<bool?>("ignore_unavailable"); set => Q("ignore_unavailable", value); }
	}

	[ConvertAs(typeof(ReloadSearchAnalyzersRequest))]
	public partial interface IReloadSearchAnalyzersRequest : IRequest<ReloadSearchAnalyzersRequestParameters>
	{
	}

	public partial class ReloadSearchAnalyzersRequest : PlainRequestBase<ReloadSearchAnalyzersRequestParameters>, IReloadSearchAnalyzersRequest
	{
		protected IReloadSearchAnalyzersRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndexManagementReloadSearchAnalyzers;
		protected override HttpMethod HttpMethod => HttpMethod.POST;
		protected override bool SupportsBody => false;
		protected override bool CanBeEmpty => false;
		protected override bool IsEmpty => false;

		///<summary>/{index}/_reload_search_analyzers</summary>
        public ReloadSearchAnalyzersRequest(Elastic.Clients.Elasticsearch.Indices index) : base(r => r.Required("index", index))
		{
		}

		[JsonIgnore]
		public bool? AllowNoIndices { get => Q<bool?>("allow_no_indices"); set => Q("allow_no_indices", value); }

		[JsonIgnore]
		public Elastic.Clients.Elasticsearch.ExpandWildcards? ExpandWildcards { get => Q<Elastic.Clients.Elasticsearch.ExpandWildcards?>("expand_wildcards"); set => Q("expand_wildcards", value); }

		[JsonIgnore]
		public bool? IgnoreUnavailable { get => Q<bool?>("ignore_unavailable"); set => Q("ignore_unavailable", value); }
	}

	[ConvertAs(typeof(ResolveIndexRequest))]
	public partial interface IResolveIndexRequest : IRequest<ResolveIndexRequestParameters>
	{
	}

	public partial class ResolveIndexRequest : PlainRequestBase<ResolveIndexRequestParameters>, IResolveIndexRequest
	{
		protected IResolveIndexRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndexManagementResolveIndex;
		protected override HttpMethod HttpMethod => HttpMethod.GET;
		protected override bool SupportsBody => false;
		protected override bool CanBeEmpty => false;
		protected override bool IsEmpty => false;

		///<summary>/_resolve/index/{name}</summary>
        public ResolveIndexRequest(Elastic.Clients.Elasticsearch.Names name) : base(r => r.Required("name", name))
		{
		}

		[JsonIgnore]
		public Elastic.Clients.Elasticsearch.ExpandWildcards? ExpandWildcards { get => Q<Elastic.Clients.Elasticsearch.ExpandWildcards?>("expand_wildcards"); set => Q("expand_wildcards", value); }
	}

	[ConvertAs(typeof(RolloverRequest))]
	public partial interface IRolloverRequest : IRequest<RolloverRequestParameters>
	{
		Dictionary<Elastic.Clients.Elasticsearch.IndexName, Elastic.Clients.Elasticsearch.IndexManagement.Alias>? Aliases { get; set; }

		Elastic.Clients.Elasticsearch.IndexManagement.Rollover.RolloverConditions? Conditions { get; set; }

		Union<Dictionary<string, Elastic.Clients.Elasticsearch.Mapping.TypeMapping>, Elastic.Clients.Elasticsearch.Mapping.TypeMapping>? Mappings { get; set; }

		Dictionary<string, object>? Settings { get; set; }
	}

	public partial class RolloverRequest : PlainRequestBase<RolloverRequestParameters>, IRolloverRequest
	{
		protected IRolloverRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndexManagementRollover;
		protected override HttpMethod HttpMethod => HttpMethod.POST;
		protected override bool SupportsBody => true;
		protected override bool CanBeEmpty => false;
		protected override bool IsEmpty => false;

		///<summary>/{alias}/_rollover</summary>
        public RolloverRequest(Elastic.Clients.Elasticsearch.IndexAlias alias) : base(r => r.Required("alias", alias))
		{
		}

		///<summary>/{alias}/_rollover/{new_index}</summary>
        public RolloverRequest(Elastic.Clients.Elasticsearch.IndexAlias alias, Elastic.Clients.Elasticsearch.IndexName? new_index) : base(r => r.Required("alias", alias).Optional("new_index", new_index))
		{
		}

		[JsonIgnore]
		public bool? DryRun { get => Q<bool?>("dry_run"); set => Q("dry_run", value); }

		[JsonIgnore]
		public bool? IncludeTypeName { get => Q<bool?>("include_type_name"); set => Q("include_type_name", value); }

		[JsonIgnore]
		public Elastic.Clients.Elasticsearch.Time? MasterTimeout { get => Q<Elastic.Clients.Elasticsearch.Time?>("master_timeout"); set => Q("master_timeout", value); }

		[JsonIgnore]
		public Elastic.Clients.Elasticsearch.Time? Timeout { get => Q<Elastic.Clients.Elasticsearch.Time?>("timeout"); set => Q("timeout", value); }

		[JsonIgnore]
		public Elastic.Clients.Elasticsearch.WaitForActiveShards? WaitForActiveShards { get => Q<Elastic.Clients.Elasticsearch.WaitForActiveShards?>("wait_for_active_shards"); set => Q("wait_for_active_shards", value); }

		[JsonPropertyName("aliases")]
		public Dictionary<Elastic.Clients.Elasticsearch.IndexName, Elastic.Clients.Elasticsearch.IndexManagement.Alias>? Aliases { get; set; }

		[JsonPropertyName("conditions")]
		public Elastic.Clients.Elasticsearch.IndexManagement.Rollover.RolloverConditions? Conditions { get; set; }

		[JsonPropertyName("mappings")]
		public Union<Dictionary<string, Elastic.Clients.Elasticsearch.Mapping.TypeMapping>, Elastic.Clients.Elasticsearch.Mapping.TypeMapping>? Mappings { get; set; }

		[JsonPropertyName("settings")]
		public Dictionary<string, object>? Settings { get; set; }
	}

	[ConvertAs(typeof(SegmentsRequest))]
	public partial interface ISegmentsRequest : IRequest<SegmentsRequestParameters>
	{
	}

	public partial class SegmentsRequest : PlainRequestBase<SegmentsRequestParameters>, ISegmentsRequest
	{
		protected ISegmentsRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndexManagementSegments;
		protected override HttpMethod HttpMethod => HttpMethod.GET;
		protected override bool SupportsBody => false;
		protected override bool CanBeEmpty => true;
		protected override bool IsEmpty => true;

		///<summary>/_segments</summary>
        public SegmentsRequest() : base()
		{
		}

		///<summary>/{index}/_segments</summary>
        public SegmentsRequest(Elastic.Clients.Elasticsearch.Indices? index) : base(r => r.Optional("index", index))
		{
		}

		[JsonIgnore]
		public bool? AllowNoIndices { get => Q<bool?>("allow_no_indices"); set => Q("allow_no_indices", value); }

		[JsonIgnore]
		public Elastic.Clients.Elasticsearch.ExpandWildcards? ExpandWildcards { get => Q<Elastic.Clients.Elasticsearch.ExpandWildcards?>("expand_wildcards"); set => Q("expand_wildcards", value); }

		[JsonIgnore]
		public bool? IgnoreUnavailable { get => Q<bool?>("ignore_unavailable"); set => Q("ignore_unavailable", value); }

		[JsonIgnore]
		public bool? Verbose { get => Q<bool?>("verbose"); set => Q("verbose", value); }
	}

	[ConvertAs(typeof(ShardStoresRequest))]
	public partial interface IShardStoresRequest : IRequest<ShardStoresRequestParameters>
	{
	}

	public partial class ShardStoresRequest : PlainRequestBase<ShardStoresRequestParameters>, IShardStoresRequest
	{
		protected IShardStoresRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndexManagementShardStores;
		protected override HttpMethod HttpMethod => HttpMethod.GET;
		protected override bool SupportsBody => false;
		protected override bool CanBeEmpty => true;
		protected override bool IsEmpty => true;

		///<summary>/_shard_stores</summary>
        public ShardStoresRequest() : base()
		{
		}

		///<summary>/{index}/_shard_stores</summary>
        public ShardStoresRequest(Elastic.Clients.Elasticsearch.Indices? index) : base(r => r.Optional("index", index))
		{
		}

		[JsonIgnore]
		public bool? AllowNoIndices { get => Q<bool?>("allow_no_indices"); set => Q("allow_no_indices", value); }

		[JsonIgnore]
		public Elastic.Clients.Elasticsearch.ExpandWildcards? ExpandWildcards { get => Q<Elastic.Clients.Elasticsearch.ExpandWildcards?>("expand_wildcards"); set => Q("expand_wildcards", value); }

		[JsonIgnore]
		public bool? IgnoreUnavailable { get => Q<bool?>("ignore_unavailable"); set => Q("ignore_unavailable", value); }

		[JsonIgnore]
		public Union<string, IEnumerable<string>>? Status { get => Q<Union<string, IEnumerable<string>>?>("status"); set => Q("status", value); }
	}

	[ConvertAs(typeof(ShrinkRequest))]
	public partial interface IShrinkRequest : IRequest<ShrinkRequestParameters>
	{
		Dictionary<Elastic.Clients.Elasticsearch.IndexName, Elastic.Clients.Elasticsearch.IndexManagement.Alias>? Aliases { get; set; }

		Dictionary<string, object>? Settings { get; set; }
	}

	public partial class ShrinkRequest : PlainRequestBase<ShrinkRequestParameters>, IShrinkRequest
	{
		protected IShrinkRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndexManagementShrink;
		protected override HttpMethod HttpMethod => HttpMethod.PUT;
		protected override bool SupportsBody => true;
		protected override bool CanBeEmpty => false;
		protected override bool IsEmpty => false;

		///<summary>/{index}/_shrink/{target}</summary>
        public ShrinkRequest(Elastic.Clients.Elasticsearch.IndexName index, Elastic.Clients.Elasticsearch.IndexName target) : base(r => r.Required("index", index).Required("target", target))
		{
		}

		[JsonIgnore]
		public Elastic.Clients.Elasticsearch.Time? MasterTimeout { get => Q<Elastic.Clients.Elasticsearch.Time?>("master_timeout"); set => Q("master_timeout", value); }

		[JsonIgnore]
		public Elastic.Clients.Elasticsearch.Time? Timeout { get => Q<Elastic.Clients.Elasticsearch.Time?>("timeout"); set => Q("timeout", value); }

		[JsonIgnore]
		public Elastic.Clients.Elasticsearch.WaitForActiveShards? WaitForActiveShards { get => Q<Elastic.Clients.Elasticsearch.WaitForActiveShards?>("wait_for_active_shards"); set => Q("wait_for_active_shards", value); }

		[JsonPropertyName("aliases")]
		public Dictionary<Elastic.Clients.Elasticsearch.IndexName, Elastic.Clients.Elasticsearch.IndexManagement.Alias>? Aliases { get; set; }

		[JsonPropertyName("settings")]
		public Dictionary<string, object>? Settings { get; set; }
	}

	[ConvertAs(typeof(SimulateIndexTemplateRequest))]
	public partial interface ISimulateIndexTemplateRequest : IRequest<SimulateIndexTemplateRequestParameters>
	{
		IEnumerable<Elastic.Clients.Elasticsearch.IndexName>? IndexPatterns { get; set; }

		IEnumerable<Elastic.Clients.Elasticsearch.Name>? ComposedOf { get; set; }

		IEnumerable<Elastic.Clients.Elasticsearch.IndexManagement.OverlappingIndexTemplate>? Overlapping { get; set; }

		Elastic.Clients.Elasticsearch.IndexManagement.TemplateMapping? Template { get; set; }
	}

	public partial class SimulateIndexTemplateRequest : PlainRequestBase<SimulateIndexTemplateRequestParameters>, ISimulateIndexTemplateRequest
	{
		protected ISimulateIndexTemplateRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndexManagementSimulateIndexTemplate;
		protected override HttpMethod HttpMethod => HttpMethod.POST;
		protected override bool SupportsBody => true;
		protected override bool CanBeEmpty => false;
		protected override bool IsEmpty => false;

		///<summary>/_index_template/_simulate_index/{name}</summary>
        public SimulateIndexTemplateRequest(Elastic.Clients.Elasticsearch.Name name) : base(r => r.Required("name", name))
		{
		}

		[JsonPropertyName("index_patterns")]
		public IEnumerable<Elastic.Clients.Elasticsearch.IndexName>? IndexPatterns { get; set; }

		[JsonPropertyName("composed_of")]
		public IEnumerable<Elastic.Clients.Elasticsearch.Name>? ComposedOf { get; set; }

		[JsonPropertyName("overlapping")]
		public IEnumerable<Elastic.Clients.Elasticsearch.IndexManagement.OverlappingIndexTemplate>? Overlapping { get; set; }

		[JsonPropertyName("template")]
		public Elastic.Clients.Elasticsearch.IndexManagement.TemplateMapping? Template { get; set; }
	}

	[ConvertAs(typeof(SimulateTemplateRequest))]
	public partial interface ISimulateTemplateRequest : IRequest<SimulateTemplateRequestParameters>
	{
	}

	public partial class SimulateTemplateRequest : PlainRequestBase<SimulateTemplateRequestParameters>, ISimulateTemplateRequest
	{
		protected ISimulateTemplateRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndexManagementSimulateTemplate;
		protected override HttpMethod HttpMethod => HttpMethod.POST;
		protected override bool SupportsBody => false;
		protected override bool CanBeEmpty => true;
		protected override bool IsEmpty => true;

		///<summary>/_index_template/_simulate</summary>
        public SimulateTemplateRequest() : base()
		{
		}

		///<summary>/_index_template/_simulate/{name}</summary>
        public SimulateTemplateRequest(Elastic.Clients.Elasticsearch.Name? name) : base(r => r.Optional("name", name))
		{
		}

		[JsonIgnore]
		public bool? Create { get => Q<bool?>("create"); set => Q("create", value); }

		[JsonIgnore]
		public Elastic.Clients.Elasticsearch.Time? MasterTimeout { get => Q<Elastic.Clients.Elasticsearch.Time?>("master_timeout"); set => Q("master_timeout", value); }
	}

	[ConvertAs(typeof(SplitRequest))]
	public partial interface ISplitRequest : IRequest<SplitRequestParameters>
	{
		Dictionary<Elastic.Clients.Elasticsearch.IndexName, Elastic.Clients.Elasticsearch.IndexManagement.Alias>? Aliases { get; set; }

		Dictionary<string, object>? Settings { get; set; }
	}

	public partial class SplitRequest : PlainRequestBase<SplitRequestParameters>, ISplitRequest
	{
		protected ISplitRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndexManagementSplit;
		protected override HttpMethod HttpMethod => HttpMethod.PUT;
		protected override bool SupportsBody => true;
		protected override bool CanBeEmpty => false;
		protected override bool IsEmpty => false;

		///<summary>/{index}/_split/{target}</summary>
        public SplitRequest(Elastic.Clients.Elasticsearch.IndexName index, Elastic.Clients.Elasticsearch.IndexName target) : base(r => r.Required("index", index).Required("target", target))
		{
		}

		[JsonIgnore]
		public Elastic.Clients.Elasticsearch.Time? MasterTimeout { get => Q<Elastic.Clients.Elasticsearch.Time?>("master_timeout"); set => Q("master_timeout", value); }

		[JsonIgnore]
		public Elastic.Clients.Elasticsearch.Time? Timeout { get => Q<Elastic.Clients.Elasticsearch.Time?>("timeout"); set => Q("timeout", value); }

		[JsonIgnore]
		public Elastic.Clients.Elasticsearch.WaitForActiveShards? WaitForActiveShards { get => Q<Elastic.Clients.Elasticsearch.WaitForActiveShards?>("wait_for_active_shards"); set => Q("wait_for_active_shards", value); }

		[JsonPropertyName("aliases")]
		public Dictionary<Elastic.Clients.Elasticsearch.IndexName, Elastic.Clients.Elasticsearch.IndexManagement.Alias>? Aliases { get; set; }

		[JsonPropertyName("settings")]
		public Dictionary<string, object>? Settings { get; set; }
	}

	[ConvertAs(typeof(StatsRequest))]
	public partial interface IStatsRequest : IRequest<StatsRequestParameters>
	{
	}

	public partial class StatsRequest : PlainRequestBase<StatsRequestParameters>, IStatsRequest
	{
		protected IStatsRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndexManagementStats;
		protected override HttpMethod HttpMethod => HttpMethod.GET;
		protected override bool SupportsBody => false;
		protected override bool CanBeEmpty => true;
		protected override bool IsEmpty => true;

		///<summary>/_stats</summary>
        public StatsRequest() : base()
		{
		}

		///<summary>/_stats/{metric}</summary>
        public StatsRequest(Elastic.Clients.Elasticsearch.Metrics? metric) : base(r => r.Optional("metric", metric))
		{
		}

		///<summary>/{index}/_stats</summary>
        public StatsRequest(Elastic.Clients.Elasticsearch.Indices? index) : base(r => r.Optional("index", index))
		{
		}

		///<summary>/{index}/_stats/{metric}</summary>
        public StatsRequest(Elastic.Clients.Elasticsearch.Indices? index, Elastic.Clients.Elasticsearch.Metrics? metric) : base(r => r.Optional("index", index).Optional("metric", metric))
		{
		}

		[JsonIgnore]
		public Elastic.Clients.Elasticsearch.Fields? CompletionFields { get => Q<Elastic.Clients.Elasticsearch.Fields?>("completion_fields"); set => Q("completion_fields", value); }

		[JsonIgnore]
		public Elastic.Clients.Elasticsearch.ExpandWildcards? ExpandWildcards { get => Q<Elastic.Clients.Elasticsearch.ExpandWildcards?>("expand_wildcards"); set => Q("expand_wildcards", value); }

		[JsonIgnore]
		public Elastic.Clients.Elasticsearch.Fields? FielddataFields { get => Q<Elastic.Clients.Elasticsearch.Fields?>("fielddata_fields"); set => Q("fielddata_fields", value); }

		[JsonIgnore]
		public Elastic.Clients.Elasticsearch.Fields? Fields { get => Q<Elastic.Clients.Elasticsearch.Fields?>("fields"); set => Q("fields", value); }

		[JsonIgnore]
		public bool? ForbidClosedIndices { get => Q<bool?>("forbid_closed_indices"); set => Q("forbid_closed_indices", value); }

		[JsonIgnore]
		public Union<string, IEnumerable<string>>? Groups { get => Q<Union<string, IEnumerable<string>>?>("groups"); set => Q("groups", value); }

		[JsonIgnore]
		public bool? IncludeSegmentFileSizes { get => Q<bool?>("include_segment_file_sizes"); set => Q("include_segment_file_sizes", value); }

		[JsonIgnore]
		public bool? IncludeUnloadedSegments { get => Q<bool?>("include_unloaded_segments"); set => Q("include_unloaded_segments", value); }

		[JsonIgnore]
		public Elastic.Clients.Elasticsearch.Level? Level { get => Q<Elastic.Clients.Elasticsearch.Level?>("level"); set => Q("level", value); }
	}

	[ConvertAs(typeof(UpdateAliasesRequest))]
	public partial interface IUpdateAliasesRequest : IRequest<UpdateAliasesRequestParameters>
	{
		IEnumerable<Elastic.Clients.Elasticsearch.IndexManagement.UpdateAliases.IndicesUpdateAliasBulk>? Actions { get; set; }
	}

	public partial class UpdateAliasesRequest : PlainRequestBase<UpdateAliasesRequestParameters>, IUpdateAliasesRequest
	{
		protected IUpdateAliasesRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndexManagementUpdateAliases;
		protected override HttpMethod HttpMethod => HttpMethod.POST;
		protected override bool SupportsBody => true;
		protected override bool CanBeEmpty => true;
		protected override bool IsEmpty => true;

		///<summary>/_aliases</summary>
        public UpdateAliasesRequest() : base()
		{
		}

		[JsonIgnore]
		public Elastic.Clients.Elasticsearch.Time? MasterTimeout { get => Q<Elastic.Clients.Elasticsearch.Time?>("master_timeout"); set => Q("master_timeout", value); }

		[JsonIgnore]
		public Elastic.Clients.Elasticsearch.Time? Timeout { get => Q<Elastic.Clients.Elasticsearch.Time?>("timeout"); set => Q("timeout", value); }

		[JsonPropertyName("actions")]
		public IEnumerable<Elastic.Clients.Elasticsearch.IndexManagement.UpdateAliases.IndicesUpdateAliasBulk>? Actions { get; set; }
	}

	[ConvertAs(typeof(ValidateQueryRequest))]
	public partial interface IValidateQueryRequest : IRequest<ValidateQueryRequestParameters>
	{
		Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? Query { get; set; }
	}

	public partial class ValidateQueryRequest : PlainRequestBase<ValidateQueryRequestParameters>, IValidateQueryRequest
	{
		protected IValidateQueryRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndexManagementValidateQuery;
		protected override HttpMethod HttpMethod => HttpMethod.POST;
		protected override bool SupportsBody => true;
		protected override bool CanBeEmpty => true;
		protected override bool IsEmpty => Query is null;

		///<summary>/_validate/query</summary>
        public ValidateQueryRequest() : base()
		{
		}

		///<summary>/{index}/_validate/query</summary>
        public ValidateQueryRequest(Elastic.Clients.Elasticsearch.Indices? index) : base(r => r.Optional("index", index))
		{
		}

		[JsonIgnore]
		public bool? AllowNoIndices { get => Q<bool?>("allow_no_indices"); set => Q("allow_no_indices", value); }

		[JsonIgnore]
		public bool? AllShards { get => Q<bool?>("all_shards"); set => Q("all_shards", value); }

		[JsonIgnore]
		public string? Analyzer { get => Q<string?>("analyzer"); set => Q("analyzer", value); }

		[JsonIgnore]
		public bool? AnalyzeWildcard { get => Q<bool?>("analyze_wildcard"); set => Q("analyze_wildcard", value); }

		[JsonIgnore]
		public Elastic.Clients.Elasticsearch.DefaultOperator? DefaultOperator { get => Q<Elastic.Clients.Elasticsearch.DefaultOperator?>("default_operator"); set => Q("default_operator", value); }

		[JsonIgnore]
		public string? Df { get => Q<string?>("df"); set => Q("df", value); }

		[JsonIgnore]
		public Elastic.Clients.Elasticsearch.ExpandWildcards? ExpandWildcards { get => Q<Elastic.Clients.Elasticsearch.ExpandWildcards?>("expand_wildcards"); set => Q("expand_wildcards", value); }

		[JsonIgnore]
		public bool? Explain { get => Q<bool?>("explain"); set => Q("explain", value); }

		[JsonIgnore]
		public bool? IgnoreUnavailable { get => Q<bool?>("ignore_unavailable"); set => Q("ignore_unavailable", value); }

		[JsonIgnore]
		public bool? Lenient { get => Q<bool?>("lenient"); set => Q("lenient", value); }

		[JsonIgnore]
		public string? QueryOnQueryString { get => Q<string?>("query_on_query_string"); set => Q("query_on_query_string", value); }

		[JsonIgnore]
		public bool? Rewrite { get => Q<bool?>("rewrite"); set => Q("rewrite", value); }

		[JsonIgnore]
		public string? LuceneQueryString { get => Q<string?>("q"); set => Q("q", value); }

		[JsonPropertyName("query")]
		public Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? Query { get; set; }
	}
}