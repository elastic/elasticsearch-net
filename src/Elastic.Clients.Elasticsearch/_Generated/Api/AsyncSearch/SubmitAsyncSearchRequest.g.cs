// Licensed to Elasticsearch B.V under one or more agreements.
// Elasticsearch B.V licenses this file to you under the Apache 2.0 License.
// See the LICENSE file in the project root for more information.
//
// ███╗   ██╗ ██████╗ ████████╗██╗ ██████╗███████╗
// ████╗  ██║██╔═══██╗╚══██╔══╝██║██╔════╝██╔════╝
// ██╔██╗ ██║██║   ██║   ██║   ██║██║     █████╗
// ██║╚██╗██║██║   ██║   ██║   ██║██║     ██╔══╝
// ██║ ╚████║╚██████╔╝   ██║   ██║╚██████╗███████╗
// ╚═╝  ╚═══╝ ╚═════╝    ╚═╝   ╚═╝ ╚═════╝╚══════╝
// ------------------------------------------------
//
// This file is automatically generated.
// Please do not edit these files manually.
//
// ------------------------------------------------

#nullable restore

using Elastic.Clients.Elasticsearch.Fluent;
using Elastic.Clients.Elasticsearch.Requests;
using Elastic.Clients.Elasticsearch.Serialization;
using Elastic.Transport;
using Elastic.Transport.Extensions;
using System;
using System.Collections.Generic;
using System.Linq.Expressions;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace Elastic.Clients.Elasticsearch.AsyncSearch;

public sealed partial class SubmitAsyncSearchRequestParameters : RequestParameters
{
	/// <summary>
	/// <para>
	/// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes <c>_all</c> string or when no indices have been specified)
	/// </para>
	/// </summary>
	public bool? AllowNoIndices { get => Q<bool?>("allow_no_indices"); set => Q("allow_no_indices", value); }

	/// <summary>
	/// <para>
	/// Indicate if an error should be returned if there is a partial search failure or timeout
	/// </para>
	/// </summary>
	public bool? AllowPartialSearchResults { get => Q<bool?>("allow_partial_search_results"); set => Q("allow_partial_search_results", value); }

	/// <summary>
	/// <para>
	/// The analyzer to use for the query string
	/// </para>
	/// </summary>
	public string? Analyzer { get => Q<string?>("analyzer"); set => Q("analyzer", value); }

	/// <summary>
	/// <para>
	/// Specify whether wildcard and prefix queries should be analyzed (default: false)
	/// </para>
	/// </summary>
	public bool? AnalyzeWildcard { get => Q<bool?>("analyze_wildcard"); set => Q("analyze_wildcard", value); }

	/// <summary>
	/// <para>
	/// Affects how often partial results become available, which happens whenever shard results are reduced.
	/// A partial reduction is performed every time the coordinating node has received a certain number of new shard responses (5 by default).
	/// </para>
	/// </summary>
	public long? BatchedReduceSize { get => Q<long?>("batched_reduce_size"); set => Q("batched_reduce_size", value); }

	/// <summary>
	/// <para>
	/// The default value is the only supported value.
	/// </para>
	/// </summary>
	public bool? CcsMinimizeRoundtrips { get => Q<bool?>("ccs_minimize_roundtrips"); set => Q("ccs_minimize_roundtrips", value); }

	/// <summary>
	/// <para>
	/// The default operator for query string query (AND or OR)
	/// </para>
	/// </summary>
	public Elastic.Clients.Elasticsearch.QueryDsl.Operator? DefaultOperator { get => Q<Elastic.Clients.Elasticsearch.QueryDsl.Operator?>("default_operator"); set => Q("default_operator", value); }

	/// <summary>
	/// <para>
	/// The field to use as default where no field prefix is given in the query string
	/// </para>
	/// </summary>
	public string? Df { get => Q<string?>("df"); set => Q("df", value); }

	/// <summary>
	/// <para>
	/// Whether to expand wildcard expression to concrete indices that are open, closed or both.
	/// </para>
	/// </summary>
	public ICollection<Elastic.Clients.Elasticsearch.ExpandWildcard>? ExpandWildcards { get => Q<ICollection<Elastic.Clients.Elasticsearch.ExpandWildcard>?>("expand_wildcards"); set => Q("expand_wildcards", value); }

	/// <summary>
	/// <para>
	/// Whether specified concrete, expanded or aliased indices should be ignored when throttled
	/// </para>
	/// </summary>
	public bool? IgnoreThrottled { get => Q<bool?>("ignore_throttled"); set => Q("ignore_throttled", value); }

	/// <summary>
	/// <para>
	/// Whether specified concrete indices should be ignored when unavailable (missing or closed)
	/// </para>
	/// </summary>
	public bool? IgnoreUnavailable { get => Q<bool?>("ignore_unavailable"); set => Q("ignore_unavailable", value); }

	/// <summary>
	/// <para>
	/// If <c>true</c>, results are stored for later retrieval when the search completes within the <c>wait_for_completion_timeout</c>.
	/// </para>
	/// </summary>
	public bool? KeepOnCompletion { get => Q<bool?>("keep_on_completion"); set => Q("keep_on_completion", value); }

	/// <summary>
	/// <para>
	/// Specify whether format-based query failures (such as providing text to a numeric field) should be ignored
	/// </para>
	/// </summary>
	public bool? Lenient { get => Q<bool?>("lenient"); set => Q("lenient", value); }

	/// <summary>
	/// <para>
	/// The number of concurrent shard requests per node this search executes concurrently. This value should be used to limit the impact of the search on the cluster in order to limit the number of concurrent shard requests
	/// </para>
	/// </summary>
	public long? MaxConcurrentShardRequests { get => Q<long?>("max_concurrent_shard_requests"); set => Q("max_concurrent_shard_requests", value); }

	/// <summary>
	/// <para>
	/// Specify the node or shard the operation should be performed on (default: random)
	/// </para>
	/// </summary>
	public string? Preference { get => Q<string?>("preference"); set => Q("preference", value); }

	/// <summary>
	/// <para>
	/// Query in the Lucene query string syntax
	/// </para>
	/// </summary>
	public string? QueryLuceneSyntax { get => Q<string?>("q"); set => Q("q", value); }

	/// <summary>
	/// <para>
	/// Specify if request cache should be used for this request or not, defaults to true
	/// </para>
	/// </summary>
	public bool? RequestCache { get => Q<bool?>("request_cache"); set => Q("request_cache", value); }

	/// <summary>
	/// <para>
	/// Indicates whether hits.total should be rendered as an integer or an object in the rest search response
	/// </para>
	/// </summary>
	public bool? RestTotalHitsAsInt { get => Q<bool?>("rest_total_hits_as_int"); set => Q("rest_total_hits_as_int", value); }

	/// <summary>
	/// <para>
	/// A comma-separated list of specific routing values
	/// </para>
	/// </summary>
	public Elastic.Clients.Elasticsearch.Routing? Routing { get => Q<Elastic.Clients.Elasticsearch.Routing?>("routing"); set => Q("routing", value); }

	/// <summary>
	/// <para>
	/// Search operation type
	/// </para>
	/// </summary>
	public Elastic.Clients.Elasticsearch.SearchType? SearchType { get => Q<Elastic.Clients.Elasticsearch.SearchType?>("search_type"); set => Q("search_type", value); }

	/// <summary>
	/// <para>
	/// A list of fields to exclude from the returned _source field
	/// </para>
	/// </summary>
	public Elastic.Clients.Elasticsearch.Fields? SourceExcludes { get => Q<Elastic.Clients.Elasticsearch.Fields?>("_source_excludes"); set => Q("_source_excludes", value); }

	/// <summary>
	/// <para>
	/// A list of fields to extract and return from the _source field
	/// </para>
	/// </summary>
	public Elastic.Clients.Elasticsearch.Fields? SourceIncludes { get => Q<Elastic.Clients.Elasticsearch.Fields?>("_source_includes"); set => Q("_source_includes", value); }

	/// <summary>
	/// <para>
	/// Specifies which field to use for suggestions.
	/// </para>
	/// </summary>
	public Elastic.Clients.Elasticsearch.Field? SuggestField { get => Q<Elastic.Clients.Elasticsearch.Field?>("suggest_field"); set => Q("suggest_field", value); }

	/// <summary>
	/// <para>
	/// Specify suggest mode
	/// </para>
	/// </summary>
	public Elastic.Clients.Elasticsearch.SuggestMode? SuggestMode { get => Q<Elastic.Clients.Elasticsearch.SuggestMode?>("suggest_mode"); set => Q("suggest_mode", value); }

	/// <summary>
	/// <para>
	/// How many suggestions to return in response
	/// </para>
	/// </summary>
	public long? SuggestSize { get => Q<long?>("suggest_size"); set => Q("suggest_size", value); }

	/// <summary>
	/// <para>
	/// The source text for which the suggestions should be returned.
	/// </para>
	/// </summary>
	public string? SuggestText { get => Q<string?>("suggest_text"); set => Q("suggest_text", value); }

	/// <summary>
	/// <para>
	/// Specify whether aggregation and suggester names should be prefixed by their respective types in the response
	/// </para>
	/// </summary>
	public bool? TypedKeys { get => Q<bool?>("typed_keys"); set => Q("typed_keys", value); }

	/// <summary>
	/// <para>
	/// Blocks and waits until the search is completed up to a certain timeout.
	/// When the async search completes within the timeout, the response won’t include the ID as the results are not stored in the cluster.
	/// </para>
	/// </summary>
	public Elastic.Clients.Elasticsearch.Duration? WaitForCompletionTimeout { get => Q<Elastic.Clients.Elasticsearch.Duration?>("wait_for_completion_timeout"); set => Q("wait_for_completion_timeout", value); }
}

internal sealed partial class SubmitAsyncSearchRequestConverter : System.Text.Json.Serialization.JsonConverter<SubmitAsyncSearchRequest>
{
	private static readonly System.Text.Json.JsonEncodedText PropAggregations = System.Text.Json.JsonEncodedText.Encode("aggregations");
	private static readonly System.Text.Json.JsonEncodedText PropAggregations1 = System.Text.Json.JsonEncodedText.Encode("aggs");
	private static readonly System.Text.Json.JsonEncodedText PropCollapse = System.Text.Json.JsonEncodedText.Encode("collapse");
	private static readonly System.Text.Json.JsonEncodedText PropDocvalueFields = System.Text.Json.JsonEncodedText.Encode("docvalue_fields");
	private static readonly System.Text.Json.JsonEncodedText PropExplain = System.Text.Json.JsonEncodedText.Encode("explain");
	private static readonly System.Text.Json.JsonEncodedText PropExt = System.Text.Json.JsonEncodedText.Encode("ext");
	private static readonly System.Text.Json.JsonEncodedText PropFields = System.Text.Json.JsonEncodedText.Encode("fields");
	private static readonly System.Text.Json.JsonEncodedText PropFrom = System.Text.Json.JsonEncodedText.Encode("from");
	private static readonly System.Text.Json.JsonEncodedText PropHighlight = System.Text.Json.JsonEncodedText.Encode("highlight");
	private static readonly System.Text.Json.JsonEncodedText PropIndicesBoost = System.Text.Json.JsonEncodedText.Encode("indices_boost");
	private static readonly System.Text.Json.JsonEncodedText PropKnn = System.Text.Json.JsonEncodedText.Encode("knn");
	private static readonly System.Text.Json.JsonEncodedText PropMinScore = System.Text.Json.JsonEncodedText.Encode("min_score");
	private static readonly System.Text.Json.JsonEncodedText PropPit = System.Text.Json.JsonEncodedText.Encode("pit");
	private static readonly System.Text.Json.JsonEncodedText PropPostFilter = System.Text.Json.JsonEncodedText.Encode("post_filter");
	private static readonly System.Text.Json.JsonEncodedText PropProfile = System.Text.Json.JsonEncodedText.Encode("profile");
	private static readonly System.Text.Json.JsonEncodedText PropQuery = System.Text.Json.JsonEncodedText.Encode("query");
	private static readonly System.Text.Json.JsonEncodedText PropRescore = System.Text.Json.JsonEncodedText.Encode("rescore");
	private static readonly System.Text.Json.JsonEncodedText PropRuntimeMappings = System.Text.Json.JsonEncodedText.Encode("runtime_mappings");
	private static readonly System.Text.Json.JsonEncodedText PropScriptFields = System.Text.Json.JsonEncodedText.Encode("script_fields");
	private static readonly System.Text.Json.JsonEncodedText PropSearchAfter = System.Text.Json.JsonEncodedText.Encode("search_after");
	private static readonly System.Text.Json.JsonEncodedText PropSeqNoPrimaryTerm = System.Text.Json.JsonEncodedText.Encode("seq_no_primary_term");
	private static readonly System.Text.Json.JsonEncodedText PropSize = System.Text.Json.JsonEncodedText.Encode("size");
	private static readonly System.Text.Json.JsonEncodedText PropSlice = System.Text.Json.JsonEncodedText.Encode("slice");
	private static readonly System.Text.Json.JsonEncodedText PropSort = System.Text.Json.JsonEncodedText.Encode("sort");
	private static readonly System.Text.Json.JsonEncodedText PropSource = System.Text.Json.JsonEncodedText.Encode("_source");
	private static readonly System.Text.Json.JsonEncodedText PropStats = System.Text.Json.JsonEncodedText.Encode("stats");
	private static readonly System.Text.Json.JsonEncodedText PropStoredFields = System.Text.Json.JsonEncodedText.Encode("stored_fields");
	private static readonly System.Text.Json.JsonEncodedText PropSuggest = System.Text.Json.JsonEncodedText.Encode("suggest");
	private static readonly System.Text.Json.JsonEncodedText PropTerminateAfter = System.Text.Json.JsonEncodedText.Encode("terminate_after");
	private static readonly System.Text.Json.JsonEncodedText PropTimeout = System.Text.Json.JsonEncodedText.Encode("timeout");
	private static readonly System.Text.Json.JsonEncodedText PropTrackScores = System.Text.Json.JsonEncodedText.Encode("track_scores");
	private static readonly System.Text.Json.JsonEncodedText PropTrackTotalHits = System.Text.Json.JsonEncodedText.Encode("track_total_hits");
	private static readonly System.Text.Json.JsonEncodedText PropVersion = System.Text.Json.JsonEncodedText.Encode("version");

	public override SubmitAsyncSearchRequest Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.StartObject);
		LocalJsonValue<IDictionary<string, Elastic.Clients.Elasticsearch.Aggregations.Aggregation>?> propAggregations = default;
		LocalJsonValue<Elastic.Clients.Elasticsearch.Core.Search.FieldCollapse?> propCollapse = default;
		LocalJsonValue<ICollection<Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormat>?> propDocvalueFields = default;
		LocalJsonValue<bool?> propExplain = default;
		LocalJsonValue<IDictionary<string, object>?> propExt = default;
		LocalJsonValue<ICollection<Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormat>?> propFields = default;
		LocalJsonValue<int?> propFrom = default;
		LocalJsonValue<Elastic.Clients.Elasticsearch.Core.Search.Highlight?> propHighlight = default;
		LocalJsonValue<ICollection<IDictionary<Elastic.Clients.Elasticsearch.IndexName, double>>?> propIndicesBoost = default;
		LocalJsonValue<ICollection<Elastic.Clients.Elasticsearch.KnnSearch>?> propKnn = default;
		LocalJsonValue<double?> propMinScore = default;
		LocalJsonValue<Elastic.Clients.Elasticsearch.Core.Search.PointInTimeReference?> propPit = default;
		LocalJsonValue<Elastic.Clients.Elasticsearch.QueryDsl.Query?> propPostFilter = default;
		LocalJsonValue<bool?> propProfile = default;
		LocalJsonValue<Elastic.Clients.Elasticsearch.QueryDsl.Query?> propQuery = default;
		LocalJsonValue<ICollection<Elastic.Clients.Elasticsearch.Core.Search.Rescore>?> propRescore = default;
		LocalJsonValue<IDictionary<Elastic.Clients.Elasticsearch.Field, Elastic.Clients.Elasticsearch.Mapping.RuntimeField>?> propRuntimeMappings = default;
		LocalJsonValue<IDictionary<string, Elastic.Clients.Elasticsearch.ScriptField>?> propScriptFields = default;
		LocalJsonValue<ICollection<Elastic.Clients.Elasticsearch.FieldValue>?> propSearchAfter = default;
		LocalJsonValue<bool?> propSeqNoPrimaryTerm = default;
		LocalJsonValue<int?> propSize = default;
		LocalJsonValue<Elastic.Clients.Elasticsearch.SlicedScroll?> propSlice = default;
		LocalJsonValue<ICollection<Elastic.Clients.Elasticsearch.SortOptions>?> propSort = default;
		LocalJsonValue<Elastic.Clients.Elasticsearch.Core.Search.SourceConfig?> propSource = default;
		LocalJsonValue<ICollection<string>?> propStats = default;
		LocalJsonValue<Elastic.Clients.Elasticsearch.Fields?> propStoredFields = default;
		LocalJsonValue<Elastic.Clients.Elasticsearch.Core.Search.Suggester?> propSuggest = default;
		LocalJsonValue<long?> propTerminateAfter = default;
		LocalJsonValue<string?> propTimeout = default;
		LocalJsonValue<bool?> propTrackScores = default;
		LocalJsonValue<Elastic.Clients.Elasticsearch.Core.Search.TrackHits?> propTrackTotalHits = default;
		LocalJsonValue<bool?> propVersion = default;
		while (reader.Read() && reader.TokenType is System.Text.Json.JsonTokenType.PropertyName)
		{
			if (propAggregations.TryReadProperty(ref reader, options, PropAggregations, static IDictionary<string, Elastic.Clients.Elasticsearch.Aggregations.Aggregation>? (ref System.Text.Json.Utf8JsonReader r, System.Text.Json.JsonSerializerOptions o) => r.ReadDictionaryValue<string, Elastic.Clients.Elasticsearch.Aggregations.Aggregation>(o, null, null)) || propAggregations.TryReadProperty(ref reader, options, PropAggregations1, static IDictionary<string, Elastic.Clients.Elasticsearch.Aggregations.Aggregation>? (ref System.Text.Json.Utf8JsonReader r, System.Text.Json.JsonSerializerOptions o) => r.ReadDictionaryValue<string, Elastic.Clients.Elasticsearch.Aggregations.Aggregation>(o, null, null)))
			{
				continue;
			}

			if (propCollapse.TryReadProperty(ref reader, options, PropCollapse, null))
			{
				continue;
			}

			if (propDocvalueFields.TryReadProperty(ref reader, options, PropDocvalueFields, static ICollection<Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormat>? (ref System.Text.Json.Utf8JsonReader r, System.Text.Json.JsonSerializerOptions o) => r.ReadCollectionValue<Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormat>(o, null)))
			{
				continue;
			}

			if (propExplain.TryReadProperty(ref reader, options, PropExplain, null))
			{
				continue;
			}

			if (propExt.TryReadProperty(ref reader, options, PropExt, static IDictionary<string, object>? (ref System.Text.Json.Utf8JsonReader r, System.Text.Json.JsonSerializerOptions o) => r.ReadDictionaryValue<string, object>(o, null, null)))
			{
				continue;
			}

			if (propFields.TryReadProperty(ref reader, options, PropFields, static ICollection<Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormat>? (ref System.Text.Json.Utf8JsonReader r, System.Text.Json.JsonSerializerOptions o) => r.ReadCollectionValue<Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormat>(o, null)))
			{
				continue;
			}

			if (propFrom.TryReadProperty(ref reader, options, PropFrom, null))
			{
				continue;
			}

			if (propHighlight.TryReadProperty(ref reader, options, PropHighlight, null))
			{
				continue;
			}

			if (propIndicesBoost.TryReadProperty(ref reader, options, PropIndicesBoost, static ICollection<IDictionary<Elastic.Clients.Elasticsearch.IndexName, double>>? (ref System.Text.Json.Utf8JsonReader r, System.Text.Json.JsonSerializerOptions o) => r.ReadCollectionValue<IDictionary<Elastic.Clients.Elasticsearch.IndexName, double>>(o, static IDictionary<Elastic.Clients.Elasticsearch.IndexName, double> (ref System.Text.Json.Utf8JsonReader r, System.Text.Json.JsonSerializerOptions o) => r.ReadDictionaryValue<Elastic.Clients.Elasticsearch.IndexName, double>(o, null, null)!)))
			{
				continue;
			}

			if (propKnn.TryReadProperty(ref reader, options, PropKnn, static ICollection<Elastic.Clients.Elasticsearch.KnnSearch>? (ref System.Text.Json.Utf8JsonReader r, System.Text.Json.JsonSerializerOptions o) => r.ReadSingleOrManyCollectionValue<Elastic.Clients.Elasticsearch.KnnSearch>(o, null)))
			{
				continue;
			}

			if (propMinScore.TryReadProperty(ref reader, options, PropMinScore, null))
			{
				continue;
			}

			if (propPit.TryReadProperty(ref reader, options, PropPit, null))
			{
				continue;
			}

			if (propPostFilter.TryReadProperty(ref reader, options, PropPostFilter, null))
			{
				continue;
			}

			if (propProfile.TryReadProperty(ref reader, options, PropProfile, null))
			{
				continue;
			}

			if (propQuery.TryReadProperty(ref reader, options, PropQuery, null))
			{
				continue;
			}

			if (propRescore.TryReadProperty(ref reader, options, PropRescore, static ICollection<Elastic.Clients.Elasticsearch.Core.Search.Rescore>? (ref System.Text.Json.Utf8JsonReader r, System.Text.Json.JsonSerializerOptions o) => r.ReadSingleOrManyCollectionValue<Elastic.Clients.Elasticsearch.Core.Search.Rescore>(o, null)))
			{
				continue;
			}

			if (propRuntimeMappings.TryReadProperty(ref reader, options, PropRuntimeMappings, static IDictionary<Elastic.Clients.Elasticsearch.Field, Elastic.Clients.Elasticsearch.Mapping.RuntimeField>? (ref System.Text.Json.Utf8JsonReader r, System.Text.Json.JsonSerializerOptions o) => r.ReadDictionaryValue<Elastic.Clients.Elasticsearch.Field, Elastic.Clients.Elasticsearch.Mapping.RuntimeField>(o, null, null)))
			{
				continue;
			}

			if (propScriptFields.TryReadProperty(ref reader, options, PropScriptFields, static IDictionary<string, Elastic.Clients.Elasticsearch.ScriptField>? (ref System.Text.Json.Utf8JsonReader r, System.Text.Json.JsonSerializerOptions o) => r.ReadDictionaryValue<string, Elastic.Clients.Elasticsearch.ScriptField>(o, null, null)))
			{
				continue;
			}

			if (propSearchAfter.TryReadProperty(ref reader, options, PropSearchAfter, static ICollection<Elastic.Clients.Elasticsearch.FieldValue>? (ref System.Text.Json.Utf8JsonReader r, System.Text.Json.JsonSerializerOptions o) => r.ReadCollectionValue<Elastic.Clients.Elasticsearch.FieldValue>(o, null)))
			{
				continue;
			}

			if (propSeqNoPrimaryTerm.TryReadProperty(ref reader, options, PropSeqNoPrimaryTerm, null))
			{
				continue;
			}

			if (propSize.TryReadProperty(ref reader, options, PropSize, null))
			{
				continue;
			}

			if (propSlice.TryReadProperty(ref reader, options, PropSlice, null))
			{
				continue;
			}

			if (propSort.TryReadProperty(ref reader, options, PropSort, static ICollection<Elastic.Clients.Elasticsearch.SortOptions>? (ref System.Text.Json.Utf8JsonReader r, System.Text.Json.JsonSerializerOptions o) => r.ReadSingleOrManyCollectionValue<Elastic.Clients.Elasticsearch.SortOptions>(o, null)))
			{
				continue;
			}

			if (propSource.TryReadProperty(ref reader, options, PropSource, null))
			{
				continue;
			}

			if (propStats.TryReadProperty(ref reader, options, PropStats, static ICollection<string>? (ref System.Text.Json.Utf8JsonReader r, System.Text.Json.JsonSerializerOptions o) => r.ReadCollectionValue<string>(o, null)))
			{
				continue;
			}

			if (propStoredFields.TryReadProperty(ref reader, options, PropStoredFields, static Elastic.Clients.Elasticsearch.Fields? (ref System.Text.Json.Utf8JsonReader r, System.Text.Json.JsonSerializerOptions o) => r.ReadValueEx<Elastic.Clients.Elasticsearch.Fields?>(o, typeof(SingleOrManyFieldsMarker))))
			{
				continue;
			}

			if (propSuggest.TryReadProperty(ref reader, options, PropSuggest, null))
			{
				continue;
			}

			if (propTerminateAfter.TryReadProperty(ref reader, options, PropTerminateAfter, null))
			{
				continue;
			}

			if (propTimeout.TryReadProperty(ref reader, options, PropTimeout, null))
			{
				continue;
			}

			if (propTrackScores.TryReadProperty(ref reader, options, PropTrackScores, null))
			{
				continue;
			}

			if (propTrackTotalHits.TryReadProperty(ref reader, options, PropTrackTotalHits, null))
			{
				continue;
			}

			if (propVersion.TryReadProperty(ref reader, options, PropVersion, null))
			{
				continue;
			}

			throw new System.Text.Json.JsonException($"Unknown JSON property '{reader.GetString()}' for type '{typeToConvert.Name}'.");
		}

		reader.ValidateToken(System.Text.Json.JsonTokenType.EndObject);
		return new SubmitAsyncSearchRequest
		{
			Aggregations = propAggregations.Value
	,
			Collapse = propCollapse.Value
	,
			DocvalueFields = propDocvalueFields.Value
	,
			Explain = propExplain.Value
	,
			Ext = propExt.Value
	,
			Fields = propFields.Value
	,
			From = propFrom.Value
	,
			Highlight = propHighlight.Value
	,
			IndicesBoost = propIndicesBoost.Value
	,
			Knn = propKnn.Value
	,
			MinScore = propMinScore.Value
	,
			Pit = propPit.Value
	,
			PostFilter = propPostFilter.Value
	,
			Profile = propProfile.Value
	,
			Query = propQuery.Value
	,
			Rescore = propRescore.Value
	,
			RuntimeMappings = propRuntimeMappings.Value
	,
			ScriptFields = propScriptFields.Value
	,
			SearchAfter = propSearchAfter.Value
	,
			SeqNoPrimaryTerm = propSeqNoPrimaryTerm.Value
	,
			Size = propSize.Value
	,
			Slice = propSlice.Value
	,
			Sort = propSort.Value
	,
			Source = propSource.Value
	,
			Stats = propStats.Value
	,
			StoredFields = propStoredFields.Value
	,
			Suggest = propSuggest.Value
	,
			TerminateAfter = propTerminateAfter.Value
	,
			Timeout = propTimeout.Value
	,
			TrackScores = propTrackScores.Value
	,
			TrackTotalHits = propTrackTotalHits.Value
	,
			Version = propVersion.Value
		};
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, SubmitAsyncSearchRequest value, System.Text.Json.JsonSerializerOptions options)
	{
		writer.WriteStartObject();
		writer.WriteProperty(options, PropAggregations, value.Aggregations, null, static (System.Text.Json.Utf8JsonWriter w, System.Text.Json.JsonSerializerOptions o, IDictionary<string, Elastic.Clients.Elasticsearch.Aggregations.Aggregation>? v) => w.WriteDictionaryValue<string, Elastic.Clients.Elasticsearch.Aggregations.Aggregation>(o, v, null, null));
		writer.WriteProperty(options, PropCollapse, value.Collapse, null, null);
		writer.WriteProperty(options, PropDocvalueFields, value.DocvalueFields, null, static (System.Text.Json.Utf8JsonWriter w, System.Text.Json.JsonSerializerOptions o, ICollection<Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormat>? v) => w.WriteCollectionValue<Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormat>(o, v, null));
		writer.WriteProperty(options, PropExplain, value.Explain, null, null);
		writer.WriteProperty(options, PropExt, value.Ext, null, static (System.Text.Json.Utf8JsonWriter w, System.Text.Json.JsonSerializerOptions o, IDictionary<string, object>? v) => w.WriteDictionaryValue<string, object>(o, v, null, null));
		writer.WriteProperty(options, PropFields, value.Fields, null, static (System.Text.Json.Utf8JsonWriter w, System.Text.Json.JsonSerializerOptions o, ICollection<Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormat>? v) => w.WriteCollectionValue<Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormat>(o, v, null));
		writer.WriteProperty(options, PropFrom, value.From, null, null);
		writer.WriteProperty(options, PropHighlight, value.Highlight, null, null);
		writer.WriteProperty(options, PropIndicesBoost, value.IndicesBoost, null, static (System.Text.Json.Utf8JsonWriter w, System.Text.Json.JsonSerializerOptions o, ICollection<IDictionary<Elastic.Clients.Elasticsearch.IndexName, double>>? v) => w.WriteCollectionValue<IDictionary<Elastic.Clients.Elasticsearch.IndexName, double>>(o, v, static (System.Text.Json.Utf8JsonWriter w, System.Text.Json.JsonSerializerOptions o, IDictionary<Elastic.Clients.Elasticsearch.IndexName, double> v) => w.WriteDictionaryValue<Elastic.Clients.Elasticsearch.IndexName, double>(o, v, null, null)));
		writer.WriteProperty(options, PropKnn, value.Knn, null, static (System.Text.Json.Utf8JsonWriter w, System.Text.Json.JsonSerializerOptions o, ICollection<Elastic.Clients.Elasticsearch.KnnSearch>? v) => w.WriteSingleOrManyCollectionValue<Elastic.Clients.Elasticsearch.KnnSearch>(o, v, null));
		writer.WriteProperty(options, PropMinScore, value.MinScore, null, null);
		writer.WriteProperty(options, PropPit, value.Pit, null, null);
		writer.WriteProperty(options, PropPostFilter, value.PostFilter, null, null);
		writer.WriteProperty(options, PropProfile, value.Profile, null, null);
		writer.WriteProperty(options, PropQuery, value.Query, null, null);
		writer.WriteProperty(options, PropRescore, value.Rescore, null, static (System.Text.Json.Utf8JsonWriter w, System.Text.Json.JsonSerializerOptions o, ICollection<Elastic.Clients.Elasticsearch.Core.Search.Rescore>? v) => w.WriteSingleOrManyCollectionValue<Elastic.Clients.Elasticsearch.Core.Search.Rescore>(o, v, null));
		writer.WriteProperty(options, PropRuntimeMappings, value.RuntimeMappings, null, static (System.Text.Json.Utf8JsonWriter w, System.Text.Json.JsonSerializerOptions o, IDictionary<Elastic.Clients.Elasticsearch.Field, Elastic.Clients.Elasticsearch.Mapping.RuntimeField>? v) => w.WriteDictionaryValue<Elastic.Clients.Elasticsearch.Field, Elastic.Clients.Elasticsearch.Mapping.RuntimeField>(o, v, null, null));
		writer.WriteProperty(options, PropScriptFields, value.ScriptFields, null, static (System.Text.Json.Utf8JsonWriter w, System.Text.Json.JsonSerializerOptions o, IDictionary<string, Elastic.Clients.Elasticsearch.ScriptField>? v) => w.WriteDictionaryValue<string, Elastic.Clients.Elasticsearch.ScriptField>(o, v, null, null));
		writer.WriteProperty(options, PropSearchAfter, value.SearchAfter, null, static (System.Text.Json.Utf8JsonWriter w, System.Text.Json.JsonSerializerOptions o, ICollection<Elastic.Clients.Elasticsearch.FieldValue>? v) => w.WriteCollectionValue<Elastic.Clients.Elasticsearch.FieldValue>(o, v, null));
		writer.WriteProperty(options, PropSeqNoPrimaryTerm, value.SeqNoPrimaryTerm, null, null);
		writer.WriteProperty(options, PropSize, value.Size, null, null);
		writer.WriteProperty(options, PropSlice, value.Slice, null, null);
		writer.WriteProperty(options, PropSort, value.Sort, null, static (System.Text.Json.Utf8JsonWriter w, System.Text.Json.JsonSerializerOptions o, ICollection<Elastic.Clients.Elasticsearch.SortOptions>? v) => w.WriteSingleOrManyCollectionValue<Elastic.Clients.Elasticsearch.SortOptions>(o, v, null));
		writer.WriteProperty(options, PropSource, value.Source, null, null);
		writer.WriteProperty(options, PropStats, value.Stats, null, static (System.Text.Json.Utf8JsonWriter w, System.Text.Json.JsonSerializerOptions o, ICollection<string>? v) => w.WriteCollectionValue<string>(o, v, null));
		writer.WriteProperty(options, PropStoredFields, value.StoredFields, null, static (System.Text.Json.Utf8JsonWriter w, System.Text.Json.JsonSerializerOptions o, Elastic.Clients.Elasticsearch.Fields? v) => w.WriteValueEx<Elastic.Clients.Elasticsearch.Fields?>(o, v, typeof(SingleOrManyFieldsMarker)));
		writer.WriteProperty(options, PropSuggest, value.Suggest, null, null);
		writer.WriteProperty(options, PropTerminateAfter, value.TerminateAfter, null, null);
		writer.WriteProperty(options, PropTimeout, value.Timeout, null, null);
		writer.WriteProperty(options, PropTrackScores, value.TrackScores, null, null);
		writer.WriteProperty(options, PropTrackTotalHits, value.TrackTotalHits, null, null);
		writer.WriteProperty(options, PropVersion, value.Version, null, null);
		writer.WriteEndObject();
	}
}

/// <summary>
/// <para>
/// Run an async search.
/// </para>
/// <para>
/// When the primary sort of the results is an indexed field, shards get sorted based on minimum and maximum value that they hold for that field. Partial results become available following the sort criteria that was requested.
/// </para>
/// <para>
/// Warning: Asynchronous search does not support scroll or search requests that include only the suggest section.
/// </para>
/// <para>
/// By default, Elasticsearch does not allow you to store an async search response larger than 10Mb and an attempt to do this results in an error.
/// The maximum allowed size for a stored async search response can be set by changing the <c>search.max_async_search_response_size</c> cluster level setting.
/// </para>
/// </summary>
[JsonConverter(typeof(SubmitAsyncSearchRequestConverter))]
public sealed partial class SubmitAsyncSearchRequest : PlainRequest<SubmitAsyncSearchRequestParameters>
{
	[JsonConstructor]
	public SubmitAsyncSearchRequest()
	{
	}

	public SubmitAsyncSearchRequest(Elastic.Clients.Elasticsearch.Indices? indices) : base(r => r.Optional("index", indices))
	{
	}

	internal override ApiUrls ApiUrls => ApiUrlLookup.AsyncSearchSubmit;

	protected override HttpMethod StaticHttpMethod => HttpMethod.POST;

	internal override bool SupportsBody => true;

	internal override string OperationName => "async_search.submit";

	/// <summary>
	/// <para>
	/// A comma-separated list of index names to search; use <c>_all</c> or empty string to perform the operation on all indices
	/// </para>
	/// </summary>
	public Elastic.Clients.Elasticsearch.Indices? Indices { get => P<Elastic.Clients.Elasticsearch.Indices?>("index"); set => PO("index", value); }

	/// <summary>
	/// <para>
	/// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes <c>_all</c> string or when no indices have been specified)
	/// </para>
	/// </summary>
	public bool? AllowNoIndices { get => Q<bool?>("allow_no_indices"); set => Q("allow_no_indices", value); }

	/// <summary>
	/// <para>
	/// Indicate if an error should be returned if there is a partial search failure or timeout
	/// </para>
	/// </summary>
	public bool? AllowPartialSearchResults { get => Q<bool?>("allow_partial_search_results"); set => Q("allow_partial_search_results", value); }

	/// <summary>
	/// <para>
	/// The analyzer to use for the query string
	/// </para>
	/// </summary>
	public string? Analyzer { get => Q<string?>("analyzer"); set => Q("analyzer", value); }

	/// <summary>
	/// <para>
	/// Specify whether wildcard and prefix queries should be analyzed (default: false)
	/// </para>
	/// </summary>
	public bool? AnalyzeWildcard { get => Q<bool?>("analyze_wildcard"); set => Q("analyze_wildcard", value); }

	/// <summary>
	/// <para>
	/// Affects how often partial results become available, which happens whenever shard results are reduced.
	/// A partial reduction is performed every time the coordinating node has received a certain number of new shard responses (5 by default).
	/// </para>
	/// </summary>
	public long? BatchedReduceSize { get => Q<long?>("batched_reduce_size"); set => Q("batched_reduce_size", value); }

	/// <summary>
	/// <para>
	/// The default value is the only supported value.
	/// </para>
	/// </summary>
	public bool? CcsMinimizeRoundtrips { get => Q<bool?>("ccs_minimize_roundtrips"); set => Q("ccs_minimize_roundtrips", value); }

	/// <summary>
	/// <para>
	/// The default operator for query string query (AND or OR)
	/// </para>
	/// </summary>
	public Elastic.Clients.Elasticsearch.QueryDsl.Operator? DefaultOperator { get => Q<Elastic.Clients.Elasticsearch.QueryDsl.Operator?>("default_operator"); set => Q("default_operator", value); }

	/// <summary>
	/// <para>
	/// The field to use as default where no field prefix is given in the query string
	/// </para>
	/// </summary>
	public string? Df { get => Q<string?>("df"); set => Q("df", value); }

	/// <summary>
	/// <para>
	/// Whether to expand wildcard expression to concrete indices that are open, closed or both.
	/// </para>
	/// </summary>
	public ICollection<Elastic.Clients.Elasticsearch.ExpandWildcard>? ExpandWildcards { get => Q<ICollection<Elastic.Clients.Elasticsearch.ExpandWildcard>?>("expand_wildcards"); set => Q("expand_wildcards", value); }

	/// <summary>
	/// <para>
	/// Whether specified concrete, expanded or aliased indices should be ignored when throttled
	/// </para>
	/// </summary>
	public bool? IgnoreThrottled { get => Q<bool?>("ignore_throttled"); set => Q("ignore_throttled", value); }

	/// <summary>
	/// <para>
	/// Whether specified concrete indices should be ignored when unavailable (missing or closed)
	/// </para>
	/// </summary>
	public bool? IgnoreUnavailable { get => Q<bool?>("ignore_unavailable"); set => Q("ignore_unavailable", value); }

	/// <summary>
	/// <para>
	/// If <c>true</c>, results are stored for later retrieval when the search completes within the <c>wait_for_completion_timeout</c>.
	/// </para>
	/// </summary>
	public bool? KeepOnCompletion { get => Q<bool?>("keep_on_completion"); set => Q("keep_on_completion", value); }

	/// <summary>
	/// <para>
	/// Specify whether format-based query failures (such as providing text to a numeric field) should be ignored
	/// </para>
	/// </summary>
	public bool? Lenient { get => Q<bool?>("lenient"); set => Q("lenient", value); }

	/// <summary>
	/// <para>
	/// The number of concurrent shard requests per node this search executes concurrently. This value should be used to limit the impact of the search on the cluster in order to limit the number of concurrent shard requests
	/// </para>
	/// </summary>
	public long? MaxConcurrentShardRequests { get => Q<long?>("max_concurrent_shard_requests"); set => Q("max_concurrent_shard_requests", value); }

	/// <summary>
	/// <para>
	/// Specify the node or shard the operation should be performed on (default: random)
	/// </para>
	/// </summary>
	public string? Preference { get => Q<string?>("preference"); set => Q("preference", value); }

	/// <summary>
	/// <para>
	/// Query in the Lucene query string syntax
	/// </para>
	/// </summary>
	public string? QueryLuceneSyntax { get => Q<string?>("q"); set => Q("q", value); }

	/// <summary>
	/// <para>
	/// Specify if request cache should be used for this request or not, defaults to true
	/// </para>
	/// </summary>
	public bool? RequestCache { get => Q<bool?>("request_cache"); set => Q("request_cache", value); }

	/// <summary>
	/// <para>
	/// Indicates whether hits.total should be rendered as an integer or an object in the rest search response
	/// </para>
	/// </summary>
	public bool? RestTotalHitsAsInt { get => Q<bool?>("rest_total_hits_as_int"); set => Q("rest_total_hits_as_int", value); }

	/// <summary>
	/// <para>
	/// A comma-separated list of specific routing values
	/// </para>
	/// </summary>
	public Elastic.Clients.Elasticsearch.Routing? Routing { get => Q<Elastic.Clients.Elasticsearch.Routing?>("routing"); set => Q("routing", value); }

	/// <summary>
	/// <para>
	/// Search operation type
	/// </para>
	/// </summary>
	public Elastic.Clients.Elasticsearch.SearchType? SearchType { get => Q<Elastic.Clients.Elasticsearch.SearchType?>("search_type"); set => Q("search_type", value); }

	/// <summary>
	/// <para>
	/// A list of fields to exclude from the returned _source field
	/// </para>
	/// </summary>
	public Elastic.Clients.Elasticsearch.Fields? SourceExcludes { get => Q<Elastic.Clients.Elasticsearch.Fields?>("_source_excludes"); set => Q("_source_excludes", value); }

	/// <summary>
	/// <para>
	/// A list of fields to extract and return from the _source field
	/// </para>
	/// </summary>
	public Elastic.Clients.Elasticsearch.Fields? SourceIncludes { get => Q<Elastic.Clients.Elasticsearch.Fields?>("_source_includes"); set => Q("_source_includes", value); }

	/// <summary>
	/// <para>
	/// Specifies which field to use for suggestions.
	/// </para>
	/// </summary>
	public Elastic.Clients.Elasticsearch.Field? SuggestField { get => Q<Elastic.Clients.Elasticsearch.Field?>("suggest_field"); set => Q("suggest_field", value); }

	/// <summary>
	/// <para>
	/// Specify suggest mode
	/// </para>
	/// </summary>
	public Elastic.Clients.Elasticsearch.SuggestMode? SuggestMode { get => Q<Elastic.Clients.Elasticsearch.SuggestMode?>("suggest_mode"); set => Q("suggest_mode", value); }

	/// <summary>
	/// <para>
	/// How many suggestions to return in response
	/// </para>
	/// </summary>
	public long? SuggestSize { get => Q<long?>("suggest_size"); set => Q("suggest_size", value); }

	/// <summary>
	/// <para>
	/// The source text for which the suggestions should be returned.
	/// </para>
	/// </summary>
	public string? SuggestText { get => Q<string?>("suggest_text"); set => Q("suggest_text", value); }

	/// <summary>
	/// <para>
	/// Specify whether aggregation and suggester names should be prefixed by their respective types in the response
	/// </para>
	/// </summary>
	public bool? TypedKeys { get => Q<bool?>("typed_keys"); set => Q("typed_keys", value); }

	/// <summary>
	/// <para>
	/// Blocks and waits until the search is completed up to a certain timeout.
	/// When the async search completes within the timeout, the response won’t include the ID as the results are not stored in the cluster.
	/// </para>
	/// </summary>
	public Elastic.Clients.Elasticsearch.Duration? WaitForCompletionTimeout { get => Q<Elastic.Clients.Elasticsearch.Duration?>("wait_for_completion_timeout"); set => Q("wait_for_completion_timeout", value); }
	public IDictionary<string, Elastic.Clients.Elasticsearch.Aggregations.Aggregation>? Aggregations { get; set; }
	public Elastic.Clients.Elasticsearch.Core.Search.FieldCollapse? Collapse { get; set; }

	/// <summary>
	/// <para>
	/// Array of wildcard (*) patterns. The request returns doc values for field
	/// names matching these patterns in the hits.fields property of the response.
	/// </para>
	/// </summary>
	public ICollection<Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormat>? DocvalueFields { get; set; }

	/// <summary>
	/// <para>
	/// If true, returns detailed information about score computation as part of a hit.
	/// </para>
	/// </summary>
	public bool? Explain { get; set; }

	/// <summary>
	/// <para>
	/// Configuration of search extensions defined by Elasticsearch plugins.
	/// </para>
	/// </summary>
	public IDictionary<string, object>? Ext { get; set; }

	/// <summary>
	/// <para>
	/// Array of wildcard (*) patterns. The request returns values for field names
	/// matching these patterns in the hits.fields property of the response.
	/// </para>
	/// </summary>
	public ICollection<Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormat>? Fields { get; set; }

	/// <summary>
	/// <para>
	/// Starting document offset. By default, you cannot page through more than 10,000
	/// hits using the from and size parameters. To page through more hits, use the
	/// search_after parameter.
	/// </para>
	/// </summary>
	public int? From { get; set; }
	public Elastic.Clients.Elasticsearch.Core.Search.Highlight? Highlight { get; set; }

	/// <summary>
	/// <para>
	/// Boosts the _score of documents from specified indices.
	/// </para>
	/// </summary>
	public ICollection<IDictionary<Elastic.Clients.Elasticsearch.IndexName, double>>? IndicesBoost { get; set; }

	/// <summary>
	/// <para>
	/// Defines the approximate kNN search to run.
	/// </para>
	/// </summary>
	public ICollection<Elastic.Clients.Elasticsearch.KnnSearch>? Knn { get; set; }

	/// <summary>
	/// <para>
	/// Minimum _score for matching documents. Documents with a lower _score are
	/// not included in the search results.
	/// </para>
	/// </summary>
	public double? MinScore { get; set; }

	/// <summary>
	/// <para>
	/// Limits the search to a point in time (PIT). If you provide a PIT, you
	/// cannot specify an &lt;index> in the request path.
	/// </para>
	/// </summary>
	public Elastic.Clients.Elasticsearch.Core.Search.PointInTimeReference? Pit { get; set; }
	public Elastic.Clients.Elasticsearch.QueryDsl.Query? PostFilter { get; set; }
	public bool? Profile { get; set; }

	/// <summary>
	/// <para>
	/// Defines the search definition using the Query DSL.
	/// </para>
	/// </summary>
	public Elastic.Clients.Elasticsearch.QueryDsl.Query? Query { get; set; }
	public ICollection<Elastic.Clients.Elasticsearch.Core.Search.Rescore>? Rescore { get; set; }

	/// <summary>
	/// <para>
	/// Defines one or more runtime fields in the search request. These fields take
	/// precedence over mapped fields with the same name.
	/// </para>
	/// </summary>
	public IDictionary<Elastic.Clients.Elasticsearch.Field, Elastic.Clients.Elasticsearch.Mapping.RuntimeField>? RuntimeMappings { get; set; }

	/// <summary>
	/// <para>
	/// Retrieve a script evaluation (based on different fields) for each hit.
	/// </para>
	/// </summary>
	public IDictionary<string, Elastic.Clients.Elasticsearch.ScriptField>? ScriptFields { get; set; }
	public ICollection<Elastic.Clients.Elasticsearch.FieldValue>? SearchAfter { get; set; }

	/// <summary>
	/// <para>
	/// If true, returns sequence number and primary term of the last modification
	/// of each hit. See Optimistic concurrency control.
	/// </para>
	/// </summary>
	public bool? SeqNoPrimaryTerm { get; set; }

	/// <summary>
	/// <para>
	/// The number of hits to return. By default, you cannot page through more
	/// than 10,000 hits using the from and size parameters. To page through more
	/// hits, use the search_after parameter.
	/// </para>
	/// </summary>
	public int? Size { get; set; }
	public Elastic.Clients.Elasticsearch.SlicedScroll? Slice { get; set; }
	public ICollection<Elastic.Clients.Elasticsearch.SortOptions>? Sort { get; set; }

	/// <summary>
	/// <para>
	/// Indicates which source fields are returned for matching documents. These
	/// fields are returned in the hits._source property of the search response.
	/// </para>
	/// </summary>
	public Elastic.Clients.Elasticsearch.Core.Search.SourceConfig? Source { get; set; }

	/// <summary>
	/// <para>
	/// Stats groups to associate with the search. Each group maintains a statistics
	/// aggregation for its associated searches. You can retrieve these stats using
	/// the indices stats API.
	/// </para>
	/// </summary>
	public ICollection<string>? Stats { get; set; }

	/// <summary>
	/// <para>
	/// List of stored fields to return as part of a hit. If no fields are specified,
	/// no stored fields are included in the response. If this field is specified, the _source
	/// parameter defaults to false. You can pass _source: true to return both source fields
	/// and stored fields in the search response.
	/// </para>
	/// </summary>
	public Elastic.Clients.Elasticsearch.Fields? StoredFields { get; set; }
	public Elastic.Clients.Elasticsearch.Core.Search.Suggester? Suggest { get; set; }

	/// <summary>
	/// <para>
	/// Maximum number of documents to collect for each shard. If a query reaches this
	/// limit, Elasticsearch terminates the query early. Elasticsearch collects documents
	/// before sorting. Defaults to 0, which does not terminate query execution early.
	/// </para>
	/// </summary>
	public long? TerminateAfter { get; set; }

	/// <summary>
	/// <para>
	/// Specifies the period of time to wait for a response from each shard. If no response
	/// is received before the timeout expires, the request fails and returns an error.
	/// Defaults to no timeout.
	/// </para>
	/// </summary>
	public string? Timeout { get; set; }

	/// <summary>
	/// <para>
	/// If true, calculate and return document scores, even if the scores are not used for sorting.
	/// </para>
	/// </summary>
	public bool? TrackScores { get; set; }

	/// <summary>
	/// <para>
	/// Number of hits matching the query to count accurately. If true, the exact
	/// number of hits is returned at the cost of some performance. If false, the
	/// response does not include the total number of hits matching the query.
	/// Defaults to 10,000 hits.
	/// </para>
	/// </summary>
	public Elastic.Clients.Elasticsearch.Core.Search.TrackHits? TrackTotalHits { get; set; }

	/// <summary>
	/// <para>
	/// If true, returns document version as part of a hit.
	/// </para>
	/// </summary>
	public bool? Version { get; set; }
}

/// <summary>
/// <para>
/// Run an async search.
/// </para>
/// <para>
/// When the primary sort of the results is an indexed field, shards get sorted based on minimum and maximum value that they hold for that field. Partial results become available following the sort criteria that was requested.
/// </para>
/// <para>
/// Warning: Asynchronous search does not support scroll or search requests that include only the suggest section.
/// </para>
/// <para>
/// By default, Elasticsearch does not allow you to store an async search response larger than 10Mb and an attempt to do this results in an error.
/// The maximum allowed size for a stored async search response can be set by changing the <c>search.max_async_search_response_size</c> cluster level setting.
/// </para>
/// </summary>
public sealed partial class SubmitAsyncSearchRequestDescriptor<TDocument> : RequestDescriptor<SubmitAsyncSearchRequestDescriptor<TDocument>, SubmitAsyncSearchRequestParameters>
{
	internal SubmitAsyncSearchRequestDescriptor(Action<SubmitAsyncSearchRequestDescriptor<TDocument>> configure) => configure.Invoke(this);

	public SubmitAsyncSearchRequestDescriptor(Elastic.Clients.Elasticsearch.Indices? indices) : base(r => r.Optional("index", indices))
	{
	}

	public SubmitAsyncSearchRequestDescriptor()
	{
	}

	internal override ApiUrls ApiUrls => ApiUrlLookup.AsyncSearchSubmit;

	protected override HttpMethod StaticHttpMethod => HttpMethod.POST;

	internal override bool SupportsBody => true;

	internal override string OperationName => "async_search.submit";

	public SubmitAsyncSearchRequestDescriptor<TDocument> AllowNoIndices(bool? allowNoIndices = true) => Qs("allow_no_indices", allowNoIndices);
	public SubmitAsyncSearchRequestDescriptor<TDocument> AllowPartialSearchResults(bool? allowPartialSearchResults = true) => Qs("allow_partial_search_results", allowPartialSearchResults);
	public SubmitAsyncSearchRequestDescriptor<TDocument> Analyzer(string? analyzer) => Qs("analyzer", analyzer);
	public SubmitAsyncSearchRequestDescriptor<TDocument> AnalyzeWildcard(bool? analyzeWildcard = true) => Qs("analyze_wildcard", analyzeWildcard);
	public SubmitAsyncSearchRequestDescriptor<TDocument> BatchedReduceSize(long? batchedReduceSize) => Qs("batched_reduce_size", batchedReduceSize);
	public SubmitAsyncSearchRequestDescriptor<TDocument> CcsMinimizeRoundtrips(bool? ccsMinimizeRoundtrips = true) => Qs("ccs_minimize_roundtrips", ccsMinimizeRoundtrips);
	public SubmitAsyncSearchRequestDescriptor<TDocument> DefaultOperator(Elastic.Clients.Elasticsearch.QueryDsl.Operator? defaultOperator) => Qs("default_operator", defaultOperator);
	public SubmitAsyncSearchRequestDescriptor<TDocument> Df(string? df) => Qs("df", df);
	public SubmitAsyncSearchRequestDescriptor<TDocument> ExpandWildcards(ICollection<Elastic.Clients.Elasticsearch.ExpandWildcard>? expandWildcards) => Qs("expand_wildcards", expandWildcards);
	public SubmitAsyncSearchRequestDescriptor<TDocument> IgnoreThrottled(bool? ignoreThrottled = true) => Qs("ignore_throttled", ignoreThrottled);
	public SubmitAsyncSearchRequestDescriptor<TDocument> IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
	public SubmitAsyncSearchRequestDescriptor<TDocument> KeepOnCompletion(bool? keepOnCompletion = true) => Qs("keep_on_completion", keepOnCompletion);
	public SubmitAsyncSearchRequestDescriptor<TDocument> Lenient(bool? lenient = true) => Qs("lenient", lenient);
	public SubmitAsyncSearchRequestDescriptor<TDocument> MaxConcurrentShardRequests(long? maxConcurrentShardRequests) => Qs("max_concurrent_shard_requests", maxConcurrentShardRequests);
	public SubmitAsyncSearchRequestDescriptor<TDocument> Preference(string? preference) => Qs("preference", preference);
	public SubmitAsyncSearchRequestDescriptor<TDocument> QueryLuceneSyntax(string? queryLuceneSyntax) => Qs("q", queryLuceneSyntax);
	public SubmitAsyncSearchRequestDescriptor<TDocument> RequestCache(bool? requestCache = true) => Qs("request_cache", requestCache);
	public SubmitAsyncSearchRequestDescriptor<TDocument> RestTotalHitsAsInt(bool? restTotalHitsAsInt = true) => Qs("rest_total_hits_as_int", restTotalHitsAsInt);
	public SubmitAsyncSearchRequestDescriptor<TDocument> Routing(Elastic.Clients.Elasticsearch.Routing? routing) => Qs("routing", routing);
	public SubmitAsyncSearchRequestDescriptor<TDocument> SearchType(Elastic.Clients.Elasticsearch.SearchType? searchType) => Qs("search_type", searchType);
	public SubmitAsyncSearchRequestDescriptor<TDocument> SourceExcludes(Elastic.Clients.Elasticsearch.Fields? sourceExcludes) => Qs("_source_excludes", sourceExcludes);
	public SubmitAsyncSearchRequestDescriptor<TDocument> SourceIncludes(Elastic.Clients.Elasticsearch.Fields? sourceIncludes) => Qs("_source_includes", sourceIncludes);
	public SubmitAsyncSearchRequestDescriptor<TDocument> SuggestField(Elastic.Clients.Elasticsearch.Field? suggestField) => Qs("suggest_field", suggestField);
	public SubmitAsyncSearchRequestDescriptor<TDocument> SuggestMode(Elastic.Clients.Elasticsearch.SuggestMode? suggestMode) => Qs("suggest_mode", suggestMode);
	public SubmitAsyncSearchRequestDescriptor<TDocument> SuggestSize(long? suggestSize) => Qs("suggest_size", suggestSize);
	public SubmitAsyncSearchRequestDescriptor<TDocument> SuggestText(string? suggestText) => Qs("suggest_text", suggestText);
	public SubmitAsyncSearchRequestDescriptor<TDocument> TypedKeys(bool? typedKeys = true) => Qs("typed_keys", typedKeys);
	public SubmitAsyncSearchRequestDescriptor<TDocument> WaitForCompletionTimeout(Elastic.Clients.Elasticsearch.Duration? waitForCompletionTimeout) => Qs("wait_for_completion_timeout", waitForCompletionTimeout);

	public SubmitAsyncSearchRequestDescriptor<TDocument> Indices(Elastic.Clients.Elasticsearch.Indices? indices)
	{
		RouteValues.Optional("index", indices);
		return Self;
	}

	private IDictionary<string, Elastic.Clients.Elasticsearch.Aggregations.AggregationDescriptor<TDocument>> AggregationsValue { get; set; }
	private Elastic.Clients.Elasticsearch.Core.Search.FieldCollapse? CollapseValue { get; set; }
	private Elastic.Clients.Elasticsearch.Core.Search.FieldCollapseDescriptor<TDocument> CollapseDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.Core.Search.FieldCollapseDescriptor<TDocument>> CollapseDescriptorAction { get; set; }
	private ICollection<Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormat>? DocvalueFieldsValue { get; set; }
	private Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormatDescriptor<TDocument> DocvalueFieldsDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormatDescriptor<TDocument>> DocvalueFieldsDescriptorAction { get; set; }
	private Action<Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormatDescriptor<TDocument>>[] DocvalueFieldsDescriptorActions { get; set; }
	private bool? ExplainValue { get; set; }
	private IDictionary<string, object>? ExtValue { get; set; }
	private ICollection<Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormat>? FieldsValue { get; set; }
	private Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormatDescriptor<TDocument> FieldsDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormatDescriptor<TDocument>> FieldsDescriptorAction { get; set; }
	private Action<Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormatDescriptor<TDocument>>[] FieldsDescriptorActions { get; set; }
	private int? FromValue { get; set; }
	private Elastic.Clients.Elasticsearch.Core.Search.Highlight? HighlightValue { get; set; }
	private Elastic.Clients.Elasticsearch.Core.Search.HighlightDescriptor<TDocument> HighlightDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.Core.Search.HighlightDescriptor<TDocument>> HighlightDescriptorAction { get; set; }
	private ICollection<IDictionary<Elastic.Clients.Elasticsearch.IndexName, double>>? IndicesBoostValue { get; set; }
	private ICollection<Elastic.Clients.Elasticsearch.KnnSearch>? KnnValue { get; set; }
	private Elastic.Clients.Elasticsearch.KnnSearchDescriptor<TDocument> KnnDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.KnnSearchDescriptor<TDocument>> KnnDescriptorAction { get; set; }
	private Action<Elastic.Clients.Elasticsearch.KnnSearchDescriptor<TDocument>>[] KnnDescriptorActions { get; set; }
	private double? MinScoreValue { get; set; }
	private Elastic.Clients.Elasticsearch.Core.Search.PointInTimeReference? PitValue { get; set; }
	private Elastic.Clients.Elasticsearch.Core.Search.PointInTimeReferenceDescriptor PitDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.Core.Search.PointInTimeReferenceDescriptor> PitDescriptorAction { get; set; }
	private Elastic.Clients.Elasticsearch.QueryDsl.Query? PostFilterValue { get; set; }
	private Elastic.Clients.Elasticsearch.QueryDsl.QueryDescriptor<TDocument> PostFilterDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.QueryDsl.QueryDescriptor<TDocument>> PostFilterDescriptorAction { get; set; }
	private bool? ProfileValue { get; set; }
	private Elastic.Clients.Elasticsearch.QueryDsl.Query? QueryValue { get; set; }
	private Elastic.Clients.Elasticsearch.QueryDsl.QueryDescriptor<TDocument> QueryDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.QueryDsl.QueryDescriptor<TDocument>> QueryDescriptorAction { get; set; }
	private ICollection<Elastic.Clients.Elasticsearch.Core.Search.Rescore>? RescoreValue { get; set; }
	private Elastic.Clients.Elasticsearch.Core.Search.RescoreDescriptor<TDocument> RescoreDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.Core.Search.RescoreDescriptor<TDocument>> RescoreDescriptorAction { get; set; }
	private Action<Elastic.Clients.Elasticsearch.Core.Search.RescoreDescriptor<TDocument>>[] RescoreDescriptorActions { get; set; }
	private IDictionary<Elastic.Clients.Elasticsearch.Field, Elastic.Clients.Elasticsearch.Mapping.RuntimeFieldDescriptor<TDocument>> RuntimeMappingsValue { get; set; }
	private IDictionary<string, Elastic.Clients.Elasticsearch.ScriptFieldDescriptor> ScriptFieldsValue { get; set; }
	private ICollection<Elastic.Clients.Elasticsearch.FieldValue>? SearchAfterValue { get; set; }
	private bool? SeqNoPrimaryTermValue { get; set; }
	private int? SizeValue { get; set; }
	private Elastic.Clients.Elasticsearch.SlicedScroll? SliceValue { get; set; }
	private Elastic.Clients.Elasticsearch.SlicedScrollDescriptor<TDocument> SliceDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.SlicedScrollDescriptor<TDocument>> SliceDescriptorAction { get; set; }
	private ICollection<Elastic.Clients.Elasticsearch.SortOptions>? SortValue { get; set; }
	private Elastic.Clients.Elasticsearch.SortOptionsDescriptor<TDocument> SortDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.SortOptionsDescriptor<TDocument>> SortDescriptorAction { get; set; }
	private Action<Elastic.Clients.Elasticsearch.SortOptionsDescriptor<TDocument>>[] SortDescriptorActions { get; set; }
	private Elastic.Clients.Elasticsearch.Core.Search.SourceConfig? SourceValue { get; set; }
	private ICollection<string>? StatsValue { get; set; }
	private Elastic.Clients.Elasticsearch.Fields? StoredFieldsValue { get; set; }
	private Elastic.Clients.Elasticsearch.Core.Search.Suggester? SuggestValue { get; set; }
	private Elastic.Clients.Elasticsearch.Core.Search.SuggesterDescriptor<TDocument> SuggestDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.Core.Search.SuggesterDescriptor<TDocument>> SuggestDescriptorAction { get; set; }
	private long? TerminateAfterValue { get; set; }
	private string? TimeoutValue { get; set; }
	private bool? TrackScoresValue { get; set; }
	private Elastic.Clients.Elasticsearch.Core.Search.TrackHits? TrackTotalHitsValue { get; set; }
	private bool? VersionValue { get; set; }

	public SubmitAsyncSearchRequestDescriptor<TDocument> Aggregations(Func<FluentDescriptorDictionary<string, Elastic.Clients.Elasticsearch.Aggregations.AggregationDescriptor<TDocument>>, FluentDescriptorDictionary<string, Elastic.Clients.Elasticsearch.Aggregations.AggregationDescriptor<TDocument>>> selector)
	{
		AggregationsValue = selector?.Invoke(new FluentDescriptorDictionary<string, Elastic.Clients.Elasticsearch.Aggregations.AggregationDescriptor<TDocument>>());
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor<TDocument> Collapse(Elastic.Clients.Elasticsearch.Core.Search.FieldCollapse? collapse)
	{
		CollapseDescriptor = null;
		CollapseDescriptorAction = null;
		CollapseValue = collapse;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor<TDocument> Collapse(Elastic.Clients.Elasticsearch.Core.Search.FieldCollapseDescriptor<TDocument> descriptor)
	{
		CollapseValue = null;
		CollapseDescriptorAction = null;
		CollapseDescriptor = descriptor;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor<TDocument> Collapse(Action<Elastic.Clients.Elasticsearch.Core.Search.FieldCollapseDescriptor<TDocument>> configure)
	{
		CollapseValue = null;
		CollapseDescriptor = null;
		CollapseDescriptorAction = configure;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Array of wildcard (*) patterns. The request returns doc values for field
	/// names matching these patterns in the hits.fields property of the response.
	/// </para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor<TDocument> DocvalueFields(ICollection<Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormat>? docvalueFields)
	{
		DocvalueFieldsDescriptor = null;
		DocvalueFieldsDescriptorAction = null;
		DocvalueFieldsDescriptorActions = null;
		DocvalueFieldsValue = docvalueFields;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor<TDocument> DocvalueFields(Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormatDescriptor<TDocument> descriptor)
	{
		DocvalueFieldsValue = null;
		DocvalueFieldsDescriptorAction = null;
		DocvalueFieldsDescriptorActions = null;
		DocvalueFieldsDescriptor = descriptor;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor<TDocument> DocvalueFields(Action<Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormatDescriptor<TDocument>> configure)
	{
		DocvalueFieldsValue = null;
		DocvalueFieldsDescriptor = null;
		DocvalueFieldsDescriptorActions = null;
		DocvalueFieldsDescriptorAction = configure;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor<TDocument> DocvalueFields(params Action<Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormatDescriptor<TDocument>>[] configure)
	{
		DocvalueFieldsValue = null;
		DocvalueFieldsDescriptor = null;
		DocvalueFieldsDescriptorAction = null;
		DocvalueFieldsDescriptorActions = configure;
		return Self;
	}

	/// <summary>
	/// <para>
	/// If true, returns detailed information about score computation as part of a hit.
	/// </para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor<TDocument> Explain(bool? explain = true)
	{
		ExplainValue = explain;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Configuration of search extensions defined by Elasticsearch plugins.
	/// </para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor<TDocument> Ext(Func<FluentDictionary<string, object>, FluentDictionary<string, object>> selector)
	{
		ExtValue = selector?.Invoke(new FluentDictionary<string, object>());
		return Self;
	}

	/// <summary>
	/// <para>
	/// Array of wildcard (*) patterns. The request returns values for field names
	/// matching these patterns in the hits.fields property of the response.
	/// </para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor<TDocument> Fields(ICollection<Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormat>? fields)
	{
		FieldsDescriptor = null;
		FieldsDescriptorAction = null;
		FieldsDescriptorActions = null;
		FieldsValue = fields;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor<TDocument> Fields(Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormatDescriptor<TDocument> descriptor)
	{
		FieldsValue = null;
		FieldsDescriptorAction = null;
		FieldsDescriptorActions = null;
		FieldsDescriptor = descriptor;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor<TDocument> Fields(Action<Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormatDescriptor<TDocument>> configure)
	{
		FieldsValue = null;
		FieldsDescriptor = null;
		FieldsDescriptorActions = null;
		FieldsDescriptorAction = configure;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor<TDocument> Fields(params Action<Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormatDescriptor<TDocument>>[] configure)
	{
		FieldsValue = null;
		FieldsDescriptor = null;
		FieldsDescriptorAction = null;
		FieldsDescriptorActions = configure;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Starting document offset. By default, you cannot page through more than 10,000
	/// hits using the from and size parameters. To page through more hits, use the
	/// search_after parameter.
	/// </para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor<TDocument> From(int? from)
	{
		FromValue = from;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor<TDocument> Highlight(Elastic.Clients.Elasticsearch.Core.Search.Highlight? highlight)
	{
		HighlightDescriptor = null;
		HighlightDescriptorAction = null;
		HighlightValue = highlight;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor<TDocument> Highlight(Elastic.Clients.Elasticsearch.Core.Search.HighlightDescriptor<TDocument> descriptor)
	{
		HighlightValue = null;
		HighlightDescriptorAction = null;
		HighlightDescriptor = descriptor;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor<TDocument> Highlight(Action<Elastic.Clients.Elasticsearch.Core.Search.HighlightDescriptor<TDocument>> configure)
	{
		HighlightValue = null;
		HighlightDescriptor = null;
		HighlightDescriptorAction = configure;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Boosts the _score of documents from specified indices.
	/// </para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor<TDocument> IndicesBoost(ICollection<IDictionary<Elastic.Clients.Elasticsearch.IndexName, double>>? indicesBoost)
	{
		IndicesBoostValue = indicesBoost;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Defines the approximate kNN search to run.
	/// </para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor<TDocument> Knn(ICollection<Elastic.Clients.Elasticsearch.KnnSearch>? knn)
	{
		KnnDescriptor = null;
		KnnDescriptorAction = null;
		KnnDescriptorActions = null;
		KnnValue = knn;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor<TDocument> Knn(Elastic.Clients.Elasticsearch.KnnSearchDescriptor<TDocument> descriptor)
	{
		KnnValue = null;
		KnnDescriptorAction = null;
		KnnDescriptorActions = null;
		KnnDescriptor = descriptor;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor<TDocument> Knn(Action<Elastic.Clients.Elasticsearch.KnnSearchDescriptor<TDocument>> configure)
	{
		KnnValue = null;
		KnnDescriptor = null;
		KnnDescriptorActions = null;
		KnnDescriptorAction = configure;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor<TDocument> Knn(params Action<Elastic.Clients.Elasticsearch.KnnSearchDescriptor<TDocument>>[] configure)
	{
		KnnValue = null;
		KnnDescriptor = null;
		KnnDescriptorAction = null;
		KnnDescriptorActions = configure;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Minimum _score for matching documents. Documents with a lower _score are
	/// not included in the search results.
	/// </para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor<TDocument> MinScore(double? minScore)
	{
		MinScoreValue = minScore;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Limits the search to a point in time (PIT). If you provide a PIT, you
	/// cannot specify an &lt;index> in the request path.
	/// </para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor<TDocument> Pit(Elastic.Clients.Elasticsearch.Core.Search.PointInTimeReference? pit)
	{
		PitDescriptor = null;
		PitDescriptorAction = null;
		PitValue = pit;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor<TDocument> Pit(Elastic.Clients.Elasticsearch.Core.Search.PointInTimeReferenceDescriptor descriptor)
	{
		PitValue = null;
		PitDescriptorAction = null;
		PitDescriptor = descriptor;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor<TDocument> Pit(Action<Elastic.Clients.Elasticsearch.Core.Search.PointInTimeReferenceDescriptor> configure)
	{
		PitValue = null;
		PitDescriptor = null;
		PitDescriptorAction = configure;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor<TDocument> PostFilter(Elastic.Clients.Elasticsearch.QueryDsl.Query? postFilter)
	{
		PostFilterDescriptor = null;
		PostFilterDescriptorAction = null;
		PostFilterValue = postFilter;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor<TDocument> PostFilter(Elastic.Clients.Elasticsearch.QueryDsl.QueryDescriptor<TDocument> descriptor)
	{
		PostFilterValue = null;
		PostFilterDescriptorAction = null;
		PostFilterDescriptor = descriptor;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor<TDocument> PostFilter(Action<Elastic.Clients.Elasticsearch.QueryDsl.QueryDescriptor<TDocument>> configure)
	{
		PostFilterValue = null;
		PostFilterDescriptor = null;
		PostFilterDescriptorAction = configure;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor<TDocument> Profile(bool? profile = true)
	{
		ProfileValue = profile;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Defines the search definition using the Query DSL.
	/// </para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor<TDocument> Query(Elastic.Clients.Elasticsearch.QueryDsl.Query? query)
	{
		QueryDescriptor = null;
		QueryDescriptorAction = null;
		QueryValue = query;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor<TDocument> Query(Elastic.Clients.Elasticsearch.QueryDsl.QueryDescriptor<TDocument> descriptor)
	{
		QueryValue = null;
		QueryDescriptorAction = null;
		QueryDescriptor = descriptor;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor<TDocument> Query(Action<Elastic.Clients.Elasticsearch.QueryDsl.QueryDescriptor<TDocument>> configure)
	{
		QueryValue = null;
		QueryDescriptor = null;
		QueryDescriptorAction = configure;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor<TDocument> Rescore(ICollection<Elastic.Clients.Elasticsearch.Core.Search.Rescore>? rescore)
	{
		RescoreDescriptor = null;
		RescoreDescriptorAction = null;
		RescoreDescriptorActions = null;
		RescoreValue = rescore;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor<TDocument> Rescore(Elastic.Clients.Elasticsearch.Core.Search.RescoreDescriptor<TDocument> descriptor)
	{
		RescoreValue = null;
		RescoreDescriptorAction = null;
		RescoreDescriptorActions = null;
		RescoreDescriptor = descriptor;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor<TDocument> Rescore(Action<Elastic.Clients.Elasticsearch.Core.Search.RescoreDescriptor<TDocument>> configure)
	{
		RescoreValue = null;
		RescoreDescriptor = null;
		RescoreDescriptorActions = null;
		RescoreDescriptorAction = configure;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor<TDocument> Rescore(params Action<Elastic.Clients.Elasticsearch.Core.Search.RescoreDescriptor<TDocument>>[] configure)
	{
		RescoreValue = null;
		RescoreDescriptor = null;
		RescoreDescriptorAction = null;
		RescoreDescriptorActions = configure;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Defines one or more runtime fields in the search request. These fields take
	/// precedence over mapped fields with the same name.
	/// </para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor<TDocument> RuntimeMappings(Func<FluentDescriptorDictionary<Elastic.Clients.Elasticsearch.Field, Elastic.Clients.Elasticsearch.Mapping.RuntimeFieldDescriptor<TDocument>>, FluentDescriptorDictionary<Elastic.Clients.Elasticsearch.Field, Elastic.Clients.Elasticsearch.Mapping.RuntimeFieldDescriptor<TDocument>>> selector)
	{
		RuntimeMappingsValue = selector?.Invoke(new FluentDescriptorDictionary<Elastic.Clients.Elasticsearch.Field, Elastic.Clients.Elasticsearch.Mapping.RuntimeFieldDescriptor<TDocument>>());
		return Self;
	}

	/// <summary>
	/// <para>
	/// Retrieve a script evaluation (based on different fields) for each hit.
	/// </para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor<TDocument> ScriptFields(Func<FluentDescriptorDictionary<string, Elastic.Clients.Elasticsearch.ScriptFieldDescriptor>, FluentDescriptorDictionary<string, Elastic.Clients.Elasticsearch.ScriptFieldDescriptor>> selector)
	{
		ScriptFieldsValue = selector?.Invoke(new FluentDescriptorDictionary<string, Elastic.Clients.Elasticsearch.ScriptFieldDescriptor>());
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor<TDocument> SearchAfter(ICollection<Elastic.Clients.Elasticsearch.FieldValue>? searchAfter)
	{
		SearchAfterValue = searchAfter;
		return Self;
	}

	/// <summary>
	/// <para>
	/// If true, returns sequence number and primary term of the last modification
	/// of each hit. See Optimistic concurrency control.
	/// </para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor<TDocument> SeqNoPrimaryTerm(bool? seqNoPrimaryTerm = true)
	{
		SeqNoPrimaryTermValue = seqNoPrimaryTerm;
		return Self;
	}

	/// <summary>
	/// <para>
	/// The number of hits to return. By default, you cannot page through more
	/// than 10,000 hits using the from and size parameters. To page through more
	/// hits, use the search_after parameter.
	/// </para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor<TDocument> Size(int? size)
	{
		SizeValue = size;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor<TDocument> Slice(Elastic.Clients.Elasticsearch.SlicedScroll? slice)
	{
		SliceDescriptor = null;
		SliceDescriptorAction = null;
		SliceValue = slice;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor<TDocument> Slice(Elastic.Clients.Elasticsearch.SlicedScrollDescriptor<TDocument> descriptor)
	{
		SliceValue = null;
		SliceDescriptorAction = null;
		SliceDescriptor = descriptor;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor<TDocument> Slice(Action<Elastic.Clients.Elasticsearch.SlicedScrollDescriptor<TDocument>> configure)
	{
		SliceValue = null;
		SliceDescriptor = null;
		SliceDescriptorAction = configure;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor<TDocument> Sort(ICollection<Elastic.Clients.Elasticsearch.SortOptions>? sort)
	{
		SortDescriptor = null;
		SortDescriptorAction = null;
		SortDescriptorActions = null;
		SortValue = sort;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor<TDocument> Sort(Elastic.Clients.Elasticsearch.SortOptionsDescriptor<TDocument> descriptor)
	{
		SortValue = null;
		SortDescriptorAction = null;
		SortDescriptorActions = null;
		SortDescriptor = descriptor;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor<TDocument> Sort(Action<Elastic.Clients.Elasticsearch.SortOptionsDescriptor<TDocument>> configure)
	{
		SortValue = null;
		SortDescriptor = null;
		SortDescriptorActions = null;
		SortDescriptorAction = configure;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor<TDocument> Sort(params Action<Elastic.Clients.Elasticsearch.SortOptionsDescriptor<TDocument>>[] configure)
	{
		SortValue = null;
		SortDescriptor = null;
		SortDescriptorAction = null;
		SortDescriptorActions = configure;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Indicates which source fields are returned for matching documents. These
	/// fields are returned in the hits._source property of the search response.
	/// </para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor<TDocument> Source(Elastic.Clients.Elasticsearch.Core.Search.SourceConfig? source)
	{
		SourceValue = source;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Stats groups to associate with the search. Each group maintains a statistics
	/// aggregation for its associated searches. You can retrieve these stats using
	/// the indices stats API.
	/// </para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor<TDocument> Stats(ICollection<string>? stats)
	{
		StatsValue = stats;
		return Self;
	}

	/// <summary>
	/// <para>
	/// List of stored fields to return as part of a hit. If no fields are specified,
	/// no stored fields are included in the response. If this field is specified, the _source
	/// parameter defaults to false. You can pass _source: true to return both source fields
	/// and stored fields in the search response.
	/// </para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor<TDocument> StoredFields(Elastic.Clients.Elasticsearch.Fields? storedFields)
	{
		StoredFieldsValue = storedFields;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor<TDocument> Suggest(Elastic.Clients.Elasticsearch.Core.Search.Suggester? suggest)
	{
		SuggestDescriptor = null;
		SuggestDescriptorAction = null;
		SuggestValue = suggest;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor<TDocument> Suggest(Elastic.Clients.Elasticsearch.Core.Search.SuggesterDescriptor<TDocument> descriptor)
	{
		SuggestValue = null;
		SuggestDescriptorAction = null;
		SuggestDescriptor = descriptor;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor<TDocument> Suggest(Action<Elastic.Clients.Elasticsearch.Core.Search.SuggesterDescriptor<TDocument>> configure)
	{
		SuggestValue = null;
		SuggestDescriptor = null;
		SuggestDescriptorAction = configure;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Maximum number of documents to collect for each shard. If a query reaches this
	/// limit, Elasticsearch terminates the query early. Elasticsearch collects documents
	/// before sorting. Defaults to 0, which does not terminate query execution early.
	/// </para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor<TDocument> TerminateAfter(long? terminateAfter)
	{
		TerminateAfterValue = terminateAfter;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Specifies the period of time to wait for a response from each shard. If no response
	/// is received before the timeout expires, the request fails and returns an error.
	/// Defaults to no timeout.
	/// </para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor<TDocument> Timeout(string? timeout)
	{
		TimeoutValue = timeout;
		return Self;
	}

	/// <summary>
	/// <para>
	/// If true, calculate and return document scores, even if the scores are not used for sorting.
	/// </para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor<TDocument> TrackScores(bool? trackScores = true)
	{
		TrackScoresValue = trackScores;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Number of hits matching the query to count accurately. If true, the exact
	/// number of hits is returned at the cost of some performance. If false, the
	/// response does not include the total number of hits matching the query.
	/// Defaults to 10,000 hits.
	/// </para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor<TDocument> TrackTotalHits(Elastic.Clients.Elasticsearch.Core.Search.TrackHits? trackTotalHits)
	{
		TrackTotalHitsValue = trackTotalHits;
		return Self;
	}

	/// <summary>
	/// <para>
	/// If true, returns document version as part of a hit.
	/// </para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor<TDocument> Version(bool? version = true)
	{
		VersionValue = version;
		return Self;
	}

	protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
	{
		writer.WriteStartObject();
		if (AggregationsValue is not null)
		{
			writer.WritePropertyName("aggregations");
			JsonSerializer.Serialize(writer, AggregationsValue, options);
		}

		if (CollapseDescriptor is not null)
		{
			writer.WritePropertyName("collapse");
			JsonSerializer.Serialize(writer, CollapseDescriptor, options);
		}
		else if (CollapseDescriptorAction is not null)
		{
			writer.WritePropertyName("collapse");
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.Core.Search.FieldCollapseDescriptor<TDocument>(CollapseDescriptorAction), options);
		}
		else if (CollapseValue is not null)
		{
			writer.WritePropertyName("collapse");
			JsonSerializer.Serialize(writer, CollapseValue, options);
		}

		if (DocvalueFieldsDescriptor is not null)
		{
			writer.WritePropertyName("docvalue_fields");
			writer.WriteStartArray();
			JsonSerializer.Serialize(writer, DocvalueFieldsDescriptor, options);
			writer.WriteEndArray();
		}
		else if (DocvalueFieldsDescriptorAction is not null)
		{
			writer.WritePropertyName("docvalue_fields");
			writer.WriteStartArray();
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormatDescriptor<TDocument>(DocvalueFieldsDescriptorAction), options);
			writer.WriteEndArray();
		}
		else if (DocvalueFieldsDescriptorActions is not null)
		{
			writer.WritePropertyName("docvalue_fields");
			writer.WriteStartArray();
			foreach (var action in DocvalueFieldsDescriptorActions)
			{
				JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormatDescriptor<TDocument>(action), options);
			}

			writer.WriteEndArray();
		}
		else if (DocvalueFieldsValue is not null)
		{
			writer.WritePropertyName("docvalue_fields");
			JsonSerializer.Serialize(writer, DocvalueFieldsValue, options);
		}

		if (ExplainValue.HasValue)
		{
			writer.WritePropertyName("explain");
			writer.WriteBooleanValue(ExplainValue.Value);
		}

		if (ExtValue is not null)
		{
			writer.WritePropertyName("ext");
			JsonSerializer.Serialize(writer, ExtValue, options);
		}

		if (FieldsDescriptor is not null)
		{
			writer.WritePropertyName("fields");
			writer.WriteStartArray();
			JsonSerializer.Serialize(writer, FieldsDescriptor, options);
			writer.WriteEndArray();
		}
		else if (FieldsDescriptorAction is not null)
		{
			writer.WritePropertyName("fields");
			writer.WriteStartArray();
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormatDescriptor<TDocument>(FieldsDescriptorAction), options);
			writer.WriteEndArray();
		}
		else if (FieldsDescriptorActions is not null)
		{
			writer.WritePropertyName("fields");
			writer.WriteStartArray();
			foreach (var action in FieldsDescriptorActions)
			{
				JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormatDescriptor<TDocument>(action), options);
			}

			writer.WriteEndArray();
		}
		else if (FieldsValue is not null)
		{
			writer.WritePropertyName("fields");
			JsonSerializer.Serialize(writer, FieldsValue, options);
		}

		if (FromValue.HasValue)
		{
			writer.WritePropertyName("from");
			writer.WriteNumberValue(FromValue.Value);
		}

		if (HighlightDescriptor is not null)
		{
			writer.WritePropertyName("highlight");
			JsonSerializer.Serialize(writer, HighlightDescriptor, options);
		}
		else if (HighlightDescriptorAction is not null)
		{
			writer.WritePropertyName("highlight");
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.Core.Search.HighlightDescriptor<TDocument>(HighlightDescriptorAction), options);
		}
		else if (HighlightValue is not null)
		{
			writer.WritePropertyName("highlight");
			JsonSerializer.Serialize(writer, HighlightValue, options);
		}

		if (IndicesBoostValue is not null)
		{
			writer.WritePropertyName("indices_boost");
			JsonSerializer.Serialize(writer, IndicesBoostValue, options);
		}

		if (KnnDescriptor is not null)
		{
			writer.WritePropertyName("knn");
			JsonSerializer.Serialize(writer, KnnDescriptor, options);
		}
		else if (KnnDescriptorAction is not null)
		{
			writer.WritePropertyName("knn");
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.KnnSearchDescriptor<TDocument>(KnnDescriptorAction), options);
		}
		else if (KnnDescriptorActions is not null)
		{
			writer.WritePropertyName("knn");
			if (KnnDescriptorActions.Length != 1)
				writer.WriteStartArray();
			foreach (var action in KnnDescriptorActions)
			{
				JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.KnnSearchDescriptor<TDocument>(action), options);
			}

			if (KnnDescriptorActions.Length != 1)
				writer.WriteEndArray();
		}
		else if (KnnValue is not null)
		{
			writer.WritePropertyName("knn");
			SingleOrManySerializationHelper.Serialize<Elastic.Clients.Elasticsearch.KnnSearch>(KnnValue, writer, options);
		}

		if (MinScoreValue.HasValue)
		{
			writer.WritePropertyName("min_score");
			writer.WriteNumberValue(MinScoreValue.Value);
		}

		if (PitDescriptor is not null)
		{
			writer.WritePropertyName("pit");
			JsonSerializer.Serialize(writer, PitDescriptor, options);
		}
		else if (PitDescriptorAction is not null)
		{
			writer.WritePropertyName("pit");
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.Core.Search.PointInTimeReferenceDescriptor(PitDescriptorAction), options);
		}
		else if (PitValue is not null)
		{
			writer.WritePropertyName("pit");
			JsonSerializer.Serialize(writer, PitValue, options);
		}

		if (PostFilterDescriptor is not null)
		{
			writer.WritePropertyName("post_filter");
			JsonSerializer.Serialize(writer, PostFilterDescriptor, options);
		}
		else if (PostFilterDescriptorAction is not null)
		{
			writer.WritePropertyName("post_filter");
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.QueryDsl.QueryDescriptor<TDocument>(PostFilterDescriptorAction), options);
		}
		else if (PostFilterValue is not null)
		{
			writer.WritePropertyName("post_filter");
			JsonSerializer.Serialize(writer, PostFilterValue, options);
		}

		if (ProfileValue.HasValue)
		{
			writer.WritePropertyName("profile");
			writer.WriteBooleanValue(ProfileValue.Value);
		}

		if (QueryDescriptor is not null)
		{
			writer.WritePropertyName("query");
			JsonSerializer.Serialize(writer, QueryDescriptor, options);
		}
		else if (QueryDescriptorAction is not null)
		{
			writer.WritePropertyName("query");
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.QueryDsl.QueryDescriptor<TDocument>(QueryDescriptorAction), options);
		}
		else if (QueryValue is not null)
		{
			writer.WritePropertyName("query");
			JsonSerializer.Serialize(writer, QueryValue, options);
		}

		if (RescoreDescriptor is not null)
		{
			writer.WritePropertyName("rescore");
			JsonSerializer.Serialize(writer, RescoreDescriptor, options);
		}
		else if (RescoreDescriptorAction is not null)
		{
			writer.WritePropertyName("rescore");
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.Core.Search.RescoreDescriptor<TDocument>(RescoreDescriptorAction), options);
		}
		else if (RescoreDescriptorActions is not null)
		{
			writer.WritePropertyName("rescore");
			if (RescoreDescriptorActions.Length != 1)
				writer.WriteStartArray();
			foreach (var action in RescoreDescriptorActions)
			{
				JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.Core.Search.RescoreDescriptor<TDocument>(action), options);
			}

			if (RescoreDescriptorActions.Length != 1)
				writer.WriteEndArray();
		}
		else if (RescoreValue is not null)
		{
			writer.WritePropertyName("rescore");
			SingleOrManySerializationHelper.Serialize<Elastic.Clients.Elasticsearch.Core.Search.Rescore>(RescoreValue, writer, options);
		}

		if (RuntimeMappingsValue is not null)
		{
			writer.WritePropertyName("runtime_mappings");
			JsonSerializer.Serialize(writer, RuntimeMappingsValue, options);
		}

		if (ScriptFieldsValue is not null)
		{
			writer.WritePropertyName("script_fields");
			JsonSerializer.Serialize(writer, ScriptFieldsValue, options);
		}

		if (SearchAfterValue is not null)
		{
			writer.WritePropertyName("search_after");
			JsonSerializer.Serialize(writer, SearchAfterValue, options);
		}

		if (SeqNoPrimaryTermValue.HasValue)
		{
			writer.WritePropertyName("seq_no_primary_term");
			writer.WriteBooleanValue(SeqNoPrimaryTermValue.Value);
		}

		if (SizeValue.HasValue)
		{
			writer.WritePropertyName("size");
			writer.WriteNumberValue(SizeValue.Value);
		}

		if (SliceDescriptor is not null)
		{
			writer.WritePropertyName("slice");
			JsonSerializer.Serialize(writer, SliceDescriptor, options);
		}
		else if (SliceDescriptorAction is not null)
		{
			writer.WritePropertyName("slice");
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.SlicedScrollDescriptor<TDocument>(SliceDescriptorAction), options);
		}
		else if (SliceValue is not null)
		{
			writer.WritePropertyName("slice");
			JsonSerializer.Serialize(writer, SliceValue, options);
		}

		if (SortDescriptor is not null)
		{
			writer.WritePropertyName("sort");
			JsonSerializer.Serialize(writer, SortDescriptor, options);
		}
		else if (SortDescriptorAction is not null)
		{
			writer.WritePropertyName("sort");
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.SortOptionsDescriptor<TDocument>(SortDescriptorAction), options);
		}
		else if (SortDescriptorActions is not null)
		{
			writer.WritePropertyName("sort");
			if (SortDescriptorActions.Length != 1)
				writer.WriteStartArray();
			foreach (var action in SortDescriptorActions)
			{
				JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.SortOptionsDescriptor<TDocument>(action), options);
			}

			if (SortDescriptorActions.Length != 1)
				writer.WriteEndArray();
		}
		else if (SortValue is not null)
		{
			writer.WritePropertyName("sort");
			SingleOrManySerializationHelper.Serialize<Elastic.Clients.Elasticsearch.SortOptions>(SortValue, writer, options);
		}

		if (SourceValue is not null)
		{
			writer.WritePropertyName("_source");
			JsonSerializer.Serialize(writer, SourceValue, options);
		}

		if (StatsValue is not null)
		{
			writer.WritePropertyName("stats");
			JsonSerializer.Serialize(writer, StatsValue, options);
		}

		if (StoredFieldsValue is not null)
		{
			writer.WritePropertyName("stored_fields");
			JsonSerializer.Serialize(writer, StoredFieldsValue, options);
		}

		if (SuggestDescriptor is not null)
		{
			writer.WritePropertyName("suggest");
			JsonSerializer.Serialize(writer, SuggestDescriptor, options);
		}
		else if (SuggestDescriptorAction is not null)
		{
			writer.WritePropertyName("suggest");
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.Core.Search.SuggesterDescriptor<TDocument>(SuggestDescriptorAction), options);
		}
		else if (SuggestValue is not null)
		{
			writer.WritePropertyName("suggest");
			JsonSerializer.Serialize(writer, SuggestValue, options);
		}

		if (TerminateAfterValue.HasValue)
		{
			writer.WritePropertyName("terminate_after");
			writer.WriteNumberValue(TerminateAfterValue.Value);
		}

		if (!string.IsNullOrEmpty(TimeoutValue))
		{
			writer.WritePropertyName("timeout");
			writer.WriteStringValue(TimeoutValue);
		}

		if (TrackScoresValue.HasValue)
		{
			writer.WritePropertyName("track_scores");
			writer.WriteBooleanValue(TrackScoresValue.Value);
		}

		if (TrackTotalHitsValue is not null)
		{
			writer.WritePropertyName("track_total_hits");
			JsonSerializer.Serialize(writer, TrackTotalHitsValue, options);
		}

		if (VersionValue.HasValue)
		{
			writer.WritePropertyName("version");
			writer.WriteBooleanValue(VersionValue.Value);
		}

		writer.WriteEndObject();
	}
}

/// <summary>
/// <para>
/// Run an async search.
/// </para>
/// <para>
/// When the primary sort of the results is an indexed field, shards get sorted based on minimum and maximum value that they hold for that field. Partial results become available following the sort criteria that was requested.
/// </para>
/// <para>
/// Warning: Asynchronous search does not support scroll or search requests that include only the suggest section.
/// </para>
/// <para>
/// By default, Elasticsearch does not allow you to store an async search response larger than 10Mb and an attempt to do this results in an error.
/// The maximum allowed size for a stored async search response can be set by changing the <c>search.max_async_search_response_size</c> cluster level setting.
/// </para>
/// </summary>
public sealed partial class SubmitAsyncSearchRequestDescriptor : RequestDescriptor<SubmitAsyncSearchRequestDescriptor, SubmitAsyncSearchRequestParameters>
{
	internal SubmitAsyncSearchRequestDescriptor(Action<SubmitAsyncSearchRequestDescriptor> configure) => configure.Invoke(this);

	public SubmitAsyncSearchRequestDescriptor(Elastic.Clients.Elasticsearch.Indices? indices) : base(r => r.Optional("index", indices))
	{
	}

	public SubmitAsyncSearchRequestDescriptor()
	{
	}

	internal override ApiUrls ApiUrls => ApiUrlLookup.AsyncSearchSubmit;

	protected override HttpMethod StaticHttpMethod => HttpMethod.POST;

	internal override bool SupportsBody => true;

	internal override string OperationName => "async_search.submit";

	public SubmitAsyncSearchRequestDescriptor AllowNoIndices(bool? allowNoIndices = true) => Qs("allow_no_indices", allowNoIndices);
	public SubmitAsyncSearchRequestDescriptor AllowPartialSearchResults(bool? allowPartialSearchResults = true) => Qs("allow_partial_search_results", allowPartialSearchResults);
	public SubmitAsyncSearchRequestDescriptor Analyzer(string? analyzer) => Qs("analyzer", analyzer);
	public SubmitAsyncSearchRequestDescriptor AnalyzeWildcard(bool? analyzeWildcard = true) => Qs("analyze_wildcard", analyzeWildcard);
	public SubmitAsyncSearchRequestDescriptor BatchedReduceSize(long? batchedReduceSize) => Qs("batched_reduce_size", batchedReduceSize);
	public SubmitAsyncSearchRequestDescriptor CcsMinimizeRoundtrips(bool? ccsMinimizeRoundtrips = true) => Qs("ccs_minimize_roundtrips", ccsMinimizeRoundtrips);
	public SubmitAsyncSearchRequestDescriptor DefaultOperator(Elastic.Clients.Elasticsearch.QueryDsl.Operator? defaultOperator) => Qs("default_operator", defaultOperator);
	public SubmitAsyncSearchRequestDescriptor Df(string? df) => Qs("df", df);
	public SubmitAsyncSearchRequestDescriptor ExpandWildcards(ICollection<Elastic.Clients.Elasticsearch.ExpandWildcard>? expandWildcards) => Qs("expand_wildcards", expandWildcards);
	public SubmitAsyncSearchRequestDescriptor IgnoreThrottled(bool? ignoreThrottled = true) => Qs("ignore_throttled", ignoreThrottled);
	public SubmitAsyncSearchRequestDescriptor IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
	public SubmitAsyncSearchRequestDescriptor KeepOnCompletion(bool? keepOnCompletion = true) => Qs("keep_on_completion", keepOnCompletion);
	public SubmitAsyncSearchRequestDescriptor Lenient(bool? lenient = true) => Qs("lenient", lenient);
	public SubmitAsyncSearchRequestDescriptor MaxConcurrentShardRequests(long? maxConcurrentShardRequests) => Qs("max_concurrent_shard_requests", maxConcurrentShardRequests);
	public SubmitAsyncSearchRequestDescriptor Preference(string? preference) => Qs("preference", preference);
	public SubmitAsyncSearchRequestDescriptor QueryLuceneSyntax(string? queryLuceneSyntax) => Qs("q", queryLuceneSyntax);
	public SubmitAsyncSearchRequestDescriptor RequestCache(bool? requestCache = true) => Qs("request_cache", requestCache);
	public SubmitAsyncSearchRequestDescriptor RestTotalHitsAsInt(bool? restTotalHitsAsInt = true) => Qs("rest_total_hits_as_int", restTotalHitsAsInt);
	public SubmitAsyncSearchRequestDescriptor Routing(Elastic.Clients.Elasticsearch.Routing? routing) => Qs("routing", routing);
	public SubmitAsyncSearchRequestDescriptor SearchType(Elastic.Clients.Elasticsearch.SearchType? searchType) => Qs("search_type", searchType);
	public SubmitAsyncSearchRequestDescriptor SourceExcludes(Elastic.Clients.Elasticsearch.Fields? sourceExcludes) => Qs("_source_excludes", sourceExcludes);
	public SubmitAsyncSearchRequestDescriptor SourceIncludes(Elastic.Clients.Elasticsearch.Fields? sourceIncludes) => Qs("_source_includes", sourceIncludes);
	public SubmitAsyncSearchRequestDescriptor SuggestField(Elastic.Clients.Elasticsearch.Field? suggestField) => Qs("suggest_field", suggestField);
	public SubmitAsyncSearchRequestDescriptor SuggestMode(Elastic.Clients.Elasticsearch.SuggestMode? suggestMode) => Qs("suggest_mode", suggestMode);
	public SubmitAsyncSearchRequestDescriptor SuggestSize(long? suggestSize) => Qs("suggest_size", suggestSize);
	public SubmitAsyncSearchRequestDescriptor SuggestText(string? suggestText) => Qs("suggest_text", suggestText);
	public SubmitAsyncSearchRequestDescriptor TypedKeys(bool? typedKeys = true) => Qs("typed_keys", typedKeys);
	public SubmitAsyncSearchRequestDescriptor WaitForCompletionTimeout(Elastic.Clients.Elasticsearch.Duration? waitForCompletionTimeout) => Qs("wait_for_completion_timeout", waitForCompletionTimeout);

	public SubmitAsyncSearchRequestDescriptor Indices(Elastic.Clients.Elasticsearch.Indices? indices)
	{
		RouteValues.Optional("index", indices);
		return Self;
	}

	private IDictionary<string, Elastic.Clients.Elasticsearch.Aggregations.AggregationDescriptor> AggregationsValue { get; set; }
	private Elastic.Clients.Elasticsearch.Core.Search.FieldCollapse? CollapseValue { get; set; }
	private Elastic.Clients.Elasticsearch.Core.Search.FieldCollapseDescriptor CollapseDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.Core.Search.FieldCollapseDescriptor> CollapseDescriptorAction { get; set; }
	private ICollection<Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormat>? DocvalueFieldsValue { get; set; }
	private Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormatDescriptor DocvalueFieldsDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormatDescriptor> DocvalueFieldsDescriptorAction { get; set; }
	private Action<Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormatDescriptor>[] DocvalueFieldsDescriptorActions { get; set; }
	private bool? ExplainValue { get; set; }
	private IDictionary<string, object>? ExtValue { get; set; }
	private ICollection<Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormat>? FieldsValue { get; set; }
	private Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormatDescriptor FieldsDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormatDescriptor> FieldsDescriptorAction { get; set; }
	private Action<Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormatDescriptor>[] FieldsDescriptorActions { get; set; }
	private int? FromValue { get; set; }
	private Elastic.Clients.Elasticsearch.Core.Search.Highlight? HighlightValue { get; set; }
	private Elastic.Clients.Elasticsearch.Core.Search.HighlightDescriptor HighlightDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.Core.Search.HighlightDescriptor> HighlightDescriptorAction { get; set; }
	private ICollection<IDictionary<Elastic.Clients.Elasticsearch.IndexName, double>>? IndicesBoostValue { get; set; }
	private ICollection<Elastic.Clients.Elasticsearch.KnnSearch>? KnnValue { get; set; }
	private Elastic.Clients.Elasticsearch.KnnSearchDescriptor KnnDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.KnnSearchDescriptor> KnnDescriptorAction { get; set; }
	private Action<Elastic.Clients.Elasticsearch.KnnSearchDescriptor>[] KnnDescriptorActions { get; set; }
	private double? MinScoreValue { get; set; }
	private Elastic.Clients.Elasticsearch.Core.Search.PointInTimeReference? PitValue { get; set; }
	private Elastic.Clients.Elasticsearch.Core.Search.PointInTimeReferenceDescriptor PitDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.Core.Search.PointInTimeReferenceDescriptor> PitDescriptorAction { get; set; }
	private Elastic.Clients.Elasticsearch.QueryDsl.Query? PostFilterValue { get; set; }
	private Elastic.Clients.Elasticsearch.QueryDsl.QueryDescriptor PostFilterDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.QueryDsl.QueryDescriptor> PostFilterDescriptorAction { get; set; }
	private bool? ProfileValue { get; set; }
	private Elastic.Clients.Elasticsearch.QueryDsl.Query? QueryValue { get; set; }
	private Elastic.Clients.Elasticsearch.QueryDsl.QueryDescriptor QueryDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.QueryDsl.QueryDescriptor> QueryDescriptorAction { get; set; }
	private ICollection<Elastic.Clients.Elasticsearch.Core.Search.Rescore>? RescoreValue { get; set; }
	private Elastic.Clients.Elasticsearch.Core.Search.RescoreDescriptor RescoreDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.Core.Search.RescoreDescriptor> RescoreDescriptorAction { get; set; }
	private Action<Elastic.Clients.Elasticsearch.Core.Search.RescoreDescriptor>[] RescoreDescriptorActions { get; set; }
	private IDictionary<Elastic.Clients.Elasticsearch.Field, Elastic.Clients.Elasticsearch.Mapping.RuntimeFieldDescriptor> RuntimeMappingsValue { get; set; }
	private IDictionary<string, Elastic.Clients.Elasticsearch.ScriptFieldDescriptor> ScriptFieldsValue { get; set; }
	private ICollection<Elastic.Clients.Elasticsearch.FieldValue>? SearchAfterValue { get; set; }
	private bool? SeqNoPrimaryTermValue { get; set; }
	private int? SizeValue { get; set; }
	private Elastic.Clients.Elasticsearch.SlicedScroll? SliceValue { get; set; }
	private Elastic.Clients.Elasticsearch.SlicedScrollDescriptor SliceDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.SlicedScrollDescriptor> SliceDescriptorAction { get; set; }
	private ICollection<Elastic.Clients.Elasticsearch.SortOptions>? SortValue { get; set; }
	private Elastic.Clients.Elasticsearch.SortOptionsDescriptor SortDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.SortOptionsDescriptor> SortDescriptorAction { get; set; }
	private Action<Elastic.Clients.Elasticsearch.SortOptionsDescriptor>[] SortDescriptorActions { get; set; }
	private Elastic.Clients.Elasticsearch.Core.Search.SourceConfig? SourceValue { get; set; }
	private ICollection<string>? StatsValue { get; set; }
	private Elastic.Clients.Elasticsearch.Fields? StoredFieldsValue { get; set; }
	private Elastic.Clients.Elasticsearch.Core.Search.Suggester? SuggestValue { get; set; }
	private Elastic.Clients.Elasticsearch.Core.Search.SuggesterDescriptor SuggestDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.Core.Search.SuggesterDescriptor> SuggestDescriptorAction { get; set; }
	private long? TerminateAfterValue { get; set; }
	private string? TimeoutValue { get; set; }
	private bool? TrackScoresValue { get; set; }
	private Elastic.Clients.Elasticsearch.Core.Search.TrackHits? TrackTotalHitsValue { get; set; }
	private bool? VersionValue { get; set; }

	public SubmitAsyncSearchRequestDescriptor Aggregations(Func<FluentDescriptorDictionary<string, Elastic.Clients.Elasticsearch.Aggregations.AggregationDescriptor>, FluentDescriptorDictionary<string, Elastic.Clients.Elasticsearch.Aggregations.AggregationDescriptor>> selector)
	{
		AggregationsValue = selector?.Invoke(new FluentDescriptorDictionary<string, Elastic.Clients.Elasticsearch.Aggregations.AggregationDescriptor>());
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor Collapse(Elastic.Clients.Elasticsearch.Core.Search.FieldCollapse? collapse)
	{
		CollapseDescriptor = null;
		CollapseDescriptorAction = null;
		CollapseValue = collapse;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor Collapse(Elastic.Clients.Elasticsearch.Core.Search.FieldCollapseDescriptor descriptor)
	{
		CollapseValue = null;
		CollapseDescriptorAction = null;
		CollapseDescriptor = descriptor;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor Collapse(Action<Elastic.Clients.Elasticsearch.Core.Search.FieldCollapseDescriptor> configure)
	{
		CollapseValue = null;
		CollapseDescriptor = null;
		CollapseDescriptorAction = configure;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Array of wildcard (*) patterns. The request returns doc values for field
	/// names matching these patterns in the hits.fields property of the response.
	/// </para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor DocvalueFields(ICollection<Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormat>? docvalueFields)
	{
		DocvalueFieldsDescriptor = null;
		DocvalueFieldsDescriptorAction = null;
		DocvalueFieldsDescriptorActions = null;
		DocvalueFieldsValue = docvalueFields;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor DocvalueFields(Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormatDescriptor descriptor)
	{
		DocvalueFieldsValue = null;
		DocvalueFieldsDescriptorAction = null;
		DocvalueFieldsDescriptorActions = null;
		DocvalueFieldsDescriptor = descriptor;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor DocvalueFields(Action<Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormatDescriptor> configure)
	{
		DocvalueFieldsValue = null;
		DocvalueFieldsDescriptor = null;
		DocvalueFieldsDescriptorActions = null;
		DocvalueFieldsDescriptorAction = configure;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor DocvalueFields(params Action<Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormatDescriptor>[] configure)
	{
		DocvalueFieldsValue = null;
		DocvalueFieldsDescriptor = null;
		DocvalueFieldsDescriptorAction = null;
		DocvalueFieldsDescriptorActions = configure;
		return Self;
	}

	/// <summary>
	/// <para>
	/// If true, returns detailed information about score computation as part of a hit.
	/// </para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor Explain(bool? explain = true)
	{
		ExplainValue = explain;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Configuration of search extensions defined by Elasticsearch plugins.
	/// </para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor Ext(Func<FluentDictionary<string, object>, FluentDictionary<string, object>> selector)
	{
		ExtValue = selector?.Invoke(new FluentDictionary<string, object>());
		return Self;
	}

	/// <summary>
	/// <para>
	/// Array of wildcard (*) patterns. The request returns values for field names
	/// matching these patterns in the hits.fields property of the response.
	/// </para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor Fields(ICollection<Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormat>? fields)
	{
		FieldsDescriptor = null;
		FieldsDescriptorAction = null;
		FieldsDescriptorActions = null;
		FieldsValue = fields;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor Fields(Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormatDescriptor descriptor)
	{
		FieldsValue = null;
		FieldsDescriptorAction = null;
		FieldsDescriptorActions = null;
		FieldsDescriptor = descriptor;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor Fields(Action<Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormatDescriptor> configure)
	{
		FieldsValue = null;
		FieldsDescriptor = null;
		FieldsDescriptorActions = null;
		FieldsDescriptorAction = configure;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor Fields(params Action<Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormatDescriptor>[] configure)
	{
		FieldsValue = null;
		FieldsDescriptor = null;
		FieldsDescriptorAction = null;
		FieldsDescriptorActions = configure;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Starting document offset. By default, you cannot page through more than 10,000
	/// hits using the from and size parameters. To page through more hits, use the
	/// search_after parameter.
	/// </para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor From(int? from)
	{
		FromValue = from;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor Highlight(Elastic.Clients.Elasticsearch.Core.Search.Highlight? highlight)
	{
		HighlightDescriptor = null;
		HighlightDescriptorAction = null;
		HighlightValue = highlight;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor Highlight(Elastic.Clients.Elasticsearch.Core.Search.HighlightDescriptor descriptor)
	{
		HighlightValue = null;
		HighlightDescriptorAction = null;
		HighlightDescriptor = descriptor;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor Highlight(Action<Elastic.Clients.Elasticsearch.Core.Search.HighlightDescriptor> configure)
	{
		HighlightValue = null;
		HighlightDescriptor = null;
		HighlightDescriptorAction = configure;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Boosts the _score of documents from specified indices.
	/// </para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor IndicesBoost(ICollection<IDictionary<Elastic.Clients.Elasticsearch.IndexName, double>>? indicesBoost)
	{
		IndicesBoostValue = indicesBoost;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Defines the approximate kNN search to run.
	/// </para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor Knn(ICollection<Elastic.Clients.Elasticsearch.KnnSearch>? knn)
	{
		KnnDescriptor = null;
		KnnDescriptorAction = null;
		KnnDescriptorActions = null;
		KnnValue = knn;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor Knn(Elastic.Clients.Elasticsearch.KnnSearchDescriptor descriptor)
	{
		KnnValue = null;
		KnnDescriptorAction = null;
		KnnDescriptorActions = null;
		KnnDescriptor = descriptor;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor Knn(Action<Elastic.Clients.Elasticsearch.KnnSearchDescriptor> configure)
	{
		KnnValue = null;
		KnnDescriptor = null;
		KnnDescriptorActions = null;
		KnnDescriptorAction = configure;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor Knn(params Action<Elastic.Clients.Elasticsearch.KnnSearchDescriptor>[] configure)
	{
		KnnValue = null;
		KnnDescriptor = null;
		KnnDescriptorAction = null;
		KnnDescriptorActions = configure;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Minimum _score for matching documents. Documents with a lower _score are
	/// not included in the search results.
	/// </para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor MinScore(double? minScore)
	{
		MinScoreValue = minScore;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Limits the search to a point in time (PIT). If you provide a PIT, you
	/// cannot specify an &lt;index> in the request path.
	/// </para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor Pit(Elastic.Clients.Elasticsearch.Core.Search.PointInTimeReference? pit)
	{
		PitDescriptor = null;
		PitDescriptorAction = null;
		PitValue = pit;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor Pit(Elastic.Clients.Elasticsearch.Core.Search.PointInTimeReferenceDescriptor descriptor)
	{
		PitValue = null;
		PitDescriptorAction = null;
		PitDescriptor = descriptor;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor Pit(Action<Elastic.Clients.Elasticsearch.Core.Search.PointInTimeReferenceDescriptor> configure)
	{
		PitValue = null;
		PitDescriptor = null;
		PitDescriptorAction = configure;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor PostFilter(Elastic.Clients.Elasticsearch.QueryDsl.Query? postFilter)
	{
		PostFilterDescriptor = null;
		PostFilterDescriptorAction = null;
		PostFilterValue = postFilter;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor PostFilter(Elastic.Clients.Elasticsearch.QueryDsl.QueryDescriptor descriptor)
	{
		PostFilterValue = null;
		PostFilterDescriptorAction = null;
		PostFilterDescriptor = descriptor;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor PostFilter(Action<Elastic.Clients.Elasticsearch.QueryDsl.QueryDescriptor> configure)
	{
		PostFilterValue = null;
		PostFilterDescriptor = null;
		PostFilterDescriptorAction = configure;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor Profile(bool? profile = true)
	{
		ProfileValue = profile;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Defines the search definition using the Query DSL.
	/// </para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor Query(Elastic.Clients.Elasticsearch.QueryDsl.Query? query)
	{
		QueryDescriptor = null;
		QueryDescriptorAction = null;
		QueryValue = query;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor Query(Elastic.Clients.Elasticsearch.QueryDsl.QueryDescriptor descriptor)
	{
		QueryValue = null;
		QueryDescriptorAction = null;
		QueryDescriptor = descriptor;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor Query(Action<Elastic.Clients.Elasticsearch.QueryDsl.QueryDescriptor> configure)
	{
		QueryValue = null;
		QueryDescriptor = null;
		QueryDescriptorAction = configure;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor Rescore(ICollection<Elastic.Clients.Elasticsearch.Core.Search.Rescore>? rescore)
	{
		RescoreDescriptor = null;
		RescoreDescriptorAction = null;
		RescoreDescriptorActions = null;
		RescoreValue = rescore;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor Rescore(Elastic.Clients.Elasticsearch.Core.Search.RescoreDescriptor descriptor)
	{
		RescoreValue = null;
		RescoreDescriptorAction = null;
		RescoreDescriptorActions = null;
		RescoreDescriptor = descriptor;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor Rescore(Action<Elastic.Clients.Elasticsearch.Core.Search.RescoreDescriptor> configure)
	{
		RescoreValue = null;
		RescoreDescriptor = null;
		RescoreDescriptorActions = null;
		RescoreDescriptorAction = configure;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor Rescore(params Action<Elastic.Clients.Elasticsearch.Core.Search.RescoreDescriptor>[] configure)
	{
		RescoreValue = null;
		RescoreDescriptor = null;
		RescoreDescriptorAction = null;
		RescoreDescriptorActions = configure;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Defines one or more runtime fields in the search request. These fields take
	/// precedence over mapped fields with the same name.
	/// </para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor RuntimeMappings(Func<FluentDescriptorDictionary<Elastic.Clients.Elasticsearch.Field, Elastic.Clients.Elasticsearch.Mapping.RuntimeFieldDescriptor>, FluentDescriptorDictionary<Elastic.Clients.Elasticsearch.Field, Elastic.Clients.Elasticsearch.Mapping.RuntimeFieldDescriptor>> selector)
	{
		RuntimeMappingsValue = selector?.Invoke(new FluentDescriptorDictionary<Elastic.Clients.Elasticsearch.Field, Elastic.Clients.Elasticsearch.Mapping.RuntimeFieldDescriptor>());
		return Self;
	}

	/// <summary>
	/// <para>
	/// Retrieve a script evaluation (based on different fields) for each hit.
	/// </para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor ScriptFields(Func<FluentDescriptorDictionary<string, Elastic.Clients.Elasticsearch.ScriptFieldDescriptor>, FluentDescriptorDictionary<string, Elastic.Clients.Elasticsearch.ScriptFieldDescriptor>> selector)
	{
		ScriptFieldsValue = selector?.Invoke(new FluentDescriptorDictionary<string, Elastic.Clients.Elasticsearch.ScriptFieldDescriptor>());
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor SearchAfter(ICollection<Elastic.Clients.Elasticsearch.FieldValue>? searchAfter)
	{
		SearchAfterValue = searchAfter;
		return Self;
	}

	/// <summary>
	/// <para>
	/// If true, returns sequence number and primary term of the last modification
	/// of each hit. See Optimistic concurrency control.
	/// </para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor SeqNoPrimaryTerm(bool? seqNoPrimaryTerm = true)
	{
		SeqNoPrimaryTermValue = seqNoPrimaryTerm;
		return Self;
	}

	/// <summary>
	/// <para>
	/// The number of hits to return. By default, you cannot page through more
	/// than 10,000 hits using the from and size parameters. To page through more
	/// hits, use the search_after parameter.
	/// </para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor Size(int? size)
	{
		SizeValue = size;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor Slice(Elastic.Clients.Elasticsearch.SlicedScroll? slice)
	{
		SliceDescriptor = null;
		SliceDescriptorAction = null;
		SliceValue = slice;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor Slice(Elastic.Clients.Elasticsearch.SlicedScrollDescriptor descriptor)
	{
		SliceValue = null;
		SliceDescriptorAction = null;
		SliceDescriptor = descriptor;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor Slice(Action<Elastic.Clients.Elasticsearch.SlicedScrollDescriptor> configure)
	{
		SliceValue = null;
		SliceDescriptor = null;
		SliceDescriptorAction = configure;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor Sort(ICollection<Elastic.Clients.Elasticsearch.SortOptions>? sort)
	{
		SortDescriptor = null;
		SortDescriptorAction = null;
		SortDescriptorActions = null;
		SortValue = sort;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor Sort(Elastic.Clients.Elasticsearch.SortOptionsDescriptor descriptor)
	{
		SortValue = null;
		SortDescriptorAction = null;
		SortDescriptorActions = null;
		SortDescriptor = descriptor;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor Sort(Action<Elastic.Clients.Elasticsearch.SortOptionsDescriptor> configure)
	{
		SortValue = null;
		SortDescriptor = null;
		SortDescriptorActions = null;
		SortDescriptorAction = configure;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor Sort(params Action<Elastic.Clients.Elasticsearch.SortOptionsDescriptor>[] configure)
	{
		SortValue = null;
		SortDescriptor = null;
		SortDescriptorAction = null;
		SortDescriptorActions = configure;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Indicates which source fields are returned for matching documents. These
	/// fields are returned in the hits._source property of the search response.
	/// </para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor Source(Elastic.Clients.Elasticsearch.Core.Search.SourceConfig? source)
	{
		SourceValue = source;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Stats groups to associate with the search. Each group maintains a statistics
	/// aggregation for its associated searches. You can retrieve these stats using
	/// the indices stats API.
	/// </para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor Stats(ICollection<string>? stats)
	{
		StatsValue = stats;
		return Self;
	}

	/// <summary>
	/// <para>
	/// List of stored fields to return as part of a hit. If no fields are specified,
	/// no stored fields are included in the response. If this field is specified, the _source
	/// parameter defaults to false. You can pass _source: true to return both source fields
	/// and stored fields in the search response.
	/// </para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor StoredFields(Elastic.Clients.Elasticsearch.Fields? storedFields)
	{
		StoredFieldsValue = storedFields;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor Suggest(Elastic.Clients.Elasticsearch.Core.Search.Suggester? suggest)
	{
		SuggestDescriptor = null;
		SuggestDescriptorAction = null;
		SuggestValue = suggest;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor Suggest(Elastic.Clients.Elasticsearch.Core.Search.SuggesterDescriptor descriptor)
	{
		SuggestValue = null;
		SuggestDescriptorAction = null;
		SuggestDescriptor = descriptor;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor Suggest(Action<Elastic.Clients.Elasticsearch.Core.Search.SuggesterDescriptor> configure)
	{
		SuggestValue = null;
		SuggestDescriptor = null;
		SuggestDescriptorAction = configure;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Maximum number of documents to collect for each shard. If a query reaches this
	/// limit, Elasticsearch terminates the query early. Elasticsearch collects documents
	/// before sorting. Defaults to 0, which does not terminate query execution early.
	/// </para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor TerminateAfter(long? terminateAfter)
	{
		TerminateAfterValue = terminateAfter;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Specifies the period of time to wait for a response from each shard. If no response
	/// is received before the timeout expires, the request fails and returns an error.
	/// Defaults to no timeout.
	/// </para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor Timeout(string? timeout)
	{
		TimeoutValue = timeout;
		return Self;
	}

	/// <summary>
	/// <para>
	/// If true, calculate and return document scores, even if the scores are not used for sorting.
	/// </para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor TrackScores(bool? trackScores = true)
	{
		TrackScoresValue = trackScores;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Number of hits matching the query to count accurately. If true, the exact
	/// number of hits is returned at the cost of some performance. If false, the
	/// response does not include the total number of hits matching the query.
	/// Defaults to 10,000 hits.
	/// </para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor TrackTotalHits(Elastic.Clients.Elasticsearch.Core.Search.TrackHits? trackTotalHits)
	{
		TrackTotalHitsValue = trackTotalHits;
		return Self;
	}

	/// <summary>
	/// <para>
	/// If true, returns document version as part of a hit.
	/// </para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor Version(bool? version = true)
	{
		VersionValue = version;
		return Self;
	}

	protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
	{
		writer.WriteStartObject();
		if (AggregationsValue is not null)
		{
			writer.WritePropertyName("aggregations");
			JsonSerializer.Serialize(writer, AggregationsValue, options);
		}

		if (CollapseDescriptor is not null)
		{
			writer.WritePropertyName("collapse");
			JsonSerializer.Serialize(writer, CollapseDescriptor, options);
		}
		else if (CollapseDescriptorAction is not null)
		{
			writer.WritePropertyName("collapse");
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.Core.Search.FieldCollapseDescriptor(CollapseDescriptorAction), options);
		}
		else if (CollapseValue is not null)
		{
			writer.WritePropertyName("collapse");
			JsonSerializer.Serialize(writer, CollapseValue, options);
		}

		if (DocvalueFieldsDescriptor is not null)
		{
			writer.WritePropertyName("docvalue_fields");
			writer.WriteStartArray();
			JsonSerializer.Serialize(writer, DocvalueFieldsDescriptor, options);
			writer.WriteEndArray();
		}
		else if (DocvalueFieldsDescriptorAction is not null)
		{
			writer.WritePropertyName("docvalue_fields");
			writer.WriteStartArray();
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormatDescriptor(DocvalueFieldsDescriptorAction), options);
			writer.WriteEndArray();
		}
		else if (DocvalueFieldsDescriptorActions is not null)
		{
			writer.WritePropertyName("docvalue_fields");
			writer.WriteStartArray();
			foreach (var action in DocvalueFieldsDescriptorActions)
			{
				JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormatDescriptor(action), options);
			}

			writer.WriteEndArray();
		}
		else if (DocvalueFieldsValue is not null)
		{
			writer.WritePropertyName("docvalue_fields");
			JsonSerializer.Serialize(writer, DocvalueFieldsValue, options);
		}

		if (ExplainValue.HasValue)
		{
			writer.WritePropertyName("explain");
			writer.WriteBooleanValue(ExplainValue.Value);
		}

		if (ExtValue is not null)
		{
			writer.WritePropertyName("ext");
			JsonSerializer.Serialize(writer, ExtValue, options);
		}

		if (FieldsDescriptor is not null)
		{
			writer.WritePropertyName("fields");
			writer.WriteStartArray();
			JsonSerializer.Serialize(writer, FieldsDescriptor, options);
			writer.WriteEndArray();
		}
		else if (FieldsDescriptorAction is not null)
		{
			writer.WritePropertyName("fields");
			writer.WriteStartArray();
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormatDescriptor(FieldsDescriptorAction), options);
			writer.WriteEndArray();
		}
		else if (FieldsDescriptorActions is not null)
		{
			writer.WritePropertyName("fields");
			writer.WriteStartArray();
			foreach (var action in FieldsDescriptorActions)
			{
				JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormatDescriptor(action), options);
			}

			writer.WriteEndArray();
		}
		else if (FieldsValue is not null)
		{
			writer.WritePropertyName("fields");
			JsonSerializer.Serialize(writer, FieldsValue, options);
		}

		if (FromValue.HasValue)
		{
			writer.WritePropertyName("from");
			writer.WriteNumberValue(FromValue.Value);
		}

		if (HighlightDescriptor is not null)
		{
			writer.WritePropertyName("highlight");
			JsonSerializer.Serialize(writer, HighlightDescriptor, options);
		}
		else if (HighlightDescriptorAction is not null)
		{
			writer.WritePropertyName("highlight");
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.Core.Search.HighlightDescriptor(HighlightDescriptorAction), options);
		}
		else if (HighlightValue is not null)
		{
			writer.WritePropertyName("highlight");
			JsonSerializer.Serialize(writer, HighlightValue, options);
		}

		if (IndicesBoostValue is not null)
		{
			writer.WritePropertyName("indices_boost");
			JsonSerializer.Serialize(writer, IndicesBoostValue, options);
		}

		if (KnnDescriptor is not null)
		{
			writer.WritePropertyName("knn");
			JsonSerializer.Serialize(writer, KnnDescriptor, options);
		}
		else if (KnnDescriptorAction is not null)
		{
			writer.WritePropertyName("knn");
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.KnnSearchDescriptor(KnnDescriptorAction), options);
		}
		else if (KnnDescriptorActions is not null)
		{
			writer.WritePropertyName("knn");
			if (KnnDescriptorActions.Length != 1)
				writer.WriteStartArray();
			foreach (var action in KnnDescriptorActions)
			{
				JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.KnnSearchDescriptor(action), options);
			}

			if (KnnDescriptorActions.Length != 1)
				writer.WriteEndArray();
		}
		else if (KnnValue is not null)
		{
			writer.WritePropertyName("knn");
			SingleOrManySerializationHelper.Serialize<Elastic.Clients.Elasticsearch.KnnSearch>(KnnValue, writer, options);
		}

		if (MinScoreValue.HasValue)
		{
			writer.WritePropertyName("min_score");
			writer.WriteNumberValue(MinScoreValue.Value);
		}

		if (PitDescriptor is not null)
		{
			writer.WritePropertyName("pit");
			JsonSerializer.Serialize(writer, PitDescriptor, options);
		}
		else if (PitDescriptorAction is not null)
		{
			writer.WritePropertyName("pit");
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.Core.Search.PointInTimeReferenceDescriptor(PitDescriptorAction), options);
		}
		else if (PitValue is not null)
		{
			writer.WritePropertyName("pit");
			JsonSerializer.Serialize(writer, PitValue, options);
		}

		if (PostFilterDescriptor is not null)
		{
			writer.WritePropertyName("post_filter");
			JsonSerializer.Serialize(writer, PostFilterDescriptor, options);
		}
		else if (PostFilterDescriptorAction is not null)
		{
			writer.WritePropertyName("post_filter");
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.QueryDsl.QueryDescriptor(PostFilterDescriptorAction), options);
		}
		else if (PostFilterValue is not null)
		{
			writer.WritePropertyName("post_filter");
			JsonSerializer.Serialize(writer, PostFilterValue, options);
		}

		if (ProfileValue.HasValue)
		{
			writer.WritePropertyName("profile");
			writer.WriteBooleanValue(ProfileValue.Value);
		}

		if (QueryDescriptor is not null)
		{
			writer.WritePropertyName("query");
			JsonSerializer.Serialize(writer, QueryDescriptor, options);
		}
		else if (QueryDescriptorAction is not null)
		{
			writer.WritePropertyName("query");
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.QueryDsl.QueryDescriptor(QueryDescriptorAction), options);
		}
		else if (QueryValue is not null)
		{
			writer.WritePropertyName("query");
			JsonSerializer.Serialize(writer, QueryValue, options);
		}

		if (RescoreDescriptor is not null)
		{
			writer.WritePropertyName("rescore");
			JsonSerializer.Serialize(writer, RescoreDescriptor, options);
		}
		else if (RescoreDescriptorAction is not null)
		{
			writer.WritePropertyName("rescore");
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.Core.Search.RescoreDescriptor(RescoreDescriptorAction), options);
		}
		else if (RescoreDescriptorActions is not null)
		{
			writer.WritePropertyName("rescore");
			if (RescoreDescriptorActions.Length != 1)
				writer.WriteStartArray();
			foreach (var action in RescoreDescriptorActions)
			{
				JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.Core.Search.RescoreDescriptor(action), options);
			}

			if (RescoreDescriptorActions.Length != 1)
				writer.WriteEndArray();
		}
		else if (RescoreValue is not null)
		{
			writer.WritePropertyName("rescore");
			SingleOrManySerializationHelper.Serialize<Elastic.Clients.Elasticsearch.Core.Search.Rescore>(RescoreValue, writer, options);
		}

		if (RuntimeMappingsValue is not null)
		{
			writer.WritePropertyName("runtime_mappings");
			JsonSerializer.Serialize(writer, RuntimeMappingsValue, options);
		}

		if (ScriptFieldsValue is not null)
		{
			writer.WritePropertyName("script_fields");
			JsonSerializer.Serialize(writer, ScriptFieldsValue, options);
		}

		if (SearchAfterValue is not null)
		{
			writer.WritePropertyName("search_after");
			JsonSerializer.Serialize(writer, SearchAfterValue, options);
		}

		if (SeqNoPrimaryTermValue.HasValue)
		{
			writer.WritePropertyName("seq_no_primary_term");
			writer.WriteBooleanValue(SeqNoPrimaryTermValue.Value);
		}

		if (SizeValue.HasValue)
		{
			writer.WritePropertyName("size");
			writer.WriteNumberValue(SizeValue.Value);
		}

		if (SliceDescriptor is not null)
		{
			writer.WritePropertyName("slice");
			JsonSerializer.Serialize(writer, SliceDescriptor, options);
		}
		else if (SliceDescriptorAction is not null)
		{
			writer.WritePropertyName("slice");
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.SlicedScrollDescriptor(SliceDescriptorAction), options);
		}
		else if (SliceValue is not null)
		{
			writer.WritePropertyName("slice");
			JsonSerializer.Serialize(writer, SliceValue, options);
		}

		if (SortDescriptor is not null)
		{
			writer.WritePropertyName("sort");
			JsonSerializer.Serialize(writer, SortDescriptor, options);
		}
		else if (SortDescriptorAction is not null)
		{
			writer.WritePropertyName("sort");
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.SortOptionsDescriptor(SortDescriptorAction), options);
		}
		else if (SortDescriptorActions is not null)
		{
			writer.WritePropertyName("sort");
			if (SortDescriptorActions.Length != 1)
				writer.WriteStartArray();
			foreach (var action in SortDescriptorActions)
			{
				JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.SortOptionsDescriptor(action), options);
			}

			if (SortDescriptorActions.Length != 1)
				writer.WriteEndArray();
		}
		else if (SortValue is not null)
		{
			writer.WritePropertyName("sort");
			SingleOrManySerializationHelper.Serialize<Elastic.Clients.Elasticsearch.SortOptions>(SortValue, writer, options);
		}

		if (SourceValue is not null)
		{
			writer.WritePropertyName("_source");
			JsonSerializer.Serialize(writer, SourceValue, options);
		}

		if (StatsValue is not null)
		{
			writer.WritePropertyName("stats");
			JsonSerializer.Serialize(writer, StatsValue, options);
		}

		if (StoredFieldsValue is not null)
		{
			writer.WritePropertyName("stored_fields");
			JsonSerializer.Serialize(writer, StoredFieldsValue, options);
		}

		if (SuggestDescriptor is not null)
		{
			writer.WritePropertyName("suggest");
			JsonSerializer.Serialize(writer, SuggestDescriptor, options);
		}
		else if (SuggestDescriptorAction is not null)
		{
			writer.WritePropertyName("suggest");
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.Core.Search.SuggesterDescriptor(SuggestDescriptorAction), options);
		}
		else if (SuggestValue is not null)
		{
			writer.WritePropertyName("suggest");
			JsonSerializer.Serialize(writer, SuggestValue, options);
		}

		if (TerminateAfterValue.HasValue)
		{
			writer.WritePropertyName("terminate_after");
			writer.WriteNumberValue(TerminateAfterValue.Value);
		}

		if (!string.IsNullOrEmpty(TimeoutValue))
		{
			writer.WritePropertyName("timeout");
			writer.WriteStringValue(TimeoutValue);
		}

		if (TrackScoresValue.HasValue)
		{
			writer.WritePropertyName("track_scores");
			writer.WriteBooleanValue(TrackScoresValue.Value);
		}

		if (TrackTotalHitsValue is not null)
		{
			writer.WritePropertyName("track_total_hits");
			JsonSerializer.Serialize(writer, TrackTotalHitsValue, options);
		}

		if (VersionValue.HasValue)
		{
			writer.WritePropertyName("version");
			writer.WriteBooleanValue(VersionValue.Value);
		}

		writer.WriteEndObject();
	}
}