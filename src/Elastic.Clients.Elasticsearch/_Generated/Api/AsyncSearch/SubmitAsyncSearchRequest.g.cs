// Licensed to Elasticsearch B.V under one or more agreements.
// Elasticsearch B.V licenses this file to you under the Apache 2.0 License.
// See the LICENSE file in the project root for more information.
//
// ███╗   ██╗ ██████╗ ████████╗██╗ ██████╗███████╗
// ████╗  ██║██╔═══██╗╚══██╔══╝██║██╔════╝██╔════╝
// ██╔██╗ ██║██║   ██║   ██║   ██║██║     █████╗
// ██║╚██╗██║██║   ██║   ██║   ██║██║     ██╔══╝
// ██║ ╚████║╚██████╔╝   ██║   ██║╚██████╗███████╗
// ╚═╝  ╚═══╝ ╚═════╝    ╚═╝   ╚═╝ ╚═════╝╚══════╝
// ------------------------------------------------
//
// This file is automatically generated.
// Please do not edit these files manually.
//
// ------------------------------------------------

#nullable restore

using Elastic.Clients.Elasticsearch.Fluent;
using Elastic.Clients.Elasticsearch.Requests;
using Elastic.Clients.Elasticsearch.Serialization;
using Elastic.Transport;
using System;
using System.Collections.Generic;
using System.Linq.Expressions;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace Elastic.Clients.Elasticsearch.AsyncSearch;

public sealed class SubmitAsyncSearchRequestParameters : RequestParameters
{
	/// <summary>
	/// <para>Blocks and waits until the search is completed up to a certain timeout.<br/>When the async search completes within the timeout, the response won’t include the ID as the results are not stored in the cluster.</para>
	/// </summary>
	public Elastic.Clients.Elasticsearch.Duration? WaitForCompletionTimeout { get => Q<Elastic.Clients.Elasticsearch.Duration?>("wait_for_completion_timeout"); set => Q("wait_for_completion_timeout", value); }

	/// <summary>
	/// <para>If `true`, results are stored for later retrieval when the search completes within the `wait_for_completion_timeout`.</para>
	/// </summary>
	public bool? KeepOnCompletion { get => Q<bool?>("keep_on_completion"); set => Q("keep_on_completion", value); }

	/// <summary>
	/// <para>Specifies how long the async search needs to be available.<br/>Ongoing async searches and any saved search results are deleted after this period.</para>
	/// </summary>
	public Elastic.Clients.Elasticsearch.Duration? KeepAlive { get => Q<Elastic.Clients.Elasticsearch.Duration?>("keep_alive"); set => Q("keep_alive", value); }

	/// <summary>
	/// <para>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</para>
	/// </summary>
	public bool? AllowNoIndices { get => Q<bool?>("allow_no_indices"); set => Q("allow_no_indices", value); }

	/// <summary>
	/// <para>Indicate if an error should be returned if there is a partial search failure or timeout</para>
	/// </summary>
	public bool? AllowPartialSearchResults { get => Q<bool?>("allow_partial_search_results"); set => Q("allow_partial_search_results", value); }

	/// <summary>
	/// <para>The analyzer to use for the query string</para>
	/// </summary>
	public string? Analyzer { get => Q<string?>("analyzer"); set => Q("analyzer", value); }

	/// <summary>
	/// <para>Specify whether wildcard and prefix queries should be analyzed (default: false)</para>
	/// </summary>
	public bool? AnalyzeWildcard { get => Q<bool?>("analyze_wildcard"); set => Q("analyze_wildcard", value); }

	/// <summary>
	/// <para>Affects how often partial results become available, which happens whenever shard results are reduced.<br/>A partial reduction is performed every time the coordinating node has received a certain number of new shard responses (5 by default).</para>
	/// </summary>
	public long? BatchedReduceSize { get => Q<long?>("batched_reduce_size"); set => Q("batched_reduce_size", value); }

	/// <summary>
	/// <para>The default value is the only supported value.</para>
	/// </summary>
	public bool? CcsMinimizeRoundtrips { get => Q<bool?>("ccs_minimize_roundtrips"); set => Q("ccs_minimize_roundtrips", value); }

	/// <summary>
	/// <para>The default operator for query string query (AND or OR)</para>
	/// </summary>
	public Elastic.Clients.Elasticsearch.QueryDsl.Operator? DefaultOperator { get => Q<Elastic.Clients.Elasticsearch.QueryDsl.Operator?>("default_operator"); set => Q("default_operator", value); }

	/// <summary>
	/// <para>The field to use as default where no field prefix is given in the query string</para>
	/// </summary>
	public string? Df { get => Q<string?>("df"); set => Q("df", value); }

	/// <summary>
	/// <para>Whether to expand wildcard expression to concrete indices that are open, closed or both.</para>
	/// </summary>
	public ICollection<Elastic.Clients.Elasticsearch.ExpandWildcard>? ExpandWildcards { get => Q<ICollection<Elastic.Clients.Elasticsearch.ExpandWildcard>?>("expand_wildcards"); set => Q("expand_wildcards", value); }

	/// <summary>
	/// <para>Whether specified concrete, expanded or aliased indices should be ignored when throttled</para>
	/// </summary>
	public bool? IgnoreThrottled { get => Q<bool?>("ignore_throttled"); set => Q("ignore_throttled", value); }

	/// <summary>
	/// <para>Whether specified concrete indices should be ignored when unavailable (missing or closed)</para>
	/// </summary>
	public bool? IgnoreUnavailable { get => Q<bool?>("ignore_unavailable"); set => Q("ignore_unavailable", value); }

	/// <summary>
	/// <para>Specify whether format-based query failures (such as providing text to a numeric field) should be ignored</para>
	/// </summary>
	public bool? Lenient { get => Q<bool?>("lenient"); set => Q("lenient", value); }

	/// <summary>
	/// <para>The number of concurrent shard requests per node this search executes concurrently. This value should be used to limit the impact of the search on the cluster in order to limit the number of concurrent shard requests</para>
	/// </summary>
	public long? MaxConcurrentShardRequests { get => Q<long?>("max_concurrent_shard_requests"); set => Q("max_concurrent_shard_requests", value); }
	public string? MinCompatibleShardNode { get => Q<string?>("min_compatible_shard_node"); set => Q("min_compatible_shard_node", value); }

	/// <summary>
	/// <para>Specify the node or shard the operation should be performed on (default: random)</para>
	/// </summary>
	public string? Preference { get => Q<string?>("preference"); set => Q("preference", value); }

	/// <summary>
	/// <para>The default value cannot be changed, which enforces the execution of a pre-filter roundtrip to retrieve statistics from each shard so that the ones that surely don’t hold any document matching the query get skipped.</para>
	/// </summary>
	public long? PreFilterShardSize { get => Q<long?>("pre_filter_shard_size"); set => Q("pre_filter_shard_size", value); }

	/// <summary>
	/// <para>Specify if request cache should be used for this request or not, defaults to true</para>
	/// </summary>
	public bool? RequestCache { get => Q<bool?>("request_cache"); set => Q("request_cache", value); }

	/// <summary>
	/// <para>A comma-separated list of specific routing values</para>
	/// </summary>
	public Elastic.Clients.Elasticsearch.Routing? Routing { get => Q<Elastic.Clients.Elasticsearch.Routing?>("routing"); set => Q("routing", value); }
	public Elastic.Clients.Elasticsearch.Duration? Scroll { get => Q<Elastic.Clients.Elasticsearch.Duration?>("scroll"); set => Q("scroll", value); }

	/// <summary>
	/// <para>Search operation type</para>
	/// </summary>
	public Elastic.Clients.Elasticsearch.SearchType? SearchType { get => Q<Elastic.Clients.Elasticsearch.SearchType?>("search_type"); set => Q("search_type", value); }

	/// <summary>
	/// <para>Specifies which field to use for suggestions.</para>
	/// </summary>
	public Elastic.Clients.Elasticsearch.Field? SuggestField { get => Q<Elastic.Clients.Elasticsearch.Field?>("suggest_field"); set => Q("suggest_field", value); }

	/// <summary>
	/// <para>Specify suggest mode</para>
	/// </summary>
	public Elastic.Clients.Elasticsearch.SuggestMode? SuggestMode { get => Q<Elastic.Clients.Elasticsearch.SuggestMode?>("suggest_mode"); set => Q("suggest_mode", value); }

	/// <summary>
	/// <para>How many suggestions to return in response</para>
	/// </summary>
	public long? SuggestSize { get => Q<long?>("suggest_size"); set => Q("suggest_size", value); }

	/// <summary>
	/// <para>The source text for which the suggestions should be returned.</para>
	/// </summary>
	public string? SuggestText { get => Q<string?>("suggest_text"); set => Q("suggest_text", value); }

	/// <summary>
	/// <para>Specify whether aggregation and suggester names should be prefixed by their respective types in the response</para>
	/// </summary>
	public bool? TypedKeys { get => Q<bool?>("typed_keys"); set => Q("typed_keys", value); }
	public bool? RestTotalHitsAsInt { get => Q<bool?>("rest_total_hits_as_int"); set => Q("rest_total_hits_as_int", value); }

	/// <summary>
	/// <para>A list of fields to exclude from the returned _source field</para>
	/// </summary>
	public Elastic.Clients.Elasticsearch.Fields? SourceExcludes { get => Q<Elastic.Clients.Elasticsearch.Fields?>("_source_excludes"); set => Q("_source_excludes", value); }

	/// <summary>
	/// <para>A list of fields to extract and return from the _source field</para>
	/// </summary>
	public Elastic.Clients.Elasticsearch.Fields? SourceIncludes { get => Q<Elastic.Clients.Elasticsearch.Fields?>("_source_includes"); set => Q("_source_includes", value); }

	/// <summary>
	/// <para>Query in the Lucene query string syntax</para>
	/// </summary>
	public string? QueryLuceneSyntax { get => Q<string?>("q"); set => Q("q", value); }
}

internal sealed partial class SubmitAsyncSearchRequestConverter : JsonConverter<SubmitAsyncSearchRequest>
{
	public override SubmitAsyncSearchRequest Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
	{
		if (reader.TokenType != JsonTokenType.StartObject)
			throw new JsonException("Unexpected JSON detected.");
		var variant = new SubmitAsyncSearchRequest();
		while (reader.Read() && reader.TokenType != JsonTokenType.EndObject)
		{
			if (reader.TokenType == JsonTokenType.PropertyName)
			{
				var property = reader.GetString();
				if (property == "aggregations" || property == "aggs")
				{
					variant.Aggregations = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.AggregationDictionary?>(ref reader, options);
					continue;
				}

				if (property == "collapse")
				{
					variant.Collapse = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Core.Search.FieldCollapse?>(ref reader, options);
					continue;
				}

				if (property == "explain")
				{
					variant.Explain = JsonSerializer.Deserialize<bool?>(ref reader, options);
					continue;
				}

				if (property == "ext")
				{
					variant.Ext = JsonSerializer.Deserialize<IDictionary<string, object>?>(ref reader, options);
					continue;
				}

				if (property == "from")
				{
					variant.From = JsonSerializer.Deserialize<int?>(ref reader, options);
					continue;
				}

				if (property == "highlight")
				{
					variant.Highlight = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Core.Search.Highlight?>(ref reader, options);
					continue;
				}

				if (property == "track_total_hits")
				{
					variant.TrackTotalHits = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Core.Search.TrackHits?>(ref reader, options);
					continue;
				}

				if (property == "indices_boost")
				{
					variant.IndicesBoost = JsonSerializer.Deserialize<ICollection<IDictionary<Elastic.Clients.Elasticsearch.IndexName, double>>?>(ref reader, options);
					continue;
				}

				if (property == "docvalue_fields")
				{
					variant.DocvalueFields = JsonSerializer.Deserialize<ICollection<Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormat>?>(ref reader, options);
					continue;
				}

				if (property == "knn")
				{
					variant.Knn = JsonSerializer.Deserialize<ICollection<Elastic.Clients.Elasticsearch.KnnQuery>?>(ref reader, options);
					continue;
				}

				if (property == "min_score")
				{
					variant.MinScore = JsonSerializer.Deserialize<double?>(ref reader, options);
					continue;
				}

				if (property == "post_filter")
				{
					variant.PostFilter = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.Query?>(ref reader, options);
					continue;
				}

				if (property == "profile")
				{
					variant.Profile = JsonSerializer.Deserialize<bool?>(ref reader, options);
					continue;
				}

				if (property == "query")
				{
					variant.Query = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.Query?>(ref reader, options);
					continue;
				}

				if (property == "rescore")
				{
					variant.Rescore = JsonSerializer.Deserialize<ICollection<Elastic.Clients.Elasticsearch.Core.Search.Rescore>?>(ref reader, options);
					continue;
				}

				if (property == "script_fields")
				{
					variant.ScriptFields = JsonSerializer.Deserialize<IDictionary<string, Elastic.Clients.Elasticsearch.ScriptField>?>(ref reader, options);
					continue;
				}

				if (property == "search_after")
				{
					variant.SearchAfter = JsonSerializer.Deserialize<ICollection<Elastic.Clients.Elasticsearch.FieldValue>?>(ref reader, options);
					continue;
				}

				if (property == "size")
				{
					variant.Size = JsonSerializer.Deserialize<int?>(ref reader, options);
					continue;
				}

				if (property == "slice")
				{
					variant.Slice = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.SlicedScroll?>(ref reader, options);
					continue;
				}

				if (property == "sort")
				{
					variant.Sort = JsonSerializer.Deserialize<ICollection<Elastic.Clients.Elasticsearch.SortOptions>?>(ref reader, options);
					continue;
				}

				if (property == "_source")
				{
					variant.Source = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Core.Search.SourceConfig?>(ref reader, options);
					continue;
				}

				if (property == "fields")
				{
					variant.Fields = JsonSerializer.Deserialize<ICollection<Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormat>?>(ref reader, options);
					continue;
				}

				if (property == "suggest")
				{
					variant.Suggest = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Core.Search.Suggester?>(ref reader, options);
					continue;
				}

				if (property == "terminate_after")
				{
					variant.TerminateAfter = JsonSerializer.Deserialize<long?>(ref reader, options);
					continue;
				}

				if (property == "timeout")
				{
					variant.Timeout = JsonSerializer.Deserialize<string?>(ref reader, options);
					continue;
				}

				if (property == "track_scores")
				{
					variant.TrackScores = JsonSerializer.Deserialize<bool?>(ref reader, options);
					continue;
				}

				if (property == "version")
				{
					variant.Version = JsonSerializer.Deserialize<bool?>(ref reader, options);
					continue;
				}

				if (property == "seq_no_primary_term")
				{
					variant.SeqNoPrimaryTerm = JsonSerializer.Deserialize<bool?>(ref reader, options);
					continue;
				}

				if (property == "stored_fields")
				{
					variant.StoredFields = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Fields?>(ref reader, options);
					continue;
				}

				if (property == "pit")
				{
					variant.Pit = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Core.Search.PointInTimeReference?>(ref reader, options);
					continue;
				}

				if (property == "runtime_mappings")
				{
					variant.RuntimeMappings = JsonSerializer.Deserialize<IDictionary<Elastic.Clients.Elasticsearch.Field, Elastic.Clients.Elasticsearch.Mapping.RuntimeField>?>(ref reader, options);
					continue;
				}

				if (property == "stats")
				{
					variant.Stats = JsonSerializer.Deserialize<ICollection<string>?>(ref reader, options);
					continue;
				}
			}
		}

		return variant;
	}

	public override void Write(Utf8JsonWriter writer, SubmitAsyncSearchRequest value, JsonSerializerOptions options)
	{
		writer.WriteStartObject();
		if (value.Aggregations is not null)
		{
			writer.WritePropertyName("aggregations");
			JsonSerializer.Serialize(writer, value.Aggregations, options);
		}

		if (value.Collapse is not null)
		{
			writer.WritePropertyName("collapse");
			JsonSerializer.Serialize(writer, value.Collapse, options);
		}

		if (value.Explain.HasValue)
		{
			writer.WritePropertyName("explain");
			writer.WriteBooleanValue(value.Explain.Value);
		}

		if (value.Ext is not null)
		{
			writer.WritePropertyName("ext");
			JsonSerializer.Serialize(writer, value.Ext, options);
		}

		if (value.From.HasValue)
		{
			writer.WritePropertyName("from");
			writer.WriteNumberValue(value.From.Value);
		}

		if (value.Highlight is not null)
		{
			writer.WritePropertyName("highlight");
			JsonSerializer.Serialize(writer, value.Highlight, options);
		}

		if (value.TrackTotalHits is not null)
		{
			writer.WritePropertyName("track_total_hits");
			JsonSerializer.Serialize(writer, value.TrackTotalHits, options);
		}

		if (value.IndicesBoost is not null)
		{
			writer.WritePropertyName("indices_boost");
			JsonSerializer.Serialize(writer, value.IndicesBoost, options);
		}

		if (value.DocvalueFields is not null)
		{
			writer.WritePropertyName("docvalue_fields");
			JsonSerializer.Serialize(writer, value.DocvalueFields, options);
		}

		if (value.Knn is not null)
		{
			writer.WritePropertyName("knn");
			JsonSerializer.Serialize(writer, value.Knn, options);
		}

		if (value.MinScore.HasValue)
		{
			writer.WritePropertyName("min_score");
			writer.WriteNumberValue(value.MinScore.Value);
		}

		if (value.PostFilter is not null)
		{
			writer.WritePropertyName("post_filter");
			JsonSerializer.Serialize(writer, value.PostFilter, options);
		}

		if (value.Profile.HasValue)
		{
			writer.WritePropertyName("profile");
			writer.WriteBooleanValue(value.Profile.Value);
		}

		if (value.Query is not null)
		{
			writer.WritePropertyName("query");
			JsonSerializer.Serialize(writer, value.Query, options);
		}

		if (value.Rescore is not null)
		{
			writer.WritePropertyName("rescore");
			JsonSerializer.Serialize(writer, value.Rescore, options);
		}

		if (value.ScriptFields is not null)
		{
			writer.WritePropertyName("script_fields");
			JsonSerializer.Serialize(writer, value.ScriptFields, options);
		}

		if (value.SearchAfter is not null)
		{
			writer.WritePropertyName("search_after");
			JsonSerializer.Serialize(writer, value.SearchAfter, options);
		}

		if (value.Size.HasValue)
		{
			writer.WritePropertyName("size");
			writer.WriteNumberValue(value.Size.Value);
		}

		if (value.Slice is not null)
		{
			writer.WritePropertyName("slice");
			JsonSerializer.Serialize(writer, value.Slice, options);
		}

		if (value.Sort is not null)
		{
			writer.WritePropertyName("sort");
			JsonSerializer.Serialize(writer, value.Sort, options);
		}

		if (value.Source is not null)
		{
			writer.WritePropertyName("_source");
			JsonSerializer.Serialize(writer, value.Source, options);
		}

		if (value.Fields is not null)
		{
			writer.WritePropertyName("fields");
			JsonSerializer.Serialize(writer, value.Fields, options);
		}

		if (value.Suggest is not null)
		{
			writer.WritePropertyName("suggest");
			JsonSerializer.Serialize(writer, value.Suggest, options);
		}

		if (value.TerminateAfter.HasValue)
		{
			writer.WritePropertyName("terminate_after");
			writer.WriteNumberValue(value.TerminateAfter.Value);
		}

		if (!string.IsNullOrEmpty(value.Timeout))
		{
			writer.WritePropertyName("timeout");
			writer.WriteStringValue(value.Timeout);
		}

		if (value.TrackScores.HasValue)
		{
			writer.WritePropertyName("track_scores");
			writer.WriteBooleanValue(value.TrackScores.Value);
		}

		if (value.Version.HasValue)
		{
			writer.WritePropertyName("version");
			writer.WriteBooleanValue(value.Version.Value);
		}

		if (value.SeqNoPrimaryTerm.HasValue)
		{
			writer.WritePropertyName("seq_no_primary_term");
			writer.WriteBooleanValue(value.SeqNoPrimaryTerm.Value);
		}

		if (value.StoredFields is not null)
		{
			writer.WritePropertyName("stored_fields");
			JsonSerializer.Serialize(writer, value.StoredFields, options);
		}

		if (value.Pit is not null)
		{
			writer.WritePropertyName("pit");
			JsonSerializer.Serialize(writer, value.Pit, options);
		}

		if (value.RuntimeMappings is not null)
		{
			writer.WritePropertyName("runtime_mappings");
			JsonSerializer.Serialize(writer, value.RuntimeMappings, options);
		}

		if (value.Stats is not null)
		{
			writer.WritePropertyName("stats");
			JsonSerializer.Serialize(writer, value.Stats, options);
		}

		writer.WriteEndObject();
	}
}

[JsonConverter(typeof(SubmitAsyncSearchRequestConverter))]
/// <summary>
/// <para>Runs a search request asynchronously.<br/>When the primary sort of the results is an indexed field, shards get sorted based on minimum and maximum value that they hold for that field, hence partial results become available following the sort criteria that was requested.<br/>Warning: Async search does not support scroll nor search requests that only include the suggest section.<br/>By default, Elasticsearch doesn’t allow you to store an async search response larger than 10Mb and an attempt to do this results in an error.<br/>The maximum allowed size for a stored async search response can be set by changing the `search.max_async_search_response_size` cluster level setting.</para>
/// </summary>
public sealed partial class SubmitAsyncSearchRequest : PlainRequest<SubmitAsyncSearchRequestParameters>
{
	public SubmitAsyncSearchRequest()
	{
	}

	public SubmitAsyncSearchRequest(Elastic.Clients.Elasticsearch.Indices? indices) : base(r => r.Optional("index", indices))
	{
	}

	internal override ApiUrls ApiUrls => ApiUrlLookup.AsyncSearchSubmit;

	protected override HttpMethod StaticHttpMethod => HttpMethod.POST;

	internal override bool SupportsBody => true;

	/// <summary>
	/// <para>Blocks and waits until the search is completed up to a certain timeout.<br/>When the async search completes within the timeout, the response won’t include the ID as the results are not stored in the cluster.</para>
	/// </summary>
	[JsonIgnore]
	public Elastic.Clients.Elasticsearch.Duration? WaitForCompletionTimeout { get => Q<Elastic.Clients.Elasticsearch.Duration?>("wait_for_completion_timeout"); set => Q("wait_for_completion_timeout", value); }

	/// <summary>
	/// <para>If `true`, results are stored for later retrieval when the search completes within the `wait_for_completion_timeout`.</para>
	/// </summary>
	[JsonIgnore]
	public bool? KeepOnCompletion { get => Q<bool?>("keep_on_completion"); set => Q("keep_on_completion", value); }

	/// <summary>
	/// <para>Specifies how long the async search needs to be available.<br/>Ongoing async searches and any saved search results are deleted after this period.</para>
	/// </summary>
	[JsonIgnore]
	public Elastic.Clients.Elasticsearch.Duration? KeepAlive { get => Q<Elastic.Clients.Elasticsearch.Duration?>("keep_alive"); set => Q("keep_alive", value); }

	/// <summary>
	/// <para>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</para>
	/// </summary>
	[JsonIgnore]
	public bool? AllowNoIndices { get => Q<bool?>("allow_no_indices"); set => Q("allow_no_indices", value); }

	/// <summary>
	/// <para>Indicate if an error should be returned if there is a partial search failure or timeout</para>
	/// </summary>
	[JsonIgnore]
	public bool? AllowPartialSearchResults { get => Q<bool?>("allow_partial_search_results"); set => Q("allow_partial_search_results", value); }

	/// <summary>
	/// <para>The analyzer to use for the query string</para>
	/// </summary>
	[JsonIgnore]
	public string? Analyzer { get => Q<string?>("analyzer"); set => Q("analyzer", value); }

	/// <summary>
	/// <para>Specify whether wildcard and prefix queries should be analyzed (default: false)</para>
	/// </summary>
	[JsonIgnore]
	public bool? AnalyzeWildcard { get => Q<bool?>("analyze_wildcard"); set => Q("analyze_wildcard", value); }

	/// <summary>
	/// <para>Affects how often partial results become available, which happens whenever shard results are reduced.<br/>A partial reduction is performed every time the coordinating node has received a certain number of new shard responses (5 by default).</para>
	/// </summary>
	[JsonIgnore]
	public long? BatchedReduceSize { get => Q<long?>("batched_reduce_size"); set => Q("batched_reduce_size", value); }

	/// <summary>
	/// <para>The default value is the only supported value.</para>
	/// </summary>
	[JsonIgnore]
	public bool? CcsMinimizeRoundtrips { get => Q<bool?>("ccs_minimize_roundtrips"); set => Q("ccs_minimize_roundtrips", value); }

	/// <summary>
	/// <para>The default operator for query string query (AND or OR)</para>
	/// </summary>
	[JsonIgnore]
	public Elastic.Clients.Elasticsearch.QueryDsl.Operator? DefaultOperator { get => Q<Elastic.Clients.Elasticsearch.QueryDsl.Operator?>("default_operator"); set => Q("default_operator", value); }

	/// <summary>
	/// <para>The field to use as default where no field prefix is given in the query string</para>
	/// </summary>
	[JsonIgnore]
	public string? Df { get => Q<string?>("df"); set => Q("df", value); }

	/// <summary>
	/// <para>Whether to expand wildcard expression to concrete indices that are open, closed or both.</para>
	/// </summary>
	[JsonIgnore]
	public ICollection<Elastic.Clients.Elasticsearch.ExpandWildcard>? ExpandWildcards { get => Q<ICollection<Elastic.Clients.Elasticsearch.ExpandWildcard>?>("expand_wildcards"); set => Q("expand_wildcards", value); }

	/// <summary>
	/// <para>Whether specified concrete, expanded or aliased indices should be ignored when throttled</para>
	/// </summary>
	[JsonIgnore]
	public bool? IgnoreThrottled { get => Q<bool?>("ignore_throttled"); set => Q("ignore_throttled", value); }

	/// <summary>
	/// <para>Whether specified concrete indices should be ignored when unavailable (missing or closed)</para>
	/// </summary>
	[JsonIgnore]
	public bool? IgnoreUnavailable { get => Q<bool?>("ignore_unavailable"); set => Q("ignore_unavailable", value); }

	/// <summary>
	/// <para>Specify whether format-based query failures (such as providing text to a numeric field) should be ignored</para>
	/// </summary>
	[JsonIgnore]
	public bool? Lenient { get => Q<bool?>("lenient"); set => Q("lenient", value); }

	/// <summary>
	/// <para>The number of concurrent shard requests per node this search executes concurrently. This value should be used to limit the impact of the search on the cluster in order to limit the number of concurrent shard requests</para>
	/// </summary>
	[JsonIgnore]
	public long? MaxConcurrentShardRequests { get => Q<long?>("max_concurrent_shard_requests"); set => Q("max_concurrent_shard_requests", value); }
	[JsonIgnore]
	public string? MinCompatibleShardNode { get => Q<string?>("min_compatible_shard_node"); set => Q("min_compatible_shard_node", value); }

	/// <summary>
	/// <para>Specify the node or shard the operation should be performed on (default: random)</para>
	/// </summary>
	[JsonIgnore]
	public string? Preference { get => Q<string?>("preference"); set => Q("preference", value); }

	/// <summary>
	/// <para>The default value cannot be changed, which enforces the execution of a pre-filter roundtrip to retrieve statistics from each shard so that the ones that surely don’t hold any document matching the query get skipped.</para>
	/// </summary>
	[JsonIgnore]
	public long? PreFilterShardSize { get => Q<long?>("pre_filter_shard_size"); set => Q("pre_filter_shard_size", value); }

	/// <summary>
	/// <para>Specify if request cache should be used for this request or not, defaults to true</para>
	/// </summary>
	[JsonIgnore]
	public bool? RequestCache { get => Q<bool?>("request_cache"); set => Q("request_cache", value); }

	/// <summary>
	/// <para>A comma-separated list of specific routing values</para>
	/// </summary>
	[JsonIgnore]
	public Elastic.Clients.Elasticsearch.Routing? Routing { get => Q<Elastic.Clients.Elasticsearch.Routing?>("routing"); set => Q("routing", value); }
	[JsonIgnore]
	public Elastic.Clients.Elasticsearch.Duration? Scroll { get => Q<Elastic.Clients.Elasticsearch.Duration?>("scroll"); set => Q("scroll", value); }

	/// <summary>
	/// <para>Search operation type</para>
	/// </summary>
	[JsonIgnore]
	public Elastic.Clients.Elasticsearch.SearchType? SearchType { get => Q<Elastic.Clients.Elasticsearch.SearchType?>("search_type"); set => Q("search_type", value); }

	/// <summary>
	/// <para>Specifies which field to use for suggestions.</para>
	/// </summary>
	[JsonIgnore]
	public Elastic.Clients.Elasticsearch.Field? SuggestField { get => Q<Elastic.Clients.Elasticsearch.Field?>("suggest_field"); set => Q("suggest_field", value); }

	/// <summary>
	/// <para>Specify suggest mode</para>
	/// </summary>
	[JsonIgnore]
	public Elastic.Clients.Elasticsearch.SuggestMode? SuggestMode { get => Q<Elastic.Clients.Elasticsearch.SuggestMode?>("suggest_mode"); set => Q("suggest_mode", value); }

	/// <summary>
	/// <para>How many suggestions to return in response</para>
	/// </summary>
	[JsonIgnore]
	public long? SuggestSize { get => Q<long?>("suggest_size"); set => Q("suggest_size", value); }

	/// <summary>
	/// <para>The source text for which the suggestions should be returned.</para>
	/// </summary>
	[JsonIgnore]
	public string? SuggestText { get => Q<string?>("suggest_text"); set => Q("suggest_text", value); }

	/// <summary>
	/// <para>Specify whether aggregation and suggester names should be prefixed by their respective types in the response</para>
	/// </summary>
	[JsonIgnore]
	public bool? TypedKeys { get => Q<bool?>("typed_keys"); set => Q("typed_keys", value); }
	[JsonIgnore]
	public bool? RestTotalHitsAsInt { get => Q<bool?>("rest_total_hits_as_int"); set => Q("rest_total_hits_as_int", value); }

	/// <summary>
	/// <para>A list of fields to exclude from the returned _source field</para>
	/// </summary>
	[JsonIgnore]
	public Elastic.Clients.Elasticsearch.Fields? SourceExcludes { get => Q<Elastic.Clients.Elasticsearch.Fields?>("_source_excludes"); set => Q("_source_excludes", value); }

	/// <summary>
	/// <para>A list of fields to extract and return from the _source field</para>
	/// </summary>
	[JsonIgnore]
	public Elastic.Clients.Elasticsearch.Fields? SourceIncludes { get => Q<Elastic.Clients.Elasticsearch.Fields?>("_source_includes"); set => Q("_source_includes", value); }

	/// <summary>
	/// <para>Query in the Lucene query string syntax</para>
	/// </summary>
	[JsonIgnore]
	public string? QueryLuceneSyntax { get => Q<string?>("q"); set => Q("q", value); }
	[JsonInclude, JsonPropertyName("aggregations")]
	public Elastic.Clients.Elasticsearch.Aggregations.AggregationDictionary? Aggregations { get; set; }
	[JsonInclude, JsonPropertyName("collapse")]
	public Elastic.Clients.Elasticsearch.Core.Search.FieldCollapse? Collapse { get; set; }

	/// <summary>
	/// <para>If true, returns detailed information about score computation as part of a hit.</para>
	/// </summary>
	[JsonInclude, JsonPropertyName("explain")]
	public bool? Explain { get; set; }

	/// <summary>
	/// <para>Configuration of search extensions defined by Elasticsearch plugins.</para>
	/// </summary>
	[JsonInclude, JsonPropertyName("ext")]
	public IDictionary<string, object>? Ext { get; set; }

	/// <summary>
	/// <para>Starting document offset. By default, you cannot page through more than 10,000<br/>hits using the from and size parameters. To page through more hits, use the<br/>search_after parameter.</para>
	/// </summary>
	[JsonInclude, JsonPropertyName("from")]
	public int? From { get; set; }
	[JsonInclude, JsonPropertyName("highlight")]
	public Elastic.Clients.Elasticsearch.Core.Search.Highlight? Highlight { get; set; }

	/// <summary>
	/// <para>Number of hits matching the query to count accurately. If true, the exact<br/>number of hits is returned at the cost of some performance. If false, the<br/>response does not include the total number of hits matching the query.<br/>Defaults to 10,000 hits.</para>
	/// </summary>
	[JsonInclude, JsonPropertyName("track_total_hits")]
	public Elastic.Clients.Elasticsearch.Core.Search.TrackHits? TrackTotalHits { get; set; }

	/// <summary>
	/// <para>Boosts the _score of documents from specified indices.</para>
	/// </summary>
	[JsonInclude, JsonPropertyName("indices_boost")]
	public ICollection<IDictionary<Elastic.Clients.Elasticsearch.IndexName, double>>? IndicesBoost { get; set; }

	/// <summary>
	/// <para>Array of wildcard (*) patterns. The request returns doc values for field<br/>names matching these patterns in the hits.fields property of the response.</para>
	/// </summary>
	[JsonInclude, JsonPropertyName("docvalue_fields")]
	public ICollection<Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormat>? DocvalueFields { get; set; }

	/// <summary>
	/// <para>Defines the approximate kNN search to run.</para>
	/// </summary>
	[JsonInclude, JsonPropertyName("knn"), SingleOrManyCollectionConverter(typeof(Elastic.Clients.Elasticsearch.KnnQuery))]
	public ICollection<Elastic.Clients.Elasticsearch.KnnQuery>? Knn { get; set; }

	/// <summary>
	/// <para>Minimum _score for matching documents. Documents with a lower _score are<br/>not included in the search results.</para>
	/// </summary>
	[JsonInclude, JsonPropertyName("min_score")]
	public double? MinScore { get; set; }
	[JsonInclude, JsonPropertyName("post_filter")]
	public Elastic.Clients.Elasticsearch.QueryDsl.Query? PostFilter { get; set; }
	[JsonInclude, JsonPropertyName("profile")]
	public bool? Profile { get; set; }

	/// <summary>
	/// <para>Defines the search definition using the Query DSL.</para>
	/// </summary>
	[JsonInclude, JsonPropertyName("query")]
	public Elastic.Clients.Elasticsearch.QueryDsl.Query? Query { get; set; }
	[JsonInclude, JsonPropertyName("rescore"), SingleOrManyCollectionConverter(typeof(Elastic.Clients.Elasticsearch.Core.Search.Rescore))]
	public ICollection<Elastic.Clients.Elasticsearch.Core.Search.Rescore>? Rescore { get; set; }

	/// <summary>
	/// <para>Retrieve a script evaluation (based on different fields) for each hit.</para>
	/// </summary>
	[JsonInclude, JsonPropertyName("script_fields")]
	public IDictionary<string, Elastic.Clients.Elasticsearch.ScriptField>? ScriptFields { get; set; }
	[JsonInclude, JsonPropertyName("search_after")]
	public ICollection<Elastic.Clients.Elasticsearch.FieldValue>? SearchAfter { get; set; }

	/// <summary>
	/// <para>The number of hits to return. By default, you cannot page through more<br/>than 10,000 hits using the from and size parameters. To page through more<br/>hits, use the search_after parameter.</para>
	/// </summary>
	[JsonInclude, JsonPropertyName("size")]
	public int? Size { get; set; }
	[JsonInclude, JsonPropertyName("slice")]
	public Elastic.Clients.Elasticsearch.SlicedScroll? Slice { get; set; }
	[JsonInclude, JsonPropertyName("sort"), SingleOrManyCollectionConverter(typeof(Elastic.Clients.Elasticsearch.SortOptions))]
	public ICollection<Elastic.Clients.Elasticsearch.SortOptions>? Sort { get; set; }

	/// <summary>
	/// <para>Indicates which source fields are returned for matching documents. These<br/>fields are returned in the hits._source property of the search response.</para>
	/// </summary>
	[JsonInclude, JsonPropertyName("_source")]
	public Elastic.Clients.Elasticsearch.Core.Search.SourceConfig? Source { get; set; }

	/// <summary>
	/// <para>Array of wildcard (*) patterns. The request returns values for field names<br/>matching these patterns in the hits.fields property of the response.</para>
	/// </summary>
	[JsonInclude, JsonPropertyName("fields")]
	public ICollection<Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormat>? Fields { get; set; }
	[JsonInclude, JsonPropertyName("suggest")]
	public Elastic.Clients.Elasticsearch.Core.Search.Suggester? Suggest { get; set; }

	/// <summary>
	/// <para>Maximum number of documents to collect for each shard. If a query reaches this<br/>limit, Elasticsearch terminates the query early. Elasticsearch collects documents<br/>before sorting. Defaults to 0, which does not terminate query execution early.</para>
	/// </summary>
	[JsonInclude, JsonPropertyName("terminate_after")]
	public long? TerminateAfter { get; set; }

	/// <summary>
	/// <para>Specifies the period of time to wait for a response from each shard. If no response<br/>is received before the timeout expires, the request fails and returns an error.<br/>Defaults to no timeout.</para>
	/// </summary>
	[JsonInclude, JsonPropertyName("timeout")]
	public string? Timeout { get; set; }

	/// <summary>
	/// <para>If true, calculate and return document scores, even if the scores are not used for sorting.</para>
	/// </summary>
	[JsonInclude, JsonPropertyName("track_scores")]
	public bool? TrackScores { get; set; }

	/// <summary>
	/// <para>If true, returns document version as part of a hit.</para>
	/// </summary>
	[JsonInclude, JsonPropertyName("version")]
	public bool? Version { get; set; }

	/// <summary>
	/// <para>If true, returns sequence number and primary term of the last modification<br/>of each hit. See Optimistic concurrency control.</para>
	/// </summary>
	[JsonInclude, JsonPropertyName("seq_no_primary_term")]
	public bool? SeqNoPrimaryTerm { get; set; }

	/// <summary>
	/// <para>List of stored fields to return as part of a hit. If no fields are specified,<br/>no stored fields are included in the response. If this field is specified, the _source<br/>parameter defaults to false. You can pass _source: true to return both source fields<br/>and stored fields in the search response.</para>
	/// </summary>
	[JsonInclude, JsonPropertyName("stored_fields")]
	public Elastic.Clients.Elasticsearch.Fields? StoredFields { get; set; }

	/// <summary>
	/// <para>Limits the search to a point in time (PIT). If you provide a PIT, you<br/>cannot specify an <index> in the request path.</para>
	/// </summary>
	[JsonInclude, JsonPropertyName("pit")]
	public Elastic.Clients.Elasticsearch.Core.Search.PointInTimeReference? Pit { get; set; }

	/// <summary>
	/// <para>Defines one or more runtime fields in the search request. These fields take<br/>precedence over mapped fields with the same name.</para>
	/// </summary>
	[JsonInclude, JsonPropertyName("runtime_mappings")]
	public IDictionary<Elastic.Clients.Elasticsearch.Field, Elastic.Clients.Elasticsearch.Mapping.RuntimeField>? RuntimeMappings { get; set; }

	/// <summary>
	/// <para>Stats groups to associate with the search. Each group maintains a statistics<br/>aggregation for its associated searches. You can retrieve these stats using<br/>the indices stats API.</para>
	/// </summary>
	[JsonInclude, JsonPropertyName("stats")]
	public ICollection<string>? Stats { get; set; }
}

/// <summary>
/// <para>Runs a search request asynchronously.<br/>When the primary sort of the results is an indexed field, shards get sorted based on minimum and maximum value that they hold for that field, hence partial results become available following the sort criteria that was requested.<br/>Warning: Async search does not support scroll nor search requests that only include the suggest section.<br/>By default, Elasticsearch doesn’t allow you to store an async search response larger than 10Mb and an attempt to do this results in an error.<br/>The maximum allowed size for a stored async search response can be set by changing the `search.max_async_search_response_size` cluster level setting.</para>
/// </summary>
public sealed partial class SubmitAsyncSearchRequestDescriptor<TDocument> : RequestDescriptor<SubmitAsyncSearchRequestDescriptor<TDocument>, SubmitAsyncSearchRequestParameters>
{
	internal SubmitAsyncSearchRequestDescriptor(Action<SubmitAsyncSearchRequestDescriptor<TDocument>> configure) => configure.Invoke(this);

	public SubmitAsyncSearchRequestDescriptor()
	{
	}

	internal override ApiUrls ApiUrls => ApiUrlLookup.AsyncSearchSubmit;

	protected override HttpMethod StaticHttpMethod => HttpMethod.POST;

	internal override bool SupportsBody => true;

	public SubmitAsyncSearchRequestDescriptor<TDocument> SourceExcludes(Elastic.Clients.Elasticsearch.Fields? sourceExcludes) => Qs("_source_excludes", sourceExcludes);
	public SubmitAsyncSearchRequestDescriptor<TDocument> SourceIncludes(Elastic.Clients.Elasticsearch.Fields? sourceIncludes) => Qs("_source_includes", sourceIncludes);
	public SubmitAsyncSearchRequestDescriptor<TDocument> AllowNoIndices(bool? allowNoIndices = true) => Qs("allow_no_indices", allowNoIndices);
	public SubmitAsyncSearchRequestDescriptor<TDocument> AllowPartialSearchResults(bool? allowPartialSearchResults = true) => Qs("allow_partial_search_results", allowPartialSearchResults);
	public SubmitAsyncSearchRequestDescriptor<TDocument> AnalyzeWildcard(bool? analyzeWildcard = true) => Qs("analyze_wildcard", analyzeWildcard);
	public SubmitAsyncSearchRequestDescriptor<TDocument> Analyzer(string? analyzer) => Qs("analyzer", analyzer);
	public SubmitAsyncSearchRequestDescriptor<TDocument> BatchedReduceSize(long? batchedReduceSize) => Qs("batched_reduce_size", batchedReduceSize);
	public SubmitAsyncSearchRequestDescriptor<TDocument> CcsMinimizeRoundtrips(bool? ccsMinimizeRoundtrips = true) => Qs("ccs_minimize_roundtrips", ccsMinimizeRoundtrips);
	public SubmitAsyncSearchRequestDescriptor<TDocument> DefaultOperator(Elastic.Clients.Elasticsearch.QueryDsl.Operator? defaultOperator) => Qs("default_operator", defaultOperator);
	public SubmitAsyncSearchRequestDescriptor<TDocument> Df(string? df) => Qs("df", df);
	public SubmitAsyncSearchRequestDescriptor<TDocument> ExpandWildcards(ICollection<Elastic.Clients.Elasticsearch.ExpandWildcard>? expandWildcards) => Qs("expand_wildcards", expandWildcards);
	public SubmitAsyncSearchRequestDescriptor<TDocument> IgnoreThrottled(bool? ignoreThrottled = true) => Qs("ignore_throttled", ignoreThrottled);
	public SubmitAsyncSearchRequestDescriptor<TDocument> IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
	public SubmitAsyncSearchRequestDescriptor<TDocument> KeepAlive(Elastic.Clients.Elasticsearch.Duration? keepAlive) => Qs("keep_alive", keepAlive);
	public SubmitAsyncSearchRequestDescriptor<TDocument> KeepOnCompletion(bool? keepOnCompletion = true) => Qs("keep_on_completion", keepOnCompletion);
	public SubmitAsyncSearchRequestDescriptor<TDocument> Lenient(bool? lenient = true) => Qs("lenient", lenient);
	public SubmitAsyncSearchRequestDescriptor<TDocument> MaxConcurrentShardRequests(long? maxConcurrentShardRequests) => Qs("max_concurrent_shard_requests", maxConcurrentShardRequests);
	public SubmitAsyncSearchRequestDescriptor<TDocument> MinCompatibleShardNode(string? minCompatibleShardNode) => Qs("min_compatible_shard_node", minCompatibleShardNode);
	public SubmitAsyncSearchRequestDescriptor<TDocument> PreFilterShardSize(long? preFilterShardSize) => Qs("pre_filter_shard_size", preFilterShardSize);
	public SubmitAsyncSearchRequestDescriptor<TDocument> Preference(string? preference) => Qs("preference", preference);
	public SubmitAsyncSearchRequestDescriptor<TDocument> QueryLuceneSyntax(string? q) => Qs("q", q);
	public SubmitAsyncSearchRequestDescriptor<TDocument> RequestCache(bool? requestCache = true) => Qs("request_cache", requestCache);
	public SubmitAsyncSearchRequestDescriptor<TDocument> RestTotalHitsAsInt(bool? restTotalHitsAsInt = true) => Qs("rest_total_hits_as_int", restTotalHitsAsInt);
	public SubmitAsyncSearchRequestDescriptor<TDocument> Routing(Elastic.Clients.Elasticsearch.Routing? routing) => Qs("routing", routing);
	public SubmitAsyncSearchRequestDescriptor<TDocument> Scroll(Elastic.Clients.Elasticsearch.Duration? scroll) => Qs("scroll", scroll);
	public SubmitAsyncSearchRequestDescriptor<TDocument> SearchType(Elastic.Clients.Elasticsearch.SearchType? searchType) => Qs("search_type", searchType);
	public SubmitAsyncSearchRequestDescriptor<TDocument> SuggestField(Elastic.Clients.Elasticsearch.Field? suggestField) => Qs("suggest_field", suggestField);
	public SubmitAsyncSearchRequestDescriptor<TDocument> SuggestMode(Elastic.Clients.Elasticsearch.SuggestMode? suggestMode) => Qs("suggest_mode", suggestMode);
	public SubmitAsyncSearchRequestDescriptor<TDocument> SuggestSize(long? suggestSize) => Qs("suggest_size", suggestSize);
	public SubmitAsyncSearchRequestDescriptor<TDocument> SuggestText(string? suggestText) => Qs("suggest_text", suggestText);
	public SubmitAsyncSearchRequestDescriptor<TDocument> TypedKeys(bool? typedKeys = true) => Qs("typed_keys", typedKeys);
	public SubmitAsyncSearchRequestDescriptor<TDocument> WaitForCompletionTimeout(Elastic.Clients.Elasticsearch.Duration? waitForCompletionTimeout) => Qs("wait_for_completion_timeout", waitForCompletionTimeout);

	public SubmitAsyncSearchRequestDescriptor<TDocument> Indices(Elastic.Clients.Elasticsearch.Indices? indices)
	{
		RouteValues.Optional("index", indices);
		return Self;
	}

	private Elastic.Clients.Elasticsearch.Aggregations.AggregationDictionary? AggregationsValue { get; set; }
	private Elastic.Clients.Elasticsearch.Aggregations.AggregationDescriptor<TDocument> AggregationsDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.Aggregations.AggregationDescriptor<TDocument>> AggregationsDescriptorAction { get; set; }
	private Elastic.Clients.Elasticsearch.Core.Search.FieldCollapse? CollapseValue { get; set; }
	private Core.Search.FieldCollapseDescriptor<TDocument> CollapseDescriptor { get; set; }
	private Action<Core.Search.FieldCollapseDescriptor<TDocument>> CollapseDescriptorAction { get; set; }
	private ICollection<Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormat>? DocvalueFieldsValue { get; set; }
	private QueryDsl.FieldAndFormatDescriptor<TDocument> DocvalueFieldsDescriptor { get; set; }
	private Action<QueryDsl.FieldAndFormatDescriptor<TDocument>> DocvalueFieldsDescriptorAction { get; set; }
	private Action<QueryDsl.FieldAndFormatDescriptor<TDocument>>[] DocvalueFieldsDescriptorActions { get; set; }
	private ICollection<Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormat>? FieldsValue { get; set; }
	private QueryDsl.FieldAndFormatDescriptor<TDocument> FieldsDescriptor { get; set; }
	private Action<QueryDsl.FieldAndFormatDescriptor<TDocument>> FieldsDescriptorAction { get; set; }
	private Action<QueryDsl.FieldAndFormatDescriptor<TDocument>>[] FieldsDescriptorActions { get; set; }
	private Elastic.Clients.Elasticsearch.Core.Search.Highlight? HighlightValue { get; set; }
	private Core.Search.HighlightDescriptor<TDocument> HighlightDescriptor { get; set; }
	private Action<Core.Search.HighlightDescriptor<TDocument>> HighlightDescriptorAction { get; set; }
	private ICollection<Elastic.Clients.Elasticsearch.KnnQuery>? KnnValue { get; set; }
	private KnnQueryDescriptor<TDocument> KnnDescriptor { get; set; }
	private Action<KnnQueryDescriptor<TDocument>> KnnDescriptorAction { get; set; }
	private Action<KnnQueryDescriptor<TDocument>>[] KnnDescriptorActions { get; set; }
	private Elastic.Clients.Elasticsearch.QueryDsl.Query? PostFilterValue { get; set; }
	private QueryDsl.QueryDescriptor<TDocument> PostFilterDescriptor { get; set; }
	private Action<QueryDsl.QueryDescriptor<TDocument>> PostFilterDescriptorAction { get; set; }
	private Elastic.Clients.Elasticsearch.QueryDsl.Query? QueryValue { get; set; }
	private QueryDsl.QueryDescriptor<TDocument> QueryDescriptor { get; set; }
	private Action<QueryDsl.QueryDescriptor<TDocument>> QueryDescriptorAction { get; set; }
	private ICollection<Elastic.Clients.Elasticsearch.Core.Search.Rescore>? RescoreValue { get; set; }
	private Core.Search.RescoreDescriptor<TDocument> RescoreDescriptor { get; set; }
	private Action<Core.Search.RescoreDescriptor<TDocument>> RescoreDescriptorAction { get; set; }
	private Action<Core.Search.RescoreDescriptor<TDocument>>[] RescoreDescriptorActions { get; set; }
	private Elastic.Clients.Elasticsearch.SlicedScroll? SliceValue { get; set; }
	private SlicedScrollDescriptor<TDocument> SliceDescriptor { get; set; }
	private Action<SlicedScrollDescriptor<TDocument>> SliceDescriptorAction { get; set; }
	private ICollection<Elastic.Clients.Elasticsearch.SortOptions>? SortValue { get; set; }
	private SortOptionsDescriptor<TDocument> SortDescriptor { get; set; }
	private Action<SortOptionsDescriptor<TDocument>> SortDescriptorAction { get; set; }
	private Action<SortOptionsDescriptor<TDocument>>[] SortDescriptorActions { get; set; }
	private Elastic.Clients.Elasticsearch.Core.Search.SourceConfig? SourceValue { get; set; }
	private bool? ExplainValue { get; set; }
	private IDictionary<string, object>? ExtValue { get; set; }
	private int? FromValue { get; set; }
	private ICollection<IDictionary<Elastic.Clients.Elasticsearch.IndexName, double>>? IndicesBoostValue { get; set; }
	private double? MinScoreValue { get; set; }
	private Elastic.Clients.Elasticsearch.Core.Search.PointInTimeReference? PitValue { get; set; }
	private Core.Search.PointInTimeReferenceDescriptor PitDescriptor { get; set; }
	private Action<Core.Search.PointInTimeReferenceDescriptor> PitDescriptorAction { get; set; }
	private bool? ProfileValue { get; set; }
	private IDictionary<Elastic.Clients.Elasticsearch.Field, Elastic.Clients.Elasticsearch.Mapping.RuntimeField>? RuntimeMappingsValue { get; set; }
	private IDictionary<string, Elastic.Clients.Elasticsearch.ScriptField>? ScriptFieldsValue { get; set; }
	private ICollection<Elastic.Clients.Elasticsearch.FieldValue>? SearchAfterValue { get; set; }
	private bool? SeqNoPrimaryTermValue { get; set; }
	private int? SizeValue { get; set; }
	private ICollection<string>? StatsValue { get; set; }
	private Elastic.Clients.Elasticsearch.Fields? StoredFieldsValue { get; set; }
	private Elastic.Clients.Elasticsearch.Core.Search.Suggester? SuggestValue { get; set; }
	private Core.Search.SuggesterDescriptor SuggestDescriptor { get; set; }
	private Action<Core.Search.SuggesterDescriptor> SuggestDescriptorAction { get; set; }
	private long? TerminateAfterValue { get; set; }
	private string? TimeoutValue { get; set; }
	private bool? TrackScoresValue { get; set; }
	private Elastic.Clients.Elasticsearch.Core.Search.TrackHits? TrackTotalHitsValue { get; set; }
	private bool? VersionValue { get; set; }

	public SubmitAsyncSearchRequestDescriptor<TDocument> Aggregations(Elastic.Clients.Elasticsearch.Aggregations.AggregationDictionary? aggregations)
	{
		AggregationsDescriptor = null;
		AggregationsDescriptorAction = null;
		AggregationsValue = aggregations;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor<TDocument> Aggregations(Elastic.Clients.Elasticsearch.Aggregations.AggregationDescriptor<TDocument> descriptor)
	{
		AggregationsValue = null;
		AggregationsDescriptorAction = null;
		AggregationsDescriptor = descriptor;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor<TDocument> Aggregations(Action<Elastic.Clients.Elasticsearch.Aggregations.AggregationDescriptor<TDocument>> configure)
	{
		AggregationsValue = null;
		AggregationsDescriptor = null;
		AggregationsDescriptorAction = configure;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor<TDocument> Collapse(Elastic.Clients.Elasticsearch.Core.Search.FieldCollapse? collapse)
	{
		CollapseDescriptor = null;
		CollapseDescriptorAction = null;
		CollapseValue = collapse;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor<TDocument> Collapse(Core.Search.FieldCollapseDescriptor<TDocument> descriptor)
	{
		CollapseValue = null;
		CollapseDescriptorAction = null;
		CollapseDescriptor = descriptor;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor<TDocument> Collapse(Action<Core.Search.FieldCollapseDescriptor<TDocument>> configure)
	{
		CollapseValue = null;
		CollapseDescriptor = null;
		CollapseDescriptorAction = configure;
		return Self;
	}

	/// <summary>
	/// <para>Array of wildcard (*) patterns. The request returns doc values for field<br/>names matching these patterns in the hits.fields property of the response.</para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor<TDocument> DocvalueFields(ICollection<Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormat>? docvalueFields)
	{
		DocvalueFieldsDescriptor = null;
		DocvalueFieldsDescriptorAction = null;
		DocvalueFieldsDescriptorActions = null;
		DocvalueFieldsValue = docvalueFields;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor<TDocument> DocvalueFields(QueryDsl.FieldAndFormatDescriptor<TDocument> descriptor)
	{
		DocvalueFieldsValue = null;
		DocvalueFieldsDescriptorAction = null;
		DocvalueFieldsDescriptorActions = null;
		DocvalueFieldsDescriptor = descriptor;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor<TDocument> DocvalueFields(Action<QueryDsl.FieldAndFormatDescriptor<TDocument>> configure)
	{
		DocvalueFieldsValue = null;
		DocvalueFieldsDescriptor = null;
		DocvalueFieldsDescriptorActions = null;
		DocvalueFieldsDescriptorAction = configure;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor<TDocument> DocvalueFields(params Action<QueryDsl.FieldAndFormatDescriptor<TDocument>>[] configure)
	{
		DocvalueFieldsValue = null;
		DocvalueFieldsDescriptor = null;
		DocvalueFieldsDescriptorAction = null;
		DocvalueFieldsDescriptorActions = configure;
		return Self;
	}

	/// <summary>
	/// <para>Array of wildcard (*) patterns. The request returns values for field names<br/>matching these patterns in the hits.fields property of the response.</para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor<TDocument> Fields(ICollection<Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormat>? fields)
	{
		FieldsDescriptor = null;
		FieldsDescriptorAction = null;
		FieldsDescriptorActions = null;
		FieldsValue = fields;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor<TDocument> Fields(QueryDsl.FieldAndFormatDescriptor<TDocument> descriptor)
	{
		FieldsValue = null;
		FieldsDescriptorAction = null;
		FieldsDescriptorActions = null;
		FieldsDescriptor = descriptor;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor<TDocument> Fields(Action<QueryDsl.FieldAndFormatDescriptor<TDocument>> configure)
	{
		FieldsValue = null;
		FieldsDescriptor = null;
		FieldsDescriptorActions = null;
		FieldsDescriptorAction = configure;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor<TDocument> Fields(params Action<QueryDsl.FieldAndFormatDescriptor<TDocument>>[] configure)
	{
		FieldsValue = null;
		FieldsDescriptor = null;
		FieldsDescriptorAction = null;
		FieldsDescriptorActions = configure;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor<TDocument> Highlight(Elastic.Clients.Elasticsearch.Core.Search.Highlight? highlight)
	{
		HighlightDescriptor = null;
		HighlightDescriptorAction = null;
		HighlightValue = highlight;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor<TDocument> Highlight(Core.Search.HighlightDescriptor<TDocument> descriptor)
	{
		HighlightValue = null;
		HighlightDescriptorAction = null;
		HighlightDescriptor = descriptor;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor<TDocument> Highlight(Action<Core.Search.HighlightDescriptor<TDocument>> configure)
	{
		HighlightValue = null;
		HighlightDescriptor = null;
		HighlightDescriptorAction = configure;
		return Self;
	}

	/// <summary>
	/// <para>Defines the approximate kNN search to run.</para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor<TDocument> Knn(ICollection<Elastic.Clients.Elasticsearch.KnnQuery>? knn)
	{
		KnnDescriptor = null;
		KnnDescriptorAction = null;
		KnnDescriptorActions = null;
		KnnValue = knn;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor<TDocument> Knn(KnnQueryDescriptor<TDocument> descriptor)
	{
		KnnValue = null;
		KnnDescriptorAction = null;
		KnnDescriptorActions = null;
		KnnDescriptor = descriptor;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor<TDocument> Knn(Action<KnnQueryDescriptor<TDocument>> configure)
	{
		KnnValue = null;
		KnnDescriptor = null;
		KnnDescriptorActions = null;
		KnnDescriptorAction = configure;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor<TDocument> Knn(params Action<KnnQueryDescriptor<TDocument>>[] configure)
	{
		KnnValue = null;
		KnnDescriptor = null;
		KnnDescriptorAction = null;
		KnnDescriptorActions = configure;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor<TDocument> PostFilter(Elastic.Clients.Elasticsearch.QueryDsl.Query? postFilter)
	{
		PostFilterDescriptor = null;
		PostFilterDescriptorAction = null;
		PostFilterValue = postFilter;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor<TDocument> PostFilter(QueryDsl.QueryDescriptor<TDocument> descriptor)
	{
		PostFilterValue = null;
		PostFilterDescriptorAction = null;
		PostFilterDescriptor = descriptor;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor<TDocument> PostFilter(Action<QueryDsl.QueryDescriptor<TDocument>> configure)
	{
		PostFilterValue = null;
		PostFilterDescriptor = null;
		PostFilterDescriptorAction = configure;
		return Self;
	}

	/// <summary>
	/// <para>Defines the search definition using the Query DSL.</para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor<TDocument> Query(Elastic.Clients.Elasticsearch.QueryDsl.Query? query)
	{
		QueryDescriptor = null;
		QueryDescriptorAction = null;
		QueryValue = query;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor<TDocument> Query(QueryDsl.QueryDescriptor<TDocument> descriptor)
	{
		QueryValue = null;
		QueryDescriptorAction = null;
		QueryDescriptor = descriptor;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor<TDocument> Query(Action<QueryDsl.QueryDescriptor<TDocument>> configure)
	{
		QueryValue = null;
		QueryDescriptor = null;
		QueryDescriptorAction = configure;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor<TDocument> Rescore(ICollection<Elastic.Clients.Elasticsearch.Core.Search.Rescore>? rescore)
	{
		RescoreDescriptor = null;
		RescoreDescriptorAction = null;
		RescoreDescriptorActions = null;
		RescoreValue = rescore;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor<TDocument> Rescore(Core.Search.RescoreDescriptor<TDocument> descriptor)
	{
		RescoreValue = null;
		RescoreDescriptorAction = null;
		RescoreDescriptorActions = null;
		RescoreDescriptor = descriptor;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor<TDocument> Rescore(Action<Core.Search.RescoreDescriptor<TDocument>> configure)
	{
		RescoreValue = null;
		RescoreDescriptor = null;
		RescoreDescriptorActions = null;
		RescoreDescriptorAction = configure;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor<TDocument> Rescore(params Action<Core.Search.RescoreDescriptor<TDocument>>[] configure)
	{
		RescoreValue = null;
		RescoreDescriptor = null;
		RescoreDescriptorAction = null;
		RescoreDescriptorActions = configure;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor<TDocument> Slice(Elastic.Clients.Elasticsearch.SlicedScroll? slice)
	{
		SliceDescriptor = null;
		SliceDescriptorAction = null;
		SliceValue = slice;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor<TDocument> Slice(SlicedScrollDescriptor<TDocument> descriptor)
	{
		SliceValue = null;
		SliceDescriptorAction = null;
		SliceDescriptor = descriptor;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor<TDocument> Slice(Action<SlicedScrollDescriptor<TDocument>> configure)
	{
		SliceValue = null;
		SliceDescriptor = null;
		SliceDescriptorAction = configure;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor<TDocument> Sort(ICollection<Elastic.Clients.Elasticsearch.SortOptions>? sort)
	{
		SortDescriptor = null;
		SortDescriptorAction = null;
		SortDescriptorActions = null;
		SortValue = sort;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor<TDocument> Sort(SortOptionsDescriptor<TDocument> descriptor)
	{
		SortValue = null;
		SortDescriptorAction = null;
		SortDescriptorActions = null;
		SortDescriptor = descriptor;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor<TDocument> Sort(Action<SortOptionsDescriptor<TDocument>> configure)
	{
		SortValue = null;
		SortDescriptor = null;
		SortDescriptorActions = null;
		SortDescriptorAction = configure;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor<TDocument> Sort(params Action<SortOptionsDescriptor<TDocument>>[] configure)
	{
		SortValue = null;
		SortDescriptor = null;
		SortDescriptorAction = null;
		SortDescriptorActions = configure;
		return Self;
	}

	/// <summary>
	/// <para>Indicates which source fields are returned for matching documents. These<br/>fields are returned in the hits._source property of the search response.</para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor<TDocument> Source(Elastic.Clients.Elasticsearch.Core.Search.SourceConfig? source)
	{
		SourceValue = source;
		return Self;
	}

	/// <summary>
	/// <para>If true, returns detailed information about score computation as part of a hit.</para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor<TDocument> Explain(bool? explain = true)
	{
		ExplainValue = explain;
		return Self;
	}

	/// <summary>
	/// <para>Configuration of search extensions defined by Elasticsearch plugins.</para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor<TDocument> Ext(Func<FluentDictionary<string, object>, FluentDictionary<string, object>> selector)
	{
		ExtValue = selector?.Invoke(new FluentDictionary<string, object>());
		return Self;
	}

	/// <summary>
	/// <para>Starting document offset. By default, you cannot page through more than 10,000<br/>hits using the from and size parameters. To page through more hits, use the<br/>search_after parameter.</para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor<TDocument> From(int? from)
	{
		FromValue = from;
		return Self;
	}

	/// <summary>
	/// <para>Boosts the _score of documents from specified indices.</para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor<TDocument> IndicesBoost(ICollection<IDictionary<Elastic.Clients.Elasticsearch.IndexName, double>>? indicesBoost)
	{
		IndicesBoostValue = indicesBoost;
		return Self;
	}

	/// <summary>
	/// <para>Minimum _score for matching documents. Documents with a lower _score are<br/>not included in the search results.</para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor<TDocument> MinScore(double? minScore)
	{
		MinScoreValue = minScore;
		return Self;
	}

	/// <summary>
	/// <para>Limits the search to a point in time (PIT). If you provide a PIT, you<br/>cannot specify an <index> in the request path.</para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor<TDocument> Pit(Elastic.Clients.Elasticsearch.Core.Search.PointInTimeReference? pit)
	{
		PitDescriptor = null;
		PitDescriptorAction = null;
		PitValue = pit;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor<TDocument> Pit(Core.Search.PointInTimeReferenceDescriptor descriptor)
	{
		PitValue = null;
		PitDescriptorAction = null;
		PitDescriptor = descriptor;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor<TDocument> Pit(Action<Core.Search.PointInTimeReferenceDescriptor> configure)
	{
		PitValue = null;
		PitDescriptor = null;
		PitDescriptorAction = configure;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor<TDocument> Profile(bool? profile = true)
	{
		ProfileValue = profile;
		return Self;
	}

	/// <summary>
	/// <para>Defines one or more runtime fields in the search request. These fields take<br/>precedence over mapped fields with the same name.</para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor<TDocument> RuntimeMappings(Func<FluentDictionary<Elastic.Clients.Elasticsearch.Field, Elastic.Clients.Elasticsearch.Mapping.RuntimeField>, FluentDictionary<Elastic.Clients.Elasticsearch.Field, Elastic.Clients.Elasticsearch.Mapping.RuntimeField>> selector)
	{
		RuntimeMappingsValue = selector?.Invoke(new FluentDictionary<Elastic.Clients.Elasticsearch.Field, Elastic.Clients.Elasticsearch.Mapping.RuntimeField>());
		return Self;
	}

	/// <summary>
	/// <para>Retrieve a script evaluation (based on different fields) for each hit.</para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor<TDocument> ScriptFields(Func<FluentDictionary<string, Elastic.Clients.Elasticsearch.ScriptField>, FluentDictionary<string, Elastic.Clients.Elasticsearch.ScriptField>> selector)
	{
		ScriptFieldsValue = selector?.Invoke(new FluentDictionary<string, Elastic.Clients.Elasticsearch.ScriptField>());
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor<TDocument> SearchAfter(ICollection<Elastic.Clients.Elasticsearch.FieldValue>? searchAfter)
	{
		SearchAfterValue = searchAfter;
		return Self;
	}

	/// <summary>
	/// <para>If true, returns sequence number and primary term of the last modification<br/>of each hit. See Optimistic concurrency control.</para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor<TDocument> SeqNoPrimaryTerm(bool? seqNoPrimaryTerm = true)
	{
		SeqNoPrimaryTermValue = seqNoPrimaryTerm;
		return Self;
	}

	/// <summary>
	/// <para>The number of hits to return. By default, you cannot page through more<br/>than 10,000 hits using the from and size parameters. To page through more<br/>hits, use the search_after parameter.</para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor<TDocument> Size(int? size)
	{
		SizeValue = size;
		return Self;
	}

	/// <summary>
	/// <para>Stats groups to associate with the search. Each group maintains a statistics<br/>aggregation for its associated searches. You can retrieve these stats using<br/>the indices stats API.</para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor<TDocument> Stats(ICollection<string>? stats)
	{
		StatsValue = stats;
		return Self;
	}

	/// <summary>
	/// <para>List of stored fields to return as part of a hit. If no fields are specified,<br/>no stored fields are included in the response. If this field is specified, the _source<br/>parameter defaults to false. You can pass _source: true to return both source fields<br/>and stored fields in the search response.</para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor<TDocument> StoredFields(Elastic.Clients.Elasticsearch.Fields? storedFields)
	{
		StoredFieldsValue = storedFields;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor<TDocument> Suggest(Elastic.Clients.Elasticsearch.Core.Search.Suggester? suggest)
	{
		SuggestDescriptor = null;
		SuggestDescriptorAction = null;
		SuggestValue = suggest;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor<TDocument> Suggest(Core.Search.SuggesterDescriptor descriptor)
	{
		SuggestValue = null;
		SuggestDescriptorAction = null;
		SuggestDescriptor = descriptor;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor<TDocument> Suggest(Action<Core.Search.SuggesterDescriptor> configure)
	{
		SuggestValue = null;
		SuggestDescriptor = null;
		SuggestDescriptorAction = configure;
		return Self;
	}

	/// <summary>
	/// <para>Maximum number of documents to collect for each shard. If a query reaches this<br/>limit, Elasticsearch terminates the query early. Elasticsearch collects documents<br/>before sorting. Defaults to 0, which does not terminate query execution early.</para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor<TDocument> TerminateAfter(long? terminateAfter)
	{
		TerminateAfterValue = terminateAfter;
		return Self;
	}

	/// <summary>
	/// <para>Specifies the period of time to wait for a response from each shard. If no response<br/>is received before the timeout expires, the request fails and returns an error.<br/>Defaults to no timeout.</para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor<TDocument> Timeout(string? timeout)
	{
		TimeoutValue = timeout;
		return Self;
	}

	/// <summary>
	/// <para>If true, calculate and return document scores, even if the scores are not used for sorting.</para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor<TDocument> TrackScores(bool? trackScores = true)
	{
		TrackScoresValue = trackScores;
		return Self;
	}

	/// <summary>
	/// <para>Number of hits matching the query to count accurately. If true, the exact<br/>number of hits is returned at the cost of some performance. If false, the<br/>response does not include the total number of hits matching the query.<br/>Defaults to 10,000 hits.</para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor<TDocument> TrackTotalHits(Elastic.Clients.Elasticsearch.Core.Search.TrackHits? trackTotalHits)
	{
		TrackTotalHitsValue = trackTotalHits;
		return Self;
	}

	/// <summary>
	/// <para>If true, returns document version as part of a hit.</para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor<TDocument> Version(bool? version = true)
	{
		VersionValue = version;
		return Self;
	}

	protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
	{
		writer.WriteStartObject();
		if (AggregationsDescriptor is not null)
		{
			writer.WritePropertyName("aggregations");
			JsonSerializer.Serialize(writer, AggregationsDescriptor, options);
		}
		else if (AggregationsDescriptorAction is not null)
		{
			writer.WritePropertyName("aggregations");
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.Aggregations.AggregationDescriptor<TDocument>(AggregationsDescriptorAction), options);
		}
		else if (AggregationsValue is not null)
		{
			writer.WritePropertyName("aggregations");
			JsonSerializer.Serialize(writer, AggregationsValue, options);
		}

		if (CollapseDescriptor is not null)
		{
			writer.WritePropertyName("collapse");
			JsonSerializer.Serialize(writer, CollapseDescriptor, options);
		}
		else if (CollapseDescriptorAction is not null)
		{
			writer.WritePropertyName("collapse");
			JsonSerializer.Serialize(writer, new Core.Search.FieldCollapseDescriptor<TDocument>(CollapseDescriptorAction), options);
		}
		else if (CollapseValue is not null)
		{
			writer.WritePropertyName("collapse");
			JsonSerializer.Serialize(writer, CollapseValue, options);
		}

		if (DocvalueFieldsDescriptor is not null)
		{
			writer.WritePropertyName("docvalue_fields");
			writer.WriteStartArray();
			JsonSerializer.Serialize(writer, DocvalueFieldsDescriptor, options);
			writer.WriteEndArray();
		}
		else if (DocvalueFieldsDescriptorAction is not null)
		{
			writer.WritePropertyName("docvalue_fields");
			writer.WriteStartArray();
			JsonSerializer.Serialize(writer, new QueryDsl.FieldAndFormatDescriptor<TDocument>(DocvalueFieldsDescriptorAction), options);
			writer.WriteEndArray();
		}
		else if (DocvalueFieldsDescriptorActions is not null)
		{
			writer.WritePropertyName("docvalue_fields");
			writer.WriteStartArray();
			foreach (var action in DocvalueFieldsDescriptorActions)
			{
				JsonSerializer.Serialize(writer, new QueryDsl.FieldAndFormatDescriptor<TDocument>(action), options);
			}

			writer.WriteEndArray();
		}
		else if (DocvalueFieldsValue is not null)
		{
			writer.WritePropertyName("docvalue_fields");
			JsonSerializer.Serialize(writer, DocvalueFieldsValue, options);
		}

		if (FieldsDescriptor is not null)
		{
			writer.WritePropertyName("fields");
			writer.WriteStartArray();
			JsonSerializer.Serialize(writer, FieldsDescriptor, options);
			writer.WriteEndArray();
		}
		else if (FieldsDescriptorAction is not null)
		{
			writer.WritePropertyName("fields");
			writer.WriteStartArray();
			JsonSerializer.Serialize(writer, new QueryDsl.FieldAndFormatDescriptor<TDocument>(FieldsDescriptorAction), options);
			writer.WriteEndArray();
		}
		else if (FieldsDescriptorActions is not null)
		{
			writer.WritePropertyName("fields");
			writer.WriteStartArray();
			foreach (var action in FieldsDescriptorActions)
			{
				JsonSerializer.Serialize(writer, new QueryDsl.FieldAndFormatDescriptor<TDocument>(action), options);
			}

			writer.WriteEndArray();
		}
		else if (FieldsValue is not null)
		{
			writer.WritePropertyName("fields");
			JsonSerializer.Serialize(writer, FieldsValue, options);
		}

		if (HighlightDescriptor is not null)
		{
			writer.WritePropertyName("highlight");
			JsonSerializer.Serialize(writer, HighlightDescriptor, options);
		}
		else if (HighlightDescriptorAction is not null)
		{
			writer.WritePropertyName("highlight");
			JsonSerializer.Serialize(writer, new Core.Search.HighlightDescriptor<TDocument>(HighlightDescriptorAction), options);
		}
		else if (HighlightValue is not null)
		{
			writer.WritePropertyName("highlight");
			JsonSerializer.Serialize(writer, HighlightValue, options);
		}

		if (KnnDescriptor is not null)
		{
			writer.WritePropertyName("knn");
			JsonSerializer.Serialize(writer, KnnDescriptor, options);
		}
		else if (KnnDescriptorAction is not null)
		{
			writer.WritePropertyName("knn");
			JsonSerializer.Serialize(writer, new KnnQueryDescriptor<TDocument>(KnnDescriptorAction), options);
		}
		else if (KnnDescriptorActions is not null)
		{
			writer.WritePropertyName("knn");
			if (KnnDescriptorActions.Length > 1)
				writer.WriteStartArray();
			foreach (var action in KnnDescriptorActions)
			{
				JsonSerializer.Serialize(writer, new KnnQueryDescriptor<TDocument>(action), options);
			}

			if (KnnDescriptorActions.Length > 1)
				writer.WriteEndArray();
		}
		else if (KnnValue is not null)
		{
			writer.WritePropertyName("knn");
			SingleOrManySerializationHelper.Serialize<Elastic.Clients.Elasticsearch.KnnQuery>(KnnValue, writer, options);
		}

		if (PostFilterDescriptor is not null)
		{
			writer.WritePropertyName("post_filter");
			JsonSerializer.Serialize(writer, PostFilterDescriptor, options);
		}
		else if (PostFilterDescriptorAction is not null)
		{
			writer.WritePropertyName("post_filter");
			JsonSerializer.Serialize(writer, new QueryDsl.QueryDescriptor<TDocument>(PostFilterDescriptorAction), options);
		}
		else if (PostFilterValue is not null)
		{
			writer.WritePropertyName("post_filter");
			JsonSerializer.Serialize(writer, PostFilterValue, options);
		}

		if (QueryDescriptor is not null)
		{
			writer.WritePropertyName("query");
			JsonSerializer.Serialize(writer, QueryDescriptor, options);
		}
		else if (QueryDescriptorAction is not null)
		{
			writer.WritePropertyName("query");
			JsonSerializer.Serialize(writer, new QueryDsl.QueryDescriptor<TDocument>(QueryDescriptorAction), options);
		}
		else if (QueryValue is not null)
		{
			writer.WritePropertyName("query");
			JsonSerializer.Serialize(writer, QueryValue, options);
		}

		if (RescoreDescriptor is not null)
		{
			writer.WritePropertyName("rescore");
			JsonSerializer.Serialize(writer, RescoreDescriptor, options);
		}
		else if (RescoreDescriptorAction is not null)
		{
			writer.WritePropertyName("rescore");
			JsonSerializer.Serialize(writer, new Core.Search.RescoreDescriptor<TDocument>(RescoreDescriptorAction), options);
		}
		else if (RescoreDescriptorActions is not null)
		{
			writer.WritePropertyName("rescore");
			if (RescoreDescriptorActions.Length > 1)
				writer.WriteStartArray();
			foreach (var action in RescoreDescriptorActions)
			{
				JsonSerializer.Serialize(writer, new Core.Search.RescoreDescriptor<TDocument>(action), options);
			}

			if (RescoreDescriptorActions.Length > 1)
				writer.WriteEndArray();
		}
		else if (RescoreValue is not null)
		{
			writer.WritePropertyName("rescore");
			SingleOrManySerializationHelper.Serialize<Elastic.Clients.Elasticsearch.Core.Search.Rescore>(RescoreValue, writer, options);
		}

		if (SliceDescriptor is not null)
		{
			writer.WritePropertyName("slice");
			JsonSerializer.Serialize(writer, SliceDescriptor, options);
		}
		else if (SliceDescriptorAction is not null)
		{
			writer.WritePropertyName("slice");
			JsonSerializer.Serialize(writer, new SlicedScrollDescriptor<TDocument>(SliceDescriptorAction), options);
		}
		else if (SliceValue is not null)
		{
			writer.WritePropertyName("slice");
			JsonSerializer.Serialize(writer, SliceValue, options);
		}

		if (SortDescriptor is not null)
		{
			writer.WritePropertyName("sort");
			JsonSerializer.Serialize(writer, SortDescriptor, options);
		}
		else if (SortDescriptorAction is not null)
		{
			writer.WritePropertyName("sort");
			JsonSerializer.Serialize(writer, new SortOptionsDescriptor<TDocument>(SortDescriptorAction), options);
		}
		else if (SortDescriptorActions is not null)
		{
			writer.WritePropertyName("sort");
			if (SortDescriptorActions.Length > 1)
				writer.WriteStartArray();
			foreach (var action in SortDescriptorActions)
			{
				JsonSerializer.Serialize(writer, new SortOptionsDescriptor<TDocument>(action), options);
			}

			if (SortDescriptorActions.Length > 1)
				writer.WriteEndArray();
		}
		else if (SortValue is not null)
		{
			writer.WritePropertyName("sort");
			SingleOrManySerializationHelper.Serialize<Elastic.Clients.Elasticsearch.SortOptions>(SortValue, writer, options);
		}

		if (SourceValue is not null)
		{
			writer.WritePropertyName("_source");
			JsonSerializer.Serialize(writer, SourceValue, options);
		}

		if (ExplainValue.HasValue)
		{
			writer.WritePropertyName("explain");
			writer.WriteBooleanValue(ExplainValue.Value);
		}

		if (ExtValue is not null)
		{
			writer.WritePropertyName("ext");
			JsonSerializer.Serialize(writer, ExtValue, options);
		}

		if (FromValue.HasValue)
		{
			writer.WritePropertyName("from");
			writer.WriteNumberValue(FromValue.Value);
		}

		if (IndicesBoostValue is not null)
		{
			writer.WritePropertyName("indices_boost");
			JsonSerializer.Serialize(writer, IndicesBoostValue, options);
		}

		if (MinScoreValue.HasValue)
		{
			writer.WritePropertyName("min_score");
			writer.WriteNumberValue(MinScoreValue.Value);
		}

		if (PitDescriptor is not null)
		{
			writer.WritePropertyName("pit");
			JsonSerializer.Serialize(writer, PitDescriptor, options);
		}
		else if (PitDescriptorAction is not null)
		{
			writer.WritePropertyName("pit");
			JsonSerializer.Serialize(writer, new Core.Search.PointInTimeReferenceDescriptor(PitDescriptorAction), options);
		}
		else if (PitValue is not null)
		{
			writer.WritePropertyName("pit");
			JsonSerializer.Serialize(writer, PitValue, options);
		}

		if (ProfileValue.HasValue)
		{
			writer.WritePropertyName("profile");
			writer.WriteBooleanValue(ProfileValue.Value);
		}

		if (RuntimeMappingsValue is not null)
		{
			writer.WritePropertyName("runtime_mappings");
			JsonSerializer.Serialize(writer, RuntimeMappingsValue, options);
		}

		if (ScriptFieldsValue is not null)
		{
			writer.WritePropertyName("script_fields");
			JsonSerializer.Serialize(writer, ScriptFieldsValue, options);
		}

		if (SearchAfterValue is not null)
		{
			writer.WritePropertyName("search_after");
			JsonSerializer.Serialize(writer, SearchAfterValue, options);
		}

		if (SeqNoPrimaryTermValue.HasValue)
		{
			writer.WritePropertyName("seq_no_primary_term");
			writer.WriteBooleanValue(SeqNoPrimaryTermValue.Value);
		}

		if (SizeValue.HasValue)
		{
			writer.WritePropertyName("size");
			writer.WriteNumberValue(SizeValue.Value);
		}

		if (StatsValue is not null)
		{
			writer.WritePropertyName("stats");
			JsonSerializer.Serialize(writer, StatsValue, options);
		}

		if (StoredFieldsValue is not null)
		{
			writer.WritePropertyName("stored_fields");
			JsonSerializer.Serialize(writer, StoredFieldsValue, options);
		}

		if (SuggestDescriptor is not null)
		{
			writer.WritePropertyName("suggest");
			JsonSerializer.Serialize(writer, SuggestDescriptor, options);
		}
		else if (SuggestDescriptorAction is not null)
		{
			writer.WritePropertyName("suggest");
			JsonSerializer.Serialize(writer, new Core.Search.SuggesterDescriptor(SuggestDescriptorAction), options);
		}
		else if (SuggestValue is not null)
		{
			writer.WritePropertyName("suggest");
			JsonSerializer.Serialize(writer, SuggestValue, options);
		}

		if (TerminateAfterValue.HasValue)
		{
			writer.WritePropertyName("terminate_after");
			writer.WriteNumberValue(TerminateAfterValue.Value);
		}

		if (!string.IsNullOrEmpty(TimeoutValue))
		{
			writer.WritePropertyName("timeout");
			writer.WriteStringValue(TimeoutValue);
		}

		if (TrackScoresValue.HasValue)
		{
			writer.WritePropertyName("track_scores");
			writer.WriteBooleanValue(TrackScoresValue.Value);
		}

		if (TrackTotalHitsValue is not null)
		{
			writer.WritePropertyName("track_total_hits");
			JsonSerializer.Serialize(writer, TrackTotalHitsValue, options);
		}

		if (VersionValue.HasValue)
		{
			writer.WritePropertyName("version");
			writer.WriteBooleanValue(VersionValue.Value);
		}

		writer.WriteEndObject();
	}
}

/// <summary>
/// <para>Runs a search request asynchronously.<br/>When the primary sort of the results is an indexed field, shards get sorted based on minimum and maximum value that they hold for that field, hence partial results become available following the sort criteria that was requested.<br/>Warning: Async search does not support scroll nor search requests that only include the suggest section.<br/>By default, Elasticsearch doesn’t allow you to store an async search response larger than 10Mb and an attempt to do this results in an error.<br/>The maximum allowed size for a stored async search response can be set by changing the `search.max_async_search_response_size` cluster level setting.</para>
/// </summary>
public sealed partial class SubmitAsyncSearchRequestDescriptor : RequestDescriptor<SubmitAsyncSearchRequestDescriptor, SubmitAsyncSearchRequestParameters>
{
	internal SubmitAsyncSearchRequestDescriptor(Action<SubmitAsyncSearchRequestDescriptor> configure) => configure.Invoke(this);

	public SubmitAsyncSearchRequestDescriptor()
	{
	}

	internal override ApiUrls ApiUrls => ApiUrlLookup.AsyncSearchSubmit;

	protected override HttpMethod StaticHttpMethod => HttpMethod.POST;

	internal override bool SupportsBody => true;

	public SubmitAsyncSearchRequestDescriptor SourceExcludes(Elastic.Clients.Elasticsearch.Fields? sourceExcludes) => Qs("_source_excludes", sourceExcludes);
	public SubmitAsyncSearchRequestDescriptor SourceIncludes(Elastic.Clients.Elasticsearch.Fields? sourceIncludes) => Qs("_source_includes", sourceIncludes);
	public SubmitAsyncSearchRequestDescriptor AllowNoIndices(bool? allowNoIndices = true) => Qs("allow_no_indices", allowNoIndices);
	public SubmitAsyncSearchRequestDescriptor AllowPartialSearchResults(bool? allowPartialSearchResults = true) => Qs("allow_partial_search_results", allowPartialSearchResults);
	public SubmitAsyncSearchRequestDescriptor AnalyzeWildcard(bool? analyzeWildcard = true) => Qs("analyze_wildcard", analyzeWildcard);
	public SubmitAsyncSearchRequestDescriptor Analyzer(string? analyzer) => Qs("analyzer", analyzer);
	public SubmitAsyncSearchRequestDescriptor BatchedReduceSize(long? batchedReduceSize) => Qs("batched_reduce_size", batchedReduceSize);
	public SubmitAsyncSearchRequestDescriptor CcsMinimizeRoundtrips(bool? ccsMinimizeRoundtrips = true) => Qs("ccs_minimize_roundtrips", ccsMinimizeRoundtrips);
	public SubmitAsyncSearchRequestDescriptor DefaultOperator(Elastic.Clients.Elasticsearch.QueryDsl.Operator? defaultOperator) => Qs("default_operator", defaultOperator);
	public SubmitAsyncSearchRequestDescriptor Df(string? df) => Qs("df", df);
	public SubmitAsyncSearchRequestDescriptor ExpandWildcards(ICollection<Elastic.Clients.Elasticsearch.ExpandWildcard>? expandWildcards) => Qs("expand_wildcards", expandWildcards);
	public SubmitAsyncSearchRequestDescriptor IgnoreThrottled(bool? ignoreThrottled = true) => Qs("ignore_throttled", ignoreThrottled);
	public SubmitAsyncSearchRequestDescriptor IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
	public SubmitAsyncSearchRequestDescriptor KeepAlive(Elastic.Clients.Elasticsearch.Duration? keepAlive) => Qs("keep_alive", keepAlive);
	public SubmitAsyncSearchRequestDescriptor KeepOnCompletion(bool? keepOnCompletion = true) => Qs("keep_on_completion", keepOnCompletion);
	public SubmitAsyncSearchRequestDescriptor Lenient(bool? lenient = true) => Qs("lenient", lenient);
	public SubmitAsyncSearchRequestDescriptor MaxConcurrentShardRequests(long? maxConcurrentShardRequests) => Qs("max_concurrent_shard_requests", maxConcurrentShardRequests);
	public SubmitAsyncSearchRequestDescriptor MinCompatibleShardNode(string? minCompatibleShardNode) => Qs("min_compatible_shard_node", minCompatibleShardNode);
	public SubmitAsyncSearchRequestDescriptor PreFilterShardSize(long? preFilterShardSize) => Qs("pre_filter_shard_size", preFilterShardSize);
	public SubmitAsyncSearchRequestDescriptor Preference(string? preference) => Qs("preference", preference);
	public SubmitAsyncSearchRequestDescriptor QueryLuceneSyntax(string? q) => Qs("q", q);
	public SubmitAsyncSearchRequestDescriptor RequestCache(bool? requestCache = true) => Qs("request_cache", requestCache);
	public SubmitAsyncSearchRequestDescriptor RestTotalHitsAsInt(bool? restTotalHitsAsInt = true) => Qs("rest_total_hits_as_int", restTotalHitsAsInt);
	public SubmitAsyncSearchRequestDescriptor Routing(Elastic.Clients.Elasticsearch.Routing? routing) => Qs("routing", routing);
	public SubmitAsyncSearchRequestDescriptor Scroll(Elastic.Clients.Elasticsearch.Duration? scroll) => Qs("scroll", scroll);
	public SubmitAsyncSearchRequestDescriptor SearchType(Elastic.Clients.Elasticsearch.SearchType? searchType) => Qs("search_type", searchType);
	public SubmitAsyncSearchRequestDescriptor SuggestField(Elastic.Clients.Elasticsearch.Field? suggestField) => Qs("suggest_field", suggestField);
	public SubmitAsyncSearchRequestDescriptor SuggestMode(Elastic.Clients.Elasticsearch.SuggestMode? suggestMode) => Qs("suggest_mode", suggestMode);
	public SubmitAsyncSearchRequestDescriptor SuggestSize(long? suggestSize) => Qs("suggest_size", suggestSize);
	public SubmitAsyncSearchRequestDescriptor SuggestText(string? suggestText) => Qs("suggest_text", suggestText);
	public SubmitAsyncSearchRequestDescriptor TypedKeys(bool? typedKeys = true) => Qs("typed_keys", typedKeys);
	public SubmitAsyncSearchRequestDescriptor WaitForCompletionTimeout(Elastic.Clients.Elasticsearch.Duration? waitForCompletionTimeout) => Qs("wait_for_completion_timeout", waitForCompletionTimeout);

	public SubmitAsyncSearchRequestDescriptor Indices(Elastic.Clients.Elasticsearch.Indices? indices)
	{
		RouteValues.Optional("index", indices);
		return Self;
	}

	private Elastic.Clients.Elasticsearch.Aggregations.AggregationDictionary? AggregationsValue { get; set; }
	private Elastic.Clients.Elasticsearch.Aggregations.AggregationDescriptor AggregationsDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.Aggregations.AggregationDescriptor> AggregationsDescriptorAction { get; set; }
	private Elastic.Clients.Elasticsearch.Core.Search.FieldCollapse? CollapseValue { get; set; }
	private Core.Search.FieldCollapseDescriptor CollapseDescriptor { get; set; }
	private Action<Core.Search.FieldCollapseDescriptor> CollapseDescriptorAction { get; set; }
	private ICollection<Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormat>? DocvalueFieldsValue { get; set; }
	private QueryDsl.FieldAndFormatDescriptor DocvalueFieldsDescriptor { get; set; }
	private Action<QueryDsl.FieldAndFormatDescriptor> DocvalueFieldsDescriptorAction { get; set; }
	private Action<QueryDsl.FieldAndFormatDescriptor>[] DocvalueFieldsDescriptorActions { get; set; }
	private ICollection<Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormat>? FieldsValue { get; set; }
	private QueryDsl.FieldAndFormatDescriptor FieldsDescriptor { get; set; }
	private Action<QueryDsl.FieldAndFormatDescriptor> FieldsDescriptorAction { get; set; }
	private Action<QueryDsl.FieldAndFormatDescriptor>[] FieldsDescriptorActions { get; set; }
	private Elastic.Clients.Elasticsearch.Core.Search.Highlight? HighlightValue { get; set; }
	private Core.Search.HighlightDescriptor HighlightDescriptor { get; set; }
	private Action<Core.Search.HighlightDescriptor> HighlightDescriptorAction { get; set; }
	private ICollection<Elastic.Clients.Elasticsearch.KnnQuery>? KnnValue { get; set; }
	private KnnQueryDescriptor KnnDescriptor { get; set; }
	private Action<KnnQueryDescriptor> KnnDescriptorAction { get; set; }
	private Action<KnnQueryDescriptor>[] KnnDescriptorActions { get; set; }
	private Elastic.Clients.Elasticsearch.QueryDsl.Query? PostFilterValue { get; set; }
	private QueryDsl.QueryDescriptor PostFilterDescriptor { get; set; }
	private Action<QueryDsl.QueryDescriptor> PostFilterDescriptorAction { get; set; }
	private Elastic.Clients.Elasticsearch.QueryDsl.Query? QueryValue { get; set; }
	private QueryDsl.QueryDescriptor QueryDescriptor { get; set; }
	private Action<QueryDsl.QueryDescriptor> QueryDescriptorAction { get; set; }
	private ICollection<Elastic.Clients.Elasticsearch.Core.Search.Rescore>? RescoreValue { get; set; }
	private Core.Search.RescoreDescriptor RescoreDescriptor { get; set; }
	private Action<Core.Search.RescoreDescriptor> RescoreDescriptorAction { get; set; }
	private Action<Core.Search.RescoreDescriptor>[] RescoreDescriptorActions { get; set; }
	private Elastic.Clients.Elasticsearch.SlicedScroll? SliceValue { get; set; }
	private SlicedScrollDescriptor SliceDescriptor { get; set; }
	private Action<SlicedScrollDescriptor> SliceDescriptorAction { get; set; }
	private ICollection<Elastic.Clients.Elasticsearch.SortOptions>? SortValue { get; set; }
	private SortOptionsDescriptor SortDescriptor { get; set; }
	private Action<SortOptionsDescriptor> SortDescriptorAction { get; set; }
	private Action<SortOptionsDescriptor>[] SortDescriptorActions { get; set; }
	private Elastic.Clients.Elasticsearch.Core.Search.SourceConfig? SourceValue { get; set; }
	private bool? ExplainValue { get; set; }
	private IDictionary<string, object>? ExtValue { get; set; }
	private int? FromValue { get; set; }
	private ICollection<IDictionary<Elastic.Clients.Elasticsearch.IndexName, double>>? IndicesBoostValue { get; set; }
	private double? MinScoreValue { get; set; }
	private Elastic.Clients.Elasticsearch.Core.Search.PointInTimeReference? PitValue { get; set; }
	private Core.Search.PointInTimeReferenceDescriptor PitDescriptor { get; set; }
	private Action<Core.Search.PointInTimeReferenceDescriptor> PitDescriptorAction { get; set; }
	private bool? ProfileValue { get; set; }
	private IDictionary<Elastic.Clients.Elasticsearch.Field, Elastic.Clients.Elasticsearch.Mapping.RuntimeField>? RuntimeMappingsValue { get; set; }
	private IDictionary<string, Elastic.Clients.Elasticsearch.ScriptField>? ScriptFieldsValue { get; set; }
	private ICollection<Elastic.Clients.Elasticsearch.FieldValue>? SearchAfterValue { get; set; }
	private bool? SeqNoPrimaryTermValue { get; set; }
	private int? SizeValue { get; set; }
	private ICollection<string>? StatsValue { get; set; }
	private Elastic.Clients.Elasticsearch.Fields? StoredFieldsValue { get; set; }
	private Elastic.Clients.Elasticsearch.Core.Search.Suggester? SuggestValue { get; set; }
	private Core.Search.SuggesterDescriptor SuggestDescriptor { get; set; }
	private Action<Core.Search.SuggesterDescriptor> SuggestDescriptorAction { get; set; }
	private long? TerminateAfterValue { get; set; }
	private string? TimeoutValue { get; set; }
	private bool? TrackScoresValue { get; set; }
	private Elastic.Clients.Elasticsearch.Core.Search.TrackHits? TrackTotalHitsValue { get; set; }
	private bool? VersionValue { get; set; }

	public SubmitAsyncSearchRequestDescriptor Aggregations(Elastic.Clients.Elasticsearch.Aggregations.AggregationDictionary? aggregations)
	{
		AggregationsDescriptor = null;
		AggregationsDescriptorAction = null;
		AggregationsValue = aggregations;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor Aggregations(Elastic.Clients.Elasticsearch.Aggregations.AggregationDescriptor descriptor)
	{
		AggregationsValue = null;
		AggregationsDescriptorAction = null;
		AggregationsDescriptor = descriptor;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor Aggregations(Action<Elastic.Clients.Elasticsearch.Aggregations.AggregationDescriptor> configure)
	{
		AggregationsValue = null;
		AggregationsDescriptor = null;
		AggregationsDescriptorAction = configure;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor Collapse(Elastic.Clients.Elasticsearch.Core.Search.FieldCollapse? collapse)
	{
		CollapseDescriptor = null;
		CollapseDescriptorAction = null;
		CollapseValue = collapse;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor Collapse(Core.Search.FieldCollapseDescriptor descriptor)
	{
		CollapseValue = null;
		CollapseDescriptorAction = null;
		CollapseDescriptor = descriptor;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor Collapse(Action<Core.Search.FieldCollapseDescriptor> configure)
	{
		CollapseValue = null;
		CollapseDescriptor = null;
		CollapseDescriptorAction = configure;
		return Self;
	}

	/// <summary>
	/// <para>Array of wildcard (*) patterns. The request returns doc values for field<br/>names matching these patterns in the hits.fields property of the response.</para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor DocvalueFields(ICollection<Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormat>? docvalueFields)
	{
		DocvalueFieldsDescriptor = null;
		DocvalueFieldsDescriptorAction = null;
		DocvalueFieldsDescriptorActions = null;
		DocvalueFieldsValue = docvalueFields;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor DocvalueFields(QueryDsl.FieldAndFormatDescriptor descriptor)
	{
		DocvalueFieldsValue = null;
		DocvalueFieldsDescriptorAction = null;
		DocvalueFieldsDescriptorActions = null;
		DocvalueFieldsDescriptor = descriptor;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor DocvalueFields(Action<QueryDsl.FieldAndFormatDescriptor> configure)
	{
		DocvalueFieldsValue = null;
		DocvalueFieldsDescriptor = null;
		DocvalueFieldsDescriptorActions = null;
		DocvalueFieldsDescriptorAction = configure;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor DocvalueFields(params Action<QueryDsl.FieldAndFormatDescriptor>[] configure)
	{
		DocvalueFieldsValue = null;
		DocvalueFieldsDescriptor = null;
		DocvalueFieldsDescriptorAction = null;
		DocvalueFieldsDescriptorActions = configure;
		return Self;
	}

	/// <summary>
	/// <para>Array of wildcard (*) patterns. The request returns values for field names<br/>matching these patterns in the hits.fields property of the response.</para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor Fields(ICollection<Elastic.Clients.Elasticsearch.QueryDsl.FieldAndFormat>? fields)
	{
		FieldsDescriptor = null;
		FieldsDescriptorAction = null;
		FieldsDescriptorActions = null;
		FieldsValue = fields;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor Fields(QueryDsl.FieldAndFormatDescriptor descriptor)
	{
		FieldsValue = null;
		FieldsDescriptorAction = null;
		FieldsDescriptorActions = null;
		FieldsDescriptor = descriptor;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor Fields(Action<QueryDsl.FieldAndFormatDescriptor> configure)
	{
		FieldsValue = null;
		FieldsDescriptor = null;
		FieldsDescriptorActions = null;
		FieldsDescriptorAction = configure;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor Fields(params Action<QueryDsl.FieldAndFormatDescriptor>[] configure)
	{
		FieldsValue = null;
		FieldsDescriptor = null;
		FieldsDescriptorAction = null;
		FieldsDescriptorActions = configure;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor Highlight(Elastic.Clients.Elasticsearch.Core.Search.Highlight? highlight)
	{
		HighlightDescriptor = null;
		HighlightDescriptorAction = null;
		HighlightValue = highlight;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor Highlight(Core.Search.HighlightDescriptor descriptor)
	{
		HighlightValue = null;
		HighlightDescriptorAction = null;
		HighlightDescriptor = descriptor;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor Highlight(Action<Core.Search.HighlightDescriptor> configure)
	{
		HighlightValue = null;
		HighlightDescriptor = null;
		HighlightDescriptorAction = configure;
		return Self;
	}

	/// <summary>
	/// <para>Defines the approximate kNN search to run.</para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor Knn(ICollection<Elastic.Clients.Elasticsearch.KnnQuery>? knn)
	{
		KnnDescriptor = null;
		KnnDescriptorAction = null;
		KnnDescriptorActions = null;
		KnnValue = knn;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor Knn(KnnQueryDescriptor descriptor)
	{
		KnnValue = null;
		KnnDescriptorAction = null;
		KnnDescriptorActions = null;
		KnnDescriptor = descriptor;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor Knn(Action<KnnQueryDescriptor> configure)
	{
		KnnValue = null;
		KnnDescriptor = null;
		KnnDescriptorActions = null;
		KnnDescriptorAction = configure;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor Knn(params Action<KnnQueryDescriptor>[] configure)
	{
		KnnValue = null;
		KnnDescriptor = null;
		KnnDescriptorAction = null;
		KnnDescriptorActions = configure;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor PostFilter(Elastic.Clients.Elasticsearch.QueryDsl.Query? postFilter)
	{
		PostFilterDescriptor = null;
		PostFilterDescriptorAction = null;
		PostFilterValue = postFilter;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor PostFilter(QueryDsl.QueryDescriptor descriptor)
	{
		PostFilterValue = null;
		PostFilterDescriptorAction = null;
		PostFilterDescriptor = descriptor;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor PostFilter(Action<QueryDsl.QueryDescriptor> configure)
	{
		PostFilterValue = null;
		PostFilterDescriptor = null;
		PostFilterDescriptorAction = configure;
		return Self;
	}

	/// <summary>
	/// <para>Defines the search definition using the Query DSL.</para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor Query(Elastic.Clients.Elasticsearch.QueryDsl.Query? query)
	{
		QueryDescriptor = null;
		QueryDescriptorAction = null;
		QueryValue = query;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor Query(QueryDsl.QueryDescriptor descriptor)
	{
		QueryValue = null;
		QueryDescriptorAction = null;
		QueryDescriptor = descriptor;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor Query(Action<QueryDsl.QueryDescriptor> configure)
	{
		QueryValue = null;
		QueryDescriptor = null;
		QueryDescriptorAction = configure;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor Rescore(ICollection<Elastic.Clients.Elasticsearch.Core.Search.Rescore>? rescore)
	{
		RescoreDescriptor = null;
		RescoreDescriptorAction = null;
		RescoreDescriptorActions = null;
		RescoreValue = rescore;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor Rescore(Core.Search.RescoreDescriptor descriptor)
	{
		RescoreValue = null;
		RescoreDescriptorAction = null;
		RescoreDescriptorActions = null;
		RescoreDescriptor = descriptor;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor Rescore(Action<Core.Search.RescoreDescriptor> configure)
	{
		RescoreValue = null;
		RescoreDescriptor = null;
		RescoreDescriptorActions = null;
		RescoreDescriptorAction = configure;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor Rescore(params Action<Core.Search.RescoreDescriptor>[] configure)
	{
		RescoreValue = null;
		RescoreDescriptor = null;
		RescoreDescriptorAction = null;
		RescoreDescriptorActions = configure;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor Slice(Elastic.Clients.Elasticsearch.SlicedScroll? slice)
	{
		SliceDescriptor = null;
		SliceDescriptorAction = null;
		SliceValue = slice;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor Slice(SlicedScrollDescriptor descriptor)
	{
		SliceValue = null;
		SliceDescriptorAction = null;
		SliceDescriptor = descriptor;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor Slice(Action<SlicedScrollDescriptor> configure)
	{
		SliceValue = null;
		SliceDescriptor = null;
		SliceDescriptorAction = configure;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor Sort(ICollection<Elastic.Clients.Elasticsearch.SortOptions>? sort)
	{
		SortDescriptor = null;
		SortDescriptorAction = null;
		SortDescriptorActions = null;
		SortValue = sort;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor Sort(SortOptionsDescriptor descriptor)
	{
		SortValue = null;
		SortDescriptorAction = null;
		SortDescriptorActions = null;
		SortDescriptor = descriptor;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor Sort(Action<SortOptionsDescriptor> configure)
	{
		SortValue = null;
		SortDescriptor = null;
		SortDescriptorActions = null;
		SortDescriptorAction = configure;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor Sort(params Action<SortOptionsDescriptor>[] configure)
	{
		SortValue = null;
		SortDescriptor = null;
		SortDescriptorAction = null;
		SortDescriptorActions = configure;
		return Self;
	}

	/// <summary>
	/// <para>Indicates which source fields are returned for matching documents. These<br/>fields are returned in the hits._source property of the search response.</para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor Source(Elastic.Clients.Elasticsearch.Core.Search.SourceConfig? source)
	{
		SourceValue = source;
		return Self;
	}

	/// <summary>
	/// <para>If true, returns detailed information about score computation as part of a hit.</para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor Explain(bool? explain = true)
	{
		ExplainValue = explain;
		return Self;
	}

	/// <summary>
	/// <para>Configuration of search extensions defined by Elasticsearch plugins.</para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor Ext(Func<FluentDictionary<string, object>, FluentDictionary<string, object>> selector)
	{
		ExtValue = selector?.Invoke(new FluentDictionary<string, object>());
		return Self;
	}

	/// <summary>
	/// <para>Starting document offset. By default, you cannot page through more than 10,000<br/>hits using the from and size parameters. To page through more hits, use the<br/>search_after parameter.</para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor From(int? from)
	{
		FromValue = from;
		return Self;
	}

	/// <summary>
	/// <para>Boosts the _score of documents from specified indices.</para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor IndicesBoost(ICollection<IDictionary<Elastic.Clients.Elasticsearch.IndexName, double>>? indicesBoost)
	{
		IndicesBoostValue = indicesBoost;
		return Self;
	}

	/// <summary>
	/// <para>Minimum _score for matching documents. Documents with a lower _score are<br/>not included in the search results.</para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor MinScore(double? minScore)
	{
		MinScoreValue = minScore;
		return Self;
	}

	/// <summary>
	/// <para>Limits the search to a point in time (PIT). If you provide a PIT, you<br/>cannot specify an <index> in the request path.</para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor Pit(Elastic.Clients.Elasticsearch.Core.Search.PointInTimeReference? pit)
	{
		PitDescriptor = null;
		PitDescriptorAction = null;
		PitValue = pit;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor Pit(Core.Search.PointInTimeReferenceDescriptor descriptor)
	{
		PitValue = null;
		PitDescriptorAction = null;
		PitDescriptor = descriptor;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor Pit(Action<Core.Search.PointInTimeReferenceDescriptor> configure)
	{
		PitValue = null;
		PitDescriptor = null;
		PitDescriptorAction = configure;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor Profile(bool? profile = true)
	{
		ProfileValue = profile;
		return Self;
	}

	/// <summary>
	/// <para>Defines one or more runtime fields in the search request. These fields take<br/>precedence over mapped fields with the same name.</para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor RuntimeMappings(Func<FluentDictionary<Elastic.Clients.Elasticsearch.Field, Elastic.Clients.Elasticsearch.Mapping.RuntimeField>, FluentDictionary<Elastic.Clients.Elasticsearch.Field, Elastic.Clients.Elasticsearch.Mapping.RuntimeField>> selector)
	{
		RuntimeMappingsValue = selector?.Invoke(new FluentDictionary<Elastic.Clients.Elasticsearch.Field, Elastic.Clients.Elasticsearch.Mapping.RuntimeField>());
		return Self;
	}

	/// <summary>
	/// <para>Retrieve a script evaluation (based on different fields) for each hit.</para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor ScriptFields(Func<FluentDictionary<string, Elastic.Clients.Elasticsearch.ScriptField>, FluentDictionary<string, Elastic.Clients.Elasticsearch.ScriptField>> selector)
	{
		ScriptFieldsValue = selector?.Invoke(new FluentDictionary<string, Elastic.Clients.Elasticsearch.ScriptField>());
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor SearchAfter(ICollection<Elastic.Clients.Elasticsearch.FieldValue>? searchAfter)
	{
		SearchAfterValue = searchAfter;
		return Self;
	}

	/// <summary>
	/// <para>If true, returns sequence number and primary term of the last modification<br/>of each hit. See Optimistic concurrency control.</para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor SeqNoPrimaryTerm(bool? seqNoPrimaryTerm = true)
	{
		SeqNoPrimaryTermValue = seqNoPrimaryTerm;
		return Self;
	}

	/// <summary>
	/// <para>The number of hits to return. By default, you cannot page through more<br/>than 10,000 hits using the from and size parameters. To page through more<br/>hits, use the search_after parameter.</para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor Size(int? size)
	{
		SizeValue = size;
		return Self;
	}

	/// <summary>
	/// <para>Stats groups to associate with the search. Each group maintains a statistics<br/>aggregation for its associated searches. You can retrieve these stats using<br/>the indices stats API.</para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor Stats(ICollection<string>? stats)
	{
		StatsValue = stats;
		return Self;
	}

	/// <summary>
	/// <para>List of stored fields to return as part of a hit. If no fields are specified,<br/>no stored fields are included in the response. If this field is specified, the _source<br/>parameter defaults to false. You can pass _source: true to return both source fields<br/>and stored fields in the search response.</para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor StoredFields(Elastic.Clients.Elasticsearch.Fields? storedFields)
	{
		StoredFieldsValue = storedFields;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor Suggest(Elastic.Clients.Elasticsearch.Core.Search.Suggester? suggest)
	{
		SuggestDescriptor = null;
		SuggestDescriptorAction = null;
		SuggestValue = suggest;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor Suggest(Core.Search.SuggesterDescriptor descriptor)
	{
		SuggestValue = null;
		SuggestDescriptorAction = null;
		SuggestDescriptor = descriptor;
		return Self;
	}

	public SubmitAsyncSearchRequestDescriptor Suggest(Action<Core.Search.SuggesterDescriptor> configure)
	{
		SuggestValue = null;
		SuggestDescriptor = null;
		SuggestDescriptorAction = configure;
		return Self;
	}

	/// <summary>
	/// <para>Maximum number of documents to collect for each shard. If a query reaches this<br/>limit, Elasticsearch terminates the query early. Elasticsearch collects documents<br/>before sorting. Defaults to 0, which does not terminate query execution early.</para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor TerminateAfter(long? terminateAfter)
	{
		TerminateAfterValue = terminateAfter;
		return Self;
	}

	/// <summary>
	/// <para>Specifies the period of time to wait for a response from each shard. If no response<br/>is received before the timeout expires, the request fails and returns an error.<br/>Defaults to no timeout.</para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor Timeout(string? timeout)
	{
		TimeoutValue = timeout;
		return Self;
	}

	/// <summary>
	/// <para>If true, calculate and return document scores, even if the scores are not used for sorting.</para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor TrackScores(bool? trackScores = true)
	{
		TrackScoresValue = trackScores;
		return Self;
	}

	/// <summary>
	/// <para>Number of hits matching the query to count accurately. If true, the exact<br/>number of hits is returned at the cost of some performance. If false, the<br/>response does not include the total number of hits matching the query.<br/>Defaults to 10,000 hits.</para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor TrackTotalHits(Elastic.Clients.Elasticsearch.Core.Search.TrackHits? trackTotalHits)
	{
		TrackTotalHitsValue = trackTotalHits;
		return Self;
	}

	/// <summary>
	/// <para>If true, returns document version as part of a hit.</para>
	/// </summary>
	public SubmitAsyncSearchRequestDescriptor Version(bool? version = true)
	{
		VersionValue = version;
		return Self;
	}

	protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
	{
		writer.WriteStartObject();
		if (AggregationsDescriptor is not null)
		{
			writer.WritePropertyName("aggregations");
			JsonSerializer.Serialize(writer, AggregationsDescriptor, options);
		}
		else if (AggregationsDescriptorAction is not null)
		{
			writer.WritePropertyName("aggregations");
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.Aggregations.AggregationDescriptor(AggregationsDescriptorAction), options);
		}
		else if (AggregationsValue is not null)
		{
			writer.WritePropertyName("aggregations");
			JsonSerializer.Serialize(writer, AggregationsValue, options);
		}

		if (CollapseDescriptor is not null)
		{
			writer.WritePropertyName("collapse");
			JsonSerializer.Serialize(writer, CollapseDescriptor, options);
		}
		else if (CollapseDescriptorAction is not null)
		{
			writer.WritePropertyName("collapse");
			JsonSerializer.Serialize(writer, new Core.Search.FieldCollapseDescriptor(CollapseDescriptorAction), options);
		}
		else if (CollapseValue is not null)
		{
			writer.WritePropertyName("collapse");
			JsonSerializer.Serialize(writer, CollapseValue, options);
		}

		if (DocvalueFieldsDescriptor is not null)
		{
			writer.WritePropertyName("docvalue_fields");
			writer.WriteStartArray();
			JsonSerializer.Serialize(writer, DocvalueFieldsDescriptor, options);
			writer.WriteEndArray();
		}
		else if (DocvalueFieldsDescriptorAction is not null)
		{
			writer.WritePropertyName("docvalue_fields");
			writer.WriteStartArray();
			JsonSerializer.Serialize(writer, new QueryDsl.FieldAndFormatDescriptor(DocvalueFieldsDescriptorAction), options);
			writer.WriteEndArray();
		}
		else if (DocvalueFieldsDescriptorActions is not null)
		{
			writer.WritePropertyName("docvalue_fields");
			writer.WriteStartArray();
			foreach (var action in DocvalueFieldsDescriptorActions)
			{
				JsonSerializer.Serialize(writer, new QueryDsl.FieldAndFormatDescriptor(action), options);
			}

			writer.WriteEndArray();
		}
		else if (DocvalueFieldsValue is not null)
		{
			writer.WritePropertyName("docvalue_fields");
			JsonSerializer.Serialize(writer, DocvalueFieldsValue, options);
		}

		if (FieldsDescriptor is not null)
		{
			writer.WritePropertyName("fields");
			writer.WriteStartArray();
			JsonSerializer.Serialize(writer, FieldsDescriptor, options);
			writer.WriteEndArray();
		}
		else if (FieldsDescriptorAction is not null)
		{
			writer.WritePropertyName("fields");
			writer.WriteStartArray();
			JsonSerializer.Serialize(writer, new QueryDsl.FieldAndFormatDescriptor(FieldsDescriptorAction), options);
			writer.WriteEndArray();
		}
		else if (FieldsDescriptorActions is not null)
		{
			writer.WritePropertyName("fields");
			writer.WriteStartArray();
			foreach (var action in FieldsDescriptorActions)
			{
				JsonSerializer.Serialize(writer, new QueryDsl.FieldAndFormatDescriptor(action), options);
			}

			writer.WriteEndArray();
		}
		else if (FieldsValue is not null)
		{
			writer.WritePropertyName("fields");
			JsonSerializer.Serialize(writer, FieldsValue, options);
		}

		if (HighlightDescriptor is not null)
		{
			writer.WritePropertyName("highlight");
			JsonSerializer.Serialize(writer, HighlightDescriptor, options);
		}
		else if (HighlightDescriptorAction is not null)
		{
			writer.WritePropertyName("highlight");
			JsonSerializer.Serialize(writer, new Core.Search.HighlightDescriptor(HighlightDescriptorAction), options);
		}
		else if (HighlightValue is not null)
		{
			writer.WritePropertyName("highlight");
			JsonSerializer.Serialize(writer, HighlightValue, options);
		}

		if (KnnDescriptor is not null)
		{
			writer.WritePropertyName("knn");
			JsonSerializer.Serialize(writer, KnnDescriptor, options);
		}
		else if (KnnDescriptorAction is not null)
		{
			writer.WritePropertyName("knn");
			JsonSerializer.Serialize(writer, new KnnQueryDescriptor(KnnDescriptorAction), options);
		}
		else if (KnnDescriptorActions is not null)
		{
			writer.WritePropertyName("knn");
			if (KnnDescriptorActions.Length > 1)
				writer.WriteStartArray();
			foreach (var action in KnnDescriptorActions)
			{
				JsonSerializer.Serialize(writer, new KnnQueryDescriptor(action), options);
			}

			if (KnnDescriptorActions.Length > 1)
				writer.WriteEndArray();
		}
		else if (KnnValue is not null)
		{
			writer.WritePropertyName("knn");
			SingleOrManySerializationHelper.Serialize<Elastic.Clients.Elasticsearch.KnnQuery>(KnnValue, writer, options);
		}

		if (PostFilterDescriptor is not null)
		{
			writer.WritePropertyName("post_filter");
			JsonSerializer.Serialize(writer, PostFilterDescriptor, options);
		}
		else if (PostFilterDescriptorAction is not null)
		{
			writer.WritePropertyName("post_filter");
			JsonSerializer.Serialize(writer, new QueryDsl.QueryDescriptor(PostFilterDescriptorAction), options);
		}
		else if (PostFilterValue is not null)
		{
			writer.WritePropertyName("post_filter");
			JsonSerializer.Serialize(writer, PostFilterValue, options);
		}

		if (QueryDescriptor is not null)
		{
			writer.WritePropertyName("query");
			JsonSerializer.Serialize(writer, QueryDescriptor, options);
		}
		else if (QueryDescriptorAction is not null)
		{
			writer.WritePropertyName("query");
			JsonSerializer.Serialize(writer, new QueryDsl.QueryDescriptor(QueryDescriptorAction), options);
		}
		else if (QueryValue is not null)
		{
			writer.WritePropertyName("query");
			JsonSerializer.Serialize(writer, QueryValue, options);
		}

		if (RescoreDescriptor is not null)
		{
			writer.WritePropertyName("rescore");
			JsonSerializer.Serialize(writer, RescoreDescriptor, options);
		}
		else if (RescoreDescriptorAction is not null)
		{
			writer.WritePropertyName("rescore");
			JsonSerializer.Serialize(writer, new Core.Search.RescoreDescriptor(RescoreDescriptorAction), options);
		}
		else if (RescoreDescriptorActions is not null)
		{
			writer.WritePropertyName("rescore");
			if (RescoreDescriptorActions.Length > 1)
				writer.WriteStartArray();
			foreach (var action in RescoreDescriptorActions)
			{
				JsonSerializer.Serialize(writer, new Core.Search.RescoreDescriptor(action), options);
			}

			if (RescoreDescriptorActions.Length > 1)
				writer.WriteEndArray();
		}
		else if (RescoreValue is not null)
		{
			writer.WritePropertyName("rescore");
			SingleOrManySerializationHelper.Serialize<Elastic.Clients.Elasticsearch.Core.Search.Rescore>(RescoreValue, writer, options);
		}

		if (SliceDescriptor is not null)
		{
			writer.WritePropertyName("slice");
			JsonSerializer.Serialize(writer, SliceDescriptor, options);
		}
		else if (SliceDescriptorAction is not null)
		{
			writer.WritePropertyName("slice");
			JsonSerializer.Serialize(writer, new SlicedScrollDescriptor(SliceDescriptorAction), options);
		}
		else if (SliceValue is not null)
		{
			writer.WritePropertyName("slice");
			JsonSerializer.Serialize(writer, SliceValue, options);
		}

		if (SortDescriptor is not null)
		{
			writer.WritePropertyName("sort");
			JsonSerializer.Serialize(writer, SortDescriptor, options);
		}
		else if (SortDescriptorAction is not null)
		{
			writer.WritePropertyName("sort");
			JsonSerializer.Serialize(writer, new SortOptionsDescriptor(SortDescriptorAction), options);
		}
		else if (SortDescriptorActions is not null)
		{
			writer.WritePropertyName("sort");
			if (SortDescriptorActions.Length > 1)
				writer.WriteStartArray();
			foreach (var action in SortDescriptorActions)
			{
				JsonSerializer.Serialize(writer, new SortOptionsDescriptor(action), options);
			}

			if (SortDescriptorActions.Length > 1)
				writer.WriteEndArray();
		}
		else if (SortValue is not null)
		{
			writer.WritePropertyName("sort");
			SingleOrManySerializationHelper.Serialize<Elastic.Clients.Elasticsearch.SortOptions>(SortValue, writer, options);
		}

		if (SourceValue is not null)
		{
			writer.WritePropertyName("_source");
			JsonSerializer.Serialize(writer, SourceValue, options);
		}

		if (ExplainValue.HasValue)
		{
			writer.WritePropertyName("explain");
			writer.WriteBooleanValue(ExplainValue.Value);
		}

		if (ExtValue is not null)
		{
			writer.WritePropertyName("ext");
			JsonSerializer.Serialize(writer, ExtValue, options);
		}

		if (FromValue.HasValue)
		{
			writer.WritePropertyName("from");
			writer.WriteNumberValue(FromValue.Value);
		}

		if (IndicesBoostValue is not null)
		{
			writer.WritePropertyName("indices_boost");
			JsonSerializer.Serialize(writer, IndicesBoostValue, options);
		}

		if (MinScoreValue.HasValue)
		{
			writer.WritePropertyName("min_score");
			writer.WriteNumberValue(MinScoreValue.Value);
		}

		if (PitDescriptor is not null)
		{
			writer.WritePropertyName("pit");
			JsonSerializer.Serialize(writer, PitDescriptor, options);
		}
		else if (PitDescriptorAction is not null)
		{
			writer.WritePropertyName("pit");
			JsonSerializer.Serialize(writer, new Core.Search.PointInTimeReferenceDescriptor(PitDescriptorAction), options);
		}
		else if (PitValue is not null)
		{
			writer.WritePropertyName("pit");
			JsonSerializer.Serialize(writer, PitValue, options);
		}

		if (ProfileValue.HasValue)
		{
			writer.WritePropertyName("profile");
			writer.WriteBooleanValue(ProfileValue.Value);
		}

		if (RuntimeMappingsValue is not null)
		{
			writer.WritePropertyName("runtime_mappings");
			JsonSerializer.Serialize(writer, RuntimeMappingsValue, options);
		}

		if (ScriptFieldsValue is not null)
		{
			writer.WritePropertyName("script_fields");
			JsonSerializer.Serialize(writer, ScriptFieldsValue, options);
		}

		if (SearchAfterValue is not null)
		{
			writer.WritePropertyName("search_after");
			JsonSerializer.Serialize(writer, SearchAfterValue, options);
		}

		if (SeqNoPrimaryTermValue.HasValue)
		{
			writer.WritePropertyName("seq_no_primary_term");
			writer.WriteBooleanValue(SeqNoPrimaryTermValue.Value);
		}

		if (SizeValue.HasValue)
		{
			writer.WritePropertyName("size");
			writer.WriteNumberValue(SizeValue.Value);
		}

		if (StatsValue is not null)
		{
			writer.WritePropertyName("stats");
			JsonSerializer.Serialize(writer, StatsValue, options);
		}

		if (StoredFieldsValue is not null)
		{
			writer.WritePropertyName("stored_fields");
			JsonSerializer.Serialize(writer, StoredFieldsValue, options);
		}

		if (SuggestDescriptor is not null)
		{
			writer.WritePropertyName("suggest");
			JsonSerializer.Serialize(writer, SuggestDescriptor, options);
		}
		else if (SuggestDescriptorAction is not null)
		{
			writer.WritePropertyName("suggest");
			JsonSerializer.Serialize(writer, new Core.Search.SuggesterDescriptor(SuggestDescriptorAction), options);
		}
		else if (SuggestValue is not null)
		{
			writer.WritePropertyName("suggest");
			JsonSerializer.Serialize(writer, SuggestValue, options);
		}

		if (TerminateAfterValue.HasValue)
		{
			writer.WritePropertyName("terminate_after");
			writer.WriteNumberValue(TerminateAfterValue.Value);
		}

		if (!string.IsNullOrEmpty(TimeoutValue))
		{
			writer.WritePropertyName("timeout");
			writer.WriteStringValue(TimeoutValue);
		}

		if (TrackScoresValue.HasValue)
		{
			writer.WritePropertyName("track_scores");
			writer.WriteBooleanValue(TrackScoresValue.Value);
		}

		if (TrackTotalHitsValue is not null)
		{
			writer.WritePropertyName("track_total_hits");
			JsonSerializer.Serialize(writer, TrackTotalHitsValue, options);
		}

		if (VersionValue.HasValue)
		{
			writer.WritePropertyName("version");
			writer.WriteBooleanValue(VersionValue.Value);
		}

		writer.WriteEndObject();
	}
}