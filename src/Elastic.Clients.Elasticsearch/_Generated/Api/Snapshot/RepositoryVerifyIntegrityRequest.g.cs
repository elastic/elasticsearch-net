// Licensed to Elasticsearch B.V under one or more agreements.
// Elasticsearch B.V licenses this file to you under the Apache 2.0 License.
// See the LICENSE file in the project root for more information.
//
// ███╗   ██╗ ██████╗ ████████╗██╗ ██████╗███████╗
// ████╗  ██║██╔═══██╗╚══██╔══╝██║██╔════╝██╔════╝
// ██╔██╗ ██║██║   ██║   ██║   ██║██║     █████╗
// ██║╚██╗██║██║   ██║   ██║   ██║██║     ██╔══╝
// ██║ ╚████║╚██████╔╝   ██║   ██║╚██████╗███████╗
// ╚═╝  ╚═══╝ ╚═════╝    ╚═╝   ╚═╝ ╚═════╝╚══════╝
// ------------------------------------------------
//
// This file is automatically generated.
// Please do not edit these files manually.
//
// ------------------------------------------------

#nullable restore

using Elastic.Clients.Elasticsearch.Fluent;
using Elastic.Clients.Elasticsearch.Requests;
using Elastic.Clients.Elasticsearch.Serialization;
using Elastic.Transport;
using Elastic.Transport.Extensions;
using System;
using System.Collections.Generic;
using System.Linq.Expressions;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace Elastic.Clients.Elasticsearch.Snapshot;

public sealed partial class RepositoryVerifyIntegrityRequestParameters : RequestParameters
{
	/// <summary>
	/// <para>
	/// Number of threads to use for reading blob contents
	/// </para>
	/// </summary>
	public int? BlobThreadPoolConcurrency { get => Q<int?>("blob_thread_pool_concurrency"); set => Q("blob_thread_pool_concurrency", value); }

	/// <summary>
	/// <para>
	/// Number of snapshots to verify concurrently within each index
	/// </para>
	/// </summary>
	public int? IndexSnapshotVerificationConcurrency { get => Q<int?>("index_snapshot_verification_concurrency"); set => Q("index_snapshot_verification_concurrency", value); }

	/// <summary>
	/// <para>
	/// Number of indices to verify concurrently
	/// </para>
	/// </summary>
	public int? IndexVerificationConcurrency { get => Q<int?>("index_verification_concurrency"); set => Q("index_verification_concurrency", value); }

	/// <summary>
	/// <para>
	/// Rate limit for individual blob verification
	/// </para>
	/// </summary>
	public string? MaxBytesPerSec { get => Q<string?>("max_bytes_per_sec"); set => Q("max_bytes_per_sec", value); }

	/// <summary>
	/// <para>
	/// Maximum permitted number of failed shard snapshots
	/// </para>
	/// </summary>
	public int? MaxFailedShardSnapshots { get => Q<int?>("max_failed_shard_snapshots"); set => Q("max_failed_shard_snapshots", value); }

	/// <summary>
	/// <para>
	/// Number of threads to use for reading metadata
	/// </para>
	/// </summary>
	public int? MetaThreadPoolConcurrency { get => Q<int?>("meta_thread_pool_concurrency"); set => Q("meta_thread_pool_concurrency", value); }

	/// <summary>
	/// <para>
	/// Number of snapshots to verify concurrently
	/// </para>
	/// </summary>
	public int? SnapshotVerificationConcurrency { get => Q<int?>("snapshot_verification_concurrency"); set => Q("snapshot_verification_concurrency", value); }

	/// <summary>
	/// <para>
	/// Whether to verify the contents of individual blobs
	/// </para>
	/// </summary>
	public bool? VerifyBlobContents { get => Q<bool?>("verify_blob_contents"); set => Q("verify_blob_contents", value); }
}

/// <summary>
/// <para>
/// Verifies the integrity of the contents of a snapshot repository
/// </para>
/// </summary>
public sealed partial class RepositoryVerifyIntegrityRequest : PlainRequest<RepositoryVerifyIntegrityRequestParameters>
{
	public RepositoryVerifyIntegrityRequest(Elastic.Clients.Elasticsearch.Names name) : base(r => r.Required("repository", name))
	{
	}

	internal override ApiUrls ApiUrls => ApiUrlLookup.SnapshotRepositoryVerifyIntegrity;

	protected override HttpMethod StaticHttpMethod => HttpMethod.POST;

	internal override bool SupportsBody => false;

	internal override string OperationName => "snapshot.repository_verify_integrity";

	/// <summary>
	/// <para>
	/// Number of threads to use for reading blob contents
	/// </para>
	/// </summary>
	[JsonIgnore]
	public int? BlobThreadPoolConcurrency { get => Q<int?>("blob_thread_pool_concurrency"); set => Q("blob_thread_pool_concurrency", value); }

	/// <summary>
	/// <para>
	/// Number of snapshots to verify concurrently within each index
	/// </para>
	/// </summary>
	[JsonIgnore]
	public int? IndexSnapshotVerificationConcurrency { get => Q<int?>("index_snapshot_verification_concurrency"); set => Q("index_snapshot_verification_concurrency", value); }

	/// <summary>
	/// <para>
	/// Number of indices to verify concurrently
	/// </para>
	/// </summary>
	[JsonIgnore]
	public int? IndexVerificationConcurrency { get => Q<int?>("index_verification_concurrency"); set => Q("index_verification_concurrency", value); }

	/// <summary>
	/// <para>
	/// Rate limit for individual blob verification
	/// </para>
	/// </summary>
	[JsonIgnore]
	public string? MaxBytesPerSec { get => Q<string?>("max_bytes_per_sec"); set => Q("max_bytes_per_sec", value); }

	/// <summary>
	/// <para>
	/// Maximum permitted number of failed shard snapshots
	/// </para>
	/// </summary>
	[JsonIgnore]
	public int? MaxFailedShardSnapshots { get => Q<int?>("max_failed_shard_snapshots"); set => Q("max_failed_shard_snapshots", value); }

	/// <summary>
	/// <para>
	/// Number of threads to use for reading metadata
	/// </para>
	/// </summary>
	[JsonIgnore]
	public int? MetaThreadPoolConcurrency { get => Q<int?>("meta_thread_pool_concurrency"); set => Q("meta_thread_pool_concurrency", value); }

	/// <summary>
	/// <para>
	/// Number of snapshots to verify concurrently
	/// </para>
	/// </summary>
	[JsonIgnore]
	public int? SnapshotVerificationConcurrency { get => Q<int?>("snapshot_verification_concurrency"); set => Q("snapshot_verification_concurrency", value); }

	/// <summary>
	/// <para>
	/// Whether to verify the contents of individual blobs
	/// </para>
	/// </summary>
	[JsonIgnore]
	public bool? VerifyBlobContents { get => Q<bool?>("verify_blob_contents"); set => Q("verify_blob_contents", value); }
}

/// <summary>
/// <para>
/// Verifies the integrity of the contents of a snapshot repository
/// </para>
/// </summary>
public sealed partial class RepositoryVerifyIntegrityRequestDescriptor : RequestDescriptor<RepositoryVerifyIntegrityRequestDescriptor, RepositoryVerifyIntegrityRequestParameters>
{
	internal RepositoryVerifyIntegrityRequestDescriptor(Action<RepositoryVerifyIntegrityRequestDescriptor> configure) => configure.Invoke(this);

	public RepositoryVerifyIntegrityRequestDescriptor(Elastic.Clients.Elasticsearch.Names name) : base(r => r.Required("repository", name))
	{
	}

	internal override ApiUrls ApiUrls => ApiUrlLookup.SnapshotRepositoryVerifyIntegrity;

	protected override HttpMethod StaticHttpMethod => HttpMethod.POST;

	internal override bool SupportsBody => false;

	internal override string OperationName => "snapshot.repository_verify_integrity";

	public RepositoryVerifyIntegrityRequestDescriptor BlobThreadPoolConcurrency(int? blobThreadPoolConcurrency) => Qs("blob_thread_pool_concurrency", blobThreadPoolConcurrency);
	public RepositoryVerifyIntegrityRequestDescriptor IndexSnapshotVerificationConcurrency(int? indexSnapshotVerificationConcurrency) => Qs("index_snapshot_verification_concurrency", indexSnapshotVerificationConcurrency);
	public RepositoryVerifyIntegrityRequestDescriptor IndexVerificationConcurrency(int? indexVerificationConcurrency) => Qs("index_verification_concurrency", indexVerificationConcurrency);
	public RepositoryVerifyIntegrityRequestDescriptor MaxBytesPerSec(string? maxBytesPerSec) => Qs("max_bytes_per_sec", maxBytesPerSec);
	public RepositoryVerifyIntegrityRequestDescriptor MaxFailedShardSnapshots(int? maxFailedShardSnapshots) => Qs("max_failed_shard_snapshots", maxFailedShardSnapshots);
	public RepositoryVerifyIntegrityRequestDescriptor MetaThreadPoolConcurrency(int? metaThreadPoolConcurrency) => Qs("meta_thread_pool_concurrency", metaThreadPoolConcurrency);
	public RepositoryVerifyIntegrityRequestDescriptor SnapshotVerificationConcurrency(int? snapshotVerificationConcurrency) => Qs("snapshot_verification_concurrency", snapshotVerificationConcurrency);
	public RepositoryVerifyIntegrityRequestDescriptor VerifyBlobContents(bool? verifyBlobContents = true) => Qs("verify_blob_contents", verifyBlobContents);

	public RepositoryVerifyIntegrityRequestDescriptor Name(Elastic.Clients.Elasticsearch.Names name)
	{
		RouteValues.Required("repository", name);
		return Self;
	}

	protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
	{
	}
}