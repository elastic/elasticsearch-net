// Licensed to Elasticsearch B.V under one or more agreements.
// Elasticsearch B.V licenses this file to you under the Apache 2.0 License.
// See the LICENSE file in the project root for more information.
//
// ███╗   ██╗ ██████╗ ████████╗██╗ ██████╗███████╗
// ████╗  ██║██╔═══██╗╚══██╔══╝██║██╔════╝██╔════╝
// ██╔██╗ ██║██║   ██║   ██║   ██║██║     █████╗
// ██║╚██╗██║██║   ██║   ██║   ██║██║     ██╔══╝
// ██║ ╚████║╚██████╔╝   ██║   ██║╚██████╗███████╗
// ╚═╝  ╚═══╝ ╚═════╝    ╚═╝   ╚═╝ ╚═════╝╚══════╝
// ------------------------------------------------
//
// This file is automatically generated.
// Please do not edit these files manually.
//
// ------------------------------------------------

#nullable restore

using Elastic.Clients.Elasticsearch.Fluent;
using Elastic.Clients.Elasticsearch.Requests;
using Elastic.Clients.Elasticsearch.Serialization;
using Elastic.Transport;
using System;
using System.Collections.Generic;
using System.Linq.Expressions;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace Elastic.Clients.Elasticsearch.Rollup;

public sealed partial class PutJobRequestParameters : RequestParameters
{
}

/// <summary>
/// <para>Creates a rollup job.</para>
/// </summary>
public sealed partial class PutJobRequest : PlainRequest<PutJobRequestParameters>
{
	public PutJobRequest(Elastic.Clients.Elasticsearch.Id id) : base(r => r.Required("id", id))
	{
	}

	internal override ApiUrls ApiUrls => ApiUrlLookup.RollupPutJob;

	protected override HttpMethod StaticHttpMethod => HttpMethod.PUT;

	internal override bool SupportsBody => true;

	internal override string OperationName => "rollup.put_job";

	/// <summary>
	/// <para>A cron string which defines the intervals when the rollup job should be executed. When the interval<br/>triggers, the indexer attempts to rollup the data in the index pattern. The cron pattern is unrelated<br/>to the time interval of the data being rolled up. For example, you may wish to create hourly rollups<br/>of your document but to only run the indexer on a daily basis at midnight, as defined by the cron. The<br/>cron pattern is defined just like a Watcher cron schedule.</para>
	/// </summary>
	[JsonInclude, JsonPropertyName("cron")]
	public string Cron { get; set; }

	/// <summary>
	/// <para>Defines the grouping fields and aggregations that are defined for this rollup job. These fields will then be<br/>available later for aggregating into buckets. These aggs and fields can be used in any combination. Think of<br/>the groups configuration as defining a set of tools that can later be used in aggregations to partition the<br/>data. Unlike raw data, we have to think ahead to which fields and aggregations might be used. Rollups provide<br/>enough flexibility that you simply need to determine which fields are needed, not in what order they are needed.</para>
	/// </summary>
	[JsonInclude, JsonPropertyName("groups")]
	public Elastic.Clients.Elasticsearch.Rollup.Groupings Groups { get; set; }
	[JsonInclude, JsonPropertyName("headers")]
	public IDictionary<string, Union<string, ICollection<string>>>? Headers { get; set; }

	/// <summary>
	/// <para>The index or index pattern to roll up. Supports wildcard-style patterns (`logstash-*`). The job attempts to<br/>rollup the entire index or index-pattern.</para>
	/// </summary>
	[JsonInclude, JsonPropertyName("index_pattern")]
	public string IndexPattern { get; set; }

	/// <summary>
	/// <para>Defines the metrics to collect for each grouping tuple. By default, only the doc_counts are collected for each<br/>group. To make rollup useful, you will often add metrics like averages, mins, maxes, etc. Metrics are defined<br/>on a per-field basis and for each field you configure which metric should be collected.</para>
	/// </summary>
	[JsonInclude, JsonPropertyName("metrics")]
	public ICollection<Elastic.Clients.Elasticsearch.Rollup.FieldMetric>? Metrics { get; set; }

	/// <summary>
	/// <para>The number of bucket results that are processed on each iteration of the rollup indexer. A larger value tends<br/>to execute faster, but requires more memory during processing. This value has no effect on how the data is<br/>rolled up; it is merely used for tweaking the speed or memory cost of the indexer.</para>
	/// </summary>
	[JsonInclude, JsonPropertyName("page_size")]
	public int PageSize { get; set; }

	/// <summary>
	/// <para>The index that contains the rollup results. The index can be shared with other rollup jobs. The data is stored so that it doesn’t interfere with unrelated jobs.</para>
	/// </summary>
	[JsonInclude, JsonPropertyName("rollup_index")]
	public Elastic.Clients.Elasticsearch.IndexName RollupIndex { get; set; }

	/// <summary>
	/// <para>Time to wait for the request to complete.</para>
	/// </summary>
	[JsonInclude, JsonPropertyName("timeout")]
	public Elastic.Clients.Elasticsearch.Duration? Timeout { get; set; }
}

/// <summary>
/// <para>Creates a rollup job.</para>
/// </summary>
public sealed partial class PutJobRequestDescriptor<TDocument> : RequestDescriptor<PutJobRequestDescriptor<TDocument>, PutJobRequestParameters>
{
	internal PutJobRequestDescriptor(Action<PutJobRequestDescriptor<TDocument>> configure) => configure.Invoke(this);

	public PutJobRequestDescriptor(Elastic.Clients.Elasticsearch.Id id) : base(r => r.Required("id", id))
	{
	}

	internal override ApiUrls ApiUrls => ApiUrlLookup.RollupPutJob;

	protected override HttpMethod StaticHttpMethod => HttpMethod.PUT;

	internal override bool SupportsBody => true;

	internal override string OperationName => "rollup.put_job";

	public PutJobRequestDescriptor<TDocument> Id(Elastic.Clients.Elasticsearch.Id id)
	{
		RouteValues.Required("id", id);
		return Self;
	}

	private string CronValue { get; set; }
	private Elastic.Clients.Elasticsearch.Rollup.Groupings GroupsValue { get; set; }
	private Elastic.Clients.Elasticsearch.Rollup.GroupingsDescriptor<TDocument> GroupsDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.Rollup.GroupingsDescriptor<TDocument>> GroupsDescriptorAction { get; set; }
	private IDictionary<string, Union<string, ICollection<string>>>? HeadersValue { get; set; }
	private string IndexPatternValue { get; set; }
	private ICollection<Elastic.Clients.Elasticsearch.Rollup.FieldMetric>? MetricsValue { get; set; }
	private Elastic.Clients.Elasticsearch.Rollup.FieldMetricDescriptor<TDocument> MetricsDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.Rollup.FieldMetricDescriptor<TDocument>> MetricsDescriptorAction { get; set; }
	private Action<Elastic.Clients.Elasticsearch.Rollup.FieldMetricDescriptor<TDocument>>[] MetricsDescriptorActions { get; set; }
	private int PageSizeValue { get; set; }
	private Elastic.Clients.Elasticsearch.IndexName RollupIndexValue { get; set; }
	private Elastic.Clients.Elasticsearch.Duration? TimeoutValue { get; set; }

	/// <summary>
	/// <para>A cron string which defines the intervals when the rollup job should be executed. When the interval<br/>triggers, the indexer attempts to rollup the data in the index pattern. The cron pattern is unrelated<br/>to the time interval of the data being rolled up. For example, you may wish to create hourly rollups<br/>of your document but to only run the indexer on a daily basis at midnight, as defined by the cron. The<br/>cron pattern is defined just like a Watcher cron schedule.</para>
	/// </summary>
	public PutJobRequestDescriptor<TDocument> Cron(string cron)
	{
		CronValue = cron;
		return Self;
	}

	/// <summary>
	/// <para>Defines the grouping fields and aggregations that are defined for this rollup job. These fields will then be<br/>available later for aggregating into buckets. These aggs and fields can be used in any combination. Think of<br/>the groups configuration as defining a set of tools that can later be used in aggregations to partition the<br/>data. Unlike raw data, we have to think ahead to which fields and aggregations might be used. Rollups provide<br/>enough flexibility that you simply need to determine which fields are needed, not in what order they are needed.</para>
	/// </summary>
	public PutJobRequestDescriptor<TDocument> Groups(Elastic.Clients.Elasticsearch.Rollup.Groupings groups)
	{
		GroupsDescriptor = null;
		GroupsDescriptorAction = null;
		GroupsValue = groups;
		return Self;
	}

	public PutJobRequestDescriptor<TDocument> Groups(Elastic.Clients.Elasticsearch.Rollup.GroupingsDescriptor<TDocument> descriptor)
	{
		GroupsValue = null;
		GroupsDescriptorAction = null;
		GroupsDescriptor = descriptor;
		return Self;
	}

	public PutJobRequestDescriptor<TDocument> Groups(Action<Elastic.Clients.Elasticsearch.Rollup.GroupingsDescriptor<TDocument>> configure)
	{
		GroupsValue = null;
		GroupsDescriptor = null;
		GroupsDescriptorAction = configure;
		return Self;
	}

	public PutJobRequestDescriptor<TDocument> Headers(Func<FluentDictionary<string, Union<string, ICollection<string>>>, FluentDictionary<string, Union<string, ICollection<string>>>> selector)
	{
		HeadersValue = selector?.Invoke(new FluentDictionary<string, Union<string, ICollection<string>>>());
		return Self;
	}

	/// <summary>
	/// <para>The index or index pattern to roll up. Supports wildcard-style patterns (`logstash-*`). The job attempts to<br/>rollup the entire index or index-pattern.</para>
	/// </summary>
	public PutJobRequestDescriptor<TDocument> IndexPattern(string indexPattern)
	{
		IndexPatternValue = indexPattern;
		return Self;
	}

	/// <summary>
	/// <para>Defines the metrics to collect for each grouping tuple. By default, only the doc_counts are collected for each<br/>group. To make rollup useful, you will often add metrics like averages, mins, maxes, etc. Metrics are defined<br/>on a per-field basis and for each field you configure which metric should be collected.</para>
	/// </summary>
	public PutJobRequestDescriptor<TDocument> Metrics(ICollection<Elastic.Clients.Elasticsearch.Rollup.FieldMetric>? metrics)
	{
		MetricsDescriptor = null;
		MetricsDescriptorAction = null;
		MetricsDescriptorActions = null;
		MetricsValue = metrics;
		return Self;
	}

	public PutJobRequestDescriptor<TDocument> Metrics(Elastic.Clients.Elasticsearch.Rollup.FieldMetricDescriptor<TDocument> descriptor)
	{
		MetricsValue = null;
		MetricsDescriptorAction = null;
		MetricsDescriptorActions = null;
		MetricsDescriptor = descriptor;
		return Self;
	}

	public PutJobRequestDescriptor<TDocument> Metrics(Action<Elastic.Clients.Elasticsearch.Rollup.FieldMetricDescriptor<TDocument>> configure)
	{
		MetricsValue = null;
		MetricsDescriptor = null;
		MetricsDescriptorActions = null;
		MetricsDescriptorAction = configure;
		return Self;
	}

	public PutJobRequestDescriptor<TDocument> Metrics(params Action<Elastic.Clients.Elasticsearch.Rollup.FieldMetricDescriptor<TDocument>>[] configure)
	{
		MetricsValue = null;
		MetricsDescriptor = null;
		MetricsDescriptorAction = null;
		MetricsDescriptorActions = configure;
		return Self;
	}

	/// <summary>
	/// <para>The number of bucket results that are processed on each iteration of the rollup indexer. A larger value tends<br/>to execute faster, but requires more memory during processing. This value has no effect on how the data is<br/>rolled up; it is merely used for tweaking the speed or memory cost of the indexer.</para>
	/// </summary>
	public PutJobRequestDescriptor<TDocument> PageSize(int pageSize)
	{
		PageSizeValue = pageSize;
		return Self;
	}

	/// <summary>
	/// <para>The index that contains the rollup results. The index can be shared with other rollup jobs. The data is stored so that it doesn’t interfere with unrelated jobs.</para>
	/// </summary>
	public PutJobRequestDescriptor<TDocument> RollupIndex(Elastic.Clients.Elasticsearch.IndexName rollupIndex)
	{
		RollupIndexValue = rollupIndex;
		return Self;
	}

	/// <summary>
	/// <para>Time to wait for the request to complete.</para>
	/// </summary>
	public PutJobRequestDescriptor<TDocument> Timeout(Elastic.Clients.Elasticsearch.Duration? timeout)
	{
		TimeoutValue = timeout;
		return Self;
	}

	protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
	{
		writer.WriteStartObject();
		writer.WritePropertyName("cron");
		writer.WriteStringValue(CronValue);
		if (GroupsDescriptor is not null)
		{
			writer.WritePropertyName("groups");
			JsonSerializer.Serialize(writer, GroupsDescriptor, options);
		}
		else if (GroupsDescriptorAction is not null)
		{
			writer.WritePropertyName("groups");
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.Rollup.GroupingsDescriptor<TDocument>(GroupsDescriptorAction), options);
		}
		else
		{
			writer.WritePropertyName("groups");
			JsonSerializer.Serialize(writer, GroupsValue, options);
		}

		if (HeadersValue is not null)
		{
			writer.WritePropertyName("headers");
			JsonSerializer.Serialize(writer, HeadersValue, options);
		}

		writer.WritePropertyName("index_pattern");
		writer.WriteStringValue(IndexPatternValue);
		if (MetricsDescriptor is not null)
		{
			writer.WritePropertyName("metrics");
			writer.WriteStartArray();
			JsonSerializer.Serialize(writer, MetricsDescriptor, options);
			writer.WriteEndArray();
		}
		else if (MetricsDescriptorAction is not null)
		{
			writer.WritePropertyName("metrics");
			writer.WriteStartArray();
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.Rollup.FieldMetricDescriptor<TDocument>(MetricsDescriptorAction), options);
			writer.WriteEndArray();
		}
		else if (MetricsDescriptorActions is not null)
		{
			writer.WritePropertyName("metrics");
			writer.WriteStartArray();
			foreach (var action in MetricsDescriptorActions)
			{
				JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.Rollup.FieldMetricDescriptor<TDocument>(action), options);
			}

			writer.WriteEndArray();
		}
		else if (MetricsValue is not null)
		{
			writer.WritePropertyName("metrics");
			JsonSerializer.Serialize(writer, MetricsValue, options);
		}

		writer.WritePropertyName("page_size");
		writer.WriteNumberValue(PageSizeValue);
		writer.WritePropertyName("rollup_index");
		JsonSerializer.Serialize(writer, RollupIndexValue, options);
		if (TimeoutValue is not null)
		{
			writer.WritePropertyName("timeout");
			JsonSerializer.Serialize(writer, TimeoutValue, options);
		}

		writer.WriteEndObject();
	}
}

/// <summary>
/// <para>Creates a rollup job.</para>
/// </summary>
public sealed partial class PutJobRequestDescriptor : RequestDescriptor<PutJobRequestDescriptor, PutJobRequestParameters>
{
	internal PutJobRequestDescriptor(Action<PutJobRequestDescriptor> configure) => configure.Invoke(this);

	public PutJobRequestDescriptor(Elastic.Clients.Elasticsearch.Id id) : base(r => r.Required("id", id))
	{
	}

	internal override ApiUrls ApiUrls => ApiUrlLookup.RollupPutJob;

	protected override HttpMethod StaticHttpMethod => HttpMethod.PUT;

	internal override bool SupportsBody => true;

	internal override string OperationName => "rollup.put_job";

	public PutJobRequestDescriptor Id(Elastic.Clients.Elasticsearch.Id id)
	{
		RouteValues.Required("id", id);
		return Self;
	}

	private string CronValue { get; set; }
	private Elastic.Clients.Elasticsearch.Rollup.Groupings GroupsValue { get; set; }
	private Elastic.Clients.Elasticsearch.Rollup.GroupingsDescriptor GroupsDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.Rollup.GroupingsDescriptor> GroupsDescriptorAction { get; set; }
	private IDictionary<string, Union<string, ICollection<string>>>? HeadersValue { get; set; }
	private string IndexPatternValue { get; set; }
	private ICollection<Elastic.Clients.Elasticsearch.Rollup.FieldMetric>? MetricsValue { get; set; }
	private Elastic.Clients.Elasticsearch.Rollup.FieldMetricDescriptor MetricsDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.Rollup.FieldMetricDescriptor> MetricsDescriptorAction { get; set; }
	private Action<Elastic.Clients.Elasticsearch.Rollup.FieldMetricDescriptor>[] MetricsDescriptorActions { get; set; }
	private int PageSizeValue { get; set; }
	private Elastic.Clients.Elasticsearch.IndexName RollupIndexValue { get; set; }
	private Elastic.Clients.Elasticsearch.Duration? TimeoutValue { get; set; }

	/// <summary>
	/// <para>A cron string which defines the intervals when the rollup job should be executed. When the interval<br/>triggers, the indexer attempts to rollup the data in the index pattern. The cron pattern is unrelated<br/>to the time interval of the data being rolled up. For example, you may wish to create hourly rollups<br/>of your document but to only run the indexer on a daily basis at midnight, as defined by the cron. The<br/>cron pattern is defined just like a Watcher cron schedule.</para>
	/// </summary>
	public PutJobRequestDescriptor Cron(string cron)
	{
		CronValue = cron;
		return Self;
	}

	/// <summary>
	/// <para>Defines the grouping fields and aggregations that are defined for this rollup job. These fields will then be<br/>available later for aggregating into buckets. These aggs and fields can be used in any combination. Think of<br/>the groups configuration as defining a set of tools that can later be used in aggregations to partition the<br/>data. Unlike raw data, we have to think ahead to which fields and aggregations might be used. Rollups provide<br/>enough flexibility that you simply need to determine which fields are needed, not in what order they are needed.</para>
	/// </summary>
	public PutJobRequestDescriptor Groups(Elastic.Clients.Elasticsearch.Rollup.Groupings groups)
	{
		GroupsDescriptor = null;
		GroupsDescriptorAction = null;
		GroupsValue = groups;
		return Self;
	}

	public PutJobRequestDescriptor Groups(Elastic.Clients.Elasticsearch.Rollup.GroupingsDescriptor descriptor)
	{
		GroupsValue = null;
		GroupsDescriptorAction = null;
		GroupsDescriptor = descriptor;
		return Self;
	}

	public PutJobRequestDescriptor Groups(Action<Elastic.Clients.Elasticsearch.Rollup.GroupingsDescriptor> configure)
	{
		GroupsValue = null;
		GroupsDescriptor = null;
		GroupsDescriptorAction = configure;
		return Self;
	}

	public PutJobRequestDescriptor Headers(Func<FluentDictionary<string, Union<string, ICollection<string>>>, FluentDictionary<string, Union<string, ICollection<string>>>> selector)
	{
		HeadersValue = selector?.Invoke(new FluentDictionary<string, Union<string, ICollection<string>>>());
		return Self;
	}

	/// <summary>
	/// <para>The index or index pattern to roll up. Supports wildcard-style patterns (`logstash-*`). The job attempts to<br/>rollup the entire index or index-pattern.</para>
	/// </summary>
	public PutJobRequestDescriptor IndexPattern(string indexPattern)
	{
		IndexPatternValue = indexPattern;
		return Self;
	}

	/// <summary>
	/// <para>Defines the metrics to collect for each grouping tuple. By default, only the doc_counts are collected for each<br/>group. To make rollup useful, you will often add metrics like averages, mins, maxes, etc. Metrics are defined<br/>on a per-field basis and for each field you configure which metric should be collected.</para>
	/// </summary>
	public PutJobRequestDescriptor Metrics(ICollection<Elastic.Clients.Elasticsearch.Rollup.FieldMetric>? metrics)
	{
		MetricsDescriptor = null;
		MetricsDescriptorAction = null;
		MetricsDescriptorActions = null;
		MetricsValue = metrics;
		return Self;
	}

	public PutJobRequestDescriptor Metrics(Elastic.Clients.Elasticsearch.Rollup.FieldMetricDescriptor descriptor)
	{
		MetricsValue = null;
		MetricsDescriptorAction = null;
		MetricsDescriptorActions = null;
		MetricsDescriptor = descriptor;
		return Self;
	}

	public PutJobRequestDescriptor Metrics(Action<Elastic.Clients.Elasticsearch.Rollup.FieldMetricDescriptor> configure)
	{
		MetricsValue = null;
		MetricsDescriptor = null;
		MetricsDescriptorActions = null;
		MetricsDescriptorAction = configure;
		return Self;
	}

	public PutJobRequestDescriptor Metrics(params Action<Elastic.Clients.Elasticsearch.Rollup.FieldMetricDescriptor>[] configure)
	{
		MetricsValue = null;
		MetricsDescriptor = null;
		MetricsDescriptorAction = null;
		MetricsDescriptorActions = configure;
		return Self;
	}

	/// <summary>
	/// <para>The number of bucket results that are processed on each iteration of the rollup indexer. A larger value tends<br/>to execute faster, but requires more memory during processing. This value has no effect on how the data is<br/>rolled up; it is merely used for tweaking the speed or memory cost of the indexer.</para>
	/// </summary>
	public PutJobRequestDescriptor PageSize(int pageSize)
	{
		PageSizeValue = pageSize;
		return Self;
	}

	/// <summary>
	/// <para>The index that contains the rollup results. The index can be shared with other rollup jobs. The data is stored so that it doesn’t interfere with unrelated jobs.</para>
	/// </summary>
	public PutJobRequestDescriptor RollupIndex(Elastic.Clients.Elasticsearch.IndexName rollupIndex)
	{
		RollupIndexValue = rollupIndex;
		return Self;
	}

	/// <summary>
	/// <para>Time to wait for the request to complete.</para>
	/// </summary>
	public PutJobRequestDescriptor Timeout(Elastic.Clients.Elasticsearch.Duration? timeout)
	{
		TimeoutValue = timeout;
		return Self;
	}

	protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
	{
		writer.WriteStartObject();
		writer.WritePropertyName("cron");
		writer.WriteStringValue(CronValue);
		if (GroupsDescriptor is not null)
		{
			writer.WritePropertyName("groups");
			JsonSerializer.Serialize(writer, GroupsDescriptor, options);
		}
		else if (GroupsDescriptorAction is not null)
		{
			writer.WritePropertyName("groups");
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.Rollup.GroupingsDescriptor(GroupsDescriptorAction), options);
		}
		else
		{
			writer.WritePropertyName("groups");
			JsonSerializer.Serialize(writer, GroupsValue, options);
		}

		if (HeadersValue is not null)
		{
			writer.WritePropertyName("headers");
			JsonSerializer.Serialize(writer, HeadersValue, options);
		}

		writer.WritePropertyName("index_pattern");
		writer.WriteStringValue(IndexPatternValue);
		if (MetricsDescriptor is not null)
		{
			writer.WritePropertyName("metrics");
			writer.WriteStartArray();
			JsonSerializer.Serialize(writer, MetricsDescriptor, options);
			writer.WriteEndArray();
		}
		else if (MetricsDescriptorAction is not null)
		{
			writer.WritePropertyName("metrics");
			writer.WriteStartArray();
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.Rollup.FieldMetricDescriptor(MetricsDescriptorAction), options);
			writer.WriteEndArray();
		}
		else if (MetricsDescriptorActions is not null)
		{
			writer.WritePropertyName("metrics");
			writer.WriteStartArray();
			foreach (var action in MetricsDescriptorActions)
			{
				JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.Rollup.FieldMetricDescriptor(action), options);
			}

			writer.WriteEndArray();
		}
		else if (MetricsValue is not null)
		{
			writer.WritePropertyName("metrics");
			JsonSerializer.Serialize(writer, MetricsValue, options);
		}

		writer.WritePropertyName("page_size");
		writer.WriteNumberValue(PageSizeValue);
		writer.WritePropertyName("rollup_index");
		JsonSerializer.Serialize(writer, RollupIndexValue, options);
		if (TimeoutValue is not null)
		{
			writer.WritePropertyName("timeout");
			JsonSerializer.Serialize(writer, TimeoutValue, options);
		}

		writer.WriteEndObject();
	}
}