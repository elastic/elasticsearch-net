// Licensed to Elasticsearch B.V under one or more agreements.
// Elasticsearch B.V licenses this file to you under the Apache 2.0 License.
// See the LICENSE file in the project root for more information.
//
// ███╗   ██╗ ██████╗ ████████╗██╗ ██████╗███████╗
// ████╗  ██║██╔═══██╗╚══██╔══╝██║██╔════╝██╔════╝
// ██╔██╗ ██║██║   ██║   ██║   ██║██║     █████╗
// ██║╚██╗██║██║   ██║   ██║   ██║██║     ██╔══╝
// ██║ ╚████║╚██████╔╝   ██║   ██║╚██████╗███████╗
// ╚═╝  ╚═══╝ ╚═════╝    ╚═╝   ╚═╝ ╚═════╝╚══════╝
// ------------------------------------------------
//
// This file is automatically generated.
// Please do not edit these files manually.
//
// ------------------------------------------------

using System;
using System.Collections.Generic;
using System.Text.Json;
using System.Text.Json.Serialization;

#nullable restore
namespace Elastic.Clients.Elasticsearch.QueryDsl
{
	public partial class BoolQuery : QueryDsl.QueryBase, IQueryContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "bool";
		[JsonInclude]
		[JsonPropertyName("filter")]
		public Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? Filter { get; set; }

		[JsonInclude]
		[JsonPropertyName("minimum_should_match")]
		public Elastic.Clients.Elasticsearch.MinimumShouldMatch? MinimumShouldMatch { get; set; }

		[JsonInclude]
		[JsonPropertyName("must")]
		public Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? Must { get; set; }

		[JsonInclude]
		[JsonPropertyName("must_not")]
		public Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? MustNot { get; set; }

		[JsonInclude]
		[JsonPropertyName("should")]
		public Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? Should { get; set; }
	}

	[JsonConverter(typeof(BoolQueryDescriptorConverter))]
	public sealed partial class BoolQueryDescriptor : DescriptorBase<BoolQueryDescriptor>, IQueryContainerVariantDescriptor
	{
		public BoolQueryDescriptor()
		{
		}

		internal BoolQueryDescriptor(Action<BoolQueryDescriptor> configure) => configure.Invoke(this);
		internal Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? FilterValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.MinimumShouldMatch? MinimumShouldMatchValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? MustValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? MustNotValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? ShouldValue { get; private set; }

		internal QueryContainerDescriptor FilterDescriptor { get; private set; }

		internal QueryContainerDescriptor MustDescriptor { get; private set; }

		internal QueryContainerDescriptor MustNotDescriptor { get; private set; }

		internal QueryContainerDescriptor ShouldDescriptor { get; private set; }

		internal Action<QueryContainerDescriptor> FilterDescriptorAction { get; private set; }

		internal Action<QueryContainerDescriptor> MustDescriptorAction { get; private set; }

		internal Action<QueryContainerDescriptor> MustNotDescriptorAction { get; private set; }

		internal Action<QueryContainerDescriptor> ShouldDescriptorAction { get; private set; }

		public BoolQueryDescriptor Filter(Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? filter)
		{
			FilterDescriptor = null;
			FilterDescriptorAction = null;
			return Assign(filter, (a, v) => a.FilterValue = v);
		}

		public BoolQueryDescriptor Filter(Elastic.Clients.Elasticsearch.QueryDsl.QueryContainerDescriptor descriptor)
		{
			FilterValue = null;
			FilterDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.FilterDescriptor = v);
		}

		public BoolQueryDescriptor Filter(Action<Elastic.Clients.Elasticsearch.QueryDsl.QueryContainerDescriptor> configure)
		{
			FilterValue = null;
			FilterDescriptorAction = null;
			return Assign(configure, (a, v) => a.FilterDescriptorAction = v);
		}

		public BoolQueryDescriptor MinimumShouldMatch(Elastic.Clients.Elasticsearch.MinimumShouldMatch? minimumShouldMatch) => Assign(minimumShouldMatch, (a, v) => a.MinimumShouldMatchValue = v);
		public BoolQueryDescriptor Must(Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? must)
		{
			MustDescriptor = null;
			MustDescriptorAction = null;
			return Assign(must, (a, v) => a.MustValue = v);
		}

		public BoolQueryDescriptor Must(Elastic.Clients.Elasticsearch.QueryDsl.QueryContainerDescriptor descriptor)
		{
			MustValue = null;
			MustDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.MustDescriptor = v);
		}

		public BoolQueryDescriptor Must(Action<Elastic.Clients.Elasticsearch.QueryDsl.QueryContainerDescriptor> configure)
		{
			MustValue = null;
			MustDescriptorAction = null;
			return Assign(configure, (a, v) => a.MustDescriptorAction = v);
		}

		public BoolQueryDescriptor MustNot(Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? mustNot)
		{
			MustNotDescriptor = null;
			MustNotDescriptorAction = null;
			return Assign(mustNot, (a, v) => a.MustNotValue = v);
		}

		public BoolQueryDescriptor MustNot(Elastic.Clients.Elasticsearch.QueryDsl.QueryContainerDescriptor descriptor)
		{
			MustNotValue = null;
			MustNotDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.MustNotDescriptor = v);
		}

		public BoolQueryDescriptor MustNot(Action<Elastic.Clients.Elasticsearch.QueryDsl.QueryContainerDescriptor> configure)
		{
			MustNotValue = null;
			MustNotDescriptorAction = null;
			return Assign(configure, (a, v) => a.MustNotDescriptorAction = v);
		}

		public BoolQueryDescriptor Should(Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? should)
		{
			ShouldDescriptor = null;
			ShouldDescriptorAction = null;
			return Assign(should, (a, v) => a.ShouldValue = v);
		}

		public BoolQueryDescriptor Should(Elastic.Clients.Elasticsearch.QueryDsl.QueryContainerDescriptor descriptor)
		{
			ShouldValue = null;
			ShouldDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.ShouldDescriptor = v);
		}

		public BoolQueryDescriptor Should(Action<Elastic.Clients.Elasticsearch.QueryDsl.QueryContainerDescriptor> configure)
		{
			ShouldValue = null;
			ShouldDescriptorAction = null;
			return Assign(configure, (a, v) => a.ShouldDescriptorAction = v);
		}
	}

	internal sealed class BoolQueryDescriptorConverter : JsonConverter<BoolQueryDescriptor>
	{
		public override BoolQueryDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, BoolQueryDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value.FilterDescriptor is not null)
			{
				writer.WritePropertyName("filter");
				JsonSerializer.Serialize(writer, value.FilterDescriptor, options);
			}
			else if (value.FilterDescriptorAction is not null)
			{
				writer.WritePropertyName("filter");
				JsonSerializer.Serialize(writer, new QueryContainerDescriptor(value.FilterDescriptorAction), options);
			}
			else if (value.FilterValue is not null)
			{
				writer.WritePropertyName("filter");
				JsonSerializer.Serialize(writer, value.FilterValue, options);
			}

			if (value.MinimumShouldMatchValue is not null)
			{
				writer.WritePropertyName("minimum_should_match");
				JsonSerializer.Serialize(writer, value.MinimumShouldMatchValue, options);
			}

			if (value.MustDescriptor is not null)
			{
				writer.WritePropertyName("must");
				JsonSerializer.Serialize(writer, value.MustDescriptor, options);
			}
			else if (value.MustDescriptorAction is not null)
			{
				writer.WritePropertyName("must");
				JsonSerializer.Serialize(writer, new QueryContainerDescriptor(value.MustDescriptorAction), options);
			}
			else if (value.MustValue is not null)
			{
				writer.WritePropertyName("must");
				JsonSerializer.Serialize(writer, value.MustValue, options);
			}

			if (value.MustNotDescriptor is not null)
			{
				writer.WritePropertyName("must_not");
				JsonSerializer.Serialize(writer, value.MustNotDescriptor, options);
			}
			else if (value.MustNotDescriptorAction is not null)
			{
				writer.WritePropertyName("must_not");
				JsonSerializer.Serialize(writer, new QueryContainerDescriptor(value.MustNotDescriptorAction), options);
			}
			else if (value.MustNotValue is not null)
			{
				writer.WritePropertyName("must_not");
				JsonSerializer.Serialize(writer, value.MustNotValue, options);
			}

			if (value.ShouldDescriptor is not null)
			{
				writer.WritePropertyName("should");
				JsonSerializer.Serialize(writer, value.ShouldDescriptor, options);
			}
			else if (value.ShouldDescriptorAction is not null)
			{
				writer.WritePropertyName("should");
				JsonSerializer.Serialize(writer, new QueryContainerDescriptor(value.ShouldDescriptorAction), options);
			}
			else if (value.ShouldValue is not null)
			{
				writer.WritePropertyName("should");
				JsonSerializer.Serialize(writer, value.ShouldValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class BoostingQuery : QueryDsl.QueryBase, IQueryContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "boosting";
		[JsonInclude]
		[JsonPropertyName("negative_boost")]
		public double NegativeBoost { get; set; }

		[JsonInclude]
		[JsonPropertyName("negative")]
		public Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer Negative { get; set; }

		[JsonInclude]
		[JsonPropertyName("positive")]
		public Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer Positive { get; set; }
	}

	[JsonConverter(typeof(BoostingQueryDescriptorConverter))]
	public sealed partial class BoostingQueryDescriptor : DescriptorBase<BoostingQueryDescriptor>, IQueryContainerVariantDescriptor
	{
		public BoostingQueryDescriptor()
		{
		}

		internal BoostingQueryDescriptor(Action<BoostingQueryDescriptor> configure) => configure.Invoke(this);
		internal double NegativeBoostValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer NegativeValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer PositiveValue { get; private set; }

		internal QueryContainerDescriptor NegativeDescriptor { get; private set; }

		internal QueryContainerDescriptor PositiveDescriptor { get; private set; }

		internal Action<QueryContainerDescriptor> NegativeDescriptorAction { get; private set; }

		internal Action<QueryContainerDescriptor> PositiveDescriptorAction { get; private set; }

		public BoostingQueryDescriptor NegativeBoost(double negativeBoost) => Assign(negativeBoost, (a, v) => a.NegativeBoostValue = v);
		public BoostingQueryDescriptor Negative(Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer negative)
		{
			NegativeDescriptor = null;
			NegativeDescriptorAction = null;
			return Assign(negative, (a, v) => a.NegativeValue = v);
		}

		public BoostingQueryDescriptor Negative(Elastic.Clients.Elasticsearch.QueryDsl.QueryContainerDescriptor descriptor)
		{
			NegativeValue = null;
			NegativeDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.NegativeDescriptor = v);
		}

		public BoostingQueryDescriptor Negative(Action<Elastic.Clients.Elasticsearch.QueryDsl.QueryContainerDescriptor> configure)
		{
			NegativeValue = null;
			NegativeDescriptorAction = null;
			return Assign(configure, (a, v) => a.NegativeDescriptorAction = v);
		}

		public BoostingQueryDescriptor Positive(Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer positive)
		{
			PositiveDescriptor = null;
			PositiveDescriptorAction = null;
			return Assign(positive, (a, v) => a.PositiveValue = v);
		}

		public BoostingQueryDescriptor Positive(Elastic.Clients.Elasticsearch.QueryDsl.QueryContainerDescriptor descriptor)
		{
			PositiveValue = null;
			PositiveDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.PositiveDescriptor = v);
		}

		public BoostingQueryDescriptor Positive(Action<Elastic.Clients.Elasticsearch.QueryDsl.QueryContainerDescriptor> configure)
		{
			PositiveValue = null;
			PositiveDescriptorAction = null;
			return Assign(configure, (a, v) => a.PositiveDescriptorAction = v);
		}
	}

	internal sealed class BoostingQueryDescriptorConverter : JsonConverter<BoostingQueryDescriptor>
	{
		public override BoostingQueryDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, BoostingQueryDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("negative_boost");
			writer.WriteNumberValue(value.NegativeBoostValue);
			if (value.NegativeDescriptor is not null)
			{
				writer.WritePropertyName("negative");
				JsonSerializer.Serialize(writer, value.NegativeDescriptor, options);
			}
			else if (value.NegativeDescriptorAction is not null)
			{
				writer.WritePropertyName("negative");
				JsonSerializer.Serialize(writer, new QueryContainerDescriptor(value.NegativeDescriptorAction), options);
			}
			else
			{
				writer.WritePropertyName("negative");
				JsonSerializer.Serialize(writer, value.NegativeValue, options);
			}

			if (value.PositiveDescriptor is not null)
			{
				writer.WritePropertyName("positive");
				JsonSerializer.Serialize(writer, value.PositiveDescriptor, options);
			}
			else if (value.PositiveDescriptorAction is not null)
			{
				writer.WritePropertyName("positive");
				JsonSerializer.Serialize(writer, new QueryContainerDescriptor(value.PositiveDescriptorAction), options);
			}
			else
			{
				writer.WritePropertyName("positive");
				JsonSerializer.Serialize(writer, value.PositiveValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class BoundingBox
	{
		[JsonInclude]
		[JsonPropertyName("bottom_right")]
		public Elastic.Clients.Elasticsearch.QueryDsl.GeoLocation? BottomRight { get; set; }

		[JsonInclude]
		[JsonPropertyName("top_left")]
		public Elastic.Clients.Elasticsearch.QueryDsl.GeoLocation? TopLeft { get; set; }

		[JsonInclude]
		[JsonPropertyName("top_right")]
		public Elastic.Clients.Elasticsearch.QueryDsl.GeoLocation? TopRight { get; set; }

		[JsonInclude]
		[JsonPropertyName("bottom_left")]
		public Elastic.Clients.Elasticsearch.QueryDsl.GeoLocation? BottomLeft { get; set; }

		[JsonInclude]
		[JsonPropertyName("top")]
		public double? Top { get; set; }

		[JsonInclude]
		[JsonPropertyName("left")]
		public double? Left { get; set; }

		[JsonInclude]
		[JsonPropertyName("right")]
		public double? Right { get; set; }

		[JsonInclude]
		[JsonPropertyName("bottom")]
		public double? Bottom { get; set; }

		[JsonInclude]
		[JsonPropertyName("wkt")]
		public string? Wkt { get; set; }
	}

	[JsonConverter(typeof(BoundingBoxDescriptorConverter))]
	public sealed partial class BoundingBoxDescriptor : DescriptorBase<BoundingBoxDescriptor>
	{
		public BoundingBoxDescriptor()
		{
		}

		internal BoundingBoxDescriptor(Action<BoundingBoxDescriptor> configure) => configure.Invoke(this);
		internal Elastic.Clients.Elasticsearch.QueryDsl.GeoLocation? BottomRightValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.GeoLocation? TopLeftValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.GeoLocation? TopRightValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.GeoLocation? BottomLeftValue { get; private set; }

		internal double? TopValue { get; private set; }

		internal double? LeftValue { get; private set; }

		internal double? RightValue { get; private set; }

		internal double? BottomValue { get; private set; }

		internal string? WktValue { get; private set; }

		public BoundingBoxDescriptor BottomRight(Elastic.Clients.Elasticsearch.QueryDsl.GeoLocation? bottomRight) => Assign(bottomRight, (a, v) => a.BottomRightValue = v);
		public BoundingBoxDescriptor TopLeft(Elastic.Clients.Elasticsearch.QueryDsl.GeoLocation? topLeft) => Assign(topLeft, (a, v) => a.TopLeftValue = v);
		public BoundingBoxDescriptor TopRight(Elastic.Clients.Elasticsearch.QueryDsl.GeoLocation? topRight) => Assign(topRight, (a, v) => a.TopRightValue = v);
		public BoundingBoxDescriptor BottomLeft(Elastic.Clients.Elasticsearch.QueryDsl.GeoLocation? bottomLeft) => Assign(bottomLeft, (a, v) => a.BottomLeftValue = v);
		public BoundingBoxDescriptor Top(double? top) => Assign(top, (a, v) => a.TopValue = v);
		public BoundingBoxDescriptor Left(double? left) => Assign(left, (a, v) => a.LeftValue = v);
		public BoundingBoxDescriptor Right(double? right) => Assign(right, (a, v) => a.RightValue = v);
		public BoundingBoxDescriptor Bottom(double? bottom) => Assign(bottom, (a, v) => a.BottomValue = v);
		public BoundingBoxDescriptor Wkt(string? wkt) => Assign(wkt, (a, v) => a.WktValue = v);
	}

	internal sealed class BoundingBoxDescriptorConverter : JsonConverter<BoundingBoxDescriptor>
	{
		public override BoundingBoxDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, BoundingBoxDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value.BottomRightValue is not null)
			{
				writer.WritePropertyName("bottom_right");
				JsonSerializer.Serialize(writer, value.BottomRightValue, options);
			}

			if (value.TopLeftValue is not null)
			{
				writer.WritePropertyName("top_left");
				JsonSerializer.Serialize(writer, value.TopLeftValue, options);
			}

			if (value.TopRightValue is not null)
			{
				writer.WritePropertyName("top_right");
				JsonSerializer.Serialize(writer, value.TopRightValue, options);
			}

			if (value.BottomLeftValue is not null)
			{
				writer.WritePropertyName("bottom_left");
				JsonSerializer.Serialize(writer, value.BottomLeftValue, options);
			}

			if (value.TopValue.HasValue)
			{
				writer.WritePropertyName("top");
				writer.WriteNumberValue(value.TopValue.Value);
			}

			if (value.LeftValue.HasValue)
			{
				writer.WritePropertyName("left");
				writer.WriteNumberValue(value.LeftValue.Value);
			}

			if (value.RightValue.HasValue)
			{
				writer.WritePropertyName("right");
				writer.WriteNumberValue(value.RightValue.Value);
			}

			if (value.BottomValue.HasValue)
			{
				writer.WritePropertyName("bottom");
				writer.WriteNumberValue(value.BottomValue.Value);
			}

			if (!string.IsNullOrEmpty(value.WktValue))
			{
				writer.WritePropertyName("wkt");
				writer.WriteStringValue(value.WktValue);
			}

			writer.WriteEndObject();
		}
	}

	public partial class CombinedFieldsQuery : QueryDsl.QueryBase, IQueryContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "combined_fields";
		[JsonInclude]
		[JsonPropertyName("fields")]
		public IEnumerable<string> Fields { get; set; }

		[JsonInclude]
		[JsonPropertyName("query")]
		public string Query { get; set; }

		[JsonInclude]
		[JsonPropertyName("auto_generate_synonyms_phrase_query")]
		public bool? AutoGenerateSynonymsPhraseQuery { get; set; }

		[JsonInclude]
		[JsonPropertyName("operator")]
		public Elastic.Clients.Elasticsearch.QueryDsl.CombinedFieldsOperator? Operator { get; set; }

		[JsonInclude]
		[JsonPropertyName("mimimum_should_match")]
		public Elastic.Clients.Elasticsearch.MinimumShouldMatch? MimimumShouldMatch { get; set; }

		[JsonInclude]
		[JsonPropertyName("zero_terms_query")]
		public Elastic.Clients.Elasticsearch.QueryDsl.CombinedFieldsZeroTerms? ZeroTermsQuery { get; set; }
	}

	[JsonConverter(typeof(CombinedFieldsQueryDescriptorConverter))]
	public sealed partial class CombinedFieldsQueryDescriptor : DescriptorBase<CombinedFieldsQueryDescriptor>, IQueryContainerVariantDescriptor
	{
		public CombinedFieldsQueryDescriptor()
		{
		}

		internal CombinedFieldsQueryDescriptor(Action<CombinedFieldsQueryDescriptor> configure) => configure.Invoke(this);
		internal IEnumerable<string> FieldsValue { get; private set; }

		internal string QueryValue { get; private set; }

		internal bool? AutoGenerateSynonymsPhraseQueryValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.CombinedFieldsOperator? OperatorValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.MinimumShouldMatch? MimimumShouldMatchValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.CombinedFieldsZeroTerms? ZeroTermsQueryValue { get; private set; }

		public CombinedFieldsQueryDescriptor Fields(IEnumerable<string> fields) => Assign(fields, (a, v) => a.FieldsValue = v);
		public CombinedFieldsQueryDescriptor Query(string query) => Assign(query, (a, v) => a.QueryValue = v);
		public CombinedFieldsQueryDescriptor AutoGenerateSynonymsPhraseQuery(bool? autoGenerateSynonymsPhraseQuery = true) => Assign(autoGenerateSynonymsPhraseQuery, (a, v) => a.AutoGenerateSynonymsPhraseQueryValue = v);
		public CombinedFieldsQueryDescriptor Operator(Elastic.Clients.Elasticsearch.QueryDsl.CombinedFieldsOperator? op) => Assign(op, (a, v) => a.OperatorValue = v);
		public CombinedFieldsQueryDescriptor MimimumShouldMatch(Elastic.Clients.Elasticsearch.MinimumShouldMatch? mimimumShouldMatch) => Assign(mimimumShouldMatch, (a, v) => a.MimimumShouldMatchValue = v);
		public CombinedFieldsQueryDescriptor ZeroTermsQuery(Elastic.Clients.Elasticsearch.QueryDsl.CombinedFieldsZeroTerms? zeroTermsQuery) => Assign(zeroTermsQuery, (a, v) => a.ZeroTermsQueryValue = v);
	}

	internal sealed class CombinedFieldsQueryDescriptorConverter : JsonConverter<CombinedFieldsQueryDescriptor>
	{
		public override CombinedFieldsQueryDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, CombinedFieldsQueryDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("fields");
			JsonSerializer.Serialize(writer, value.FieldsValue, options);
			writer.WritePropertyName("query");
			writer.WriteStringValue(value.QueryValue);
			if (value.AutoGenerateSynonymsPhraseQueryValue.HasValue)
			{
				writer.WritePropertyName("auto_generate_synonyms_phrase_query");
				writer.WriteBooleanValue(value.AutoGenerateSynonymsPhraseQueryValue.Value);
			}

			if (value.OperatorValue is not null)
			{
				writer.WritePropertyName("operator");
				JsonSerializer.Serialize(writer, value.OperatorValue, options);
			}

			if (value.MimimumShouldMatchValue is not null)
			{
				writer.WritePropertyName("mimimum_should_match");
				JsonSerializer.Serialize(writer, value.MimimumShouldMatchValue, options);
			}

			if (value.ZeroTermsQueryValue is not null)
			{
				writer.WritePropertyName("zero_terms_query");
				JsonSerializer.Serialize(writer, value.ZeroTermsQueryValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class ConstantScoreQuery : QueryDsl.QueryBase, IQueryContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "constant_score";
		[JsonInclude]
		[JsonPropertyName("filter")]
		public Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer Filter { get; set; }
	}

	[JsonConverter(typeof(ConstantScoreQueryDescriptorConverter))]
	public sealed partial class ConstantScoreQueryDescriptor : DescriptorBase<ConstantScoreQueryDescriptor>, IQueryContainerVariantDescriptor
	{
		public ConstantScoreQueryDescriptor()
		{
		}

		internal ConstantScoreQueryDescriptor(Action<ConstantScoreQueryDescriptor> configure) => configure.Invoke(this);
		internal Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer FilterValue { get; private set; }

		internal QueryContainerDescriptor FilterDescriptor { get; private set; }

		internal Action<QueryContainerDescriptor> FilterDescriptorAction { get; private set; }

		public ConstantScoreQueryDescriptor Filter(Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer filter)
		{
			FilterDescriptor = null;
			FilterDescriptorAction = null;
			return Assign(filter, (a, v) => a.FilterValue = v);
		}

		public ConstantScoreQueryDescriptor Filter(Elastic.Clients.Elasticsearch.QueryDsl.QueryContainerDescriptor descriptor)
		{
			FilterValue = null;
			FilterDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.FilterDescriptor = v);
		}

		public ConstantScoreQueryDescriptor Filter(Action<Elastic.Clients.Elasticsearch.QueryDsl.QueryContainerDescriptor> configure)
		{
			FilterValue = null;
			FilterDescriptorAction = null;
			return Assign(configure, (a, v) => a.FilterDescriptorAction = v);
		}
	}

	internal sealed class ConstantScoreQueryDescriptorConverter : JsonConverter<ConstantScoreQueryDescriptor>
	{
		public override ConstantScoreQueryDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, ConstantScoreQueryDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value.FilterDescriptor is not null)
			{
				writer.WritePropertyName("filter");
				JsonSerializer.Serialize(writer, value.FilterDescriptor, options);
			}
			else if (value.FilterDescriptorAction is not null)
			{
				writer.WritePropertyName("filter");
				JsonSerializer.Serialize(writer, new QueryContainerDescriptor(value.FilterDescriptorAction), options);
			}
			else
			{
				writer.WritePropertyName("filter");
				JsonSerializer.Serialize(writer, value.FilterValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class DisMaxQuery : QueryDsl.QueryBase, IQueryContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "dis_max";
		[JsonInclude]
		[JsonPropertyName("queries")]
		public IEnumerable<Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer> Queries { get; set; }

		[JsonInclude]
		[JsonPropertyName("tie_breaker")]
		public double? TieBreaker { get; set; }
	}

	[JsonConverter(typeof(DisMaxQueryDescriptorConverter))]
	public sealed partial class DisMaxQueryDescriptor : DescriptorBase<DisMaxQueryDescriptor>, IQueryContainerVariantDescriptor
	{
		public DisMaxQueryDescriptor()
		{
		}

		internal DisMaxQueryDescriptor(Action<DisMaxQueryDescriptor> configure) => configure.Invoke(this);
		internal IEnumerable<Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer> QueriesValue { get; private set; }

		internal double? TieBreakerValue { get; private set; }

		public DisMaxQueryDescriptor Queries(IEnumerable<Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer> queries) => Assign(queries, (a, v) => a.QueriesValue = v);
		public DisMaxQueryDescriptor TieBreaker(double? tieBreaker) => Assign(tieBreaker, (a, v) => a.TieBreakerValue = v);
	}

	internal sealed class DisMaxQueryDescriptorConverter : JsonConverter<DisMaxQueryDescriptor>
	{
		public override DisMaxQueryDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, DisMaxQueryDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("queries");
			JsonSerializer.Serialize(writer, value.QueriesValue, options);
			if (value.TieBreakerValue.HasValue)
			{
				writer.WritePropertyName("tie_breaker");
				writer.WriteNumberValue(value.TieBreakerValue.Value);
			}

			writer.WriteEndObject();
		}
	}

	public partial class ExistsQuery : QueryDsl.QueryBase, IQueryContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "exists";
		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }
	}

	[JsonConverter(typeof(ExistsQueryDescriptorConverter))]
	public sealed partial class ExistsQueryDescriptor : DescriptorBase<ExistsQueryDescriptor>, IQueryContainerVariantDescriptor
	{
		public ExistsQueryDescriptor()
		{
		}

		internal ExistsQueryDescriptor(Action<ExistsQueryDescriptor> configure) => configure.Invoke(this);
		internal string FieldValue { get; private set; }

		public ExistsQueryDescriptor Field(string field) => Assign(field, (a, v) => a.FieldValue = v);
	}

	internal sealed class ExistsQueryDescriptorConverter : JsonConverter<ExistsQueryDescriptor>
	{
		public override ExistsQueryDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, ExistsQueryDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, value.FieldValue, options);
			writer.WriteEndObject();
		}
	}

	public partial class FieldValueFactorScoreFunction : QueryDsl.ScoreFunctionBase, IFunctionScoreContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IFunctionScoreContainerVariant.FunctionScoreContainerVariantName => "field_value_factor";
		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("factor")]
		public double? Factor { get; set; }

		[JsonInclude]
		[JsonPropertyName("missing")]
		public double? Missing { get; set; }

		[JsonInclude]
		[JsonPropertyName("modifier")]
		public Elastic.Clients.Elasticsearch.QueryDsl.FieldValueFactorModifier? Modifier { get; set; }
	}

	[JsonConverter(typeof(FieldValueFactorScoreFunctionDescriptorConverter))]
	public sealed partial class FieldValueFactorScoreFunctionDescriptor : DescriptorBase<FieldValueFactorScoreFunctionDescriptor>, IFunctionScoreContainerVariantDescriptor
	{
		public FieldValueFactorScoreFunctionDescriptor()
		{
		}

		internal FieldValueFactorScoreFunctionDescriptor(Action<FieldValueFactorScoreFunctionDescriptor> configure) => configure.Invoke(this);
		internal string FieldValue { get; private set; }

		internal double? FactorValue { get; private set; }

		internal double? MissingValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.FieldValueFactorModifier? ModifierValue { get; private set; }

		public FieldValueFactorScoreFunctionDescriptor Field(string field) => Assign(field, (a, v) => a.FieldValue = v);
		public FieldValueFactorScoreFunctionDescriptor Factor(double? factor) => Assign(factor, (a, v) => a.FactorValue = v);
		public FieldValueFactorScoreFunctionDescriptor Missing(double? missing) => Assign(missing, (a, v) => a.MissingValue = v);
		public FieldValueFactorScoreFunctionDescriptor Modifier(Elastic.Clients.Elasticsearch.QueryDsl.FieldValueFactorModifier? modifier) => Assign(modifier, (a, v) => a.ModifierValue = v);
	}

	internal sealed class FieldValueFactorScoreFunctionDescriptorConverter : JsonConverter<FieldValueFactorScoreFunctionDescriptor>
	{
		public override FieldValueFactorScoreFunctionDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, FieldValueFactorScoreFunctionDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, value.FieldValue, options);
			if (value.FactorValue.HasValue)
			{
				writer.WritePropertyName("factor");
				writer.WriteNumberValue(value.FactorValue.Value);
			}

			if (value.MissingValue.HasValue)
			{
				writer.WritePropertyName("missing");
				writer.WriteNumberValue(value.MissingValue.Value);
			}

			if (value.ModifierValue is not null)
			{
				writer.WritePropertyName("modifier");
				JsonSerializer.Serialize(writer, value.ModifierValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public interface IFunctionScoreContainerVariant
	{
		string FunctionScoreContainerVariantName { get; }
	}

	internal interface IFunctionScoreContainerVariantDescriptor
	{
	}

	[JsonConverter(typeof(FunctionScoreContainerConverter))]
	public partial class FunctionScoreContainer : IContainer
	{
		public FunctionScoreContainer(IFunctionScoreContainerVariant variant) => Variant = variant ?? throw new ArgumentNullException(nameof(variant));
		internal IFunctionScoreContainerVariant Variant { get; }

		[JsonInclude]
		[JsonPropertyName("filter")]
		public Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? Filter { get; set; }

		[JsonInclude]
		[JsonPropertyName("weight")]
		public double? Weight { get; set; }
	}

	internal sealed class FunctionScoreContainerConverter : JsonConverter<FunctionScoreContainer>
	{
		public override FunctionScoreContainer Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			reader.Read();
			if (reader.TokenType != JsonTokenType.PropertyName)
			{
				throw new JsonException();
			}

			var propertyName = reader.GetString();
			if (propertyName == "field_value_factor")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.FieldValueFactorScoreFunction?>(ref reader, options);
				reader.Read();
				return new FunctionScoreContainer(variant);
			}

			if (propertyName == "random_score")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.RandomScoreFunction?>(ref reader, options);
				reader.Read();
				return new FunctionScoreContainer(variant);
			}

			if (propertyName == "script_score")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.ScriptScoreFunction?>(ref reader, options);
				reader.Read();
				return new FunctionScoreContainer(variant);
			}

			throw new JsonException();
		}

		public override void Write(Utf8JsonWriter writer, FunctionScoreContainer value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName(value.Variant.FunctionScoreContainerVariantName);
			switch (value.Variant)
			{
				case Elastic.Clients.Elasticsearch.QueryDsl.FieldValueFactorScoreFunction variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.RandomScoreFunction variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.ScriptScoreFunction variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
			}

			writer.WriteEndObject();
		}
	}

	public sealed partial class FunctionScoreContainerDescriptor : DescriptorBase<FunctionScoreContainerDescriptor>
	{
		public FunctionScoreContainerDescriptor()
		{
		}

		internal FunctionScoreContainerDescriptor(Action<FunctionScoreContainerDescriptor> configure) => configure.Invoke(this);
	}

	internal sealed class FunctionScoreContainerDescriptorConverter : JsonConverter<FunctionScoreContainerDescriptor>
	{
		public override FunctionScoreContainerDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, FunctionScoreContainerDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WriteEndObject();
		}
	}

	public partial class FunctionScoreQuery : QueryDsl.QueryBase, IQueryContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "function_score";
		[JsonInclude]
		[JsonPropertyName("boost_mode")]
		public Elastic.Clients.Elasticsearch.QueryDsl.FunctionBoostMode? BoostMode { get; set; }

		[JsonInclude]
		[JsonPropertyName("functions")]
		public IEnumerable<Elastic.Clients.Elasticsearch.QueryDsl.FunctionScoreContainer>? Functions { get; set; }

		[JsonInclude]
		[JsonPropertyName("max_boost")]
		public double? MaxBoost { get; set; }

		[JsonInclude]
		[JsonPropertyName("min_score")]
		public double? MinScore { get; set; }

		[JsonInclude]
		[JsonPropertyName("query")]
		public Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? Query { get; set; }

		[JsonInclude]
		[JsonPropertyName("score_mode")]
		public Elastic.Clients.Elasticsearch.QueryDsl.FunctionScoreMode? ScoreMode { get; set; }
	}

	[JsonConverter(typeof(FunctionScoreQueryDescriptorConverter))]
	public sealed partial class FunctionScoreQueryDescriptor : DescriptorBase<FunctionScoreQueryDescriptor>, IQueryContainerVariantDescriptor
	{
		public FunctionScoreQueryDescriptor()
		{
		}

		internal FunctionScoreQueryDescriptor(Action<FunctionScoreQueryDescriptor> configure) => configure.Invoke(this);
		internal Elastic.Clients.Elasticsearch.QueryDsl.FunctionBoostMode? BoostModeValue { get; private set; }

		internal IEnumerable<Elastic.Clients.Elasticsearch.QueryDsl.FunctionScoreContainer>? FunctionsValue { get; private set; }

		internal double? MaxBoostValue { get; private set; }

		internal double? MinScoreValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? QueryValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.FunctionScoreMode? ScoreModeValue { get; private set; }

		internal QueryContainerDescriptor QueryDescriptor { get; private set; }

		internal Action<QueryContainerDescriptor> QueryDescriptorAction { get; private set; }

		public FunctionScoreQueryDescriptor BoostMode(Elastic.Clients.Elasticsearch.QueryDsl.FunctionBoostMode? boostMode) => Assign(boostMode, (a, v) => a.BoostModeValue = v);
		public FunctionScoreQueryDescriptor Functions(IEnumerable<Elastic.Clients.Elasticsearch.QueryDsl.FunctionScoreContainer>? functions) => Assign(functions, (a, v) => a.FunctionsValue = v);
		public FunctionScoreQueryDescriptor MaxBoost(double? maxBoost) => Assign(maxBoost, (a, v) => a.MaxBoostValue = v);
		public FunctionScoreQueryDescriptor MinScore(double? minScore) => Assign(minScore, (a, v) => a.MinScoreValue = v);
		public FunctionScoreQueryDescriptor Query(Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? query)
		{
			QueryDescriptor = null;
			QueryDescriptorAction = null;
			return Assign(query, (a, v) => a.QueryValue = v);
		}

		public FunctionScoreQueryDescriptor Query(Elastic.Clients.Elasticsearch.QueryDsl.QueryContainerDescriptor descriptor)
		{
			QueryValue = null;
			QueryDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.QueryDescriptor = v);
		}

		public FunctionScoreQueryDescriptor Query(Action<Elastic.Clients.Elasticsearch.QueryDsl.QueryContainerDescriptor> configure)
		{
			QueryValue = null;
			QueryDescriptorAction = null;
			return Assign(configure, (a, v) => a.QueryDescriptorAction = v);
		}

		public FunctionScoreQueryDescriptor ScoreMode(Elastic.Clients.Elasticsearch.QueryDsl.FunctionScoreMode? scoreMode) => Assign(scoreMode, (a, v) => a.ScoreModeValue = v);
	}

	internal sealed class FunctionScoreQueryDescriptorConverter : JsonConverter<FunctionScoreQueryDescriptor>
	{
		public override FunctionScoreQueryDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, FunctionScoreQueryDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value.BoostModeValue is not null)
			{
				writer.WritePropertyName("boost_mode");
				JsonSerializer.Serialize(writer, value.BoostModeValue, options);
			}

			if (value.FunctionsValue is not null)
			{
				writer.WritePropertyName("functions");
				JsonSerializer.Serialize(writer, value.FunctionsValue, options);
			}

			if (value.MaxBoostValue.HasValue)
			{
				writer.WritePropertyName("max_boost");
				writer.WriteNumberValue(value.MaxBoostValue.Value);
			}

			if (value.MinScoreValue.HasValue)
			{
				writer.WritePropertyName("min_score");
				writer.WriteNumberValue(value.MinScoreValue.Value);
			}

			if (value.QueryDescriptor is not null)
			{
				writer.WritePropertyName("query");
				JsonSerializer.Serialize(writer, value.QueryDescriptor, options);
			}
			else if (value.QueryDescriptorAction is not null)
			{
				writer.WritePropertyName("query");
				JsonSerializer.Serialize(writer, new QueryContainerDescriptor(value.QueryDescriptorAction), options);
			}
			else if (value.QueryValue is not null)
			{
				writer.WritePropertyName("query");
				JsonSerializer.Serialize(writer, value.QueryValue, options);
			}

			if (value.ScoreModeValue is not null)
			{
				writer.WritePropertyName("score_mode");
				JsonSerializer.Serialize(writer, value.ScoreModeValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class FuzzyQuery : FieldNameQueryBase, IQueryContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "fuzzy";
		[JsonInclude]
		[JsonPropertyName("max_expansions")]
		public int? MaxExpansions { get; set; }

		[JsonInclude]
		[JsonPropertyName("prefix_length")]
		public int? PrefixLength { get; set; }

		[JsonInclude]
		[JsonPropertyName("rewrite")]
		public string? Rewrite { get; set; }

		[JsonInclude]
		[JsonPropertyName("transpositions")]
		public bool? Transpositions { get; set; }

		[JsonInclude]
		[JsonPropertyName("fuzziness")]
		public Elastic.Clients.Elasticsearch.Fuzziness? Fuzziness { get; set; }

		[JsonInclude]
		[JsonPropertyName("value")]
		public object Value { get; set; }
	}

	[JsonConverter(typeof(FuzzyQueryDescriptorConverter))]
	public sealed partial class FuzzyQueryDescriptor : DescriptorBase<FuzzyQueryDescriptor>, IQueryContainerVariantDescriptor
	{
		public FuzzyQueryDescriptor()
		{
		}

		internal FuzzyQueryDescriptor(Action<FuzzyQueryDescriptor> configure) => configure.Invoke(this);
		internal int? MaxExpansionsValue { get; private set; }

		internal int? PrefixLengthValue { get; private set; }

		internal string? RewriteValue { get; private set; }

		internal bool? TranspositionsValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Fuzziness? FuzzinessValue { get; private set; }

		internal object ValueValue { get; private set; }

		public FuzzyQueryDescriptor MaxExpansions(int? maxExpansions) => Assign(maxExpansions, (a, v) => a.MaxExpansionsValue = v);
		public FuzzyQueryDescriptor PrefixLength(int? prefixLength) => Assign(prefixLength, (a, v) => a.PrefixLengthValue = v);
		public FuzzyQueryDescriptor Rewrite(string? rewrite) => Assign(rewrite, (a, v) => a.RewriteValue = v);
		public FuzzyQueryDescriptor Transpositions(bool? transpositions = true) => Assign(transpositions, (a, v) => a.TranspositionsValue = v);
		public FuzzyQueryDescriptor Fuzziness(Elastic.Clients.Elasticsearch.Fuzziness? fuzziness) => Assign(fuzziness, (a, v) => a.FuzzinessValue = v);
		public FuzzyQueryDescriptor Value(object value) => Assign(value, (a, v) => a.ValueValue = v);
	}

	internal sealed class FuzzyQueryDescriptorConverter : JsonConverter<FuzzyQueryDescriptor>
	{
		public override FuzzyQueryDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, FuzzyQueryDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value.MaxExpansionsValue.HasValue)
			{
				writer.WritePropertyName("max_expansions");
				writer.WriteNumberValue(value.MaxExpansionsValue.Value);
			}

			if (value.PrefixLengthValue.HasValue)
			{
				writer.WritePropertyName("prefix_length");
				writer.WriteNumberValue(value.PrefixLengthValue.Value);
			}

			if (value.RewriteValue is not null)
			{
				writer.WritePropertyName("rewrite");
				JsonSerializer.Serialize(writer, value.RewriteValue, options);
			}

			if (value.TranspositionsValue.HasValue)
			{
				writer.WritePropertyName("transpositions");
				writer.WriteBooleanValue(value.TranspositionsValue.Value);
			}

			if (value.FuzzinessValue is not null)
			{
				writer.WritePropertyName("fuzziness");
				JsonSerializer.Serialize(writer, value.FuzzinessValue, options);
			}

			writer.WritePropertyName("value");
			JsonSerializer.Serialize(writer, value.ValueValue, options);
			writer.WriteEndObject();
		}
	}

	public partial class GeoBoundingBoxQuery : QueryDsl.QueryBase, IQueryContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "geo_bounding_box";
		[JsonInclude]
		[JsonPropertyName("validation_method")]
		public Elastic.Clients.Elasticsearch.QueryDsl.GeoValidationMethod? ValidationMethod { get; set; }

		[JsonInclude]
		[JsonPropertyName("ignore_unmapped")]
		public bool? IgnoreUnmapped { get; set; }
	}

	[JsonConverter(typeof(GeoBoundingBoxQueryDescriptorConverter))]
	public sealed partial class GeoBoundingBoxQueryDescriptor : DescriptorBase<GeoBoundingBoxQueryDescriptor>, IQueryContainerVariantDescriptor
	{
		public GeoBoundingBoxQueryDescriptor()
		{
		}

		internal GeoBoundingBoxQueryDescriptor(Action<GeoBoundingBoxQueryDescriptor> configure) => configure.Invoke(this);
		internal Elastic.Clients.Elasticsearch.QueryDsl.GeoValidationMethod? ValidationMethodValue { get; private set; }

		internal bool? IgnoreUnmappedValue { get; private set; }

		public GeoBoundingBoxQueryDescriptor ValidationMethod(Elastic.Clients.Elasticsearch.QueryDsl.GeoValidationMethod? validationMethod) => Assign(validationMethod, (a, v) => a.ValidationMethodValue = v);
		public GeoBoundingBoxQueryDescriptor IgnoreUnmapped(bool? ignoreUnmapped = true) => Assign(ignoreUnmapped, (a, v) => a.IgnoreUnmappedValue = v);
	}

	internal sealed class GeoBoundingBoxQueryDescriptorConverter : JsonConverter<GeoBoundingBoxQueryDescriptor>
	{
		public override GeoBoundingBoxQueryDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, GeoBoundingBoxQueryDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value.ValidationMethodValue is not null)
			{
				writer.WritePropertyName("validation_method");
				JsonSerializer.Serialize(writer, value.ValidationMethodValue, options);
			}

			if (value.IgnoreUnmappedValue.HasValue)
			{
				writer.WritePropertyName("ignore_unmapped");
				writer.WriteBooleanValue(value.IgnoreUnmappedValue.Value);
			}

			writer.WriteEndObject();
		}
	}

	public partial class GeoDistanceQuery : QueryDsl.QueryBase, IQueryContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "geo_distance";
		[JsonInclude]
		[JsonPropertyName("distance")]
		public string? Distance { get; set; }

		[JsonInclude]
		[JsonPropertyName("distance_type")]
		public Elastic.Clients.Elasticsearch.GeoDistanceType? DistanceType { get; set; }

		[JsonInclude]
		[JsonPropertyName("validation_method")]
		public Elastic.Clients.Elasticsearch.QueryDsl.GeoValidationMethod? ValidationMethod { get; set; }
	}

	[JsonConverter(typeof(GeoDistanceQueryDescriptorConverter))]
	public sealed partial class GeoDistanceQueryDescriptor : DescriptorBase<GeoDistanceQueryDescriptor>, IQueryContainerVariantDescriptor
	{
		public GeoDistanceQueryDescriptor()
		{
		}

		internal GeoDistanceQueryDescriptor(Action<GeoDistanceQueryDescriptor> configure) => configure.Invoke(this);
		internal string? DistanceValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.GeoDistanceType? DistanceTypeValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.GeoValidationMethod? ValidationMethodValue { get; private set; }

		public GeoDistanceQueryDescriptor Distance(string? distance) => Assign(distance, (a, v) => a.DistanceValue = v);
		public GeoDistanceQueryDescriptor DistanceType(Elastic.Clients.Elasticsearch.GeoDistanceType? distanceType) => Assign(distanceType, (a, v) => a.DistanceTypeValue = v);
		public GeoDistanceQueryDescriptor ValidationMethod(Elastic.Clients.Elasticsearch.QueryDsl.GeoValidationMethod? validationMethod) => Assign(validationMethod, (a, v) => a.ValidationMethodValue = v);
	}

	internal sealed class GeoDistanceQueryDescriptorConverter : JsonConverter<GeoDistanceQueryDescriptor>
	{
		public override GeoDistanceQueryDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, GeoDistanceQueryDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value.DistanceValue is not null)
			{
				writer.WritePropertyName("distance");
				JsonSerializer.Serialize(writer, value.DistanceValue, options);
			}

			if (value.DistanceTypeValue is not null)
			{
				writer.WritePropertyName("distance_type");
				JsonSerializer.Serialize(writer, value.DistanceTypeValue, options);
			}

			if (value.ValidationMethodValue is not null)
			{
				writer.WritePropertyName("validation_method");
				JsonSerializer.Serialize(writer, value.ValidationMethodValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class GeoPolygonQuery : QueryDsl.QueryBase, IQueryContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "geo_polygon";
		[JsonInclude]
		[JsonPropertyName("validation_method")]
		public Elastic.Clients.Elasticsearch.QueryDsl.GeoValidationMethod? ValidationMethod { get; set; }

		[JsonInclude]
		[JsonPropertyName("ignore_unmapped")]
		public bool? IgnoreUnmapped { get; set; }
	}

	[JsonConverter(typeof(GeoPolygonQueryDescriptorConverter))]
	public sealed partial class GeoPolygonQueryDescriptor : DescriptorBase<GeoPolygonQueryDescriptor>, IQueryContainerVariantDescriptor
	{
		public GeoPolygonQueryDescriptor()
		{
		}

		internal GeoPolygonQueryDescriptor(Action<GeoPolygonQueryDescriptor> configure) => configure.Invoke(this);
		internal Elastic.Clients.Elasticsearch.QueryDsl.GeoValidationMethod? ValidationMethodValue { get; private set; }

		internal bool? IgnoreUnmappedValue { get; private set; }

		public GeoPolygonQueryDescriptor ValidationMethod(Elastic.Clients.Elasticsearch.QueryDsl.GeoValidationMethod? validationMethod) => Assign(validationMethod, (a, v) => a.ValidationMethodValue = v);
		public GeoPolygonQueryDescriptor IgnoreUnmapped(bool? ignoreUnmapped = true) => Assign(ignoreUnmapped, (a, v) => a.IgnoreUnmappedValue = v);
	}

	internal sealed class GeoPolygonQueryDescriptorConverter : JsonConverter<GeoPolygonQueryDescriptor>
	{
		public override GeoPolygonQueryDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, GeoPolygonQueryDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value.ValidationMethodValue is not null)
			{
				writer.WritePropertyName("validation_method");
				JsonSerializer.Serialize(writer, value.ValidationMethodValue, options);
			}

			if (value.IgnoreUnmappedValue.HasValue)
			{
				writer.WritePropertyName("ignore_unmapped");
				writer.WriteBooleanValue(value.IgnoreUnmappedValue.Value);
			}

			writer.WriteEndObject();
		}
	}

	public partial class GeoShapeQuery : QueryDsl.QueryBase, IQueryContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "geo_shape";
		[JsonInclude]
		[JsonPropertyName("ignore_unmapped")]
		public bool? IgnoreUnmapped { get; set; }
	}

	[JsonConverter(typeof(GeoShapeQueryDescriptorConverter))]
	public sealed partial class GeoShapeQueryDescriptor : DescriptorBase<GeoShapeQueryDescriptor>, IQueryContainerVariantDescriptor
	{
		public GeoShapeQueryDescriptor()
		{
		}

		internal GeoShapeQueryDescriptor(Action<GeoShapeQueryDescriptor> configure) => configure.Invoke(this);
		internal bool? IgnoreUnmappedValue { get; private set; }

		public GeoShapeQueryDescriptor IgnoreUnmapped(bool? ignoreUnmapped = true) => Assign(ignoreUnmapped, (a, v) => a.IgnoreUnmappedValue = v);
	}

	internal sealed class GeoShapeQueryDescriptorConverter : JsonConverter<GeoShapeQueryDescriptor>
	{
		public override GeoShapeQueryDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, GeoShapeQueryDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value.IgnoreUnmappedValue.HasValue)
			{
				writer.WritePropertyName("ignore_unmapped");
				writer.WriteBooleanValue(value.IgnoreUnmappedValue.Value);
			}

			writer.WriteEndObject();
		}
	}

	public partial class HasChildQuery : QueryDsl.QueryBase, IQueryContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "has_child";
		[JsonInclude]
		[JsonPropertyName("ignore_unmapped")]
		public bool? IgnoreUnmapped { get; set; }

		[JsonInclude]
		[JsonPropertyName("inner_hits")]
		public Elastic.Clients.Elasticsearch.InnerHits? InnerHits { get; set; }

		[JsonInclude]
		[JsonPropertyName("max_children")]
		public int? MaxChildren { get; set; }

		[JsonInclude]
		[JsonPropertyName("min_children")]
		public int? MinChildren { get; set; }

		[JsonInclude]
		[JsonPropertyName("query")]
		public Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer Query { get; set; }

		[JsonInclude]
		[JsonPropertyName("score_mode")]
		public Elastic.Clients.Elasticsearch.QueryDsl.ChildScoreMode? ScoreMode { get; set; }

		[JsonInclude]
		[JsonPropertyName("type")]
		public string Type { get; set; }
	}

	[JsonConverter(typeof(HasChildQueryDescriptorConverter))]
	public sealed partial class HasChildQueryDescriptor : DescriptorBase<HasChildQueryDescriptor>, IQueryContainerVariantDescriptor
	{
		public HasChildQueryDescriptor()
		{
		}

		internal HasChildQueryDescriptor(Action<HasChildQueryDescriptor> configure) => configure.Invoke(this);
		internal bool? IgnoreUnmappedValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.InnerHits? InnerHitsValue { get; private set; }

		internal int? MaxChildrenValue { get; private set; }

		internal int? MinChildrenValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer QueryValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.ChildScoreMode? ScoreModeValue { get; private set; }

		internal string TypeValue { get; private set; }

		internal InnerHitsDescriptor InnerHitsDescriptor { get; private set; }

		internal QueryContainerDescriptor QueryDescriptor { get; private set; }

		internal Action<InnerHitsDescriptor> InnerHitsDescriptorAction { get; private set; }

		internal Action<QueryContainerDescriptor> QueryDescriptorAction { get; private set; }

		public HasChildQueryDescriptor IgnoreUnmapped(bool? ignoreUnmapped = true) => Assign(ignoreUnmapped, (a, v) => a.IgnoreUnmappedValue = v);
		public HasChildQueryDescriptor InnerHits(Elastic.Clients.Elasticsearch.InnerHits? innerHits)
		{
			InnerHitsDescriptor = null;
			InnerHitsDescriptorAction = null;
			return Assign(innerHits, (a, v) => a.InnerHitsValue = v);
		}

		public HasChildQueryDescriptor InnerHits(Elastic.Clients.Elasticsearch.InnerHitsDescriptor descriptor)
		{
			InnerHitsValue = null;
			InnerHitsDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.InnerHitsDescriptor = v);
		}

		public HasChildQueryDescriptor InnerHits(Action<Elastic.Clients.Elasticsearch.InnerHitsDescriptor> configure)
		{
			InnerHitsValue = null;
			InnerHitsDescriptorAction = null;
			return Assign(configure, (a, v) => a.InnerHitsDescriptorAction = v);
		}

		public HasChildQueryDescriptor MaxChildren(int? maxChildren) => Assign(maxChildren, (a, v) => a.MaxChildrenValue = v);
		public HasChildQueryDescriptor MinChildren(int? minChildren) => Assign(minChildren, (a, v) => a.MinChildrenValue = v);
		public HasChildQueryDescriptor Query(Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer query)
		{
			QueryDescriptor = null;
			QueryDescriptorAction = null;
			return Assign(query, (a, v) => a.QueryValue = v);
		}

		public HasChildQueryDescriptor Query(Elastic.Clients.Elasticsearch.QueryDsl.QueryContainerDescriptor descriptor)
		{
			QueryValue = null;
			QueryDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.QueryDescriptor = v);
		}

		public HasChildQueryDescriptor Query(Action<Elastic.Clients.Elasticsearch.QueryDsl.QueryContainerDescriptor> configure)
		{
			QueryValue = null;
			QueryDescriptorAction = null;
			return Assign(configure, (a, v) => a.QueryDescriptorAction = v);
		}

		public HasChildQueryDescriptor ScoreMode(Elastic.Clients.Elasticsearch.QueryDsl.ChildScoreMode? scoreMode) => Assign(scoreMode, (a, v) => a.ScoreModeValue = v);
		public HasChildQueryDescriptor Type(string type) => Assign(type, (a, v) => a.TypeValue = v);
	}

	internal sealed class HasChildQueryDescriptorConverter : JsonConverter<HasChildQueryDescriptor>
	{
		public override HasChildQueryDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, HasChildQueryDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value.IgnoreUnmappedValue.HasValue)
			{
				writer.WritePropertyName("ignore_unmapped");
				writer.WriteBooleanValue(value.IgnoreUnmappedValue.Value);
			}

			if (value.InnerHitsDescriptor is not null)
			{
				writer.WritePropertyName("inner_hits");
				JsonSerializer.Serialize(writer, value.InnerHitsDescriptor, options);
			}
			else if (value.InnerHitsDescriptorAction is not null)
			{
				writer.WritePropertyName("inner_hits");
				JsonSerializer.Serialize(writer, new InnerHitsDescriptor(value.InnerHitsDescriptorAction), options);
			}
			else if (value.InnerHitsValue is not null)
			{
				writer.WritePropertyName("inner_hits");
				JsonSerializer.Serialize(writer, value.InnerHitsValue, options);
			}

			if (value.MaxChildrenValue.HasValue)
			{
				writer.WritePropertyName("max_children");
				writer.WriteNumberValue(value.MaxChildrenValue.Value);
			}

			if (value.MinChildrenValue.HasValue)
			{
				writer.WritePropertyName("min_children");
				writer.WriteNumberValue(value.MinChildrenValue.Value);
			}

			if (value.QueryDescriptor is not null)
			{
				writer.WritePropertyName("query");
				JsonSerializer.Serialize(writer, value.QueryDescriptor, options);
			}
			else if (value.QueryDescriptorAction is not null)
			{
				writer.WritePropertyName("query");
				JsonSerializer.Serialize(writer, new QueryContainerDescriptor(value.QueryDescriptorAction), options);
			}
			else
			{
				writer.WritePropertyName("query");
				JsonSerializer.Serialize(writer, value.QueryValue, options);
			}

			if (value.ScoreModeValue is not null)
			{
				writer.WritePropertyName("score_mode");
				JsonSerializer.Serialize(writer, value.ScoreModeValue, options);
			}

			writer.WritePropertyName("type");
			JsonSerializer.Serialize(writer, value.TypeValue, options);
			writer.WriteEndObject();
		}
	}

	public partial class HasParentQuery : QueryDsl.QueryBase, IQueryContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "has_parent";
		[JsonInclude]
		[JsonPropertyName("ignore_unmapped")]
		public bool? IgnoreUnmapped { get; set; }

		[JsonInclude]
		[JsonPropertyName("inner_hits")]
		public Elastic.Clients.Elasticsearch.InnerHits? InnerHits { get; set; }

		[JsonInclude]
		[JsonPropertyName("parent_type")]
		public string ParentType { get; set; }

		[JsonInclude]
		[JsonPropertyName("query")]
		public Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer Query { get; set; }

		[JsonInclude]
		[JsonPropertyName("score")]
		public bool? Score { get; set; }
	}

	[JsonConverter(typeof(HasParentQueryDescriptorConverter))]
	public sealed partial class HasParentQueryDescriptor : DescriptorBase<HasParentQueryDescriptor>, IQueryContainerVariantDescriptor
	{
		public HasParentQueryDescriptor()
		{
		}

		internal HasParentQueryDescriptor(Action<HasParentQueryDescriptor> configure) => configure.Invoke(this);
		internal bool? IgnoreUnmappedValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.InnerHits? InnerHitsValue { get; private set; }

		internal string ParentTypeValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer QueryValue { get; private set; }

		internal bool? ScoreValue { get; private set; }

		internal InnerHitsDescriptor InnerHitsDescriptor { get; private set; }

		internal QueryContainerDescriptor QueryDescriptor { get; private set; }

		internal Action<InnerHitsDescriptor> InnerHitsDescriptorAction { get; private set; }

		internal Action<QueryContainerDescriptor> QueryDescriptorAction { get; private set; }

		public HasParentQueryDescriptor IgnoreUnmapped(bool? ignoreUnmapped = true) => Assign(ignoreUnmapped, (a, v) => a.IgnoreUnmappedValue = v);
		public HasParentQueryDescriptor InnerHits(Elastic.Clients.Elasticsearch.InnerHits? innerHits)
		{
			InnerHitsDescriptor = null;
			InnerHitsDescriptorAction = null;
			return Assign(innerHits, (a, v) => a.InnerHitsValue = v);
		}

		public HasParentQueryDescriptor InnerHits(Elastic.Clients.Elasticsearch.InnerHitsDescriptor descriptor)
		{
			InnerHitsValue = null;
			InnerHitsDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.InnerHitsDescriptor = v);
		}

		public HasParentQueryDescriptor InnerHits(Action<Elastic.Clients.Elasticsearch.InnerHitsDescriptor> configure)
		{
			InnerHitsValue = null;
			InnerHitsDescriptorAction = null;
			return Assign(configure, (a, v) => a.InnerHitsDescriptorAction = v);
		}

		public HasParentQueryDescriptor ParentType(string parentType) => Assign(parentType, (a, v) => a.ParentTypeValue = v);
		public HasParentQueryDescriptor Query(Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer query)
		{
			QueryDescriptor = null;
			QueryDescriptorAction = null;
			return Assign(query, (a, v) => a.QueryValue = v);
		}

		public HasParentQueryDescriptor Query(Elastic.Clients.Elasticsearch.QueryDsl.QueryContainerDescriptor descriptor)
		{
			QueryValue = null;
			QueryDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.QueryDescriptor = v);
		}

		public HasParentQueryDescriptor Query(Action<Elastic.Clients.Elasticsearch.QueryDsl.QueryContainerDescriptor> configure)
		{
			QueryValue = null;
			QueryDescriptorAction = null;
			return Assign(configure, (a, v) => a.QueryDescriptorAction = v);
		}

		public HasParentQueryDescriptor Score(bool? score = true) => Assign(score, (a, v) => a.ScoreValue = v);
	}

	internal sealed class HasParentQueryDescriptorConverter : JsonConverter<HasParentQueryDescriptor>
	{
		public override HasParentQueryDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, HasParentQueryDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value.IgnoreUnmappedValue.HasValue)
			{
				writer.WritePropertyName("ignore_unmapped");
				writer.WriteBooleanValue(value.IgnoreUnmappedValue.Value);
			}

			if (value.InnerHitsDescriptor is not null)
			{
				writer.WritePropertyName("inner_hits");
				JsonSerializer.Serialize(writer, value.InnerHitsDescriptor, options);
			}
			else if (value.InnerHitsDescriptorAction is not null)
			{
				writer.WritePropertyName("inner_hits");
				JsonSerializer.Serialize(writer, new InnerHitsDescriptor(value.InnerHitsDescriptorAction), options);
			}
			else if (value.InnerHitsValue is not null)
			{
				writer.WritePropertyName("inner_hits");
				JsonSerializer.Serialize(writer, value.InnerHitsValue, options);
			}

			writer.WritePropertyName("parent_type");
			JsonSerializer.Serialize(writer, value.ParentTypeValue, options);
			if (value.QueryDescriptor is not null)
			{
				writer.WritePropertyName("query");
				JsonSerializer.Serialize(writer, value.QueryDescriptor, options);
			}
			else if (value.QueryDescriptorAction is not null)
			{
				writer.WritePropertyName("query");
				JsonSerializer.Serialize(writer, new QueryContainerDescriptor(value.QueryDescriptorAction), options);
			}
			else
			{
				writer.WritePropertyName("query");
				JsonSerializer.Serialize(writer, value.QueryValue, options);
			}

			if (value.ScoreValue.HasValue)
			{
				writer.WritePropertyName("score");
				writer.WriteBooleanValue(value.ScoreValue.Value);
			}

			writer.WriteEndObject();
		}
	}

	public partial class IdsQuery : QueryDsl.QueryBase, IQueryContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "ids";
		[JsonInclude]
		[JsonPropertyName("values")]
		public Elastic.Clients.Elasticsearch.Ids? Values { get; set; }
	}

	[JsonConverter(typeof(IdsQueryDescriptorConverter))]
	public sealed partial class IdsQueryDescriptor : DescriptorBase<IdsQueryDescriptor>, IQueryContainerVariantDescriptor
	{
		public IdsQueryDescriptor()
		{
		}

		internal IdsQueryDescriptor(Action<IdsQueryDescriptor> configure) => configure.Invoke(this);
		internal Elastic.Clients.Elasticsearch.Ids? ValuesValue { get; private set; }

		public IdsQueryDescriptor Values(Elastic.Clients.Elasticsearch.Ids? values) => Assign(values, (a, v) => a.ValuesValue = v);
	}

	internal sealed class IdsQueryDescriptorConverter : JsonConverter<IdsQueryDescriptor>
	{
		public override IdsQueryDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, IdsQueryDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value.ValuesValue is not null)
			{
				writer.WritePropertyName("values");
				JsonSerializer.Serialize(writer, value.ValuesValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class IntervalsAllOf : IIntervalsContainerVariant, IIntervalsQueryVariant
	{
		[JsonIgnore]
		string QueryDsl.IIntervalsContainerVariant.IntervalsContainerVariantName => "all_of";
		[JsonIgnore]
		string QueryDsl.IIntervalsQueryVariant.IntervalsQueryVariantName => "all_of";
		[JsonInclude]
		[JsonPropertyName("intervals")]
		public IEnumerable<Elastic.Clients.Elasticsearch.QueryDsl.IntervalsContainer> Intervals { get; set; }

		[JsonInclude]
		[JsonPropertyName("max_gaps")]
		public int? MaxGaps { get; set; }

		[JsonInclude]
		[JsonPropertyName("ordered")]
		public bool? Ordered { get; set; }

		[JsonInclude]
		[JsonPropertyName("filter")]
		public Elastic.Clients.Elasticsearch.QueryDsl.IntervalsFilter? Filter { get; set; }
	}

	[JsonConverter(typeof(IntervalsAllOfDescriptorConverter))]
	public sealed partial class IntervalsAllOfDescriptor : DescriptorBase<IntervalsAllOfDescriptor>, IIntervalsContainerVariantDescriptor, IIntervalsQueryVariantDescriptor
	{
		public IntervalsAllOfDescriptor()
		{
		}

		internal IntervalsAllOfDescriptor(Action<IntervalsAllOfDescriptor> configure) => configure.Invoke(this);
		internal IEnumerable<Elastic.Clients.Elasticsearch.QueryDsl.IntervalsContainer> IntervalsValue { get; private set; }

		internal int? MaxGapsValue { get; private set; }

		internal bool? OrderedValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.IntervalsFilter? FilterValue { get; private set; }

		internal IntervalsFilterDescriptor FilterDescriptor { get; private set; }

		internal Action<IntervalsFilterDescriptor> FilterDescriptorAction { get; private set; }

		public IntervalsAllOfDescriptor Intervals(IEnumerable<Elastic.Clients.Elasticsearch.QueryDsl.IntervalsContainer> intervals) => Assign(intervals, (a, v) => a.IntervalsValue = v);
		public IntervalsAllOfDescriptor MaxGaps(int? maxGaps) => Assign(maxGaps, (a, v) => a.MaxGapsValue = v);
		public IntervalsAllOfDescriptor Ordered(bool? ordered = true) => Assign(ordered, (a, v) => a.OrderedValue = v);
		public IntervalsAllOfDescriptor Filter(Elastic.Clients.Elasticsearch.QueryDsl.IntervalsFilter? filter)
		{
			FilterDescriptor = null;
			FilterDescriptorAction = null;
			return Assign(filter, (a, v) => a.FilterValue = v);
		}

		public IntervalsAllOfDescriptor Filter(Elastic.Clients.Elasticsearch.QueryDsl.IntervalsFilterDescriptor descriptor)
		{
			FilterValue = null;
			FilterDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.FilterDescriptor = v);
		}

		public IntervalsAllOfDescriptor Filter(Action<Elastic.Clients.Elasticsearch.QueryDsl.IntervalsFilterDescriptor> configure)
		{
			FilterValue = null;
			FilterDescriptorAction = null;
			return Assign(configure, (a, v) => a.FilterDescriptorAction = v);
		}
	}

	internal sealed class IntervalsAllOfDescriptorConverter : JsonConverter<IntervalsAllOfDescriptor>
	{
		public override IntervalsAllOfDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, IntervalsAllOfDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("intervals");
			JsonSerializer.Serialize(writer, value.IntervalsValue, options);
			if (value.MaxGapsValue.HasValue)
			{
				writer.WritePropertyName("max_gaps");
				writer.WriteNumberValue(value.MaxGapsValue.Value);
			}

			if (value.OrderedValue.HasValue)
			{
				writer.WritePropertyName("ordered");
				writer.WriteBooleanValue(value.OrderedValue.Value);
			}

			if (value.FilterDescriptor is not null)
			{
				writer.WritePropertyName("filter");
				JsonSerializer.Serialize(writer, value.FilterDescriptor, options);
			}
			else if (value.FilterDescriptorAction is not null)
			{
				writer.WritePropertyName("filter");
				JsonSerializer.Serialize(writer, new IntervalsFilterDescriptor(value.FilterDescriptorAction), options);
			}
			else if (value.FilterValue is not null)
			{
				writer.WritePropertyName("filter");
				JsonSerializer.Serialize(writer, value.FilterValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class IntervalsAnyOf : IIntervalsContainerVariant, IIntervalsQueryVariant
	{
		[JsonIgnore]
		string QueryDsl.IIntervalsContainerVariant.IntervalsContainerVariantName => "any_of";
		[JsonIgnore]
		string QueryDsl.IIntervalsQueryVariant.IntervalsQueryVariantName => "any_of";
		[JsonInclude]
		[JsonPropertyName("intervals")]
		public IEnumerable<Elastic.Clients.Elasticsearch.QueryDsl.IntervalsContainer> Intervals { get; set; }

		[JsonInclude]
		[JsonPropertyName("filter")]
		public Elastic.Clients.Elasticsearch.QueryDsl.IntervalsFilter? Filter { get; set; }
	}

	[JsonConverter(typeof(IntervalsAnyOfDescriptorConverter))]
	public sealed partial class IntervalsAnyOfDescriptor : DescriptorBase<IntervalsAnyOfDescriptor>, IIntervalsContainerVariantDescriptor, IIntervalsQueryVariantDescriptor
	{
		public IntervalsAnyOfDescriptor()
		{
		}

		internal IntervalsAnyOfDescriptor(Action<IntervalsAnyOfDescriptor> configure) => configure.Invoke(this);
		internal IEnumerable<Elastic.Clients.Elasticsearch.QueryDsl.IntervalsContainer> IntervalsValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.IntervalsFilter? FilterValue { get; private set; }

		internal IntervalsFilterDescriptor FilterDescriptor { get; private set; }

		internal Action<IntervalsFilterDescriptor> FilterDescriptorAction { get; private set; }

		public IntervalsAnyOfDescriptor Intervals(IEnumerable<Elastic.Clients.Elasticsearch.QueryDsl.IntervalsContainer> intervals) => Assign(intervals, (a, v) => a.IntervalsValue = v);
		public IntervalsAnyOfDescriptor Filter(Elastic.Clients.Elasticsearch.QueryDsl.IntervalsFilter? filter)
		{
			FilterDescriptor = null;
			FilterDescriptorAction = null;
			return Assign(filter, (a, v) => a.FilterValue = v);
		}

		public IntervalsAnyOfDescriptor Filter(Elastic.Clients.Elasticsearch.QueryDsl.IntervalsFilterDescriptor descriptor)
		{
			FilterValue = null;
			FilterDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.FilterDescriptor = v);
		}

		public IntervalsAnyOfDescriptor Filter(Action<Elastic.Clients.Elasticsearch.QueryDsl.IntervalsFilterDescriptor> configure)
		{
			FilterValue = null;
			FilterDescriptorAction = null;
			return Assign(configure, (a, v) => a.FilterDescriptorAction = v);
		}
	}

	internal sealed class IntervalsAnyOfDescriptorConverter : JsonConverter<IntervalsAnyOfDescriptor>
	{
		public override IntervalsAnyOfDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, IntervalsAnyOfDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("intervals");
			JsonSerializer.Serialize(writer, value.IntervalsValue, options);
			if (value.FilterDescriptor is not null)
			{
				writer.WritePropertyName("filter");
				JsonSerializer.Serialize(writer, value.FilterDescriptor, options);
			}
			else if (value.FilterDescriptorAction is not null)
			{
				writer.WritePropertyName("filter");
				JsonSerializer.Serialize(writer, new IntervalsFilterDescriptor(value.FilterDescriptorAction), options);
			}
			else if (value.FilterValue is not null)
			{
				writer.WritePropertyName("filter");
				JsonSerializer.Serialize(writer, value.FilterValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public interface IIntervalsContainerVariant
	{
		string IntervalsContainerVariantName { get; }
	}

	internal interface IIntervalsContainerVariantDescriptor
	{
	}

	[JsonConverter(typeof(IntervalsContainerConverter))]
	public partial class IntervalsContainer : IContainer
	{
		public IntervalsContainer(IIntervalsContainerVariant variant) => Variant = variant ?? throw new ArgumentNullException(nameof(variant));
		internal IIntervalsContainerVariant Variant { get; }
	}

	internal sealed class IntervalsContainerConverter : JsonConverter<IntervalsContainer>
	{
		public override IntervalsContainer Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			reader.Read();
			if (reader.TokenType != JsonTokenType.PropertyName)
			{
				throw new JsonException();
			}

			var propertyName = reader.GetString();
			if (propertyName == "all_of")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.IntervalsAllOf?>(ref reader, options);
				reader.Read();
				return new IntervalsContainer(variant);
			}

			if (propertyName == "any_of")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.IntervalsAnyOf?>(ref reader, options);
				reader.Read();
				return new IntervalsContainer(variant);
			}

			if (propertyName == "fuzzy")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.IntervalsFuzzy?>(ref reader, options);
				reader.Read();
				return new IntervalsContainer(variant);
			}

			if (propertyName == "match")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.IntervalsMatch?>(ref reader, options);
				reader.Read();
				return new IntervalsContainer(variant);
			}

			if (propertyName == "prefix")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.IntervalsPrefix?>(ref reader, options);
				reader.Read();
				return new IntervalsContainer(variant);
			}

			if (propertyName == "wildcard")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.IntervalsWildcard?>(ref reader, options);
				reader.Read();
				return new IntervalsContainer(variant);
			}

			throw new JsonException();
		}

		public override void Write(Utf8JsonWriter writer, IntervalsContainer value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName(value.Variant.IntervalsContainerVariantName);
			switch (value.Variant)
			{
				case Elastic.Clients.Elasticsearch.QueryDsl.IntervalsAllOf variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.IntervalsAnyOf variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.IntervalsFuzzy variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.IntervalsMatch variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.IntervalsPrefix variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.IntervalsWildcard variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
			}

			writer.WriteEndObject();
		}
	}

	public sealed partial class IntervalsContainerDescriptor : DescriptorBase<IntervalsContainerDescriptor>
	{
		public IntervalsContainerDescriptor()
		{
		}

		internal IntervalsContainerDescriptor(Action<IntervalsContainerDescriptor> configure) => configure.Invoke(this);
	}

	internal sealed class IntervalsContainerDescriptorConverter : JsonConverter<IntervalsContainerDescriptor>
	{
		public override IntervalsContainerDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, IntervalsContainerDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WriteEndObject();
		}
	}

	public interface IIntervalsFilterVariant
	{
		string IntervalsFilterVariantName { get; }
	}

	internal interface IIntervalsFilterVariantDescriptor
	{
	}

	[JsonConverter(typeof(IntervalsFilterConverter))]
	public partial class IntervalsFilter : IContainer
	{
		public IntervalsFilter(IIntervalsFilterVariant variant) => Variant = variant ?? throw new ArgumentNullException(nameof(variant));
		internal IIntervalsFilterVariant Variant { get; }
	}

	internal sealed class IntervalsFilterConverter : JsonConverter<IntervalsFilter>
	{
		public override IntervalsFilter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			reader.Read();
			if (reader.TokenType != JsonTokenType.PropertyName)
			{
				throw new JsonException();
			}

			var propertyName = reader.GetString();
			throw new JsonException();
		}

		public override void Write(Utf8JsonWriter writer, IntervalsFilter value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName(value.Variant.IntervalsFilterVariantName);
			writer.WriteEndObject();
		}
	}

	public sealed partial class IntervalsFilterDescriptor : DescriptorBase<IntervalsFilterDescriptor>
	{
		public IntervalsFilterDescriptor()
		{
		}

		internal IntervalsFilterDescriptor(Action<IntervalsFilterDescriptor> configure) => configure.Invoke(this);
	}

	internal sealed class IntervalsFilterDescriptorConverter : JsonConverter<IntervalsFilterDescriptor>
	{
		public override IntervalsFilterDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, IntervalsFilterDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WriteEndObject();
		}
	}

	public partial class IntervalsFuzzy : IIntervalsContainerVariant, IIntervalsQueryVariant
	{
		[JsonIgnore]
		string QueryDsl.IIntervalsContainerVariant.IntervalsContainerVariantName => "fuzzy";
		[JsonIgnore]
		string QueryDsl.IIntervalsQueryVariant.IntervalsQueryVariantName => "fuzzy";
		[JsonInclude]
		[JsonPropertyName("analyzer")]
		public string? Analyzer { get; set; }

		[JsonInclude]
		[JsonPropertyName("fuzziness")]
		public Elastic.Clients.Elasticsearch.Fuzziness? Fuzziness { get; set; }

		[JsonInclude]
		[JsonPropertyName("prefix_length")]
		public int? PrefixLength { get; set; }

		[JsonInclude]
		[JsonPropertyName("term")]
		public string Term { get; set; }

		[JsonInclude]
		[JsonPropertyName("transpositions")]
		public bool? Transpositions { get; set; }

		[JsonInclude]
		[JsonPropertyName("use_field")]
		public string? UseField { get; set; }
	}

	[JsonConverter(typeof(IntervalsFuzzyDescriptorConverter))]
	public sealed partial class IntervalsFuzzyDescriptor : DescriptorBase<IntervalsFuzzyDescriptor>, IIntervalsContainerVariantDescriptor, IIntervalsQueryVariantDescriptor
	{
		public IntervalsFuzzyDescriptor()
		{
		}

		internal IntervalsFuzzyDescriptor(Action<IntervalsFuzzyDescriptor> configure) => configure.Invoke(this);
		internal string? AnalyzerValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Fuzziness? FuzzinessValue { get; private set; }

		internal int? PrefixLengthValue { get; private set; }

		internal string TermValue { get; private set; }

		internal bool? TranspositionsValue { get; private set; }

		internal string? UseFieldValue { get; private set; }

		public IntervalsFuzzyDescriptor Analyzer(string? analyzer) => Assign(analyzer, (a, v) => a.AnalyzerValue = v);
		public IntervalsFuzzyDescriptor Fuzziness(Elastic.Clients.Elasticsearch.Fuzziness? fuzziness) => Assign(fuzziness, (a, v) => a.FuzzinessValue = v);
		public IntervalsFuzzyDescriptor PrefixLength(int? prefixLength) => Assign(prefixLength, (a, v) => a.PrefixLengthValue = v);
		public IntervalsFuzzyDescriptor Term(string term) => Assign(term, (a, v) => a.TermValue = v);
		public IntervalsFuzzyDescriptor Transpositions(bool? transpositions = true) => Assign(transpositions, (a, v) => a.TranspositionsValue = v);
		public IntervalsFuzzyDescriptor UseField(string? useField) => Assign(useField, (a, v) => a.UseFieldValue = v);
	}

	internal sealed class IntervalsFuzzyDescriptorConverter : JsonConverter<IntervalsFuzzyDescriptor>
	{
		public override IntervalsFuzzyDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, IntervalsFuzzyDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (!string.IsNullOrEmpty(value.AnalyzerValue))
			{
				writer.WritePropertyName("analyzer");
				writer.WriteStringValue(value.AnalyzerValue);
			}

			if (value.FuzzinessValue is not null)
			{
				writer.WritePropertyName("fuzziness");
				JsonSerializer.Serialize(writer, value.FuzzinessValue, options);
			}

			if (value.PrefixLengthValue.HasValue)
			{
				writer.WritePropertyName("prefix_length");
				writer.WriteNumberValue(value.PrefixLengthValue.Value);
			}

			writer.WritePropertyName("term");
			writer.WriteStringValue(value.TermValue);
			if (value.TranspositionsValue.HasValue)
			{
				writer.WritePropertyName("transpositions");
				writer.WriteBooleanValue(value.TranspositionsValue.Value);
			}

			if (value.UseFieldValue is not null)
			{
				writer.WritePropertyName("use_field");
				JsonSerializer.Serialize(writer, value.UseFieldValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class IntervalsMatch : IIntervalsContainerVariant, IIntervalsQueryVariant
	{
		[JsonIgnore]
		string QueryDsl.IIntervalsContainerVariant.IntervalsContainerVariantName => "match";
		[JsonIgnore]
		string QueryDsl.IIntervalsQueryVariant.IntervalsQueryVariantName => "match";
		[JsonInclude]
		[JsonPropertyName("analyzer")]
		public string? Analyzer { get; set; }

		[JsonInclude]
		[JsonPropertyName("max_gaps")]
		public int? MaxGaps { get; set; }

		[JsonInclude]
		[JsonPropertyName("ordered")]
		public bool? Ordered { get; set; }

		[JsonInclude]
		[JsonPropertyName("query")]
		public string Query { get; set; }

		[JsonInclude]
		[JsonPropertyName("use_field")]
		public string? UseField { get; set; }

		[JsonInclude]
		[JsonPropertyName("filter")]
		public Elastic.Clients.Elasticsearch.QueryDsl.IntervalsFilter? Filter { get; set; }
	}

	[JsonConverter(typeof(IntervalsMatchDescriptorConverter))]
	public sealed partial class IntervalsMatchDescriptor : DescriptorBase<IntervalsMatchDescriptor>, IIntervalsContainerVariantDescriptor, IIntervalsQueryVariantDescriptor
	{
		public IntervalsMatchDescriptor()
		{
		}

		internal IntervalsMatchDescriptor(Action<IntervalsMatchDescriptor> configure) => configure.Invoke(this);
		internal string? AnalyzerValue { get; private set; }

		internal int? MaxGapsValue { get; private set; }

		internal bool? OrderedValue { get; private set; }

		internal string QueryValue { get; private set; }

		internal string? UseFieldValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.IntervalsFilter? FilterValue { get; private set; }

		internal IntervalsFilterDescriptor FilterDescriptor { get; private set; }

		internal Action<IntervalsFilterDescriptor> FilterDescriptorAction { get; private set; }

		public IntervalsMatchDescriptor Analyzer(string? analyzer) => Assign(analyzer, (a, v) => a.AnalyzerValue = v);
		public IntervalsMatchDescriptor MaxGaps(int? maxGaps) => Assign(maxGaps, (a, v) => a.MaxGapsValue = v);
		public IntervalsMatchDescriptor Ordered(bool? ordered = true) => Assign(ordered, (a, v) => a.OrderedValue = v);
		public IntervalsMatchDescriptor Query(string query) => Assign(query, (a, v) => a.QueryValue = v);
		public IntervalsMatchDescriptor UseField(string? useField) => Assign(useField, (a, v) => a.UseFieldValue = v);
		public IntervalsMatchDescriptor Filter(Elastic.Clients.Elasticsearch.QueryDsl.IntervalsFilter? filter)
		{
			FilterDescriptor = null;
			FilterDescriptorAction = null;
			return Assign(filter, (a, v) => a.FilterValue = v);
		}

		public IntervalsMatchDescriptor Filter(Elastic.Clients.Elasticsearch.QueryDsl.IntervalsFilterDescriptor descriptor)
		{
			FilterValue = null;
			FilterDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.FilterDescriptor = v);
		}

		public IntervalsMatchDescriptor Filter(Action<Elastic.Clients.Elasticsearch.QueryDsl.IntervalsFilterDescriptor> configure)
		{
			FilterValue = null;
			FilterDescriptorAction = null;
			return Assign(configure, (a, v) => a.FilterDescriptorAction = v);
		}
	}

	internal sealed class IntervalsMatchDescriptorConverter : JsonConverter<IntervalsMatchDescriptor>
	{
		public override IntervalsMatchDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, IntervalsMatchDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (!string.IsNullOrEmpty(value.AnalyzerValue))
			{
				writer.WritePropertyName("analyzer");
				writer.WriteStringValue(value.AnalyzerValue);
			}

			if (value.MaxGapsValue.HasValue)
			{
				writer.WritePropertyName("max_gaps");
				writer.WriteNumberValue(value.MaxGapsValue.Value);
			}

			if (value.OrderedValue.HasValue)
			{
				writer.WritePropertyName("ordered");
				writer.WriteBooleanValue(value.OrderedValue.Value);
			}

			writer.WritePropertyName("query");
			writer.WriteStringValue(value.QueryValue);
			if (value.UseFieldValue is not null)
			{
				writer.WritePropertyName("use_field");
				JsonSerializer.Serialize(writer, value.UseFieldValue, options);
			}

			if (value.FilterDescriptor is not null)
			{
				writer.WritePropertyName("filter");
				JsonSerializer.Serialize(writer, value.FilterDescriptor, options);
			}
			else if (value.FilterDescriptorAction is not null)
			{
				writer.WritePropertyName("filter");
				JsonSerializer.Serialize(writer, new IntervalsFilterDescriptor(value.FilterDescriptorAction), options);
			}
			else if (value.FilterValue is not null)
			{
				writer.WritePropertyName("filter");
				JsonSerializer.Serialize(writer, value.FilterValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class IntervalsPrefix : IIntervalsContainerVariant, IIntervalsQueryVariant
	{
		[JsonIgnore]
		string QueryDsl.IIntervalsContainerVariant.IntervalsContainerVariantName => "prefix";
		[JsonIgnore]
		string QueryDsl.IIntervalsQueryVariant.IntervalsQueryVariantName => "prefix";
		[JsonInclude]
		[JsonPropertyName("analyzer")]
		public string? Analyzer { get; set; }

		[JsonInclude]
		[JsonPropertyName("prefix")]
		public string Prefix { get; set; }

		[JsonInclude]
		[JsonPropertyName("use_field")]
		public string? UseField { get; set; }
	}

	[JsonConverter(typeof(IntervalsPrefixDescriptorConverter))]
	public sealed partial class IntervalsPrefixDescriptor : DescriptorBase<IntervalsPrefixDescriptor>, IIntervalsContainerVariantDescriptor, IIntervalsQueryVariantDescriptor
	{
		public IntervalsPrefixDescriptor()
		{
		}

		internal IntervalsPrefixDescriptor(Action<IntervalsPrefixDescriptor> configure) => configure.Invoke(this);
		internal string? AnalyzerValue { get; private set; }

		internal string PrefixValue { get; private set; }

		internal string? UseFieldValue { get; private set; }

		public IntervalsPrefixDescriptor Analyzer(string? analyzer) => Assign(analyzer, (a, v) => a.AnalyzerValue = v);
		public IntervalsPrefixDescriptor Prefix(string prefix) => Assign(prefix, (a, v) => a.PrefixValue = v);
		public IntervalsPrefixDescriptor UseField(string? useField) => Assign(useField, (a, v) => a.UseFieldValue = v);
	}

	internal sealed class IntervalsPrefixDescriptorConverter : JsonConverter<IntervalsPrefixDescriptor>
	{
		public override IntervalsPrefixDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, IntervalsPrefixDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (!string.IsNullOrEmpty(value.AnalyzerValue))
			{
				writer.WritePropertyName("analyzer");
				writer.WriteStringValue(value.AnalyzerValue);
			}

			writer.WritePropertyName("prefix");
			writer.WriteStringValue(value.PrefixValue);
			if (value.UseFieldValue is not null)
			{
				writer.WritePropertyName("use_field");
				JsonSerializer.Serialize(writer, value.UseFieldValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public interface IIntervalsQueryVariant
	{
		string IntervalsQueryVariantName { get; }
	}

	internal interface IIntervalsQueryVariantDescriptor
	{
	}

	[JsonConverter(typeof(IntervalsQueryConverter))]
	public partial class IntervalsQuery : FieldNameQueryBase, IContainer, IQueryContainerVariant
	{
		public IntervalsQuery(IIntervalsQueryVariant variant) => Variant = variant ?? throw new ArgumentNullException(nameof(variant));
		internal IIntervalsQueryVariant Variant { get; }

		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "intervals";
	}

	internal sealed class IntervalsQueryConverter : JsonConverter<IntervalsQuery>
	{
		public override IntervalsQuery Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			reader.Read();
			if (reader.TokenType != JsonTokenType.PropertyName)
			{
				throw new JsonException();
			}

			var propertyName = reader.GetString();
			if (propertyName == "all_of")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.IntervalsAllOf?>(ref reader, options);
				reader.Read();
				return new IntervalsQuery(variant);
			}

			if (propertyName == "any_of")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.IntervalsAnyOf?>(ref reader, options);
				reader.Read();
				return new IntervalsQuery(variant);
			}

			if (propertyName == "fuzzy")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.IntervalsFuzzy?>(ref reader, options);
				reader.Read();
				return new IntervalsQuery(variant);
			}

			if (propertyName == "match")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.IntervalsMatch?>(ref reader, options);
				reader.Read();
				return new IntervalsQuery(variant);
			}

			if (propertyName == "prefix")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.IntervalsPrefix?>(ref reader, options);
				reader.Read();
				return new IntervalsQuery(variant);
			}

			if (propertyName == "wildcard")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.IntervalsWildcard?>(ref reader, options);
				reader.Read();
				return new IntervalsQuery(variant);
			}

			throw new JsonException();
		}

		public override void Write(Utf8JsonWriter writer, IntervalsQuery value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName(value.Variant.IntervalsQueryVariantName);
			switch (value.Variant)
			{
				case Elastic.Clients.Elasticsearch.QueryDsl.IntervalsAllOf variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.IntervalsAnyOf variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.IntervalsFuzzy variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.IntervalsMatch variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.IntervalsPrefix variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.IntervalsWildcard variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
			}

			writer.WriteEndObject();
		}
	}

	public sealed partial class IntervalsQueryDescriptor : DescriptorBase<IntervalsQueryDescriptor>
	{
		public IntervalsQueryDescriptor()
		{
		}

		internal IntervalsQueryDescriptor(Action<IntervalsQueryDescriptor> configure) => configure.Invoke(this);
	}

	internal sealed class IntervalsQueryDescriptorConverter : JsonConverter<IntervalsQueryDescriptor>
	{
		public override IntervalsQueryDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, IntervalsQueryDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WriteEndObject();
		}
	}

	public partial class IntervalsWildcard : IIntervalsContainerVariant, IIntervalsQueryVariant
	{
		[JsonIgnore]
		string QueryDsl.IIntervalsContainerVariant.IntervalsContainerVariantName => "wildcard";
		[JsonIgnore]
		string QueryDsl.IIntervalsQueryVariant.IntervalsQueryVariantName => "wildcard";
		[JsonInclude]
		[JsonPropertyName("analyzer")]
		public string? Analyzer { get; set; }

		[JsonInclude]
		[JsonPropertyName("pattern")]
		public string Pattern { get; set; }

		[JsonInclude]
		[JsonPropertyName("use_field")]
		public string? UseField { get; set; }
	}

	[JsonConverter(typeof(IntervalsWildcardDescriptorConverter))]
	public sealed partial class IntervalsWildcardDescriptor : DescriptorBase<IntervalsWildcardDescriptor>, IIntervalsContainerVariantDescriptor, IIntervalsQueryVariantDescriptor
	{
		public IntervalsWildcardDescriptor()
		{
		}

		internal IntervalsWildcardDescriptor(Action<IntervalsWildcardDescriptor> configure) => configure.Invoke(this);
		internal string? AnalyzerValue { get; private set; }

		internal string PatternValue { get; private set; }

		internal string? UseFieldValue { get; private set; }

		public IntervalsWildcardDescriptor Analyzer(string? analyzer) => Assign(analyzer, (a, v) => a.AnalyzerValue = v);
		public IntervalsWildcardDescriptor Pattern(string pattern) => Assign(pattern, (a, v) => a.PatternValue = v);
		public IntervalsWildcardDescriptor UseField(string? useField) => Assign(useField, (a, v) => a.UseFieldValue = v);
	}

	internal sealed class IntervalsWildcardDescriptorConverter : JsonConverter<IntervalsWildcardDescriptor>
	{
		public override IntervalsWildcardDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, IntervalsWildcardDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (!string.IsNullOrEmpty(value.AnalyzerValue))
			{
				writer.WritePropertyName("analyzer");
				writer.WriteStringValue(value.AnalyzerValue);
			}

			writer.WritePropertyName("pattern");
			writer.WriteStringValue(value.PatternValue);
			if (value.UseFieldValue is not null)
			{
				writer.WritePropertyName("use_field");
				JsonSerializer.Serialize(writer, value.UseFieldValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class LikeDocument
	{
		[JsonInclude]
		[JsonPropertyName("doc")]
		public object? Doc { get; init; }

		[JsonInclude]
		[JsonPropertyName("fields")]
		public IReadOnlyCollection<string>? Fields { get; init; }

		[JsonInclude]
		[JsonPropertyName("_id")]
		public Elastic.Clients.Elasticsearch.Id? Id { get; init; }

		[JsonInclude]
		[JsonPropertyName("_type")]
		public string? Type { get; init; }

		[JsonInclude]
		[JsonPropertyName("_index")]
		public Elastic.Clients.Elasticsearch.IndexName? Index { get; init; }

		[JsonInclude]
		[JsonPropertyName("per_field_analyzer")]
		public Dictionary<string, string>? PerFieldAnalyzer { get; init; }

		[JsonInclude]
		[JsonPropertyName("routing")]
		public string? Routing { get; init; }

		[JsonInclude]
		[JsonPropertyName("version")]
		public long? Version { get; init; }

		[JsonInclude]
		[JsonPropertyName("version_type")]
		public Elastic.Clients.Elasticsearch.VersionType? VersionType { get; init; }
	}

	public partial class MatchAllQuery : QueryDsl.QueryBase, IQueryContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "match_all";
	}

	[JsonConverter(typeof(MatchAllQueryDescriptorConverter))]
	public sealed partial class MatchAllQueryDescriptor : DescriptorBase<MatchAllQueryDescriptor>, IQueryContainerVariantDescriptor
	{
		public MatchAllQueryDescriptor()
		{
		}

		internal MatchAllQueryDescriptor(Action<MatchAllQueryDescriptor> configure) => configure.Invoke(this);
	}

	internal sealed class MatchAllQueryDescriptorConverter : JsonConverter<MatchAllQueryDescriptor>
	{
		public override MatchAllQueryDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, MatchAllQueryDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WriteEndObject();
		}
	}

	public partial class MatchBoolPrefixQuery : FieldNameQueryBase, IQueryContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "match_bool_prefix";
		[JsonInclude]
		[JsonPropertyName("analyzer")]
		public string? Analyzer { get; set; }

		[JsonInclude]
		[JsonPropertyName("fuzziness")]
		public Elastic.Clients.Elasticsearch.Fuzziness? Fuzziness { get; set; }

		[JsonInclude]
		[JsonPropertyName("fuzzy_rewrite")]
		public string? FuzzyRewrite { get; set; }

		[JsonInclude]
		[JsonPropertyName("fuzzy_transpositions")]
		public bool? FuzzyTranspositions { get; set; }

		[JsonInclude]
		[JsonPropertyName("max_expansions")]
		public int? MaxExpansions { get; set; }

		[JsonInclude]
		[JsonPropertyName("minimum_should_match")]
		public Elastic.Clients.Elasticsearch.MinimumShouldMatch? MinimumShouldMatch { get; set; }

		[JsonInclude]
		[JsonPropertyName("operator")]
		public Elastic.Clients.Elasticsearch.QueryDsl.Operator? Operator { get; set; }

		[JsonInclude]
		[JsonPropertyName("prefix_length")]
		public int? PrefixLength { get; set; }

		[JsonInclude]
		[JsonPropertyName("query")]
		public string Query { get; set; }
	}

	[JsonConverter(typeof(MatchBoolPrefixQueryDescriptorConverter))]
	public sealed partial class MatchBoolPrefixQueryDescriptor : DescriptorBase<MatchBoolPrefixQueryDescriptor>, IQueryContainerVariantDescriptor
	{
		public MatchBoolPrefixQueryDescriptor()
		{
		}

		internal MatchBoolPrefixQueryDescriptor(Action<MatchBoolPrefixQueryDescriptor> configure) => configure.Invoke(this);
		internal string? AnalyzerValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Fuzziness? FuzzinessValue { get; private set; }

		internal string? FuzzyRewriteValue { get; private set; }

		internal bool? FuzzyTranspositionsValue { get; private set; }

		internal int? MaxExpansionsValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.MinimumShouldMatch? MinimumShouldMatchValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.Operator? OperatorValue { get; private set; }

		internal int? PrefixLengthValue { get; private set; }

		internal string QueryValue { get; private set; }

		public MatchBoolPrefixQueryDescriptor Analyzer(string? analyzer) => Assign(analyzer, (a, v) => a.AnalyzerValue = v);
		public MatchBoolPrefixQueryDescriptor Fuzziness(Elastic.Clients.Elasticsearch.Fuzziness? fuzziness) => Assign(fuzziness, (a, v) => a.FuzzinessValue = v);
		public MatchBoolPrefixQueryDescriptor FuzzyRewrite(string? fuzzyRewrite) => Assign(fuzzyRewrite, (a, v) => a.FuzzyRewriteValue = v);
		public MatchBoolPrefixQueryDescriptor FuzzyTranspositions(bool? fuzzyTranspositions = true) => Assign(fuzzyTranspositions, (a, v) => a.FuzzyTranspositionsValue = v);
		public MatchBoolPrefixQueryDescriptor MaxExpansions(int? maxExpansions) => Assign(maxExpansions, (a, v) => a.MaxExpansionsValue = v);
		public MatchBoolPrefixQueryDescriptor MinimumShouldMatch(Elastic.Clients.Elasticsearch.MinimumShouldMatch? minimumShouldMatch) => Assign(minimumShouldMatch, (a, v) => a.MinimumShouldMatchValue = v);
		public MatchBoolPrefixQueryDescriptor Operator(Elastic.Clients.Elasticsearch.QueryDsl.Operator? op) => Assign(op, (a, v) => a.OperatorValue = v);
		public MatchBoolPrefixQueryDescriptor PrefixLength(int? prefixLength) => Assign(prefixLength, (a, v) => a.PrefixLengthValue = v);
		public MatchBoolPrefixQueryDescriptor Query(string query) => Assign(query, (a, v) => a.QueryValue = v);
	}

	internal sealed class MatchBoolPrefixQueryDescriptorConverter : JsonConverter<MatchBoolPrefixQueryDescriptor>
	{
		public override MatchBoolPrefixQueryDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, MatchBoolPrefixQueryDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (!string.IsNullOrEmpty(value.AnalyzerValue))
			{
				writer.WritePropertyName("analyzer");
				writer.WriteStringValue(value.AnalyzerValue);
			}

			if (value.FuzzinessValue is not null)
			{
				writer.WritePropertyName("fuzziness");
				JsonSerializer.Serialize(writer, value.FuzzinessValue, options);
			}

			if (value.FuzzyRewriteValue is not null)
			{
				writer.WritePropertyName("fuzzy_rewrite");
				JsonSerializer.Serialize(writer, value.FuzzyRewriteValue, options);
			}

			if (value.FuzzyTranspositionsValue.HasValue)
			{
				writer.WritePropertyName("fuzzy_transpositions");
				writer.WriteBooleanValue(value.FuzzyTranspositionsValue.Value);
			}

			if (value.MaxExpansionsValue.HasValue)
			{
				writer.WritePropertyName("max_expansions");
				writer.WriteNumberValue(value.MaxExpansionsValue.Value);
			}

			if (value.MinimumShouldMatchValue is not null)
			{
				writer.WritePropertyName("minimum_should_match");
				JsonSerializer.Serialize(writer, value.MinimumShouldMatchValue, options);
			}

			if (value.OperatorValue is not null)
			{
				writer.WritePropertyName("operator");
				JsonSerializer.Serialize(writer, value.OperatorValue, options);
			}

			if (value.PrefixLengthValue.HasValue)
			{
				writer.WritePropertyName("prefix_length");
				writer.WriteNumberValue(value.PrefixLengthValue.Value);
			}

			writer.WritePropertyName("query");
			writer.WriteStringValue(value.QueryValue);
			writer.WriteEndObject();
		}
	}

	public partial class MatchNoneQuery : QueryDsl.QueryBase, IQueryContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "match_none";
	}

	[JsonConverter(typeof(MatchNoneQueryDescriptorConverter))]
	public sealed partial class MatchNoneQueryDescriptor : DescriptorBase<MatchNoneQueryDescriptor>, IQueryContainerVariantDescriptor
	{
		public MatchNoneQueryDescriptor()
		{
		}

		internal MatchNoneQueryDescriptor(Action<MatchNoneQueryDescriptor> configure) => configure.Invoke(this);
	}

	internal sealed class MatchNoneQueryDescriptorConverter : JsonConverter<MatchNoneQueryDescriptor>
	{
		public override MatchNoneQueryDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, MatchNoneQueryDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WriteEndObject();
		}
	}

	public partial class MatchPhrasePrefixQuery : FieldNameQueryBase, IQueryContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "match_phrase_prefix";
		[JsonInclude]
		[JsonPropertyName("analyzer")]
		public string? Analyzer { get; set; }

		[JsonInclude]
		[JsonPropertyName("max_expansions")]
		public int? MaxExpansions { get; set; }

		[JsonInclude]
		[JsonPropertyName("query")]
		public string Query { get; set; }

		[JsonInclude]
		[JsonPropertyName("slop")]
		public int? Slop { get; set; }

		[JsonInclude]
		[JsonPropertyName("zero_terms_query")]
		public Elastic.Clients.Elasticsearch.QueryDsl.ZeroTermsQuery? ZeroTermsQuery { get; set; }
	}

	[JsonConverter(typeof(MatchPhrasePrefixQueryDescriptorConverter))]
	public sealed partial class MatchPhrasePrefixQueryDescriptor : DescriptorBase<MatchPhrasePrefixQueryDescriptor>, IQueryContainerVariantDescriptor
	{
		public MatchPhrasePrefixQueryDescriptor()
		{
		}

		internal MatchPhrasePrefixQueryDescriptor(Action<MatchPhrasePrefixQueryDescriptor> configure) => configure.Invoke(this);
		internal string? AnalyzerValue { get; private set; }

		internal int? MaxExpansionsValue { get; private set; }

		internal string QueryValue { get; private set; }

		internal int? SlopValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.ZeroTermsQuery? ZeroTermsQueryValue { get; private set; }

		public MatchPhrasePrefixQueryDescriptor Analyzer(string? analyzer) => Assign(analyzer, (a, v) => a.AnalyzerValue = v);
		public MatchPhrasePrefixQueryDescriptor MaxExpansions(int? maxExpansions) => Assign(maxExpansions, (a, v) => a.MaxExpansionsValue = v);
		public MatchPhrasePrefixQueryDescriptor Query(string query) => Assign(query, (a, v) => a.QueryValue = v);
		public MatchPhrasePrefixQueryDescriptor Slop(int? slop) => Assign(slop, (a, v) => a.SlopValue = v);
		public MatchPhrasePrefixQueryDescriptor ZeroTermsQuery(Elastic.Clients.Elasticsearch.QueryDsl.ZeroTermsQuery? zeroTermsQuery) => Assign(zeroTermsQuery, (a, v) => a.ZeroTermsQueryValue = v);
	}

	internal sealed class MatchPhrasePrefixQueryDescriptorConverter : JsonConverter<MatchPhrasePrefixQueryDescriptor>
	{
		public override MatchPhrasePrefixQueryDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, MatchPhrasePrefixQueryDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (!string.IsNullOrEmpty(value.AnalyzerValue))
			{
				writer.WritePropertyName("analyzer");
				writer.WriteStringValue(value.AnalyzerValue);
			}

			if (value.MaxExpansionsValue.HasValue)
			{
				writer.WritePropertyName("max_expansions");
				writer.WriteNumberValue(value.MaxExpansionsValue.Value);
			}

			writer.WritePropertyName("query");
			writer.WriteStringValue(value.QueryValue);
			if (value.SlopValue.HasValue)
			{
				writer.WritePropertyName("slop");
				writer.WriteNumberValue(value.SlopValue.Value);
			}

			if (value.ZeroTermsQueryValue is not null)
			{
				writer.WritePropertyName("zero_terms_query");
				JsonSerializer.Serialize(writer, value.ZeroTermsQueryValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class MatchPhraseQuery : FieldNameQueryBase, IQueryContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "match_phrase";
		[JsonInclude]
		[JsonPropertyName("analyzer")]
		public string? Analyzer { get; set; }

		[JsonInclude]
		[JsonPropertyName("query")]
		public string Query { get; set; }

		[JsonInclude]
		[JsonPropertyName("slop")]
		public int? Slop { get; set; }

		[JsonInclude]
		[JsonPropertyName("zero_terms_query")]
		public Elastic.Clients.Elasticsearch.QueryDsl.ZeroTermsQuery? ZeroTermsQuery { get; set; }
	}

	[JsonConverter(typeof(MatchPhraseQueryDescriptorConverter))]
	public sealed partial class MatchPhraseQueryDescriptor : DescriptorBase<MatchPhraseQueryDescriptor>, IQueryContainerVariantDescriptor
	{
		public MatchPhraseQueryDescriptor()
		{
		}

		internal MatchPhraseQueryDescriptor(Action<MatchPhraseQueryDescriptor> configure) => configure.Invoke(this);
		internal string? AnalyzerValue { get; private set; }

		internal string QueryValue { get; private set; }

		internal int? SlopValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.ZeroTermsQuery? ZeroTermsQueryValue { get; private set; }

		public MatchPhraseQueryDescriptor Analyzer(string? analyzer) => Assign(analyzer, (a, v) => a.AnalyzerValue = v);
		public MatchPhraseQueryDescriptor Query(string query) => Assign(query, (a, v) => a.QueryValue = v);
		public MatchPhraseQueryDescriptor Slop(int? slop) => Assign(slop, (a, v) => a.SlopValue = v);
		public MatchPhraseQueryDescriptor ZeroTermsQuery(Elastic.Clients.Elasticsearch.QueryDsl.ZeroTermsQuery? zeroTermsQuery) => Assign(zeroTermsQuery, (a, v) => a.ZeroTermsQueryValue = v);
	}

	internal sealed class MatchPhraseQueryDescriptorConverter : JsonConverter<MatchPhraseQueryDescriptor>
	{
		public override MatchPhraseQueryDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, MatchPhraseQueryDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (!string.IsNullOrEmpty(value.AnalyzerValue))
			{
				writer.WritePropertyName("analyzer");
				writer.WriteStringValue(value.AnalyzerValue);
			}

			writer.WritePropertyName("query");
			writer.WriteStringValue(value.QueryValue);
			if (value.SlopValue.HasValue)
			{
				writer.WritePropertyName("slop");
				writer.WriteNumberValue(value.SlopValue.Value);
			}

			if (value.ZeroTermsQueryValue is not null)
			{
				writer.WritePropertyName("zero_terms_query");
				JsonSerializer.Serialize(writer, value.ZeroTermsQueryValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class MatchQuery : FieldNameQueryBase, IQueryContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "match";
		[JsonInclude]
		[JsonPropertyName("analyzer")]
		public string? Analyzer { get; set; }

		[JsonInclude]
		[JsonPropertyName("auto_generate_synonyms_phrase_query")]
		public bool? AutoGenerateSynonymsPhraseQuery { get; set; }

		[JsonInclude]
		[JsonPropertyName("fuzziness")]
		public Elastic.Clients.Elasticsearch.Fuzziness? Fuzziness { get; set; }

		[JsonInclude]
		[JsonPropertyName("fuzzy_rewrite")]
		public string? FuzzyRewrite { get; set; }

		[JsonInclude]
		[JsonPropertyName("fuzzy_transpositions")]
		public bool? FuzzyTranspositions { get; set; }

		[JsonInclude]
		[JsonPropertyName("lenient")]
		public bool? Lenient { get; set; }

		[JsonInclude]
		[JsonPropertyName("max_expansions")]
		public int? MaxExpansions { get; set; }

		[JsonInclude]
		[JsonPropertyName("minimum_should_match")]
		public Elastic.Clients.Elasticsearch.MinimumShouldMatch? MinimumShouldMatch { get; set; }

		[JsonInclude]
		[JsonPropertyName("operator")]
		public Elastic.Clients.Elasticsearch.QueryDsl.Operator? Operator { get; set; }

		[JsonInclude]
		[JsonPropertyName("prefix_length")]
		public int? PrefixLength { get; set; }

		[JsonInclude]
		[JsonPropertyName("query")]
		public string Query { get; set; }

		[JsonInclude]
		[JsonPropertyName("zero_terms_query")]
		public Elastic.Clients.Elasticsearch.QueryDsl.ZeroTermsQuery? ZeroTermsQuery { get; set; }
	}

	[JsonConverter(typeof(MatchQueryDescriptorConverter))]
	public sealed partial class MatchQueryDescriptor : FieldNameQueryDescriptorBase<MatchQueryDescriptor>, IQueryContainerVariantDescriptor
	{
		public MatchQueryDescriptor()
		{
		}

		internal MatchQueryDescriptor(Action<MatchQueryDescriptor> configure) => configure.Invoke(this);
		internal string? AnalyzerValue { get; private set; }

		internal bool? AutoGenerateSynonymsPhraseQueryValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Fuzziness? FuzzinessValue { get; private set; }

		internal string? FuzzyRewriteValue { get; private set; }

		internal bool? FuzzyTranspositionsValue { get; private set; }

		internal bool? LenientValue { get; private set; }

		internal int? MaxExpansionsValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.MinimumShouldMatch? MinimumShouldMatchValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.Operator? OperatorValue { get; private set; }

		internal int? PrefixLengthValue { get; private set; }

		internal string QueryValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.ZeroTermsQuery? ZeroTermsQueryValue { get; private set; }

		public MatchQueryDescriptor Analyzer(string? analyzer) => Assign(analyzer, (a, v) => a.AnalyzerValue = v);
		public MatchQueryDescriptor AutoGenerateSynonymsPhraseQuery(bool? autoGenerateSynonymsPhraseQuery = true) => Assign(autoGenerateSynonymsPhraseQuery, (a, v) => a.AutoGenerateSynonymsPhraseQueryValue = v);
		public MatchQueryDescriptor Fuzziness(Elastic.Clients.Elasticsearch.Fuzziness? fuzziness) => Assign(fuzziness, (a, v) => a.FuzzinessValue = v);
		public MatchQueryDescriptor FuzzyRewrite(string? fuzzyRewrite) => Assign(fuzzyRewrite, (a, v) => a.FuzzyRewriteValue = v);
		public MatchQueryDescriptor FuzzyTranspositions(bool? fuzzyTranspositions = true) => Assign(fuzzyTranspositions, (a, v) => a.FuzzyTranspositionsValue = v);
		public MatchQueryDescriptor Lenient(bool? lenient = true) => Assign(lenient, (a, v) => a.LenientValue = v);
		public MatchQueryDescriptor MaxExpansions(int? maxExpansions) => Assign(maxExpansions, (a, v) => a.MaxExpansionsValue = v);
		public MatchQueryDescriptor MinimumShouldMatch(Elastic.Clients.Elasticsearch.MinimumShouldMatch? minimumShouldMatch) => Assign(minimumShouldMatch, (a, v) => a.MinimumShouldMatchValue = v);
		public MatchQueryDescriptor Operator(Elastic.Clients.Elasticsearch.QueryDsl.Operator? op) => Assign(op, (a, v) => a.OperatorValue = v);
		public MatchQueryDescriptor PrefixLength(int? prefixLength) => Assign(prefixLength, (a, v) => a.PrefixLengthValue = v);
		public MatchQueryDescriptor Query(string query) => Assign(query, (a, v) => a.QueryValue = v);
		public MatchQueryDescriptor ZeroTermsQuery(Elastic.Clients.Elasticsearch.QueryDsl.ZeroTermsQuery? zeroTermsQuery) => Assign(zeroTermsQuery, (a, v) => a.ZeroTermsQueryValue = v);
	}

	//internal sealed class MatchQueryDescriptorConverter : JsonConverter<MatchQueryDescriptor>
	//{
	//	public override MatchQueryDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
	//	public override void Write(Utf8JsonWriter writer, MatchQueryDescriptor value, JsonSerializerOptions options)
	//	{
	//		writer.WriteStartObject();
	//		if (!string.IsNullOrEmpty(value.AnalyzerValue))
	//		{
	//			writer.WritePropertyName("analyzer");
	//			writer.WriteStringValue(value.AnalyzerValue);
	//		}

	//		if (value.AutoGenerateSynonymsPhraseQueryValue.HasValue)
	//		{
	//			writer.WritePropertyName("auto_generate_synonyms_phrase_query");
	//			writer.WriteBooleanValue(value.AutoGenerateSynonymsPhraseQueryValue.Value);
	//		}

	//		if (value.FuzzinessValue is not null)
	//		{
	//			writer.WritePropertyName("fuzziness");
	//			JsonSerializer.Serialize(writer, value.FuzzinessValue, options);
	//		}

	//		if (value.FuzzyRewriteValue is not null)
	//		{
	//			writer.WritePropertyName("fuzzy_rewrite");
	//			JsonSerializer.Serialize(writer, value.FuzzyRewriteValue, options);
	//		}

	//		if (value.FuzzyTranspositionsValue.HasValue)
	//		{
	//			writer.WritePropertyName("fuzzy_transpositions");
	//			writer.WriteBooleanValue(value.FuzzyTranspositionsValue.Value);
	//		}

	//		if (value.LenientValue.HasValue)
	//		{
	//			writer.WritePropertyName("lenient");
	//			writer.WriteBooleanValue(value.LenientValue.Value);
	//		}

	//		if (value.MaxExpansionsValue.HasValue)
	//		{
	//			writer.WritePropertyName("max_expansions");
	//			writer.WriteNumberValue(value.MaxExpansionsValue.Value);
	//		}

	//		if (value.MinimumShouldMatchValue is not null)
	//		{
	//			writer.WritePropertyName("minimum_should_match");
	//			JsonSerializer.Serialize(writer, value.MinimumShouldMatchValue, options);
	//		}

	//		if (value.OperatorValue is not null)
	//		{
	//			writer.WritePropertyName("operator");
	//			JsonSerializer.Serialize(writer, value.OperatorValue, options);
	//		}

	//		if (value.PrefixLengthValue.HasValue)
	//		{
	//			writer.WritePropertyName("prefix_length");
	//			writer.WriteNumberValue(value.PrefixLengthValue.Value);
	//		}

	//		writer.WritePropertyName("query");
	//		JsonSerializer.Serialize(writer, value.QueryValue, options);
	//		if (value.ZeroTermsQueryValue is not null)
	//		{
	//			writer.WritePropertyName("zero_terms_query");
	//			JsonSerializer.Serialize(writer, value.ZeroTermsQueryValue, options);
	//		}

	//		writer.WriteEndObject();
	//	}
	//}

	public partial class MoreLikeThisQuery : QueryDsl.QueryBase, IQueryContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "more_like_this";
		[JsonInclude]
		[JsonPropertyName("analyzer")]
		public string? Analyzer { get; set; }

		[JsonInclude]
		[JsonPropertyName("boost_terms")]
		public double? BoostTerms { get; set; }

		[JsonInclude]
		[JsonPropertyName("fail_on_unsupported_field")]
		public bool? FailOnUnsupportedField { get; set; }

		[JsonInclude]
		[JsonPropertyName("fields")]
		public IEnumerable<string>? Fields { get; set; }

		[JsonInclude]
		[JsonPropertyName("include")]
		public bool? Include { get; set; }

		[JsonInclude]
		[JsonPropertyName("like")]
		public Elastic.Clients.Elasticsearch.QueryDsl.Like Like { get; set; }

		[JsonInclude]
		[JsonPropertyName("max_doc_freq")]
		public int? MaxDocFreq { get; set; }

		[JsonInclude]
		[JsonPropertyName("max_query_terms")]
		public int? MaxQueryTerms { get; set; }

		[JsonInclude]
		[JsonPropertyName("max_word_length")]
		public int? MaxWordLength { get; set; }

		[JsonInclude]
		[JsonPropertyName("min_doc_freq")]
		public int? MinDocFreq { get; set; }

		[JsonInclude]
		[JsonPropertyName("minimum_should_match")]
		public Elastic.Clients.Elasticsearch.MinimumShouldMatch? MinimumShouldMatch { get; set; }

		[JsonInclude]
		[JsonPropertyName("min_term_freq")]
		public int? MinTermFreq { get; set; }

		[JsonInclude]
		[JsonPropertyName("min_word_length")]
		public int? MinWordLength { get; set; }

		[JsonInclude]
		[JsonPropertyName("per_field_analyzer")]
		public Dictionary<string, string>? PerFieldAnalyzer { get; set; }

		[JsonInclude]
		[JsonPropertyName("routing")]
		public string? Routing { get; set; }

		[JsonInclude]
		[JsonPropertyName("stop_words")]
		public Elastic.Clients.Elasticsearch.Analysis.StopWords? StopWords { get; set; }

		[JsonInclude]
		[JsonPropertyName("unlike")]
		public Elastic.Clients.Elasticsearch.QueryDsl.Like? Unlike { get; set; }

		[JsonInclude]
		[JsonPropertyName("version")]
		public long? Version { get; set; }

		[JsonInclude]
		[JsonPropertyName("version_type")]
		public Elastic.Clients.Elasticsearch.VersionType? VersionType { get; set; }
	}

	[JsonConverter(typeof(MoreLikeThisQueryDescriptorConverter))]
	public sealed partial class MoreLikeThisQueryDescriptor : DescriptorBase<MoreLikeThisQueryDescriptor>, IQueryContainerVariantDescriptor
	{
		public MoreLikeThisQueryDescriptor()
		{
		}

		internal MoreLikeThisQueryDescriptor(Action<MoreLikeThisQueryDescriptor> configure) => configure.Invoke(this);
		internal string? AnalyzerValue { get; private set; }

		internal double? BoostTermsValue { get; private set; }

		internal bool? FailOnUnsupportedFieldValue { get; private set; }

		internal IEnumerable<string>? FieldsValue { get; private set; }

		internal bool? IncludeValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.Like LikeValue { get; private set; }

		internal int? MaxDocFreqValue { get; private set; }

		internal int? MaxQueryTermsValue { get; private set; }

		internal int? MaxWordLengthValue { get; private set; }

		internal int? MinDocFreqValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.MinimumShouldMatch? MinimumShouldMatchValue { get; private set; }

		internal int? MinTermFreqValue { get; private set; }

		internal int? MinWordLengthValue { get; private set; }

		internal Dictionary<string, string>? PerFieldAnalyzerValue { get; private set; }

		internal string? RoutingValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Analysis.StopWords? StopWordsValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.Like? UnlikeValue { get; private set; }

		internal long? VersionValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.VersionType? VersionTypeValue { get; private set; }

		public MoreLikeThisQueryDescriptor Analyzer(string? analyzer) => Assign(analyzer, (a, v) => a.AnalyzerValue = v);
		public MoreLikeThisQueryDescriptor BoostTerms(double? boostTerms) => Assign(boostTerms, (a, v) => a.BoostTermsValue = v);
		public MoreLikeThisQueryDescriptor FailOnUnsupportedField(bool? failOnUnsupportedField = true) => Assign(failOnUnsupportedField, (a, v) => a.FailOnUnsupportedFieldValue = v);
		public MoreLikeThisQueryDescriptor Fields(IEnumerable<string>? fields) => Assign(fields, (a, v) => a.FieldsValue = v);
		public MoreLikeThisQueryDescriptor Include(bool? include = true) => Assign(include, (a, v) => a.IncludeValue = v);
		public MoreLikeThisQueryDescriptor Like(Elastic.Clients.Elasticsearch.QueryDsl.Like like) => Assign(like, (a, v) => a.LikeValue = v);
		public MoreLikeThisQueryDescriptor MaxDocFreq(int? maxDocFreq) => Assign(maxDocFreq, (a, v) => a.MaxDocFreqValue = v);
		public MoreLikeThisQueryDescriptor MaxQueryTerms(int? maxQueryTerms) => Assign(maxQueryTerms, (a, v) => a.MaxQueryTermsValue = v);
		public MoreLikeThisQueryDescriptor MaxWordLength(int? maxWordLength) => Assign(maxWordLength, (a, v) => a.MaxWordLengthValue = v);
		public MoreLikeThisQueryDescriptor MinDocFreq(int? minDocFreq) => Assign(minDocFreq, (a, v) => a.MinDocFreqValue = v);
		public MoreLikeThisQueryDescriptor MinimumShouldMatch(Elastic.Clients.Elasticsearch.MinimumShouldMatch? minimumShouldMatch) => Assign(minimumShouldMatch, (a, v) => a.MinimumShouldMatchValue = v);
		public MoreLikeThisQueryDescriptor MinTermFreq(int? minTermFreq) => Assign(minTermFreq, (a, v) => a.MinTermFreqValue = v);
		public MoreLikeThisQueryDescriptor MinWordLength(int? minWordLength) => Assign(minWordLength, (a, v) => a.MinWordLengthValue = v);
		public MoreLikeThisQueryDescriptor PerFieldAnalyzer(Func<FluentDictionary<string?, string?>, FluentDictionary<string?, string?>> selector) => Assign(selector, (a, v) => a.PerFieldAnalyzerValue = v?.Invoke(new FluentDictionary<string?, string?>()));
		public MoreLikeThisQueryDescriptor Routing(string? routing) => Assign(routing, (a, v) => a.RoutingValue = v);
		public MoreLikeThisQueryDescriptor StopWords(Elastic.Clients.Elasticsearch.Analysis.StopWords? stopWords) => Assign(stopWords, (a, v) => a.StopWordsValue = v);
		public MoreLikeThisQueryDescriptor Unlike(Elastic.Clients.Elasticsearch.QueryDsl.Like? unlike) => Assign(unlike, (a, v) => a.UnlikeValue = v);
		public MoreLikeThisQueryDescriptor Version(long? version) => Assign(version, (a, v) => a.VersionValue = v);
		public MoreLikeThisQueryDescriptor VersionType(Elastic.Clients.Elasticsearch.VersionType? versionType) => Assign(versionType, (a, v) => a.VersionTypeValue = v);
	}

	internal sealed class MoreLikeThisQueryDescriptorConverter : JsonConverter<MoreLikeThisQueryDescriptor>
	{
		public override MoreLikeThisQueryDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, MoreLikeThisQueryDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (!string.IsNullOrEmpty(value.AnalyzerValue))
			{
				writer.WritePropertyName("analyzer");
				writer.WriteStringValue(value.AnalyzerValue);
			}

			if (value.BoostTermsValue.HasValue)
			{
				writer.WritePropertyName("boost_terms");
				writer.WriteNumberValue(value.BoostTermsValue.Value);
			}

			if (value.FailOnUnsupportedFieldValue.HasValue)
			{
				writer.WritePropertyName("fail_on_unsupported_field");
				writer.WriteBooleanValue(value.FailOnUnsupportedFieldValue.Value);
			}

			if (value.FieldsValue is not null)
			{
				writer.WritePropertyName("fields");
				JsonSerializer.Serialize(writer, value.FieldsValue, options);
			}

			if (value.IncludeValue.HasValue)
			{
				writer.WritePropertyName("include");
				writer.WriteBooleanValue(value.IncludeValue.Value);
			}

			writer.WritePropertyName("like");
			JsonSerializer.Serialize(writer, value.LikeValue, options);
			if (value.MaxDocFreqValue.HasValue)
			{
				writer.WritePropertyName("max_doc_freq");
				writer.WriteNumberValue(value.MaxDocFreqValue.Value);
			}

			if (value.MaxQueryTermsValue.HasValue)
			{
				writer.WritePropertyName("max_query_terms");
				writer.WriteNumberValue(value.MaxQueryTermsValue.Value);
			}

			if (value.MaxWordLengthValue.HasValue)
			{
				writer.WritePropertyName("max_word_length");
				writer.WriteNumberValue(value.MaxWordLengthValue.Value);
			}

			if (value.MinDocFreqValue.HasValue)
			{
				writer.WritePropertyName("min_doc_freq");
				writer.WriteNumberValue(value.MinDocFreqValue.Value);
			}

			if (value.MinimumShouldMatchValue is not null)
			{
				writer.WritePropertyName("minimum_should_match");
				JsonSerializer.Serialize(writer, value.MinimumShouldMatchValue, options);
			}

			if (value.MinTermFreqValue.HasValue)
			{
				writer.WritePropertyName("min_term_freq");
				writer.WriteNumberValue(value.MinTermFreqValue.Value);
			}

			if (value.MinWordLengthValue.HasValue)
			{
				writer.WritePropertyName("min_word_length");
				writer.WriteNumberValue(value.MinWordLengthValue.Value);
			}

			if (value.PerFieldAnalyzerValue is not null)
			{
				writer.WritePropertyName("per_field_analyzer");
				JsonSerializer.Serialize(writer, value.PerFieldAnalyzerValue, options);
			}

			if (value.RoutingValue is not null)
			{
				writer.WritePropertyName("routing");
				JsonSerializer.Serialize(writer, value.RoutingValue, options);
			}

			if (value.StopWordsValue is not null)
			{
				writer.WritePropertyName("stop_words");
				JsonSerializer.Serialize(writer, value.StopWordsValue, options);
			}

			if (value.UnlikeValue is not null)
			{
				writer.WritePropertyName("unlike");
				JsonSerializer.Serialize(writer, value.UnlikeValue, options);
			}

			if (value.VersionValue is not null)
			{
				writer.WritePropertyName("version");
				JsonSerializer.Serialize(writer, value.VersionValue, options);
			}

			if (value.VersionTypeValue is not null)
			{
				writer.WritePropertyName("version_type");
				JsonSerializer.Serialize(writer, value.VersionTypeValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class MultiMatchQuery : QueryDsl.QueryBase, IQueryContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "multi_match";
		[JsonInclude]
		[JsonPropertyName("analyzer")]
		public string? Analyzer { get; set; }

		[JsonInclude]
		[JsonPropertyName("auto_generate_synonyms_phrase_query")]
		public bool? AutoGenerateSynonymsPhraseQuery { get; set; }

		[JsonInclude]
		[JsonPropertyName("fields")]
		public Elastic.Clients.Elasticsearch.Fields? Fields { get; set; }

		[JsonInclude]
		[JsonPropertyName("fuzziness")]
		public Elastic.Clients.Elasticsearch.Fuzziness? Fuzziness { get; set; }

		[JsonInclude]
		[JsonPropertyName("fuzzy_rewrite")]
		public string? FuzzyRewrite { get; set; }

		[JsonInclude]
		[JsonPropertyName("fuzzy_transpositions")]
		public bool? FuzzyTranspositions { get; set; }

		[JsonInclude]
		[JsonPropertyName("lenient")]
		public bool? Lenient { get; set; }

		[JsonInclude]
		[JsonPropertyName("max_expansions")]
		public int? MaxExpansions { get; set; }

		[JsonInclude]
		[JsonPropertyName("minimum_should_match")]
		public Elastic.Clients.Elasticsearch.MinimumShouldMatch? MinimumShouldMatch { get; set; }

		[JsonInclude]
		[JsonPropertyName("operator")]
		public Elastic.Clients.Elasticsearch.QueryDsl.Operator? Operator { get; set; }

		[JsonInclude]
		[JsonPropertyName("prefix_length")]
		public int? PrefixLength { get; set; }

		[JsonInclude]
		[JsonPropertyName("query")]
		public string Query { get; set; }

		[JsonInclude]
		[JsonPropertyName("slop")]
		public int? Slop { get; set; }

		[JsonInclude]
		[JsonPropertyName("tie_breaker")]
		public double? TieBreaker { get; set; }

		[JsonInclude]
		[JsonPropertyName("type")]
		public Elastic.Clients.Elasticsearch.QueryDsl.TextQueryType? Type { get; set; }

		[JsonInclude]
		[JsonPropertyName("zero_terms_query")]
		public Elastic.Clients.Elasticsearch.QueryDsl.ZeroTermsQuery? ZeroTermsQuery { get; set; }
	}

	[JsonConverter(typeof(MultiMatchQueryDescriptorConverter))]
	public sealed partial class MultiMatchQueryDescriptor : DescriptorBase<MultiMatchQueryDescriptor>, IQueryContainerVariantDescriptor
	{
		public MultiMatchQueryDescriptor()
		{
		}

		internal MultiMatchQueryDescriptor(Action<MultiMatchQueryDescriptor> configure) => configure.Invoke(this);
		internal string? AnalyzerValue { get; private set; }

		internal bool? AutoGenerateSynonymsPhraseQueryValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Fields? FieldsValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Fuzziness? FuzzinessValue { get; private set; }

		internal string? FuzzyRewriteValue { get; private set; }

		internal bool? FuzzyTranspositionsValue { get; private set; }

		internal bool? LenientValue { get; private set; }

		internal int? MaxExpansionsValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.MinimumShouldMatch? MinimumShouldMatchValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.Operator? OperatorValue { get; private set; }

		internal int? PrefixLengthValue { get; private set; }

		internal string QueryValue { get; private set; }

		internal int? SlopValue { get; private set; }

		internal double? TieBreakerValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.TextQueryType? TypeValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.ZeroTermsQuery? ZeroTermsQueryValue { get; private set; }

		public MultiMatchQueryDescriptor Analyzer(string? analyzer) => Assign(analyzer, (a, v) => a.AnalyzerValue = v);
		public MultiMatchQueryDescriptor AutoGenerateSynonymsPhraseQuery(bool? autoGenerateSynonymsPhraseQuery = true) => Assign(autoGenerateSynonymsPhraseQuery, (a, v) => a.AutoGenerateSynonymsPhraseQueryValue = v);
		public MultiMatchQueryDescriptor Fields(Elastic.Clients.Elasticsearch.Fields? fields) => Assign(fields, (a, v) => a.FieldsValue = v);
		public MultiMatchQueryDescriptor Fuzziness(Elastic.Clients.Elasticsearch.Fuzziness? fuzziness) => Assign(fuzziness, (a, v) => a.FuzzinessValue = v);
		public MultiMatchQueryDescriptor FuzzyRewrite(string? fuzzyRewrite) => Assign(fuzzyRewrite, (a, v) => a.FuzzyRewriteValue = v);
		public MultiMatchQueryDescriptor FuzzyTranspositions(bool? fuzzyTranspositions = true) => Assign(fuzzyTranspositions, (a, v) => a.FuzzyTranspositionsValue = v);
		public MultiMatchQueryDescriptor Lenient(bool? lenient = true) => Assign(lenient, (a, v) => a.LenientValue = v);
		public MultiMatchQueryDescriptor MaxExpansions(int? maxExpansions) => Assign(maxExpansions, (a, v) => a.MaxExpansionsValue = v);
		public MultiMatchQueryDescriptor MinimumShouldMatch(Elastic.Clients.Elasticsearch.MinimumShouldMatch? minimumShouldMatch) => Assign(minimumShouldMatch, (a, v) => a.MinimumShouldMatchValue = v);
		public MultiMatchQueryDescriptor Operator(Elastic.Clients.Elasticsearch.QueryDsl.Operator? op) => Assign(op, (a, v) => a.OperatorValue = v);
		public MultiMatchQueryDescriptor PrefixLength(int? prefixLength) => Assign(prefixLength, (a, v) => a.PrefixLengthValue = v);
		public MultiMatchQueryDescriptor Query(string query) => Assign(query, (a, v) => a.QueryValue = v);
		public MultiMatchQueryDescriptor Slop(int? slop) => Assign(slop, (a, v) => a.SlopValue = v);
		public MultiMatchQueryDescriptor TieBreaker(double? tieBreaker) => Assign(tieBreaker, (a, v) => a.TieBreakerValue = v);
		public MultiMatchQueryDescriptor Type(Elastic.Clients.Elasticsearch.QueryDsl.TextQueryType? type) => Assign(type, (a, v) => a.TypeValue = v);
		public MultiMatchQueryDescriptor ZeroTermsQuery(Elastic.Clients.Elasticsearch.QueryDsl.ZeroTermsQuery? zeroTermsQuery) => Assign(zeroTermsQuery, (a, v) => a.ZeroTermsQueryValue = v);
	}

	internal sealed class MultiMatchQueryDescriptorConverter : JsonConverter<MultiMatchQueryDescriptor>
	{
		public override MultiMatchQueryDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, MultiMatchQueryDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (!string.IsNullOrEmpty(value.AnalyzerValue))
			{
				writer.WritePropertyName("analyzer");
				writer.WriteStringValue(value.AnalyzerValue);
			}

			if (value.AutoGenerateSynonymsPhraseQueryValue.HasValue)
			{
				writer.WritePropertyName("auto_generate_synonyms_phrase_query");
				writer.WriteBooleanValue(value.AutoGenerateSynonymsPhraseQueryValue.Value);
			}

			if (value.FieldsValue is not null)
			{
				writer.WritePropertyName("fields");
				JsonSerializer.Serialize(writer, value.FieldsValue, options);
			}

			if (value.FuzzinessValue is not null)
			{
				writer.WritePropertyName("fuzziness");
				JsonSerializer.Serialize(writer, value.FuzzinessValue, options);
			}

			if (value.FuzzyRewriteValue is not null)
			{
				writer.WritePropertyName("fuzzy_rewrite");
				JsonSerializer.Serialize(writer, value.FuzzyRewriteValue, options);
			}

			if (value.FuzzyTranspositionsValue.HasValue)
			{
				writer.WritePropertyName("fuzzy_transpositions");
				writer.WriteBooleanValue(value.FuzzyTranspositionsValue.Value);
			}

			if (value.LenientValue.HasValue)
			{
				writer.WritePropertyName("lenient");
				writer.WriteBooleanValue(value.LenientValue.Value);
			}

			if (value.MaxExpansionsValue.HasValue)
			{
				writer.WritePropertyName("max_expansions");
				writer.WriteNumberValue(value.MaxExpansionsValue.Value);
			}

			if (value.MinimumShouldMatchValue is not null)
			{
				writer.WritePropertyName("minimum_should_match");
				JsonSerializer.Serialize(writer, value.MinimumShouldMatchValue, options);
			}

			if (value.OperatorValue is not null)
			{
				writer.WritePropertyName("operator");
				JsonSerializer.Serialize(writer, value.OperatorValue, options);
			}

			if (value.PrefixLengthValue.HasValue)
			{
				writer.WritePropertyName("prefix_length");
				writer.WriteNumberValue(value.PrefixLengthValue.Value);
			}

			writer.WritePropertyName("query");
			writer.WriteStringValue(value.QueryValue);
			if (value.SlopValue.HasValue)
			{
				writer.WritePropertyName("slop");
				writer.WriteNumberValue(value.SlopValue.Value);
			}

			if (value.TieBreakerValue.HasValue)
			{
				writer.WritePropertyName("tie_breaker");
				writer.WriteNumberValue(value.TieBreakerValue.Value);
			}

			if (value.TypeValue is not null)
			{
				writer.WritePropertyName("type");
				JsonSerializer.Serialize(writer, value.TypeValue, options);
			}

			if (value.ZeroTermsQueryValue is not null)
			{
				writer.WritePropertyName("zero_terms_query");
				JsonSerializer.Serialize(writer, value.ZeroTermsQueryValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class NestedQuery : QueryDsl.QueryBase, IQueryContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "nested";
		[JsonInclude]
		[JsonPropertyName("ignore_unmapped")]
		public bool? IgnoreUnmapped { get; set; }

		[JsonInclude]
		[JsonPropertyName("inner_hits")]
		public Elastic.Clients.Elasticsearch.InnerHits? InnerHits { get; set; }

		[JsonInclude]
		[JsonPropertyName("path")]
		public string Path { get; set; }

		[JsonInclude]
		[JsonPropertyName("query")]
		public Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer Query { get; set; }

		[JsonInclude]
		[JsonPropertyName("score_mode")]
		public Elastic.Clients.Elasticsearch.QueryDsl.NestedScoreMode? ScoreMode { get; set; }
	}

	[JsonConverter(typeof(NestedQueryDescriptorConverter))]
	public sealed partial class NestedQueryDescriptor : DescriptorBase<NestedQueryDescriptor>, IQueryContainerVariantDescriptor
	{
		public NestedQueryDescriptor()
		{
		}

		internal NestedQueryDescriptor(Action<NestedQueryDescriptor> configure) => configure.Invoke(this);
		internal bool? IgnoreUnmappedValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.InnerHits? InnerHitsValue { get; private set; }

		internal string PathValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer QueryValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.NestedScoreMode? ScoreModeValue { get; private set; }

		internal InnerHitsDescriptor InnerHitsDescriptor { get; private set; }

		internal QueryContainerDescriptor QueryDescriptor { get; private set; }

		internal Action<InnerHitsDescriptor> InnerHitsDescriptorAction { get; private set; }

		internal Action<QueryContainerDescriptor> QueryDescriptorAction { get; private set; }

		public NestedQueryDescriptor IgnoreUnmapped(bool? ignoreUnmapped = true) => Assign(ignoreUnmapped, (a, v) => a.IgnoreUnmappedValue = v);
		public NestedQueryDescriptor InnerHits(Elastic.Clients.Elasticsearch.InnerHits? innerHits)
		{
			InnerHitsDescriptor = null;
			InnerHitsDescriptorAction = null;
			return Assign(innerHits, (a, v) => a.InnerHitsValue = v);
		}

		public NestedQueryDescriptor InnerHits(Elastic.Clients.Elasticsearch.InnerHitsDescriptor descriptor)
		{
			InnerHitsValue = null;
			InnerHitsDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.InnerHitsDescriptor = v);
		}

		public NestedQueryDescriptor InnerHits(Action<Elastic.Clients.Elasticsearch.InnerHitsDescriptor> configure)
		{
			InnerHitsValue = null;
			InnerHitsDescriptorAction = null;
			return Assign(configure, (a, v) => a.InnerHitsDescriptorAction = v);
		}

		public NestedQueryDescriptor Path(string path) => Assign(path, (a, v) => a.PathValue = v);
		public NestedQueryDescriptor Query(Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer query)
		{
			QueryDescriptor = null;
			QueryDescriptorAction = null;
			return Assign(query, (a, v) => a.QueryValue = v);
		}

		public NestedQueryDescriptor Query(Elastic.Clients.Elasticsearch.QueryDsl.QueryContainerDescriptor descriptor)
		{
			QueryValue = null;
			QueryDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.QueryDescriptor = v);
		}

		public NestedQueryDescriptor Query(Action<Elastic.Clients.Elasticsearch.QueryDsl.QueryContainerDescriptor> configure)
		{
			QueryValue = null;
			QueryDescriptorAction = null;
			return Assign(configure, (a, v) => a.QueryDescriptorAction = v);
		}

		public NestedQueryDescriptor ScoreMode(Elastic.Clients.Elasticsearch.QueryDsl.NestedScoreMode? scoreMode) => Assign(scoreMode, (a, v) => a.ScoreModeValue = v);
	}

	internal sealed class NestedQueryDescriptorConverter : JsonConverter<NestedQueryDescriptor>
	{
		public override NestedQueryDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, NestedQueryDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value.IgnoreUnmappedValue.HasValue)
			{
				writer.WritePropertyName("ignore_unmapped");
				writer.WriteBooleanValue(value.IgnoreUnmappedValue.Value);
			}

			if (value.InnerHitsDescriptor is not null)
			{
				writer.WritePropertyName("inner_hits");
				JsonSerializer.Serialize(writer, value.InnerHitsDescriptor, options);
			}
			else if (value.InnerHitsDescriptorAction is not null)
			{
				writer.WritePropertyName("inner_hits");
				JsonSerializer.Serialize(writer, new InnerHitsDescriptor(value.InnerHitsDescriptorAction), options);
			}
			else if (value.InnerHitsValue is not null)
			{
				writer.WritePropertyName("inner_hits");
				JsonSerializer.Serialize(writer, value.InnerHitsValue, options);
			}

			writer.WritePropertyName("path");
			JsonSerializer.Serialize(writer, value.PathValue, options);
			if (value.QueryDescriptor is not null)
			{
				writer.WritePropertyName("query");
				JsonSerializer.Serialize(writer, value.QueryDescriptor, options);
			}
			else if (value.QueryDescriptorAction is not null)
			{
				writer.WritePropertyName("query");
				JsonSerializer.Serialize(writer, new QueryContainerDescriptor(value.QueryDescriptorAction), options);
			}
			else
			{
				writer.WritePropertyName("query");
				JsonSerializer.Serialize(writer, value.QueryValue, options);
			}

			if (value.ScoreModeValue is not null)
			{
				writer.WritePropertyName("score_mode");
				JsonSerializer.Serialize(writer, value.ScoreModeValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class ParentIdQuery : QueryDsl.QueryBase, IQueryContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "parent_id";
		[JsonInclude]
		[JsonPropertyName("id")]
		public Elastic.Clients.Elasticsearch.Id? Id { get; set; }

		[JsonInclude]
		[JsonPropertyName("ignore_unmapped")]
		public bool? IgnoreUnmapped { get; set; }

		[JsonInclude]
		[JsonPropertyName("type")]
		public string? Type { get; set; }
	}

	[JsonConverter(typeof(ParentIdQueryDescriptorConverter))]
	public sealed partial class ParentIdQueryDescriptor : DescriptorBase<ParentIdQueryDescriptor>, IQueryContainerVariantDescriptor
	{
		public ParentIdQueryDescriptor()
		{
		}

		internal ParentIdQueryDescriptor(Action<ParentIdQueryDescriptor> configure) => configure.Invoke(this);
		internal Elastic.Clients.Elasticsearch.Id? IdValue { get; private set; }

		internal bool? IgnoreUnmappedValue { get; private set; }

		internal string? TypeValue { get; private set; }

		public ParentIdQueryDescriptor Id(Elastic.Clients.Elasticsearch.Id? id) => Assign(id, (a, v) => a.IdValue = v);
		public ParentIdQueryDescriptor IgnoreUnmapped(bool? ignoreUnmapped = true) => Assign(ignoreUnmapped, (a, v) => a.IgnoreUnmappedValue = v);
		public ParentIdQueryDescriptor Type(string? type) => Assign(type, (a, v) => a.TypeValue = v);
	}

	internal sealed class ParentIdQueryDescriptorConverter : JsonConverter<ParentIdQueryDescriptor>
	{
		public override ParentIdQueryDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, ParentIdQueryDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value.IdValue is not null)
			{
				writer.WritePropertyName("id");
				JsonSerializer.Serialize(writer, value.IdValue, options);
			}

			if (value.IgnoreUnmappedValue.HasValue)
			{
				writer.WritePropertyName("ignore_unmapped");
				writer.WriteBooleanValue(value.IgnoreUnmappedValue.Value);
			}

			if (value.TypeValue is not null)
			{
				writer.WritePropertyName("type");
				JsonSerializer.Serialize(writer, value.TypeValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class PercolateQuery : QueryDsl.QueryBase, IQueryContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "percolate";
		[JsonInclude]
		[JsonPropertyName("document")]
		public object? Document { get; set; }

		[JsonInclude]
		[JsonPropertyName("documents")]
		public IEnumerable<object>? Documents { get; set; }

		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("id")]
		public Elastic.Clients.Elasticsearch.Id? Id { get; set; }

		[JsonInclude]
		[JsonPropertyName("index")]
		public Elastic.Clients.Elasticsearch.IndexName? Index { get; set; }

		[JsonInclude]
		[JsonPropertyName("name")]
		public string? Name { get; set; }

		[JsonInclude]
		[JsonPropertyName("preference")]
		public string? Preference { get; set; }

		[JsonInclude]
		[JsonPropertyName("routing")]
		public string? Routing { get; set; }

		[JsonInclude]
		[JsonPropertyName("version")]
		public long? Version { get; set; }
	}

	[JsonConverter(typeof(PercolateQueryDescriptorConverter))]
	public sealed partial class PercolateQueryDescriptor : DescriptorBase<PercolateQueryDescriptor>, IQueryContainerVariantDescriptor
	{
		public PercolateQueryDescriptor()
		{
		}

		internal PercolateQueryDescriptor(Action<PercolateQueryDescriptor> configure) => configure.Invoke(this);
		internal object? DocumentValue { get; private set; }

		internal IEnumerable<object>? DocumentsValue { get; private set; }

		internal string FieldValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Id? IdValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.IndexName? IndexValue { get; private set; }

		internal string? NameValue { get; private set; }

		internal string? PreferenceValue { get; private set; }

		internal string? RoutingValue { get; private set; }

		internal long? VersionValue { get; private set; }

		public PercolateQueryDescriptor Document(object? document) => Assign(document, (a, v) => a.DocumentValue = v);
		public PercolateQueryDescriptor Documents(IEnumerable<object>? documents) => Assign(documents, (a, v) => a.DocumentsValue = v);
		public PercolateQueryDescriptor Field(string field) => Assign(field, (a, v) => a.FieldValue = v);
		public PercolateQueryDescriptor Id(Elastic.Clients.Elasticsearch.Id? id) => Assign(id, (a, v) => a.IdValue = v);
		public PercolateQueryDescriptor Index(Elastic.Clients.Elasticsearch.IndexName? index) => Assign(index, (a, v) => a.IndexValue = v);
		public PercolateQueryDescriptor Name(string? name) => Assign(name, (a, v) => a.NameValue = v);
		public PercolateQueryDescriptor Preference(string? preference) => Assign(preference, (a, v) => a.PreferenceValue = v);
		public PercolateQueryDescriptor Routing(string? routing) => Assign(routing, (a, v) => a.RoutingValue = v);
		public PercolateQueryDescriptor Version(long? version) => Assign(version, (a, v) => a.VersionValue = v);
	}

	internal sealed class PercolateQueryDescriptorConverter : JsonConverter<PercolateQueryDescriptor>
	{
		public override PercolateQueryDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, PercolateQueryDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value.DocumentsValue is not null)
			{
				writer.WritePropertyName("documents");
				JsonSerializer.Serialize(writer, value.DocumentsValue, options);
			}

			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, value.FieldValue, options);
			if (value.IdValue is not null)
			{
				writer.WritePropertyName("id");
				JsonSerializer.Serialize(writer, value.IdValue, options);
			}

			if (value.IndexValue is not null)
			{
				writer.WritePropertyName("index");
				JsonSerializer.Serialize(writer, value.IndexValue, options);
			}

			if (!string.IsNullOrEmpty(value.NameValue))
			{
				writer.WritePropertyName("name");
				writer.WriteStringValue(value.NameValue);
			}

			if (!string.IsNullOrEmpty(value.PreferenceValue))
			{
				writer.WritePropertyName("preference");
				writer.WriteStringValue(value.PreferenceValue);
			}

			if (value.RoutingValue is not null)
			{
				writer.WritePropertyName("routing");
				JsonSerializer.Serialize(writer, value.RoutingValue, options);
			}

			if (value.VersionValue is not null)
			{
				writer.WritePropertyName("version");
				JsonSerializer.Serialize(writer, value.VersionValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public interface IPinnedQueryVariant
	{
		string PinnedQueryVariantName { get; }
	}

	internal interface IPinnedQueryVariantDescriptor
	{
	}

	[JsonConverter(typeof(PinnedQueryConverter))]
	public partial class PinnedQuery : QueryDsl.QueryBase, IContainer, IQueryContainerVariant
	{
		public PinnedQuery(IPinnedQueryVariant variant) => Variant = variant ?? throw new ArgumentNullException(nameof(variant));
		internal IPinnedQueryVariant Variant { get; }

		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "pinned";
		[JsonInclude]
		[JsonPropertyName("organic")]
		public Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer Organic { get; set; }
	}

	internal sealed class PinnedQueryConverter : JsonConverter<PinnedQuery>
	{
		public override PinnedQuery Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			reader.Read();
			if (reader.TokenType != JsonTokenType.PropertyName)
			{
				throw new JsonException();
			}

			var propertyName = reader.GetString();
			throw new JsonException();
		}

		public override void Write(Utf8JsonWriter writer, PinnedQuery value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName(value.Variant.PinnedQueryVariantName);
			writer.WriteEndObject();
		}
	}

	public sealed partial class PinnedQueryDescriptor : DescriptorBase<PinnedQueryDescriptor>
	{
		public PinnedQueryDescriptor()
		{
		}

		internal PinnedQueryDescriptor(Action<PinnedQueryDescriptor> configure) => configure.Invoke(this);
	}

	internal sealed class PinnedQueryDescriptorConverter : JsonConverter<PinnedQueryDescriptor>
	{
		public override PinnedQueryDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, PinnedQueryDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WriteEndObject();
		}
	}

	public partial class PrefixQuery : FieldNameQueryBase, IQueryContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "prefix";
		[JsonInclude]
		[JsonPropertyName("rewrite")]
		public string? Rewrite { get; set; }

		[JsonInclude]
		[JsonPropertyName("value")]
		public string Value { get; set; }

		[JsonInclude]
		[JsonPropertyName("case_insensitive")]
		public bool? CaseInsensitive { get; set; }
	}

	[JsonConverter(typeof(PrefixQueryDescriptorConverter))]
	public sealed partial class PrefixQueryDescriptor : DescriptorBase<PrefixQueryDescriptor>, IQueryContainerVariantDescriptor
	{
		public PrefixQueryDescriptor()
		{
		}

		internal PrefixQueryDescriptor(Action<PrefixQueryDescriptor> configure) => configure.Invoke(this);
		internal string? RewriteValue { get; private set; }

		internal string ValueValue { get; private set; }

		internal bool? CaseInsensitiveValue { get; private set; }

		public PrefixQueryDescriptor Rewrite(string? rewrite) => Assign(rewrite, (a, v) => a.RewriteValue = v);
		public PrefixQueryDescriptor Value(string value) => Assign(value, (a, v) => a.ValueValue = v);
		public PrefixQueryDescriptor CaseInsensitive(bool? caseInsensitive = true) => Assign(caseInsensitive, (a, v) => a.CaseInsensitiveValue = v);
	}

	internal sealed class PrefixQueryDescriptorConverter : JsonConverter<PrefixQueryDescriptor>
	{
		public override PrefixQueryDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, PrefixQueryDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value.RewriteValue is not null)
			{
				writer.WritePropertyName("rewrite");
				JsonSerializer.Serialize(writer, value.RewriteValue, options);
			}

			writer.WritePropertyName("value");
			writer.WriteStringValue(value.ValueValue);
			if (value.CaseInsensitiveValue.HasValue)
			{
				writer.WritePropertyName("case_insensitive");
				writer.WriteBooleanValue(value.CaseInsensitiveValue.Value);
			}

			writer.WriteEndObject();
		}
	}

	public abstract partial class QueryBase
	{
		[JsonInclude]
		[JsonPropertyName("boost")]
		public float? Boost { get; set; }

		[JsonInclude]
		[JsonPropertyName("_name")]
		public string? QueryName { get; set; }
	}

	[JsonConverter(typeof(QueryBaseDescriptorConverter))]
	public sealed partial class QueryBaseDescriptor : DescriptorBase<QueryBaseDescriptor>
	{
		public QueryBaseDescriptor()
		{
		}

		internal QueryBaseDescriptor(Action<QueryBaseDescriptor> configure) => configure.Invoke(this);
		internal float? BoostValue { get; private set; }

		internal string? QueryNameValue { get; private set; }

		public QueryBaseDescriptor Boost(float? boost) => Assign(boost, (a, v) => a.BoostValue = v);
		public QueryBaseDescriptor QueryName(string? queryName) => Assign(queryName, (a, v) => a.QueryNameValue = v);
	}

	internal sealed class QueryBaseDescriptorConverter : JsonConverter<QueryBaseDescriptor>
	{
		public override QueryBaseDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, QueryBaseDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value.BoostValue.HasValue)
			{
				writer.WritePropertyName("boost");
				writer.WriteNumberValue(value.BoostValue.Value);
			}

			if (!string.IsNullOrEmpty(value.QueryNameValue))
			{
				writer.WritePropertyName("_name");
				writer.WriteStringValue(value.QueryNameValue);
			}

			writer.WriteEndObject();
		}
	}

	public interface IQueryContainerVariant
	{
		string QueryContainerVariantName { get; }
	}

	internal interface IQueryContainerVariantDescriptor
	{
	}

	[JsonConverter(typeof(QueryContainerConverter))]
	public partial class QueryContainer : IContainer, Aggregations.IAggregationContainerVariant
	{
		public QueryContainer(IQueryContainerVariant variant) => Variant = variant ?? throw new ArgumentNullException(nameof(variant));
		internal IQueryContainerVariant Variant { get; }

		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "filter";
	}

	internal sealed class QueryContainerConverter : JsonConverter<QueryContainer>
	{
		public override QueryContainer Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			reader.Read();
			if (reader.TokenType != JsonTokenType.PropertyName)
			{
				throw new JsonException();
			}

			var propertyName = reader.GetString();
			if (propertyName == "bool")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.BoolQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "boosting")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.BoostingQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "combined_fields")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.CombinedFieldsQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "constant_score")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.ConstantScoreQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "dis_max")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.DisMaxQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "exists")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.ExistsQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "function_score")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.FunctionScoreQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "fuzzy")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.FuzzyQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "geo_bounding_box")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.GeoBoundingBoxQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "geo_distance")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.GeoDistanceQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "geo_polygon")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.GeoPolygonQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "geo_shape")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.GeoShapeQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "has_child")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.HasChildQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "has_parent")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.HasParentQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "ids")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.IdsQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "intervals")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.IntervalsQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "match")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.MatchQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "match_all")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.MatchAllQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "match_bool_prefix")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.MatchBoolPrefixQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "match_none")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.MatchNoneQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "match_phrase")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.MatchPhraseQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "match_phrase_prefix")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.MatchPhrasePrefixQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "more_like_this")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.MoreLikeThisQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "multi_match")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.MultiMatchQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "nested")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.NestedQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "parent_id")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.ParentIdQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "percolate")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.PercolateQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "pinned")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.PinnedQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "prefix")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.PrefixQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "query_string")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.QueryStringQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "rank_feature")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.RankFeatureQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "regexp")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.RegexpQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "script")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.ScriptQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "script_score")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.ScriptScoreQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "shape")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.ShapeQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "simple_query_string")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.SimpleQueryStringQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "span_containing")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.SpanContainingQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "field_masking_span")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.SpanFieldMaskingQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "span_first")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.SpanFirstQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "span_multi")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.SpanMultiTermQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "span_near")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.SpanNearQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "span_not")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.SpanNotQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "span_or")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.SpanOrQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "span_term")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.SpanTermQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "span_within")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.SpanWithinQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "term")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.TermQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "terms")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.TermsQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "terms_set")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.TermsSetQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "wildcard")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.WildcardQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			throw new JsonException();
		}

		public override void Write(Utf8JsonWriter writer, QueryContainer value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName(value.Variant.QueryContainerVariantName);
			switch (value.Variant)
			{
				case Elastic.Clients.Elasticsearch.QueryDsl.BoolQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.BoostingQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.CombinedFieldsQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.ConstantScoreQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.DisMaxQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.ExistsQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.FunctionScoreQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.FuzzyQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.GeoBoundingBoxQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.GeoDistanceQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.GeoPolygonQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.GeoShapeQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.HasChildQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.HasParentQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.IdsQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.IntervalsQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.MatchQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.MatchAllQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.MatchBoolPrefixQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.MatchNoneQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.MatchPhraseQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.MatchPhrasePrefixQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.MoreLikeThisQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.MultiMatchQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.NestedQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.ParentIdQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.PercolateQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.PinnedQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.PrefixQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.QueryStringQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.RankFeatureQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.RegexpQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.ScriptQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.ScriptScoreQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.ShapeQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.SimpleQueryStringQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.SpanContainingQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.SpanFieldMaskingQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.SpanFirstQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.SpanMultiTermQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.SpanNearQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.SpanNotQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.SpanOrQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.SpanTermQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.SpanWithinQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.TermQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.TermsQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.TermsSetQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.WildcardQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
			}

			writer.WriteEndObject();
		}
	}

	[JsonConverter(typeof(QueryContainerDescriptorConverter))]
	public sealed partial class QueryContainerDescriptor : DescriptorBase<QueryContainerDescriptor>
	{
		public QueryContainerDescriptor()
		{
		}

		internal QueryContainerDescriptor(Action<QueryContainerDescriptor> configure) => configure.Invoke(this);
	}

	//internal sealed class QueryContainerDescriptorConverter : JsonConverter<QueryContainerDescriptor>
	//{
	//	public override QueryContainerDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
	//	public override void Write(Utf8JsonWriter writer, QueryContainerDescriptor value, JsonSerializerOptions options)
	//	{
	//		writer.WriteStartObject();
	//		writer.WriteEndObject();
	//	}
	//}

	public partial class QueryStringQuery : QueryDsl.QueryBase, IQueryContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "query_string";
		[JsonInclude]
		[JsonPropertyName("allow_leading_wildcard")]
		public bool? AllowLeadingWildcard { get; set; }

		[JsonInclude]
		[JsonPropertyName("analyzer")]
		public string? Analyzer { get; set; }

		[JsonInclude]
		[JsonPropertyName("analyze_wildcard")]
		public bool? AnalyzeWildcard { get; set; }

		[JsonInclude]
		[JsonPropertyName("auto_generate_synonyms_phrase_query")]
		public bool? AutoGenerateSynonymsPhraseQuery { get; set; }

		[JsonInclude]
		[JsonPropertyName("default_field")]
		public string? DefaultField { get; set; }

		[JsonInclude]
		[JsonPropertyName("default_operator")]
		public Elastic.Clients.Elasticsearch.QueryDsl.Operator? DefaultOperator { get; set; }

		[JsonInclude]
		[JsonPropertyName("enable_position_increments")]
		public bool? EnablePositionIncrements { get; set; }

		[JsonInclude]
		[JsonPropertyName("escape")]
		public bool? Escape { get; set; }

		[JsonInclude]
		[JsonPropertyName("fields")]
		public IEnumerable<string>? Fields { get; set; }

		[JsonInclude]
		[JsonPropertyName("fuzziness")]
		public Elastic.Clients.Elasticsearch.Fuzziness? Fuzziness { get; set; }

		[JsonInclude]
		[JsonPropertyName("fuzzy_max_expansions")]
		public int? FuzzyMaxExpansions { get; set; }

		[JsonInclude]
		[JsonPropertyName("fuzzy_prefix_length")]
		public int? FuzzyPrefixLength { get; set; }

		[JsonInclude]
		[JsonPropertyName("fuzzy_rewrite")]
		public string? FuzzyRewrite { get; set; }

		[JsonInclude]
		[JsonPropertyName("fuzzy_transpositions")]
		public bool? FuzzyTranspositions { get; set; }

		[JsonInclude]
		[JsonPropertyName("lenient")]
		public bool? Lenient { get; set; }

		[JsonInclude]
		[JsonPropertyName("max_determinized_states")]
		public int? MaxDeterminizedStates { get; set; }

		[JsonInclude]
		[JsonPropertyName("minimum_should_match")]
		public Elastic.Clients.Elasticsearch.MinimumShouldMatch? MinimumShouldMatch { get; set; }

		[JsonInclude]
		[JsonPropertyName("phrase_slop")]
		public double? PhraseSlop { get; set; }

		[JsonInclude]
		[JsonPropertyName("query")]
		public string Query { get; set; }

		[JsonInclude]
		[JsonPropertyName("quote_analyzer")]
		public string? QuoteAnalyzer { get; set; }

		[JsonInclude]
		[JsonPropertyName("quote_field_suffix")]
		public string? QuoteFieldSuffix { get; set; }

		[JsonInclude]
		[JsonPropertyName("rewrite")]
		public string? Rewrite { get; set; }

		[JsonInclude]
		[JsonPropertyName("tie_breaker")]
		public double? TieBreaker { get; set; }

		[JsonInclude]
		[JsonPropertyName("time_zone")]
		public string? TimeZone { get; set; }

		[JsonInclude]
		[JsonPropertyName("type")]
		public Elastic.Clients.Elasticsearch.QueryDsl.TextQueryType? Type { get; set; }
	}

	[JsonConverter(typeof(QueryStringQueryDescriptorConverter))]
	public sealed partial class QueryStringQueryDescriptor : DescriptorBase<QueryStringQueryDescriptor>, IQueryContainerVariantDescriptor
	{
		public QueryStringQueryDescriptor()
		{
		}

		internal QueryStringQueryDescriptor(Action<QueryStringQueryDescriptor> configure) => configure.Invoke(this);
		internal bool? AllowLeadingWildcardValue { get; private set; }

		internal string? AnalyzerValue { get; private set; }

		internal bool? AnalyzeWildcardValue { get; private set; }

		internal bool? AutoGenerateSynonymsPhraseQueryValue { get; private set; }

		internal string? DefaultFieldValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.Operator? DefaultOperatorValue { get; private set; }

		internal bool? EnablePositionIncrementsValue { get; private set; }

		internal bool? EscapeValue { get; private set; }

		internal IEnumerable<string>? FieldsValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Fuzziness? FuzzinessValue { get; private set; }

		internal int? FuzzyMaxExpansionsValue { get; private set; }

		internal int? FuzzyPrefixLengthValue { get; private set; }

		internal string? FuzzyRewriteValue { get; private set; }

		internal bool? FuzzyTranspositionsValue { get; private set; }

		internal bool? LenientValue { get; private set; }

		internal int? MaxDeterminizedStatesValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.MinimumShouldMatch? MinimumShouldMatchValue { get; private set; }

		internal double? PhraseSlopValue { get; private set; }

		internal string QueryValue { get; private set; }

		internal string? QuoteAnalyzerValue { get; private set; }

		internal string? QuoteFieldSuffixValue { get; private set; }

		internal string? RewriteValue { get; private set; }

		internal double? TieBreakerValue { get; private set; }

		internal string? TimeZoneValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.TextQueryType? TypeValue { get; private set; }

		public QueryStringQueryDescriptor AllowLeadingWildcard(bool? allowLeadingWildcard = true) => Assign(allowLeadingWildcard, (a, v) => a.AllowLeadingWildcardValue = v);
		public QueryStringQueryDescriptor Analyzer(string? analyzer) => Assign(analyzer, (a, v) => a.AnalyzerValue = v);
		public QueryStringQueryDescriptor AnalyzeWildcard(bool? analyzeWildcard = true) => Assign(analyzeWildcard, (a, v) => a.AnalyzeWildcardValue = v);
		public QueryStringQueryDescriptor AutoGenerateSynonymsPhraseQuery(bool? autoGenerateSynonymsPhraseQuery = true) => Assign(autoGenerateSynonymsPhraseQuery, (a, v) => a.AutoGenerateSynonymsPhraseQueryValue = v);
		public QueryStringQueryDescriptor DefaultField(string? defaultField) => Assign(defaultField, (a, v) => a.DefaultFieldValue = v);
		public QueryStringQueryDescriptor DefaultOperator(Elastic.Clients.Elasticsearch.QueryDsl.Operator? defaultOperator) => Assign(defaultOperator, (a, v) => a.DefaultOperatorValue = v);
		public QueryStringQueryDescriptor EnablePositionIncrements(bool? enablePositionIncrements = true) => Assign(enablePositionIncrements, (a, v) => a.EnablePositionIncrementsValue = v);
		public QueryStringQueryDescriptor Escape(bool? escape = true) => Assign(escape, (a, v) => a.EscapeValue = v);
		public QueryStringQueryDescriptor Fields(IEnumerable<string>? fields) => Assign(fields, (a, v) => a.FieldsValue = v);
		public QueryStringQueryDescriptor Fuzziness(Elastic.Clients.Elasticsearch.Fuzziness? fuzziness) => Assign(fuzziness, (a, v) => a.FuzzinessValue = v);
		public QueryStringQueryDescriptor FuzzyMaxExpansions(int? fuzzyMaxExpansions) => Assign(fuzzyMaxExpansions, (a, v) => a.FuzzyMaxExpansionsValue = v);
		public QueryStringQueryDescriptor FuzzyPrefixLength(int? fuzzyPrefixLength) => Assign(fuzzyPrefixLength, (a, v) => a.FuzzyPrefixLengthValue = v);
		public QueryStringQueryDescriptor FuzzyRewrite(string? fuzzyRewrite) => Assign(fuzzyRewrite, (a, v) => a.FuzzyRewriteValue = v);
		public QueryStringQueryDescriptor FuzzyTranspositions(bool? fuzzyTranspositions = true) => Assign(fuzzyTranspositions, (a, v) => a.FuzzyTranspositionsValue = v);
		public QueryStringQueryDescriptor Lenient(bool? lenient = true) => Assign(lenient, (a, v) => a.LenientValue = v);
		public QueryStringQueryDescriptor MaxDeterminizedStates(int? maxDeterminizedStates) => Assign(maxDeterminizedStates, (a, v) => a.MaxDeterminizedStatesValue = v);
		public QueryStringQueryDescriptor MinimumShouldMatch(Elastic.Clients.Elasticsearch.MinimumShouldMatch? minimumShouldMatch) => Assign(minimumShouldMatch, (a, v) => a.MinimumShouldMatchValue = v);
		public QueryStringQueryDescriptor PhraseSlop(double? phraseSlop) => Assign(phraseSlop, (a, v) => a.PhraseSlopValue = v);
		public QueryStringQueryDescriptor Query(string query) => Assign(query, (a, v) => a.QueryValue = v);
		public QueryStringQueryDescriptor QuoteAnalyzer(string? quoteAnalyzer) => Assign(quoteAnalyzer, (a, v) => a.QuoteAnalyzerValue = v);
		public QueryStringQueryDescriptor QuoteFieldSuffix(string? quoteFieldSuffix) => Assign(quoteFieldSuffix, (a, v) => a.QuoteFieldSuffixValue = v);
		public QueryStringQueryDescriptor Rewrite(string? rewrite) => Assign(rewrite, (a, v) => a.RewriteValue = v);
		public QueryStringQueryDescriptor TieBreaker(double? tieBreaker) => Assign(tieBreaker, (a, v) => a.TieBreakerValue = v);
		public QueryStringQueryDescriptor TimeZone(string? timeZone) => Assign(timeZone, (a, v) => a.TimeZoneValue = v);
		public QueryStringQueryDescriptor Type(Elastic.Clients.Elasticsearch.QueryDsl.TextQueryType? type) => Assign(type, (a, v) => a.TypeValue = v);
	}

	internal sealed class QueryStringQueryDescriptorConverter : JsonConverter<QueryStringQueryDescriptor>
	{
		public override QueryStringQueryDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, QueryStringQueryDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value.AllowLeadingWildcardValue.HasValue)
			{
				writer.WritePropertyName("allow_leading_wildcard");
				writer.WriteBooleanValue(value.AllowLeadingWildcardValue.Value);
			}

			if (!string.IsNullOrEmpty(value.AnalyzerValue))
			{
				writer.WritePropertyName("analyzer");
				writer.WriteStringValue(value.AnalyzerValue);
			}

			if (value.AnalyzeWildcardValue.HasValue)
			{
				writer.WritePropertyName("analyze_wildcard");
				writer.WriteBooleanValue(value.AnalyzeWildcardValue.Value);
			}

			if (value.AutoGenerateSynonymsPhraseQueryValue.HasValue)
			{
				writer.WritePropertyName("auto_generate_synonyms_phrase_query");
				writer.WriteBooleanValue(value.AutoGenerateSynonymsPhraseQueryValue.Value);
			}

			if (value.DefaultFieldValue is not null)
			{
				writer.WritePropertyName("default_field");
				JsonSerializer.Serialize(writer, value.DefaultFieldValue, options);
			}

			if (value.DefaultOperatorValue is not null)
			{
				writer.WritePropertyName("default_operator");
				JsonSerializer.Serialize(writer, value.DefaultOperatorValue, options);
			}

			if (value.EnablePositionIncrementsValue.HasValue)
			{
				writer.WritePropertyName("enable_position_increments");
				writer.WriteBooleanValue(value.EnablePositionIncrementsValue.Value);
			}

			if (value.EscapeValue.HasValue)
			{
				writer.WritePropertyName("escape");
				writer.WriteBooleanValue(value.EscapeValue.Value);
			}

			if (value.FieldsValue is not null)
			{
				writer.WritePropertyName("fields");
				JsonSerializer.Serialize(writer, value.FieldsValue, options);
			}

			if (value.FuzzinessValue is not null)
			{
				writer.WritePropertyName("fuzziness");
				JsonSerializer.Serialize(writer, value.FuzzinessValue, options);
			}

			if (value.FuzzyMaxExpansionsValue.HasValue)
			{
				writer.WritePropertyName("fuzzy_max_expansions");
				writer.WriteNumberValue(value.FuzzyMaxExpansionsValue.Value);
			}

			if (value.FuzzyPrefixLengthValue.HasValue)
			{
				writer.WritePropertyName("fuzzy_prefix_length");
				writer.WriteNumberValue(value.FuzzyPrefixLengthValue.Value);
			}

			if (value.FuzzyRewriteValue is not null)
			{
				writer.WritePropertyName("fuzzy_rewrite");
				JsonSerializer.Serialize(writer, value.FuzzyRewriteValue, options);
			}

			if (value.FuzzyTranspositionsValue.HasValue)
			{
				writer.WritePropertyName("fuzzy_transpositions");
				writer.WriteBooleanValue(value.FuzzyTranspositionsValue.Value);
			}

			if (value.LenientValue.HasValue)
			{
				writer.WritePropertyName("lenient");
				writer.WriteBooleanValue(value.LenientValue.Value);
			}

			if (value.MaxDeterminizedStatesValue.HasValue)
			{
				writer.WritePropertyName("max_determinized_states");
				writer.WriteNumberValue(value.MaxDeterminizedStatesValue.Value);
			}

			if (value.MinimumShouldMatchValue is not null)
			{
				writer.WritePropertyName("minimum_should_match");
				JsonSerializer.Serialize(writer, value.MinimumShouldMatchValue, options);
			}

			if (value.PhraseSlopValue.HasValue)
			{
				writer.WritePropertyName("phrase_slop");
				writer.WriteNumberValue(value.PhraseSlopValue.Value);
			}

			writer.WritePropertyName("query");
			writer.WriteStringValue(value.QueryValue);
			if (!string.IsNullOrEmpty(value.QuoteAnalyzerValue))
			{
				writer.WritePropertyName("quote_analyzer");
				writer.WriteStringValue(value.QuoteAnalyzerValue);
			}

			if (!string.IsNullOrEmpty(value.QuoteFieldSuffixValue))
			{
				writer.WritePropertyName("quote_field_suffix");
				writer.WriteStringValue(value.QuoteFieldSuffixValue);
			}

			if (value.RewriteValue is not null)
			{
				writer.WritePropertyName("rewrite");
				JsonSerializer.Serialize(writer, value.RewriteValue, options);
			}

			if (value.TieBreakerValue.HasValue)
			{
				writer.WritePropertyName("tie_breaker");
				writer.WriteNumberValue(value.TieBreakerValue.Value);
			}

			if (value.TimeZoneValue is not null)
			{
				writer.WritePropertyName("time_zone");
				JsonSerializer.Serialize(writer, value.TimeZoneValue, options);
			}

			if (value.TypeValue is not null)
			{
				writer.WritePropertyName("type");
				JsonSerializer.Serialize(writer, value.TypeValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class RandomScoreFunction : QueryDsl.ScoreFunctionBase, IFunctionScoreContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IFunctionScoreContainerVariant.FunctionScoreContainerVariantName => "random_score";
		[JsonInclude]
		[JsonPropertyName("field")]
		public string? Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("seed")]
		public Union<long?, string?>? Seed { get; set; }
	}

	[JsonConverter(typeof(RandomScoreFunctionDescriptorConverter))]
	public sealed partial class RandomScoreFunctionDescriptor : DescriptorBase<RandomScoreFunctionDescriptor>, IFunctionScoreContainerVariantDescriptor
	{
		public RandomScoreFunctionDescriptor()
		{
		}

		internal RandomScoreFunctionDescriptor(Action<RandomScoreFunctionDescriptor> configure) => configure.Invoke(this);
		internal string? FieldValue { get; private set; }

		internal Union<long?, string?>? SeedValue { get; private set; }

		public RandomScoreFunctionDescriptor Field(string? field) => Assign(field, (a, v) => a.FieldValue = v);
		public RandomScoreFunctionDescriptor Seed(Union<long?, string?>? seed) => Assign(seed, (a, v) => a.SeedValue = v);
	}

	internal sealed class RandomScoreFunctionDescriptorConverter : JsonConverter<RandomScoreFunctionDescriptor>
	{
		public override RandomScoreFunctionDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, RandomScoreFunctionDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value.FieldValue is not null)
			{
				writer.WritePropertyName("field");
				JsonSerializer.Serialize(writer, value.FieldValue, options);
			}

			if (value.SeedValue is not null)
			{
				writer.WritePropertyName("seed");
				JsonSerializer.Serialize(writer, value.SeedValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class RankFeatureFunction
	{
	}

	[JsonConverter(typeof(RankFeatureFunctionDescriptorConverter))]
	public sealed partial class RankFeatureFunctionDescriptor : DescriptorBase<RankFeatureFunctionDescriptor>
	{
		public RankFeatureFunctionDescriptor()
		{
		}

		internal RankFeatureFunctionDescriptor(Action<RankFeatureFunctionDescriptor> configure) => configure.Invoke(this);
	}

	internal sealed class RankFeatureFunctionDescriptorConverter : JsonConverter<RankFeatureFunctionDescriptor>
	{
		public override RankFeatureFunctionDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, RankFeatureFunctionDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WriteEndObject();
		}
	}

	public partial class RankFeatureFunctionLinear : QueryDsl.RankFeatureFunction
	{
	}

	[JsonConverter(typeof(RankFeatureFunctionLinearDescriptorConverter))]
	public sealed partial class RankFeatureFunctionLinearDescriptor : DescriptorBase<RankFeatureFunctionLinearDescriptor>
	{
		public RankFeatureFunctionLinearDescriptor()
		{
		}

		internal RankFeatureFunctionLinearDescriptor(Action<RankFeatureFunctionLinearDescriptor> configure) => configure.Invoke(this);
	}

	internal sealed class RankFeatureFunctionLinearDescriptorConverter : JsonConverter<RankFeatureFunctionLinearDescriptor>
	{
		public override RankFeatureFunctionLinearDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, RankFeatureFunctionLinearDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WriteEndObject();
		}
	}

	public partial class RankFeatureFunctionLogarithm : QueryDsl.RankFeatureFunction
	{
		[JsonInclude]
		[JsonPropertyName("scaling_factor")]
		public float ScalingFactor { get; set; }
	}

	[JsonConverter(typeof(RankFeatureFunctionLogarithmDescriptorConverter))]
	public sealed partial class RankFeatureFunctionLogarithmDescriptor : DescriptorBase<RankFeatureFunctionLogarithmDescriptor>
	{
		public RankFeatureFunctionLogarithmDescriptor()
		{
		}

		internal RankFeatureFunctionLogarithmDescriptor(Action<RankFeatureFunctionLogarithmDescriptor> configure) => configure.Invoke(this);
		internal float ScalingFactorValue { get; private set; }

		public RankFeatureFunctionLogarithmDescriptor ScalingFactor(float scalingFactor) => Assign(scalingFactor, (a, v) => a.ScalingFactorValue = v);
	}

	internal sealed class RankFeatureFunctionLogarithmDescriptorConverter : JsonConverter<RankFeatureFunctionLogarithmDescriptor>
	{
		public override RankFeatureFunctionLogarithmDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, RankFeatureFunctionLogarithmDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("scaling_factor");
			writer.WriteNumberValue(value.ScalingFactorValue);
			writer.WriteEndObject();
		}
	}

	public partial class RankFeatureFunctionSaturation : QueryDsl.RankFeatureFunction
	{
		[JsonInclude]
		[JsonPropertyName("pivot")]
		public float? Pivot { get; set; }
	}

	[JsonConverter(typeof(RankFeatureFunctionSaturationDescriptorConverter))]
	public sealed partial class RankFeatureFunctionSaturationDescriptor : DescriptorBase<RankFeatureFunctionSaturationDescriptor>
	{
		public RankFeatureFunctionSaturationDescriptor()
		{
		}

		internal RankFeatureFunctionSaturationDescriptor(Action<RankFeatureFunctionSaturationDescriptor> configure) => configure.Invoke(this);
		internal float? PivotValue { get; private set; }

		public RankFeatureFunctionSaturationDescriptor Pivot(float? pivot) => Assign(pivot, (a, v) => a.PivotValue = v);
	}

	internal sealed class RankFeatureFunctionSaturationDescriptorConverter : JsonConverter<RankFeatureFunctionSaturationDescriptor>
	{
		public override RankFeatureFunctionSaturationDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, RankFeatureFunctionSaturationDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value.PivotValue.HasValue)
			{
				writer.WritePropertyName("pivot");
				writer.WriteNumberValue(value.PivotValue.Value);
			}

			writer.WriteEndObject();
		}
	}

	public partial class RankFeatureFunctionSigmoid : QueryDsl.RankFeatureFunction
	{
		[JsonInclude]
		[JsonPropertyName("pivot")]
		public float Pivot { get; set; }

		[JsonInclude]
		[JsonPropertyName("exponent")]
		public float Exponent { get; set; }
	}

	[JsonConverter(typeof(RankFeatureFunctionSigmoidDescriptorConverter))]
	public sealed partial class RankFeatureFunctionSigmoidDescriptor : DescriptorBase<RankFeatureFunctionSigmoidDescriptor>
	{
		public RankFeatureFunctionSigmoidDescriptor()
		{
		}

		internal RankFeatureFunctionSigmoidDescriptor(Action<RankFeatureFunctionSigmoidDescriptor> configure) => configure.Invoke(this);
		internal float PivotValue { get; private set; }

		internal float ExponentValue { get; private set; }

		public RankFeatureFunctionSigmoidDescriptor Pivot(float pivot) => Assign(pivot, (a, v) => a.PivotValue = v);
		public RankFeatureFunctionSigmoidDescriptor Exponent(float exponent) => Assign(exponent, (a, v) => a.ExponentValue = v);
	}

	internal sealed class RankFeatureFunctionSigmoidDescriptorConverter : JsonConverter<RankFeatureFunctionSigmoidDescriptor>
	{
		public override RankFeatureFunctionSigmoidDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, RankFeatureFunctionSigmoidDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("pivot");
			writer.WriteNumberValue(value.PivotValue);
			writer.WritePropertyName("exponent");
			writer.WriteNumberValue(value.ExponentValue);
			writer.WriteEndObject();
		}
	}

	public partial class RankFeatureQuery : QueryDsl.QueryBase, IQueryContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "rank_feature";
		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("saturation")]
		public Elastic.Clients.Elasticsearch.QueryDsl.RankFeatureFunctionSaturation? Saturation { get; set; }

		[JsonInclude]
		[JsonPropertyName("log")]
		public Elastic.Clients.Elasticsearch.QueryDsl.RankFeatureFunctionLogarithm? Log { get; set; }

		[JsonInclude]
		[JsonPropertyName("linear")]
		public Elastic.Clients.Elasticsearch.QueryDsl.RankFeatureFunctionLinear? Linear { get; set; }

		[JsonInclude]
		[JsonPropertyName("sigmoid")]
		public Elastic.Clients.Elasticsearch.QueryDsl.RankFeatureFunctionSigmoid? Sigmoid { get; set; }
	}

	[JsonConverter(typeof(RankFeatureQueryDescriptorConverter))]
	public sealed partial class RankFeatureQueryDescriptor : DescriptorBase<RankFeatureQueryDescriptor>, IQueryContainerVariantDescriptor
	{
		public RankFeatureQueryDescriptor()
		{
		}

		internal RankFeatureQueryDescriptor(Action<RankFeatureQueryDescriptor> configure) => configure.Invoke(this);
		internal string FieldValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.RankFeatureFunctionSaturation? SaturationValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.RankFeatureFunctionLogarithm? LogValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.RankFeatureFunctionLinear? LinearValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.RankFeatureFunctionSigmoid? SigmoidValue { get; private set; }

		internal RankFeatureFunctionSaturationDescriptor SaturationDescriptor { get; private set; }

		internal RankFeatureFunctionLogarithmDescriptor LogDescriptor { get; private set; }

		internal RankFeatureFunctionLinearDescriptor LinearDescriptor { get; private set; }

		internal RankFeatureFunctionSigmoidDescriptor SigmoidDescriptor { get; private set; }

		internal Action<RankFeatureFunctionSaturationDescriptor> SaturationDescriptorAction { get; private set; }

		internal Action<RankFeatureFunctionLogarithmDescriptor> LogDescriptorAction { get; private set; }

		internal Action<RankFeatureFunctionLinearDescriptor> LinearDescriptorAction { get; private set; }

		internal Action<RankFeatureFunctionSigmoidDescriptor> SigmoidDescriptorAction { get; private set; }

		public RankFeatureQueryDescriptor Field(string field) => Assign(field, (a, v) => a.FieldValue = v);
		public RankFeatureQueryDescriptor Saturation(Elastic.Clients.Elasticsearch.QueryDsl.RankFeatureFunctionSaturation? saturation)
		{
			SaturationDescriptor = null;
			SaturationDescriptorAction = null;
			return Assign(saturation, (a, v) => a.SaturationValue = v);
		}

		public RankFeatureQueryDescriptor Saturation(Elastic.Clients.Elasticsearch.QueryDsl.RankFeatureFunctionSaturationDescriptor descriptor)
		{
			SaturationValue = null;
			SaturationDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.SaturationDescriptor = v);
		}

		public RankFeatureQueryDescriptor Saturation(Action<Elastic.Clients.Elasticsearch.QueryDsl.RankFeatureFunctionSaturationDescriptor> configure)
		{
			SaturationValue = null;
			SaturationDescriptorAction = null;
			return Assign(configure, (a, v) => a.SaturationDescriptorAction = v);
		}

		public RankFeatureQueryDescriptor Log(Elastic.Clients.Elasticsearch.QueryDsl.RankFeatureFunctionLogarithm? log)
		{
			LogDescriptor = null;
			LogDescriptorAction = null;
			return Assign(log, (a, v) => a.LogValue = v);
		}

		public RankFeatureQueryDescriptor Log(Elastic.Clients.Elasticsearch.QueryDsl.RankFeatureFunctionLogarithmDescriptor descriptor)
		{
			LogValue = null;
			LogDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.LogDescriptor = v);
		}

		public RankFeatureQueryDescriptor Log(Action<Elastic.Clients.Elasticsearch.QueryDsl.RankFeatureFunctionLogarithmDescriptor> configure)
		{
			LogValue = null;
			LogDescriptorAction = null;
			return Assign(configure, (a, v) => a.LogDescriptorAction = v);
		}

		public RankFeatureQueryDescriptor Linear(Elastic.Clients.Elasticsearch.QueryDsl.RankFeatureFunctionLinear? linear)
		{
			LinearDescriptor = null;
			LinearDescriptorAction = null;
			return Assign(linear, (a, v) => a.LinearValue = v);
		}

		public RankFeatureQueryDescriptor Linear(Elastic.Clients.Elasticsearch.QueryDsl.RankFeatureFunctionLinearDescriptor descriptor)
		{
			LinearValue = null;
			LinearDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.LinearDescriptor = v);
		}

		public RankFeatureQueryDescriptor Linear(Action<Elastic.Clients.Elasticsearch.QueryDsl.RankFeatureFunctionLinearDescriptor> configure)
		{
			LinearValue = null;
			LinearDescriptorAction = null;
			return Assign(configure, (a, v) => a.LinearDescriptorAction = v);
		}

		public RankFeatureQueryDescriptor Sigmoid(Elastic.Clients.Elasticsearch.QueryDsl.RankFeatureFunctionSigmoid? sigmoid)
		{
			SigmoidDescriptor = null;
			SigmoidDescriptorAction = null;
			return Assign(sigmoid, (a, v) => a.SigmoidValue = v);
		}

		public RankFeatureQueryDescriptor Sigmoid(Elastic.Clients.Elasticsearch.QueryDsl.RankFeatureFunctionSigmoidDescriptor descriptor)
		{
			SigmoidValue = null;
			SigmoidDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.SigmoidDescriptor = v);
		}

		public RankFeatureQueryDescriptor Sigmoid(Action<Elastic.Clients.Elasticsearch.QueryDsl.RankFeatureFunctionSigmoidDescriptor> configure)
		{
			SigmoidValue = null;
			SigmoidDescriptorAction = null;
			return Assign(configure, (a, v) => a.SigmoidDescriptorAction = v);
		}
	}

	internal sealed class RankFeatureQueryDescriptorConverter : JsonConverter<RankFeatureQueryDescriptor>
	{
		public override RankFeatureQueryDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, RankFeatureQueryDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, value.FieldValue, options);
			if (value.SaturationDescriptor is not null)
			{
				writer.WritePropertyName("saturation");
				JsonSerializer.Serialize(writer, value.SaturationDescriptor, options);
			}
			else if (value.SaturationDescriptorAction is not null)
			{
				writer.WritePropertyName("saturation");
				JsonSerializer.Serialize(writer, new RankFeatureFunctionSaturationDescriptor(value.SaturationDescriptorAction), options);
			}
			else if (value.SaturationValue is not null)
			{
				writer.WritePropertyName("saturation");
				JsonSerializer.Serialize(writer, value.SaturationValue, options);
			}

			if (value.LogDescriptor is not null)
			{
				writer.WritePropertyName("log");
				JsonSerializer.Serialize(writer, value.LogDescriptor, options);
			}
			else if (value.LogDescriptorAction is not null)
			{
				writer.WritePropertyName("log");
				JsonSerializer.Serialize(writer, new RankFeatureFunctionLogarithmDescriptor(value.LogDescriptorAction), options);
			}
			else if (value.LogValue is not null)
			{
				writer.WritePropertyName("log");
				JsonSerializer.Serialize(writer, value.LogValue, options);
			}

			if (value.LinearDescriptor is not null)
			{
				writer.WritePropertyName("linear");
				JsonSerializer.Serialize(writer, value.LinearDescriptor, options);
			}
			else if (value.LinearDescriptorAction is not null)
			{
				writer.WritePropertyName("linear");
				JsonSerializer.Serialize(writer, new RankFeatureFunctionLinearDescriptor(value.LinearDescriptorAction), options);
			}
			else if (value.LinearValue is not null)
			{
				writer.WritePropertyName("linear");
				JsonSerializer.Serialize(writer, value.LinearValue, options);
			}

			if (value.SigmoidDescriptor is not null)
			{
				writer.WritePropertyName("sigmoid");
				JsonSerializer.Serialize(writer, value.SigmoidDescriptor, options);
			}
			else if (value.SigmoidDescriptorAction is not null)
			{
				writer.WritePropertyName("sigmoid");
				JsonSerializer.Serialize(writer, new RankFeatureFunctionSigmoidDescriptor(value.SigmoidDescriptorAction), options);
			}
			else if (value.SigmoidValue is not null)
			{
				writer.WritePropertyName("sigmoid");
				JsonSerializer.Serialize(writer, value.SigmoidValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class RegexpQuery : FieldNameQueryBase, IQueryContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "regexp";
		[JsonInclude]
		[JsonPropertyName("case_insensitive")]
		public bool? CaseInsensitive { get; set; }

		[JsonInclude]
		[JsonPropertyName("flags")]
		public string? Flags { get; set; }

		[JsonInclude]
		[JsonPropertyName("max_determinized_states")]
		public int? MaxDeterminizedStates { get; set; }

		[JsonInclude]
		[JsonPropertyName("rewrite")]
		public string? Rewrite { get; set; }

		[JsonInclude]
		[JsonPropertyName("value")]
		public string Value { get; set; }
	}

	[JsonConverter(typeof(RegexpQueryDescriptorConverter))]
	public sealed partial class RegexpQueryDescriptor : DescriptorBase<RegexpQueryDescriptor>, IQueryContainerVariantDescriptor
	{
		public RegexpQueryDescriptor()
		{
		}

		internal RegexpQueryDescriptor(Action<RegexpQueryDescriptor> configure) => configure.Invoke(this);
		internal bool? CaseInsensitiveValue { get; private set; }

		internal string? FlagsValue { get; private set; }

		internal int? MaxDeterminizedStatesValue { get; private set; }

		internal string? RewriteValue { get; private set; }

		internal string ValueValue { get; private set; }

		public RegexpQueryDescriptor CaseInsensitive(bool? caseInsensitive = true) => Assign(caseInsensitive, (a, v) => a.CaseInsensitiveValue = v);
		public RegexpQueryDescriptor Flags(string? flags) => Assign(flags, (a, v) => a.FlagsValue = v);
		public RegexpQueryDescriptor MaxDeterminizedStates(int? maxDeterminizedStates) => Assign(maxDeterminizedStates, (a, v) => a.MaxDeterminizedStatesValue = v);
		public RegexpQueryDescriptor Rewrite(string? rewrite) => Assign(rewrite, (a, v) => a.RewriteValue = v);
		public RegexpQueryDescriptor Value(string value) => Assign(value, (a, v) => a.ValueValue = v);
	}

	internal sealed class RegexpQueryDescriptorConverter : JsonConverter<RegexpQueryDescriptor>
	{
		public override RegexpQueryDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, RegexpQueryDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value.CaseInsensitiveValue.HasValue)
			{
				writer.WritePropertyName("case_insensitive");
				writer.WriteBooleanValue(value.CaseInsensitiveValue.Value);
			}

			if (!string.IsNullOrEmpty(value.FlagsValue))
			{
				writer.WritePropertyName("flags");
				writer.WriteStringValue(value.FlagsValue);
			}

			if (value.MaxDeterminizedStatesValue.HasValue)
			{
				writer.WritePropertyName("max_determinized_states");
				writer.WriteNumberValue(value.MaxDeterminizedStatesValue.Value);
			}

			if (value.RewriteValue is not null)
			{
				writer.WritePropertyName("rewrite");
				JsonSerializer.Serialize(writer, value.RewriteValue, options);
			}

			writer.WritePropertyName("value");
			writer.WriteStringValue(value.ValueValue);
			writer.WriteEndObject();
		}
	}

	public abstract partial class ScoreFunctionBase
	{
		[JsonInclude]
		[JsonPropertyName("filter")]
		public Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? Filter { get; set; }

		[JsonInclude]
		[JsonPropertyName("weight")]
		public double? Weight { get; set; }
	}

	[JsonConverter(typeof(ScoreFunctionBaseDescriptorConverter))]
	public sealed partial class ScoreFunctionBaseDescriptor : DescriptorBase<ScoreFunctionBaseDescriptor>
	{
		public ScoreFunctionBaseDescriptor()
		{
		}

		internal ScoreFunctionBaseDescriptor(Action<ScoreFunctionBaseDescriptor> configure) => configure.Invoke(this);
		internal Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? FilterValue { get; private set; }

		internal double? WeightValue { get; private set; }

		internal QueryContainerDescriptor FilterDescriptor { get; private set; }

		internal Action<QueryContainerDescriptor> FilterDescriptorAction { get; private set; }

		public ScoreFunctionBaseDescriptor Filter(Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? filter)
		{
			FilterDescriptor = null;
			FilterDescriptorAction = null;
			return Assign(filter, (a, v) => a.FilterValue = v);
		}

		public ScoreFunctionBaseDescriptor Filter(Elastic.Clients.Elasticsearch.QueryDsl.QueryContainerDescriptor descriptor)
		{
			FilterValue = null;
			FilterDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.FilterDescriptor = v);
		}

		public ScoreFunctionBaseDescriptor Filter(Action<Elastic.Clients.Elasticsearch.QueryDsl.QueryContainerDescriptor> configure)
		{
			FilterValue = null;
			FilterDescriptorAction = null;
			return Assign(configure, (a, v) => a.FilterDescriptorAction = v);
		}

		public ScoreFunctionBaseDescriptor Weight(double? weight) => Assign(weight, (a, v) => a.WeightValue = v);
	}

	internal sealed class ScoreFunctionBaseDescriptorConverter : JsonConverter<ScoreFunctionBaseDescriptor>
	{
		public override ScoreFunctionBaseDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, ScoreFunctionBaseDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value.FilterDescriptor is not null)
			{
				writer.WritePropertyName("filter");
				JsonSerializer.Serialize(writer, value.FilterDescriptor, options);
			}
			else if (value.FilterDescriptorAction is not null)
			{
				writer.WritePropertyName("filter");
				JsonSerializer.Serialize(writer, new QueryContainerDescriptor(value.FilterDescriptorAction), options);
			}
			else if (value.FilterValue is not null)
			{
				writer.WritePropertyName("filter");
				JsonSerializer.Serialize(writer, value.FilterValue, options);
			}

			if (value.WeightValue.HasValue)
			{
				writer.WritePropertyName("weight");
				writer.WriteNumberValue(value.WeightValue.Value);
			}

			writer.WriteEndObject();
		}
	}

	public partial class ScriptQuery : QueryDsl.QueryBase, IQueryContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "script";
		[JsonInclude]
		[JsonPropertyName("script")]
		public Elastic.Clients.Elasticsearch.Script Script { get; set; }
	}

	[JsonConverter(typeof(ScriptQueryDescriptorConverter))]
	public sealed partial class ScriptQueryDescriptor : DescriptorBase<ScriptQueryDescriptor>, IQueryContainerVariantDescriptor
	{
		public ScriptQueryDescriptor()
		{
		}

		internal ScriptQueryDescriptor(Action<ScriptQueryDescriptor> configure) => configure.Invoke(this);
		internal Elastic.Clients.Elasticsearch.Script ScriptValue { get; private set; }

		public ScriptQueryDescriptor Script(Elastic.Clients.Elasticsearch.Script script) => Assign(script, (a, v) => a.ScriptValue = v);
	}

	internal sealed class ScriptQueryDescriptorConverter : JsonConverter<ScriptQueryDescriptor>
	{
		public override ScriptQueryDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, ScriptQueryDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("script");
			JsonSerializer.Serialize(writer, value.ScriptValue, options);
			writer.WriteEndObject();
		}
	}

	public partial class ScriptScoreFunction : QueryDsl.ScoreFunctionBase, IFunctionScoreContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IFunctionScoreContainerVariant.FunctionScoreContainerVariantName => "script_score";
		[JsonInclude]
		[JsonPropertyName("script")]
		public Elastic.Clients.Elasticsearch.Script Script { get; set; }
	}

	[JsonConverter(typeof(ScriptScoreFunctionDescriptorConverter))]
	public sealed partial class ScriptScoreFunctionDescriptor : DescriptorBase<ScriptScoreFunctionDescriptor>, IFunctionScoreContainerVariantDescriptor
	{
		public ScriptScoreFunctionDescriptor()
		{
		}

		internal ScriptScoreFunctionDescriptor(Action<ScriptScoreFunctionDescriptor> configure) => configure.Invoke(this);
		internal Elastic.Clients.Elasticsearch.Script ScriptValue { get; private set; }

		public ScriptScoreFunctionDescriptor Script(Elastic.Clients.Elasticsearch.Script script) => Assign(script, (a, v) => a.ScriptValue = v);
	}

	internal sealed class ScriptScoreFunctionDescriptorConverter : JsonConverter<ScriptScoreFunctionDescriptor>
	{
		public override ScriptScoreFunctionDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, ScriptScoreFunctionDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("script");
			JsonSerializer.Serialize(writer, value.ScriptValue, options);
			writer.WriteEndObject();
		}
	}

	public partial class ScriptScoreQuery : QueryDsl.QueryBase, IQueryContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "script_score";
		[JsonInclude]
		[JsonPropertyName("min_score")]
		public float? MinScore { get; set; }

		[JsonInclude]
		[JsonPropertyName("query")]
		public Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer Query { get; set; }

		[JsonInclude]
		[JsonPropertyName("script")]
		public Elastic.Clients.Elasticsearch.Script Script { get; set; }
	}

	[JsonConverter(typeof(ScriptScoreQueryDescriptorConverter))]
	public sealed partial class ScriptScoreQueryDescriptor : DescriptorBase<ScriptScoreQueryDescriptor>, IQueryContainerVariantDescriptor
	{
		public ScriptScoreQueryDescriptor()
		{
		}

		internal ScriptScoreQueryDescriptor(Action<ScriptScoreQueryDescriptor> configure) => configure.Invoke(this);
		internal float? MinScoreValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer QueryValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Script ScriptValue { get; private set; }

		internal QueryContainerDescriptor QueryDescriptor { get; private set; }

		internal Action<QueryContainerDescriptor> QueryDescriptorAction { get; private set; }

		public ScriptScoreQueryDescriptor MinScore(float? minScore) => Assign(minScore, (a, v) => a.MinScoreValue = v);
		public ScriptScoreQueryDescriptor Query(Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer query)
		{
			QueryDescriptor = null;
			QueryDescriptorAction = null;
			return Assign(query, (a, v) => a.QueryValue = v);
		}

		public ScriptScoreQueryDescriptor Query(Elastic.Clients.Elasticsearch.QueryDsl.QueryContainerDescriptor descriptor)
		{
			QueryValue = null;
			QueryDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.QueryDescriptor = v);
		}

		public ScriptScoreQueryDescriptor Query(Action<Elastic.Clients.Elasticsearch.QueryDsl.QueryContainerDescriptor> configure)
		{
			QueryValue = null;
			QueryDescriptorAction = null;
			return Assign(configure, (a, v) => a.QueryDescriptorAction = v);
		}

		public ScriptScoreQueryDescriptor Script(Elastic.Clients.Elasticsearch.Script script) => Assign(script, (a, v) => a.ScriptValue = v);
	}

	internal sealed class ScriptScoreQueryDescriptorConverter : JsonConverter<ScriptScoreQueryDescriptor>
	{
		public override ScriptScoreQueryDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, ScriptScoreQueryDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value.MinScoreValue.HasValue)
			{
				writer.WritePropertyName("min_score");
				writer.WriteNumberValue(value.MinScoreValue.Value);
			}

			if (value.QueryDescriptor is not null)
			{
				writer.WritePropertyName("query");
				JsonSerializer.Serialize(writer, value.QueryDescriptor, options);
			}
			else if (value.QueryDescriptorAction is not null)
			{
				writer.WritePropertyName("query");
				JsonSerializer.Serialize(writer, new QueryContainerDescriptor(value.QueryDescriptorAction), options);
			}
			else
			{
				writer.WritePropertyName("query");
				JsonSerializer.Serialize(writer, value.QueryValue, options);
			}

			writer.WritePropertyName("script");
			JsonSerializer.Serialize(writer, value.ScriptValue, options);
			writer.WriteEndObject();
		}
	}

	public partial class ShapeQuery : QueryDsl.QueryBase, IQueryContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "shape";
	}

	[JsonConverter(typeof(ShapeQueryDescriptorConverter))]
	public sealed partial class ShapeQueryDescriptor : DescriptorBase<ShapeQueryDescriptor>, IQueryContainerVariantDescriptor
	{
		public ShapeQueryDescriptor()
		{
		}

		internal ShapeQueryDescriptor(Action<ShapeQueryDescriptor> configure) => configure.Invoke(this);
	}

	internal sealed class ShapeQueryDescriptorConverter : JsonConverter<ShapeQueryDescriptor>
	{
		public override ShapeQueryDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, ShapeQueryDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WriteEndObject();
		}
	}

	public partial class SimpleQueryStringQuery : QueryDsl.QueryBase, IQueryContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "simple_query_string";
		[JsonInclude]
		[JsonPropertyName("analyzer")]
		public string? Analyzer { get; set; }

		[JsonInclude]
		[JsonPropertyName("analyze_wildcard")]
		public bool? AnalyzeWildcard { get; set; }

		[JsonInclude]
		[JsonPropertyName("auto_generate_synonyms_phrase_query")]
		public bool? AutoGenerateSynonymsPhraseQuery { get; set; }

		[JsonInclude]
		[JsonPropertyName("default_operator")]
		public Elastic.Clients.Elasticsearch.QueryDsl.Operator? DefaultOperator { get; set; }

		[JsonInclude]
		[JsonPropertyName("fields")]
		public IEnumerable<string>? Fields { get; set; }

		[JsonInclude]
		[JsonPropertyName("flags")]
		public Union<Elastic.Clients.Elasticsearch.QueryDsl.SimpleQueryStringFlags?, string?>? Flags { get; set; }

		[JsonInclude]
		[JsonPropertyName("fuzzy_max_expansions")]
		public int? FuzzyMaxExpansions { get; set; }

		[JsonInclude]
		[JsonPropertyName("fuzzy_prefix_length")]
		public int? FuzzyPrefixLength { get; set; }

		[JsonInclude]
		[JsonPropertyName("fuzzy_transpositions")]
		public bool? FuzzyTranspositions { get; set; }

		[JsonInclude]
		[JsonPropertyName("lenient")]
		public bool? Lenient { get; set; }

		[JsonInclude]
		[JsonPropertyName("minimum_should_match")]
		public Elastic.Clients.Elasticsearch.MinimumShouldMatch? MinimumShouldMatch { get; set; }

		[JsonInclude]
		[JsonPropertyName("query")]
		public string Query { get; set; }

		[JsonInclude]
		[JsonPropertyName("quote_field_suffix")]
		public string? QuoteFieldSuffix { get; set; }
	}

	[JsonConverter(typeof(SimpleQueryStringQueryDescriptorConverter))]
	public sealed partial class SimpleQueryStringQueryDescriptor : DescriptorBase<SimpleQueryStringQueryDescriptor>, IQueryContainerVariantDescriptor
	{
		public SimpleQueryStringQueryDescriptor()
		{
		}

		internal SimpleQueryStringQueryDescriptor(Action<SimpleQueryStringQueryDescriptor> configure) => configure.Invoke(this);
		internal string? AnalyzerValue { get; private set; }

		internal bool? AnalyzeWildcardValue { get; private set; }

		internal bool? AutoGenerateSynonymsPhraseQueryValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.Operator? DefaultOperatorValue { get; private set; }

		internal IEnumerable<string>? FieldsValue { get; private set; }

		internal Union<Elastic.Clients.Elasticsearch.QueryDsl.SimpleQueryStringFlags?, string?>? FlagsValue { get; private set; }

		internal int? FuzzyMaxExpansionsValue { get; private set; }

		internal int? FuzzyPrefixLengthValue { get; private set; }

		internal bool? FuzzyTranspositionsValue { get; private set; }

		internal bool? LenientValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.MinimumShouldMatch? MinimumShouldMatchValue { get; private set; }

		internal string QueryValue { get; private set; }

		internal string? QuoteFieldSuffixValue { get; private set; }

		public SimpleQueryStringQueryDescriptor Analyzer(string? analyzer) => Assign(analyzer, (a, v) => a.AnalyzerValue = v);
		public SimpleQueryStringQueryDescriptor AnalyzeWildcard(bool? analyzeWildcard = true) => Assign(analyzeWildcard, (a, v) => a.AnalyzeWildcardValue = v);
		public SimpleQueryStringQueryDescriptor AutoGenerateSynonymsPhraseQuery(bool? autoGenerateSynonymsPhraseQuery = true) => Assign(autoGenerateSynonymsPhraseQuery, (a, v) => a.AutoGenerateSynonymsPhraseQueryValue = v);
		public SimpleQueryStringQueryDescriptor DefaultOperator(Elastic.Clients.Elasticsearch.QueryDsl.Operator? defaultOperator) => Assign(defaultOperator, (a, v) => a.DefaultOperatorValue = v);
		public SimpleQueryStringQueryDescriptor Fields(IEnumerable<string>? fields) => Assign(fields, (a, v) => a.FieldsValue = v);
		public SimpleQueryStringQueryDescriptor Flags(Union<Elastic.Clients.Elasticsearch.QueryDsl.SimpleQueryStringFlags?, string?>? flags) => Assign(flags, (a, v) => a.FlagsValue = v);
		public SimpleQueryStringQueryDescriptor FuzzyMaxExpansions(int? fuzzyMaxExpansions) => Assign(fuzzyMaxExpansions, (a, v) => a.FuzzyMaxExpansionsValue = v);
		public SimpleQueryStringQueryDescriptor FuzzyPrefixLength(int? fuzzyPrefixLength) => Assign(fuzzyPrefixLength, (a, v) => a.FuzzyPrefixLengthValue = v);
		public SimpleQueryStringQueryDescriptor FuzzyTranspositions(bool? fuzzyTranspositions = true) => Assign(fuzzyTranspositions, (a, v) => a.FuzzyTranspositionsValue = v);
		public SimpleQueryStringQueryDescriptor Lenient(bool? lenient = true) => Assign(lenient, (a, v) => a.LenientValue = v);
		public SimpleQueryStringQueryDescriptor MinimumShouldMatch(Elastic.Clients.Elasticsearch.MinimumShouldMatch? minimumShouldMatch) => Assign(minimumShouldMatch, (a, v) => a.MinimumShouldMatchValue = v);
		public SimpleQueryStringQueryDescriptor Query(string query) => Assign(query, (a, v) => a.QueryValue = v);
		public SimpleQueryStringQueryDescriptor QuoteFieldSuffix(string? quoteFieldSuffix) => Assign(quoteFieldSuffix, (a, v) => a.QuoteFieldSuffixValue = v);
	}

	internal sealed class SimpleQueryStringQueryDescriptorConverter : JsonConverter<SimpleQueryStringQueryDescriptor>
	{
		public override SimpleQueryStringQueryDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, SimpleQueryStringQueryDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (!string.IsNullOrEmpty(value.AnalyzerValue))
			{
				writer.WritePropertyName("analyzer");
				writer.WriteStringValue(value.AnalyzerValue);
			}

			if (value.AnalyzeWildcardValue.HasValue)
			{
				writer.WritePropertyName("analyze_wildcard");
				writer.WriteBooleanValue(value.AnalyzeWildcardValue.Value);
			}

			if (value.AutoGenerateSynonymsPhraseQueryValue.HasValue)
			{
				writer.WritePropertyName("auto_generate_synonyms_phrase_query");
				writer.WriteBooleanValue(value.AutoGenerateSynonymsPhraseQueryValue.Value);
			}

			if (value.DefaultOperatorValue is not null)
			{
				writer.WritePropertyName("default_operator");
				JsonSerializer.Serialize(writer, value.DefaultOperatorValue, options);
			}

			if (value.FieldsValue is not null)
			{
				writer.WritePropertyName("fields");
				JsonSerializer.Serialize(writer, value.FieldsValue, options);
			}

			if (value.FlagsValue is not null)
			{
				writer.WritePropertyName("flags");
				JsonSerializer.Serialize(writer, value.FlagsValue, options);
			}

			if (value.FuzzyMaxExpansionsValue.HasValue)
			{
				writer.WritePropertyName("fuzzy_max_expansions");
				writer.WriteNumberValue(value.FuzzyMaxExpansionsValue.Value);
			}

			if (value.FuzzyPrefixLengthValue.HasValue)
			{
				writer.WritePropertyName("fuzzy_prefix_length");
				writer.WriteNumberValue(value.FuzzyPrefixLengthValue.Value);
			}

			if (value.FuzzyTranspositionsValue.HasValue)
			{
				writer.WritePropertyName("fuzzy_transpositions");
				writer.WriteBooleanValue(value.FuzzyTranspositionsValue.Value);
			}

			if (value.LenientValue.HasValue)
			{
				writer.WritePropertyName("lenient");
				writer.WriteBooleanValue(value.LenientValue.Value);
			}

			if (value.MinimumShouldMatchValue is not null)
			{
				writer.WritePropertyName("minimum_should_match");
				JsonSerializer.Serialize(writer, value.MinimumShouldMatchValue, options);
			}

			writer.WritePropertyName("query");
			writer.WriteStringValue(value.QueryValue);
			if (!string.IsNullOrEmpty(value.QuoteFieldSuffixValue))
			{
				writer.WritePropertyName("quote_field_suffix");
				writer.WriteStringValue(value.QuoteFieldSuffixValue);
			}

			writer.WriteEndObject();
		}
	}

	public partial class SpanContainingQuery : QueryDsl.QueryBase, IQueryContainerVariant, ISpanQueryVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "span_containing";
		[JsonIgnore]
		string QueryDsl.ISpanQueryVariant.SpanQueryVariantName => "span_containing";
		[JsonInclude]
		[JsonPropertyName("big")]
		public Elastic.Clients.Elasticsearch.QueryDsl.SpanQuery Big { get; set; }

		[JsonInclude]
		[JsonPropertyName("little")]
		public Elastic.Clients.Elasticsearch.QueryDsl.SpanQuery Little { get; set; }
	}

	[JsonConverter(typeof(SpanContainingQueryDescriptorConverter))]
	public sealed partial class SpanContainingQueryDescriptor : DescriptorBase<SpanContainingQueryDescriptor>, IQueryContainerVariantDescriptor, ISpanQueryVariantDescriptor
	{
		public SpanContainingQueryDescriptor()
		{
		}

		internal SpanContainingQueryDescriptor(Action<SpanContainingQueryDescriptor> configure) => configure.Invoke(this);
		internal Elastic.Clients.Elasticsearch.QueryDsl.SpanQuery BigValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.SpanQuery LittleValue { get; private set; }

		internal SpanQueryDescriptor BigDescriptor { get; private set; }

		internal SpanQueryDescriptor LittleDescriptor { get; private set; }

		internal Action<SpanQueryDescriptor> BigDescriptorAction { get; private set; }

		internal Action<SpanQueryDescriptor> LittleDescriptorAction { get; private set; }

		public SpanContainingQueryDescriptor Big(Elastic.Clients.Elasticsearch.QueryDsl.SpanQuery big)
		{
			BigDescriptor = null;
			BigDescriptorAction = null;
			return Assign(big, (a, v) => a.BigValue = v);
		}

		public SpanContainingQueryDescriptor Big(Elastic.Clients.Elasticsearch.QueryDsl.SpanQueryDescriptor descriptor)
		{
			BigValue = null;
			BigDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.BigDescriptor = v);
		}

		public SpanContainingQueryDescriptor Big(Action<Elastic.Clients.Elasticsearch.QueryDsl.SpanQueryDescriptor> configure)
		{
			BigValue = null;
			BigDescriptorAction = null;
			return Assign(configure, (a, v) => a.BigDescriptorAction = v);
		}

		public SpanContainingQueryDescriptor Little(Elastic.Clients.Elasticsearch.QueryDsl.SpanQuery little)
		{
			LittleDescriptor = null;
			LittleDescriptorAction = null;
			return Assign(little, (a, v) => a.LittleValue = v);
		}

		public SpanContainingQueryDescriptor Little(Elastic.Clients.Elasticsearch.QueryDsl.SpanQueryDescriptor descriptor)
		{
			LittleValue = null;
			LittleDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.LittleDescriptor = v);
		}

		public SpanContainingQueryDescriptor Little(Action<Elastic.Clients.Elasticsearch.QueryDsl.SpanQueryDescriptor> configure)
		{
			LittleValue = null;
			LittleDescriptorAction = null;
			return Assign(configure, (a, v) => a.LittleDescriptorAction = v);
		}
	}

	internal sealed class SpanContainingQueryDescriptorConverter : JsonConverter<SpanContainingQueryDescriptor>
	{
		public override SpanContainingQueryDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, SpanContainingQueryDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value.BigDescriptor is not null)
			{
				writer.WritePropertyName("big");
				JsonSerializer.Serialize(writer, value.BigDescriptor, options);
			}
			else if (value.BigDescriptorAction is not null)
			{
				writer.WritePropertyName("big");
				JsonSerializer.Serialize(writer, new SpanQueryDescriptor(value.BigDescriptorAction), options);
			}
			else
			{
				writer.WritePropertyName("big");
				JsonSerializer.Serialize(writer, value.BigValue, options);
			}

			if (value.LittleDescriptor is not null)
			{
				writer.WritePropertyName("little");
				JsonSerializer.Serialize(writer, value.LittleDescriptor, options);
			}
			else if (value.LittleDescriptorAction is not null)
			{
				writer.WritePropertyName("little");
				JsonSerializer.Serialize(writer, new SpanQueryDescriptor(value.LittleDescriptorAction), options);
			}
			else
			{
				writer.WritePropertyName("little");
				JsonSerializer.Serialize(writer, value.LittleValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class SpanFieldMaskingQuery : QueryDsl.QueryBase, IQueryContainerVariant, ISpanQueryVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "field_masking_span";
		[JsonIgnore]
		string QueryDsl.ISpanQueryVariant.SpanQueryVariantName => "field_masking_span";
		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("query")]
		public Elastic.Clients.Elasticsearch.QueryDsl.SpanQuery Query { get; set; }
	}

	[JsonConverter(typeof(SpanFieldMaskingQueryDescriptorConverter))]
	public sealed partial class SpanFieldMaskingQueryDescriptor : DescriptorBase<SpanFieldMaskingQueryDescriptor>, IQueryContainerVariantDescriptor, ISpanQueryVariantDescriptor
	{
		public SpanFieldMaskingQueryDescriptor()
		{
		}

		internal SpanFieldMaskingQueryDescriptor(Action<SpanFieldMaskingQueryDescriptor> configure) => configure.Invoke(this);
		internal string FieldValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.SpanQuery QueryValue { get; private set; }

		internal SpanQueryDescriptor QueryDescriptor { get; private set; }

		internal Action<SpanQueryDescriptor> QueryDescriptorAction { get; private set; }

		public SpanFieldMaskingQueryDescriptor Field(string field) => Assign(field, (a, v) => a.FieldValue = v);
		public SpanFieldMaskingQueryDescriptor Query(Elastic.Clients.Elasticsearch.QueryDsl.SpanQuery query)
		{
			QueryDescriptor = null;
			QueryDescriptorAction = null;
			return Assign(query, (a, v) => a.QueryValue = v);
		}

		public SpanFieldMaskingQueryDescriptor Query(Elastic.Clients.Elasticsearch.QueryDsl.SpanQueryDescriptor descriptor)
		{
			QueryValue = null;
			QueryDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.QueryDescriptor = v);
		}

		public SpanFieldMaskingQueryDescriptor Query(Action<Elastic.Clients.Elasticsearch.QueryDsl.SpanQueryDescriptor> configure)
		{
			QueryValue = null;
			QueryDescriptorAction = null;
			return Assign(configure, (a, v) => a.QueryDescriptorAction = v);
		}
	}

	internal sealed class SpanFieldMaskingQueryDescriptorConverter : JsonConverter<SpanFieldMaskingQueryDescriptor>
	{
		public override SpanFieldMaskingQueryDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, SpanFieldMaskingQueryDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, value.FieldValue, options);
			if (value.QueryDescriptor is not null)
			{
				writer.WritePropertyName("query");
				JsonSerializer.Serialize(writer, value.QueryDescriptor, options);
			}
			else if (value.QueryDescriptorAction is not null)
			{
				writer.WritePropertyName("query");
				JsonSerializer.Serialize(writer, new SpanQueryDescriptor(value.QueryDescriptorAction), options);
			}
			else
			{
				writer.WritePropertyName("query");
				JsonSerializer.Serialize(writer, value.QueryValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class SpanFirstQuery : QueryDsl.QueryBase, IQueryContainerVariant, ISpanQueryVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "span_first";
		[JsonIgnore]
		string QueryDsl.ISpanQueryVariant.SpanQueryVariantName => "span_first";
		[JsonInclude]
		[JsonPropertyName("end")]
		public int End { get; set; }

		[JsonInclude]
		[JsonPropertyName("match")]
		public Elastic.Clients.Elasticsearch.QueryDsl.SpanQuery Match { get; set; }
	}

	[JsonConverter(typeof(SpanFirstQueryDescriptorConverter))]
	public sealed partial class SpanFirstQueryDescriptor : DescriptorBase<SpanFirstQueryDescriptor>, IQueryContainerVariantDescriptor, ISpanQueryVariantDescriptor
	{
		public SpanFirstQueryDescriptor()
		{
		}

		internal SpanFirstQueryDescriptor(Action<SpanFirstQueryDescriptor> configure) => configure.Invoke(this);
		internal int EndValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.SpanQuery MatchValue { get; private set; }

		internal SpanQueryDescriptor MatchDescriptor { get; private set; }

		internal Action<SpanQueryDescriptor> MatchDescriptorAction { get; private set; }

		public SpanFirstQueryDescriptor End(int end) => Assign(end, (a, v) => a.EndValue = v);
		public SpanFirstQueryDescriptor Match(Elastic.Clients.Elasticsearch.QueryDsl.SpanQuery match)
		{
			MatchDescriptor = null;
			MatchDescriptorAction = null;
			return Assign(match, (a, v) => a.MatchValue = v);
		}

		public SpanFirstQueryDescriptor Match(Elastic.Clients.Elasticsearch.QueryDsl.SpanQueryDescriptor descriptor)
		{
			MatchValue = null;
			MatchDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.MatchDescriptor = v);
		}

		public SpanFirstQueryDescriptor Match(Action<Elastic.Clients.Elasticsearch.QueryDsl.SpanQueryDescriptor> configure)
		{
			MatchValue = null;
			MatchDescriptorAction = null;
			return Assign(configure, (a, v) => a.MatchDescriptorAction = v);
		}
	}

	internal sealed class SpanFirstQueryDescriptorConverter : JsonConverter<SpanFirstQueryDescriptor>
	{
		public override SpanFirstQueryDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, SpanFirstQueryDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("end");
			writer.WriteNumberValue(value.EndValue);
			if (value.MatchDescriptor is not null)
			{
				writer.WritePropertyName("match");
				JsonSerializer.Serialize(writer, value.MatchDescriptor, options);
			}
			else if (value.MatchDescriptorAction is not null)
			{
				writer.WritePropertyName("match");
				JsonSerializer.Serialize(writer, new SpanQueryDescriptor(value.MatchDescriptorAction), options);
			}
			else
			{
				writer.WritePropertyName("match");
				JsonSerializer.Serialize(writer, value.MatchValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class SpanMultiTermQuery : QueryDsl.QueryBase, IQueryContainerVariant, ISpanQueryVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "span_multi";
		[JsonIgnore]
		string QueryDsl.ISpanQueryVariant.SpanQueryVariantName => "span_multi";
		[JsonInclude]
		[JsonPropertyName("match")]
		public Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer Match { get; set; }
	}

	[JsonConverter(typeof(SpanMultiTermQueryDescriptorConverter))]
	public sealed partial class SpanMultiTermQueryDescriptor : DescriptorBase<SpanMultiTermQueryDescriptor>, IQueryContainerVariantDescriptor, ISpanQueryVariantDescriptor
	{
		public SpanMultiTermQueryDescriptor()
		{
		}

		internal SpanMultiTermQueryDescriptor(Action<SpanMultiTermQueryDescriptor> configure) => configure.Invoke(this);
		internal Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer MatchValue { get; private set; }

		internal QueryContainerDescriptor MatchDescriptor { get; private set; }

		internal Action<QueryContainerDescriptor> MatchDescriptorAction { get; private set; }

		public SpanMultiTermQueryDescriptor Match(Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer match)
		{
			MatchDescriptor = null;
			MatchDescriptorAction = null;
			return Assign(match, (a, v) => a.MatchValue = v);
		}

		public SpanMultiTermQueryDescriptor Match(Elastic.Clients.Elasticsearch.QueryDsl.QueryContainerDescriptor descriptor)
		{
			MatchValue = null;
			MatchDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.MatchDescriptor = v);
		}

		public SpanMultiTermQueryDescriptor Match(Action<Elastic.Clients.Elasticsearch.QueryDsl.QueryContainerDescriptor> configure)
		{
			MatchValue = null;
			MatchDescriptorAction = null;
			return Assign(configure, (a, v) => a.MatchDescriptorAction = v);
		}
	}

	internal sealed class SpanMultiTermQueryDescriptorConverter : JsonConverter<SpanMultiTermQueryDescriptor>
	{
		public override SpanMultiTermQueryDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, SpanMultiTermQueryDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value.MatchDescriptor is not null)
			{
				writer.WritePropertyName("match");
				JsonSerializer.Serialize(writer, value.MatchDescriptor, options);
			}
			else if (value.MatchDescriptorAction is not null)
			{
				writer.WritePropertyName("match");
				JsonSerializer.Serialize(writer, new QueryContainerDescriptor(value.MatchDescriptorAction), options);
			}
			else
			{
				writer.WritePropertyName("match");
				JsonSerializer.Serialize(writer, value.MatchValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class SpanNearQuery : QueryDsl.QueryBase, IQueryContainerVariant, ISpanQueryVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "span_near";
		[JsonIgnore]
		string QueryDsl.ISpanQueryVariant.SpanQueryVariantName => "span_near";
		[JsonInclude]
		[JsonPropertyName("clauses")]
		public IEnumerable<Elastic.Clients.Elasticsearch.QueryDsl.SpanQuery> Clauses { get; set; }

		[JsonInclude]
		[JsonPropertyName("in_order")]
		public bool? InOrder { get; set; }

		[JsonInclude]
		[JsonPropertyName("slop")]
		public int? Slop { get; set; }
	}

	[JsonConverter(typeof(SpanNearQueryDescriptorConverter))]
	public sealed partial class SpanNearQueryDescriptor : DescriptorBase<SpanNearQueryDescriptor>, IQueryContainerVariantDescriptor, ISpanQueryVariantDescriptor
	{
		public SpanNearQueryDescriptor()
		{
		}

		internal SpanNearQueryDescriptor(Action<SpanNearQueryDescriptor> configure) => configure.Invoke(this);
		internal IEnumerable<Elastic.Clients.Elasticsearch.QueryDsl.SpanQuery> ClausesValue { get; private set; }

		internal bool? InOrderValue { get; private set; }

		internal int? SlopValue { get; private set; }

		public SpanNearQueryDescriptor Clauses(IEnumerable<Elastic.Clients.Elasticsearch.QueryDsl.SpanQuery> clauses) => Assign(clauses, (a, v) => a.ClausesValue = v);
		public SpanNearQueryDescriptor InOrder(bool? inOrder = true) => Assign(inOrder, (a, v) => a.InOrderValue = v);
		public SpanNearQueryDescriptor Slop(int? slop) => Assign(slop, (a, v) => a.SlopValue = v);
	}

	internal sealed class SpanNearQueryDescriptorConverter : JsonConverter<SpanNearQueryDescriptor>
	{
		public override SpanNearQueryDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, SpanNearQueryDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("clauses");
			JsonSerializer.Serialize(writer, value.ClausesValue, options);
			if (value.InOrderValue.HasValue)
			{
				writer.WritePropertyName("in_order");
				writer.WriteBooleanValue(value.InOrderValue.Value);
			}

			if (value.SlopValue.HasValue)
			{
				writer.WritePropertyName("slop");
				writer.WriteNumberValue(value.SlopValue.Value);
			}

			writer.WriteEndObject();
		}
	}

	public partial class SpanNotQuery : QueryDsl.QueryBase, IQueryContainerVariant, ISpanQueryVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "span_not";
		[JsonIgnore]
		string QueryDsl.ISpanQueryVariant.SpanQueryVariantName => "span_not";
		[JsonInclude]
		[JsonPropertyName("dist")]
		public int? Dist { get; set; }

		[JsonInclude]
		[JsonPropertyName("exclude")]
		public Elastic.Clients.Elasticsearch.QueryDsl.SpanQuery Exclude { get; set; }

		[JsonInclude]
		[JsonPropertyName("include")]
		public Elastic.Clients.Elasticsearch.QueryDsl.SpanQuery Include { get; set; }

		[JsonInclude]
		[JsonPropertyName("post")]
		public int? Post { get; set; }

		[JsonInclude]
		[JsonPropertyName("pre")]
		public int? Pre { get; set; }
	}

	[JsonConverter(typeof(SpanNotQueryDescriptorConverter))]
	public sealed partial class SpanNotQueryDescriptor : DescriptorBase<SpanNotQueryDescriptor>, IQueryContainerVariantDescriptor, ISpanQueryVariantDescriptor
	{
		public SpanNotQueryDescriptor()
		{
		}

		internal SpanNotQueryDescriptor(Action<SpanNotQueryDescriptor> configure) => configure.Invoke(this);
		internal int? DistValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.SpanQuery ExcludeValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.SpanQuery IncludeValue { get; private set; }

		internal int? PostValue { get; private set; }

		internal int? PreValue { get; private set; }

		internal SpanQueryDescriptor ExcludeDescriptor { get; private set; }

		internal SpanQueryDescriptor IncludeDescriptor { get; private set; }

		internal Action<SpanQueryDescriptor> ExcludeDescriptorAction { get; private set; }

		internal Action<SpanQueryDescriptor> IncludeDescriptorAction { get; private set; }

		public SpanNotQueryDescriptor Dist(int? dist) => Assign(dist, (a, v) => a.DistValue = v);
		public SpanNotQueryDescriptor Exclude(Elastic.Clients.Elasticsearch.QueryDsl.SpanQuery exclude)
		{
			ExcludeDescriptor = null;
			ExcludeDescriptorAction = null;
			return Assign(exclude, (a, v) => a.ExcludeValue = v);
		}

		public SpanNotQueryDescriptor Exclude(Elastic.Clients.Elasticsearch.QueryDsl.SpanQueryDescriptor descriptor)
		{
			ExcludeValue = null;
			ExcludeDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.ExcludeDescriptor = v);
		}

		public SpanNotQueryDescriptor Exclude(Action<Elastic.Clients.Elasticsearch.QueryDsl.SpanQueryDescriptor> configure)
		{
			ExcludeValue = null;
			ExcludeDescriptorAction = null;
			return Assign(configure, (a, v) => a.ExcludeDescriptorAction = v);
		}

		public SpanNotQueryDescriptor Include(Elastic.Clients.Elasticsearch.QueryDsl.SpanQuery include)
		{
			IncludeDescriptor = null;
			IncludeDescriptorAction = null;
			return Assign(include, (a, v) => a.IncludeValue = v);
		}

		public SpanNotQueryDescriptor Include(Elastic.Clients.Elasticsearch.QueryDsl.SpanQueryDescriptor descriptor)
		{
			IncludeValue = null;
			IncludeDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.IncludeDescriptor = v);
		}

		public SpanNotQueryDescriptor Include(Action<Elastic.Clients.Elasticsearch.QueryDsl.SpanQueryDescriptor> configure)
		{
			IncludeValue = null;
			IncludeDescriptorAction = null;
			return Assign(configure, (a, v) => a.IncludeDescriptorAction = v);
		}

		public SpanNotQueryDescriptor Post(int? post) => Assign(post, (a, v) => a.PostValue = v);
		public SpanNotQueryDescriptor Pre(int? pre) => Assign(pre, (a, v) => a.PreValue = v);
	}

	internal sealed class SpanNotQueryDescriptorConverter : JsonConverter<SpanNotQueryDescriptor>
	{
		public override SpanNotQueryDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, SpanNotQueryDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value.DistValue.HasValue)
			{
				writer.WritePropertyName("dist");
				writer.WriteNumberValue(value.DistValue.Value);
			}

			if (value.ExcludeDescriptor is not null)
			{
				writer.WritePropertyName("exclude");
				JsonSerializer.Serialize(writer, value.ExcludeDescriptor, options);
			}
			else if (value.ExcludeDescriptorAction is not null)
			{
				writer.WritePropertyName("exclude");
				JsonSerializer.Serialize(writer, new SpanQueryDescriptor(value.ExcludeDescriptorAction), options);
			}
			else
			{
				writer.WritePropertyName("exclude");
				JsonSerializer.Serialize(writer, value.ExcludeValue, options);
			}

			if (value.IncludeDescriptor is not null)
			{
				writer.WritePropertyName("include");
				JsonSerializer.Serialize(writer, value.IncludeDescriptor, options);
			}
			else if (value.IncludeDescriptorAction is not null)
			{
				writer.WritePropertyName("include");
				JsonSerializer.Serialize(writer, new SpanQueryDescriptor(value.IncludeDescriptorAction), options);
			}
			else
			{
				writer.WritePropertyName("include");
				JsonSerializer.Serialize(writer, value.IncludeValue, options);
			}

			if (value.PostValue.HasValue)
			{
				writer.WritePropertyName("post");
				writer.WriteNumberValue(value.PostValue.Value);
			}

			if (value.PreValue.HasValue)
			{
				writer.WritePropertyName("pre");
				writer.WriteNumberValue(value.PreValue.Value);
			}

			writer.WriteEndObject();
		}
	}

	public partial class SpanOrQuery : QueryDsl.QueryBase, IQueryContainerVariant, ISpanQueryVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "span_or";
		[JsonIgnore]
		string QueryDsl.ISpanQueryVariant.SpanQueryVariantName => "span_or";
		[JsonInclude]
		[JsonPropertyName("clauses")]
		public IEnumerable<Elastic.Clients.Elasticsearch.QueryDsl.SpanQuery> Clauses { get; set; }
	}

	[JsonConverter(typeof(SpanOrQueryDescriptorConverter))]
	public sealed partial class SpanOrQueryDescriptor : DescriptorBase<SpanOrQueryDescriptor>, IQueryContainerVariantDescriptor, ISpanQueryVariantDescriptor
	{
		public SpanOrQueryDescriptor()
		{
		}

		internal SpanOrQueryDescriptor(Action<SpanOrQueryDescriptor> configure) => configure.Invoke(this);
		internal IEnumerable<Elastic.Clients.Elasticsearch.QueryDsl.SpanQuery> ClausesValue { get; private set; }

		public SpanOrQueryDescriptor Clauses(IEnumerable<Elastic.Clients.Elasticsearch.QueryDsl.SpanQuery> clauses) => Assign(clauses, (a, v) => a.ClausesValue = v);
	}

	internal sealed class SpanOrQueryDescriptorConverter : JsonConverter<SpanOrQueryDescriptor>
	{
		public override SpanOrQueryDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, SpanOrQueryDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("clauses");
			JsonSerializer.Serialize(writer, value.ClausesValue, options);
			writer.WriteEndObject();
		}
	}

	public interface ISpanQueryVariant
	{
		string SpanQueryVariantName { get; }
	}

	internal interface ISpanQueryVariantDescriptor
	{
	}

	[JsonConverter(typeof(SpanQueryConverter))]
	public partial class SpanQuery : IContainer
	{
		public SpanQuery(ISpanQueryVariant variant) => Variant = variant ?? throw new ArgumentNullException(nameof(variant));
		internal ISpanQueryVariant Variant { get; }
	}

	internal sealed class SpanQueryConverter : JsonConverter<SpanQuery>
	{
		public override SpanQuery Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			reader.Read();
			if (reader.TokenType != JsonTokenType.PropertyName)
			{
				throw new JsonException();
			}

			var propertyName = reader.GetString();
			if (propertyName == "span_containing")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.SpanContainingQuery?>(ref reader, options);
				reader.Read();
				return new SpanQuery(variant);
			}

			if (propertyName == "field_masking_span")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.SpanFieldMaskingQuery?>(ref reader, options);
				reader.Read();
				return new SpanQuery(variant);
			}

			if (propertyName == "span_first")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.SpanFirstQuery?>(ref reader, options);
				reader.Read();
				return new SpanQuery(variant);
			}

			if (propertyName == "span_multi")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.SpanMultiTermQuery?>(ref reader, options);
				reader.Read();
				return new SpanQuery(variant);
			}

			if (propertyName == "span_near")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.SpanNearQuery?>(ref reader, options);
				reader.Read();
				return new SpanQuery(variant);
			}

			if (propertyName == "span_not")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.SpanNotQuery?>(ref reader, options);
				reader.Read();
				return new SpanQuery(variant);
			}

			if (propertyName == "span_or")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.SpanOrQuery?>(ref reader, options);
				reader.Read();
				return new SpanQuery(variant);
			}

			if (propertyName == "span_term")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.SpanTermQuery?>(ref reader, options);
				reader.Read();
				return new SpanQuery(variant);
			}

			if (propertyName == "span_within")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.SpanWithinQuery?>(ref reader, options);
				reader.Read();
				return new SpanQuery(variant);
			}

			throw new JsonException();
		}

		public override void Write(Utf8JsonWriter writer, SpanQuery value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName(value.Variant.SpanQueryVariantName);
			switch (value.Variant)
			{
				case Elastic.Clients.Elasticsearch.QueryDsl.SpanContainingQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.SpanFieldMaskingQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.SpanFirstQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.SpanMultiTermQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.SpanNearQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.SpanNotQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.SpanOrQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.SpanTermQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.SpanWithinQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
			}

			writer.WriteEndObject();
		}
	}

	public sealed partial class SpanQueryDescriptor : DescriptorBase<SpanQueryDescriptor>
	{
		public SpanQueryDescriptor()
		{
		}

		internal SpanQueryDescriptor(Action<SpanQueryDescriptor> configure) => configure.Invoke(this);
	}

	internal sealed class SpanQueryDescriptorConverter : JsonConverter<SpanQueryDescriptor>
	{
		public override SpanQueryDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, SpanQueryDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WriteEndObject();
		}
	}

	public partial class SpanTermQuery : FieldNameQueryBase, IQueryContainerVariant, ISpanQueryVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "span_term";
		[JsonIgnore]
		string QueryDsl.ISpanQueryVariant.SpanQueryVariantName => "span_term";
		[JsonInclude]
		[JsonPropertyName("value")]
		public string Value { get; set; }
	}

	[JsonConverter(typeof(SpanTermQueryDescriptorConverter))]
	public sealed partial class SpanTermQueryDescriptor : DescriptorBase<SpanTermQueryDescriptor>, IQueryContainerVariantDescriptor, ISpanQueryVariantDescriptor
	{
		public SpanTermQueryDescriptor()
		{
		}

		internal SpanTermQueryDescriptor(Action<SpanTermQueryDescriptor> configure) => configure.Invoke(this);
		internal string ValueValue { get; private set; }

		public SpanTermQueryDescriptor Value(string value) => Assign(value, (a, v) => a.ValueValue = v);
	}

	internal sealed class SpanTermQueryDescriptorConverter : JsonConverter<SpanTermQueryDescriptor>
	{
		public override SpanTermQueryDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, SpanTermQueryDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("value");
			writer.WriteStringValue(value.ValueValue);
			writer.WriteEndObject();
		}
	}

	public partial class SpanWithinQuery : QueryDsl.QueryBase, IQueryContainerVariant, ISpanQueryVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "span_within";
		[JsonIgnore]
		string QueryDsl.ISpanQueryVariant.SpanQueryVariantName => "span_within";
		[JsonInclude]
		[JsonPropertyName("big")]
		public Elastic.Clients.Elasticsearch.QueryDsl.SpanQuery Big { get; set; }

		[JsonInclude]
		[JsonPropertyName("little")]
		public Elastic.Clients.Elasticsearch.QueryDsl.SpanQuery Little { get; set; }
	}

	[JsonConverter(typeof(SpanWithinQueryDescriptorConverter))]
	public sealed partial class SpanWithinQueryDescriptor : DescriptorBase<SpanWithinQueryDescriptor>, IQueryContainerVariantDescriptor, ISpanQueryVariantDescriptor
	{
		public SpanWithinQueryDescriptor()
		{
		}

		internal SpanWithinQueryDescriptor(Action<SpanWithinQueryDescriptor> configure) => configure.Invoke(this);
		internal Elastic.Clients.Elasticsearch.QueryDsl.SpanQuery BigValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.SpanQuery LittleValue { get; private set; }

		internal SpanQueryDescriptor BigDescriptor { get; private set; }

		internal SpanQueryDescriptor LittleDescriptor { get; private set; }

		internal Action<SpanQueryDescriptor> BigDescriptorAction { get; private set; }

		internal Action<SpanQueryDescriptor> LittleDescriptorAction { get; private set; }

		public SpanWithinQueryDescriptor Big(Elastic.Clients.Elasticsearch.QueryDsl.SpanQuery big)
		{
			BigDescriptor = null;
			BigDescriptorAction = null;
			return Assign(big, (a, v) => a.BigValue = v);
		}

		public SpanWithinQueryDescriptor Big(Elastic.Clients.Elasticsearch.QueryDsl.SpanQueryDescriptor descriptor)
		{
			BigValue = null;
			BigDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.BigDescriptor = v);
		}

		public SpanWithinQueryDescriptor Big(Action<Elastic.Clients.Elasticsearch.QueryDsl.SpanQueryDescriptor> configure)
		{
			BigValue = null;
			BigDescriptorAction = null;
			return Assign(configure, (a, v) => a.BigDescriptorAction = v);
		}

		public SpanWithinQueryDescriptor Little(Elastic.Clients.Elasticsearch.QueryDsl.SpanQuery little)
		{
			LittleDescriptor = null;
			LittleDescriptorAction = null;
			return Assign(little, (a, v) => a.LittleValue = v);
		}

		public SpanWithinQueryDescriptor Little(Elastic.Clients.Elasticsearch.QueryDsl.SpanQueryDescriptor descriptor)
		{
			LittleValue = null;
			LittleDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.LittleDescriptor = v);
		}

		public SpanWithinQueryDescriptor Little(Action<Elastic.Clients.Elasticsearch.QueryDsl.SpanQueryDescriptor> configure)
		{
			LittleValue = null;
			LittleDescriptorAction = null;
			return Assign(configure, (a, v) => a.LittleDescriptorAction = v);
		}
	}

	internal sealed class SpanWithinQueryDescriptorConverter : JsonConverter<SpanWithinQueryDescriptor>
	{
		public override SpanWithinQueryDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, SpanWithinQueryDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value.BigDescriptor is not null)
			{
				writer.WritePropertyName("big");
				JsonSerializer.Serialize(writer, value.BigDescriptor, options);
			}
			else if (value.BigDescriptorAction is not null)
			{
				writer.WritePropertyName("big");
				JsonSerializer.Serialize(writer, new SpanQueryDescriptor(value.BigDescriptorAction), options);
			}
			else
			{
				writer.WritePropertyName("big");
				JsonSerializer.Serialize(writer, value.BigValue, options);
			}

			if (value.LittleDescriptor is not null)
			{
				writer.WritePropertyName("little");
				JsonSerializer.Serialize(writer, value.LittleDescriptor, options);
			}
			else if (value.LittleDescriptorAction is not null)
			{
				writer.WritePropertyName("little");
				JsonSerializer.Serialize(writer, new SpanQueryDescriptor(value.LittleDescriptorAction), options);
			}
			else
			{
				writer.WritePropertyName("little");
				JsonSerializer.Serialize(writer, value.LittleValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class TermQuery : FieldNameQueryBase, IQueryContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "term";
		[JsonInclude]
		[JsonPropertyName("value")]
		public object Value { get; set; }

		[JsonInclude]
		[JsonPropertyName("case_insensitive")]
		public bool? CaseInsensitive { get; set; }
	}

	[JsonConverter(typeof(TermQueryDescriptorConverter))]
	public sealed partial class TermQueryDescriptor : DescriptorBase<TermQueryDescriptor>, IQueryContainerVariantDescriptor
	{
		public TermQueryDescriptor()
		{
		}

		internal TermQueryDescriptor(Action<TermQueryDescriptor> configure) => configure.Invoke(this);
		internal object ValueValue { get; private set; }

		internal bool? CaseInsensitiveValue { get; private set; }

		public TermQueryDescriptor Value(object value) => Assign(value, (a, v) => a.ValueValue = v);
		public TermQueryDescriptor CaseInsensitive(bool? caseInsensitive = true) => Assign(caseInsensitive, (a, v) => a.CaseInsensitiveValue = v);
	}

	internal sealed class TermQueryDescriptorConverter : JsonConverter<TermQueryDescriptor>
	{
		public override TermQueryDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, TermQueryDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("value");
			JsonSerializer.Serialize(writer, value.ValueValue, options);
			if (value.CaseInsensitiveValue.HasValue)
			{
				writer.WritePropertyName("case_insensitive");
				writer.WriteBooleanValue(value.CaseInsensitiveValue.Value);
			}

			writer.WriteEndObject();
		}
	}

	public partial class TermsQuery : QueryDsl.QueryBase, IQueryContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "terms";
	}

	[JsonConverter(typeof(TermsQueryDescriptorConverter))]
	public sealed partial class TermsQueryDescriptor : DescriptorBase<TermsQueryDescriptor>, IQueryContainerVariantDescriptor
	{
		public TermsQueryDescriptor()
		{
		}

		internal TermsQueryDescriptor(Action<TermsQueryDescriptor> configure) => configure.Invoke(this);
	}

	internal sealed class TermsQueryDescriptorConverter : JsonConverter<TermsQueryDescriptor>
	{
		public override TermsQueryDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, TermsQueryDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WriteEndObject();
		}
	}

	public partial class TermsSetQuery : FieldNameQueryBase, IQueryContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "terms_set";
		[JsonInclude]
		[JsonPropertyName("minimum_should_match_field")]
		public string? MinimumShouldMatchField { get; set; }

		[JsonInclude]
		[JsonPropertyName("minimum_should_match_script")]
		public Elastic.Clients.Elasticsearch.Script? MinimumShouldMatchScript { get; set; }

		[JsonInclude]
		[JsonPropertyName("terms")]
		public IEnumerable<string> Terms { get; set; }
	}

	[JsonConverter(typeof(TermsSetQueryDescriptorConverter))]
	public sealed partial class TermsSetQueryDescriptor : DescriptorBase<TermsSetQueryDescriptor>, IQueryContainerVariantDescriptor
	{
		public TermsSetQueryDescriptor()
		{
		}

		internal TermsSetQueryDescriptor(Action<TermsSetQueryDescriptor> configure) => configure.Invoke(this);
		internal string? MinimumShouldMatchFieldValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Script? MinimumShouldMatchScriptValue { get; private set; }

		internal IEnumerable<string> TermsValue { get; private set; }

		public TermsSetQueryDescriptor MinimumShouldMatchField(string? minimumShouldMatchField) => Assign(minimumShouldMatchField, (a, v) => a.MinimumShouldMatchFieldValue = v);
		public TermsSetQueryDescriptor MinimumShouldMatchScript(Elastic.Clients.Elasticsearch.Script? minimumShouldMatchScript) => Assign(minimumShouldMatchScript, (a, v) => a.MinimumShouldMatchScriptValue = v);
		public TermsSetQueryDescriptor Terms(IEnumerable<string> terms) => Assign(terms, (a, v) => a.TermsValue = v);
	}

	internal sealed class TermsSetQueryDescriptorConverter : JsonConverter<TermsSetQueryDescriptor>
	{
		public override TermsSetQueryDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, TermsSetQueryDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value.MinimumShouldMatchFieldValue is not null)
			{
				writer.WritePropertyName("minimum_should_match_field");
				JsonSerializer.Serialize(writer, value.MinimumShouldMatchFieldValue, options);
			}

			if (value.MinimumShouldMatchScriptValue is not null)
			{
				writer.WritePropertyName("minimum_should_match_script");
				JsonSerializer.Serialize(writer, value.MinimumShouldMatchScriptValue, options);
			}

			writer.WritePropertyName("terms");
			JsonSerializer.Serialize(writer, value.TermsValue, options);
			writer.WriteEndObject();
		}
	}

	public partial class TwoDimensionalPoint
	{
		[JsonInclude]
		[JsonPropertyName("lat")]
		public double Lat { get; init; }

		[JsonInclude]
		[JsonPropertyName("lon")]
		public double Lon { get; init; }
	}

	public partial class WildcardQuery : FieldNameQueryBase, IQueryContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "wildcard";
		[JsonInclude]
		[JsonPropertyName("case_insensitive")]
		public bool? CaseInsensitive { get; set; }

		[JsonInclude]
		[JsonPropertyName("rewrite")]
		public string? Rewrite { get; set; }

		[JsonInclude]
		[JsonPropertyName("value")]
		public string? Value { get; set; }

		[JsonInclude]
		[JsonPropertyName("wildcard")]
		public string? Wildcard { get; set; }
	}

	[JsonConverter(typeof(WildcardQueryDescriptorConverter))]
	public sealed partial class WildcardQueryDescriptor : DescriptorBase<WildcardQueryDescriptor>, IQueryContainerVariantDescriptor
	{
		public WildcardQueryDescriptor()
		{
		}

		internal WildcardQueryDescriptor(Action<WildcardQueryDescriptor> configure) => configure.Invoke(this);
		internal bool? CaseInsensitiveValue { get; private set; }

		internal string? RewriteValue { get; private set; }

		internal string? ValueValue { get; private set; }

		internal string? WildcardValue { get; private set; }

		public WildcardQueryDescriptor CaseInsensitive(bool? caseInsensitive = true) => Assign(caseInsensitive, (a, v) => a.CaseInsensitiveValue = v);
		public WildcardQueryDescriptor Rewrite(string? rewrite) => Assign(rewrite, (a, v) => a.RewriteValue = v);
		public WildcardQueryDescriptor Value(string? value) => Assign(value, (a, v) => a.ValueValue = v);
		public WildcardQueryDescriptor Wildcard(string? wildcard) => Assign(wildcard, (a, v) => a.WildcardValue = v);
	}

	internal sealed class WildcardQueryDescriptorConverter : JsonConverter<WildcardQueryDescriptor>
	{
		public override WildcardQueryDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, WildcardQueryDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value.CaseInsensitiveValue.HasValue)
			{
				writer.WritePropertyName("case_insensitive");
				writer.WriteBooleanValue(value.CaseInsensitiveValue.Value);
			}

			if (value.RewriteValue is not null)
			{
				writer.WritePropertyName("rewrite");
				JsonSerializer.Serialize(writer, value.RewriteValue, options);
			}

			if (!string.IsNullOrEmpty(value.ValueValue))
			{
				writer.WritePropertyName("value");
				writer.WriteStringValue(value.ValueValue);
			}

			if (!string.IsNullOrEmpty(value.WildcardValue))
			{
				writer.WritePropertyName("wildcard");
				writer.WriteStringValue(value.WildcardValue);
			}

			writer.WriteEndObject();
		}
	}
}
