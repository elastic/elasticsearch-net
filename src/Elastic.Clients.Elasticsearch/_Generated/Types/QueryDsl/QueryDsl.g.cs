// Licensed to Elasticsearch B.V under one or more agreements.
// Elasticsearch B.V licenses this file to you under the Apache 2.0 License.
// See the LICENSE file in the project root for more information.
//
// ███╗   ██╗ ██████╗ ████████╗██╗ ██████╗███████╗
// ████╗  ██║██╔═══██╗╚══██╔══╝██║██╔════╝██╔════╝
// ██╔██╗ ██║██║   ██║   ██║   ██║██║     █████╗
// ██║╚██╗██║██║   ██║   ██║   ██║██║     ██╔══╝
// ██║ ╚████║╚██████╔╝   ██║   ██║╚██████╗███████╗
// ╚═╝  ╚═══╝ ╚═════╝    ╚═╝   ╚═╝ ╚═════╝╚══════╝
// ------------------------------------------------
//
// This file is automatically generated.
// Please do not edit these files manually.
//
// ------------------------------------------------

using System;
using System.Collections.Generic;
using System.Text.Json;
using System.Text.Json.Serialization;

#nullable restore
namespace Elastic.Clients.Elasticsearch.QueryDsl
{
	public partial class BoolQuery : QueryDsl.QueryBase, IQueryContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "bool";
		[JsonInclude]
		[JsonPropertyName("filter")]
		public Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? Filter { get; set; }

		[JsonInclude]
		[JsonPropertyName("minimum_should_match")]
		public Elastic.Clients.Elasticsearch.MinimumShouldMatch? MinimumShouldMatch { get; set; }

		[JsonInclude]
		[JsonPropertyName("must")]
		public Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? Must { get; set; }

		[JsonInclude]
		[JsonPropertyName("must_not")]
		public Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? MustNot { get; set; }

		[JsonInclude]
		[JsonPropertyName("should")]
		public Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? Should { get; set; }
	}

	public sealed partial class BoolQueryDescriptor<T> : DescriptorBase<BoolQueryDescriptor<T>>
	{
		public BoolQueryDescriptor()
		{
		}

		internal BoolQueryDescriptor(Action<BoolQueryDescriptor<T>> configure) => configure.Invoke(this);
		internal Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? FilterValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.MinimumShouldMatch? MinimumShouldMatchValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? MustValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? MustNotValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? ShouldValue { get; private set; }

		internal QueryContainerDescriptor<T> FilterDescriptor { get; private set; }

		internal QueryContainerDescriptor<T> MustDescriptor { get; private set; }

		internal QueryContainerDescriptor<T> MustNotDescriptor { get; private set; }

		internal QueryContainerDescriptor<T> ShouldDescriptor { get; private set; }

		internal Action<QueryContainerDescriptor<T>> FilterDescriptorAction { get; private set; }

		internal Action<QueryContainerDescriptor<T>> MustDescriptorAction { get; private set; }

		internal Action<QueryContainerDescriptor<T>> MustNotDescriptorAction { get; private set; }

		internal Action<QueryContainerDescriptor<T>> ShouldDescriptorAction { get; private set; }

		public BoolQueryDescriptor<T> Filter(Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? filter)
		{
			FilterDescriptor = null;
			FilterDescriptorAction = null;
			return Assign(filter, (a, v) => a.FilterValue = v);
		}

		public BoolQueryDescriptor<T> Filter(Elastic.Clients.Elasticsearch.QueryDsl.QueryContainerDescriptor<T> descriptor)
		{
			FilterValue = null;
			FilterDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.FilterDescriptor = v);
		}

		public BoolQueryDescriptor<T> Filter(Action<Elastic.Clients.Elasticsearch.QueryDsl.QueryContainerDescriptor<T>> configure)
		{
			FilterValue = null;
			FilterDescriptorAction = null;
			return Assign(configure, (a, v) => a.FilterDescriptorAction = v);
		}

		public BoolQueryDescriptor<T> MinimumShouldMatch(Elastic.Clients.Elasticsearch.MinimumShouldMatch? minimumShouldMatch) => Assign(minimumShouldMatch, (a, v) => a.MinimumShouldMatchValue = v);
		public BoolQueryDescriptor<T> Must(Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? must)
		{
			MustDescriptor = null;
			MustDescriptorAction = null;
			return Assign(must, (a, v) => a.MustValue = v);
		}

		public BoolQueryDescriptor<T> Must(Elastic.Clients.Elasticsearch.QueryDsl.QueryContainerDescriptor<T> descriptor)
		{
			MustValue = null;
			MustDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.MustDescriptor = v);
		}

		public BoolQueryDescriptor<T> Must(Action<Elastic.Clients.Elasticsearch.QueryDsl.QueryContainerDescriptor<T>> configure)
		{
			MustValue = null;
			MustDescriptorAction = null;
			return Assign(configure, (a, v) => a.MustDescriptorAction = v);
		}

		public BoolQueryDescriptor<T> MustNot(Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? mustNot)
		{
			MustNotDescriptor = null;
			MustNotDescriptorAction = null;
			return Assign(mustNot, (a, v) => a.MustNotValue = v);
		}

		public BoolQueryDescriptor<T> MustNot(Elastic.Clients.Elasticsearch.QueryDsl.QueryContainerDescriptor<T> descriptor)
		{
			MustNotValue = null;
			MustNotDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.MustNotDescriptor = v);
		}

		public BoolQueryDescriptor<T> MustNot(Action<Elastic.Clients.Elasticsearch.QueryDsl.QueryContainerDescriptor<T>> configure)
		{
			MustNotValue = null;
			MustNotDescriptorAction = null;
			return Assign(configure, (a, v) => a.MustNotDescriptorAction = v);
		}

		public BoolQueryDescriptor<T> Should(Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? should)
		{
			ShouldDescriptor = null;
			ShouldDescriptorAction = null;
			return Assign(should, (a, v) => a.ShouldValue = v);
		}

		public BoolQueryDescriptor<T> Should(Elastic.Clients.Elasticsearch.QueryDsl.QueryContainerDescriptor<T> descriptor)
		{
			ShouldValue = null;
			ShouldDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.ShouldDescriptor = v);
		}

		public BoolQueryDescriptor<T> Should(Action<Elastic.Clients.Elasticsearch.QueryDsl.QueryContainerDescriptor<T>> configure)
		{
			ShouldValue = null;
			ShouldDescriptorAction = null;
			return Assign(configure, (a, v) => a.ShouldDescriptorAction = v);
		}

		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (FilterDescriptor is not null)
			{
				writer.WritePropertyName("filter");
				JsonSerializer.Serialize(writer, FilterDescriptor, options);
			}
			else if (FilterDescriptorAction is not null)
			{
				writer.WritePropertyName("filter");
				JsonSerializer.Serialize(writer, new QueryContainerDescriptor<T>(FilterDescriptorAction), options);
			}
			else if (FilterValue is not null)
			{
				writer.WritePropertyName("filter");
				JsonSerializer.Serialize(writer, FilterValue, options);
			}

			if (MinimumShouldMatchValue is not null)
			{
				writer.WritePropertyName("minimum_should_match");
				JsonSerializer.Serialize(writer, MinimumShouldMatchValue, options);
			}

			if (MustDescriptor is not null)
			{
				writer.WritePropertyName("must");
				JsonSerializer.Serialize(writer, MustDescriptor, options);
			}
			else if (MustDescriptorAction is not null)
			{
				writer.WritePropertyName("must");
				JsonSerializer.Serialize(writer, new QueryContainerDescriptor<T>(MustDescriptorAction), options);
			}
			else if (MustValue is not null)
			{
				writer.WritePropertyName("must");
				JsonSerializer.Serialize(writer, MustValue, options);
			}

			if (MustNotDescriptor is not null)
			{
				writer.WritePropertyName("must_not");
				JsonSerializer.Serialize(writer, MustNotDescriptor, options);
			}
			else if (MustNotDescriptorAction is not null)
			{
				writer.WritePropertyName("must_not");
				JsonSerializer.Serialize(writer, new QueryContainerDescriptor<T>(MustNotDescriptorAction), options);
			}
			else if (MustNotValue is not null)
			{
				writer.WritePropertyName("must_not");
				JsonSerializer.Serialize(writer, MustNotValue, options);
			}

			if (ShouldDescriptor is not null)
			{
				writer.WritePropertyName("should");
				JsonSerializer.Serialize(writer, ShouldDescriptor, options);
			}
			else if (ShouldDescriptorAction is not null)
			{
				writer.WritePropertyName("should");
				JsonSerializer.Serialize(writer, new QueryContainerDescriptor<T>(ShouldDescriptorAction), options);
			}
			else if (ShouldValue is not null)
			{
				writer.WritePropertyName("should");
				JsonSerializer.Serialize(writer, ShouldValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class BoostingQuery : QueryDsl.QueryBase, IQueryContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "boosting";
		[JsonInclude]
		[JsonPropertyName("negative_boost")]
		public double NegativeBoost { get; set; }

		[JsonInclude]
		[JsonPropertyName("negative")]
		public Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer Negative { get; set; }

		[JsonInclude]
		[JsonPropertyName("positive")]
		public Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer Positive { get; set; }
	}

	public sealed partial class BoostingQueryDescriptor<T> : DescriptorBase<BoostingQueryDescriptor<T>>
	{
		public BoostingQueryDescriptor()
		{
		}

		internal BoostingQueryDescriptor(Action<BoostingQueryDescriptor<T>> configure) => configure.Invoke(this);
		internal double NegativeBoostValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer NegativeValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer PositiveValue { get; private set; }

		internal QueryContainerDescriptor<T> NegativeDescriptor { get; private set; }

		internal QueryContainerDescriptor<T> PositiveDescriptor { get; private set; }

		internal Action<QueryContainerDescriptor<T>> NegativeDescriptorAction { get; private set; }

		internal Action<QueryContainerDescriptor<T>> PositiveDescriptorAction { get; private set; }

		public BoostingQueryDescriptor<T> NegativeBoost(double negativeBoost) => Assign(negativeBoost, (a, v) => a.NegativeBoostValue = v);
		public BoostingQueryDescriptor<T> Negative(Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer negative)
		{
			NegativeDescriptor = null;
			NegativeDescriptorAction = null;
			return Assign(negative, (a, v) => a.NegativeValue = v);
		}

		public BoostingQueryDescriptor<T> Negative(Elastic.Clients.Elasticsearch.QueryDsl.QueryContainerDescriptor<T> descriptor)
		{
			NegativeValue = null;
			NegativeDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.NegativeDescriptor = v);
		}

		public BoostingQueryDescriptor<T> Negative(Action<Elastic.Clients.Elasticsearch.QueryDsl.QueryContainerDescriptor<T>> configure)
		{
			NegativeValue = null;
			NegativeDescriptorAction = null;
			return Assign(configure, (a, v) => a.NegativeDescriptorAction = v);
		}

		public BoostingQueryDescriptor<T> Positive(Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer positive)
		{
			PositiveDescriptor = null;
			PositiveDescriptorAction = null;
			return Assign(positive, (a, v) => a.PositiveValue = v);
		}

		public BoostingQueryDescriptor<T> Positive(Elastic.Clients.Elasticsearch.QueryDsl.QueryContainerDescriptor<T> descriptor)
		{
			PositiveValue = null;
			PositiveDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.PositiveDescriptor = v);
		}

		public BoostingQueryDescriptor<T> Positive(Action<Elastic.Clients.Elasticsearch.QueryDsl.QueryContainerDescriptor<T>> configure)
		{
			PositiveValue = null;
			PositiveDescriptorAction = null;
			return Assign(configure, (a, v) => a.PositiveDescriptorAction = v);
		}

		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("negative_boost");
			writer.WriteNumberValue(NegativeBoostValue);
			if (NegativeDescriptor is not null)
			{
				writer.WritePropertyName("negative");
				JsonSerializer.Serialize(writer, NegativeDescriptor, options);
			}
			else if (NegativeDescriptorAction is not null)
			{
				writer.WritePropertyName("negative");
				JsonSerializer.Serialize(writer, new QueryContainerDescriptor<T>(NegativeDescriptorAction), options);
			}
			else
			{
				writer.WritePropertyName("negative");
				JsonSerializer.Serialize(writer, NegativeValue, options);
			}

			if (PositiveDescriptor is not null)
			{
				writer.WritePropertyName("positive");
				JsonSerializer.Serialize(writer, PositiveDescriptor, options);
			}
			else if (PositiveDescriptorAction is not null)
			{
				writer.WritePropertyName("positive");
				JsonSerializer.Serialize(writer, new QueryContainerDescriptor<T>(PositiveDescriptorAction), options);
			}
			else
			{
				writer.WritePropertyName("positive");
				JsonSerializer.Serialize(writer, PositiveValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class CombinedFieldsQuery : QueryDsl.QueryBase, IQueryContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "combined_fields";
		[JsonInclude]
		[JsonPropertyName("fields")]
		public IEnumerable<string> Fields { get; set; }

		[JsonInclude]
		[JsonPropertyName("query")]
		public string Query { get; set; }

		[JsonInclude]
		[JsonPropertyName("auto_generate_synonyms_phrase_query")]
		public bool? AutoGenerateSynonymsPhraseQuery { get; set; }

		[JsonInclude]
		[JsonPropertyName("operator")]
		public Elastic.Clients.Elasticsearch.QueryDsl.CombinedFieldsOperator? Operator { get; set; }

		[JsonInclude]
		[JsonPropertyName("mimimum_should_match")]
		public Elastic.Clients.Elasticsearch.MinimumShouldMatch? MimimumShouldMatch { get; set; }

		[JsonInclude]
		[JsonPropertyName("zero_terms_query")]
		public Elastic.Clients.Elasticsearch.QueryDsl.CombinedFieldsZeroTerms? ZeroTermsQuery { get; set; }
	}

	public sealed partial class CombinedFieldsQueryDescriptor<T> : DescriptorBase<CombinedFieldsQueryDescriptor<T>>
	{
		public CombinedFieldsQueryDescriptor()
		{
		}

		internal CombinedFieldsQueryDescriptor(Action<CombinedFieldsQueryDescriptor<T>> configure) => configure.Invoke(this);
		internal IEnumerable<string> FieldsValue { get; private set; }

		internal string QueryValue { get; private set; }

		internal bool? AutoGenerateSynonymsPhraseQueryValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.CombinedFieldsOperator? OperatorValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.MinimumShouldMatch? MimimumShouldMatchValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.CombinedFieldsZeroTerms? ZeroTermsQueryValue { get; private set; }

		public CombinedFieldsQueryDescriptor<T> Fields(IEnumerable<string> fields) => Assign(fields, (a, v) => a.FieldsValue = v);
		public CombinedFieldsQueryDescriptor<T> Query(string query) => Assign(query, (a, v) => a.QueryValue = v);
		public CombinedFieldsQueryDescriptor<T> AutoGenerateSynonymsPhraseQuery(bool? autoGenerateSynonymsPhraseQuery = true) => Assign(autoGenerateSynonymsPhraseQuery, (a, v) => a.AutoGenerateSynonymsPhraseQueryValue = v);
		public CombinedFieldsQueryDescriptor<T> Operator(Elastic.Clients.Elasticsearch.QueryDsl.CombinedFieldsOperator? op) => Assign(op, (a, v) => a.OperatorValue = v);
		public CombinedFieldsQueryDescriptor<T> MimimumShouldMatch(Elastic.Clients.Elasticsearch.MinimumShouldMatch? mimimumShouldMatch) => Assign(mimimumShouldMatch, (a, v) => a.MimimumShouldMatchValue = v);
		public CombinedFieldsQueryDescriptor<T> ZeroTermsQuery(Elastic.Clients.Elasticsearch.QueryDsl.CombinedFieldsZeroTerms? zeroTermsQuery) => Assign(zeroTermsQuery, (a, v) => a.ZeroTermsQueryValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("fields");
			JsonSerializer.Serialize(writer, FieldsValue, options);
			writer.WritePropertyName("query");
			writer.WriteStringValue(QueryValue);
			if (AutoGenerateSynonymsPhraseQueryValue.HasValue)
			{
				writer.WritePropertyName("auto_generate_synonyms_phrase_query");
				writer.WriteBooleanValue(AutoGenerateSynonymsPhraseQueryValue.Value);
			}

			if (OperatorValue is not null)
			{
				writer.WritePropertyName("operator");
				JsonSerializer.Serialize(writer, OperatorValue, options);
			}

			if (MimimumShouldMatchValue is not null)
			{
				writer.WritePropertyName("mimimum_should_match");
				JsonSerializer.Serialize(writer, MimimumShouldMatchValue, options);
			}

			if (ZeroTermsQueryValue is not null)
			{
				writer.WritePropertyName("zero_terms_query");
				JsonSerializer.Serialize(writer, ZeroTermsQueryValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class ConstantScoreQuery : QueryDsl.QueryBase, IQueryContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "constant_score";
		[JsonInclude]
		[JsonPropertyName("filter")]
		public Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer Filter { get; set; }
	}

	public sealed partial class ConstantScoreQueryDescriptor<T> : DescriptorBase<ConstantScoreQueryDescriptor<T>>
	{
		public ConstantScoreQueryDescriptor()
		{
		}

		internal ConstantScoreQueryDescriptor(Action<ConstantScoreQueryDescriptor<T>> configure) => configure.Invoke(this);
		internal Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer FilterValue { get; private set; }

		internal QueryContainerDescriptor<T> FilterDescriptor { get; private set; }

		internal Action<QueryContainerDescriptor<T>> FilterDescriptorAction { get; private set; }

		public ConstantScoreQueryDescriptor<T> Filter(Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer filter)
		{
			FilterDescriptor = null;
			FilterDescriptorAction = null;
			return Assign(filter, (a, v) => a.FilterValue = v);
		}

		public ConstantScoreQueryDescriptor<T> Filter(Elastic.Clients.Elasticsearch.QueryDsl.QueryContainerDescriptor<T> descriptor)
		{
			FilterValue = null;
			FilterDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.FilterDescriptor = v);
		}

		public ConstantScoreQueryDescriptor<T> Filter(Action<Elastic.Clients.Elasticsearch.QueryDsl.QueryContainerDescriptor<T>> configure)
		{
			FilterValue = null;
			FilterDescriptorAction = null;
			return Assign(configure, (a, v) => a.FilterDescriptorAction = v);
		}

		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (FilterDescriptor is not null)
			{
				writer.WritePropertyName("filter");
				JsonSerializer.Serialize(writer, FilterDescriptor, options);
			}
			else if (FilterDescriptorAction is not null)
			{
				writer.WritePropertyName("filter");
				JsonSerializer.Serialize(writer, new QueryContainerDescriptor<T>(FilterDescriptorAction), options);
			}
			else
			{
				writer.WritePropertyName("filter");
				JsonSerializer.Serialize(writer, FilterValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class DisMaxQuery : QueryDsl.QueryBase, IQueryContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "dis_max";
		[JsonInclude]
		[JsonPropertyName("queries")]
		public IEnumerable<Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer> Queries { get; set; }

		[JsonInclude]
		[JsonPropertyName("tie_breaker")]
		public double? TieBreaker { get; set; }
	}

	public sealed partial class DisMaxQueryDescriptor : DescriptorBase<DisMaxQueryDescriptor>
	{
		public DisMaxQueryDescriptor()
		{
		}

		internal DisMaxQueryDescriptor(Action<DisMaxQueryDescriptor> configure) => configure.Invoke(this);
		internal IEnumerable<Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer> QueriesValue { get; private set; }

		internal double? TieBreakerValue { get; private set; }

		public DisMaxQueryDescriptor Queries(IEnumerable<Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer> queries) => Assign(queries, (a, v) => a.QueriesValue = v);
		public DisMaxQueryDescriptor TieBreaker(double? tieBreaker) => Assign(tieBreaker, (a, v) => a.TieBreakerValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("queries");
			JsonSerializer.Serialize(writer, QueriesValue, options);
			if (TieBreakerValue.HasValue)
			{
				writer.WritePropertyName("tie_breaker");
				writer.WriteNumberValue(TieBreakerValue.Value);
			}

			writer.WriteEndObject();
		}
	}

	public partial class ExistsQuery : QueryDsl.QueryBase, IQueryContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "exists";
		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }
	}

	public sealed partial class ExistsQueryDescriptor<T> : DescriptorBase<ExistsQueryDescriptor<T>>
	{
		public ExistsQueryDescriptor()
		{
		}

		internal ExistsQueryDescriptor(Action<ExistsQueryDescriptor<T>> configure) => configure.Invoke(this);
		internal string FieldValue { get; private set; }

		public ExistsQueryDescriptor<T> Field(string field) => Assign(field, (a, v) => a.FieldValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, FieldValue, options);
			writer.WriteEndObject();
		}
	}

	public partial class FieldAndFormat
	{
		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("format")]
		public string? Format { get; set; }

		[JsonInclude]
		[JsonPropertyName("include_unmapped")]
		public bool? IncludeUnmapped { get; set; }
	}

	public sealed partial class FieldAndFormatDescriptor<T> : DescriptorBase<FieldAndFormatDescriptor<T>>
	{
		public FieldAndFormatDescriptor()
		{
		}

		internal FieldAndFormatDescriptor(Action<FieldAndFormatDescriptor<T>> configure) => configure.Invoke(this);
		internal string FieldValue { get; private set; }

		internal string? FormatValue { get; private set; }

		internal bool? IncludeUnmappedValue { get; private set; }

		public FieldAndFormatDescriptor<T> Field(string field) => Assign(field, (a, v) => a.FieldValue = v);
		public FieldAndFormatDescriptor<T> Format(string? format) => Assign(format, (a, v) => a.FormatValue = v);
		public FieldAndFormatDescriptor<T> IncludeUnmapped(bool? includeUnmapped = true) => Assign(includeUnmapped, (a, v) => a.IncludeUnmappedValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, FieldValue, options);
			if (!string.IsNullOrEmpty(FormatValue))
			{
				writer.WritePropertyName("format");
				writer.WriteStringValue(FormatValue);
			}

			if (IncludeUnmappedValue.HasValue)
			{
				writer.WritePropertyName("include_unmapped");
				writer.WriteBooleanValue(IncludeUnmappedValue.Value);
			}

			writer.WriteEndObject();
		}
	}

	public partial class FieldValueFactorScoreFunction : QueryDsl.ScoreFunctionBase, IFunctionScoreContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IFunctionScoreContainerVariant.FunctionScoreContainerVariantName => "field_value_factor";
		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("factor")]
		public double? Factor { get; set; }

		[JsonInclude]
		[JsonPropertyName("missing")]
		public double? Missing { get; set; }

		[JsonInclude]
		[JsonPropertyName("modifier")]
		public Elastic.Clients.Elasticsearch.QueryDsl.FieldValueFactorModifier? Modifier { get; set; }
	}

	public sealed partial class FieldValueFactorScoreFunctionDescriptor<T> : DescriptorBase<FieldValueFactorScoreFunctionDescriptor<T>>
	{
		public FieldValueFactorScoreFunctionDescriptor()
		{
		}

		internal FieldValueFactorScoreFunctionDescriptor(Action<FieldValueFactorScoreFunctionDescriptor<T>> configure) => configure.Invoke(this);
		internal string FieldValue { get; private set; }

		internal double? FactorValue { get; private set; }

		internal double? MissingValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.FieldValueFactorModifier? ModifierValue { get; private set; }

		public FieldValueFactorScoreFunctionDescriptor<T> Field(string field) => Assign(field, (a, v) => a.FieldValue = v);
		public FieldValueFactorScoreFunctionDescriptor<T> Factor(double? factor) => Assign(factor, (a, v) => a.FactorValue = v);
		public FieldValueFactorScoreFunctionDescriptor<T> Missing(double? missing) => Assign(missing, (a, v) => a.MissingValue = v);
		public FieldValueFactorScoreFunctionDescriptor<T> Modifier(Elastic.Clients.Elasticsearch.QueryDsl.FieldValueFactorModifier? modifier) => Assign(modifier, (a, v) => a.ModifierValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, FieldValue, options);
			if (FactorValue.HasValue)
			{
				writer.WritePropertyName("factor");
				writer.WriteNumberValue(FactorValue.Value);
			}

			if (MissingValue.HasValue)
			{
				writer.WritePropertyName("missing");
				writer.WriteNumberValue(MissingValue.Value);
			}

			if (ModifierValue is not null)
			{
				writer.WritePropertyName("modifier");
				JsonSerializer.Serialize(writer, ModifierValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public interface IFunctionScoreContainerVariant
	{
		string FunctionScoreContainerVariantName { get; }
	}

	[JsonConverter(typeof(FunctionScoreContainerConverter))]
	public partial class FunctionScoreContainer : IContainer
	{
		public FunctionScoreContainer(IFunctionScoreContainerVariant variant) => Variant = variant ?? throw new ArgumentNullException(nameof(variant));
		internal IFunctionScoreContainerVariant Variant { get; }

		[JsonInclude]
		[JsonPropertyName("filter")]
		public Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? Filter { get; set; }

		[JsonInclude]
		[JsonPropertyName("weight")]
		public double? Weight { get; set; }
	}

	internal sealed class FunctionScoreContainerConverter : JsonConverter<FunctionScoreContainer>
	{
		public override FunctionScoreContainer Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			reader.Read();
			if (reader.TokenType != JsonTokenType.PropertyName)
			{
				throw new JsonException();
			}

			var propertyName = reader.GetString();
			if (propertyName == "field_value_factor")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.FieldValueFactorScoreFunction?>(ref reader, options);
				reader.Read();
				return new FunctionScoreContainer(variant);
			}

			if (propertyName == "random_score")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.RandomScoreFunction?>(ref reader, options);
				reader.Read();
				return new FunctionScoreContainer(variant);
			}

			if (propertyName == "script_score")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.ScriptScoreFunction?>(ref reader, options);
				reader.Read();
				return new FunctionScoreContainer(variant);
			}

			throw new JsonException();
		}

		public override void Write(Utf8JsonWriter writer, FunctionScoreContainer value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName(value.Variant.FunctionScoreContainerVariantName);
			switch (value.Variant)
			{
				case Elastic.Clients.Elasticsearch.QueryDsl.FieldValueFactorScoreFunction variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.RandomScoreFunction variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.ScriptScoreFunction variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
			}

			writer.WriteEndObject();
		}
	}

	public sealed partial class FunctionScoreContainerDescriptor<T> : DescriptorBase<FunctionScoreContainerDescriptor<T>>
	{
		public FunctionScoreContainerDescriptor()
		{
		}

		internal FunctionScoreContainerDescriptor(Action<FunctionScoreContainerDescriptor<T>> configure) => configure.Invoke(this);
		internal bool ContainsVariant { get; private set; }

		internal string ContainedVariantName { get; private set; }

		internal FunctionScoreContainer Container { get; private set; }

		internal object ContainerVariantDescriptorAction { get; private set; }

		private void Set(object descriptorAction, string variantName)
		{
			if (ContainsVariant)
				throw new Exception("TODO");
			ContainerVariantDescriptorAction = descriptorAction;
			ContainedVariantName = variantName;
			ContainsVariant = true;
		}

		private void Set(IFunctionScoreContainerVariant variant, string variantName)
		{
			if (ContainsVariant)
				throw new Exception("TODO");
			Container = new FunctionScoreContainer(variant);
			ContainedVariantName = variantName;
			ContainsVariant = true;
		}

		public void FieldValueFactor(FieldValueFactorScoreFunction variant) => Set(variant, "field_value_factor");
		public void FieldValueFactor(Action<FieldValueFactorScoreFunctionDescriptor<T>> configure) => Set(configure, "field_value_factor");
		public void RandomScore(RandomScoreFunction variant) => Set(variant, "random_score");
		public void RandomScore(Action<RandomScoreFunctionDescriptor<T>> configure) => Set(configure, "random_score");
		public void ScriptScore(ScriptScoreFunction variant) => Set(variant, "script_score");
		public void ScriptScore(Action<ScriptScoreFunctionDescriptor> configure) => Set(configure, "script_score");
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			if (!ContainsVariant)
			{
				writer.WriteNullValue();
				return;
			}

			writer.WriteStartObject();
			writer.WritePropertyName(ContainedVariantName);
			writer.WriteStartObject();
			if (Container is not null)
			{
				JsonSerializer.Serialize(writer, Container, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "field_value_factor")
			{
				var descriptor = new FieldValueFactorScoreFunctionDescriptor<T>();
				((Action<FieldValueFactorScoreFunctionDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "random_score")
			{
				var descriptor = new RandomScoreFunctionDescriptor<T>();
				((Action<RandomScoreFunctionDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "script_score")
			{
				var descriptor = new ScriptScoreFunctionDescriptor();
				((Action<ScriptScoreFunctionDescriptor>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			writer.WriteEndObject();
			writer.WriteEndObject();
			void Finalise()
			{
				writer.WriteEndObject();
				writer.WriteEndObject();
			}
		}
	}

	public partial class FunctionScoreQuery : QueryDsl.QueryBase, IQueryContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "function_score";
		[JsonInclude]
		[JsonPropertyName("boost_mode")]
		public Elastic.Clients.Elasticsearch.QueryDsl.FunctionBoostMode? BoostMode { get; set; }

		[JsonInclude]
		[JsonPropertyName("functions")]
		public IEnumerable<Elastic.Clients.Elasticsearch.QueryDsl.FunctionScoreContainer>? Functions { get; set; }

		[JsonInclude]
		[JsonPropertyName("max_boost")]
		public double? MaxBoost { get; set; }

		[JsonInclude]
		[JsonPropertyName("min_score")]
		public double? MinScore { get; set; }

		[JsonInclude]
		[JsonPropertyName("query")]
		public Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? Query { get; set; }

		[JsonInclude]
		[JsonPropertyName("score_mode")]
		public Elastic.Clients.Elasticsearch.QueryDsl.FunctionScoreMode? ScoreMode { get; set; }
	}

	public sealed partial class FunctionScoreQueryDescriptor<T> : DescriptorBase<FunctionScoreQueryDescriptor<T>>
	{
		public FunctionScoreQueryDescriptor()
		{
		}

		internal FunctionScoreQueryDescriptor(Action<FunctionScoreQueryDescriptor<T>> configure) => configure.Invoke(this);
		internal Elastic.Clients.Elasticsearch.QueryDsl.FunctionBoostMode? BoostModeValue { get; private set; }

		internal IEnumerable<Elastic.Clients.Elasticsearch.QueryDsl.FunctionScoreContainer>? FunctionsValue { get; private set; }

		internal double? MaxBoostValue { get; private set; }

		internal double? MinScoreValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? QueryValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.FunctionScoreMode? ScoreModeValue { get; private set; }

		internal QueryContainerDescriptor<T> QueryDescriptor { get; private set; }

		internal Action<QueryContainerDescriptor<T>> QueryDescriptorAction { get; private set; }

		public FunctionScoreQueryDescriptor<T> BoostMode(Elastic.Clients.Elasticsearch.QueryDsl.FunctionBoostMode? boostMode) => Assign(boostMode, (a, v) => a.BoostModeValue = v);
		public FunctionScoreQueryDescriptor<T> Functions(IEnumerable<Elastic.Clients.Elasticsearch.QueryDsl.FunctionScoreContainer>? functions) => Assign(functions, (a, v) => a.FunctionsValue = v);
		public FunctionScoreQueryDescriptor<T> MaxBoost(double? maxBoost) => Assign(maxBoost, (a, v) => a.MaxBoostValue = v);
		public FunctionScoreQueryDescriptor<T> MinScore(double? minScore) => Assign(minScore, (a, v) => a.MinScoreValue = v);
		public FunctionScoreQueryDescriptor<T> Query(Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? query)
		{
			QueryDescriptor = null;
			QueryDescriptorAction = null;
			return Assign(query, (a, v) => a.QueryValue = v);
		}

		public FunctionScoreQueryDescriptor<T> Query(Elastic.Clients.Elasticsearch.QueryDsl.QueryContainerDescriptor<T> descriptor)
		{
			QueryValue = null;
			QueryDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.QueryDescriptor = v);
		}

		public FunctionScoreQueryDescriptor<T> Query(Action<Elastic.Clients.Elasticsearch.QueryDsl.QueryContainerDescriptor<T>> configure)
		{
			QueryValue = null;
			QueryDescriptorAction = null;
			return Assign(configure, (a, v) => a.QueryDescriptorAction = v);
		}

		public FunctionScoreQueryDescriptor<T> ScoreMode(Elastic.Clients.Elasticsearch.QueryDsl.FunctionScoreMode? scoreMode) => Assign(scoreMode, (a, v) => a.ScoreModeValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (BoostModeValue is not null)
			{
				writer.WritePropertyName("boost_mode");
				JsonSerializer.Serialize(writer, BoostModeValue, options);
			}

			if (FunctionsValue is not null)
			{
				writer.WritePropertyName("functions");
				JsonSerializer.Serialize(writer, FunctionsValue, options);
			}

			if (MaxBoostValue.HasValue)
			{
				writer.WritePropertyName("max_boost");
				writer.WriteNumberValue(MaxBoostValue.Value);
			}

			if (MinScoreValue.HasValue)
			{
				writer.WritePropertyName("min_score");
				writer.WriteNumberValue(MinScoreValue.Value);
			}

			if (QueryDescriptor is not null)
			{
				writer.WritePropertyName("query");
				JsonSerializer.Serialize(writer, QueryDescriptor, options);
			}
			else if (QueryDescriptorAction is not null)
			{
				writer.WritePropertyName("query");
				JsonSerializer.Serialize(writer, new QueryContainerDescriptor<T>(QueryDescriptorAction), options);
			}
			else if (QueryValue is not null)
			{
				writer.WritePropertyName("query");
				JsonSerializer.Serialize(writer, QueryValue, options);
			}

			if (ScoreModeValue is not null)
			{
				writer.WritePropertyName("score_mode");
				JsonSerializer.Serialize(writer, ScoreModeValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class FuzzyQuery : FieldNameQueryBase, IQueryContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "fuzzy";
		[JsonInclude]
		[JsonPropertyName("max_expansions")]
		public int? MaxExpansions { get; set; }

		[JsonInclude]
		[JsonPropertyName("prefix_length")]
		public int? PrefixLength { get; set; }

		[JsonInclude]
		[JsonPropertyName("rewrite")]
		public string? Rewrite { get; set; }

		[JsonInclude]
		[JsonPropertyName("transpositions")]
		public bool? Transpositions { get; set; }

		[JsonInclude]
		[JsonPropertyName("fuzziness")]
		public Elastic.Clients.Elasticsearch.Fuzziness? Fuzziness { get; set; }

		[JsonInclude]
		[JsonPropertyName("value")]
		public object Value { get; set; }
	}

	public sealed partial class FuzzyQueryDescriptor : FieldNameQueryDescriptorBase<FuzzyQueryDescriptor>
	{
		public FuzzyQueryDescriptor()
		{
		}

		internal FuzzyQueryDescriptor(Action<FuzzyQueryDescriptor> configure) => configure.Invoke(this);
		internal int? MaxExpansionsValue { get; private set; }

		internal int? PrefixLengthValue { get; private set; }

		internal string? RewriteValue { get; private set; }

		internal bool? TranspositionsValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Fuzziness? FuzzinessValue { get; private set; }

		internal object ValueValue { get; private set; }

		public FuzzyQueryDescriptor MaxExpansions(int? maxExpansions) => Assign(maxExpansions, (a, v) => a.MaxExpansionsValue = v);
		public FuzzyQueryDescriptor PrefixLength(int? prefixLength) => Assign(prefixLength, (a, v) => a.PrefixLengthValue = v);
		public FuzzyQueryDescriptor Rewrite(string? rewrite) => Assign(rewrite, (a, v) => a.RewriteValue = v);
		public FuzzyQueryDescriptor Transpositions(bool? transpositions = true) => Assign(transpositions, (a, v) => a.TranspositionsValue = v);
		public FuzzyQueryDescriptor Fuzziness(Elastic.Clients.Elasticsearch.Fuzziness? fuzziness) => Assign(fuzziness, (a, v) => a.FuzzinessValue = v);
		public FuzzyQueryDescriptor Value(object value) => Assign(value, (a, v) => a.ValueValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WritePropertyName(settings.Inferrer.Field(_field));
			writer.WriteStartObject();
			if (MaxExpansionsValue.HasValue)
			{
				writer.WritePropertyName("max_expansions");
				writer.WriteNumberValue(MaxExpansionsValue.Value);
			}

			if (PrefixLengthValue.HasValue)
			{
				writer.WritePropertyName("prefix_length");
				writer.WriteNumberValue(PrefixLengthValue.Value);
			}

			if (RewriteValue is not null)
			{
				writer.WritePropertyName("rewrite");
				JsonSerializer.Serialize(writer, RewriteValue, options);
			}

			if (TranspositionsValue.HasValue)
			{
				writer.WritePropertyName("transpositions");
				writer.WriteBooleanValue(TranspositionsValue.Value);
			}

			if (FuzzinessValue is not null)
			{
				writer.WritePropertyName("fuzziness");
				JsonSerializer.Serialize(writer, FuzzinessValue, options);
			}

			writer.WritePropertyName("value");
			JsonSerializer.Serialize(writer, ValueValue, options);
			writer.WriteEndObject();
		}
	}

	public partial class GeoBoundingBoxQuery : QueryDsl.QueryBase, IQueryContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "geo_bounding_box";
		[JsonInclude]
		[JsonPropertyName("validation_method")]
		public Elastic.Clients.Elasticsearch.QueryDsl.GeoValidationMethod? ValidationMethod { get; set; }

		[JsonInclude]
		[JsonPropertyName("ignore_unmapped")]
		public bool? IgnoreUnmapped { get; set; }
	}

	public sealed partial class GeoBoundingBoxQueryDescriptor : DescriptorBase<GeoBoundingBoxQueryDescriptor>
	{
		public GeoBoundingBoxQueryDescriptor()
		{
		}

		internal GeoBoundingBoxQueryDescriptor(Action<GeoBoundingBoxQueryDescriptor> configure) => configure.Invoke(this);
		internal Elastic.Clients.Elasticsearch.QueryDsl.GeoValidationMethod? ValidationMethodValue { get; private set; }

		internal bool? IgnoreUnmappedValue { get; private set; }

		public GeoBoundingBoxQueryDescriptor ValidationMethod(Elastic.Clients.Elasticsearch.QueryDsl.GeoValidationMethod? validationMethod) => Assign(validationMethod, (a, v) => a.ValidationMethodValue = v);
		public GeoBoundingBoxQueryDescriptor IgnoreUnmapped(bool? ignoreUnmapped = true) => Assign(ignoreUnmapped, (a, v) => a.IgnoreUnmappedValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (ValidationMethodValue is not null)
			{
				writer.WritePropertyName("validation_method");
				JsonSerializer.Serialize(writer, ValidationMethodValue, options);
			}

			if (IgnoreUnmappedValue.HasValue)
			{
				writer.WritePropertyName("ignore_unmapped");
				writer.WriteBooleanValue(IgnoreUnmappedValue.Value);
			}

			writer.WriteEndObject();
		}
	}

	public partial class GeoDistanceQuery : QueryDsl.QueryBase, IQueryContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "geo_distance";
		[JsonInclude]
		[JsonPropertyName("distance")]
		public string? Distance { get; set; }

		[JsonInclude]
		[JsonPropertyName("distance_type")]
		public Elastic.Clients.Elasticsearch.GeoDistanceType? DistanceType { get; set; }

		[JsonInclude]
		[JsonPropertyName("validation_method")]
		public Elastic.Clients.Elasticsearch.QueryDsl.GeoValidationMethod? ValidationMethod { get; set; }
	}

	public sealed partial class GeoDistanceQueryDescriptor : DescriptorBase<GeoDistanceQueryDescriptor>
	{
		public GeoDistanceQueryDescriptor()
		{
		}

		internal GeoDistanceQueryDescriptor(Action<GeoDistanceQueryDescriptor> configure) => configure.Invoke(this);
		internal string? DistanceValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.GeoDistanceType? DistanceTypeValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.GeoValidationMethod? ValidationMethodValue { get; private set; }

		public GeoDistanceQueryDescriptor Distance(string? distance) => Assign(distance, (a, v) => a.DistanceValue = v);
		public GeoDistanceQueryDescriptor DistanceType(Elastic.Clients.Elasticsearch.GeoDistanceType? distanceType) => Assign(distanceType, (a, v) => a.DistanceTypeValue = v);
		public GeoDistanceQueryDescriptor ValidationMethod(Elastic.Clients.Elasticsearch.QueryDsl.GeoValidationMethod? validationMethod) => Assign(validationMethod, (a, v) => a.ValidationMethodValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (DistanceValue is not null)
			{
				writer.WritePropertyName("distance");
				JsonSerializer.Serialize(writer, DistanceValue, options);
			}

			if (DistanceTypeValue is not null)
			{
				writer.WritePropertyName("distance_type");
				JsonSerializer.Serialize(writer, DistanceTypeValue, options);
			}

			if (ValidationMethodValue is not null)
			{
				writer.WritePropertyName("validation_method");
				JsonSerializer.Serialize(writer, ValidationMethodValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class GeoPolygonQuery : QueryDsl.QueryBase, IQueryContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "geo_polygon";
		[JsonInclude]
		[JsonPropertyName("validation_method")]
		public Elastic.Clients.Elasticsearch.QueryDsl.GeoValidationMethod? ValidationMethod { get; set; }

		[JsonInclude]
		[JsonPropertyName("ignore_unmapped")]
		public bool? IgnoreUnmapped { get; set; }
	}

	public sealed partial class GeoPolygonQueryDescriptor : DescriptorBase<GeoPolygonQueryDescriptor>
	{
		public GeoPolygonQueryDescriptor()
		{
		}

		internal GeoPolygonQueryDescriptor(Action<GeoPolygonQueryDescriptor> configure) => configure.Invoke(this);
		internal Elastic.Clients.Elasticsearch.QueryDsl.GeoValidationMethod? ValidationMethodValue { get; private set; }

		internal bool? IgnoreUnmappedValue { get; private set; }

		public GeoPolygonQueryDescriptor ValidationMethod(Elastic.Clients.Elasticsearch.QueryDsl.GeoValidationMethod? validationMethod) => Assign(validationMethod, (a, v) => a.ValidationMethodValue = v);
		public GeoPolygonQueryDescriptor IgnoreUnmapped(bool? ignoreUnmapped = true) => Assign(ignoreUnmapped, (a, v) => a.IgnoreUnmappedValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (ValidationMethodValue is not null)
			{
				writer.WritePropertyName("validation_method");
				JsonSerializer.Serialize(writer, ValidationMethodValue, options);
			}

			if (IgnoreUnmappedValue.HasValue)
			{
				writer.WritePropertyName("ignore_unmapped");
				writer.WriteBooleanValue(IgnoreUnmappedValue.Value);
			}

			writer.WriteEndObject();
		}
	}

	public partial class GeoShapeQuery : QueryDsl.QueryBase, IQueryContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "geo_shape";
		[JsonInclude]
		[JsonPropertyName("ignore_unmapped")]
		public bool? IgnoreUnmapped { get; set; }
	}

	public sealed partial class GeoShapeQueryDescriptor : DescriptorBase<GeoShapeQueryDescriptor>
	{
		public GeoShapeQueryDescriptor()
		{
		}

		internal GeoShapeQueryDescriptor(Action<GeoShapeQueryDescriptor> configure) => configure.Invoke(this);
		internal bool? IgnoreUnmappedValue { get; private set; }

		public GeoShapeQueryDescriptor IgnoreUnmapped(bool? ignoreUnmapped = true) => Assign(ignoreUnmapped, (a, v) => a.IgnoreUnmappedValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (IgnoreUnmappedValue.HasValue)
			{
				writer.WritePropertyName("ignore_unmapped");
				writer.WriteBooleanValue(IgnoreUnmappedValue.Value);
			}

			writer.WriteEndObject();
		}
	}

	public partial class HasChildQuery : QueryDsl.QueryBase, IQueryContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "has_child";
		[JsonInclude]
		[JsonPropertyName("ignore_unmapped")]
		public bool? IgnoreUnmapped { get; set; }

		[JsonInclude]
		[JsonPropertyName("inner_hits")]
		public Elastic.Clients.Elasticsearch.InnerHits? InnerHits { get; set; }

		[JsonInclude]
		[JsonPropertyName("max_children")]
		public int? MaxChildren { get; set; }

		[JsonInclude]
		[JsonPropertyName("min_children")]
		public int? MinChildren { get; set; }

		[JsonInclude]
		[JsonPropertyName("query")]
		public Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer Query { get; set; }

		[JsonInclude]
		[JsonPropertyName("score_mode")]
		public Elastic.Clients.Elasticsearch.QueryDsl.ChildScoreMode? ScoreMode { get; set; }

		[JsonInclude]
		[JsonPropertyName("type")]
		public string Type { get; set; }
	}

	public sealed partial class HasChildQueryDescriptor<T> : DescriptorBase<HasChildQueryDescriptor<T>>
	{
		public HasChildQueryDescriptor()
		{
		}

		internal HasChildQueryDescriptor(Action<HasChildQueryDescriptor<T>> configure) => configure.Invoke(this);
		internal bool? IgnoreUnmappedValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.InnerHits? InnerHitsValue { get; private set; }

		internal int? MaxChildrenValue { get; private set; }

		internal int? MinChildrenValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer QueryValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.ChildScoreMode? ScoreModeValue { get; private set; }

		internal string TypeValue { get; private set; }

		internal InnerHitsDescriptor<T> InnerHitsDescriptor { get; private set; }

		internal QueryContainerDescriptor<T> QueryDescriptor { get; private set; }

		internal Action<InnerHitsDescriptor<T>> InnerHitsDescriptorAction { get; private set; }

		internal Action<QueryContainerDescriptor<T>> QueryDescriptorAction { get; private set; }

		public HasChildQueryDescriptor<T> IgnoreUnmapped(bool? ignoreUnmapped = true) => Assign(ignoreUnmapped, (a, v) => a.IgnoreUnmappedValue = v);
		public HasChildQueryDescriptor<T> InnerHits(Elastic.Clients.Elasticsearch.InnerHits? innerHits)
		{
			InnerHitsDescriptor = null;
			InnerHitsDescriptorAction = null;
			return Assign(innerHits, (a, v) => a.InnerHitsValue = v);
		}

		public HasChildQueryDescriptor<T> InnerHits(Elastic.Clients.Elasticsearch.InnerHitsDescriptor<T> descriptor)
		{
			InnerHitsValue = null;
			InnerHitsDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.InnerHitsDescriptor = v);
		}

		public HasChildQueryDescriptor<T> InnerHits(Action<Elastic.Clients.Elasticsearch.InnerHitsDescriptor<T>> configure)
		{
			InnerHitsValue = null;
			InnerHitsDescriptorAction = null;
			return Assign(configure, (a, v) => a.InnerHitsDescriptorAction = v);
		}

		public HasChildQueryDescriptor<T> MaxChildren(int? maxChildren) => Assign(maxChildren, (a, v) => a.MaxChildrenValue = v);
		public HasChildQueryDescriptor<T> MinChildren(int? minChildren) => Assign(minChildren, (a, v) => a.MinChildrenValue = v);
		public HasChildQueryDescriptor<T> Query(Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer query)
		{
			QueryDescriptor = null;
			QueryDescriptorAction = null;
			return Assign(query, (a, v) => a.QueryValue = v);
		}

		public HasChildQueryDescriptor<T> Query(Elastic.Clients.Elasticsearch.QueryDsl.QueryContainerDescriptor<T> descriptor)
		{
			QueryValue = null;
			QueryDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.QueryDescriptor = v);
		}

		public HasChildQueryDescriptor<T> Query(Action<Elastic.Clients.Elasticsearch.QueryDsl.QueryContainerDescriptor<T>> configure)
		{
			QueryValue = null;
			QueryDescriptorAction = null;
			return Assign(configure, (a, v) => a.QueryDescriptorAction = v);
		}

		public HasChildQueryDescriptor<T> ScoreMode(Elastic.Clients.Elasticsearch.QueryDsl.ChildScoreMode? scoreMode) => Assign(scoreMode, (a, v) => a.ScoreModeValue = v);
		public HasChildQueryDescriptor<T> Type(string type) => Assign(type, (a, v) => a.TypeValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (IgnoreUnmappedValue.HasValue)
			{
				writer.WritePropertyName("ignore_unmapped");
				writer.WriteBooleanValue(IgnoreUnmappedValue.Value);
			}

			if (InnerHitsDescriptor is not null)
			{
				writer.WritePropertyName("inner_hits");
				JsonSerializer.Serialize(writer, InnerHitsDescriptor, options);
			}
			else if (InnerHitsDescriptorAction is not null)
			{
				writer.WritePropertyName("inner_hits");
				JsonSerializer.Serialize(writer, new InnerHitsDescriptor<T>(InnerHitsDescriptorAction), options);
			}
			else if (InnerHitsValue is not null)
			{
				writer.WritePropertyName("inner_hits");
				JsonSerializer.Serialize(writer, InnerHitsValue, options);
			}

			if (MaxChildrenValue.HasValue)
			{
				writer.WritePropertyName("max_children");
				writer.WriteNumberValue(MaxChildrenValue.Value);
			}

			if (MinChildrenValue.HasValue)
			{
				writer.WritePropertyName("min_children");
				writer.WriteNumberValue(MinChildrenValue.Value);
			}

			if (QueryDescriptor is not null)
			{
				writer.WritePropertyName("query");
				JsonSerializer.Serialize(writer, QueryDescriptor, options);
			}
			else if (QueryDescriptorAction is not null)
			{
				writer.WritePropertyName("query");
				JsonSerializer.Serialize(writer, new QueryContainerDescriptor<T>(QueryDescriptorAction), options);
			}
			else
			{
				writer.WritePropertyName("query");
				JsonSerializer.Serialize(writer, QueryValue, options);
			}

			if (ScoreModeValue is not null)
			{
				writer.WritePropertyName("score_mode");
				JsonSerializer.Serialize(writer, ScoreModeValue, options);
			}

			writer.WritePropertyName("type");
			JsonSerializer.Serialize(writer, TypeValue, options);
			writer.WriteEndObject();
		}
	}

	public partial class HasParentQuery : QueryDsl.QueryBase, IQueryContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "has_parent";
		[JsonInclude]
		[JsonPropertyName("ignore_unmapped")]
		public bool? IgnoreUnmapped { get; set; }

		[JsonInclude]
		[JsonPropertyName("inner_hits")]
		public Elastic.Clients.Elasticsearch.InnerHits? InnerHits { get; set; }

		[JsonInclude]
		[JsonPropertyName("parent_type")]
		public string ParentType { get; set; }

		[JsonInclude]
		[JsonPropertyName("query")]
		public Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer Query { get; set; }

		[JsonInclude]
		[JsonPropertyName("score")]
		public bool? Score { get; set; }
	}

	public sealed partial class HasParentQueryDescriptor<T> : DescriptorBase<HasParentQueryDescriptor<T>>
	{
		public HasParentQueryDescriptor()
		{
		}

		internal HasParentQueryDescriptor(Action<HasParentQueryDescriptor<T>> configure) => configure.Invoke(this);
		internal bool? IgnoreUnmappedValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.InnerHits? InnerHitsValue { get; private set; }

		internal string ParentTypeValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer QueryValue { get; private set; }

		internal bool? ScoreValue { get; private set; }

		internal InnerHitsDescriptor<T> InnerHitsDescriptor { get; private set; }

		internal QueryContainerDescriptor<T> QueryDescriptor { get; private set; }

		internal Action<InnerHitsDescriptor<T>> InnerHitsDescriptorAction { get; private set; }

		internal Action<QueryContainerDescriptor<T>> QueryDescriptorAction { get; private set; }

		public HasParentQueryDescriptor<T> IgnoreUnmapped(bool? ignoreUnmapped = true) => Assign(ignoreUnmapped, (a, v) => a.IgnoreUnmappedValue = v);
		public HasParentQueryDescriptor<T> InnerHits(Elastic.Clients.Elasticsearch.InnerHits? innerHits)
		{
			InnerHitsDescriptor = null;
			InnerHitsDescriptorAction = null;
			return Assign(innerHits, (a, v) => a.InnerHitsValue = v);
		}

		public HasParentQueryDescriptor<T> InnerHits(Elastic.Clients.Elasticsearch.InnerHitsDescriptor<T> descriptor)
		{
			InnerHitsValue = null;
			InnerHitsDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.InnerHitsDescriptor = v);
		}

		public HasParentQueryDescriptor<T> InnerHits(Action<Elastic.Clients.Elasticsearch.InnerHitsDescriptor<T>> configure)
		{
			InnerHitsValue = null;
			InnerHitsDescriptorAction = null;
			return Assign(configure, (a, v) => a.InnerHitsDescriptorAction = v);
		}

		public HasParentQueryDescriptor<T> ParentType(string parentType) => Assign(parentType, (a, v) => a.ParentTypeValue = v);
		public HasParentQueryDescriptor<T> Query(Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer query)
		{
			QueryDescriptor = null;
			QueryDescriptorAction = null;
			return Assign(query, (a, v) => a.QueryValue = v);
		}

		public HasParentQueryDescriptor<T> Query(Elastic.Clients.Elasticsearch.QueryDsl.QueryContainerDescriptor<T> descriptor)
		{
			QueryValue = null;
			QueryDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.QueryDescriptor = v);
		}

		public HasParentQueryDescriptor<T> Query(Action<Elastic.Clients.Elasticsearch.QueryDsl.QueryContainerDescriptor<T>> configure)
		{
			QueryValue = null;
			QueryDescriptorAction = null;
			return Assign(configure, (a, v) => a.QueryDescriptorAction = v);
		}

		public HasParentQueryDescriptor<T> Score(bool? score = true) => Assign(score, (a, v) => a.ScoreValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (IgnoreUnmappedValue.HasValue)
			{
				writer.WritePropertyName("ignore_unmapped");
				writer.WriteBooleanValue(IgnoreUnmappedValue.Value);
			}

			if (InnerHitsDescriptor is not null)
			{
				writer.WritePropertyName("inner_hits");
				JsonSerializer.Serialize(writer, InnerHitsDescriptor, options);
			}
			else if (InnerHitsDescriptorAction is not null)
			{
				writer.WritePropertyName("inner_hits");
				JsonSerializer.Serialize(writer, new InnerHitsDescriptor<T>(InnerHitsDescriptorAction), options);
			}
			else if (InnerHitsValue is not null)
			{
				writer.WritePropertyName("inner_hits");
				JsonSerializer.Serialize(writer, InnerHitsValue, options);
			}

			writer.WritePropertyName("parent_type");
			JsonSerializer.Serialize(writer, ParentTypeValue, options);
			if (QueryDescriptor is not null)
			{
				writer.WritePropertyName("query");
				JsonSerializer.Serialize(writer, QueryDescriptor, options);
			}
			else if (QueryDescriptorAction is not null)
			{
				writer.WritePropertyName("query");
				JsonSerializer.Serialize(writer, new QueryContainerDescriptor<T>(QueryDescriptorAction), options);
			}
			else
			{
				writer.WritePropertyName("query");
				JsonSerializer.Serialize(writer, QueryValue, options);
			}

			if (ScoreValue.HasValue)
			{
				writer.WritePropertyName("score");
				writer.WriteBooleanValue(ScoreValue.Value);
			}

			writer.WriteEndObject();
		}
	}

	public partial class IdsQuery : QueryDsl.QueryBase, IQueryContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "ids";
		[JsonInclude]
		[JsonPropertyName("values")]
		public Elastic.Clients.Elasticsearch.Ids? Values { get; set; }
	}

	public sealed partial class IdsQueryDescriptor : DescriptorBase<IdsQueryDescriptor>
	{
		public IdsQueryDescriptor()
		{
		}

		internal IdsQueryDescriptor(Action<IdsQueryDescriptor> configure) => configure.Invoke(this);
		internal Elastic.Clients.Elasticsearch.Ids? ValuesValue { get; private set; }

		public IdsQueryDescriptor Values(Elastic.Clients.Elasticsearch.Ids? values) => Assign(values, (a, v) => a.ValuesValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (ValuesValue is not null)
			{
				writer.WritePropertyName("values");
				JsonSerializer.Serialize(writer, ValuesValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class IntervalsAllOf : IIntervalsContainerVariant, IIntervalsQueryVariant
	{
		[JsonIgnore]
		string QueryDsl.IIntervalsContainerVariant.IntervalsContainerVariantName => "all_of";
		[JsonIgnore]
		string QueryDsl.IIntervalsQueryVariant.IntervalsQueryVariantName => "all_of";
		[JsonInclude]
		[JsonPropertyName("intervals")]
		public IEnumerable<Elastic.Clients.Elasticsearch.QueryDsl.IntervalsContainer> Intervals { get; set; }

		[JsonInclude]
		[JsonPropertyName("max_gaps")]
		public int? MaxGaps { get; set; }

		[JsonInclude]
		[JsonPropertyName("ordered")]
		public bool? Ordered { get; set; }

		[JsonInclude]
		[JsonPropertyName("filter")]
		public Elastic.Clients.Elasticsearch.QueryDsl.IntervalsFilter? Filter { get; set; }
	}

	public sealed partial class IntervalsAllOfDescriptor : DescriptorBase<IntervalsAllOfDescriptor>
	{
		public IntervalsAllOfDescriptor()
		{
		}

		internal IntervalsAllOfDescriptor(Action<IntervalsAllOfDescriptor> configure) => configure.Invoke(this);
		internal IEnumerable<Elastic.Clients.Elasticsearch.QueryDsl.IntervalsContainer> IntervalsValue { get; private set; }

		internal int? MaxGapsValue { get; private set; }

		internal bool? OrderedValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.IntervalsFilter? FilterValue { get; private set; }

		internal IntervalsFilterDescriptor FilterDescriptor { get; private set; }

		internal Action<IntervalsFilterDescriptor> FilterDescriptorAction { get; private set; }

		public IntervalsAllOfDescriptor Intervals(IEnumerable<Elastic.Clients.Elasticsearch.QueryDsl.IntervalsContainer> intervals) => Assign(intervals, (a, v) => a.IntervalsValue = v);
		public IntervalsAllOfDescriptor MaxGaps(int? maxGaps) => Assign(maxGaps, (a, v) => a.MaxGapsValue = v);
		public IntervalsAllOfDescriptor Ordered(bool? ordered = true) => Assign(ordered, (a, v) => a.OrderedValue = v);
		public IntervalsAllOfDescriptor Filter(Elastic.Clients.Elasticsearch.QueryDsl.IntervalsFilter? filter)
		{
			FilterDescriptor = null;
			FilterDescriptorAction = null;
			return Assign(filter, (a, v) => a.FilterValue = v);
		}

		public IntervalsAllOfDescriptor Filter(Elastic.Clients.Elasticsearch.QueryDsl.IntervalsFilterDescriptor descriptor)
		{
			FilterValue = null;
			FilterDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.FilterDescriptor = v);
		}

		public IntervalsAllOfDescriptor Filter(Action<Elastic.Clients.Elasticsearch.QueryDsl.IntervalsFilterDescriptor> configure)
		{
			FilterValue = null;
			FilterDescriptorAction = null;
			return Assign(configure, (a, v) => a.FilterDescriptorAction = v);
		}

		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("intervals");
			JsonSerializer.Serialize(writer, IntervalsValue, options);
			if (MaxGapsValue.HasValue)
			{
				writer.WritePropertyName("max_gaps");
				writer.WriteNumberValue(MaxGapsValue.Value);
			}

			if (OrderedValue.HasValue)
			{
				writer.WritePropertyName("ordered");
				writer.WriteBooleanValue(OrderedValue.Value);
			}

			if (FilterDescriptor is not null)
			{
				writer.WritePropertyName("filter");
				JsonSerializer.Serialize(writer, FilterDescriptor, options);
			}
			else if (FilterDescriptorAction is not null)
			{
				writer.WritePropertyName("filter");
				JsonSerializer.Serialize(writer, new IntervalsFilterDescriptor(FilterDescriptorAction), options);
			}
			else if (FilterValue is not null)
			{
				writer.WritePropertyName("filter");
				JsonSerializer.Serialize(writer, FilterValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class IntervalsAnyOf : IIntervalsContainerVariant, IIntervalsQueryVariant
	{
		[JsonIgnore]
		string QueryDsl.IIntervalsContainerVariant.IntervalsContainerVariantName => "any_of";
		[JsonIgnore]
		string QueryDsl.IIntervalsQueryVariant.IntervalsQueryVariantName => "any_of";
		[JsonInclude]
		[JsonPropertyName("intervals")]
		public IEnumerable<Elastic.Clients.Elasticsearch.QueryDsl.IntervalsContainer> Intervals { get; set; }

		[JsonInclude]
		[JsonPropertyName("filter")]
		public Elastic.Clients.Elasticsearch.QueryDsl.IntervalsFilter? Filter { get; set; }
	}

	public sealed partial class IntervalsAnyOfDescriptor : DescriptorBase<IntervalsAnyOfDescriptor>
	{
		public IntervalsAnyOfDescriptor()
		{
		}

		internal IntervalsAnyOfDescriptor(Action<IntervalsAnyOfDescriptor> configure) => configure.Invoke(this);
		internal IEnumerable<Elastic.Clients.Elasticsearch.QueryDsl.IntervalsContainer> IntervalsValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.IntervalsFilter? FilterValue { get; private set; }

		internal IntervalsFilterDescriptor FilterDescriptor { get; private set; }

		internal Action<IntervalsFilterDescriptor> FilterDescriptorAction { get; private set; }

		public IntervalsAnyOfDescriptor Intervals(IEnumerable<Elastic.Clients.Elasticsearch.QueryDsl.IntervalsContainer> intervals) => Assign(intervals, (a, v) => a.IntervalsValue = v);
		public IntervalsAnyOfDescriptor Filter(Elastic.Clients.Elasticsearch.QueryDsl.IntervalsFilter? filter)
		{
			FilterDescriptor = null;
			FilterDescriptorAction = null;
			return Assign(filter, (a, v) => a.FilterValue = v);
		}

		public IntervalsAnyOfDescriptor Filter(Elastic.Clients.Elasticsearch.QueryDsl.IntervalsFilterDescriptor descriptor)
		{
			FilterValue = null;
			FilterDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.FilterDescriptor = v);
		}

		public IntervalsAnyOfDescriptor Filter(Action<Elastic.Clients.Elasticsearch.QueryDsl.IntervalsFilterDescriptor> configure)
		{
			FilterValue = null;
			FilterDescriptorAction = null;
			return Assign(configure, (a, v) => a.FilterDescriptorAction = v);
		}

		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("intervals");
			JsonSerializer.Serialize(writer, IntervalsValue, options);
			if (FilterDescriptor is not null)
			{
				writer.WritePropertyName("filter");
				JsonSerializer.Serialize(writer, FilterDescriptor, options);
			}
			else if (FilterDescriptorAction is not null)
			{
				writer.WritePropertyName("filter");
				JsonSerializer.Serialize(writer, new IntervalsFilterDescriptor(FilterDescriptorAction), options);
			}
			else if (FilterValue is not null)
			{
				writer.WritePropertyName("filter");
				JsonSerializer.Serialize(writer, FilterValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public interface IIntervalsContainerVariant
	{
		string IntervalsContainerVariantName { get; }
	}

	[JsonConverter(typeof(IntervalsContainerConverter))]
	public partial class IntervalsContainer : IContainer
	{
		public IntervalsContainer(IIntervalsContainerVariant variant) => Variant = variant ?? throw new ArgumentNullException(nameof(variant));
		internal IIntervalsContainerVariant Variant { get; }
	}

	internal sealed class IntervalsContainerConverter : JsonConverter<IntervalsContainer>
	{
		public override IntervalsContainer Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			reader.Read();
			if (reader.TokenType != JsonTokenType.PropertyName)
			{
				throw new JsonException();
			}

			var propertyName = reader.GetString();
			if (propertyName == "all_of")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.IntervalsAllOf?>(ref reader, options);
				reader.Read();
				return new IntervalsContainer(variant);
			}

			if (propertyName == "any_of")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.IntervalsAnyOf?>(ref reader, options);
				reader.Read();
				return new IntervalsContainer(variant);
			}

			if (propertyName == "fuzzy")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.IntervalsFuzzy?>(ref reader, options);
				reader.Read();
				return new IntervalsContainer(variant);
			}

			if (propertyName == "match")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.IntervalsMatch?>(ref reader, options);
				reader.Read();
				return new IntervalsContainer(variant);
			}

			if (propertyName == "prefix")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.IntervalsPrefix?>(ref reader, options);
				reader.Read();
				return new IntervalsContainer(variant);
			}

			if (propertyName == "wildcard")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.IntervalsWildcard?>(ref reader, options);
				reader.Read();
				return new IntervalsContainer(variant);
			}

			throw new JsonException();
		}

		public override void Write(Utf8JsonWriter writer, IntervalsContainer value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName(value.Variant.IntervalsContainerVariantName);
			switch (value.Variant)
			{
				case Elastic.Clients.Elasticsearch.QueryDsl.IntervalsAllOf variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.IntervalsAnyOf variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.IntervalsFuzzy variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.IntervalsMatch variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.IntervalsPrefix variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.IntervalsWildcard variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
			}

			writer.WriteEndObject();
		}
	}

	public sealed partial class IntervalsContainerDescriptor<T> : DescriptorBase<IntervalsContainerDescriptor<T>>
	{
		public IntervalsContainerDescriptor()
		{
		}

		internal IntervalsContainerDescriptor(Action<IntervalsContainerDescriptor<T>> configure) => configure.Invoke(this);
		internal bool ContainsVariant { get; private set; }

		internal string ContainedVariantName { get; private set; }

		internal IntervalsContainer Container { get; private set; }

		internal object ContainerVariantDescriptorAction { get; private set; }

		private void Set(object descriptorAction, string variantName)
		{
			if (ContainsVariant)
				throw new Exception("TODO");
			ContainerVariantDescriptorAction = descriptorAction;
			ContainedVariantName = variantName;
			ContainsVariant = true;
		}

		private void Set(IIntervalsContainerVariant variant, string variantName)
		{
			if (ContainsVariant)
				throw new Exception("TODO");
			Container = new IntervalsContainer(variant);
			ContainedVariantName = variantName;
			ContainsVariant = true;
		}

		public void AllOf(IntervalsAllOf variant) => Set(variant, "all_of");
		public void AllOf(Action<IntervalsAllOfDescriptor> configure) => Set(configure, "all_of");
		public void AnyOf(IntervalsAnyOf variant) => Set(variant, "any_of");
		public void AnyOf(Action<IntervalsAnyOfDescriptor> configure) => Set(configure, "any_of");
		public void Fuzzy(IntervalsFuzzy variant) => Set(variant, "fuzzy");
		public void Fuzzy(Action<IntervalsFuzzyDescriptor<T>> configure) => Set(configure, "fuzzy");
		public void Match(IntervalsMatch variant) => Set(variant, "match");
		public void Match(Action<IntervalsMatchDescriptor<T>> configure) => Set(configure, "match");
		public void Prefix(IntervalsPrefix variant) => Set(variant, "prefix");
		public void Prefix(Action<IntervalsPrefixDescriptor<T>> configure) => Set(configure, "prefix");
		public void Wildcard(IntervalsWildcard variant) => Set(variant, "wildcard");
		public void Wildcard(Action<IntervalsWildcardDescriptor<T>> configure) => Set(configure, "wildcard");
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			if (!ContainsVariant)
			{
				writer.WriteNullValue();
				return;
			}

			writer.WriteStartObject();
			writer.WritePropertyName(ContainedVariantName);
			writer.WriteStartObject();
			if (Container is not null)
			{
				JsonSerializer.Serialize(writer, Container, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "all_of")
			{
				var descriptor = new IntervalsAllOfDescriptor();
				((Action<IntervalsAllOfDescriptor>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "any_of")
			{
				var descriptor = new IntervalsAnyOfDescriptor();
				((Action<IntervalsAnyOfDescriptor>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "fuzzy")
			{
				var descriptor = new IntervalsFuzzyDescriptor<T>();
				((Action<IntervalsFuzzyDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "match")
			{
				var descriptor = new IntervalsMatchDescriptor<T>();
				((Action<IntervalsMatchDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "prefix")
			{
				var descriptor = new IntervalsPrefixDescriptor<T>();
				((Action<IntervalsPrefixDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "wildcard")
			{
				var descriptor = new IntervalsWildcardDescriptor<T>();
				((Action<IntervalsWildcardDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			writer.WriteEndObject();
			writer.WriteEndObject();
			void Finalise()
			{
				writer.WriteEndObject();
				writer.WriteEndObject();
			}
		}
	}

	public interface IIntervalsFilterVariant
	{
		string IntervalsFilterVariantName { get; }
	}

	[JsonConverter(typeof(IntervalsFilterConverter))]
	public partial class IntervalsFilter : IContainer
	{
		public IntervalsFilter(IIntervalsFilterVariant variant) => Variant = variant ?? throw new ArgumentNullException(nameof(variant));
		internal IIntervalsFilterVariant Variant { get; }
	}

	internal sealed class IntervalsFilterConverter : JsonConverter<IntervalsFilter>
	{
		public override IntervalsFilter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			reader.Read();
			if (reader.TokenType != JsonTokenType.PropertyName)
			{
				throw new JsonException();
			}

			var propertyName = reader.GetString();
			throw new JsonException();
		}

		public override void Write(Utf8JsonWriter writer, IntervalsFilter value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName(value.Variant.IntervalsFilterVariantName);
			writer.WriteEndObject();
		}
	}

	public sealed partial class IntervalsFilterDescriptor : DescriptorBase<IntervalsFilterDescriptor>
	{
		public IntervalsFilterDescriptor()
		{
		}

		internal IntervalsFilterDescriptor(Action<IntervalsFilterDescriptor> configure) => configure.Invoke(this);
		internal bool ContainsVariant { get; private set; }

		internal string ContainedVariantName { get; private set; }

		internal IntervalsFilter Container { get; private set; }

		internal object ContainerVariantDescriptorAction { get; private set; }

		private void Set(object descriptorAction, string variantName)
		{
			if (ContainsVariant)
				throw new Exception("TODO");
			ContainerVariantDescriptorAction = descriptorAction;
			ContainedVariantName = variantName;
			ContainsVariant = true;
		}

		private void Set(IIntervalsFilterVariant variant, string variantName)
		{
			if (ContainsVariant)
				throw new Exception("TODO");
			Container = new IntervalsFilter(variant);
			ContainedVariantName = variantName;
			ContainsVariant = true;
		}

		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			if (!ContainsVariant)
			{
				writer.WriteNullValue();
				return;
			}

			writer.WriteStartObject();
			writer.WritePropertyName(ContainedVariantName);
			writer.WriteStartObject();
			if (Container is not null)
			{
				JsonSerializer.Serialize(writer, Container, options);
				Finalise();
				return;
			}

			writer.WriteEndObject();
			writer.WriteEndObject();
			void Finalise()
			{
				writer.WriteEndObject();
				writer.WriteEndObject();
			}
		}
	}

	public partial class IntervalsFuzzy : IIntervalsContainerVariant, IIntervalsQueryVariant
	{
		[JsonIgnore]
		string QueryDsl.IIntervalsContainerVariant.IntervalsContainerVariantName => "fuzzy";
		[JsonIgnore]
		string QueryDsl.IIntervalsQueryVariant.IntervalsQueryVariantName => "fuzzy";
		[JsonInclude]
		[JsonPropertyName("analyzer")]
		public string? Analyzer { get; set; }

		[JsonInclude]
		[JsonPropertyName("fuzziness")]
		public Elastic.Clients.Elasticsearch.Fuzziness? Fuzziness { get; set; }

		[JsonInclude]
		[JsonPropertyName("prefix_length")]
		public int? PrefixLength { get; set; }

		[JsonInclude]
		[JsonPropertyName("term")]
		public string Term { get; set; }

		[JsonInclude]
		[JsonPropertyName("transpositions")]
		public bool? Transpositions { get; set; }

		[JsonInclude]
		[JsonPropertyName("use_field")]
		public string? UseField { get; set; }
	}

	public sealed partial class IntervalsFuzzyDescriptor<T> : DescriptorBase<IntervalsFuzzyDescriptor<T>>
	{
		public IntervalsFuzzyDescriptor()
		{
		}

		internal IntervalsFuzzyDescriptor(Action<IntervalsFuzzyDescriptor<T>> configure) => configure.Invoke(this);
		internal string? AnalyzerValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Fuzziness? FuzzinessValue { get; private set; }

		internal int? PrefixLengthValue { get; private set; }

		internal string TermValue { get; private set; }

		internal bool? TranspositionsValue { get; private set; }

		internal string? UseFieldValue { get; private set; }

		public IntervalsFuzzyDescriptor<T> Analyzer(string? analyzer) => Assign(analyzer, (a, v) => a.AnalyzerValue = v);
		public IntervalsFuzzyDescriptor<T> Fuzziness(Elastic.Clients.Elasticsearch.Fuzziness? fuzziness) => Assign(fuzziness, (a, v) => a.FuzzinessValue = v);
		public IntervalsFuzzyDescriptor<T> PrefixLength(int? prefixLength) => Assign(prefixLength, (a, v) => a.PrefixLengthValue = v);
		public IntervalsFuzzyDescriptor<T> Term(string term) => Assign(term, (a, v) => a.TermValue = v);
		public IntervalsFuzzyDescriptor<T> Transpositions(bool? transpositions = true) => Assign(transpositions, (a, v) => a.TranspositionsValue = v);
		public IntervalsFuzzyDescriptor<T> UseField(string? useField) => Assign(useField, (a, v) => a.UseFieldValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (!string.IsNullOrEmpty(AnalyzerValue))
			{
				writer.WritePropertyName("analyzer");
				writer.WriteStringValue(AnalyzerValue);
			}

			if (FuzzinessValue is not null)
			{
				writer.WritePropertyName("fuzziness");
				JsonSerializer.Serialize(writer, FuzzinessValue, options);
			}

			if (PrefixLengthValue.HasValue)
			{
				writer.WritePropertyName("prefix_length");
				writer.WriteNumberValue(PrefixLengthValue.Value);
			}

			writer.WritePropertyName("term");
			writer.WriteStringValue(TermValue);
			if (TranspositionsValue.HasValue)
			{
				writer.WritePropertyName("transpositions");
				writer.WriteBooleanValue(TranspositionsValue.Value);
			}

			if (UseFieldValue is not null)
			{
				writer.WritePropertyName("use_field");
				JsonSerializer.Serialize(writer, UseFieldValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class IntervalsMatch : IIntervalsContainerVariant, IIntervalsQueryVariant
	{
		[JsonIgnore]
		string QueryDsl.IIntervalsContainerVariant.IntervalsContainerVariantName => "match";
		[JsonIgnore]
		string QueryDsl.IIntervalsQueryVariant.IntervalsQueryVariantName => "match";
		[JsonInclude]
		[JsonPropertyName("analyzer")]
		public string? Analyzer { get; set; }

		[JsonInclude]
		[JsonPropertyName("max_gaps")]
		public int? MaxGaps { get; set; }

		[JsonInclude]
		[JsonPropertyName("ordered")]
		public bool? Ordered { get; set; }

		[JsonInclude]
		[JsonPropertyName("query")]
		public string Query { get; set; }

		[JsonInclude]
		[JsonPropertyName("use_field")]
		public string? UseField { get; set; }

		[JsonInclude]
		[JsonPropertyName("filter")]
		public Elastic.Clients.Elasticsearch.QueryDsl.IntervalsFilter? Filter { get; set; }
	}

	public sealed partial class IntervalsMatchDescriptor<T> : DescriptorBase<IntervalsMatchDescriptor<T>>
	{
		public IntervalsMatchDescriptor()
		{
		}

		internal IntervalsMatchDescriptor(Action<IntervalsMatchDescriptor<T>> configure) => configure.Invoke(this);
		internal string? AnalyzerValue { get; private set; }

		internal int? MaxGapsValue { get; private set; }

		internal bool? OrderedValue { get; private set; }

		internal string QueryValue { get; private set; }

		internal string? UseFieldValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.IntervalsFilter? FilterValue { get; private set; }

		internal IntervalsFilterDescriptor FilterDescriptor { get; private set; }

		internal Action<IntervalsFilterDescriptor> FilterDescriptorAction { get; private set; }

		public IntervalsMatchDescriptor<T> Analyzer(string? analyzer) => Assign(analyzer, (a, v) => a.AnalyzerValue = v);
		public IntervalsMatchDescriptor<T> MaxGaps(int? maxGaps) => Assign(maxGaps, (a, v) => a.MaxGapsValue = v);
		public IntervalsMatchDescriptor<T> Ordered(bool? ordered = true) => Assign(ordered, (a, v) => a.OrderedValue = v);
		public IntervalsMatchDescriptor<T> Query(string query) => Assign(query, (a, v) => a.QueryValue = v);
		public IntervalsMatchDescriptor<T> UseField(string? useField) => Assign(useField, (a, v) => a.UseFieldValue = v);
		public IntervalsMatchDescriptor<T> Filter(Elastic.Clients.Elasticsearch.QueryDsl.IntervalsFilter? filter)
		{
			FilterDescriptor = null;
			FilterDescriptorAction = null;
			return Assign(filter, (a, v) => a.FilterValue = v);
		}

		public IntervalsMatchDescriptor<T> Filter(Elastic.Clients.Elasticsearch.QueryDsl.IntervalsFilterDescriptor descriptor)
		{
			FilterValue = null;
			FilterDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.FilterDescriptor = v);
		}

		public IntervalsMatchDescriptor<T> Filter(Action<Elastic.Clients.Elasticsearch.QueryDsl.IntervalsFilterDescriptor> configure)
		{
			FilterValue = null;
			FilterDescriptorAction = null;
			return Assign(configure, (a, v) => a.FilterDescriptorAction = v);
		}

		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (!string.IsNullOrEmpty(AnalyzerValue))
			{
				writer.WritePropertyName("analyzer");
				writer.WriteStringValue(AnalyzerValue);
			}

			if (MaxGapsValue.HasValue)
			{
				writer.WritePropertyName("max_gaps");
				writer.WriteNumberValue(MaxGapsValue.Value);
			}

			if (OrderedValue.HasValue)
			{
				writer.WritePropertyName("ordered");
				writer.WriteBooleanValue(OrderedValue.Value);
			}

			writer.WritePropertyName("query");
			writer.WriteStringValue(QueryValue);
			if (UseFieldValue is not null)
			{
				writer.WritePropertyName("use_field");
				JsonSerializer.Serialize(writer, UseFieldValue, options);
			}

			if (FilterDescriptor is not null)
			{
				writer.WritePropertyName("filter");
				JsonSerializer.Serialize(writer, FilterDescriptor, options);
			}
			else if (FilterDescriptorAction is not null)
			{
				writer.WritePropertyName("filter");
				JsonSerializer.Serialize(writer, new IntervalsFilterDescriptor(FilterDescriptorAction), options);
			}
			else if (FilterValue is not null)
			{
				writer.WritePropertyName("filter");
				JsonSerializer.Serialize(writer, FilterValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class IntervalsPrefix : IIntervalsContainerVariant, IIntervalsQueryVariant
	{
		[JsonIgnore]
		string QueryDsl.IIntervalsContainerVariant.IntervalsContainerVariantName => "prefix";
		[JsonIgnore]
		string QueryDsl.IIntervalsQueryVariant.IntervalsQueryVariantName => "prefix";
		[JsonInclude]
		[JsonPropertyName("analyzer")]
		public string? Analyzer { get; set; }

		[JsonInclude]
		[JsonPropertyName("prefix")]
		public string Prefix { get; set; }

		[JsonInclude]
		[JsonPropertyName("use_field")]
		public string? UseField { get; set; }
	}

	public sealed partial class IntervalsPrefixDescriptor<T> : DescriptorBase<IntervalsPrefixDescriptor<T>>
	{
		public IntervalsPrefixDescriptor()
		{
		}

		internal IntervalsPrefixDescriptor(Action<IntervalsPrefixDescriptor<T>> configure) => configure.Invoke(this);
		internal string? AnalyzerValue { get; private set; }

		internal string PrefixValue { get; private set; }

		internal string? UseFieldValue { get; private set; }

		public IntervalsPrefixDescriptor<T> Analyzer(string? analyzer) => Assign(analyzer, (a, v) => a.AnalyzerValue = v);
		public IntervalsPrefixDescriptor<T> Prefix(string prefix) => Assign(prefix, (a, v) => a.PrefixValue = v);
		public IntervalsPrefixDescriptor<T> UseField(string? useField) => Assign(useField, (a, v) => a.UseFieldValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (!string.IsNullOrEmpty(AnalyzerValue))
			{
				writer.WritePropertyName("analyzer");
				writer.WriteStringValue(AnalyzerValue);
			}

			writer.WritePropertyName("prefix");
			writer.WriteStringValue(PrefixValue);
			if (UseFieldValue is not null)
			{
				writer.WritePropertyName("use_field");
				JsonSerializer.Serialize(writer, UseFieldValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public interface IIntervalsQueryVariant
	{
		string IntervalsQueryVariantName { get; }
	}

	[JsonConverter(typeof(IntervalsQueryConverter))]
	public partial class IntervalsQuery : FieldNameQueryBase, IContainer, IQueryContainerVariant
	{
		public IntervalsQuery(IIntervalsQueryVariant variant) => Variant = variant ?? throw new ArgumentNullException(nameof(variant));
		internal IIntervalsQueryVariant Variant { get; }

		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "intervals";
	}

	internal sealed class IntervalsQueryConverter : JsonConverter<IntervalsQuery>
	{
		public override IntervalsQuery Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			reader.Read();
			if (reader.TokenType != JsonTokenType.PropertyName)
			{
				throw new JsonException();
			}

			var propertyName = reader.GetString();
			if (propertyName == "all_of")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.IntervalsAllOf?>(ref reader, options);
				reader.Read();
				return new IntervalsQuery(variant);
			}

			if (propertyName == "any_of")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.IntervalsAnyOf?>(ref reader, options);
				reader.Read();
				return new IntervalsQuery(variant);
			}

			if (propertyName == "fuzzy")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.IntervalsFuzzy?>(ref reader, options);
				reader.Read();
				return new IntervalsQuery(variant);
			}

			if (propertyName == "match")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.IntervalsMatch?>(ref reader, options);
				reader.Read();
				return new IntervalsQuery(variant);
			}

			if (propertyName == "prefix")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.IntervalsPrefix?>(ref reader, options);
				reader.Read();
				return new IntervalsQuery(variant);
			}

			if (propertyName == "wildcard")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.IntervalsWildcard?>(ref reader, options);
				reader.Read();
				return new IntervalsQuery(variant);
			}

			throw new JsonException();
		}

		public override void Write(Utf8JsonWriter writer, IntervalsQuery value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName(value.Variant.IntervalsQueryVariantName);
			switch (value.Variant)
			{
				case Elastic.Clients.Elasticsearch.QueryDsl.IntervalsAllOf variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.IntervalsAnyOf variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.IntervalsFuzzy variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.IntervalsMatch variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.IntervalsPrefix variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.IntervalsWildcard variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
			}

			writer.WriteEndObject();
		}
	}

	public sealed partial class IntervalsQueryDescriptor<T> : FieldNameQueryDescriptorBase<IntervalsQueryDescriptor<T>>
	{
		public IntervalsQueryDescriptor()
		{
		}

		internal IntervalsQueryDescriptor(Action<IntervalsQueryDescriptor<T>> configure) => configure.Invoke(this);
		internal bool ContainsVariant { get; private set; }

		internal string ContainedVariantName { get; private set; }

		internal IntervalsQuery Container { get; private set; }

		internal object ContainerVariantDescriptorAction { get; private set; }

		private void Set(object descriptorAction, string variantName)
		{
			if (ContainsVariant)
				throw new Exception("TODO");
			ContainerVariantDescriptorAction = descriptorAction;
			ContainedVariantName = variantName;
			ContainsVariant = true;
		}

		private void Set(IIntervalsQueryVariant variant, string variantName)
		{
			if (ContainsVariant)
				throw new Exception("TODO");
			Container = new IntervalsQuery(variant);
			ContainedVariantName = variantName;
			ContainsVariant = true;
		}

		public void AllOf(IntervalsAllOf variant) => Set(variant, "all_of");
		public void AllOf(Action<IntervalsAllOfDescriptor> configure) => Set(configure, "all_of");
		public void AnyOf(IntervalsAnyOf variant) => Set(variant, "any_of");
		public void AnyOf(Action<IntervalsAnyOfDescriptor> configure) => Set(configure, "any_of");
		public void Fuzzy(IntervalsFuzzy variant) => Set(variant, "fuzzy");
		public void Fuzzy(Action<IntervalsFuzzyDescriptor<T>> configure) => Set(configure, "fuzzy");
		public void Match(IntervalsMatch variant) => Set(variant, "match");
		public void Match(Action<IntervalsMatchDescriptor<T>> configure) => Set(configure, "match");
		public void Prefix(IntervalsPrefix variant) => Set(variant, "prefix");
		public void Prefix(Action<IntervalsPrefixDescriptor<T>> configure) => Set(configure, "prefix");
		public void Wildcard(IntervalsWildcard variant) => Set(variant, "wildcard");
		public void Wildcard(Action<IntervalsWildcardDescriptor<T>> configure) => Set(configure, "wildcard");
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			if (!ContainsVariant)
			{
				writer.WriteNullValue();
				return;
			}

			writer.WriteStartObject();
			writer.WritePropertyName(ContainedVariantName);
			writer.WriteStartObject();
			if (Container is not null)
			{
				JsonSerializer.Serialize(writer, Container, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "all_of")
			{
				var descriptor = new IntervalsAllOfDescriptor();
				((Action<IntervalsAllOfDescriptor>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "any_of")
			{
				var descriptor = new IntervalsAnyOfDescriptor();
				((Action<IntervalsAnyOfDescriptor>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "fuzzy")
			{
				var descriptor = new IntervalsFuzzyDescriptor<T>();
				((Action<IntervalsFuzzyDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "match")
			{
				var descriptor = new IntervalsMatchDescriptor<T>();
				((Action<IntervalsMatchDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "prefix")
			{
				var descriptor = new IntervalsPrefixDescriptor<T>();
				((Action<IntervalsPrefixDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "wildcard")
			{
				var descriptor = new IntervalsWildcardDescriptor<T>();
				((Action<IntervalsWildcardDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			writer.WriteEndObject();
			writer.WriteEndObject();
			void Finalise()
			{
				writer.WriteEndObject();
				writer.WriteEndObject();
			}
		}
	}

	public partial class IntervalsWildcard : IIntervalsContainerVariant, IIntervalsQueryVariant
	{
		[JsonIgnore]
		string QueryDsl.IIntervalsContainerVariant.IntervalsContainerVariantName => "wildcard";
		[JsonIgnore]
		string QueryDsl.IIntervalsQueryVariant.IntervalsQueryVariantName => "wildcard";
		[JsonInclude]
		[JsonPropertyName("analyzer")]
		public string? Analyzer { get; set; }

		[JsonInclude]
		[JsonPropertyName("pattern")]
		public string Pattern { get; set; }

		[JsonInclude]
		[JsonPropertyName("use_field")]
		public string? UseField { get; set; }
	}

	public sealed partial class IntervalsWildcardDescriptor<T> : DescriptorBase<IntervalsWildcardDescriptor<T>>
	{
		public IntervalsWildcardDescriptor()
		{
		}

		internal IntervalsWildcardDescriptor(Action<IntervalsWildcardDescriptor<T>> configure) => configure.Invoke(this);
		internal string? AnalyzerValue { get; private set; }

		internal string PatternValue { get; private set; }

		internal string? UseFieldValue { get; private set; }

		public IntervalsWildcardDescriptor<T> Analyzer(string? analyzer) => Assign(analyzer, (a, v) => a.AnalyzerValue = v);
		public IntervalsWildcardDescriptor<T> Pattern(string pattern) => Assign(pattern, (a, v) => a.PatternValue = v);
		public IntervalsWildcardDescriptor<T> UseField(string? useField) => Assign(useField, (a, v) => a.UseFieldValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (!string.IsNullOrEmpty(AnalyzerValue))
			{
				writer.WritePropertyName("analyzer");
				writer.WriteStringValue(AnalyzerValue);
			}

			writer.WritePropertyName("pattern");
			writer.WriteStringValue(PatternValue);
			if (UseFieldValue is not null)
			{
				writer.WritePropertyName("use_field");
				JsonSerializer.Serialize(writer, UseFieldValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class LikeDocument
	{
		[JsonInclude]
		[JsonPropertyName("doc")]
		public object? Doc { get; init; }

		[JsonInclude]
		[JsonPropertyName("fields")]
		public IReadOnlyCollection<string>? Fields { get; init; }

		[JsonInclude]
		[JsonPropertyName("_id")]
		public Elastic.Clients.Elasticsearch.Id? Id { get; init; }

		[JsonInclude]
		[JsonPropertyName("_type")]
		public string? Type { get; init; }

		[JsonInclude]
		[JsonPropertyName("_index")]
		public Elastic.Clients.Elasticsearch.IndexName? Index { get; init; }

		[JsonInclude]
		[JsonPropertyName("per_field_analyzer")]
		public Dictionary<string, string>? PerFieldAnalyzer { get; init; }

		[JsonInclude]
		[JsonPropertyName("routing")]
		public string? Routing { get; init; }

		[JsonInclude]
		[JsonPropertyName("version")]
		public long? Version { get; init; }

		[JsonInclude]
		[JsonPropertyName("version_type")]
		public Elastic.Clients.Elasticsearch.VersionType? VersionType { get; init; }
	}

	public partial class MatchAllQuery : QueryDsl.QueryBase, IQueryContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "match_all";
	}

	public sealed partial class MatchAllQueryDescriptor : DescriptorBase<MatchAllQueryDescriptor>
	{
		public MatchAllQueryDescriptor()
		{
		}

		internal MatchAllQueryDescriptor(Action<MatchAllQueryDescriptor> configure) => configure.Invoke(this);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WriteEndObject();
		}
	}

	public partial class MatchBoolPrefixQuery : FieldNameQueryBase, IQueryContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "match_bool_prefix";
		[JsonInclude]
		[JsonPropertyName("analyzer")]
		public string? Analyzer { get; set; }

		[JsonInclude]
		[JsonPropertyName("fuzziness")]
		public Elastic.Clients.Elasticsearch.Fuzziness? Fuzziness { get; set; }

		[JsonInclude]
		[JsonPropertyName("fuzzy_rewrite")]
		public string? FuzzyRewrite { get; set; }

		[JsonInclude]
		[JsonPropertyName("fuzzy_transpositions")]
		public bool? FuzzyTranspositions { get; set; }

		[JsonInclude]
		[JsonPropertyName("max_expansions")]
		public int? MaxExpansions { get; set; }

		[JsonInclude]
		[JsonPropertyName("minimum_should_match")]
		public Elastic.Clients.Elasticsearch.MinimumShouldMatch? MinimumShouldMatch { get; set; }

		[JsonInclude]
		[JsonPropertyName("operator")]
		public Elastic.Clients.Elasticsearch.QueryDsl.Operator? Operator { get; set; }

		[JsonInclude]
		[JsonPropertyName("prefix_length")]
		public int? PrefixLength { get; set; }

		[JsonInclude]
		[JsonPropertyName("query")]
		public string Query { get; set; }
	}

	public sealed partial class MatchBoolPrefixQueryDescriptor : FieldNameQueryDescriptorBase<MatchBoolPrefixQueryDescriptor>
	{
		public MatchBoolPrefixQueryDescriptor()
		{
		}

		internal MatchBoolPrefixQueryDescriptor(Action<MatchBoolPrefixQueryDescriptor> configure) => configure.Invoke(this);
		internal string? AnalyzerValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Fuzziness? FuzzinessValue { get; private set; }

		internal string? FuzzyRewriteValue { get; private set; }

		internal bool? FuzzyTranspositionsValue { get; private set; }

		internal int? MaxExpansionsValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.MinimumShouldMatch? MinimumShouldMatchValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.Operator? OperatorValue { get; private set; }

		internal int? PrefixLengthValue { get; private set; }

		internal string QueryValue { get; private set; }

		public MatchBoolPrefixQueryDescriptor Analyzer(string? analyzer) => Assign(analyzer, (a, v) => a.AnalyzerValue = v);
		public MatchBoolPrefixQueryDescriptor Fuzziness(Elastic.Clients.Elasticsearch.Fuzziness? fuzziness) => Assign(fuzziness, (a, v) => a.FuzzinessValue = v);
		public MatchBoolPrefixQueryDescriptor FuzzyRewrite(string? fuzzyRewrite) => Assign(fuzzyRewrite, (a, v) => a.FuzzyRewriteValue = v);
		public MatchBoolPrefixQueryDescriptor FuzzyTranspositions(bool? fuzzyTranspositions = true) => Assign(fuzzyTranspositions, (a, v) => a.FuzzyTranspositionsValue = v);
		public MatchBoolPrefixQueryDescriptor MaxExpansions(int? maxExpansions) => Assign(maxExpansions, (a, v) => a.MaxExpansionsValue = v);
		public MatchBoolPrefixQueryDescriptor MinimumShouldMatch(Elastic.Clients.Elasticsearch.MinimumShouldMatch? minimumShouldMatch) => Assign(minimumShouldMatch, (a, v) => a.MinimumShouldMatchValue = v);
		public MatchBoolPrefixQueryDescriptor Operator(Elastic.Clients.Elasticsearch.QueryDsl.Operator? op) => Assign(op, (a, v) => a.OperatorValue = v);
		public MatchBoolPrefixQueryDescriptor PrefixLength(int? prefixLength) => Assign(prefixLength, (a, v) => a.PrefixLengthValue = v);
		public MatchBoolPrefixQueryDescriptor Query(string query) => Assign(query, (a, v) => a.QueryValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WritePropertyName(settings.Inferrer.Field(_field));
			writer.WriteStartObject();
			if (!string.IsNullOrEmpty(AnalyzerValue))
			{
				writer.WritePropertyName("analyzer");
				writer.WriteStringValue(AnalyzerValue);
			}

			if (FuzzinessValue is not null)
			{
				writer.WritePropertyName("fuzziness");
				JsonSerializer.Serialize(writer, FuzzinessValue, options);
			}

			if (FuzzyRewriteValue is not null)
			{
				writer.WritePropertyName("fuzzy_rewrite");
				JsonSerializer.Serialize(writer, FuzzyRewriteValue, options);
			}

			if (FuzzyTranspositionsValue.HasValue)
			{
				writer.WritePropertyName("fuzzy_transpositions");
				writer.WriteBooleanValue(FuzzyTranspositionsValue.Value);
			}

			if (MaxExpansionsValue.HasValue)
			{
				writer.WritePropertyName("max_expansions");
				writer.WriteNumberValue(MaxExpansionsValue.Value);
			}

			if (MinimumShouldMatchValue is not null)
			{
				writer.WritePropertyName("minimum_should_match");
				JsonSerializer.Serialize(writer, MinimumShouldMatchValue, options);
			}

			if (OperatorValue is not null)
			{
				writer.WritePropertyName("operator");
				JsonSerializer.Serialize(writer, OperatorValue, options);
			}

			if (PrefixLengthValue.HasValue)
			{
				writer.WritePropertyName("prefix_length");
				writer.WriteNumberValue(PrefixLengthValue.Value);
			}

			writer.WritePropertyName("query");
			writer.WriteStringValue(QueryValue);
			writer.WriteEndObject();
		}
	}

	public partial class MatchNoneQuery : QueryDsl.QueryBase, IQueryContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "match_none";
	}

	public sealed partial class MatchNoneQueryDescriptor : DescriptorBase<MatchNoneQueryDescriptor>
	{
		public MatchNoneQueryDescriptor()
		{
		}

		internal MatchNoneQueryDescriptor(Action<MatchNoneQueryDescriptor> configure) => configure.Invoke(this);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WriteEndObject();
		}
	}

	public partial class MatchPhrasePrefixQuery : FieldNameQueryBase, IQueryContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "match_phrase_prefix";
		[JsonInclude]
		[JsonPropertyName("analyzer")]
		public string? Analyzer { get; set; }

		[JsonInclude]
		[JsonPropertyName("max_expansions")]
		public int? MaxExpansions { get; set; }

		[JsonInclude]
		[JsonPropertyName("query")]
		public string Query { get; set; }

		[JsonInclude]
		[JsonPropertyName("slop")]
		public int? Slop { get; set; }

		[JsonInclude]
		[JsonPropertyName("zero_terms_query")]
		public Elastic.Clients.Elasticsearch.QueryDsl.ZeroTermsQuery? ZeroTermsQuery { get; set; }
	}

	public sealed partial class MatchPhrasePrefixQueryDescriptor : FieldNameQueryDescriptorBase<MatchPhrasePrefixQueryDescriptor>
	{
		public MatchPhrasePrefixQueryDescriptor()
		{
		}

		internal MatchPhrasePrefixQueryDescriptor(Action<MatchPhrasePrefixQueryDescriptor> configure) => configure.Invoke(this);
		internal string? AnalyzerValue { get; private set; }

		internal int? MaxExpansionsValue { get; private set; }

		internal string QueryValue { get; private set; }

		internal int? SlopValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.ZeroTermsQuery? ZeroTermsQueryValue { get; private set; }

		public MatchPhrasePrefixQueryDescriptor Analyzer(string? analyzer) => Assign(analyzer, (a, v) => a.AnalyzerValue = v);
		public MatchPhrasePrefixQueryDescriptor MaxExpansions(int? maxExpansions) => Assign(maxExpansions, (a, v) => a.MaxExpansionsValue = v);
		public MatchPhrasePrefixQueryDescriptor Query(string query) => Assign(query, (a, v) => a.QueryValue = v);
		public MatchPhrasePrefixQueryDescriptor Slop(int? slop) => Assign(slop, (a, v) => a.SlopValue = v);
		public MatchPhrasePrefixQueryDescriptor ZeroTermsQuery(Elastic.Clients.Elasticsearch.QueryDsl.ZeroTermsQuery? zeroTermsQuery) => Assign(zeroTermsQuery, (a, v) => a.ZeroTermsQueryValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WritePropertyName(settings.Inferrer.Field(_field));
			writer.WriteStartObject();
			if (!string.IsNullOrEmpty(AnalyzerValue))
			{
				writer.WritePropertyName("analyzer");
				writer.WriteStringValue(AnalyzerValue);
			}

			if (MaxExpansionsValue.HasValue)
			{
				writer.WritePropertyName("max_expansions");
				writer.WriteNumberValue(MaxExpansionsValue.Value);
			}

			writer.WritePropertyName("query");
			writer.WriteStringValue(QueryValue);
			if (SlopValue.HasValue)
			{
				writer.WritePropertyName("slop");
				writer.WriteNumberValue(SlopValue.Value);
			}

			if (ZeroTermsQueryValue is not null)
			{
				writer.WritePropertyName("zero_terms_query");
				JsonSerializer.Serialize(writer, ZeroTermsQueryValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class MatchPhraseQuery : FieldNameQueryBase, IQueryContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "match_phrase";
		[JsonInclude]
		[JsonPropertyName("analyzer")]
		public string? Analyzer { get; set; }

		[JsonInclude]
		[JsonPropertyName("query")]
		public string Query { get; set; }

		[JsonInclude]
		[JsonPropertyName("slop")]
		public int? Slop { get; set; }

		[JsonInclude]
		[JsonPropertyName("zero_terms_query")]
		public Elastic.Clients.Elasticsearch.QueryDsl.ZeroTermsQuery? ZeroTermsQuery { get; set; }
	}

	public sealed partial class MatchPhraseQueryDescriptor : FieldNameQueryDescriptorBase<MatchPhraseQueryDescriptor>
	{
		public MatchPhraseQueryDescriptor()
		{
		}

		internal MatchPhraseQueryDescriptor(Action<MatchPhraseQueryDescriptor> configure) => configure.Invoke(this);
		internal string? AnalyzerValue { get; private set; }

		internal string QueryValue { get; private set; }

		internal int? SlopValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.ZeroTermsQuery? ZeroTermsQueryValue { get; private set; }

		public MatchPhraseQueryDescriptor Analyzer(string? analyzer) => Assign(analyzer, (a, v) => a.AnalyzerValue = v);
		public MatchPhraseQueryDescriptor Query(string query) => Assign(query, (a, v) => a.QueryValue = v);
		public MatchPhraseQueryDescriptor Slop(int? slop) => Assign(slop, (a, v) => a.SlopValue = v);
		public MatchPhraseQueryDescriptor ZeroTermsQuery(Elastic.Clients.Elasticsearch.QueryDsl.ZeroTermsQuery? zeroTermsQuery) => Assign(zeroTermsQuery, (a, v) => a.ZeroTermsQueryValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WritePropertyName(settings.Inferrer.Field(_field));
			writer.WriteStartObject();
			if (!string.IsNullOrEmpty(AnalyzerValue))
			{
				writer.WritePropertyName("analyzer");
				writer.WriteStringValue(AnalyzerValue);
			}

			writer.WritePropertyName("query");
			writer.WriteStringValue(QueryValue);
			if (SlopValue.HasValue)
			{
				writer.WritePropertyName("slop");
				writer.WriteNumberValue(SlopValue.Value);
			}

			if (ZeroTermsQueryValue is not null)
			{
				writer.WritePropertyName("zero_terms_query");
				JsonSerializer.Serialize(writer, ZeroTermsQueryValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class MatchQuery : FieldNameQueryBase, IQueryContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "match";
		[JsonInclude]
		[JsonPropertyName("analyzer")]
		public string? Analyzer { get; set; }

		[JsonInclude]
		[JsonPropertyName("auto_generate_synonyms_phrase_query")]
		public bool? AutoGenerateSynonymsPhraseQuery { get; set; }

		[JsonInclude]
		[JsonPropertyName("fuzziness")]
		public Elastic.Clients.Elasticsearch.Fuzziness? Fuzziness { get; set; }

		[JsonInclude]
		[JsonPropertyName("fuzzy_rewrite")]
		public string? FuzzyRewrite { get; set; }

		[JsonInclude]
		[JsonPropertyName("fuzzy_transpositions")]
		public bool? FuzzyTranspositions { get; set; }

		[JsonInclude]
		[JsonPropertyName("lenient")]
		public bool? Lenient { get; set; }

		[JsonInclude]
		[JsonPropertyName("max_expansions")]
		public int? MaxExpansions { get; set; }

		[JsonInclude]
		[JsonPropertyName("minimum_should_match")]
		public Elastic.Clients.Elasticsearch.MinimumShouldMatch? MinimumShouldMatch { get; set; }

		[JsonInclude]
		[JsonPropertyName("operator")]
		public Elastic.Clients.Elasticsearch.QueryDsl.Operator? Operator { get; set; }

		[JsonInclude]
		[JsonPropertyName("prefix_length")]
		public int? PrefixLength { get; set; }

		[JsonInclude]
		[JsonPropertyName("query")]
		public string Query { get; set; }

		[JsonInclude]
		[JsonPropertyName("zero_terms_query")]
		public Elastic.Clients.Elasticsearch.QueryDsl.ZeroTermsQuery? ZeroTermsQuery { get; set; }
	}

	public sealed partial class MatchQueryDescriptor : FieldNameQueryDescriptorBase<MatchQueryDescriptor>
	{
		public MatchQueryDescriptor()
		{
		}

		internal MatchQueryDescriptor(Action<MatchQueryDescriptor> configure) => configure.Invoke(this);
		internal string? AnalyzerValue { get; private set; }

		internal bool? AutoGenerateSynonymsPhraseQueryValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Fuzziness? FuzzinessValue { get; private set; }

		internal string? FuzzyRewriteValue { get; private set; }

		internal bool? FuzzyTranspositionsValue { get; private set; }

		internal bool? LenientValue { get; private set; }

		internal int? MaxExpansionsValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.MinimumShouldMatch? MinimumShouldMatchValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.Operator? OperatorValue { get; private set; }

		internal int? PrefixLengthValue { get; private set; }

		internal string QueryValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.ZeroTermsQuery? ZeroTermsQueryValue { get; private set; }

		public MatchQueryDescriptor Analyzer(string? analyzer) => Assign(analyzer, (a, v) => a.AnalyzerValue = v);
		public MatchQueryDescriptor AutoGenerateSynonymsPhraseQuery(bool? autoGenerateSynonymsPhraseQuery = true) => Assign(autoGenerateSynonymsPhraseQuery, (a, v) => a.AutoGenerateSynonymsPhraseQueryValue = v);
		public MatchQueryDescriptor Fuzziness(Elastic.Clients.Elasticsearch.Fuzziness? fuzziness) => Assign(fuzziness, (a, v) => a.FuzzinessValue = v);
		public MatchQueryDescriptor FuzzyRewrite(string? fuzzyRewrite) => Assign(fuzzyRewrite, (a, v) => a.FuzzyRewriteValue = v);
		public MatchQueryDescriptor FuzzyTranspositions(bool? fuzzyTranspositions = true) => Assign(fuzzyTranspositions, (a, v) => a.FuzzyTranspositionsValue = v);
		public MatchQueryDescriptor Lenient(bool? lenient = true) => Assign(lenient, (a, v) => a.LenientValue = v);
		public MatchQueryDescriptor MaxExpansions(int? maxExpansions) => Assign(maxExpansions, (a, v) => a.MaxExpansionsValue = v);
		public MatchQueryDescriptor MinimumShouldMatch(Elastic.Clients.Elasticsearch.MinimumShouldMatch? minimumShouldMatch) => Assign(minimumShouldMatch, (a, v) => a.MinimumShouldMatchValue = v);
		public MatchQueryDescriptor Operator(Elastic.Clients.Elasticsearch.QueryDsl.Operator? op) => Assign(op, (a, v) => a.OperatorValue = v);
		public MatchQueryDescriptor PrefixLength(int? prefixLength) => Assign(prefixLength, (a, v) => a.PrefixLengthValue = v);
		public MatchQueryDescriptor Query(string query) => Assign(query, (a, v) => a.QueryValue = v);
		public MatchQueryDescriptor ZeroTermsQuery(Elastic.Clients.Elasticsearch.QueryDsl.ZeroTermsQuery? zeroTermsQuery) => Assign(zeroTermsQuery, (a, v) => a.ZeroTermsQueryValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WritePropertyName(settings.Inferrer.Field(_field));
			writer.WriteStartObject();
			if (!string.IsNullOrEmpty(AnalyzerValue))
			{
				writer.WritePropertyName("analyzer");
				writer.WriteStringValue(AnalyzerValue);
			}

			if (AutoGenerateSynonymsPhraseQueryValue.HasValue)
			{
				writer.WritePropertyName("auto_generate_synonyms_phrase_query");
				writer.WriteBooleanValue(AutoGenerateSynonymsPhraseQueryValue.Value);
			}

			if (FuzzinessValue is not null)
			{
				writer.WritePropertyName("fuzziness");
				JsonSerializer.Serialize(writer, FuzzinessValue, options);
			}

			if (FuzzyRewriteValue is not null)
			{
				writer.WritePropertyName("fuzzy_rewrite");
				JsonSerializer.Serialize(writer, FuzzyRewriteValue, options);
			}

			if (FuzzyTranspositionsValue.HasValue)
			{
				writer.WritePropertyName("fuzzy_transpositions");
				writer.WriteBooleanValue(FuzzyTranspositionsValue.Value);
			}

			if (LenientValue.HasValue)
			{
				writer.WritePropertyName("lenient");
				writer.WriteBooleanValue(LenientValue.Value);
			}

			if (MaxExpansionsValue.HasValue)
			{
				writer.WritePropertyName("max_expansions");
				writer.WriteNumberValue(MaxExpansionsValue.Value);
			}

			if (MinimumShouldMatchValue is not null)
			{
				writer.WritePropertyName("minimum_should_match");
				JsonSerializer.Serialize(writer, MinimumShouldMatchValue, options);
			}

			if (OperatorValue is not null)
			{
				writer.WritePropertyName("operator");
				JsonSerializer.Serialize(writer, OperatorValue, options);
			}

			if (PrefixLengthValue.HasValue)
			{
				writer.WritePropertyName("prefix_length");
				writer.WriteNumberValue(PrefixLengthValue.Value);
			}

			writer.WritePropertyName("query");
			JsonSerializer.Serialize(writer, QueryValue, options);
			if (ZeroTermsQueryValue is not null)
			{
				writer.WritePropertyName("zero_terms_query");
				JsonSerializer.Serialize(writer, ZeroTermsQueryValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class MoreLikeThisQuery : QueryDsl.QueryBase, IQueryContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "more_like_this";
		[JsonInclude]
		[JsonPropertyName("analyzer")]
		public string? Analyzer { get; set; }

		[JsonInclude]
		[JsonPropertyName("boost_terms")]
		public double? BoostTerms { get; set; }

		[JsonInclude]
		[JsonPropertyName("fail_on_unsupported_field")]
		public bool? FailOnUnsupportedField { get; set; }

		[JsonInclude]
		[JsonPropertyName("fields")]
		public IEnumerable<string>? Fields { get; set; }

		[JsonInclude]
		[JsonPropertyName("include")]
		public bool? Include { get; set; }

		[JsonInclude]
		[JsonPropertyName("like")]
		public Elastic.Clients.Elasticsearch.QueryDsl.Like Like { get; set; }

		[JsonInclude]
		[JsonPropertyName("max_doc_freq")]
		public int? MaxDocFreq { get; set; }

		[JsonInclude]
		[JsonPropertyName("max_query_terms")]
		public int? MaxQueryTerms { get; set; }

		[JsonInclude]
		[JsonPropertyName("max_word_length")]
		public int? MaxWordLength { get; set; }

		[JsonInclude]
		[JsonPropertyName("min_doc_freq")]
		public int? MinDocFreq { get; set; }

		[JsonInclude]
		[JsonPropertyName("minimum_should_match")]
		public Elastic.Clients.Elasticsearch.MinimumShouldMatch? MinimumShouldMatch { get; set; }

		[JsonInclude]
		[JsonPropertyName("min_term_freq")]
		public int? MinTermFreq { get; set; }

		[JsonInclude]
		[JsonPropertyName("min_word_length")]
		public int? MinWordLength { get; set; }

		[JsonInclude]
		[JsonPropertyName("per_field_analyzer")]
		public Dictionary<string, string>? PerFieldAnalyzer { get; set; }

		[JsonInclude]
		[JsonPropertyName("routing")]
		public string? Routing { get; set; }

		[JsonInclude]
		[JsonPropertyName("stop_words")]
		public Elastic.Clients.Elasticsearch.Analysis.StopWords? StopWords { get; set; }

		[JsonInclude]
		[JsonPropertyName("unlike")]
		public Elastic.Clients.Elasticsearch.QueryDsl.Like? Unlike { get; set; }

		[JsonInclude]
		[JsonPropertyName("version")]
		public long? Version { get; set; }

		[JsonInclude]
		[JsonPropertyName("version_type")]
		public Elastic.Clients.Elasticsearch.VersionType? VersionType { get; set; }
	}

	public sealed partial class MoreLikeThisQueryDescriptor<T> : DescriptorBase<MoreLikeThisQueryDescriptor<T>>
	{
		public MoreLikeThisQueryDescriptor()
		{
		}

		internal MoreLikeThisQueryDescriptor(Action<MoreLikeThisQueryDescriptor<T>> configure) => configure.Invoke(this);
		internal string? AnalyzerValue { get; private set; }

		internal double? BoostTermsValue { get; private set; }

		internal bool? FailOnUnsupportedFieldValue { get; private set; }

		internal IEnumerable<string>? FieldsValue { get; private set; }

		internal bool? IncludeValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.Like LikeValue { get; private set; }

		internal int? MaxDocFreqValue { get; private set; }

		internal int? MaxQueryTermsValue { get; private set; }

		internal int? MaxWordLengthValue { get; private set; }

		internal int? MinDocFreqValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.MinimumShouldMatch? MinimumShouldMatchValue { get; private set; }

		internal int? MinTermFreqValue { get; private set; }

		internal int? MinWordLengthValue { get; private set; }

		internal Dictionary<string, string>? PerFieldAnalyzerValue { get; private set; }

		internal string? RoutingValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Analysis.StopWords? StopWordsValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.Like? UnlikeValue { get; private set; }

		internal long? VersionValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.VersionType? VersionTypeValue { get; private set; }

		public MoreLikeThisQueryDescriptor<T> Analyzer(string? analyzer) => Assign(analyzer, (a, v) => a.AnalyzerValue = v);
		public MoreLikeThisQueryDescriptor<T> BoostTerms(double? boostTerms) => Assign(boostTerms, (a, v) => a.BoostTermsValue = v);
		public MoreLikeThisQueryDescriptor<T> FailOnUnsupportedField(bool? failOnUnsupportedField = true) => Assign(failOnUnsupportedField, (a, v) => a.FailOnUnsupportedFieldValue = v);
		public MoreLikeThisQueryDescriptor<T> Fields(IEnumerable<string>? fields) => Assign(fields, (a, v) => a.FieldsValue = v);
		public MoreLikeThisQueryDescriptor<T> Include(bool? include = true) => Assign(include, (a, v) => a.IncludeValue = v);
		public MoreLikeThisQueryDescriptor<T> Like(Elastic.Clients.Elasticsearch.QueryDsl.Like like) => Assign(like, (a, v) => a.LikeValue = v);
		public MoreLikeThisQueryDescriptor<T> MaxDocFreq(int? maxDocFreq) => Assign(maxDocFreq, (a, v) => a.MaxDocFreqValue = v);
		public MoreLikeThisQueryDescriptor<T> MaxQueryTerms(int? maxQueryTerms) => Assign(maxQueryTerms, (a, v) => a.MaxQueryTermsValue = v);
		public MoreLikeThisQueryDescriptor<T> MaxWordLength(int? maxWordLength) => Assign(maxWordLength, (a, v) => a.MaxWordLengthValue = v);
		public MoreLikeThisQueryDescriptor<T> MinDocFreq(int? minDocFreq) => Assign(minDocFreq, (a, v) => a.MinDocFreqValue = v);
		public MoreLikeThisQueryDescriptor<T> MinimumShouldMatch(Elastic.Clients.Elasticsearch.MinimumShouldMatch? minimumShouldMatch) => Assign(minimumShouldMatch, (a, v) => a.MinimumShouldMatchValue = v);
		public MoreLikeThisQueryDescriptor<T> MinTermFreq(int? minTermFreq) => Assign(minTermFreq, (a, v) => a.MinTermFreqValue = v);
		public MoreLikeThisQueryDescriptor<T> MinWordLength(int? minWordLength) => Assign(minWordLength, (a, v) => a.MinWordLengthValue = v);
		public MoreLikeThisQueryDescriptor<T> PerFieldAnalyzer(Func<FluentDictionary<string?, string?>, FluentDictionary<string?, string?>> selector) => Assign(selector, (a, v) => a.PerFieldAnalyzerValue = v?.Invoke(new FluentDictionary<string?, string?>()));
		public MoreLikeThisQueryDescriptor<T> Routing(string? routing) => Assign(routing, (a, v) => a.RoutingValue = v);
		public MoreLikeThisQueryDescriptor<T> StopWords(Elastic.Clients.Elasticsearch.Analysis.StopWords? stopWords) => Assign(stopWords, (a, v) => a.StopWordsValue = v);
		public MoreLikeThisQueryDescriptor<T> Unlike(Elastic.Clients.Elasticsearch.QueryDsl.Like? unlike) => Assign(unlike, (a, v) => a.UnlikeValue = v);
		public MoreLikeThisQueryDescriptor<T> Version(long? version) => Assign(version, (a, v) => a.VersionValue = v);
		public MoreLikeThisQueryDescriptor<T> VersionType(Elastic.Clients.Elasticsearch.VersionType? versionType) => Assign(versionType, (a, v) => a.VersionTypeValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (!string.IsNullOrEmpty(AnalyzerValue))
			{
				writer.WritePropertyName("analyzer");
				writer.WriteStringValue(AnalyzerValue);
			}

			if (BoostTermsValue.HasValue)
			{
				writer.WritePropertyName("boost_terms");
				writer.WriteNumberValue(BoostTermsValue.Value);
			}

			if (FailOnUnsupportedFieldValue.HasValue)
			{
				writer.WritePropertyName("fail_on_unsupported_field");
				writer.WriteBooleanValue(FailOnUnsupportedFieldValue.Value);
			}

			if (FieldsValue is not null)
			{
				writer.WritePropertyName("fields");
				JsonSerializer.Serialize(writer, FieldsValue, options);
			}

			if (IncludeValue.HasValue)
			{
				writer.WritePropertyName("include");
				writer.WriteBooleanValue(IncludeValue.Value);
			}

			writer.WritePropertyName("like");
			JsonSerializer.Serialize(writer, LikeValue, options);
			if (MaxDocFreqValue.HasValue)
			{
				writer.WritePropertyName("max_doc_freq");
				writer.WriteNumberValue(MaxDocFreqValue.Value);
			}

			if (MaxQueryTermsValue.HasValue)
			{
				writer.WritePropertyName("max_query_terms");
				writer.WriteNumberValue(MaxQueryTermsValue.Value);
			}

			if (MaxWordLengthValue.HasValue)
			{
				writer.WritePropertyName("max_word_length");
				writer.WriteNumberValue(MaxWordLengthValue.Value);
			}

			if (MinDocFreqValue.HasValue)
			{
				writer.WritePropertyName("min_doc_freq");
				writer.WriteNumberValue(MinDocFreqValue.Value);
			}

			if (MinimumShouldMatchValue is not null)
			{
				writer.WritePropertyName("minimum_should_match");
				JsonSerializer.Serialize(writer, MinimumShouldMatchValue, options);
			}

			if (MinTermFreqValue.HasValue)
			{
				writer.WritePropertyName("min_term_freq");
				writer.WriteNumberValue(MinTermFreqValue.Value);
			}

			if (MinWordLengthValue.HasValue)
			{
				writer.WritePropertyName("min_word_length");
				writer.WriteNumberValue(MinWordLengthValue.Value);
			}

			if (PerFieldAnalyzerValue is not null)
			{
				writer.WritePropertyName("per_field_analyzer");
				JsonSerializer.Serialize(writer, PerFieldAnalyzerValue, options);
			}

			if (RoutingValue is not null)
			{
				writer.WritePropertyName("routing");
				JsonSerializer.Serialize(writer, RoutingValue, options);
			}

			if (StopWordsValue is not null)
			{
				writer.WritePropertyName("stop_words");
				JsonSerializer.Serialize(writer, StopWordsValue, options);
			}

			if (UnlikeValue is not null)
			{
				writer.WritePropertyName("unlike");
				JsonSerializer.Serialize(writer, UnlikeValue, options);
			}

			if (VersionValue is not null)
			{
				writer.WritePropertyName("version");
				JsonSerializer.Serialize(writer, VersionValue, options);
			}

			if (VersionTypeValue is not null)
			{
				writer.WritePropertyName("version_type");
				JsonSerializer.Serialize(writer, VersionTypeValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class MultiMatchQuery : QueryDsl.QueryBase, IQueryContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "multi_match";
		[JsonInclude]
		[JsonPropertyName("analyzer")]
		public string? Analyzer { get; set; }

		[JsonInclude]
		[JsonPropertyName("auto_generate_synonyms_phrase_query")]
		public bool? AutoGenerateSynonymsPhraseQuery { get; set; }

		[JsonInclude]
		[JsonPropertyName("fields")]
		public Elastic.Clients.Elasticsearch.Fields? Fields { get; set; }

		[JsonInclude]
		[JsonPropertyName("fuzziness")]
		public Elastic.Clients.Elasticsearch.Fuzziness? Fuzziness { get; set; }

		[JsonInclude]
		[JsonPropertyName("fuzzy_rewrite")]
		public string? FuzzyRewrite { get; set; }

		[JsonInclude]
		[JsonPropertyName("fuzzy_transpositions")]
		public bool? FuzzyTranspositions { get; set; }

		[JsonInclude]
		[JsonPropertyName("lenient")]
		public bool? Lenient { get; set; }

		[JsonInclude]
		[JsonPropertyName("max_expansions")]
		public int? MaxExpansions { get; set; }

		[JsonInclude]
		[JsonPropertyName("minimum_should_match")]
		public Elastic.Clients.Elasticsearch.MinimumShouldMatch? MinimumShouldMatch { get; set; }

		[JsonInclude]
		[JsonPropertyName("operator")]
		public Elastic.Clients.Elasticsearch.QueryDsl.Operator? Operator { get; set; }

		[JsonInclude]
		[JsonPropertyName("prefix_length")]
		public int? PrefixLength { get; set; }

		[JsonInclude]
		[JsonPropertyName("query")]
		public string Query { get; set; }

		[JsonInclude]
		[JsonPropertyName("slop")]
		public int? Slop { get; set; }

		[JsonInclude]
		[JsonPropertyName("tie_breaker")]
		public double? TieBreaker { get; set; }

		[JsonInclude]
		[JsonPropertyName("type")]
		public Elastic.Clients.Elasticsearch.QueryDsl.TextQueryType? Type { get; set; }

		[JsonInclude]
		[JsonPropertyName("zero_terms_query")]
		public Elastic.Clients.Elasticsearch.QueryDsl.ZeroTermsQuery? ZeroTermsQuery { get; set; }
	}

	public sealed partial class MultiMatchQueryDescriptor<T> : DescriptorBase<MultiMatchQueryDescriptor<T>>
	{
		public MultiMatchQueryDescriptor()
		{
		}

		internal MultiMatchQueryDescriptor(Action<MultiMatchQueryDescriptor<T>> configure) => configure.Invoke(this);
		internal string? AnalyzerValue { get; private set; }

		internal bool? AutoGenerateSynonymsPhraseQueryValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Fields? FieldsValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Fuzziness? FuzzinessValue { get; private set; }

		internal string? FuzzyRewriteValue { get; private set; }

		internal bool? FuzzyTranspositionsValue { get; private set; }

		internal bool? LenientValue { get; private set; }

		internal int? MaxExpansionsValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.MinimumShouldMatch? MinimumShouldMatchValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.Operator? OperatorValue { get; private set; }

		internal int? PrefixLengthValue { get; private set; }

		internal string QueryValue { get; private set; }

		internal int? SlopValue { get; private set; }

		internal double? TieBreakerValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.TextQueryType? TypeValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.ZeroTermsQuery? ZeroTermsQueryValue { get; private set; }

		public MultiMatchQueryDescriptor<T> Analyzer(string? analyzer) => Assign(analyzer, (a, v) => a.AnalyzerValue = v);
		public MultiMatchQueryDescriptor<T> AutoGenerateSynonymsPhraseQuery(bool? autoGenerateSynonymsPhraseQuery = true) => Assign(autoGenerateSynonymsPhraseQuery, (a, v) => a.AutoGenerateSynonymsPhraseQueryValue = v);
		public MultiMatchQueryDescriptor<T> Fields(Elastic.Clients.Elasticsearch.Fields? fields) => Assign(fields, (a, v) => a.FieldsValue = v);
		public MultiMatchQueryDescriptor<T> Fuzziness(Elastic.Clients.Elasticsearch.Fuzziness? fuzziness) => Assign(fuzziness, (a, v) => a.FuzzinessValue = v);
		public MultiMatchQueryDescriptor<T> FuzzyRewrite(string? fuzzyRewrite) => Assign(fuzzyRewrite, (a, v) => a.FuzzyRewriteValue = v);
		public MultiMatchQueryDescriptor<T> FuzzyTranspositions(bool? fuzzyTranspositions = true) => Assign(fuzzyTranspositions, (a, v) => a.FuzzyTranspositionsValue = v);
		public MultiMatchQueryDescriptor<T> Lenient(bool? lenient = true) => Assign(lenient, (a, v) => a.LenientValue = v);
		public MultiMatchQueryDescriptor<T> MaxExpansions(int? maxExpansions) => Assign(maxExpansions, (a, v) => a.MaxExpansionsValue = v);
		public MultiMatchQueryDescriptor<T> MinimumShouldMatch(Elastic.Clients.Elasticsearch.MinimumShouldMatch? minimumShouldMatch) => Assign(minimumShouldMatch, (a, v) => a.MinimumShouldMatchValue = v);
		public MultiMatchQueryDescriptor<T> Operator(Elastic.Clients.Elasticsearch.QueryDsl.Operator? op) => Assign(op, (a, v) => a.OperatorValue = v);
		public MultiMatchQueryDescriptor<T> PrefixLength(int? prefixLength) => Assign(prefixLength, (a, v) => a.PrefixLengthValue = v);
		public MultiMatchQueryDescriptor<T> Query(string query) => Assign(query, (a, v) => a.QueryValue = v);
		public MultiMatchQueryDescriptor<T> Slop(int? slop) => Assign(slop, (a, v) => a.SlopValue = v);
		public MultiMatchQueryDescriptor<T> TieBreaker(double? tieBreaker) => Assign(tieBreaker, (a, v) => a.TieBreakerValue = v);
		public MultiMatchQueryDescriptor<T> Type(Elastic.Clients.Elasticsearch.QueryDsl.TextQueryType? type) => Assign(type, (a, v) => a.TypeValue = v);
		public MultiMatchQueryDescriptor<T> ZeroTermsQuery(Elastic.Clients.Elasticsearch.QueryDsl.ZeroTermsQuery? zeroTermsQuery) => Assign(zeroTermsQuery, (a, v) => a.ZeroTermsQueryValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (!string.IsNullOrEmpty(AnalyzerValue))
			{
				writer.WritePropertyName("analyzer");
				writer.WriteStringValue(AnalyzerValue);
			}

			if (AutoGenerateSynonymsPhraseQueryValue.HasValue)
			{
				writer.WritePropertyName("auto_generate_synonyms_phrase_query");
				writer.WriteBooleanValue(AutoGenerateSynonymsPhraseQueryValue.Value);
			}

			if (FieldsValue is not null)
			{
				writer.WritePropertyName("fields");
				JsonSerializer.Serialize(writer, FieldsValue, options);
			}

			if (FuzzinessValue is not null)
			{
				writer.WritePropertyName("fuzziness");
				JsonSerializer.Serialize(writer, FuzzinessValue, options);
			}

			if (FuzzyRewriteValue is not null)
			{
				writer.WritePropertyName("fuzzy_rewrite");
				JsonSerializer.Serialize(writer, FuzzyRewriteValue, options);
			}

			if (FuzzyTranspositionsValue.HasValue)
			{
				writer.WritePropertyName("fuzzy_transpositions");
				writer.WriteBooleanValue(FuzzyTranspositionsValue.Value);
			}

			if (LenientValue.HasValue)
			{
				writer.WritePropertyName("lenient");
				writer.WriteBooleanValue(LenientValue.Value);
			}

			if (MaxExpansionsValue.HasValue)
			{
				writer.WritePropertyName("max_expansions");
				writer.WriteNumberValue(MaxExpansionsValue.Value);
			}

			if (MinimumShouldMatchValue is not null)
			{
				writer.WritePropertyName("minimum_should_match");
				JsonSerializer.Serialize(writer, MinimumShouldMatchValue, options);
			}

			if (OperatorValue is not null)
			{
				writer.WritePropertyName("operator");
				JsonSerializer.Serialize(writer, OperatorValue, options);
			}

			if (PrefixLengthValue.HasValue)
			{
				writer.WritePropertyName("prefix_length");
				writer.WriteNumberValue(PrefixLengthValue.Value);
			}

			writer.WritePropertyName("query");
			writer.WriteStringValue(QueryValue);
			if (SlopValue.HasValue)
			{
				writer.WritePropertyName("slop");
				writer.WriteNumberValue(SlopValue.Value);
			}

			if (TieBreakerValue.HasValue)
			{
				writer.WritePropertyName("tie_breaker");
				writer.WriteNumberValue(TieBreakerValue.Value);
			}

			if (TypeValue is not null)
			{
				writer.WritePropertyName("type");
				JsonSerializer.Serialize(writer, TypeValue, options);
			}

			if (ZeroTermsQueryValue is not null)
			{
				writer.WritePropertyName("zero_terms_query");
				JsonSerializer.Serialize(writer, ZeroTermsQueryValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class NestedQuery : QueryDsl.QueryBase, IQueryContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "nested";
		[JsonInclude]
		[JsonPropertyName("ignore_unmapped")]
		public bool? IgnoreUnmapped { get; set; }

		[JsonInclude]
		[JsonPropertyName("inner_hits")]
		public Elastic.Clients.Elasticsearch.InnerHits? InnerHits { get; set; }

		[JsonInclude]
		[JsonPropertyName("path")]
		public string Path { get; set; }

		[JsonInclude]
		[JsonPropertyName("query")]
		public Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer Query { get; set; }

		[JsonInclude]
		[JsonPropertyName("score_mode")]
		public Elastic.Clients.Elasticsearch.QueryDsl.NestedScoreMode? ScoreMode { get; set; }
	}

	public sealed partial class NestedQueryDescriptor<T> : DescriptorBase<NestedQueryDescriptor<T>>
	{
		public NestedQueryDescriptor()
		{
		}

		internal NestedQueryDescriptor(Action<NestedQueryDescriptor<T>> configure) => configure.Invoke(this);
		internal bool? IgnoreUnmappedValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.InnerHits? InnerHitsValue { get; private set; }

		internal string PathValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer QueryValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.NestedScoreMode? ScoreModeValue { get; private set; }

		internal InnerHitsDescriptor<T> InnerHitsDescriptor { get; private set; }

		internal QueryContainerDescriptor<T> QueryDescriptor { get; private set; }

		internal Action<InnerHitsDescriptor<T>> InnerHitsDescriptorAction { get; private set; }

		internal Action<QueryContainerDescriptor<T>> QueryDescriptorAction { get; private set; }

		public NestedQueryDescriptor<T> IgnoreUnmapped(bool? ignoreUnmapped = true) => Assign(ignoreUnmapped, (a, v) => a.IgnoreUnmappedValue = v);
		public NestedQueryDescriptor<T> InnerHits(Elastic.Clients.Elasticsearch.InnerHits? innerHits)
		{
			InnerHitsDescriptor = null;
			InnerHitsDescriptorAction = null;
			return Assign(innerHits, (a, v) => a.InnerHitsValue = v);
		}

		public NestedQueryDescriptor<T> InnerHits(Elastic.Clients.Elasticsearch.InnerHitsDescriptor<T> descriptor)
		{
			InnerHitsValue = null;
			InnerHitsDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.InnerHitsDescriptor = v);
		}

		public NestedQueryDescriptor<T> InnerHits(Action<Elastic.Clients.Elasticsearch.InnerHitsDescriptor<T>> configure)
		{
			InnerHitsValue = null;
			InnerHitsDescriptorAction = null;
			return Assign(configure, (a, v) => a.InnerHitsDescriptorAction = v);
		}

		public NestedQueryDescriptor<T> Path(string path) => Assign(path, (a, v) => a.PathValue = v);
		public NestedQueryDescriptor<T> Query(Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer query)
		{
			QueryDescriptor = null;
			QueryDescriptorAction = null;
			return Assign(query, (a, v) => a.QueryValue = v);
		}

		public NestedQueryDescriptor<T> Query(Elastic.Clients.Elasticsearch.QueryDsl.QueryContainerDescriptor<T> descriptor)
		{
			QueryValue = null;
			QueryDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.QueryDescriptor = v);
		}

		public NestedQueryDescriptor<T> Query(Action<Elastic.Clients.Elasticsearch.QueryDsl.QueryContainerDescriptor<T>> configure)
		{
			QueryValue = null;
			QueryDescriptorAction = null;
			return Assign(configure, (a, v) => a.QueryDescriptorAction = v);
		}

		public NestedQueryDescriptor<T> ScoreMode(Elastic.Clients.Elasticsearch.QueryDsl.NestedScoreMode? scoreMode) => Assign(scoreMode, (a, v) => a.ScoreModeValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (IgnoreUnmappedValue.HasValue)
			{
				writer.WritePropertyName("ignore_unmapped");
				writer.WriteBooleanValue(IgnoreUnmappedValue.Value);
			}

			if (InnerHitsDescriptor is not null)
			{
				writer.WritePropertyName("inner_hits");
				JsonSerializer.Serialize(writer, InnerHitsDescriptor, options);
			}
			else if (InnerHitsDescriptorAction is not null)
			{
				writer.WritePropertyName("inner_hits");
				JsonSerializer.Serialize(writer, new InnerHitsDescriptor<T>(InnerHitsDescriptorAction), options);
			}
			else if (InnerHitsValue is not null)
			{
				writer.WritePropertyName("inner_hits");
				JsonSerializer.Serialize(writer, InnerHitsValue, options);
			}

			writer.WritePropertyName("path");
			JsonSerializer.Serialize(writer, PathValue, options);
			if (QueryDescriptor is not null)
			{
				writer.WritePropertyName("query");
				JsonSerializer.Serialize(writer, QueryDescriptor, options);
			}
			else if (QueryDescriptorAction is not null)
			{
				writer.WritePropertyName("query");
				JsonSerializer.Serialize(writer, new QueryContainerDescriptor<T>(QueryDescriptorAction), options);
			}
			else
			{
				writer.WritePropertyName("query");
				JsonSerializer.Serialize(writer, QueryValue, options);
			}

			if (ScoreModeValue is not null)
			{
				writer.WritePropertyName("score_mode");
				JsonSerializer.Serialize(writer, ScoreModeValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class ParentIdQuery : QueryDsl.QueryBase, IQueryContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "parent_id";
		[JsonInclude]
		[JsonPropertyName("id")]
		public Elastic.Clients.Elasticsearch.Id? Id { get; set; }

		[JsonInclude]
		[JsonPropertyName("ignore_unmapped")]
		public bool? IgnoreUnmapped { get; set; }

		[JsonInclude]
		[JsonPropertyName("type")]
		public string? Type { get; set; }
	}

	public sealed partial class ParentIdQueryDescriptor : DescriptorBase<ParentIdQueryDescriptor>
	{
		public ParentIdQueryDescriptor()
		{
		}

		internal ParentIdQueryDescriptor(Action<ParentIdQueryDescriptor> configure) => configure.Invoke(this);
		internal Elastic.Clients.Elasticsearch.Id? IdValue { get; private set; }

		internal bool? IgnoreUnmappedValue { get; private set; }

		internal string? TypeValue { get; private set; }

		public ParentIdQueryDescriptor Id(Elastic.Clients.Elasticsearch.Id? id) => Assign(id, (a, v) => a.IdValue = v);
		public ParentIdQueryDescriptor IgnoreUnmapped(bool? ignoreUnmapped = true) => Assign(ignoreUnmapped, (a, v) => a.IgnoreUnmappedValue = v);
		public ParentIdQueryDescriptor Type(string? type) => Assign(type, (a, v) => a.TypeValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (IdValue is not null)
			{
				writer.WritePropertyName("id");
				JsonSerializer.Serialize(writer, IdValue, options);
			}

			if (IgnoreUnmappedValue.HasValue)
			{
				writer.WritePropertyName("ignore_unmapped");
				writer.WriteBooleanValue(IgnoreUnmappedValue.Value);
			}

			if (TypeValue is not null)
			{
				writer.WritePropertyName("type");
				JsonSerializer.Serialize(writer, TypeValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class PercolateQuery : QueryDsl.QueryBase, IQueryContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "percolate";
		[JsonInclude]
		[JsonPropertyName("document")]
		public object? Document { get; set; }

		[JsonInclude]
		[JsonPropertyName("documents")]
		public IEnumerable<object>? Documents { get; set; }

		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("id")]
		public Elastic.Clients.Elasticsearch.Id? Id { get; set; }

		[JsonInclude]
		[JsonPropertyName("index")]
		public Elastic.Clients.Elasticsearch.IndexName? Index { get; set; }

		[JsonInclude]
		[JsonPropertyName("name")]
		public string? Name { get; set; }

		[JsonInclude]
		[JsonPropertyName("preference")]
		public string? Preference { get; set; }

		[JsonInclude]
		[JsonPropertyName("routing")]
		public string? Routing { get; set; }

		[JsonInclude]
		[JsonPropertyName("version")]
		public long? Version { get; set; }
	}

	public sealed partial class PercolateQueryDescriptor<T> : DescriptorBase<PercolateQueryDescriptor<T>>
	{
		public PercolateQueryDescriptor()
		{
		}

		internal PercolateQueryDescriptor(Action<PercolateQueryDescriptor<T>> configure) => configure.Invoke(this);
		internal object? DocumentValue { get; private set; }

		internal IEnumerable<object>? DocumentsValue { get; private set; }

		internal string FieldValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Id? IdValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.IndexName? IndexValue { get; private set; }

		internal string? NameValue { get; private set; }

		internal string? PreferenceValue { get; private set; }

		internal string? RoutingValue { get; private set; }

		internal long? VersionValue { get; private set; }

		public PercolateQueryDescriptor<T> Document(object? document) => Assign(document, (a, v) => a.DocumentValue = v);
		public PercolateQueryDescriptor<T> Documents(IEnumerable<object>? documents) => Assign(documents, (a, v) => a.DocumentsValue = v);
		public PercolateQueryDescriptor<T> Field(string field) => Assign(field, (a, v) => a.FieldValue = v);
		public PercolateQueryDescriptor<T> Id(Elastic.Clients.Elasticsearch.Id? id) => Assign(id, (a, v) => a.IdValue = v);
		public PercolateQueryDescriptor<T> Index(Elastic.Clients.Elasticsearch.IndexName? index) => Assign(index, (a, v) => a.IndexValue = v);
		public PercolateQueryDescriptor<T> Name(string? name) => Assign(name, (a, v) => a.NameValue = v);
		public PercolateQueryDescriptor<T> Preference(string? preference) => Assign(preference, (a, v) => a.PreferenceValue = v);
		public PercolateQueryDescriptor<T> Routing(string? routing) => Assign(routing, (a, v) => a.RoutingValue = v);
		public PercolateQueryDescriptor<T> Version(long? version) => Assign(version, (a, v) => a.VersionValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (DocumentsValue is not null)
			{
				writer.WritePropertyName("documents");
				JsonSerializer.Serialize(writer, DocumentsValue, options);
			}

			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, FieldValue, options);
			if (IdValue is not null)
			{
				writer.WritePropertyName("id");
				JsonSerializer.Serialize(writer, IdValue, options);
			}

			if (IndexValue is not null)
			{
				writer.WritePropertyName("index");
				JsonSerializer.Serialize(writer, IndexValue, options);
			}

			if (!string.IsNullOrEmpty(NameValue))
			{
				writer.WritePropertyName("name");
				writer.WriteStringValue(NameValue);
			}

			if (!string.IsNullOrEmpty(PreferenceValue))
			{
				writer.WritePropertyName("preference");
				writer.WriteStringValue(PreferenceValue);
			}

			if (RoutingValue is not null)
			{
				writer.WritePropertyName("routing");
				JsonSerializer.Serialize(writer, RoutingValue, options);
			}

			if (VersionValue is not null)
			{
				writer.WritePropertyName("version");
				JsonSerializer.Serialize(writer, VersionValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public interface IPinnedQueryVariant
	{
		string PinnedQueryVariantName { get; }
	}

	[JsonConverter(typeof(PinnedQueryConverter))]
	public partial class PinnedQuery : QueryDsl.QueryBase, IContainer, IQueryContainerVariant
	{
		public PinnedQuery(IPinnedQueryVariant variant) => Variant = variant ?? throw new ArgumentNullException(nameof(variant));
		internal IPinnedQueryVariant Variant { get; }

		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "pinned";
		[JsonInclude]
		[JsonPropertyName("organic")]
		public Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer Organic { get; set; }
	}

	internal sealed class PinnedQueryConverter : JsonConverter<PinnedQuery>
	{
		public override PinnedQuery Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			reader.Read();
			if (reader.TokenType != JsonTokenType.PropertyName)
			{
				throw new JsonException();
			}

			var propertyName = reader.GetString();
			throw new JsonException();
		}

		public override void Write(Utf8JsonWriter writer, PinnedQuery value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName(value.Variant.PinnedQueryVariantName);
			writer.WriteEndObject();
		}
	}

	public sealed partial class PinnedQueryDescriptor<T> : DescriptorBase<PinnedQueryDescriptor<T>>
	{
		public PinnedQueryDescriptor()
		{
		}

		internal PinnedQueryDescriptor(Action<PinnedQueryDescriptor<T>> configure) => configure.Invoke(this);
		internal bool ContainsVariant { get; private set; }

		internal string ContainedVariantName { get; private set; }

		internal PinnedQuery Container { get; private set; }

		internal object ContainerVariantDescriptorAction { get; private set; }

		private void Set(object descriptorAction, string variantName)
		{
			if (ContainsVariant)
				throw new Exception("TODO");
			ContainerVariantDescriptorAction = descriptorAction;
			ContainedVariantName = variantName;
			ContainsVariant = true;
		}

		private void Set(IPinnedQueryVariant variant, string variantName)
		{
			if (ContainsVariant)
				throw new Exception("TODO");
			Container = new PinnedQuery(variant);
			ContainedVariantName = variantName;
			ContainsVariant = true;
		}

		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			if (!ContainsVariant)
			{
				writer.WriteNullValue();
				return;
			}

			writer.WriteStartObject();
			writer.WritePropertyName(ContainedVariantName);
			writer.WriteStartObject();
			if (Container is not null)
			{
				JsonSerializer.Serialize(writer, Container, options);
				Finalise();
				return;
			}

			writer.WriteEndObject();
			writer.WriteEndObject();
			void Finalise()
			{
				writer.WriteEndObject();
				writer.WriteEndObject();
			}
		}
	}

	public partial class PrefixQuery : FieldNameQueryBase, IQueryContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "prefix";
		[JsonInclude]
		[JsonPropertyName("rewrite")]
		public string? Rewrite { get; set; }

		[JsonInclude]
		[JsonPropertyName("value")]
		public string Value { get; set; }

		[JsonInclude]
		[JsonPropertyName("case_insensitive")]
		public bool? CaseInsensitive { get; set; }
	}

	public sealed partial class PrefixQueryDescriptor : FieldNameQueryDescriptorBase<PrefixQueryDescriptor>
	{
		public PrefixQueryDescriptor()
		{
		}

		internal PrefixQueryDescriptor(Action<PrefixQueryDescriptor> configure) => configure.Invoke(this);
		internal string? RewriteValue { get; private set; }

		internal string ValueValue { get; private set; }

		internal bool? CaseInsensitiveValue { get; private set; }

		public PrefixQueryDescriptor Rewrite(string? rewrite) => Assign(rewrite, (a, v) => a.RewriteValue = v);
		public PrefixQueryDescriptor Value(string value) => Assign(value, (a, v) => a.ValueValue = v);
		public PrefixQueryDescriptor CaseInsensitive(bool? caseInsensitive = true) => Assign(caseInsensitive, (a, v) => a.CaseInsensitiveValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WritePropertyName(settings.Inferrer.Field(_field));
			writer.WriteStartObject();
			if (RewriteValue is not null)
			{
				writer.WritePropertyName("rewrite");
				JsonSerializer.Serialize(writer, RewriteValue, options);
			}

			writer.WritePropertyName("value");
			writer.WriteStringValue(ValueValue);
			if (CaseInsensitiveValue.HasValue)
			{
				writer.WritePropertyName("case_insensitive");
				writer.WriteBooleanValue(CaseInsensitiveValue.Value);
			}

			writer.WriteEndObject();
		}
	}

	public abstract partial class QueryBase
	{
		[JsonInclude]
		[JsonPropertyName("boost")]
		public float? Boost { get; set; }

		[JsonInclude]
		[JsonPropertyName("_name")]
		public string? QueryName { get; set; }
	}

	public sealed partial class QueryBaseDescriptor : DescriptorBase<QueryBaseDescriptor>
	{
		public QueryBaseDescriptor()
		{
		}

		internal QueryBaseDescriptor(Action<QueryBaseDescriptor> configure) => configure.Invoke(this);
		internal float? BoostValue { get; private set; }

		internal string? QueryNameValue { get; private set; }

		public QueryBaseDescriptor Boost(float? boost) => Assign(boost, (a, v) => a.BoostValue = v);
		public QueryBaseDescriptor QueryName(string? queryName) => Assign(queryName, (a, v) => a.QueryNameValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (BoostValue.HasValue)
			{
				writer.WritePropertyName("boost");
				writer.WriteNumberValue(BoostValue.Value);
			}

			if (!string.IsNullOrEmpty(QueryNameValue))
			{
				writer.WritePropertyName("_name");
				writer.WriteStringValue(QueryNameValue);
			}

			writer.WriteEndObject();
		}
	}

	public interface IQueryContainerVariant
	{
		string QueryContainerVariantName { get; }
	}

	[JsonConverter(typeof(QueryContainerConverter))]
	public partial class QueryContainer : IContainer, Aggregations.IAggregationContainerVariant
	{
		public QueryContainer(IQueryContainerVariant variant) => Variant = variant ?? throw new ArgumentNullException(nameof(variant));
		internal IQueryContainerVariant Variant { get; }

		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "filter";
	}

	internal sealed class QueryContainerConverter : JsonConverter<QueryContainer>
	{
		public override QueryContainer Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			reader.Read();
			if (reader.TokenType != JsonTokenType.PropertyName)
			{
				throw new JsonException();
			}

			var propertyName = reader.GetString();
			if (propertyName == "bool")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.BoolQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "boosting")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.BoostingQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "combined_fields")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.CombinedFieldsQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "constant_score")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.ConstantScoreQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "dis_max")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.DisMaxQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "exists")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.ExistsQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "function_score")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.FunctionScoreQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "fuzzy")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.FuzzyQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "geo_bounding_box")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.GeoBoundingBoxQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "geo_distance")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.GeoDistanceQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "geo_polygon")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.GeoPolygonQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "geo_shape")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.GeoShapeQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "has_child")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.HasChildQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "has_parent")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.HasParentQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "ids")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.IdsQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "intervals")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.IntervalsQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "match")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.MatchQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "match_all")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.MatchAllQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "match_bool_prefix")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.MatchBoolPrefixQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "match_none")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.MatchNoneQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "match_phrase")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.MatchPhraseQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "match_phrase_prefix")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.MatchPhrasePrefixQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "more_like_this")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.MoreLikeThisQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "multi_match")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.MultiMatchQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "nested")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.NestedQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "parent_id")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.ParentIdQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "percolate")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.PercolateQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "pinned")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.PinnedQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "prefix")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.PrefixQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "query_string")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.QueryStringQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "rank_feature")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.RankFeatureQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "regexp")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.RegexpQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "script")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.ScriptQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "script_score")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.ScriptScoreQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "shape")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.ShapeQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "simple_query_string")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.SimpleQueryStringQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "span_containing")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.SpanContainingQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "field_masking_span")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.SpanFieldMaskingQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "span_first")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.SpanFirstQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "span_multi")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.SpanMultiTermQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "span_near")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.SpanNearQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "span_not")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.SpanNotQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "span_or")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.SpanOrQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "span_term")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.SpanTermQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "span_within")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.SpanWithinQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "term")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.TermQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "terms")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.TermsQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "terms_set")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.TermsSetQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			if (propertyName == "wildcard")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.WildcardQuery?>(ref reader, options);
				reader.Read();
				return new QueryContainer(variant);
			}

			throw new JsonException();
		}

		public override void Write(Utf8JsonWriter writer, QueryContainer value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName(value.Variant.QueryContainerVariantName);
			switch (value.Variant)
			{
				case Elastic.Clients.Elasticsearch.QueryDsl.BoolQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.BoostingQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.CombinedFieldsQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.ConstantScoreQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.DisMaxQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.ExistsQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.FunctionScoreQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.FuzzyQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.GeoBoundingBoxQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.GeoDistanceQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.GeoPolygonQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.GeoShapeQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.HasChildQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.HasParentQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.IdsQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.IntervalsQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.MatchQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.MatchAllQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.MatchBoolPrefixQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.MatchNoneQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.MatchPhraseQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.MatchPhrasePrefixQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.MoreLikeThisQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.MultiMatchQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.NestedQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.ParentIdQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.PercolateQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.PinnedQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.PrefixQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.QueryStringQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.RankFeatureQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.RegexpQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.ScriptQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.ScriptScoreQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.ShapeQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.SimpleQueryStringQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.SpanContainingQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.SpanFieldMaskingQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.SpanFirstQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.SpanMultiTermQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.SpanNearQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.SpanNotQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.SpanOrQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.SpanTermQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.SpanWithinQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.TermQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.TermsQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.TermsSetQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.WildcardQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
			}

			writer.WriteEndObject();
		}
	}

	public sealed partial class QueryContainerDescriptor<T> : DescriptorBase<QueryContainerDescriptor<T>>
	{
		public QueryContainerDescriptor()
		{
		}

		internal QueryContainerDescriptor(Action<QueryContainerDescriptor<T>> configure) => configure.Invoke(this);
		internal bool ContainsVariant { get; private set; }

		internal string ContainedVariantName { get; private set; }

		internal QueryContainer Container { get; private set; }

		internal object ContainerVariantDescriptorAction { get; private set; }

		private void Set(object descriptorAction, string variantName)
		{
			if (ContainsVariant)
				throw new Exception("TODO");
			ContainerVariantDescriptorAction = descriptorAction;
			ContainedVariantName = variantName;
			ContainsVariant = true;
		}

		private void Set(IQueryContainerVariant variant, string variantName)
		{
			if (ContainsVariant)
				throw new Exception("TODO");
			Container = new QueryContainer(variant);
			ContainedVariantName = variantName;
			ContainsVariant = true;
		}

		public void Bool(BoolQuery variant) => Set(variant, "bool");
		public void Bool(Action<BoolQueryDescriptor<T>> configure) => Set(configure, "bool");
		public void Boosting(BoostingQuery variant) => Set(variant, "boosting");
		public void Boosting(Action<BoostingQueryDescriptor<T>> configure) => Set(configure, "boosting");
		public void CombinedFields(CombinedFieldsQuery variant) => Set(variant, "combined_fields");
		public void CombinedFields(Action<CombinedFieldsQueryDescriptor<T>> configure) => Set(configure, "combined_fields");
		public void ConstantScore(ConstantScoreQuery variant) => Set(variant, "constant_score");
		public void ConstantScore(Action<ConstantScoreQueryDescriptor<T>> configure) => Set(configure, "constant_score");
		public void DisMax(DisMaxQuery variant) => Set(variant, "dis_max");
		public void DisMax(Action<DisMaxQueryDescriptor> configure) => Set(configure, "dis_max");
		public void Exists(ExistsQuery variant) => Set(variant, "exists");
		public void Exists(Action<ExistsQueryDescriptor<T>> configure) => Set(configure, "exists");
		public void FunctionScore(FunctionScoreQuery variant) => Set(variant, "function_score");
		public void FunctionScore(Action<FunctionScoreQueryDescriptor<T>> configure) => Set(configure, "function_score");
		public void Fuzzy(FuzzyQuery variant) => Set(variant, "fuzzy");
		public void Fuzzy(Action<FuzzyQueryDescriptor> configure) => Set(configure, "fuzzy");
		public void GeoBoundingBox(GeoBoundingBoxQuery variant) => Set(variant, "geo_bounding_box");
		public void GeoBoundingBox(Action<GeoBoundingBoxQueryDescriptor> configure) => Set(configure, "geo_bounding_box");
		public void GeoDistance(GeoDistanceQuery variant) => Set(variant, "geo_distance");
		public void GeoDistance(Action<GeoDistanceQueryDescriptor> configure) => Set(configure, "geo_distance");
		public void GeoPolygon(GeoPolygonQuery variant) => Set(variant, "geo_polygon");
		public void GeoPolygon(Action<GeoPolygonQueryDescriptor> configure) => Set(configure, "geo_polygon");
		public void GeoShape(GeoShapeQuery variant) => Set(variant, "geo_shape");
		public void GeoShape(Action<GeoShapeQueryDescriptor> configure) => Set(configure, "geo_shape");
		public void HasChild(HasChildQuery variant) => Set(variant, "has_child");
		public void HasChild(Action<HasChildQueryDescriptor<T>> configure) => Set(configure, "has_child");
		public void HasParent(HasParentQuery variant) => Set(variant, "has_parent");
		public void HasParent(Action<HasParentQueryDescriptor<T>> configure) => Set(configure, "has_parent");
		public void Ids(IdsQuery variant) => Set(variant, "ids");
		public void Ids(Action<IdsQueryDescriptor> configure) => Set(configure, "ids");
		public void Intervals(IntervalsQuery variant) => Set(variant, "intervals");
		public void Intervals(Action<IntervalsQueryDescriptor<T>> configure) => Set(configure, "intervals");
		public void Match(MatchQuery variant) => Set(variant, "match");
		public void Match(Action<MatchQueryDescriptor> configure) => Set(configure, "match");
		public void MatchAll(MatchAllQuery variant) => Set(variant, "match_all");
		public void MatchAll(Action<MatchAllQueryDescriptor> configure) => Set(configure, "match_all");
		public void MatchBoolPrefix(MatchBoolPrefixQuery variant) => Set(variant, "match_bool_prefix");
		public void MatchBoolPrefix(Action<MatchBoolPrefixQueryDescriptor> configure) => Set(configure, "match_bool_prefix");
		public void MatchNone(MatchNoneQuery variant) => Set(variant, "match_none");
		public void MatchNone(Action<MatchNoneQueryDescriptor> configure) => Set(configure, "match_none");
		public void MatchPhrase(MatchPhraseQuery variant) => Set(variant, "match_phrase");
		public void MatchPhrase(Action<MatchPhraseQueryDescriptor> configure) => Set(configure, "match_phrase");
		public void MatchPhrasePrefix(MatchPhrasePrefixQuery variant) => Set(variant, "match_phrase_prefix");
		public void MatchPhrasePrefix(Action<MatchPhrasePrefixQueryDescriptor> configure) => Set(configure, "match_phrase_prefix");
		public void MoreLikeThis(MoreLikeThisQuery variant) => Set(variant, "more_like_this");
		public void MoreLikeThis(Action<MoreLikeThisQueryDescriptor<T>> configure) => Set(configure, "more_like_this");
		public void MultiMatch(MultiMatchQuery variant) => Set(variant, "multi_match");
		public void MultiMatch(Action<MultiMatchQueryDescriptor<T>> configure) => Set(configure, "multi_match");
		public void Nested(NestedQuery variant) => Set(variant, "nested");
		public void Nested(Action<NestedQueryDescriptor<T>> configure) => Set(configure, "nested");
		public void ParentId(ParentIdQuery variant) => Set(variant, "parent_id");
		public void ParentId(Action<ParentIdQueryDescriptor> configure) => Set(configure, "parent_id");
		public void Percolate(PercolateQuery variant) => Set(variant, "percolate");
		public void Percolate(Action<PercolateQueryDescriptor<T>> configure) => Set(configure, "percolate");
		public void Pinned(PinnedQuery variant) => Set(variant, "pinned");
		public void Pinned(Action<PinnedQueryDescriptor<T>> configure) => Set(configure, "pinned");
		public void Prefix(PrefixQuery variant) => Set(variant, "prefix");
		public void Prefix(Action<PrefixQueryDescriptor> configure) => Set(configure, "prefix");
		public void QueryString(QueryStringQuery variant) => Set(variant, "query_string");
		public void QueryString(Action<QueryStringQueryDescriptor<T>> configure) => Set(configure, "query_string");
		public void RankFeature(RankFeatureQuery variant) => Set(variant, "rank_feature");
		public void RankFeature(Action<RankFeatureQueryDescriptor<T>> configure) => Set(configure, "rank_feature");
		public void Regexp(RegexpQuery variant) => Set(variant, "regexp");
		public void Regexp(Action<RegexpQueryDescriptor> configure) => Set(configure, "regexp");
		public void Script(ScriptQuery variant) => Set(variant, "script");
		public void Script(Action<ScriptQueryDescriptor> configure) => Set(configure, "script");
		public void ScriptScore(ScriptScoreQuery variant) => Set(variant, "script_score");
		public void ScriptScore(Action<ScriptScoreQueryDescriptor<T>> configure) => Set(configure, "script_score");
		public void Shape(ShapeQuery variant) => Set(variant, "shape");
		public void Shape(Action<ShapeQueryDescriptor> configure) => Set(configure, "shape");
		public void SimpleQueryString(SimpleQueryStringQuery variant) => Set(variant, "simple_query_string");
		public void SimpleQueryString(Action<SimpleQueryStringQueryDescriptor<T>> configure) => Set(configure, "simple_query_string");
		public void SpanContaining(SpanContainingQuery variant) => Set(variant, "span_containing");
		public void SpanContaining(Action<SpanContainingQueryDescriptor<T>> configure) => Set(configure, "span_containing");
		public void FieldMaskingSpan(SpanFieldMaskingQuery variant) => Set(variant, "field_masking_span");
		public void FieldMaskingSpan(Action<SpanFieldMaskingQueryDescriptor<T>> configure) => Set(configure, "field_masking_span");
		public void SpanFirst(SpanFirstQuery variant) => Set(variant, "span_first");
		public void SpanFirst(Action<SpanFirstQueryDescriptor<T>> configure) => Set(configure, "span_first");
		public void SpanMulti(SpanMultiTermQuery variant) => Set(variant, "span_multi");
		public void SpanMulti(Action<SpanMultiTermQueryDescriptor<T>> configure) => Set(configure, "span_multi");
		public void SpanNear(SpanNearQuery variant) => Set(variant, "span_near");
		public void SpanNear(Action<SpanNearQueryDescriptor> configure) => Set(configure, "span_near");
		public void SpanNot(SpanNotQuery variant) => Set(variant, "span_not");
		public void SpanNot(Action<SpanNotQueryDescriptor<T>> configure) => Set(configure, "span_not");
		public void SpanOr(SpanOrQuery variant) => Set(variant, "span_or");
		public void SpanOr(Action<SpanOrQueryDescriptor> configure) => Set(configure, "span_or");
		public void SpanTerm(SpanTermQuery variant) => Set(variant, "span_term");
		public void SpanTerm(Action<SpanTermQueryDescriptor> configure) => Set(configure, "span_term");
		public void SpanWithin(SpanWithinQuery variant) => Set(variant, "span_within");
		public void SpanWithin(Action<SpanWithinQueryDescriptor<T>> configure) => Set(configure, "span_within");
		public void Term(TermQuery variant) => Set(variant, "term");
		public void Term(Action<TermQueryDescriptor> configure) => Set(configure, "term");
		public void Terms(TermsQuery variant) => Set(variant, "terms");
		public void Terms(Action<TermsQueryDescriptor> configure) => Set(configure, "terms");
		public void TermsSet(TermsSetQuery variant) => Set(variant, "terms_set");
		public void TermsSet(Action<TermsSetQueryDescriptor<T>> configure) => Set(configure, "terms_set");
		public void Wildcard(WildcardQuery variant) => Set(variant, "wildcard");
		public void Wildcard(Action<WildcardQueryDescriptor> configure) => Set(configure, "wildcard");
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			if (!ContainsVariant)
			{
				writer.WriteNullValue();
				return;
			}

			writer.WriteStartObject();
			writer.WritePropertyName(ContainedVariantName);
			writer.WriteStartObject();
			if (Container is not null)
			{
				JsonSerializer.Serialize(writer, Container, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "bool")
			{
				var descriptor = new BoolQueryDescriptor<T>();
				((Action<BoolQueryDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "boosting")
			{
				var descriptor = new BoostingQueryDescriptor<T>();
				((Action<BoostingQueryDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "combined_fields")
			{
				var descriptor = new CombinedFieldsQueryDescriptor<T>();
				((Action<CombinedFieldsQueryDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "constant_score")
			{
				var descriptor = new ConstantScoreQueryDescriptor<T>();
				((Action<ConstantScoreQueryDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "dis_max")
			{
				var descriptor = new DisMaxQueryDescriptor();
				((Action<DisMaxQueryDescriptor>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "exists")
			{
				var descriptor = new ExistsQueryDescriptor<T>();
				((Action<ExistsQueryDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "function_score")
			{
				var descriptor = new FunctionScoreQueryDescriptor<T>();
				((Action<FunctionScoreQueryDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "fuzzy")
			{
				var descriptor = new FuzzyQueryDescriptor();
				((Action<FuzzyQueryDescriptor>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "geo_bounding_box")
			{
				var descriptor = new GeoBoundingBoxQueryDescriptor();
				((Action<GeoBoundingBoxQueryDescriptor>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "geo_distance")
			{
				var descriptor = new GeoDistanceQueryDescriptor();
				((Action<GeoDistanceQueryDescriptor>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "geo_polygon")
			{
				var descriptor = new GeoPolygonQueryDescriptor();
				((Action<GeoPolygonQueryDescriptor>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "geo_shape")
			{
				var descriptor = new GeoShapeQueryDescriptor();
				((Action<GeoShapeQueryDescriptor>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "has_child")
			{
				var descriptor = new HasChildQueryDescriptor<T>();
				((Action<HasChildQueryDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "has_parent")
			{
				var descriptor = new HasParentQueryDescriptor<T>();
				((Action<HasParentQueryDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "ids")
			{
				var descriptor = new IdsQueryDescriptor();
				((Action<IdsQueryDescriptor>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "intervals")
			{
				var descriptor = new IntervalsQueryDescriptor<T>();
				((Action<IntervalsQueryDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "match")
			{
				var descriptor = new MatchQueryDescriptor();
				((Action<MatchQueryDescriptor>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "match_all")
			{
				var descriptor = new MatchAllQueryDescriptor();
				((Action<MatchAllQueryDescriptor>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "match_bool_prefix")
			{
				var descriptor = new MatchBoolPrefixQueryDescriptor();
				((Action<MatchBoolPrefixQueryDescriptor>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "match_none")
			{
				var descriptor = new MatchNoneQueryDescriptor();
				((Action<MatchNoneQueryDescriptor>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "match_phrase")
			{
				var descriptor = new MatchPhraseQueryDescriptor();
				((Action<MatchPhraseQueryDescriptor>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "match_phrase_prefix")
			{
				var descriptor = new MatchPhrasePrefixQueryDescriptor();
				((Action<MatchPhrasePrefixQueryDescriptor>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "more_like_this")
			{
				var descriptor = new MoreLikeThisQueryDescriptor<T>();
				((Action<MoreLikeThisQueryDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "multi_match")
			{
				var descriptor = new MultiMatchQueryDescriptor<T>();
				((Action<MultiMatchQueryDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "nested")
			{
				var descriptor = new NestedQueryDescriptor<T>();
				((Action<NestedQueryDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "parent_id")
			{
				var descriptor = new ParentIdQueryDescriptor();
				((Action<ParentIdQueryDescriptor>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "percolate")
			{
				var descriptor = new PercolateQueryDescriptor<T>();
				((Action<PercolateQueryDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "pinned")
			{
				var descriptor = new PinnedQueryDescriptor<T>();
				((Action<PinnedQueryDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "prefix")
			{
				var descriptor = new PrefixQueryDescriptor();
				((Action<PrefixQueryDescriptor>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "query_string")
			{
				var descriptor = new QueryStringQueryDescriptor<T>();
				((Action<QueryStringQueryDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "rank_feature")
			{
				var descriptor = new RankFeatureQueryDescriptor<T>();
				((Action<RankFeatureQueryDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "regexp")
			{
				var descriptor = new RegexpQueryDescriptor();
				((Action<RegexpQueryDescriptor>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "script")
			{
				var descriptor = new ScriptQueryDescriptor();
				((Action<ScriptQueryDescriptor>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "script_score")
			{
				var descriptor = new ScriptScoreQueryDescriptor<T>();
				((Action<ScriptScoreQueryDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "shape")
			{
				var descriptor = new ShapeQueryDescriptor();
				((Action<ShapeQueryDescriptor>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "simple_query_string")
			{
				var descriptor = new SimpleQueryStringQueryDescriptor<T>();
				((Action<SimpleQueryStringQueryDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "span_containing")
			{
				var descriptor = new SpanContainingQueryDescriptor<T>();
				((Action<SpanContainingQueryDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "field_masking_span")
			{
				var descriptor = new SpanFieldMaskingQueryDescriptor<T>();
				((Action<SpanFieldMaskingQueryDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "span_first")
			{
				var descriptor = new SpanFirstQueryDescriptor<T>();
				((Action<SpanFirstQueryDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "span_multi")
			{
				var descriptor = new SpanMultiTermQueryDescriptor<T>();
				((Action<SpanMultiTermQueryDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "span_near")
			{
				var descriptor = new SpanNearQueryDescriptor();
				((Action<SpanNearQueryDescriptor>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "span_not")
			{
				var descriptor = new SpanNotQueryDescriptor<T>();
				((Action<SpanNotQueryDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "span_or")
			{
				var descriptor = new SpanOrQueryDescriptor();
				((Action<SpanOrQueryDescriptor>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "span_term")
			{
				var descriptor = new SpanTermQueryDescriptor();
				((Action<SpanTermQueryDescriptor>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "span_within")
			{
				var descriptor = new SpanWithinQueryDescriptor<T>();
				((Action<SpanWithinQueryDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "term")
			{
				var descriptor = new TermQueryDescriptor();
				((Action<TermQueryDescriptor>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "terms")
			{
				var descriptor = new TermsQueryDescriptor();
				((Action<TermsQueryDescriptor>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "terms_set")
			{
				var descriptor = new TermsSetQueryDescriptor<T>();
				((Action<TermsSetQueryDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "wildcard")
			{
				var descriptor = new WildcardQueryDescriptor();
				((Action<WildcardQueryDescriptor>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			writer.WriteEndObject();
			writer.WriteEndObject();
			void Finalise()
			{
				writer.WriteEndObject();
				writer.WriteEndObject();
			}
		}
	}

	public partial class QueryStringQuery : QueryDsl.QueryBase, IQueryContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "query_string";
		[JsonInclude]
		[JsonPropertyName("allow_leading_wildcard")]
		public bool? AllowLeadingWildcard { get; set; }

		[JsonInclude]
		[JsonPropertyName("analyzer")]
		public string? Analyzer { get; set; }

		[JsonInclude]
		[JsonPropertyName("analyze_wildcard")]
		public bool? AnalyzeWildcard { get; set; }

		[JsonInclude]
		[JsonPropertyName("auto_generate_synonyms_phrase_query")]
		public bool? AutoGenerateSynonymsPhraseQuery { get; set; }

		[JsonInclude]
		[JsonPropertyName("default_field")]
		public string? DefaultField { get; set; }

		[JsonInclude]
		[JsonPropertyName("default_operator")]
		public Elastic.Clients.Elasticsearch.QueryDsl.Operator? DefaultOperator { get; set; }

		[JsonInclude]
		[JsonPropertyName("enable_position_increments")]
		public bool? EnablePositionIncrements { get; set; }

		[JsonInclude]
		[JsonPropertyName("escape")]
		public bool? Escape { get; set; }

		[JsonInclude]
		[JsonPropertyName("fields")]
		public IEnumerable<string>? Fields { get; set; }

		[JsonInclude]
		[JsonPropertyName("fuzziness")]
		public Elastic.Clients.Elasticsearch.Fuzziness? Fuzziness { get; set; }

		[JsonInclude]
		[JsonPropertyName("fuzzy_max_expansions")]
		public int? FuzzyMaxExpansions { get; set; }

		[JsonInclude]
		[JsonPropertyName("fuzzy_prefix_length")]
		public int? FuzzyPrefixLength { get; set; }

		[JsonInclude]
		[JsonPropertyName("fuzzy_rewrite")]
		public string? FuzzyRewrite { get; set; }

		[JsonInclude]
		[JsonPropertyName("fuzzy_transpositions")]
		public bool? FuzzyTranspositions { get; set; }

		[JsonInclude]
		[JsonPropertyName("lenient")]
		public bool? Lenient { get; set; }

		[JsonInclude]
		[JsonPropertyName("max_determinized_states")]
		public int? MaxDeterminizedStates { get; set; }

		[JsonInclude]
		[JsonPropertyName("minimum_should_match")]
		public Elastic.Clients.Elasticsearch.MinimumShouldMatch? MinimumShouldMatch { get; set; }

		[JsonInclude]
		[JsonPropertyName("phrase_slop")]
		public double? PhraseSlop { get; set; }

		[JsonInclude]
		[JsonPropertyName("query")]
		public string Query { get; set; }

		[JsonInclude]
		[JsonPropertyName("quote_analyzer")]
		public string? QuoteAnalyzer { get; set; }

		[JsonInclude]
		[JsonPropertyName("quote_field_suffix")]
		public string? QuoteFieldSuffix { get; set; }

		[JsonInclude]
		[JsonPropertyName("rewrite")]
		public string? Rewrite { get; set; }

		[JsonInclude]
		[JsonPropertyName("tie_breaker")]
		public double? TieBreaker { get; set; }

		[JsonInclude]
		[JsonPropertyName("time_zone")]
		public string? TimeZone { get; set; }

		[JsonInclude]
		[JsonPropertyName("type")]
		public Elastic.Clients.Elasticsearch.QueryDsl.TextQueryType? Type { get; set; }
	}

	public sealed partial class QueryStringQueryDescriptor<T> : DescriptorBase<QueryStringQueryDescriptor<T>>
	{
		public QueryStringQueryDescriptor()
		{
		}

		internal QueryStringQueryDescriptor(Action<QueryStringQueryDescriptor<T>> configure) => configure.Invoke(this);
		internal bool? AllowLeadingWildcardValue { get; private set; }

		internal string? AnalyzerValue { get; private set; }

		internal bool? AnalyzeWildcardValue { get; private set; }

		internal bool? AutoGenerateSynonymsPhraseQueryValue { get; private set; }

		internal string? DefaultFieldValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.Operator? DefaultOperatorValue { get; private set; }

		internal bool? EnablePositionIncrementsValue { get; private set; }

		internal bool? EscapeValue { get; private set; }

		internal IEnumerable<string>? FieldsValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Fuzziness? FuzzinessValue { get; private set; }

		internal int? FuzzyMaxExpansionsValue { get; private set; }

		internal int? FuzzyPrefixLengthValue { get; private set; }

		internal string? FuzzyRewriteValue { get; private set; }

		internal bool? FuzzyTranspositionsValue { get; private set; }

		internal bool? LenientValue { get; private set; }

		internal int? MaxDeterminizedStatesValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.MinimumShouldMatch? MinimumShouldMatchValue { get; private set; }

		internal double? PhraseSlopValue { get; private set; }

		internal string QueryValue { get; private set; }

		internal string? QuoteAnalyzerValue { get; private set; }

		internal string? QuoteFieldSuffixValue { get; private set; }

		internal string? RewriteValue { get; private set; }

		internal double? TieBreakerValue { get; private set; }

		internal string? TimeZoneValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.TextQueryType? TypeValue { get; private set; }

		public QueryStringQueryDescriptor<T> AllowLeadingWildcard(bool? allowLeadingWildcard = true) => Assign(allowLeadingWildcard, (a, v) => a.AllowLeadingWildcardValue = v);
		public QueryStringQueryDescriptor<T> Analyzer(string? analyzer) => Assign(analyzer, (a, v) => a.AnalyzerValue = v);
		public QueryStringQueryDescriptor<T> AnalyzeWildcard(bool? analyzeWildcard = true) => Assign(analyzeWildcard, (a, v) => a.AnalyzeWildcardValue = v);
		public QueryStringQueryDescriptor<T> AutoGenerateSynonymsPhraseQuery(bool? autoGenerateSynonymsPhraseQuery = true) => Assign(autoGenerateSynonymsPhraseQuery, (a, v) => a.AutoGenerateSynonymsPhraseQueryValue = v);
		public QueryStringQueryDescriptor<T> DefaultField(string? defaultField) => Assign(defaultField, (a, v) => a.DefaultFieldValue = v);
		public QueryStringQueryDescriptor<T> DefaultOperator(Elastic.Clients.Elasticsearch.QueryDsl.Operator? defaultOperator) => Assign(defaultOperator, (a, v) => a.DefaultOperatorValue = v);
		public QueryStringQueryDescriptor<T> EnablePositionIncrements(bool? enablePositionIncrements = true) => Assign(enablePositionIncrements, (a, v) => a.EnablePositionIncrementsValue = v);
		public QueryStringQueryDescriptor<T> Escape(bool? escape = true) => Assign(escape, (a, v) => a.EscapeValue = v);
		public QueryStringQueryDescriptor<T> Fields(IEnumerable<string>? fields) => Assign(fields, (a, v) => a.FieldsValue = v);
		public QueryStringQueryDescriptor<T> Fuzziness(Elastic.Clients.Elasticsearch.Fuzziness? fuzziness) => Assign(fuzziness, (a, v) => a.FuzzinessValue = v);
		public QueryStringQueryDescriptor<T> FuzzyMaxExpansions(int? fuzzyMaxExpansions) => Assign(fuzzyMaxExpansions, (a, v) => a.FuzzyMaxExpansionsValue = v);
		public QueryStringQueryDescriptor<T> FuzzyPrefixLength(int? fuzzyPrefixLength) => Assign(fuzzyPrefixLength, (a, v) => a.FuzzyPrefixLengthValue = v);
		public QueryStringQueryDescriptor<T> FuzzyRewrite(string? fuzzyRewrite) => Assign(fuzzyRewrite, (a, v) => a.FuzzyRewriteValue = v);
		public QueryStringQueryDescriptor<T> FuzzyTranspositions(bool? fuzzyTranspositions = true) => Assign(fuzzyTranspositions, (a, v) => a.FuzzyTranspositionsValue = v);
		public QueryStringQueryDescriptor<T> Lenient(bool? lenient = true) => Assign(lenient, (a, v) => a.LenientValue = v);
		public QueryStringQueryDescriptor<T> MaxDeterminizedStates(int? maxDeterminizedStates) => Assign(maxDeterminizedStates, (a, v) => a.MaxDeterminizedStatesValue = v);
		public QueryStringQueryDescriptor<T> MinimumShouldMatch(Elastic.Clients.Elasticsearch.MinimumShouldMatch? minimumShouldMatch) => Assign(minimumShouldMatch, (a, v) => a.MinimumShouldMatchValue = v);
		public QueryStringQueryDescriptor<T> PhraseSlop(double? phraseSlop) => Assign(phraseSlop, (a, v) => a.PhraseSlopValue = v);
		public QueryStringQueryDescriptor<T> Query(string query) => Assign(query, (a, v) => a.QueryValue = v);
		public QueryStringQueryDescriptor<T> QuoteAnalyzer(string? quoteAnalyzer) => Assign(quoteAnalyzer, (a, v) => a.QuoteAnalyzerValue = v);
		public QueryStringQueryDescriptor<T> QuoteFieldSuffix(string? quoteFieldSuffix) => Assign(quoteFieldSuffix, (a, v) => a.QuoteFieldSuffixValue = v);
		public QueryStringQueryDescriptor<T> Rewrite(string? rewrite) => Assign(rewrite, (a, v) => a.RewriteValue = v);
		public QueryStringQueryDescriptor<T> TieBreaker(double? tieBreaker) => Assign(tieBreaker, (a, v) => a.TieBreakerValue = v);
		public QueryStringQueryDescriptor<T> TimeZone(string? timeZone) => Assign(timeZone, (a, v) => a.TimeZoneValue = v);
		public QueryStringQueryDescriptor<T> Type(Elastic.Clients.Elasticsearch.QueryDsl.TextQueryType? type) => Assign(type, (a, v) => a.TypeValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (AllowLeadingWildcardValue.HasValue)
			{
				writer.WritePropertyName("allow_leading_wildcard");
				writer.WriteBooleanValue(AllowLeadingWildcardValue.Value);
			}

			if (!string.IsNullOrEmpty(AnalyzerValue))
			{
				writer.WritePropertyName("analyzer");
				writer.WriteStringValue(AnalyzerValue);
			}

			if (AnalyzeWildcardValue.HasValue)
			{
				writer.WritePropertyName("analyze_wildcard");
				writer.WriteBooleanValue(AnalyzeWildcardValue.Value);
			}

			if (AutoGenerateSynonymsPhraseQueryValue.HasValue)
			{
				writer.WritePropertyName("auto_generate_synonyms_phrase_query");
				writer.WriteBooleanValue(AutoGenerateSynonymsPhraseQueryValue.Value);
			}

			if (DefaultFieldValue is not null)
			{
				writer.WritePropertyName("default_field");
				JsonSerializer.Serialize(writer, DefaultFieldValue, options);
			}

			if (DefaultOperatorValue is not null)
			{
				writer.WritePropertyName("default_operator");
				JsonSerializer.Serialize(writer, DefaultOperatorValue, options);
			}

			if (EnablePositionIncrementsValue.HasValue)
			{
				writer.WritePropertyName("enable_position_increments");
				writer.WriteBooleanValue(EnablePositionIncrementsValue.Value);
			}

			if (EscapeValue.HasValue)
			{
				writer.WritePropertyName("escape");
				writer.WriteBooleanValue(EscapeValue.Value);
			}

			if (FieldsValue is not null)
			{
				writer.WritePropertyName("fields");
				JsonSerializer.Serialize(writer, FieldsValue, options);
			}

			if (FuzzinessValue is not null)
			{
				writer.WritePropertyName("fuzziness");
				JsonSerializer.Serialize(writer, FuzzinessValue, options);
			}

			if (FuzzyMaxExpansionsValue.HasValue)
			{
				writer.WritePropertyName("fuzzy_max_expansions");
				writer.WriteNumberValue(FuzzyMaxExpansionsValue.Value);
			}

			if (FuzzyPrefixLengthValue.HasValue)
			{
				writer.WritePropertyName("fuzzy_prefix_length");
				writer.WriteNumberValue(FuzzyPrefixLengthValue.Value);
			}

			if (FuzzyRewriteValue is not null)
			{
				writer.WritePropertyName("fuzzy_rewrite");
				JsonSerializer.Serialize(writer, FuzzyRewriteValue, options);
			}

			if (FuzzyTranspositionsValue.HasValue)
			{
				writer.WritePropertyName("fuzzy_transpositions");
				writer.WriteBooleanValue(FuzzyTranspositionsValue.Value);
			}

			if (LenientValue.HasValue)
			{
				writer.WritePropertyName("lenient");
				writer.WriteBooleanValue(LenientValue.Value);
			}

			if (MaxDeterminizedStatesValue.HasValue)
			{
				writer.WritePropertyName("max_determinized_states");
				writer.WriteNumberValue(MaxDeterminizedStatesValue.Value);
			}

			if (MinimumShouldMatchValue is not null)
			{
				writer.WritePropertyName("minimum_should_match");
				JsonSerializer.Serialize(writer, MinimumShouldMatchValue, options);
			}

			if (PhraseSlopValue.HasValue)
			{
				writer.WritePropertyName("phrase_slop");
				writer.WriteNumberValue(PhraseSlopValue.Value);
			}

			writer.WritePropertyName("query");
			writer.WriteStringValue(QueryValue);
			if (!string.IsNullOrEmpty(QuoteAnalyzerValue))
			{
				writer.WritePropertyName("quote_analyzer");
				writer.WriteStringValue(QuoteAnalyzerValue);
			}

			if (!string.IsNullOrEmpty(QuoteFieldSuffixValue))
			{
				writer.WritePropertyName("quote_field_suffix");
				writer.WriteStringValue(QuoteFieldSuffixValue);
			}

			if (RewriteValue is not null)
			{
				writer.WritePropertyName("rewrite");
				JsonSerializer.Serialize(writer, RewriteValue, options);
			}

			if (TieBreakerValue.HasValue)
			{
				writer.WritePropertyName("tie_breaker");
				writer.WriteNumberValue(TieBreakerValue.Value);
			}

			if (TimeZoneValue is not null)
			{
				writer.WritePropertyName("time_zone");
				JsonSerializer.Serialize(writer, TimeZoneValue, options);
			}

			if (TypeValue is not null)
			{
				writer.WritePropertyName("type");
				JsonSerializer.Serialize(writer, TypeValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class RandomScoreFunction : QueryDsl.ScoreFunctionBase, IFunctionScoreContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IFunctionScoreContainerVariant.FunctionScoreContainerVariantName => "random_score";
		[JsonInclude]
		[JsonPropertyName("field")]
		public string? Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("seed")]
		public Union<long?, string?>? Seed { get; set; }
	}

	public sealed partial class RandomScoreFunctionDescriptor<T> : DescriptorBase<RandomScoreFunctionDescriptor<T>>
	{
		public RandomScoreFunctionDescriptor()
		{
		}

		internal RandomScoreFunctionDescriptor(Action<RandomScoreFunctionDescriptor<T>> configure) => configure.Invoke(this);
		internal string? FieldValue { get; private set; }

		internal Union<long?, string?>? SeedValue { get; private set; }

		public RandomScoreFunctionDescriptor<T> Field(string? field) => Assign(field, (a, v) => a.FieldValue = v);
		public RandomScoreFunctionDescriptor<T> Seed(Union<long?, string?>? seed) => Assign(seed, (a, v) => a.SeedValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (FieldValue is not null)
			{
				writer.WritePropertyName("field");
				JsonSerializer.Serialize(writer, FieldValue, options);
			}

			if (SeedValue is not null)
			{
				writer.WritePropertyName("seed");
				JsonSerializer.Serialize(writer, SeedValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class RankFeatureFunction
	{
	}

	public sealed partial class RankFeatureFunctionDescriptor : DescriptorBase<RankFeatureFunctionDescriptor>
	{
		public RankFeatureFunctionDescriptor()
		{
		}

		internal RankFeatureFunctionDescriptor(Action<RankFeatureFunctionDescriptor> configure) => configure.Invoke(this);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WriteEndObject();
		}
	}

	public partial class RankFeatureFunctionLinear : QueryDsl.RankFeatureFunction
	{
	}

	public sealed partial class RankFeatureFunctionLinearDescriptor : DescriptorBase<RankFeatureFunctionLinearDescriptor>
	{
		public RankFeatureFunctionLinearDescriptor()
		{
		}

		internal RankFeatureFunctionLinearDescriptor(Action<RankFeatureFunctionLinearDescriptor> configure) => configure.Invoke(this);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WriteEndObject();
		}
	}

	public partial class RankFeatureFunctionLogarithm : QueryDsl.RankFeatureFunction
	{
		[JsonInclude]
		[JsonPropertyName("scaling_factor")]
		public float ScalingFactor { get; set; }
	}

	public sealed partial class RankFeatureFunctionLogarithmDescriptor : DescriptorBase<RankFeatureFunctionLogarithmDescriptor>
	{
		public RankFeatureFunctionLogarithmDescriptor()
		{
		}

		internal RankFeatureFunctionLogarithmDescriptor(Action<RankFeatureFunctionLogarithmDescriptor> configure) => configure.Invoke(this);
		internal float ScalingFactorValue { get; private set; }

		public RankFeatureFunctionLogarithmDescriptor ScalingFactor(float scalingFactor) => Assign(scalingFactor, (a, v) => a.ScalingFactorValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("scaling_factor");
			writer.WriteNumberValue(ScalingFactorValue);
			writer.WriteEndObject();
		}
	}

	public partial class RankFeatureFunctionSaturation : QueryDsl.RankFeatureFunction
	{
		[JsonInclude]
		[JsonPropertyName("pivot")]
		public float? Pivot { get; set; }
	}

	public sealed partial class RankFeatureFunctionSaturationDescriptor : DescriptorBase<RankFeatureFunctionSaturationDescriptor>
	{
		public RankFeatureFunctionSaturationDescriptor()
		{
		}

		internal RankFeatureFunctionSaturationDescriptor(Action<RankFeatureFunctionSaturationDescriptor> configure) => configure.Invoke(this);
		internal float? PivotValue { get; private set; }

		public RankFeatureFunctionSaturationDescriptor Pivot(float? pivot) => Assign(pivot, (a, v) => a.PivotValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (PivotValue.HasValue)
			{
				writer.WritePropertyName("pivot");
				writer.WriteNumberValue(PivotValue.Value);
			}

			writer.WriteEndObject();
		}
	}

	public partial class RankFeatureFunctionSigmoid : QueryDsl.RankFeatureFunction
	{
		[JsonInclude]
		[JsonPropertyName("pivot")]
		public float Pivot { get; set; }

		[JsonInclude]
		[JsonPropertyName("exponent")]
		public float Exponent { get; set; }
	}

	public sealed partial class RankFeatureFunctionSigmoidDescriptor : DescriptorBase<RankFeatureFunctionSigmoidDescriptor>
	{
		public RankFeatureFunctionSigmoidDescriptor()
		{
		}

		internal RankFeatureFunctionSigmoidDescriptor(Action<RankFeatureFunctionSigmoidDescriptor> configure) => configure.Invoke(this);
		internal float PivotValue { get; private set; }

		internal float ExponentValue { get; private set; }

		public RankFeatureFunctionSigmoidDescriptor Pivot(float pivot) => Assign(pivot, (a, v) => a.PivotValue = v);
		public RankFeatureFunctionSigmoidDescriptor Exponent(float exponent) => Assign(exponent, (a, v) => a.ExponentValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("pivot");
			writer.WriteNumberValue(PivotValue);
			writer.WritePropertyName("exponent");
			writer.WriteNumberValue(ExponentValue);
			writer.WriteEndObject();
		}
	}

	public partial class RankFeatureQuery : QueryDsl.QueryBase, IQueryContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "rank_feature";
		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("saturation")]
		public Elastic.Clients.Elasticsearch.QueryDsl.RankFeatureFunctionSaturation? Saturation { get; set; }

		[JsonInclude]
		[JsonPropertyName("log")]
		public Elastic.Clients.Elasticsearch.QueryDsl.RankFeatureFunctionLogarithm? Log { get; set; }

		[JsonInclude]
		[JsonPropertyName("linear")]
		public Elastic.Clients.Elasticsearch.QueryDsl.RankFeatureFunctionLinear? Linear { get; set; }

		[JsonInclude]
		[JsonPropertyName("sigmoid")]
		public Elastic.Clients.Elasticsearch.QueryDsl.RankFeatureFunctionSigmoid? Sigmoid { get; set; }
	}

	public sealed partial class RankFeatureQueryDescriptor<T> : DescriptorBase<RankFeatureQueryDescriptor<T>>
	{
		public RankFeatureQueryDescriptor()
		{
		}

		internal RankFeatureQueryDescriptor(Action<RankFeatureQueryDescriptor<T>> configure) => configure.Invoke(this);
		internal string FieldValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.RankFeatureFunctionSaturation? SaturationValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.RankFeatureFunctionLogarithm? LogValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.RankFeatureFunctionLinear? LinearValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.RankFeatureFunctionSigmoid? SigmoidValue { get; private set; }

		internal RankFeatureFunctionSaturationDescriptor SaturationDescriptor { get; private set; }

		internal RankFeatureFunctionLogarithmDescriptor LogDescriptor { get; private set; }

		internal RankFeatureFunctionLinearDescriptor LinearDescriptor { get; private set; }

		internal RankFeatureFunctionSigmoidDescriptor SigmoidDescriptor { get; private set; }

		internal Action<RankFeatureFunctionSaturationDescriptor> SaturationDescriptorAction { get; private set; }

		internal Action<RankFeatureFunctionLogarithmDescriptor> LogDescriptorAction { get; private set; }

		internal Action<RankFeatureFunctionLinearDescriptor> LinearDescriptorAction { get; private set; }

		internal Action<RankFeatureFunctionSigmoidDescriptor> SigmoidDescriptorAction { get; private set; }

		public RankFeatureQueryDescriptor<T> Field(string field) => Assign(field, (a, v) => a.FieldValue = v);
		public RankFeatureQueryDescriptor<T> Saturation(Elastic.Clients.Elasticsearch.QueryDsl.RankFeatureFunctionSaturation? saturation)
		{
			SaturationDescriptor = null;
			SaturationDescriptorAction = null;
			return Assign(saturation, (a, v) => a.SaturationValue = v);
		}

		public RankFeatureQueryDescriptor<T> Saturation(Elastic.Clients.Elasticsearch.QueryDsl.RankFeatureFunctionSaturationDescriptor descriptor)
		{
			SaturationValue = null;
			SaturationDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.SaturationDescriptor = v);
		}

		public RankFeatureQueryDescriptor<T> Saturation(Action<Elastic.Clients.Elasticsearch.QueryDsl.RankFeatureFunctionSaturationDescriptor> configure)
		{
			SaturationValue = null;
			SaturationDescriptorAction = null;
			return Assign(configure, (a, v) => a.SaturationDescriptorAction = v);
		}

		public RankFeatureQueryDescriptor<T> Log(Elastic.Clients.Elasticsearch.QueryDsl.RankFeatureFunctionLogarithm? log)
		{
			LogDescriptor = null;
			LogDescriptorAction = null;
			return Assign(log, (a, v) => a.LogValue = v);
		}

		public RankFeatureQueryDescriptor<T> Log(Elastic.Clients.Elasticsearch.QueryDsl.RankFeatureFunctionLogarithmDescriptor descriptor)
		{
			LogValue = null;
			LogDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.LogDescriptor = v);
		}

		public RankFeatureQueryDescriptor<T> Log(Action<Elastic.Clients.Elasticsearch.QueryDsl.RankFeatureFunctionLogarithmDescriptor> configure)
		{
			LogValue = null;
			LogDescriptorAction = null;
			return Assign(configure, (a, v) => a.LogDescriptorAction = v);
		}

		public RankFeatureQueryDescriptor<T> Linear(Elastic.Clients.Elasticsearch.QueryDsl.RankFeatureFunctionLinear? linear)
		{
			LinearDescriptor = null;
			LinearDescriptorAction = null;
			return Assign(linear, (a, v) => a.LinearValue = v);
		}

		public RankFeatureQueryDescriptor<T> Linear(Elastic.Clients.Elasticsearch.QueryDsl.RankFeatureFunctionLinearDescriptor descriptor)
		{
			LinearValue = null;
			LinearDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.LinearDescriptor = v);
		}

		public RankFeatureQueryDescriptor<T> Linear(Action<Elastic.Clients.Elasticsearch.QueryDsl.RankFeatureFunctionLinearDescriptor> configure)
		{
			LinearValue = null;
			LinearDescriptorAction = null;
			return Assign(configure, (a, v) => a.LinearDescriptorAction = v);
		}

		public RankFeatureQueryDescriptor<T> Sigmoid(Elastic.Clients.Elasticsearch.QueryDsl.RankFeatureFunctionSigmoid? sigmoid)
		{
			SigmoidDescriptor = null;
			SigmoidDescriptorAction = null;
			return Assign(sigmoid, (a, v) => a.SigmoidValue = v);
		}

		public RankFeatureQueryDescriptor<T> Sigmoid(Elastic.Clients.Elasticsearch.QueryDsl.RankFeatureFunctionSigmoidDescriptor descriptor)
		{
			SigmoidValue = null;
			SigmoidDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.SigmoidDescriptor = v);
		}

		public RankFeatureQueryDescriptor<T> Sigmoid(Action<Elastic.Clients.Elasticsearch.QueryDsl.RankFeatureFunctionSigmoidDescriptor> configure)
		{
			SigmoidValue = null;
			SigmoidDescriptorAction = null;
			return Assign(configure, (a, v) => a.SigmoidDescriptorAction = v);
		}

		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, FieldValue, options);
			if (SaturationDescriptor is not null)
			{
				writer.WritePropertyName("saturation");
				JsonSerializer.Serialize(writer, SaturationDescriptor, options);
			}
			else if (SaturationDescriptorAction is not null)
			{
				writer.WritePropertyName("saturation");
				JsonSerializer.Serialize(writer, new RankFeatureFunctionSaturationDescriptor(SaturationDescriptorAction), options);
			}
			else if (SaturationValue is not null)
			{
				writer.WritePropertyName("saturation");
				JsonSerializer.Serialize(writer, SaturationValue, options);
			}

			if (LogDescriptor is not null)
			{
				writer.WritePropertyName("log");
				JsonSerializer.Serialize(writer, LogDescriptor, options);
			}
			else if (LogDescriptorAction is not null)
			{
				writer.WritePropertyName("log");
				JsonSerializer.Serialize(writer, new RankFeatureFunctionLogarithmDescriptor(LogDescriptorAction), options);
			}
			else if (LogValue is not null)
			{
				writer.WritePropertyName("log");
				JsonSerializer.Serialize(writer, LogValue, options);
			}

			if (LinearDescriptor is not null)
			{
				writer.WritePropertyName("linear");
				JsonSerializer.Serialize(writer, LinearDescriptor, options);
			}
			else if (LinearDescriptorAction is not null)
			{
				writer.WritePropertyName("linear");
				JsonSerializer.Serialize(writer, new RankFeatureFunctionLinearDescriptor(LinearDescriptorAction), options);
			}
			else if (LinearValue is not null)
			{
				writer.WritePropertyName("linear");
				JsonSerializer.Serialize(writer, LinearValue, options);
			}

			if (SigmoidDescriptor is not null)
			{
				writer.WritePropertyName("sigmoid");
				JsonSerializer.Serialize(writer, SigmoidDescriptor, options);
			}
			else if (SigmoidDescriptorAction is not null)
			{
				writer.WritePropertyName("sigmoid");
				JsonSerializer.Serialize(writer, new RankFeatureFunctionSigmoidDescriptor(SigmoidDescriptorAction), options);
			}
			else if (SigmoidValue is not null)
			{
				writer.WritePropertyName("sigmoid");
				JsonSerializer.Serialize(writer, SigmoidValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class RegexpQuery : FieldNameQueryBase, IQueryContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "regexp";
		[JsonInclude]
		[JsonPropertyName("case_insensitive")]
		public bool? CaseInsensitive { get; set; }

		[JsonInclude]
		[JsonPropertyName("flags")]
		public string? Flags { get; set; }

		[JsonInclude]
		[JsonPropertyName("max_determinized_states")]
		public int? MaxDeterminizedStates { get; set; }

		[JsonInclude]
		[JsonPropertyName("rewrite")]
		public string? Rewrite { get; set; }

		[JsonInclude]
		[JsonPropertyName("value")]
		public string Value { get; set; }
	}

	public sealed partial class RegexpQueryDescriptor : FieldNameQueryDescriptorBase<RegexpQueryDescriptor>
	{
		public RegexpQueryDescriptor()
		{
		}

		internal RegexpQueryDescriptor(Action<RegexpQueryDescriptor> configure) => configure.Invoke(this);
		internal bool? CaseInsensitiveValue { get; private set; }

		internal string? FlagsValue { get; private set; }

		internal int? MaxDeterminizedStatesValue { get; private set; }

		internal string? RewriteValue { get; private set; }

		internal string ValueValue { get; private set; }

		public RegexpQueryDescriptor CaseInsensitive(bool? caseInsensitive = true) => Assign(caseInsensitive, (a, v) => a.CaseInsensitiveValue = v);
		public RegexpQueryDescriptor Flags(string? flags) => Assign(flags, (a, v) => a.FlagsValue = v);
		public RegexpQueryDescriptor MaxDeterminizedStates(int? maxDeterminizedStates) => Assign(maxDeterminizedStates, (a, v) => a.MaxDeterminizedStatesValue = v);
		public RegexpQueryDescriptor Rewrite(string? rewrite) => Assign(rewrite, (a, v) => a.RewriteValue = v);
		public RegexpQueryDescriptor Value(string value) => Assign(value, (a, v) => a.ValueValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WritePropertyName(settings.Inferrer.Field(_field));
			writer.WriteStartObject();
			if (CaseInsensitiveValue.HasValue)
			{
				writer.WritePropertyName("case_insensitive");
				writer.WriteBooleanValue(CaseInsensitiveValue.Value);
			}

			if (!string.IsNullOrEmpty(FlagsValue))
			{
				writer.WritePropertyName("flags");
				writer.WriteStringValue(FlagsValue);
			}

			if (MaxDeterminizedStatesValue.HasValue)
			{
				writer.WritePropertyName("max_determinized_states");
				writer.WriteNumberValue(MaxDeterminizedStatesValue.Value);
			}

			if (RewriteValue is not null)
			{
				writer.WritePropertyName("rewrite");
				JsonSerializer.Serialize(writer, RewriteValue, options);
			}

			writer.WritePropertyName("value");
			writer.WriteStringValue(ValueValue);
			writer.WriteEndObject();
		}
	}

	public abstract partial class ScoreFunctionBase
	{
		[JsonInclude]
		[JsonPropertyName("filter")]
		public Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? Filter { get; set; }

		[JsonInclude]
		[JsonPropertyName("weight")]
		public double? Weight { get; set; }
	}

	public sealed partial class ScoreFunctionBaseDescriptor<T> : DescriptorBase<ScoreFunctionBaseDescriptor<T>>
	{
		public ScoreFunctionBaseDescriptor()
		{
		}

		internal ScoreFunctionBaseDescriptor(Action<ScoreFunctionBaseDescriptor<T>> configure) => configure.Invoke(this);
		internal Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? FilterValue { get; private set; }

		internal double? WeightValue { get; private set; }

		internal QueryContainerDescriptor<T> FilterDescriptor { get; private set; }

		internal Action<QueryContainerDescriptor<T>> FilterDescriptorAction { get; private set; }

		public ScoreFunctionBaseDescriptor<T> Filter(Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? filter)
		{
			FilterDescriptor = null;
			FilterDescriptorAction = null;
			return Assign(filter, (a, v) => a.FilterValue = v);
		}

		public ScoreFunctionBaseDescriptor<T> Filter(Elastic.Clients.Elasticsearch.QueryDsl.QueryContainerDescriptor<T> descriptor)
		{
			FilterValue = null;
			FilterDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.FilterDescriptor = v);
		}

		public ScoreFunctionBaseDescriptor<T> Filter(Action<Elastic.Clients.Elasticsearch.QueryDsl.QueryContainerDescriptor<T>> configure)
		{
			FilterValue = null;
			FilterDescriptorAction = null;
			return Assign(configure, (a, v) => a.FilterDescriptorAction = v);
		}

		public ScoreFunctionBaseDescriptor<T> Weight(double? weight) => Assign(weight, (a, v) => a.WeightValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (FilterDescriptor is not null)
			{
				writer.WritePropertyName("filter");
				JsonSerializer.Serialize(writer, FilterDescriptor, options);
			}
			else if (FilterDescriptorAction is not null)
			{
				writer.WritePropertyName("filter");
				JsonSerializer.Serialize(writer, new QueryContainerDescriptor<T>(FilterDescriptorAction), options);
			}
			else if (FilterValue is not null)
			{
				writer.WritePropertyName("filter");
				JsonSerializer.Serialize(writer, FilterValue, options);
			}

			if (WeightValue.HasValue)
			{
				writer.WritePropertyName("weight");
				writer.WriteNumberValue(WeightValue.Value);
			}

			writer.WriteEndObject();
		}
	}

	public partial class ScriptQuery : QueryDsl.QueryBase, IQueryContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "script";
		[JsonInclude]
		[JsonPropertyName("script")]
		public Elastic.Clients.Elasticsearch.Script Script { get; set; }
	}

	public sealed partial class ScriptQueryDescriptor : DescriptorBase<ScriptQueryDescriptor>
	{
		public ScriptQueryDescriptor()
		{
		}

		internal ScriptQueryDescriptor(Action<ScriptQueryDescriptor> configure) => configure.Invoke(this);
		internal Elastic.Clients.Elasticsearch.Script ScriptValue { get; private set; }

		public ScriptQueryDescriptor Script(Elastic.Clients.Elasticsearch.Script script) => Assign(script, (a, v) => a.ScriptValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("script");
			JsonSerializer.Serialize(writer, ScriptValue, options);
			writer.WriteEndObject();
		}
	}

	public partial class ScriptScoreFunction : QueryDsl.ScoreFunctionBase, IFunctionScoreContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IFunctionScoreContainerVariant.FunctionScoreContainerVariantName => "script_score";
		[JsonInclude]
		[JsonPropertyName("script")]
		public Elastic.Clients.Elasticsearch.Script Script { get; set; }
	}

	public sealed partial class ScriptScoreFunctionDescriptor : DescriptorBase<ScriptScoreFunctionDescriptor>
	{
		public ScriptScoreFunctionDescriptor()
		{
		}

		internal ScriptScoreFunctionDescriptor(Action<ScriptScoreFunctionDescriptor> configure) => configure.Invoke(this);
		internal Elastic.Clients.Elasticsearch.Script ScriptValue { get; private set; }

		public ScriptScoreFunctionDescriptor Script(Elastic.Clients.Elasticsearch.Script script) => Assign(script, (a, v) => a.ScriptValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("script");
			JsonSerializer.Serialize(writer, ScriptValue, options);
			writer.WriteEndObject();
		}
	}

	public partial class ScriptScoreQuery : QueryDsl.QueryBase, IQueryContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "script_score";
		[JsonInclude]
		[JsonPropertyName("min_score")]
		public float? MinScore { get; set; }

		[JsonInclude]
		[JsonPropertyName("query")]
		public Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer Query { get; set; }

		[JsonInclude]
		[JsonPropertyName("script")]
		public Elastic.Clients.Elasticsearch.Script Script { get; set; }
	}

	public sealed partial class ScriptScoreQueryDescriptor<T> : DescriptorBase<ScriptScoreQueryDescriptor<T>>
	{
		public ScriptScoreQueryDescriptor()
		{
		}

		internal ScriptScoreQueryDescriptor(Action<ScriptScoreQueryDescriptor<T>> configure) => configure.Invoke(this);
		internal float? MinScoreValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer QueryValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Script ScriptValue { get; private set; }

		internal QueryContainerDescriptor<T> QueryDescriptor { get; private set; }

		internal Action<QueryContainerDescriptor<T>> QueryDescriptorAction { get; private set; }

		public ScriptScoreQueryDescriptor<T> MinScore(float? minScore) => Assign(minScore, (a, v) => a.MinScoreValue = v);
		public ScriptScoreQueryDescriptor<T> Query(Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer query)
		{
			QueryDescriptor = null;
			QueryDescriptorAction = null;
			return Assign(query, (a, v) => a.QueryValue = v);
		}

		public ScriptScoreQueryDescriptor<T> Query(Elastic.Clients.Elasticsearch.QueryDsl.QueryContainerDescriptor<T> descriptor)
		{
			QueryValue = null;
			QueryDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.QueryDescriptor = v);
		}

		public ScriptScoreQueryDescriptor<T> Query(Action<Elastic.Clients.Elasticsearch.QueryDsl.QueryContainerDescriptor<T>> configure)
		{
			QueryValue = null;
			QueryDescriptorAction = null;
			return Assign(configure, (a, v) => a.QueryDescriptorAction = v);
		}

		public ScriptScoreQueryDescriptor<T> Script(Elastic.Clients.Elasticsearch.Script script) => Assign(script, (a, v) => a.ScriptValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (MinScoreValue.HasValue)
			{
				writer.WritePropertyName("min_score");
				writer.WriteNumberValue(MinScoreValue.Value);
			}

			if (QueryDescriptor is not null)
			{
				writer.WritePropertyName("query");
				JsonSerializer.Serialize(writer, QueryDescriptor, options);
			}
			else if (QueryDescriptorAction is not null)
			{
				writer.WritePropertyName("query");
				JsonSerializer.Serialize(writer, new QueryContainerDescriptor<T>(QueryDescriptorAction), options);
			}
			else
			{
				writer.WritePropertyName("query");
				JsonSerializer.Serialize(writer, QueryValue, options);
			}

			writer.WritePropertyName("script");
			JsonSerializer.Serialize(writer, ScriptValue, options);
			writer.WriteEndObject();
		}
	}

	public partial class ShapeQuery : QueryDsl.QueryBase, IQueryContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "shape";
		[JsonInclude]
		[JsonPropertyName("ignore_unmapped")]
		public bool? IgnoreUnmapped { get; set; }
	}

	public sealed partial class ShapeQueryDescriptor : DescriptorBase<ShapeQueryDescriptor>
	{
		public ShapeQueryDescriptor()
		{
		}

		internal ShapeQueryDescriptor(Action<ShapeQueryDescriptor> configure) => configure.Invoke(this);
		internal bool? IgnoreUnmappedValue { get; private set; }

		public ShapeQueryDescriptor IgnoreUnmapped(bool? ignoreUnmapped = true) => Assign(ignoreUnmapped, (a, v) => a.IgnoreUnmappedValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (IgnoreUnmappedValue.HasValue)
			{
				writer.WritePropertyName("ignore_unmapped");
				writer.WriteBooleanValue(IgnoreUnmappedValue.Value);
			}

			writer.WriteEndObject();
		}
	}

	public partial class SimpleQueryStringQuery : QueryDsl.QueryBase, IQueryContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "simple_query_string";
		[JsonInclude]
		[JsonPropertyName("analyzer")]
		public string? Analyzer { get; set; }

		[JsonInclude]
		[JsonPropertyName("analyze_wildcard")]
		public bool? AnalyzeWildcard { get; set; }

		[JsonInclude]
		[JsonPropertyName("auto_generate_synonyms_phrase_query")]
		public bool? AutoGenerateSynonymsPhraseQuery { get; set; }

		[JsonInclude]
		[JsonPropertyName("default_operator")]
		public Elastic.Clients.Elasticsearch.QueryDsl.Operator? DefaultOperator { get; set; }

		[JsonInclude]
		[JsonPropertyName("fields")]
		public IEnumerable<string>? Fields { get; set; }

		[JsonInclude]
		[JsonPropertyName("flags")]
		public Elastic.Clients.Elasticsearch.QueryDsl.SimpleQueryStringFlags? Flags { get; set; }

		[JsonInclude]
		[JsonPropertyName("fuzzy_max_expansions")]
		public int? FuzzyMaxExpansions { get; set; }

		[JsonInclude]
		[JsonPropertyName("fuzzy_prefix_length")]
		public int? FuzzyPrefixLength { get; set; }

		[JsonInclude]
		[JsonPropertyName("fuzzy_transpositions")]
		public bool? FuzzyTranspositions { get; set; }

		[JsonInclude]
		[JsonPropertyName("lenient")]
		public bool? Lenient { get; set; }

		[JsonInclude]
		[JsonPropertyName("minimum_should_match")]
		public Elastic.Clients.Elasticsearch.MinimumShouldMatch? MinimumShouldMatch { get; set; }

		[JsonInclude]
		[JsonPropertyName("query")]
		public string Query { get; set; }

		[JsonInclude]
		[JsonPropertyName("quote_field_suffix")]
		public string? QuoteFieldSuffix { get; set; }
	}

	public sealed partial class SimpleQueryStringQueryDescriptor<T> : DescriptorBase<SimpleQueryStringQueryDescriptor<T>>
	{
		public SimpleQueryStringQueryDescriptor()
		{
		}

		internal SimpleQueryStringQueryDescriptor(Action<SimpleQueryStringQueryDescriptor<T>> configure) => configure.Invoke(this);
		internal string? AnalyzerValue { get; private set; }

		internal bool? AnalyzeWildcardValue { get; private set; }

		internal bool? AutoGenerateSynonymsPhraseQueryValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.Operator? DefaultOperatorValue { get; private set; }

		internal IEnumerable<string>? FieldsValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.SimpleQueryStringFlags? FlagsValue { get; private set; }

		internal int? FuzzyMaxExpansionsValue { get; private set; }

		internal int? FuzzyPrefixLengthValue { get; private set; }

		internal bool? FuzzyTranspositionsValue { get; private set; }

		internal bool? LenientValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.MinimumShouldMatch? MinimumShouldMatchValue { get; private set; }

		internal string QueryValue { get; private set; }

		internal string? QuoteFieldSuffixValue { get; private set; }

		public SimpleQueryStringQueryDescriptor<T> Analyzer(string? analyzer) => Assign(analyzer, (a, v) => a.AnalyzerValue = v);
		public SimpleQueryStringQueryDescriptor<T> AnalyzeWildcard(bool? analyzeWildcard = true) => Assign(analyzeWildcard, (a, v) => a.AnalyzeWildcardValue = v);
		public SimpleQueryStringQueryDescriptor<T> AutoGenerateSynonymsPhraseQuery(bool? autoGenerateSynonymsPhraseQuery = true) => Assign(autoGenerateSynonymsPhraseQuery, (a, v) => a.AutoGenerateSynonymsPhraseQueryValue = v);
		public SimpleQueryStringQueryDescriptor<T> DefaultOperator(Elastic.Clients.Elasticsearch.QueryDsl.Operator? defaultOperator) => Assign(defaultOperator, (a, v) => a.DefaultOperatorValue = v);
		public SimpleQueryStringQueryDescriptor<T> Fields(IEnumerable<string>? fields) => Assign(fields, (a, v) => a.FieldsValue = v);
		public SimpleQueryStringQueryDescriptor<T> Flags(Elastic.Clients.Elasticsearch.QueryDsl.SimpleQueryStringFlags? flags) => Assign(flags, (a, v) => a.FlagsValue = v);
		public SimpleQueryStringQueryDescriptor<T> FuzzyMaxExpansions(int? fuzzyMaxExpansions) => Assign(fuzzyMaxExpansions, (a, v) => a.FuzzyMaxExpansionsValue = v);
		public SimpleQueryStringQueryDescriptor<T> FuzzyPrefixLength(int? fuzzyPrefixLength) => Assign(fuzzyPrefixLength, (a, v) => a.FuzzyPrefixLengthValue = v);
		public SimpleQueryStringQueryDescriptor<T> FuzzyTranspositions(bool? fuzzyTranspositions = true) => Assign(fuzzyTranspositions, (a, v) => a.FuzzyTranspositionsValue = v);
		public SimpleQueryStringQueryDescriptor<T> Lenient(bool? lenient = true) => Assign(lenient, (a, v) => a.LenientValue = v);
		public SimpleQueryStringQueryDescriptor<T> MinimumShouldMatch(Elastic.Clients.Elasticsearch.MinimumShouldMatch? minimumShouldMatch) => Assign(minimumShouldMatch, (a, v) => a.MinimumShouldMatchValue = v);
		public SimpleQueryStringQueryDescriptor<T> Query(string query) => Assign(query, (a, v) => a.QueryValue = v);
		public SimpleQueryStringQueryDescriptor<T> QuoteFieldSuffix(string? quoteFieldSuffix) => Assign(quoteFieldSuffix, (a, v) => a.QuoteFieldSuffixValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (!string.IsNullOrEmpty(AnalyzerValue))
			{
				writer.WritePropertyName("analyzer");
				writer.WriteStringValue(AnalyzerValue);
			}

			if (AnalyzeWildcardValue.HasValue)
			{
				writer.WritePropertyName("analyze_wildcard");
				writer.WriteBooleanValue(AnalyzeWildcardValue.Value);
			}

			if (AutoGenerateSynonymsPhraseQueryValue.HasValue)
			{
				writer.WritePropertyName("auto_generate_synonyms_phrase_query");
				writer.WriteBooleanValue(AutoGenerateSynonymsPhraseQueryValue.Value);
			}

			if (DefaultOperatorValue is not null)
			{
				writer.WritePropertyName("default_operator");
				JsonSerializer.Serialize(writer, DefaultOperatorValue, options);
			}

			if (FieldsValue is not null)
			{
				writer.WritePropertyName("fields");
				JsonSerializer.Serialize(writer, FieldsValue, options);
			}

			if (FlagsValue is not null)
			{
				writer.WritePropertyName("flags");
				JsonSerializer.Serialize(writer, FlagsValue, options);
			}

			if (FuzzyMaxExpansionsValue.HasValue)
			{
				writer.WritePropertyName("fuzzy_max_expansions");
				writer.WriteNumberValue(FuzzyMaxExpansionsValue.Value);
			}

			if (FuzzyPrefixLengthValue.HasValue)
			{
				writer.WritePropertyName("fuzzy_prefix_length");
				writer.WriteNumberValue(FuzzyPrefixLengthValue.Value);
			}

			if (FuzzyTranspositionsValue.HasValue)
			{
				writer.WritePropertyName("fuzzy_transpositions");
				writer.WriteBooleanValue(FuzzyTranspositionsValue.Value);
			}

			if (LenientValue.HasValue)
			{
				writer.WritePropertyName("lenient");
				writer.WriteBooleanValue(LenientValue.Value);
			}

			if (MinimumShouldMatchValue is not null)
			{
				writer.WritePropertyName("minimum_should_match");
				JsonSerializer.Serialize(writer, MinimumShouldMatchValue, options);
			}

			writer.WritePropertyName("query");
			writer.WriteStringValue(QueryValue);
			if (!string.IsNullOrEmpty(QuoteFieldSuffixValue))
			{
				writer.WritePropertyName("quote_field_suffix");
				writer.WriteStringValue(QuoteFieldSuffixValue);
			}

			writer.WriteEndObject();
		}
	}

	public partial class SpanContainingQuery : QueryDsl.QueryBase, IQueryContainerVariant, ISpanQueryVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "span_containing";
		[JsonIgnore]
		string QueryDsl.ISpanQueryVariant.SpanQueryVariantName => "span_containing";
		[JsonInclude]
		[JsonPropertyName("big")]
		public Elastic.Clients.Elasticsearch.QueryDsl.SpanQuery Big { get; set; }

		[JsonInclude]
		[JsonPropertyName("little")]
		public Elastic.Clients.Elasticsearch.QueryDsl.SpanQuery Little { get; set; }
	}

	public sealed partial class SpanContainingQueryDescriptor<T> : DescriptorBase<SpanContainingQueryDescriptor<T>>
	{
		public SpanContainingQueryDescriptor()
		{
		}

		internal SpanContainingQueryDescriptor(Action<SpanContainingQueryDescriptor<T>> configure) => configure.Invoke(this);
		internal Elastic.Clients.Elasticsearch.QueryDsl.SpanQuery BigValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.SpanQuery LittleValue { get; private set; }

		internal SpanQueryDescriptor<T> BigDescriptor { get; private set; }

		internal SpanQueryDescriptor<T> LittleDescriptor { get; private set; }

		internal Action<SpanQueryDescriptor<T>> BigDescriptorAction { get; private set; }

		internal Action<SpanQueryDescriptor<T>> LittleDescriptorAction { get; private set; }

		public SpanContainingQueryDescriptor<T> Big(Elastic.Clients.Elasticsearch.QueryDsl.SpanQuery big)
		{
			BigDescriptor = null;
			BigDescriptorAction = null;
			return Assign(big, (a, v) => a.BigValue = v);
		}

		public SpanContainingQueryDescriptor<T> Big(Elastic.Clients.Elasticsearch.QueryDsl.SpanQueryDescriptor<T> descriptor)
		{
			BigValue = null;
			BigDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.BigDescriptor = v);
		}

		public SpanContainingQueryDescriptor<T> Big(Action<Elastic.Clients.Elasticsearch.QueryDsl.SpanQueryDescriptor<T>> configure)
		{
			BigValue = null;
			BigDescriptorAction = null;
			return Assign(configure, (a, v) => a.BigDescriptorAction = v);
		}

		public SpanContainingQueryDescriptor<T> Little(Elastic.Clients.Elasticsearch.QueryDsl.SpanQuery little)
		{
			LittleDescriptor = null;
			LittleDescriptorAction = null;
			return Assign(little, (a, v) => a.LittleValue = v);
		}

		public SpanContainingQueryDescriptor<T> Little(Elastic.Clients.Elasticsearch.QueryDsl.SpanQueryDescriptor<T> descriptor)
		{
			LittleValue = null;
			LittleDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.LittleDescriptor = v);
		}

		public SpanContainingQueryDescriptor<T> Little(Action<Elastic.Clients.Elasticsearch.QueryDsl.SpanQueryDescriptor<T>> configure)
		{
			LittleValue = null;
			LittleDescriptorAction = null;
			return Assign(configure, (a, v) => a.LittleDescriptorAction = v);
		}

		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (BigDescriptor is not null)
			{
				writer.WritePropertyName("big");
				JsonSerializer.Serialize(writer, BigDescriptor, options);
			}
			else if (BigDescriptorAction is not null)
			{
				writer.WritePropertyName("big");
				JsonSerializer.Serialize(writer, new SpanQueryDescriptor<T>(BigDescriptorAction), options);
			}
			else
			{
				writer.WritePropertyName("big");
				JsonSerializer.Serialize(writer, BigValue, options);
			}

			if (LittleDescriptor is not null)
			{
				writer.WritePropertyName("little");
				JsonSerializer.Serialize(writer, LittleDescriptor, options);
			}
			else if (LittleDescriptorAction is not null)
			{
				writer.WritePropertyName("little");
				JsonSerializer.Serialize(writer, new SpanQueryDescriptor<T>(LittleDescriptorAction), options);
			}
			else
			{
				writer.WritePropertyName("little");
				JsonSerializer.Serialize(writer, LittleValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class SpanFieldMaskingQuery : QueryDsl.QueryBase, IQueryContainerVariant, ISpanQueryVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "field_masking_span";
		[JsonIgnore]
		string QueryDsl.ISpanQueryVariant.SpanQueryVariantName => "field_masking_span";
		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("query")]
		public Elastic.Clients.Elasticsearch.QueryDsl.SpanQuery Query { get; set; }
	}

	public sealed partial class SpanFieldMaskingQueryDescriptor<T> : DescriptorBase<SpanFieldMaskingQueryDescriptor<T>>
	{
		public SpanFieldMaskingQueryDescriptor()
		{
		}

		internal SpanFieldMaskingQueryDescriptor(Action<SpanFieldMaskingQueryDescriptor<T>> configure) => configure.Invoke(this);
		internal string FieldValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.SpanQuery QueryValue { get; private set; }

		internal SpanQueryDescriptor<T> QueryDescriptor { get; private set; }

		internal Action<SpanQueryDescriptor<T>> QueryDescriptorAction { get; private set; }

		public SpanFieldMaskingQueryDescriptor<T> Field(string field) => Assign(field, (a, v) => a.FieldValue = v);
		public SpanFieldMaskingQueryDescriptor<T> Query(Elastic.Clients.Elasticsearch.QueryDsl.SpanQuery query)
		{
			QueryDescriptor = null;
			QueryDescriptorAction = null;
			return Assign(query, (a, v) => a.QueryValue = v);
		}

		public SpanFieldMaskingQueryDescriptor<T> Query(Elastic.Clients.Elasticsearch.QueryDsl.SpanQueryDescriptor<T> descriptor)
		{
			QueryValue = null;
			QueryDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.QueryDescriptor = v);
		}

		public SpanFieldMaskingQueryDescriptor<T> Query(Action<Elastic.Clients.Elasticsearch.QueryDsl.SpanQueryDescriptor<T>> configure)
		{
			QueryValue = null;
			QueryDescriptorAction = null;
			return Assign(configure, (a, v) => a.QueryDescriptorAction = v);
		}

		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, FieldValue, options);
			if (QueryDescriptor is not null)
			{
				writer.WritePropertyName("query");
				JsonSerializer.Serialize(writer, QueryDescriptor, options);
			}
			else if (QueryDescriptorAction is not null)
			{
				writer.WritePropertyName("query");
				JsonSerializer.Serialize(writer, new SpanQueryDescriptor<T>(QueryDescriptorAction), options);
			}
			else
			{
				writer.WritePropertyName("query");
				JsonSerializer.Serialize(writer, QueryValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class SpanFirstQuery : QueryDsl.QueryBase, IQueryContainerVariant, ISpanQueryVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "span_first";
		[JsonIgnore]
		string QueryDsl.ISpanQueryVariant.SpanQueryVariantName => "span_first";
		[JsonInclude]
		[JsonPropertyName("end")]
		public int End { get; set; }

		[JsonInclude]
		[JsonPropertyName("match")]
		public Elastic.Clients.Elasticsearch.QueryDsl.SpanQuery Match { get; set; }
	}

	public sealed partial class SpanFirstQueryDescriptor<T> : DescriptorBase<SpanFirstQueryDescriptor<T>>
	{
		public SpanFirstQueryDescriptor()
		{
		}

		internal SpanFirstQueryDescriptor(Action<SpanFirstQueryDescriptor<T>> configure) => configure.Invoke(this);
		internal int EndValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.SpanQuery MatchValue { get; private set; }

		internal SpanQueryDescriptor<T> MatchDescriptor { get; private set; }

		internal Action<SpanQueryDescriptor<T>> MatchDescriptorAction { get; private set; }

		public SpanFirstQueryDescriptor<T> End(int end) => Assign(end, (a, v) => a.EndValue = v);
		public SpanFirstQueryDescriptor<T> Match(Elastic.Clients.Elasticsearch.QueryDsl.SpanQuery match)
		{
			MatchDescriptor = null;
			MatchDescriptorAction = null;
			return Assign(match, (a, v) => a.MatchValue = v);
		}

		public SpanFirstQueryDescriptor<T> Match(Elastic.Clients.Elasticsearch.QueryDsl.SpanQueryDescriptor<T> descriptor)
		{
			MatchValue = null;
			MatchDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.MatchDescriptor = v);
		}

		public SpanFirstQueryDescriptor<T> Match(Action<Elastic.Clients.Elasticsearch.QueryDsl.SpanQueryDescriptor<T>> configure)
		{
			MatchValue = null;
			MatchDescriptorAction = null;
			return Assign(configure, (a, v) => a.MatchDescriptorAction = v);
		}

		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("end");
			writer.WriteNumberValue(EndValue);
			if (MatchDescriptor is not null)
			{
				writer.WritePropertyName("match");
				JsonSerializer.Serialize(writer, MatchDescriptor, options);
			}
			else if (MatchDescriptorAction is not null)
			{
				writer.WritePropertyName("match");
				JsonSerializer.Serialize(writer, new SpanQueryDescriptor<T>(MatchDescriptorAction), options);
			}
			else
			{
				writer.WritePropertyName("match");
				JsonSerializer.Serialize(writer, MatchValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class SpanMultiTermQuery : QueryDsl.QueryBase, IQueryContainerVariant, ISpanQueryVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "span_multi";
		[JsonIgnore]
		string QueryDsl.ISpanQueryVariant.SpanQueryVariantName => "span_multi";
		[JsonInclude]
		[JsonPropertyName("match")]
		public Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer Match { get; set; }
	}

	public sealed partial class SpanMultiTermQueryDescriptor<T> : DescriptorBase<SpanMultiTermQueryDescriptor<T>>
	{
		public SpanMultiTermQueryDescriptor()
		{
		}

		internal SpanMultiTermQueryDescriptor(Action<SpanMultiTermQueryDescriptor<T>> configure) => configure.Invoke(this);
		internal Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer MatchValue { get; private set; }

		internal QueryContainerDescriptor<T> MatchDescriptor { get; private set; }

		internal Action<QueryContainerDescriptor<T>> MatchDescriptorAction { get; private set; }

		public SpanMultiTermQueryDescriptor<T> Match(Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer match)
		{
			MatchDescriptor = null;
			MatchDescriptorAction = null;
			return Assign(match, (a, v) => a.MatchValue = v);
		}

		public SpanMultiTermQueryDescriptor<T> Match(Elastic.Clients.Elasticsearch.QueryDsl.QueryContainerDescriptor<T> descriptor)
		{
			MatchValue = null;
			MatchDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.MatchDescriptor = v);
		}

		public SpanMultiTermQueryDescriptor<T> Match(Action<Elastic.Clients.Elasticsearch.QueryDsl.QueryContainerDescriptor<T>> configure)
		{
			MatchValue = null;
			MatchDescriptorAction = null;
			return Assign(configure, (a, v) => a.MatchDescriptorAction = v);
		}

		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (MatchDescriptor is not null)
			{
				writer.WritePropertyName("match");
				JsonSerializer.Serialize(writer, MatchDescriptor, options);
			}
			else if (MatchDescriptorAction is not null)
			{
				writer.WritePropertyName("match");
				JsonSerializer.Serialize(writer, new QueryContainerDescriptor<T>(MatchDescriptorAction), options);
			}
			else
			{
				writer.WritePropertyName("match");
				JsonSerializer.Serialize(writer, MatchValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class SpanNearQuery : QueryDsl.QueryBase, IQueryContainerVariant, ISpanQueryVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "span_near";
		[JsonIgnore]
		string QueryDsl.ISpanQueryVariant.SpanQueryVariantName => "span_near";
		[JsonInclude]
		[JsonPropertyName("clauses")]
		public IEnumerable<Elastic.Clients.Elasticsearch.QueryDsl.SpanQuery> Clauses { get; set; }

		[JsonInclude]
		[JsonPropertyName("in_order")]
		public bool? InOrder { get; set; }

		[JsonInclude]
		[JsonPropertyName("slop")]
		public int? Slop { get; set; }
	}

	public sealed partial class SpanNearQueryDescriptor : DescriptorBase<SpanNearQueryDescriptor>
	{
		public SpanNearQueryDescriptor()
		{
		}

		internal SpanNearQueryDescriptor(Action<SpanNearQueryDescriptor> configure) => configure.Invoke(this);
		internal IEnumerable<Elastic.Clients.Elasticsearch.QueryDsl.SpanQuery> ClausesValue { get; private set; }

		internal bool? InOrderValue { get; private set; }

		internal int? SlopValue { get; private set; }

		public SpanNearQueryDescriptor Clauses(IEnumerable<Elastic.Clients.Elasticsearch.QueryDsl.SpanQuery> clauses) => Assign(clauses, (a, v) => a.ClausesValue = v);
		public SpanNearQueryDescriptor InOrder(bool? inOrder = true) => Assign(inOrder, (a, v) => a.InOrderValue = v);
		public SpanNearQueryDescriptor Slop(int? slop) => Assign(slop, (a, v) => a.SlopValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("clauses");
			JsonSerializer.Serialize(writer, ClausesValue, options);
			if (InOrderValue.HasValue)
			{
				writer.WritePropertyName("in_order");
				writer.WriteBooleanValue(InOrderValue.Value);
			}

			if (SlopValue.HasValue)
			{
				writer.WritePropertyName("slop");
				writer.WriteNumberValue(SlopValue.Value);
			}

			writer.WriteEndObject();
		}
	}

	public partial class SpanNotQuery : QueryDsl.QueryBase, IQueryContainerVariant, ISpanQueryVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "span_not";
		[JsonIgnore]
		string QueryDsl.ISpanQueryVariant.SpanQueryVariantName => "span_not";
		[JsonInclude]
		[JsonPropertyName("dist")]
		public int? Dist { get; set; }

		[JsonInclude]
		[JsonPropertyName("exclude")]
		public Elastic.Clients.Elasticsearch.QueryDsl.SpanQuery Exclude { get; set; }

		[JsonInclude]
		[JsonPropertyName("include")]
		public Elastic.Clients.Elasticsearch.QueryDsl.SpanQuery Include { get; set; }

		[JsonInclude]
		[JsonPropertyName("post")]
		public int? Post { get; set; }

		[JsonInclude]
		[JsonPropertyName("pre")]
		public int? Pre { get; set; }
	}

	public sealed partial class SpanNotQueryDescriptor<T> : DescriptorBase<SpanNotQueryDescriptor<T>>
	{
		public SpanNotQueryDescriptor()
		{
		}

		internal SpanNotQueryDescriptor(Action<SpanNotQueryDescriptor<T>> configure) => configure.Invoke(this);
		internal int? DistValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.SpanQuery ExcludeValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.SpanQuery IncludeValue { get; private set; }

		internal int? PostValue { get; private set; }

		internal int? PreValue { get; private set; }

		internal SpanQueryDescriptor<T> ExcludeDescriptor { get; private set; }

		internal SpanQueryDescriptor<T> IncludeDescriptor { get; private set; }

		internal Action<SpanQueryDescriptor<T>> ExcludeDescriptorAction { get; private set; }

		internal Action<SpanQueryDescriptor<T>> IncludeDescriptorAction { get; private set; }

		public SpanNotQueryDescriptor<T> Dist(int? dist) => Assign(dist, (a, v) => a.DistValue = v);
		public SpanNotQueryDescriptor<T> Exclude(Elastic.Clients.Elasticsearch.QueryDsl.SpanQuery exclude)
		{
			ExcludeDescriptor = null;
			ExcludeDescriptorAction = null;
			return Assign(exclude, (a, v) => a.ExcludeValue = v);
		}

		public SpanNotQueryDescriptor<T> Exclude(Elastic.Clients.Elasticsearch.QueryDsl.SpanQueryDescriptor<T> descriptor)
		{
			ExcludeValue = null;
			ExcludeDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.ExcludeDescriptor = v);
		}

		public SpanNotQueryDescriptor<T> Exclude(Action<Elastic.Clients.Elasticsearch.QueryDsl.SpanQueryDescriptor<T>> configure)
		{
			ExcludeValue = null;
			ExcludeDescriptorAction = null;
			return Assign(configure, (a, v) => a.ExcludeDescriptorAction = v);
		}

		public SpanNotQueryDescriptor<T> Include(Elastic.Clients.Elasticsearch.QueryDsl.SpanQuery include)
		{
			IncludeDescriptor = null;
			IncludeDescriptorAction = null;
			return Assign(include, (a, v) => a.IncludeValue = v);
		}

		public SpanNotQueryDescriptor<T> Include(Elastic.Clients.Elasticsearch.QueryDsl.SpanQueryDescriptor<T> descriptor)
		{
			IncludeValue = null;
			IncludeDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.IncludeDescriptor = v);
		}

		public SpanNotQueryDescriptor<T> Include(Action<Elastic.Clients.Elasticsearch.QueryDsl.SpanQueryDescriptor<T>> configure)
		{
			IncludeValue = null;
			IncludeDescriptorAction = null;
			return Assign(configure, (a, v) => a.IncludeDescriptorAction = v);
		}

		public SpanNotQueryDescriptor<T> Post(int? post) => Assign(post, (a, v) => a.PostValue = v);
		public SpanNotQueryDescriptor<T> Pre(int? pre) => Assign(pre, (a, v) => a.PreValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (DistValue.HasValue)
			{
				writer.WritePropertyName("dist");
				writer.WriteNumberValue(DistValue.Value);
			}

			if (ExcludeDescriptor is not null)
			{
				writer.WritePropertyName("exclude");
				JsonSerializer.Serialize(writer, ExcludeDescriptor, options);
			}
			else if (ExcludeDescriptorAction is not null)
			{
				writer.WritePropertyName("exclude");
				JsonSerializer.Serialize(writer, new SpanQueryDescriptor<T>(ExcludeDescriptorAction), options);
			}
			else
			{
				writer.WritePropertyName("exclude");
				JsonSerializer.Serialize(writer, ExcludeValue, options);
			}

			if (IncludeDescriptor is not null)
			{
				writer.WritePropertyName("include");
				JsonSerializer.Serialize(writer, IncludeDescriptor, options);
			}
			else if (IncludeDescriptorAction is not null)
			{
				writer.WritePropertyName("include");
				JsonSerializer.Serialize(writer, new SpanQueryDescriptor<T>(IncludeDescriptorAction), options);
			}
			else
			{
				writer.WritePropertyName("include");
				JsonSerializer.Serialize(writer, IncludeValue, options);
			}

			if (PostValue.HasValue)
			{
				writer.WritePropertyName("post");
				writer.WriteNumberValue(PostValue.Value);
			}

			if (PreValue.HasValue)
			{
				writer.WritePropertyName("pre");
				writer.WriteNumberValue(PreValue.Value);
			}

			writer.WriteEndObject();
		}
	}

	public partial class SpanOrQuery : QueryDsl.QueryBase, IQueryContainerVariant, ISpanQueryVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "span_or";
		[JsonIgnore]
		string QueryDsl.ISpanQueryVariant.SpanQueryVariantName => "span_or";
		[JsonInclude]
		[JsonPropertyName("clauses")]
		public IEnumerable<Elastic.Clients.Elasticsearch.QueryDsl.SpanQuery> Clauses { get; set; }
	}

	public sealed partial class SpanOrQueryDescriptor : DescriptorBase<SpanOrQueryDescriptor>
	{
		public SpanOrQueryDescriptor()
		{
		}

		internal SpanOrQueryDescriptor(Action<SpanOrQueryDescriptor> configure) => configure.Invoke(this);
		internal IEnumerable<Elastic.Clients.Elasticsearch.QueryDsl.SpanQuery> ClausesValue { get; private set; }

		public SpanOrQueryDescriptor Clauses(IEnumerable<Elastic.Clients.Elasticsearch.QueryDsl.SpanQuery> clauses) => Assign(clauses, (a, v) => a.ClausesValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("clauses");
			JsonSerializer.Serialize(writer, ClausesValue, options);
			writer.WriteEndObject();
		}
	}

	public interface ISpanQueryVariant
	{
		string SpanQueryVariantName { get; }
	}

	[JsonConverter(typeof(SpanQueryConverter))]
	public partial class SpanQuery : IContainer
	{
		public SpanQuery(ISpanQueryVariant variant) => Variant = variant ?? throw new ArgumentNullException(nameof(variant));
		internal ISpanQueryVariant Variant { get; }
	}

	internal sealed class SpanQueryConverter : JsonConverter<SpanQuery>
	{
		public override SpanQuery Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			reader.Read();
			if (reader.TokenType != JsonTokenType.PropertyName)
			{
				throw new JsonException();
			}

			var propertyName = reader.GetString();
			if (propertyName == "span_containing")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.SpanContainingQuery?>(ref reader, options);
				reader.Read();
				return new SpanQuery(variant);
			}

			if (propertyName == "field_masking_span")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.SpanFieldMaskingQuery?>(ref reader, options);
				reader.Read();
				return new SpanQuery(variant);
			}

			if (propertyName == "span_first")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.SpanFirstQuery?>(ref reader, options);
				reader.Read();
				return new SpanQuery(variant);
			}

			if (propertyName == "span_multi")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.SpanMultiTermQuery?>(ref reader, options);
				reader.Read();
				return new SpanQuery(variant);
			}

			if (propertyName == "span_near")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.SpanNearQuery?>(ref reader, options);
				reader.Read();
				return new SpanQuery(variant);
			}

			if (propertyName == "span_not")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.SpanNotQuery?>(ref reader, options);
				reader.Read();
				return new SpanQuery(variant);
			}

			if (propertyName == "span_or")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.SpanOrQuery?>(ref reader, options);
				reader.Read();
				return new SpanQuery(variant);
			}

			if (propertyName == "span_term")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.SpanTermQuery?>(ref reader, options);
				reader.Read();
				return new SpanQuery(variant);
			}

			if (propertyName == "span_within")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.SpanWithinQuery?>(ref reader, options);
				reader.Read();
				return new SpanQuery(variant);
			}

			throw new JsonException();
		}

		public override void Write(Utf8JsonWriter writer, SpanQuery value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName(value.Variant.SpanQueryVariantName);
			switch (value.Variant)
			{
				case Elastic.Clients.Elasticsearch.QueryDsl.SpanContainingQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.SpanFieldMaskingQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.SpanFirstQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.SpanMultiTermQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.SpanNearQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.SpanNotQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.SpanOrQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.SpanTermQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.SpanWithinQuery variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
			}

			writer.WriteEndObject();
		}
	}

	public sealed partial class SpanQueryDescriptor<T> : DescriptorBase<SpanQueryDescriptor<T>>
	{
		public SpanQueryDescriptor()
		{
		}

		internal SpanQueryDescriptor(Action<SpanQueryDescriptor<T>> configure) => configure.Invoke(this);
		internal bool ContainsVariant { get; private set; }

		internal string ContainedVariantName { get; private set; }

		internal SpanQuery Container { get; private set; }

		internal object ContainerVariantDescriptorAction { get; private set; }

		private void Set(object descriptorAction, string variantName)
		{
			if (ContainsVariant)
				throw new Exception("TODO");
			ContainerVariantDescriptorAction = descriptorAction;
			ContainedVariantName = variantName;
			ContainsVariant = true;
		}

		private void Set(ISpanQueryVariant variant, string variantName)
		{
			if (ContainsVariant)
				throw new Exception("TODO");
			Container = new SpanQuery(variant);
			ContainedVariantName = variantName;
			ContainsVariant = true;
		}

		public void SpanContaining(SpanContainingQuery variant) => Set(variant, "span_containing");
		public void SpanContaining(Action<SpanContainingQueryDescriptor<T>> configure) => Set(configure, "span_containing");
		public void FieldMaskingSpan(SpanFieldMaskingQuery variant) => Set(variant, "field_masking_span");
		public void FieldMaskingSpan(Action<SpanFieldMaskingQueryDescriptor<T>> configure) => Set(configure, "field_masking_span");
		public void SpanFirst(SpanFirstQuery variant) => Set(variant, "span_first");
		public void SpanFirst(Action<SpanFirstQueryDescriptor<T>> configure) => Set(configure, "span_first");
		public void SpanMulti(SpanMultiTermQuery variant) => Set(variant, "span_multi");
		public void SpanMulti(Action<SpanMultiTermQueryDescriptor<T>> configure) => Set(configure, "span_multi");
		public void SpanNear(SpanNearQuery variant) => Set(variant, "span_near");
		public void SpanNear(Action<SpanNearQueryDescriptor> configure) => Set(configure, "span_near");
		public void SpanNot(SpanNotQuery variant) => Set(variant, "span_not");
		public void SpanNot(Action<SpanNotQueryDescriptor<T>> configure) => Set(configure, "span_not");
		public void SpanOr(SpanOrQuery variant) => Set(variant, "span_or");
		public void SpanOr(Action<SpanOrQueryDescriptor> configure) => Set(configure, "span_or");
		public void SpanTerm(SpanTermQuery variant) => Set(variant, "span_term");
		public void SpanTerm(Action<SpanTermQueryDescriptor> configure) => Set(configure, "span_term");
		public void SpanWithin(SpanWithinQuery variant) => Set(variant, "span_within");
		public void SpanWithin(Action<SpanWithinQueryDescriptor<T>> configure) => Set(configure, "span_within");
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			if (!ContainsVariant)
			{
				writer.WriteNullValue();
				return;
			}

			writer.WriteStartObject();
			writer.WritePropertyName(ContainedVariantName);
			writer.WriteStartObject();
			if (Container is not null)
			{
				JsonSerializer.Serialize(writer, Container, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "span_containing")
			{
				var descriptor = new SpanContainingQueryDescriptor<T>();
				((Action<SpanContainingQueryDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "field_masking_span")
			{
				var descriptor = new SpanFieldMaskingQueryDescriptor<T>();
				((Action<SpanFieldMaskingQueryDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "span_first")
			{
				var descriptor = new SpanFirstQueryDescriptor<T>();
				((Action<SpanFirstQueryDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "span_multi")
			{
				var descriptor = new SpanMultiTermQueryDescriptor<T>();
				((Action<SpanMultiTermQueryDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "span_near")
			{
				var descriptor = new SpanNearQueryDescriptor();
				((Action<SpanNearQueryDescriptor>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "span_not")
			{
				var descriptor = new SpanNotQueryDescriptor<T>();
				((Action<SpanNotQueryDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "span_or")
			{
				var descriptor = new SpanOrQueryDescriptor();
				((Action<SpanOrQueryDescriptor>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "span_term")
			{
				var descriptor = new SpanTermQueryDescriptor();
				((Action<SpanTermQueryDescriptor>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "span_within")
			{
				var descriptor = new SpanWithinQueryDescriptor<T>();
				((Action<SpanWithinQueryDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			writer.WriteEndObject();
			writer.WriteEndObject();
			void Finalise()
			{
				writer.WriteEndObject();
				writer.WriteEndObject();
			}
		}
	}

	public partial class SpanTermQuery : FieldNameQueryBase, IQueryContainerVariant, ISpanQueryVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "span_term";
		[JsonIgnore]
		string QueryDsl.ISpanQueryVariant.SpanQueryVariantName => "span_term";
		[JsonInclude]
		[JsonPropertyName("value")]
		public string Value { get; set; }
	}

	public sealed partial class SpanTermQueryDescriptor : FieldNameQueryDescriptorBase<SpanTermQueryDescriptor>
	{
		public SpanTermQueryDescriptor()
		{
		}

		internal SpanTermQueryDescriptor(Action<SpanTermQueryDescriptor> configure) => configure.Invoke(this);
		internal string ValueValue { get; private set; }

		public SpanTermQueryDescriptor Value(string value) => Assign(value, (a, v) => a.ValueValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WritePropertyName(settings.Inferrer.Field(_field));
			writer.WriteStartObject();
			writer.WritePropertyName("value");
			writer.WriteStringValue(ValueValue);
			writer.WriteEndObject();
		}
	}

	public partial class SpanWithinQuery : QueryDsl.QueryBase, IQueryContainerVariant, ISpanQueryVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "span_within";
		[JsonIgnore]
		string QueryDsl.ISpanQueryVariant.SpanQueryVariantName => "span_within";
		[JsonInclude]
		[JsonPropertyName("big")]
		public Elastic.Clients.Elasticsearch.QueryDsl.SpanQuery Big { get; set; }

		[JsonInclude]
		[JsonPropertyName("little")]
		public Elastic.Clients.Elasticsearch.QueryDsl.SpanQuery Little { get; set; }
	}

	public sealed partial class SpanWithinQueryDescriptor<T> : DescriptorBase<SpanWithinQueryDescriptor<T>>
	{
		public SpanWithinQueryDescriptor()
		{
		}

		internal SpanWithinQueryDescriptor(Action<SpanWithinQueryDescriptor<T>> configure) => configure.Invoke(this);
		internal Elastic.Clients.Elasticsearch.QueryDsl.SpanQuery BigValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.SpanQuery LittleValue { get; private set; }

		internal SpanQueryDescriptor<T> BigDescriptor { get; private set; }

		internal SpanQueryDescriptor<T> LittleDescriptor { get; private set; }

		internal Action<SpanQueryDescriptor<T>> BigDescriptorAction { get; private set; }

		internal Action<SpanQueryDescriptor<T>> LittleDescriptorAction { get; private set; }

		public SpanWithinQueryDescriptor<T> Big(Elastic.Clients.Elasticsearch.QueryDsl.SpanQuery big)
		{
			BigDescriptor = null;
			BigDescriptorAction = null;
			return Assign(big, (a, v) => a.BigValue = v);
		}

		public SpanWithinQueryDescriptor<T> Big(Elastic.Clients.Elasticsearch.QueryDsl.SpanQueryDescriptor<T> descriptor)
		{
			BigValue = null;
			BigDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.BigDescriptor = v);
		}

		public SpanWithinQueryDescriptor<T> Big(Action<Elastic.Clients.Elasticsearch.QueryDsl.SpanQueryDescriptor<T>> configure)
		{
			BigValue = null;
			BigDescriptorAction = null;
			return Assign(configure, (a, v) => a.BigDescriptorAction = v);
		}

		public SpanWithinQueryDescriptor<T> Little(Elastic.Clients.Elasticsearch.QueryDsl.SpanQuery little)
		{
			LittleDescriptor = null;
			LittleDescriptorAction = null;
			return Assign(little, (a, v) => a.LittleValue = v);
		}

		public SpanWithinQueryDescriptor<T> Little(Elastic.Clients.Elasticsearch.QueryDsl.SpanQueryDescriptor<T> descriptor)
		{
			LittleValue = null;
			LittleDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.LittleDescriptor = v);
		}

		public SpanWithinQueryDescriptor<T> Little(Action<Elastic.Clients.Elasticsearch.QueryDsl.SpanQueryDescriptor<T>> configure)
		{
			LittleValue = null;
			LittleDescriptorAction = null;
			return Assign(configure, (a, v) => a.LittleDescriptorAction = v);
		}

		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (BigDescriptor is not null)
			{
				writer.WritePropertyName("big");
				JsonSerializer.Serialize(writer, BigDescriptor, options);
			}
			else if (BigDescriptorAction is not null)
			{
				writer.WritePropertyName("big");
				JsonSerializer.Serialize(writer, new SpanQueryDescriptor<T>(BigDescriptorAction), options);
			}
			else
			{
				writer.WritePropertyName("big");
				JsonSerializer.Serialize(writer, BigValue, options);
			}

			if (LittleDescriptor is not null)
			{
				writer.WritePropertyName("little");
				JsonSerializer.Serialize(writer, LittleDescriptor, options);
			}
			else if (LittleDescriptorAction is not null)
			{
				writer.WritePropertyName("little");
				JsonSerializer.Serialize(writer, new SpanQueryDescriptor<T>(LittleDescriptorAction), options);
			}
			else
			{
				writer.WritePropertyName("little");
				JsonSerializer.Serialize(writer, LittleValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class TermQuery : FieldNameQueryBase, IQueryContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "term";
		[JsonInclude]
		[JsonPropertyName("value")]
		public object Value { get; set; }

		[JsonInclude]
		[JsonPropertyName("case_insensitive")]
		public bool? CaseInsensitive { get; set; }
	}

	public sealed partial class TermQueryDescriptor : FieldNameQueryDescriptorBase<TermQueryDescriptor>
	{
		public TermQueryDescriptor()
		{
		}

		internal TermQueryDescriptor(Action<TermQueryDescriptor> configure) => configure.Invoke(this);
		internal object ValueValue { get; private set; }

		internal bool? CaseInsensitiveValue { get; private set; }

		public TermQueryDescriptor Value(object value) => Assign(value, (a, v) => a.ValueValue = v);
		public TermQueryDescriptor CaseInsensitive(bool? caseInsensitive = true) => Assign(caseInsensitive, (a, v) => a.CaseInsensitiveValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WritePropertyName(settings.Inferrer.Field(_field));
			writer.WriteStartObject();
			writer.WritePropertyName("value");
			JsonSerializer.Serialize(writer, ValueValue, options);
			if (CaseInsensitiveValue.HasValue)
			{
				writer.WritePropertyName("case_insensitive");
				writer.WriteBooleanValue(CaseInsensitiveValue.Value);
			}

			writer.WriteEndObject();
		}
	}

	public partial class TermsQuery : QueryDsl.QueryBase, IQueryContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "terms";
	}

	public sealed partial class TermsQueryDescriptor : DescriptorBase<TermsQueryDescriptor>
	{
		public TermsQueryDescriptor()
		{
		}

		internal TermsQueryDescriptor(Action<TermsQueryDescriptor> configure) => configure.Invoke(this);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WriteEndObject();
		}
	}

	public partial class TermsSetQuery : FieldNameQueryBase, IQueryContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "terms_set";
		[JsonInclude]
		[JsonPropertyName("minimum_should_match_field")]
		public string? MinimumShouldMatchField { get; set; }

		[JsonInclude]
		[JsonPropertyName("minimum_should_match_script")]
		public Elastic.Clients.Elasticsearch.Script? MinimumShouldMatchScript { get; set; }

		[JsonInclude]
		[JsonPropertyName("terms")]
		public IEnumerable<string> Terms { get; set; }
	}

	public sealed partial class TermsSetQueryDescriptor<T> : FieldNameQueryDescriptorBase<TermsSetQueryDescriptor<T>>
	{
		public TermsSetQueryDescriptor()
		{
		}

		internal TermsSetQueryDescriptor(Action<TermsSetQueryDescriptor<T>> configure) => configure.Invoke(this);
		internal string? MinimumShouldMatchFieldValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Script? MinimumShouldMatchScriptValue { get; private set; }

		internal IEnumerable<string> TermsValue { get; private set; }

		public TermsSetQueryDescriptor<T> MinimumShouldMatchField(string? minimumShouldMatchField) => Assign(minimumShouldMatchField, (a, v) => a.MinimumShouldMatchFieldValue = v);
		public TermsSetQueryDescriptor<T> MinimumShouldMatchScript(Elastic.Clients.Elasticsearch.Script? minimumShouldMatchScript) => Assign(minimumShouldMatchScript, (a, v) => a.MinimumShouldMatchScriptValue = v);
		public TermsSetQueryDescriptor<T> Terms(IEnumerable<string> terms) => Assign(terms, (a, v) => a.TermsValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WritePropertyName(settings.Inferrer.Field(_field));
			writer.WriteStartObject();
			if (MinimumShouldMatchFieldValue is not null)
			{
				writer.WritePropertyName("minimum_should_match_field");
				JsonSerializer.Serialize(writer, MinimumShouldMatchFieldValue, options);
			}

			if (MinimumShouldMatchScriptValue is not null)
			{
				writer.WritePropertyName("minimum_should_match_script");
				JsonSerializer.Serialize(writer, MinimumShouldMatchScriptValue, options);
			}

			writer.WritePropertyName("terms");
			JsonSerializer.Serialize(writer, TermsValue, options);
			writer.WriteEndObject();
		}
	}

	public partial class WildcardQuery : FieldNameQueryBase, IQueryContainerVariant
	{
		[JsonIgnore]
		string QueryDsl.IQueryContainerVariant.QueryContainerVariantName => "wildcard";
		[JsonInclude]
		[JsonPropertyName("case_insensitive")]
		public bool? CaseInsensitive { get; set; }

		[JsonInclude]
		[JsonPropertyName("rewrite")]
		public string? Rewrite { get; set; }

		[JsonInclude]
		[JsonPropertyName("value")]
		public string? Value { get; set; }

		[JsonInclude]
		[JsonPropertyName("wildcard")]
		public string? Wildcard { get; set; }
	}

	public sealed partial class WildcardQueryDescriptor : FieldNameQueryDescriptorBase<WildcardQueryDescriptor>
	{
		public WildcardQueryDescriptor()
		{
		}

		internal WildcardQueryDescriptor(Action<WildcardQueryDescriptor> configure) => configure.Invoke(this);
		internal bool? CaseInsensitiveValue { get; private set; }

		internal string? RewriteValue { get; private set; }

		internal string? ValueValue { get; private set; }

		internal string? WildcardValue { get; private set; }

		public WildcardQueryDescriptor CaseInsensitive(bool? caseInsensitive = true) => Assign(caseInsensitive, (a, v) => a.CaseInsensitiveValue = v);
		public WildcardQueryDescriptor Rewrite(string? rewrite) => Assign(rewrite, (a, v) => a.RewriteValue = v);
		public WildcardQueryDescriptor Value(string? value) => Assign(value, (a, v) => a.ValueValue = v);
		public WildcardQueryDescriptor Wildcard(string? wildcard) => Assign(wildcard, (a, v) => a.WildcardValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WritePropertyName(settings.Inferrer.Field(_field));
			writer.WriteStartObject();
			if (CaseInsensitiveValue.HasValue)
			{
				writer.WritePropertyName("case_insensitive");
				writer.WriteBooleanValue(CaseInsensitiveValue.Value);
			}

			if (RewriteValue is not null)
			{
				writer.WritePropertyName("rewrite");
				JsonSerializer.Serialize(writer, RewriteValue, options);
			}

			if (!string.IsNullOrEmpty(ValueValue))
			{
				writer.WritePropertyName("value");
				writer.WriteStringValue(ValueValue);
			}

			if (!string.IsNullOrEmpty(WildcardValue))
			{
				writer.WritePropertyName("wildcard");
				writer.WriteStringValue(WildcardValue);
			}

			writer.WriteEndObject();
		}
	}
}