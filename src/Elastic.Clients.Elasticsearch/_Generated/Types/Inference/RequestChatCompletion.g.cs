// Licensed to Elasticsearch B.V under one or more agreements.
// Elasticsearch B.V licenses this file to you under the Apache 2.0 License.
// See the LICENSE file in the project root for more information.
//
// ███╗   ██╗ ██████╗ ████████╗██╗ ██████╗███████╗
// ████╗  ██║██╔═══██╗╚══██╔══╝██║██╔════╝██╔════╝
// ██╔██╗ ██║██║   ██║   ██║   ██║██║     █████╗
// ██║╚██╗██║██║   ██║   ██║   ██║██║     ██╔══╝
// ██║ ╚████║╚██████╔╝   ██║   ██║╚██████╗███████╗
// ╚═╝  ╚═══╝ ╚═════╝    ╚═╝   ╚═╝ ╚═════╝╚══════╝
// ------------------------------------------------
//
// This file is automatically generated.
// Please do not edit these files manually.
//
// ------------------------------------------------

#nullable restore

using Elastic.Clients.Elasticsearch.Fluent;
using Elastic.Clients.Elasticsearch.Serialization;
using System;
using System.Collections.Generic;
using System.Linq.Expressions;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace Elastic.Clients.Elasticsearch.Inference;

public sealed partial class RequestChatCompletion
{
	/// <summary>
	/// <para>
	/// The upper bound limit for the number of tokens that can be generated for a completion request.
	/// </para>
	/// </summary>
	[JsonInclude, JsonPropertyName("max_completion_tokens")]
	public long? MaxCompletionTokens { get; set; }

	/// <summary>
	/// <para>
	/// A list of objects representing the conversation.
	/// </para>
	/// </summary>
	[JsonInclude, JsonPropertyName("messages")]
	public ICollection<Elastic.Clients.Elasticsearch.Inference.Message> Messages { get; set; }

	/// <summary>
	/// <para>
	/// The ID of the model to use.
	/// </para>
	/// </summary>
	[JsonInclude, JsonPropertyName("model")]
	public string? Model { get; set; }

	/// <summary>
	/// <para>
	/// A sequence of strings to control when the model should stop generating additional tokens.
	/// </para>
	/// </summary>
	[JsonInclude, JsonPropertyName("stop")]
	public ICollection<string>? Stop { get; set; }

	/// <summary>
	/// <para>
	/// The sampling temperature to use.
	/// </para>
	/// </summary>
	[JsonInclude, JsonPropertyName("temperature")]
	public float? Temperature { get; set; }

	/// <summary>
	/// <para>
	/// Controls which tool is called by the model.
	/// </para>
	/// </summary>
	[JsonInclude, JsonPropertyName("tool_choice")]
	public Elastic.Clients.Elasticsearch.Inference.CompletionToolType? ToolChoice { get; set; }

	/// <summary>
	/// <para>
	/// A list of tools that the model can call.
	/// </para>
	/// </summary>
	[JsonInclude, JsonPropertyName("tools")]
	public ICollection<Elastic.Clients.Elasticsearch.Inference.CompletionTool>? Tools { get; set; }

	/// <summary>
	/// <para>
	/// Nucleus sampling, an alternative to sampling with temperature.
	/// </para>
	/// </summary>
	[JsonInclude, JsonPropertyName("top_p")]
	public float? TopP { get; set; }
}

public sealed partial class RequestChatCompletionDescriptor : SerializableDescriptor<RequestChatCompletionDescriptor>
{
	internal RequestChatCompletionDescriptor(Action<RequestChatCompletionDescriptor> configure) => configure.Invoke(this);

	public RequestChatCompletionDescriptor() : base()
	{
	}

	private long? MaxCompletionTokensValue { get; set; }
	private ICollection<Elastic.Clients.Elasticsearch.Inference.Message> MessagesValue { get; set; }
	private Elastic.Clients.Elasticsearch.Inference.MessageDescriptor MessagesDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.Inference.MessageDescriptor> MessagesDescriptorAction { get; set; }
	private Action<Elastic.Clients.Elasticsearch.Inference.MessageDescriptor>[] MessagesDescriptorActions { get; set; }
	private string? ModelValue { get; set; }
	private ICollection<string>? StopValue { get; set; }
	private float? TemperatureValue { get; set; }
	private Elastic.Clients.Elasticsearch.Inference.CompletionToolType? ToolChoiceValue { get; set; }
	private ICollection<Elastic.Clients.Elasticsearch.Inference.CompletionTool>? ToolsValue { get; set; }
	private Elastic.Clients.Elasticsearch.Inference.CompletionToolDescriptor ToolsDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.Inference.CompletionToolDescriptor> ToolsDescriptorAction { get; set; }
	private Action<Elastic.Clients.Elasticsearch.Inference.CompletionToolDescriptor>[] ToolsDescriptorActions { get; set; }
	private float? TopPValue { get; set; }

	/// <summary>
	/// <para>
	/// The upper bound limit for the number of tokens that can be generated for a completion request.
	/// </para>
	/// </summary>
	public RequestChatCompletionDescriptor MaxCompletionTokens(long? maxCompletionTokens)
	{
		MaxCompletionTokensValue = maxCompletionTokens;
		return Self;
	}

	/// <summary>
	/// <para>
	/// A list of objects representing the conversation.
	/// </para>
	/// </summary>
	public RequestChatCompletionDescriptor Messages(ICollection<Elastic.Clients.Elasticsearch.Inference.Message> messages)
	{
		MessagesDescriptor = null;
		MessagesDescriptorAction = null;
		MessagesDescriptorActions = null;
		MessagesValue = messages;
		return Self;
	}

	public RequestChatCompletionDescriptor Messages(Elastic.Clients.Elasticsearch.Inference.MessageDescriptor descriptor)
	{
		MessagesValue = null;
		MessagesDescriptorAction = null;
		MessagesDescriptorActions = null;
		MessagesDescriptor = descriptor;
		return Self;
	}

	public RequestChatCompletionDescriptor Messages(Action<Elastic.Clients.Elasticsearch.Inference.MessageDescriptor> configure)
	{
		MessagesValue = null;
		MessagesDescriptor = null;
		MessagesDescriptorActions = null;
		MessagesDescriptorAction = configure;
		return Self;
	}

	public RequestChatCompletionDescriptor Messages(params Action<Elastic.Clients.Elasticsearch.Inference.MessageDescriptor>[] configure)
	{
		MessagesValue = null;
		MessagesDescriptor = null;
		MessagesDescriptorAction = null;
		MessagesDescriptorActions = configure;
		return Self;
	}

	/// <summary>
	/// <para>
	/// The ID of the model to use.
	/// </para>
	/// </summary>
	public RequestChatCompletionDescriptor Model(string? model)
	{
		ModelValue = model;
		return Self;
	}

	/// <summary>
	/// <para>
	/// A sequence of strings to control when the model should stop generating additional tokens.
	/// </para>
	/// </summary>
	public RequestChatCompletionDescriptor Stop(ICollection<string>? stop)
	{
		StopValue = stop;
		return Self;
	}

	/// <summary>
	/// <para>
	/// The sampling temperature to use.
	/// </para>
	/// </summary>
	public RequestChatCompletionDescriptor Temperature(float? temperature)
	{
		TemperatureValue = temperature;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Controls which tool is called by the model.
	/// </para>
	/// </summary>
	public RequestChatCompletionDescriptor ToolChoice(Elastic.Clients.Elasticsearch.Inference.CompletionToolType? toolChoice)
	{
		ToolChoiceValue = toolChoice;
		return Self;
	}

	/// <summary>
	/// <para>
	/// A list of tools that the model can call.
	/// </para>
	/// </summary>
	public RequestChatCompletionDescriptor Tools(ICollection<Elastic.Clients.Elasticsearch.Inference.CompletionTool>? tools)
	{
		ToolsDescriptor = null;
		ToolsDescriptorAction = null;
		ToolsDescriptorActions = null;
		ToolsValue = tools;
		return Self;
	}

	public RequestChatCompletionDescriptor Tools(Elastic.Clients.Elasticsearch.Inference.CompletionToolDescriptor descriptor)
	{
		ToolsValue = null;
		ToolsDescriptorAction = null;
		ToolsDescriptorActions = null;
		ToolsDescriptor = descriptor;
		return Self;
	}

	public RequestChatCompletionDescriptor Tools(Action<Elastic.Clients.Elasticsearch.Inference.CompletionToolDescriptor> configure)
	{
		ToolsValue = null;
		ToolsDescriptor = null;
		ToolsDescriptorActions = null;
		ToolsDescriptorAction = configure;
		return Self;
	}

	public RequestChatCompletionDescriptor Tools(params Action<Elastic.Clients.Elasticsearch.Inference.CompletionToolDescriptor>[] configure)
	{
		ToolsValue = null;
		ToolsDescriptor = null;
		ToolsDescriptorAction = null;
		ToolsDescriptorActions = configure;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Nucleus sampling, an alternative to sampling with temperature.
	/// </para>
	/// </summary>
	public RequestChatCompletionDescriptor TopP(float? topP)
	{
		TopPValue = topP;
		return Self;
	}

	protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
	{
		writer.WriteStartObject();
		if (MaxCompletionTokensValue.HasValue)
		{
			writer.WritePropertyName("max_completion_tokens");
			writer.WriteNumberValue(MaxCompletionTokensValue.Value);
		}

		if (MessagesDescriptor is not null)
		{
			writer.WritePropertyName("messages");
			writer.WriteStartArray();
			JsonSerializer.Serialize(writer, MessagesDescriptor, options);
			writer.WriteEndArray();
		}
		else if (MessagesDescriptorAction is not null)
		{
			writer.WritePropertyName("messages");
			writer.WriteStartArray();
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.Inference.MessageDescriptor(MessagesDescriptorAction), options);
			writer.WriteEndArray();
		}
		else if (MessagesDescriptorActions is not null)
		{
			writer.WritePropertyName("messages");
			writer.WriteStartArray();
			foreach (var action in MessagesDescriptorActions)
			{
				JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.Inference.MessageDescriptor(action), options);
			}

			writer.WriteEndArray();
		}
		else
		{
			writer.WritePropertyName("messages");
			JsonSerializer.Serialize(writer, MessagesValue, options);
		}

		if (!string.IsNullOrEmpty(ModelValue))
		{
			writer.WritePropertyName("model");
			writer.WriteStringValue(ModelValue);
		}

		if (StopValue is not null)
		{
			writer.WritePropertyName("stop");
			JsonSerializer.Serialize(writer, StopValue, options);
		}

		if (TemperatureValue.HasValue)
		{
			writer.WritePropertyName("temperature");
			writer.WriteNumberValue(TemperatureValue.Value);
		}

		if (ToolChoiceValue is not null)
		{
			writer.WritePropertyName("tool_choice");
			JsonSerializer.Serialize(writer, ToolChoiceValue, options);
		}

		if (ToolsDescriptor is not null)
		{
			writer.WritePropertyName("tools");
			writer.WriteStartArray();
			JsonSerializer.Serialize(writer, ToolsDescriptor, options);
			writer.WriteEndArray();
		}
		else if (ToolsDescriptorAction is not null)
		{
			writer.WritePropertyName("tools");
			writer.WriteStartArray();
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.Inference.CompletionToolDescriptor(ToolsDescriptorAction), options);
			writer.WriteEndArray();
		}
		else if (ToolsDescriptorActions is not null)
		{
			writer.WritePropertyName("tools");
			writer.WriteStartArray();
			foreach (var action in ToolsDescriptorActions)
			{
				JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.Inference.CompletionToolDescriptor(action), options);
			}

			writer.WriteEndArray();
		}
		else if (ToolsValue is not null)
		{
			writer.WritePropertyName("tools");
			JsonSerializer.Serialize(writer, ToolsValue, options);
		}

		if (TopPValue.HasValue)
		{
			writer.WritePropertyName("top_p");
			writer.WriteNumberValue(TopPValue.Value);
		}

		writer.WriteEndObject();
	}
}