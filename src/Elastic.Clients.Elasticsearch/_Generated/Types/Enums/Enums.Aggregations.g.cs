// Licensed to Elasticsearch B.V under one or more agreements.
// Elasticsearch B.V licenses this file to you under the Apache 2.0 License.
// See the LICENSE file in the project root for more information.
//
// ███╗   ██╗ ██████╗ ████████╗██╗ ██████╗███████╗
// ████╗  ██║██╔═══██╗╚══██╔══╝██║██╔════╝██╔════╝
// ██╔██╗ ██║██║   ██║   ██║   ██║██║     █████╗
// ██║╚██╗██║██║   ██║   ██║   ██║██║     ██╔══╝
// ██║ ╚████║╚██████╔╝   ██║   ██║╚██████╗███████╗
// ╚═╝  ╚═══╝ ╚═════╝    ╚═╝   ╚═╝ ╚═════╝╚══════╝
// ------------------------------------------------
//
// This file is automatically generated.
// Please do not edit these files manually.
//
// ------------------------------------------------

#nullable restore

using Elastic.Clients.Elasticsearch.Core;
using Elastic.Clients.Elasticsearch.Serialization;
using Elastic.Transport;
using System;
using System.Runtime.Serialization;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace Elastic.Clients.Elasticsearch.Aggregations;

[JsonConverter(typeof(CalendarIntervalConverter))]
public enum CalendarInterval
{
	[EnumMember(Value = "year")]
	Year,
	[EnumMember(Value = "week")]
	Week,
	[EnumMember(Value = "second")]
	Second,
	[EnumMember(Value = "quarter")]
	Quarter,
	[EnumMember(Value = "month")]
	Month,
	[EnumMember(Value = "minute")]
	Minute,
	[EnumMember(Value = "hour")]
	Hour,
	[EnumMember(Value = "day")]
	Day
}

internal sealed partial class CalendarIntervalConverter : System.Text.Json.Serialization.JsonConverter<CalendarInterval>
{
	private static readonly System.Text.Json.JsonEncodedText MemberYear = System.Text.Json.JsonEncodedText.Encode("year");
	private static readonly System.Text.Json.JsonEncodedText MemberYear1 = System.Text.Json.JsonEncodedText.Encode("1y");
	private static readonly System.Text.Json.JsonEncodedText MemberWeek = System.Text.Json.JsonEncodedText.Encode("week");
	private static readonly System.Text.Json.JsonEncodedText MemberWeek1 = System.Text.Json.JsonEncodedText.Encode("1w");
	private static readonly System.Text.Json.JsonEncodedText MemberSecond = System.Text.Json.JsonEncodedText.Encode("second");
	private static readonly System.Text.Json.JsonEncodedText MemberSecond1 = System.Text.Json.JsonEncodedText.Encode("1s");
	private static readonly System.Text.Json.JsonEncodedText MemberQuarter = System.Text.Json.JsonEncodedText.Encode("quarter");
	private static readonly System.Text.Json.JsonEncodedText MemberQuarter1 = System.Text.Json.JsonEncodedText.Encode("1q");
	private static readonly System.Text.Json.JsonEncodedText MemberMonth = System.Text.Json.JsonEncodedText.Encode("month");
	private static readonly System.Text.Json.JsonEncodedText MemberMonth1 = System.Text.Json.JsonEncodedText.Encode("1M");
	private static readonly System.Text.Json.JsonEncodedText MemberMinute = System.Text.Json.JsonEncodedText.Encode("minute");
	private static readonly System.Text.Json.JsonEncodedText MemberMinute1 = System.Text.Json.JsonEncodedText.Encode("1m");
	private static readonly System.Text.Json.JsonEncodedText MemberHour = System.Text.Json.JsonEncodedText.Encode("hour");
	private static readonly System.Text.Json.JsonEncodedText MemberHour1 = System.Text.Json.JsonEncodedText.Encode("1h");
	private static readonly System.Text.Json.JsonEncodedText MemberDay = System.Text.Json.JsonEncodedText.Encode("day");
	private static readonly System.Text.Json.JsonEncodedText MemberDay1 = System.Text.Json.JsonEncodedText.Encode("1d");

	public override CalendarInterval Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberYear) || reader.ValueTextEquals(MemberYear1))
		{
			return CalendarInterval.Year;
		}

		if (reader.ValueTextEquals(MemberWeek) || reader.ValueTextEquals(MemberWeek1))
		{
			return CalendarInterval.Week;
		}

		if (reader.ValueTextEquals(MemberSecond) || reader.ValueTextEquals(MemberSecond1))
		{
			return CalendarInterval.Second;
		}

		if (reader.ValueTextEquals(MemberQuarter) || reader.ValueTextEquals(MemberQuarter1))
		{
			return CalendarInterval.Quarter;
		}

		if (reader.ValueTextEquals(MemberMonth) || reader.ValueTextEquals(MemberMonth1))
		{
			return CalendarInterval.Month;
		}

		if (reader.ValueTextEquals(MemberMinute) || reader.ValueTextEquals(MemberMinute1))
		{
			return CalendarInterval.Minute;
		}

		if (reader.ValueTextEquals(MemberHour) || reader.ValueTextEquals(MemberHour1))
		{
			return CalendarInterval.Hour;
		}

		if (reader.ValueTextEquals(MemberDay) || reader.ValueTextEquals(MemberDay1))
		{
			return CalendarInterval.Day;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberYear.Value, System.StringComparison.OrdinalIgnoreCase) || string.Equals(value, MemberYear1.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return CalendarInterval.Year;
		}

		if (string.Equals(value, MemberWeek.Value, System.StringComparison.OrdinalIgnoreCase) || string.Equals(value, MemberWeek1.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return CalendarInterval.Week;
		}

		if (string.Equals(value, MemberSecond.Value, System.StringComparison.OrdinalIgnoreCase) || string.Equals(value, MemberSecond1.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return CalendarInterval.Second;
		}

		if (string.Equals(value, MemberQuarter.Value, System.StringComparison.OrdinalIgnoreCase) || string.Equals(value, MemberQuarter1.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return CalendarInterval.Quarter;
		}

		if (string.Equals(value, MemberMonth.Value, System.StringComparison.OrdinalIgnoreCase) || string.Equals(value, MemberMonth1.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return CalendarInterval.Month;
		}

		if (string.Equals(value, MemberMinute.Value, System.StringComparison.OrdinalIgnoreCase) || string.Equals(value, MemberMinute1.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return CalendarInterval.Minute;
		}

		if (string.Equals(value, MemberHour.Value, System.StringComparison.OrdinalIgnoreCase) || string.Equals(value, MemberHour1.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return CalendarInterval.Hour;
		}

		if (string.Equals(value, MemberDay.Value, System.StringComparison.OrdinalIgnoreCase) || string.Equals(value, MemberDay1.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return CalendarInterval.Day;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(CalendarInterval)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, CalendarInterval value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case CalendarInterval.Year:
				writer.WriteStringValue(MemberYear);
				break;
			case CalendarInterval.Week:
				writer.WriteStringValue(MemberWeek);
				break;
			case CalendarInterval.Second:
				writer.WriteStringValue(MemberSecond);
				break;
			case CalendarInterval.Quarter:
				writer.WriteStringValue(MemberQuarter);
				break;
			case CalendarInterval.Month:
				writer.WriteStringValue(MemberMonth);
				break;
			case CalendarInterval.Minute:
				writer.WriteStringValue(MemberMinute);
				break;
			case CalendarInterval.Hour:
				writer.WriteStringValue(MemberHour);
				break;
			case CalendarInterval.Day:
				writer.WriteStringValue(MemberDay);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(CalendarInterval)}'.");
		}
	}
}

[JsonConverter(typeof(CardinalityExecutionModeConverter))]
public enum CardinalityExecutionMode
{
	/// <summary>
	/// <para>
	/// Run the aggregation by using segment ordinal values and resolving those values after each segment.
	/// </para>
	/// </summary>
	[EnumMember(Value = "segment_ordinals")]
	SegmentOrdinals,
	/// <summary>
	/// <para>
	/// Heuristic-based mode, default in Elasticsearch 8.4 and later.
	/// </para>
	/// </summary>
	[EnumMember(Value = "save_time_heuristic")]
	SaveTimeHeuristic,
	/// <summary>
	/// <para>
	/// Heuristic-based mode, default in Elasticsearch 8.3 and earlier.
	/// </para>
	/// </summary>
	[EnumMember(Value = "save_memory_heuristic")]
	SaveMemoryHeuristic,
	/// <summary>
	/// <para>
	/// Run the aggregation by using global ordinals of the field and resolving those values after finishing a shard.
	/// </para>
	/// </summary>
	[EnumMember(Value = "global_ordinals")]
	GlobalOrdinals,
	/// <summary>
	/// <para>
	/// Run the aggregation by using field values directly.
	/// </para>
	/// </summary>
	[EnumMember(Value = "direct")]
	Direct
}

internal sealed partial class CardinalityExecutionModeConverter : System.Text.Json.Serialization.JsonConverter<CardinalityExecutionMode>
{
	private static readonly System.Text.Json.JsonEncodedText MemberSegmentOrdinals = System.Text.Json.JsonEncodedText.Encode("segment_ordinals");
	private static readonly System.Text.Json.JsonEncodedText MemberSaveTimeHeuristic = System.Text.Json.JsonEncodedText.Encode("save_time_heuristic");
	private static readonly System.Text.Json.JsonEncodedText MemberSaveMemoryHeuristic = System.Text.Json.JsonEncodedText.Encode("save_memory_heuristic");
	private static readonly System.Text.Json.JsonEncodedText MemberGlobalOrdinals = System.Text.Json.JsonEncodedText.Encode("global_ordinals");
	private static readonly System.Text.Json.JsonEncodedText MemberDirect = System.Text.Json.JsonEncodedText.Encode("direct");

	public override CardinalityExecutionMode Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberSegmentOrdinals))
		{
			return CardinalityExecutionMode.SegmentOrdinals;
		}

		if (reader.ValueTextEquals(MemberSaveTimeHeuristic))
		{
			return CardinalityExecutionMode.SaveTimeHeuristic;
		}

		if (reader.ValueTextEquals(MemberSaveMemoryHeuristic))
		{
			return CardinalityExecutionMode.SaveMemoryHeuristic;
		}

		if (reader.ValueTextEquals(MemberGlobalOrdinals))
		{
			return CardinalityExecutionMode.GlobalOrdinals;
		}

		if (reader.ValueTextEquals(MemberDirect))
		{
			return CardinalityExecutionMode.Direct;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberSegmentOrdinals.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return CardinalityExecutionMode.SegmentOrdinals;
		}

		if (string.Equals(value, MemberSaveTimeHeuristic.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return CardinalityExecutionMode.SaveTimeHeuristic;
		}

		if (string.Equals(value, MemberSaveMemoryHeuristic.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return CardinalityExecutionMode.SaveMemoryHeuristic;
		}

		if (string.Equals(value, MemberGlobalOrdinals.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return CardinalityExecutionMode.GlobalOrdinals;
		}

		if (string.Equals(value, MemberDirect.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return CardinalityExecutionMode.Direct;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(CardinalityExecutionMode)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, CardinalityExecutionMode value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case CardinalityExecutionMode.SegmentOrdinals:
				writer.WriteStringValue(MemberSegmentOrdinals);
				break;
			case CardinalityExecutionMode.SaveTimeHeuristic:
				writer.WriteStringValue(MemberSaveTimeHeuristic);
				break;
			case CardinalityExecutionMode.SaveMemoryHeuristic:
				writer.WriteStringValue(MemberSaveMemoryHeuristic);
				break;
			case CardinalityExecutionMode.GlobalOrdinals:
				writer.WriteStringValue(MemberGlobalOrdinals);
				break;
			case CardinalityExecutionMode.Direct:
				writer.WriteStringValue(MemberDirect);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(CardinalityExecutionMode)}'.");
		}
	}
}

[JsonConverter(typeof(GapPolicyConverter))]
public enum GapPolicy
{
	/// <summary>
	/// <para>
	/// Treats missing data as if the bucket does not exist. It will skip the bucket and
	/// continue calculating using the next available value.
	/// </para>
	/// </summary>
	[EnumMember(Value = "skip")]
	Skip,
	/// <summary>
	/// <para>
	/// Similar to skip, except if the metric provides a non-null, non-NaN value this value is used,
	/// otherwise the empty bucket is skipped.
	/// </para>
	/// </summary>
	[EnumMember(Value = "keep_values")]
	KeepValues,
	/// <summary>
	/// <para>
	/// Replace missing values with a zero (0) and pipeline aggregation computation will proceed as normal.
	/// </para>
	/// </summary>
	[EnumMember(Value = "insert_zeros")]
	InsertZeros
}

internal sealed partial class GapPolicyConverter : System.Text.Json.Serialization.JsonConverter<GapPolicy>
{
	private static readonly System.Text.Json.JsonEncodedText MemberSkip = System.Text.Json.JsonEncodedText.Encode("skip");
	private static readonly System.Text.Json.JsonEncodedText MemberKeepValues = System.Text.Json.JsonEncodedText.Encode("keep_values");
	private static readonly System.Text.Json.JsonEncodedText MemberInsertZeros = System.Text.Json.JsonEncodedText.Encode("insert_zeros");

	public override GapPolicy Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberSkip))
		{
			return GapPolicy.Skip;
		}

		if (reader.ValueTextEquals(MemberKeepValues))
		{
			return GapPolicy.KeepValues;
		}

		if (reader.ValueTextEquals(MemberInsertZeros))
		{
			return GapPolicy.InsertZeros;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberSkip.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return GapPolicy.Skip;
		}

		if (string.Equals(value, MemberKeepValues.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return GapPolicy.KeepValues;
		}

		if (string.Equals(value, MemberInsertZeros.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return GapPolicy.InsertZeros;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(GapPolicy)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, GapPolicy value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case GapPolicy.Skip:
				writer.WriteStringValue(MemberSkip);
				break;
			case GapPolicy.KeepValues:
				writer.WriteStringValue(MemberKeepValues);
				break;
			case GapPolicy.InsertZeros:
				writer.WriteStringValue(MemberInsertZeros);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(GapPolicy)}'.");
		}
	}
}

[JsonConverter(typeof(MinimumIntervalConverter))]
public enum MinimumInterval
{
	[EnumMember(Value = "year")]
	Year,
	[EnumMember(Value = "second")]
	Second,
	[EnumMember(Value = "month")]
	Month,
	[EnumMember(Value = "minute")]
	Minute,
	[EnumMember(Value = "hour")]
	Hour,
	[EnumMember(Value = "day")]
	Day
}

internal sealed partial class MinimumIntervalConverter : System.Text.Json.Serialization.JsonConverter<MinimumInterval>
{
	private static readonly System.Text.Json.JsonEncodedText MemberYear = System.Text.Json.JsonEncodedText.Encode("year");
	private static readonly System.Text.Json.JsonEncodedText MemberSecond = System.Text.Json.JsonEncodedText.Encode("second");
	private static readonly System.Text.Json.JsonEncodedText MemberMonth = System.Text.Json.JsonEncodedText.Encode("month");
	private static readonly System.Text.Json.JsonEncodedText MemberMinute = System.Text.Json.JsonEncodedText.Encode("minute");
	private static readonly System.Text.Json.JsonEncodedText MemberHour = System.Text.Json.JsonEncodedText.Encode("hour");
	private static readonly System.Text.Json.JsonEncodedText MemberDay = System.Text.Json.JsonEncodedText.Encode("day");

	public override MinimumInterval Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberYear))
		{
			return MinimumInterval.Year;
		}

		if (reader.ValueTextEquals(MemberSecond))
		{
			return MinimumInterval.Second;
		}

		if (reader.ValueTextEquals(MemberMonth))
		{
			return MinimumInterval.Month;
		}

		if (reader.ValueTextEquals(MemberMinute))
		{
			return MinimumInterval.Minute;
		}

		if (reader.ValueTextEquals(MemberHour))
		{
			return MinimumInterval.Hour;
		}

		if (reader.ValueTextEquals(MemberDay))
		{
			return MinimumInterval.Day;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberYear.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return MinimumInterval.Year;
		}

		if (string.Equals(value, MemberSecond.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return MinimumInterval.Second;
		}

		if (string.Equals(value, MemberMonth.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return MinimumInterval.Month;
		}

		if (string.Equals(value, MemberMinute.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return MinimumInterval.Minute;
		}

		if (string.Equals(value, MemberHour.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return MinimumInterval.Hour;
		}

		if (string.Equals(value, MemberDay.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return MinimumInterval.Day;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(MinimumInterval)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, MinimumInterval value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case MinimumInterval.Year:
				writer.WriteStringValue(MemberYear);
				break;
			case MinimumInterval.Second:
				writer.WriteStringValue(MemberSecond);
				break;
			case MinimumInterval.Month:
				writer.WriteStringValue(MemberMonth);
				break;
			case MinimumInterval.Minute:
				writer.WriteStringValue(MemberMinute);
				break;
			case MinimumInterval.Hour:
				writer.WriteStringValue(MemberHour);
				break;
			case MinimumInterval.Day:
				writer.WriteStringValue(MemberDay);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(MinimumInterval)}'.");
		}
	}
}

[JsonConverter(typeof(MissingOrderConverter))]
public enum MissingOrder
{
	[EnumMember(Value = "last")]
	Last,
	[EnumMember(Value = "first")]
	First,
	[EnumMember(Value = "default")]
	Default
}

internal sealed partial class MissingOrderConverter : System.Text.Json.Serialization.JsonConverter<MissingOrder>
{
	private static readonly System.Text.Json.JsonEncodedText MemberLast = System.Text.Json.JsonEncodedText.Encode("last");
	private static readonly System.Text.Json.JsonEncodedText MemberFirst = System.Text.Json.JsonEncodedText.Encode("first");
	private static readonly System.Text.Json.JsonEncodedText MemberDefault = System.Text.Json.JsonEncodedText.Encode("default");

	public override MissingOrder Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberLast))
		{
			return MissingOrder.Last;
		}

		if (reader.ValueTextEquals(MemberFirst))
		{
			return MissingOrder.First;
		}

		if (reader.ValueTextEquals(MemberDefault))
		{
			return MissingOrder.Default;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberLast.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return MissingOrder.Last;
		}

		if (string.Equals(value, MemberFirst.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return MissingOrder.First;
		}

		if (string.Equals(value, MemberDefault.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return MissingOrder.Default;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(MissingOrder)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, MissingOrder value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case MissingOrder.Last:
				writer.WriteStringValue(MemberLast);
				break;
			case MissingOrder.First:
				writer.WriteStringValue(MemberFirst);
				break;
			case MissingOrder.Default:
				writer.WriteStringValue(MemberDefault);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(MissingOrder)}'.");
		}
	}
}

[JsonConverter(typeof(NormalizeMethodConverter))]
public enum NormalizeMethod
{
	/// <summary>
	/// <para>
	/// This method normalizes such that each value represents how far it is from the mean relative to the standard deviation.
	/// </para>
	/// </summary>
	[EnumMember(Value = "z-score")]
	ZScore,
	/// <summary>
	/// <para>
	/// This method normalizes such that each value is exponentiated and relative to the sum of the exponents of the original values.
	/// </para>
	/// </summary>
	[EnumMember(Value = "softmax")]
	Softmax,
	/// <summary>
	/// <para>
	/// This method rescales the data such that the minimum number is 0, and the maximum number is 100, with the rest normalized linearly in-between.
	/// </para>
	/// </summary>
	[EnumMember(Value = "rescale_0_100")]
	Rescale0100,
	/// <summary>
	/// <para>
	/// This method rescales the data such that the minimum number is 0, and the maximum number is 1, with the rest normalized linearly in-between.
	/// </para>
	/// </summary>
	[EnumMember(Value = "rescale_0_1")]
	Rescale01,
	/// <summary>
	/// <para>
	/// This method normalizes each value so that it represents a percentage of the total sum it attributes to.
	/// </para>
	/// </summary>
	[EnumMember(Value = "percent_of_sum")]
	PercentOfSum,
	/// <summary>
	/// <para>
	/// This method normalizes such that each value is normalized by how much it differs from the average.
	/// </para>
	/// </summary>
	[EnumMember(Value = "mean")]
	Mean
}

internal sealed partial class NormalizeMethodConverter : System.Text.Json.Serialization.JsonConverter<NormalizeMethod>
{
	private static readonly System.Text.Json.JsonEncodedText MemberZScore = System.Text.Json.JsonEncodedText.Encode("z-score");
	private static readonly System.Text.Json.JsonEncodedText MemberSoftmax = System.Text.Json.JsonEncodedText.Encode("softmax");
	private static readonly System.Text.Json.JsonEncodedText MemberRescale0100 = System.Text.Json.JsonEncodedText.Encode("rescale_0_100");
	private static readonly System.Text.Json.JsonEncodedText MemberRescale01 = System.Text.Json.JsonEncodedText.Encode("rescale_0_1");
	private static readonly System.Text.Json.JsonEncodedText MemberPercentOfSum = System.Text.Json.JsonEncodedText.Encode("percent_of_sum");
	private static readonly System.Text.Json.JsonEncodedText MemberMean = System.Text.Json.JsonEncodedText.Encode("mean");

	public override NormalizeMethod Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberZScore))
		{
			return NormalizeMethod.ZScore;
		}

		if (reader.ValueTextEquals(MemberSoftmax))
		{
			return NormalizeMethod.Softmax;
		}

		if (reader.ValueTextEquals(MemberRescale0100))
		{
			return NormalizeMethod.Rescale0100;
		}

		if (reader.ValueTextEquals(MemberRescale01))
		{
			return NormalizeMethod.Rescale01;
		}

		if (reader.ValueTextEquals(MemberPercentOfSum))
		{
			return NormalizeMethod.PercentOfSum;
		}

		if (reader.ValueTextEquals(MemberMean))
		{
			return NormalizeMethod.Mean;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberZScore.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return NormalizeMethod.ZScore;
		}

		if (string.Equals(value, MemberSoftmax.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return NormalizeMethod.Softmax;
		}

		if (string.Equals(value, MemberRescale0100.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return NormalizeMethod.Rescale0100;
		}

		if (string.Equals(value, MemberRescale01.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return NormalizeMethod.Rescale01;
		}

		if (string.Equals(value, MemberPercentOfSum.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return NormalizeMethod.PercentOfSum;
		}

		if (string.Equals(value, MemberMean.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return NormalizeMethod.Mean;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(NormalizeMethod)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, NormalizeMethod value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case NormalizeMethod.ZScore:
				writer.WriteStringValue(MemberZScore);
				break;
			case NormalizeMethod.Softmax:
				writer.WriteStringValue(MemberSoftmax);
				break;
			case NormalizeMethod.Rescale0100:
				writer.WriteStringValue(MemberRescale0100);
				break;
			case NormalizeMethod.Rescale01:
				writer.WriteStringValue(MemberRescale01);
				break;
			case NormalizeMethod.PercentOfSum:
				writer.WriteStringValue(MemberPercentOfSum);
				break;
			case NormalizeMethod.Mean:
				writer.WriteStringValue(MemberMean);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(NormalizeMethod)}'.");
		}
	}
}

[JsonConverter(typeof(RateModeConverter))]
public enum RateMode
{
	/// <summary>
	/// <para>
	/// Uses the number of values of the field.
	/// </para>
	/// </summary>
	[EnumMember(Value = "value_count")]
	ValueCount,
	/// <summary>
	/// <para>
	/// Calculates the sum of all values of the field.
	/// </para>
	/// </summary>
	[EnumMember(Value = "sum")]
	Sum
}

internal sealed partial class RateModeConverter : System.Text.Json.Serialization.JsonConverter<RateMode>
{
	private static readonly System.Text.Json.JsonEncodedText MemberValueCount = System.Text.Json.JsonEncodedText.Encode("value_count");
	private static readonly System.Text.Json.JsonEncodedText MemberSum = System.Text.Json.JsonEncodedText.Encode("sum");

	public override RateMode Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberValueCount))
		{
			return RateMode.ValueCount;
		}

		if (reader.ValueTextEquals(MemberSum))
		{
			return RateMode.Sum;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberValueCount.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return RateMode.ValueCount;
		}

		if (string.Equals(value, MemberSum.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return RateMode.Sum;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(RateMode)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, RateMode value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case RateMode.ValueCount:
				writer.WriteStringValue(MemberValueCount);
				break;
			case RateMode.Sum:
				writer.WriteStringValue(MemberSum);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(RateMode)}'.");
		}
	}
}

[JsonConverter(typeof(SamplerAggregationExecutionHintConverter))]
public enum SamplerAggregationExecutionHint
{
	/// <summary>
	/// <para>
	/// Hold field values directly.
	/// </para>
	/// </summary>
	[EnumMember(Value = "map")]
	Map,
	/// <summary>
	/// <para>
	/// Hold ordinals of the field as determined by the Lucene index.
	/// </para>
	/// </summary>
	[EnumMember(Value = "global_ordinals")]
	GlobalOrdinals,
	/// <summary>
	/// <para>
	/// Hold hashes of the field values - with potential for hash collisions.
	/// </para>
	/// </summary>
	[EnumMember(Value = "bytes_hash")]
	BytesHash
}

internal sealed partial class SamplerAggregationExecutionHintConverter : System.Text.Json.Serialization.JsonConverter<SamplerAggregationExecutionHint>
{
	private static readonly System.Text.Json.JsonEncodedText MemberMap = System.Text.Json.JsonEncodedText.Encode("map");
	private static readonly System.Text.Json.JsonEncodedText MemberGlobalOrdinals = System.Text.Json.JsonEncodedText.Encode("global_ordinals");
	private static readonly System.Text.Json.JsonEncodedText MemberBytesHash = System.Text.Json.JsonEncodedText.Encode("bytes_hash");

	public override SamplerAggregationExecutionHint Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberMap))
		{
			return SamplerAggregationExecutionHint.Map;
		}

		if (reader.ValueTextEquals(MemberGlobalOrdinals))
		{
			return SamplerAggregationExecutionHint.GlobalOrdinals;
		}

		if (reader.ValueTextEquals(MemberBytesHash))
		{
			return SamplerAggregationExecutionHint.BytesHash;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberMap.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return SamplerAggregationExecutionHint.Map;
		}

		if (string.Equals(value, MemberGlobalOrdinals.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return SamplerAggregationExecutionHint.GlobalOrdinals;
		}

		if (string.Equals(value, MemberBytesHash.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return SamplerAggregationExecutionHint.BytesHash;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(SamplerAggregationExecutionHint)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, SamplerAggregationExecutionHint value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case SamplerAggregationExecutionHint.Map:
				writer.WriteStringValue(MemberMap);
				break;
			case SamplerAggregationExecutionHint.GlobalOrdinals:
				writer.WriteStringValue(MemberGlobalOrdinals);
				break;
			case SamplerAggregationExecutionHint.BytesHash:
				writer.WriteStringValue(MemberBytesHash);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(SamplerAggregationExecutionHint)}'.");
		}
	}
}

[JsonConverter(typeof(TermsAggregationCollectModeConverter))]
public enum TermsAggregationCollectMode
{
	/// <summary>
	/// <para>
	/// Expands all branches of the aggregation tree in one depth-first pass, before any pruning occurs.
	/// </para>
	/// </summary>
	[EnumMember(Value = "depth_first")]
	DepthFirst,
	/// <summary>
	/// <para>
	/// Caches the set of documents that fall into the uppermost buckets for subsequent replay.
	/// </para>
	/// </summary>
	[EnumMember(Value = "breadth_first")]
	BreadthFirst
}

internal sealed partial class TermsAggregationCollectModeConverter : System.Text.Json.Serialization.JsonConverter<TermsAggregationCollectMode>
{
	private static readonly System.Text.Json.JsonEncodedText MemberDepthFirst = System.Text.Json.JsonEncodedText.Encode("depth_first");
	private static readonly System.Text.Json.JsonEncodedText MemberBreadthFirst = System.Text.Json.JsonEncodedText.Encode("breadth_first");

	public override TermsAggregationCollectMode Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberDepthFirst))
		{
			return TermsAggregationCollectMode.DepthFirst;
		}

		if (reader.ValueTextEquals(MemberBreadthFirst))
		{
			return TermsAggregationCollectMode.BreadthFirst;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberDepthFirst.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return TermsAggregationCollectMode.DepthFirst;
		}

		if (string.Equals(value, MemberBreadthFirst.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return TermsAggregationCollectMode.BreadthFirst;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(TermsAggregationCollectMode)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, TermsAggregationCollectMode value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case TermsAggregationCollectMode.DepthFirst:
				writer.WriteStringValue(MemberDepthFirst);
				break;
			case TermsAggregationCollectMode.BreadthFirst:
				writer.WriteStringValue(MemberBreadthFirst);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(TermsAggregationCollectMode)}'.");
		}
	}
}

[JsonConverter(typeof(TermsAggregationExecutionHintConverter))]
public enum TermsAggregationExecutionHint
{
	[EnumMember(Value = "map")]
	Map,
	[EnumMember(Value = "global_ordinals_low_cardinality")]
	GlobalOrdinalsLowCardinality,
	[EnumMember(Value = "global_ordinals_hash")]
	GlobalOrdinalsHash,
	[EnumMember(Value = "global_ordinals")]
	GlobalOrdinals
}

internal sealed partial class TermsAggregationExecutionHintConverter : System.Text.Json.Serialization.JsonConverter<TermsAggregationExecutionHint>
{
	private static readonly System.Text.Json.JsonEncodedText MemberMap = System.Text.Json.JsonEncodedText.Encode("map");
	private static readonly System.Text.Json.JsonEncodedText MemberGlobalOrdinalsLowCardinality = System.Text.Json.JsonEncodedText.Encode("global_ordinals_low_cardinality");
	private static readonly System.Text.Json.JsonEncodedText MemberGlobalOrdinalsHash = System.Text.Json.JsonEncodedText.Encode("global_ordinals_hash");
	private static readonly System.Text.Json.JsonEncodedText MemberGlobalOrdinals = System.Text.Json.JsonEncodedText.Encode("global_ordinals");

	public override TermsAggregationExecutionHint Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberMap))
		{
			return TermsAggregationExecutionHint.Map;
		}

		if (reader.ValueTextEquals(MemberGlobalOrdinalsLowCardinality))
		{
			return TermsAggregationExecutionHint.GlobalOrdinalsLowCardinality;
		}

		if (reader.ValueTextEquals(MemberGlobalOrdinalsHash))
		{
			return TermsAggregationExecutionHint.GlobalOrdinalsHash;
		}

		if (reader.ValueTextEquals(MemberGlobalOrdinals))
		{
			return TermsAggregationExecutionHint.GlobalOrdinals;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberMap.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return TermsAggregationExecutionHint.Map;
		}

		if (string.Equals(value, MemberGlobalOrdinalsLowCardinality.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return TermsAggregationExecutionHint.GlobalOrdinalsLowCardinality;
		}

		if (string.Equals(value, MemberGlobalOrdinalsHash.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return TermsAggregationExecutionHint.GlobalOrdinalsHash;
		}

		if (string.Equals(value, MemberGlobalOrdinals.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return TermsAggregationExecutionHint.GlobalOrdinals;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(TermsAggregationExecutionHint)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, TermsAggregationExecutionHint value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case TermsAggregationExecutionHint.Map:
				writer.WriteStringValue(MemberMap);
				break;
			case TermsAggregationExecutionHint.GlobalOrdinalsLowCardinality:
				writer.WriteStringValue(MemberGlobalOrdinalsLowCardinality);
				break;
			case TermsAggregationExecutionHint.GlobalOrdinalsHash:
				writer.WriteStringValue(MemberGlobalOrdinalsHash);
				break;
			case TermsAggregationExecutionHint.GlobalOrdinals:
				writer.WriteStringValue(MemberGlobalOrdinals);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(TermsAggregationExecutionHint)}'.");
		}
	}
}

[JsonConverter(typeof(TTestTypeConverter))]
public enum TTestType
{
	/// <summary>
	/// <para>
	/// Performs paired t-test.
	/// </para>
	/// </summary>
	[EnumMember(Value = "paired")]
	Paired,
	/// <summary>
	/// <para>
	/// Performs two-sample equal variance test.
	/// </para>
	/// </summary>
	[EnumMember(Value = "homoscedastic")]
	Homoscedastic,
	/// <summary>
	/// <para>
	/// Performs two-sample unequal variance test.
	/// </para>
	/// </summary>
	[EnumMember(Value = "heteroscedastic")]
	Heteroscedastic
}

internal sealed partial class TTestTypeConverter : System.Text.Json.Serialization.JsonConverter<TTestType>
{
	private static readonly System.Text.Json.JsonEncodedText MemberPaired = System.Text.Json.JsonEncodedText.Encode("paired");
	private static readonly System.Text.Json.JsonEncodedText MemberHomoscedastic = System.Text.Json.JsonEncodedText.Encode("homoscedastic");
	private static readonly System.Text.Json.JsonEncodedText MemberHeteroscedastic = System.Text.Json.JsonEncodedText.Encode("heteroscedastic");

	public override TTestType Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberPaired))
		{
			return TTestType.Paired;
		}

		if (reader.ValueTextEquals(MemberHomoscedastic))
		{
			return TTestType.Homoscedastic;
		}

		if (reader.ValueTextEquals(MemberHeteroscedastic))
		{
			return TTestType.Heteroscedastic;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberPaired.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return TTestType.Paired;
		}

		if (string.Equals(value, MemberHomoscedastic.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return TTestType.Homoscedastic;
		}

		if (string.Equals(value, MemberHeteroscedastic.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return TTestType.Heteroscedastic;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(TTestType)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, TTestType value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case TTestType.Paired:
				writer.WriteStringValue(MemberPaired);
				break;
			case TTestType.Homoscedastic:
				writer.WriteStringValue(MemberHomoscedastic);
				break;
			case TTestType.Heteroscedastic:
				writer.WriteStringValue(MemberHeteroscedastic);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(TTestType)}'.");
		}
	}
}

[JsonConverter(typeof(ValueTypeConverter))]
public enum ValueType
{
	[EnumMember(Value = "string")]
	String,
	[EnumMember(Value = "numeric")]
	Numeric,
	[EnumMember(Value = "number")]
	Number,
	[EnumMember(Value = "long")]
	Long,
	[EnumMember(Value = "ip")]
	Ip,
	[EnumMember(Value = "geo_point")]
	GeoPoint,
	[EnumMember(Value = "double")]
	Double,
	[EnumMember(Value = "date_nanos")]
	DateNanos,
	[EnumMember(Value = "date")]
	Date,
	[EnumMember(Value = "boolean")]
	Boolean
}

internal sealed partial class ValueTypeConverter : System.Text.Json.Serialization.JsonConverter<ValueType>
{
	private static readonly System.Text.Json.JsonEncodedText MemberString = System.Text.Json.JsonEncodedText.Encode("string");
	private static readonly System.Text.Json.JsonEncodedText MemberNumeric = System.Text.Json.JsonEncodedText.Encode("numeric");
	private static readonly System.Text.Json.JsonEncodedText MemberNumber = System.Text.Json.JsonEncodedText.Encode("number");
	private static readonly System.Text.Json.JsonEncodedText MemberLong = System.Text.Json.JsonEncodedText.Encode("long");
	private static readonly System.Text.Json.JsonEncodedText MemberIp = System.Text.Json.JsonEncodedText.Encode("ip");
	private static readonly System.Text.Json.JsonEncodedText MemberGeoPoint = System.Text.Json.JsonEncodedText.Encode("geo_point");
	private static readonly System.Text.Json.JsonEncodedText MemberDouble = System.Text.Json.JsonEncodedText.Encode("double");
	private static readonly System.Text.Json.JsonEncodedText MemberDateNanos = System.Text.Json.JsonEncodedText.Encode("date_nanos");
	private static readonly System.Text.Json.JsonEncodedText MemberDate = System.Text.Json.JsonEncodedText.Encode("date");
	private static readonly System.Text.Json.JsonEncodedText MemberBoolean = System.Text.Json.JsonEncodedText.Encode("boolean");

	public override ValueType Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberString))
		{
			return ValueType.String;
		}

		if (reader.ValueTextEquals(MemberNumeric))
		{
			return ValueType.Numeric;
		}

		if (reader.ValueTextEquals(MemberNumber))
		{
			return ValueType.Number;
		}

		if (reader.ValueTextEquals(MemberLong))
		{
			return ValueType.Long;
		}

		if (reader.ValueTextEquals(MemberIp))
		{
			return ValueType.Ip;
		}

		if (reader.ValueTextEquals(MemberGeoPoint))
		{
			return ValueType.GeoPoint;
		}

		if (reader.ValueTextEquals(MemberDouble))
		{
			return ValueType.Double;
		}

		if (reader.ValueTextEquals(MemberDateNanos))
		{
			return ValueType.DateNanos;
		}

		if (reader.ValueTextEquals(MemberDate))
		{
			return ValueType.Date;
		}

		if (reader.ValueTextEquals(MemberBoolean))
		{
			return ValueType.Boolean;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberString.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return ValueType.String;
		}

		if (string.Equals(value, MemberNumeric.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return ValueType.Numeric;
		}

		if (string.Equals(value, MemberNumber.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return ValueType.Number;
		}

		if (string.Equals(value, MemberLong.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return ValueType.Long;
		}

		if (string.Equals(value, MemberIp.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return ValueType.Ip;
		}

		if (string.Equals(value, MemberGeoPoint.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return ValueType.GeoPoint;
		}

		if (string.Equals(value, MemberDouble.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return ValueType.Double;
		}

		if (string.Equals(value, MemberDateNanos.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return ValueType.DateNanos;
		}

		if (string.Equals(value, MemberDate.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return ValueType.Date;
		}

		if (string.Equals(value, MemberBoolean.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return ValueType.Boolean;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(ValueType)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, ValueType value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case ValueType.String:
				writer.WriteStringValue(MemberString);
				break;
			case ValueType.Numeric:
				writer.WriteStringValue(MemberNumeric);
				break;
			case ValueType.Number:
				writer.WriteStringValue(MemberNumber);
				break;
			case ValueType.Long:
				writer.WriteStringValue(MemberLong);
				break;
			case ValueType.Ip:
				writer.WriteStringValue(MemberIp);
				break;
			case ValueType.GeoPoint:
				writer.WriteStringValue(MemberGeoPoint);
				break;
			case ValueType.Double:
				writer.WriteStringValue(MemberDouble);
				break;
			case ValueType.DateNanos:
				writer.WriteStringValue(MemberDateNanos);
				break;
			case ValueType.Date:
				writer.WriteStringValue(MemberDate);
				break;
			case ValueType.Boolean:
				writer.WriteStringValue(MemberBoolean);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(ValueType)}'.");
		}
	}
}