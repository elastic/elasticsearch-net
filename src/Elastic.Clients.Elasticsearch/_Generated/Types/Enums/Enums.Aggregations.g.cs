// Licensed to Elasticsearch B.V under one or more agreements.
// Elasticsearch B.V licenses this file to you under the Apache 2.0 License.
// See the LICENSE file in the project root for more information.
//
// ███╗   ██╗ ██████╗ ████████╗██╗ ██████╗███████╗
// ████╗  ██║██╔═══██╗╚══██╔══╝██║██╔════╝██╔════╝
// ██╔██╗ ██║██║   ██║   ██║   ██║██║     █████╗
// ██║╚██╗██║██║   ██║   ██║   ██║██║     ██╔══╝
// ██║ ╚████║╚██████╔╝   ██║   ██║╚██████╗███████╗
// ╚═╝  ╚═══╝ ╚═════╝    ╚═╝   ╚═╝ ╚═════╝╚══════╝
// ------------------------------------------------
//
// This file is automatically generated.
// Please do not edit these files manually.
//
// ------------------------------------------------

using System;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Runtime.Serialization;
using Elastic.Transport;

#nullable restore
namespace Elastic.Clients.Elasticsearch.Aggregations
{
	[JsonConverter(typeof(DateIntervalConverter))]
	public enum DateInterval
	{
		Year,
		Week,
		Second,
		Quarter,
		Month,
		Minute,
		Hour,
		Day
	}

	public class DateIntervalConverter : JsonConverter<DateInterval>
	{
		public override DateInterval Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			var enumString = reader.GetString();
			switch (enumString)
			{
				case "year":
					return DateInterval.Year;
				case "week":
					return DateInterval.Week;
				case "second":
					return DateInterval.Second;
				case "quarter":
					return DateInterval.Quarter;
				case "month":
					return DateInterval.Month;
				case "minute":
					return DateInterval.Minute;
				case "hour":
					return DateInterval.Hour;
				case "day":
					return DateInterval.Day;
			}

			ThrowHelper.ThrowJsonException();
			return default;
		}

		public override void Write(Utf8JsonWriter writer, DateInterval value, JsonSerializerOptions options)
		{
			switch (value)
			{
				case DateInterval.Year:
					writer.WriteStringValue("year");
					return;
				case DateInterval.Week:
					writer.WriteStringValue("week");
					return;
				case DateInterval.Second:
					writer.WriteStringValue("second");
					return;
				case DateInterval.Quarter:
					writer.WriteStringValue("quarter");
					return;
				case DateInterval.Month:
					writer.WriteStringValue("month");
					return;
				case DateInterval.Minute:
					writer.WriteStringValue("minute");
					return;
				case DateInterval.Hour:
					writer.WriteStringValue("hour");
					return;
				case DateInterval.Day:
					writer.WriteStringValue("day");
					return;
			}

			writer.WriteNullValue();
		}
	}

	[JsonConverter(typeof(GapPolicyConverter))]
	public enum GapPolicy
	{
		Skip,
		InsertZeros
	}

	public class GapPolicyConverter : JsonConverter<GapPolicy>
	{
		public override GapPolicy Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			var enumString = reader.GetString();
			switch (enumString)
			{
				case "skip":
					return GapPolicy.Skip;
				case "insert_zeros":
					return GapPolicy.InsertZeros;
			}

			ThrowHelper.ThrowJsonException();
			return default;
		}

		public override void Write(Utf8JsonWriter writer, GapPolicy value, JsonSerializerOptions options)
		{
			switch (value)
			{
				case GapPolicy.Skip:
					writer.WriteStringValue("skip");
					return;
				case GapPolicy.InsertZeros:
					writer.WriteStringValue("insert_zeros");
					return;
			}

			writer.WriteNullValue();
		}
	}

	[JsonConverter(typeof(HoltWintersTypeConverter))]
	public enum HoltWintersType
	{
		Multiplicative,
		Additive
	}

	public class HoltWintersTypeConverter : JsonConverter<HoltWintersType>
	{
		public override HoltWintersType Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			var enumString = reader.GetString();
			switch (enumString)
			{
				case "mult":
					return HoltWintersType.Multiplicative;
				case "add":
					return HoltWintersType.Additive;
			}

			ThrowHelper.ThrowJsonException();
			return default;
		}

		public override void Write(Utf8JsonWriter writer, HoltWintersType value, JsonSerializerOptions options)
		{
			switch (value)
			{
				case HoltWintersType.Multiplicative:
					writer.WriteStringValue("mult");
					return;
				case HoltWintersType.Additive:
					writer.WriteStringValue("add");
					return;
			}

			writer.WriteNullValue();
		}
	}

	[JsonConverter(typeof(MatrixStatsModeConverter))]
	public enum MatrixStatsMode
	{
		Sum,
		Min,
		Median,
		Max,
		Avg
	}

	public class MatrixStatsModeConverter : JsonConverter<MatrixStatsMode>
	{
		public override MatrixStatsMode Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			var enumString = reader.GetString();
			switch (enumString)
			{
				case "sum":
					return MatrixStatsMode.Sum;
				case "min":
					return MatrixStatsMode.Min;
				case "median":
					return MatrixStatsMode.Median;
				case "max":
					return MatrixStatsMode.Max;
				case "avg":
					return MatrixStatsMode.Avg;
			}

			ThrowHelper.ThrowJsonException();
			return default;
		}

		public override void Write(Utf8JsonWriter writer, MatrixStatsMode value, JsonSerializerOptions options)
		{
			switch (value)
			{
				case MatrixStatsMode.Sum:
					writer.WriteStringValue("sum");
					return;
				case MatrixStatsMode.Min:
					writer.WriteStringValue("min");
					return;
				case MatrixStatsMode.Median:
					writer.WriteStringValue("median");
					return;
				case MatrixStatsMode.Max:
					writer.WriteStringValue("max");
					return;
				case MatrixStatsMode.Avg:
					writer.WriteStringValue("avg");
					return;
			}

			writer.WriteNullValue();
		}
	}

	[JsonConverter(typeof(MinimumIntervalConverter))]
	public enum MinimumInterval
	{
		Year,
		Second,
		Month,
		Minute,
		Hour,
		Day
	}

	public class MinimumIntervalConverter : JsonConverter<MinimumInterval>
	{
		public override MinimumInterval Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			var enumString = reader.GetString();
			switch (enumString)
			{
				case "year":
					return MinimumInterval.Year;
				case "second":
					return MinimumInterval.Second;
				case "month":
					return MinimumInterval.Month;
				case "minute":
					return MinimumInterval.Minute;
				case "hour":
					return MinimumInterval.Hour;
				case "day":
					return MinimumInterval.Day;
			}

			ThrowHelper.ThrowJsonException();
			return default;
		}

		public override void Write(Utf8JsonWriter writer, MinimumInterval value, JsonSerializerOptions options)
		{
			switch (value)
			{
				case MinimumInterval.Year:
					writer.WriteStringValue("year");
					return;
				case MinimumInterval.Second:
					writer.WriteStringValue("second");
					return;
				case MinimumInterval.Month:
					writer.WriteStringValue("month");
					return;
				case MinimumInterval.Minute:
					writer.WriteStringValue("minute");
					return;
				case MinimumInterval.Hour:
					writer.WriteStringValue("hour");
					return;
				case MinimumInterval.Day:
					writer.WriteStringValue("day");
					return;
			}

			writer.WriteNullValue();
		}
	}

	[JsonConverter(typeof(MissingOrderConverter))]
	public enum MissingOrder
	{
		Last,
		First,
		Default
	}

	public class MissingOrderConverter : JsonConverter<MissingOrder>
	{
		public override MissingOrder Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			var enumString = reader.GetString();
			switch (enumString)
			{
				case "last":
					return MissingOrder.Last;
				case "first":
					return MissingOrder.First;
				case "default":
					return MissingOrder.Default;
			}

			ThrowHelper.ThrowJsonException();
			return default;
		}

		public override void Write(Utf8JsonWriter writer, MissingOrder value, JsonSerializerOptions options)
		{
			switch (value)
			{
				case MissingOrder.Last:
					writer.WriteStringValue("last");
					return;
				case MissingOrder.First:
					writer.WriteStringValue("first");
					return;
				case MissingOrder.Default:
					writer.WriteStringValue("default");
					return;
			}

			writer.WriteNullValue();
		}
	}

	[JsonConverter(typeof(MovingAverageModelConverter))]
	public enum MovingAverageModel
	{
		Simple,
		Linear,
		HoltWinters,
		Holt,
		Ewma
	}

	public class MovingAverageModelConverter : JsonConverter<MovingAverageModel>
	{
		public override MovingAverageModel Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			var enumString = reader.GetString();
			switch (enumString)
			{
				case "simple":
					return MovingAverageModel.Simple;
				case "linear":
					return MovingAverageModel.Linear;
				case "holt_winters":
					return MovingAverageModel.HoltWinters;
				case "holt":
					return MovingAverageModel.Holt;
				case "ewma":
					return MovingAverageModel.Ewma;
			}

			ThrowHelper.ThrowJsonException();
			return default;
		}

		public override void Write(Utf8JsonWriter writer, MovingAverageModel value, JsonSerializerOptions options)
		{
			switch (value)
			{
				case MovingAverageModel.Simple:
					writer.WriteStringValue("simple");
					return;
				case MovingAverageModel.Linear:
					writer.WriteStringValue("linear");
					return;
				case MovingAverageModel.HoltWinters:
					writer.WriteStringValue("holt_winters");
					return;
				case MovingAverageModel.Holt:
					writer.WriteStringValue("holt");
					return;
				case MovingAverageModel.Ewma:
					writer.WriteStringValue("ewma");
					return;
			}

			writer.WriteNullValue();
		}
	}

	[JsonConverter(typeof(NormalizeMethodConverter))]
	public enum NormalizeMethod
	{
		ZScore,
		Softmax,
		Rescale0100,
		Rescale01,
		PercentOfSum,
		Mean
	}

	public class NormalizeMethodConverter : JsonConverter<NormalizeMethod>
	{
		public override NormalizeMethod Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			var enumString = reader.GetString();
			switch (enumString)
			{
				case "z-score":
					return NormalizeMethod.ZScore;
				case "softmax":
					return NormalizeMethod.Softmax;
				case "rescale_0_100":
					return NormalizeMethod.Rescale0100;
				case "rescale_0_1":
					return NormalizeMethod.Rescale01;
				case "percent_of_sum":
					return NormalizeMethod.PercentOfSum;
				case "mean":
					return NormalizeMethod.Mean;
			}

			ThrowHelper.ThrowJsonException();
			return default;
		}

		public override void Write(Utf8JsonWriter writer, NormalizeMethod value, JsonSerializerOptions options)
		{
			switch (value)
			{
				case NormalizeMethod.ZScore:
					writer.WriteStringValue("z-score");
					return;
				case NormalizeMethod.Softmax:
					writer.WriteStringValue("softmax");
					return;
				case NormalizeMethod.Rescale0100:
					writer.WriteStringValue("rescale_0_100");
					return;
				case NormalizeMethod.Rescale01:
					writer.WriteStringValue("rescale_0_1");
					return;
				case NormalizeMethod.PercentOfSum:
					writer.WriteStringValue("percent_of_sum");
					return;
				case NormalizeMethod.Mean:
					writer.WriteStringValue("mean");
					return;
			}

			writer.WriteNullValue();
		}
	}

	[JsonConverter(typeof(RateModeConverter))]
	public enum RateMode
	{
		ValueCount,
		Sum
	}

	public class RateModeConverter : JsonConverter<RateMode>
	{
		public override RateMode Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			var enumString = reader.GetString();
			switch (enumString)
			{
				case "value_count":
					return RateMode.ValueCount;
				case "sum":
					return RateMode.Sum;
			}

			ThrowHelper.ThrowJsonException();
			return default;
		}

		public override void Write(Utf8JsonWriter writer, RateMode value, JsonSerializerOptions options)
		{
			switch (value)
			{
				case RateMode.ValueCount:
					writer.WriteStringValue("value_count");
					return;
				case RateMode.Sum:
					writer.WriteStringValue("sum");
					return;
			}

			writer.WriteNullValue();
		}
	}

	[JsonConverter(typeof(SamplerAggregationExecutionHintConverter))]
	public enum SamplerAggregationExecutionHint
	{
		Map,
		GlobalOrdinals,
		BytesHash
	}

	public class SamplerAggregationExecutionHintConverter : JsonConverter<SamplerAggregationExecutionHint>
	{
		public override SamplerAggregationExecutionHint Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			var enumString = reader.GetString();
			switch (enumString)
			{
				case "map":
					return SamplerAggregationExecutionHint.Map;
				case "global_ordinals":
					return SamplerAggregationExecutionHint.GlobalOrdinals;
				case "bytes_hash":
					return SamplerAggregationExecutionHint.BytesHash;
			}

			ThrowHelper.ThrowJsonException();
			return default;
		}

		public override void Write(Utf8JsonWriter writer, SamplerAggregationExecutionHint value, JsonSerializerOptions options)
		{
			switch (value)
			{
				case SamplerAggregationExecutionHint.Map:
					writer.WriteStringValue("map");
					return;
				case SamplerAggregationExecutionHint.GlobalOrdinals:
					writer.WriteStringValue("global_ordinals");
					return;
				case SamplerAggregationExecutionHint.BytesHash:
					writer.WriteStringValue("bytes_hash");
					return;
			}

			writer.WriteNullValue();
		}
	}

	[JsonConverter(typeof(TermsAggregationCollectModeConverter))]
	public enum TermsAggregationCollectMode
	{
		DepthFirst,
		BreadthFirst
	}

	public class TermsAggregationCollectModeConverter : JsonConverter<TermsAggregationCollectMode>
	{
		public override TermsAggregationCollectMode Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			var enumString = reader.GetString();
			switch (enumString)
			{
				case "depth_first":
					return TermsAggregationCollectMode.DepthFirst;
				case "breadth_first":
					return TermsAggregationCollectMode.BreadthFirst;
			}

			ThrowHelper.ThrowJsonException();
			return default;
		}

		public override void Write(Utf8JsonWriter writer, TermsAggregationCollectMode value, JsonSerializerOptions options)
		{
			switch (value)
			{
				case TermsAggregationCollectMode.DepthFirst:
					writer.WriteStringValue("depth_first");
					return;
				case TermsAggregationCollectMode.BreadthFirst:
					writer.WriteStringValue("breadth_first");
					return;
			}

			writer.WriteNullValue();
		}
	}

	[JsonConverter(typeof(TermsAggregationExecutionHintConverter))]
	public enum TermsAggregationExecutionHint
	{
		Map,
		GlobalOrdinalsLowCardinality,
		GlobalOrdinalsHash,
		GlobalOrdinals
	}

	public class TermsAggregationExecutionHintConverter : JsonConverter<TermsAggregationExecutionHint>
	{
		public override TermsAggregationExecutionHint Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			var enumString = reader.GetString();
			switch (enumString)
			{
				case "map":
					return TermsAggregationExecutionHint.Map;
				case "global_ordinals_low_cardinality":
					return TermsAggregationExecutionHint.GlobalOrdinalsLowCardinality;
				case "global_ordinals_hash":
					return TermsAggregationExecutionHint.GlobalOrdinalsHash;
				case "global_ordinals":
					return TermsAggregationExecutionHint.GlobalOrdinals;
			}

			ThrowHelper.ThrowJsonException();
			return default;
		}

		public override void Write(Utf8JsonWriter writer, TermsAggregationExecutionHint value, JsonSerializerOptions options)
		{
			switch (value)
			{
				case TermsAggregationExecutionHint.Map:
					writer.WriteStringValue("map");
					return;
				case TermsAggregationExecutionHint.GlobalOrdinalsLowCardinality:
					writer.WriteStringValue("global_ordinals_low_cardinality");
					return;
				case TermsAggregationExecutionHint.GlobalOrdinalsHash:
					writer.WriteStringValue("global_ordinals_hash");
					return;
				case TermsAggregationExecutionHint.GlobalOrdinals:
					writer.WriteStringValue("global_ordinals");
					return;
			}

			writer.WriteNullValue();
		}
	}

	[JsonConverter(typeof(TTestTypeConverter))]
	public enum TTestType
	{
		Paired,
		Homoscedastic,
		Heteroscedastic
	}

	public class TTestTypeConverter : JsonConverter<TTestType>
	{
		public override TTestType Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			var enumString = reader.GetString();
			switch (enumString)
			{
				case "paired":
					return TTestType.Paired;
				case "homoscedastic":
					return TTestType.Homoscedastic;
				case "heteroscedastic":
					return TTestType.Heteroscedastic;
			}

			ThrowHelper.ThrowJsonException();
			return default;
		}

		public override void Write(Utf8JsonWriter writer, TTestType value, JsonSerializerOptions options)
		{
			switch (value)
			{
				case TTestType.Paired:
					writer.WriteStringValue("paired");
					return;
				case TTestType.Homoscedastic:
					writer.WriteStringValue("homoscedastic");
					return;
				case TTestType.Heteroscedastic:
					writer.WriteStringValue("heteroscedastic");
					return;
			}

			writer.WriteNullValue();
		}
	}

	[JsonConverter(typeof(ValueTypeConverter))]
	public enum ValueType
	{
		String,
		Numeric,
		Number,
		Long,
		Ip,
		GeoPoint,
		Double,
		DateNanos,
		Date,
		Boolean
	}

	public class ValueTypeConverter : JsonConverter<ValueType>
	{
		public override ValueType Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			var enumString = reader.GetString();
			switch (enumString)
			{
				case "string":
					return ValueType.String;
				case "numeric":
					return ValueType.Numeric;
				case "number":
					return ValueType.Number;
				case "long":
					return ValueType.Long;
				case "ip":
					return ValueType.Ip;
				case "geo_point":
					return ValueType.GeoPoint;
				case "double":
					return ValueType.Double;
				case "date_nanos":
					return ValueType.DateNanos;
				case "date":
					return ValueType.Date;
				case "boolean":
					return ValueType.Boolean;
			}

			ThrowHelper.ThrowJsonException();
			return default;
		}

		public override void Write(Utf8JsonWriter writer, ValueType value, JsonSerializerOptions options)
		{
			switch (value)
			{
				case ValueType.String:
					writer.WriteStringValue("string");
					return;
				case ValueType.Numeric:
					writer.WriteStringValue("numeric");
					return;
				case ValueType.Number:
					writer.WriteStringValue("number");
					return;
				case ValueType.Long:
					writer.WriteStringValue("long");
					return;
				case ValueType.Ip:
					writer.WriteStringValue("ip");
					return;
				case ValueType.GeoPoint:
					writer.WriteStringValue("geo_point");
					return;
				case ValueType.Double:
					writer.WriteStringValue("double");
					return;
				case ValueType.DateNanos:
					writer.WriteStringValue("date_nanos");
					return;
				case ValueType.Date:
					writer.WriteStringValue("date");
					return;
				case ValueType.Boolean:
					writer.WriteStringValue("boolean");
					return;
			}

			writer.WriteNullValue();
		}
	}
}