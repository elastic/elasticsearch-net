// Licensed to Elasticsearch B.V under one or more agreements.
// Elasticsearch B.V licenses this file to you under the Apache 2.0 License.
// See the LICENSE file in the project root for more information.
//
// ███╗   ██╗ ██████╗ ████████╗██╗ ██████╗███████╗
// ████╗  ██║██╔═══██╗╚══██╔══╝██║██╔════╝██╔════╝
// ██╔██╗ ██║██║   ██║   ██║   ██║██║     █████╗
// ██║╚██╗██║██║   ██║   ██║   ██║██║     ██╔══╝
// ██║ ╚████║╚██████╔╝   ██║   ██║╚██████╗███████╗
// ╚═╝  ╚═══╝ ╚═════╝    ╚═╝   ╚═╝ ╚═════╝╚══════╝
// ------------------------------------------------
//
// This file is automatically generated.
// Please do not edit these files manually.
//
// ------------------------------------------------

#nullable restore

using Elastic.Clients.Elasticsearch.Core;
using Elastic.Clients.Elasticsearch.Serialization;
using Elastic.Transport;
using System;
using System.Runtime.Serialization;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace Elastic.Clients.Elasticsearch.Ingest;

[JsonConverter(typeof(ConvertTypeConverter))]
public enum ConvertType
{
	[EnumMember(Value = "string")]
	String,
	[EnumMember(Value = "long")]
	Long,
	[EnumMember(Value = "ip")]
	Ip,
	[EnumMember(Value = "integer")]
	Integer,
	[EnumMember(Value = "float")]
	Float,
	[EnumMember(Value = "double")]
	Double,
	[EnumMember(Value = "boolean")]
	Boolean,
	[EnumMember(Value = "auto")]
	Auto
}

internal sealed class ConvertTypeConverter : JsonConverter<ConvertType>
{
	public override ConvertType Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
	{
		var enumString = reader.GetString();
		switch (enumString)
		{
			case "string":
				return ConvertType.String;
			case "long":
				return ConvertType.Long;
			case "ip":
				return ConvertType.Ip;
			case "integer":
				return ConvertType.Integer;
			case "float":
				return ConvertType.Float;
			case "double":
				return ConvertType.Double;
			case "boolean":
				return ConvertType.Boolean;
			case "auto":
				return ConvertType.Auto;
		}

		ThrowHelper.ThrowJsonException();
		return default;
	}

	public override void Write(Utf8JsonWriter writer, ConvertType value, JsonSerializerOptions options)
	{
		switch (value)
		{
			case ConvertType.String:
				writer.WriteStringValue("string");
				return;
			case ConvertType.Long:
				writer.WriteStringValue("long");
				return;
			case ConvertType.Ip:
				writer.WriteStringValue("ip");
				return;
			case ConvertType.Integer:
				writer.WriteStringValue("integer");
				return;
			case ConvertType.Float:
				writer.WriteStringValue("float");
				return;
			case ConvertType.Double:
				writer.WriteStringValue("double");
				return;
			case ConvertType.Boolean:
				writer.WriteStringValue("boolean");
				return;
			case ConvertType.Auto:
				writer.WriteStringValue("auto");
				return;
		}

		writer.WriteNullValue();
	}
}

[JsonConverter(typeof(FingerprintDigestConverter))]
public enum FingerprintDigest
{
	[EnumMember(Value = "SHA-512")]
	Sha512,
	[EnumMember(Value = "SHA-256")]
	Sha256,
	[EnumMember(Value = "SHA-1")]
	Sha1,
	[EnumMember(Value = "MurmurHash3")]
	Murmurhash3,
	[EnumMember(Value = "MD5")]
	Md5
}

internal sealed class FingerprintDigestConverter : JsonConverter<FingerprintDigest>
{
	public override FingerprintDigest Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
	{
		var enumString = reader.GetString();
		switch (enumString)
		{
			case "SHA-512":
				return FingerprintDigest.Sha512;
			case "SHA-256":
				return FingerprintDigest.Sha256;
			case "SHA-1":
				return FingerprintDigest.Sha1;
			case "MurmurHash3":
				return FingerprintDigest.Murmurhash3;
			case "MD5":
				return FingerprintDigest.Md5;
		}

		ThrowHelper.ThrowJsonException();
		return default;
	}

	public override void Write(Utf8JsonWriter writer, FingerprintDigest value, JsonSerializerOptions options)
	{
		switch (value)
		{
			case FingerprintDigest.Sha512:
				writer.WriteStringValue("SHA-512");
				return;
			case FingerprintDigest.Sha256:
				writer.WriteStringValue("SHA-256");
				return;
			case FingerprintDigest.Sha1:
				writer.WriteStringValue("SHA-1");
				return;
			case FingerprintDigest.Murmurhash3:
				writer.WriteStringValue("MurmurHash3");
				return;
			case FingerprintDigest.Md5:
				writer.WriteStringValue("MD5");
				return;
		}

		writer.WriteNullValue();
	}
}

[JsonConverter(typeof(GeoGridTargetFormatConverter))]
public enum GeoGridTargetFormat
{
	[EnumMember(Value = "wkt")]
	Wkt,
	[EnumMember(Value = "geojson")]
	Geojson
}

internal sealed class GeoGridTargetFormatConverter : JsonConverter<GeoGridTargetFormat>
{
	public override GeoGridTargetFormat Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
	{
		var enumString = reader.GetString();
		switch (enumString)
		{
			case "wkt":
				return GeoGridTargetFormat.Wkt;
			case "geojson":
				return GeoGridTargetFormat.Geojson;
		}

		ThrowHelper.ThrowJsonException();
		return default;
	}

	public override void Write(Utf8JsonWriter writer, GeoGridTargetFormat value, JsonSerializerOptions options)
	{
		switch (value)
		{
			case GeoGridTargetFormat.Wkt:
				writer.WriteStringValue("wkt");
				return;
			case GeoGridTargetFormat.Geojson:
				writer.WriteStringValue("geojson");
				return;
		}

		writer.WriteNullValue();
	}
}

[JsonConverter(typeof(GeoGridTileTypeConverter))]
public enum GeoGridTileType
{
	[EnumMember(Value = "geotile")]
	Geotile,
	[EnumMember(Value = "geohex")]
	Geohex,
	[EnumMember(Value = "geohash")]
	Geohash
}

internal sealed class GeoGridTileTypeConverter : JsonConverter<GeoGridTileType>
{
	public override GeoGridTileType Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
	{
		var enumString = reader.GetString();
		switch (enumString)
		{
			case "geotile":
				return GeoGridTileType.Geotile;
			case "geohex":
				return GeoGridTileType.Geohex;
			case "geohash":
				return GeoGridTileType.Geohash;
		}

		ThrowHelper.ThrowJsonException();
		return default;
	}

	public override void Write(Utf8JsonWriter writer, GeoGridTileType value, JsonSerializerOptions options)
	{
		switch (value)
		{
			case GeoGridTileType.Geotile:
				writer.WriteStringValue("geotile");
				return;
			case GeoGridTileType.Geohex:
				writer.WriteStringValue("geohex");
				return;
			case GeoGridTileType.Geohash:
				writer.WriteStringValue("geohash");
				return;
		}

		writer.WriteNullValue();
	}
}

[JsonConverter(typeof(JsonProcessorConflictStrategyConverter))]
public enum JsonProcessorConflictStrategy
{
	/// <summary>
	/// <para>
	/// Root fields that conflict with fields from the parsed JSON will be overridden.
	/// </para>
	/// </summary>
	[EnumMember(Value = "replace")]
	Replace,
	/// <summary>
	/// <para>
	/// Conflicting fields will be merged.
	/// </para>
	/// </summary>
	[EnumMember(Value = "merge")]
	Merge
}

internal sealed class JsonProcessorConflictStrategyConverter : JsonConverter<JsonProcessorConflictStrategy>
{
	public override JsonProcessorConflictStrategy Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
	{
		var enumString = reader.GetString();
		switch (enumString)
		{
			case "replace":
				return JsonProcessorConflictStrategy.Replace;
			case "merge":
				return JsonProcessorConflictStrategy.Merge;
		}

		ThrowHelper.ThrowJsonException();
		return default;
	}

	public override void Write(Utf8JsonWriter writer, JsonProcessorConflictStrategy value, JsonSerializerOptions options)
	{
		switch (value)
		{
			case JsonProcessorConflictStrategy.Replace:
				writer.WriteStringValue("replace");
				return;
			case JsonProcessorConflictStrategy.Merge:
				writer.WriteStringValue("merge");
				return;
		}

		writer.WriteNullValue();
	}
}

[JsonConverter(typeof(ShapeTypeConverter))]
public enum ShapeType
{
	[EnumMember(Value = "shape")]
	Shape,
	[EnumMember(Value = "geo_shape")]
	GeoShape
}

internal sealed class ShapeTypeConverter : JsonConverter<ShapeType>
{
	public override ShapeType Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
	{
		var enumString = reader.GetString();
		switch (enumString)
		{
			case "shape":
				return ShapeType.Shape;
			case "geo_shape":
				return ShapeType.GeoShape;
		}

		ThrowHelper.ThrowJsonException();
		return default;
	}

	public override void Write(Utf8JsonWriter writer, ShapeType value, JsonSerializerOptions options)
	{
		switch (value)
		{
			case ShapeType.Shape:
				writer.WriteStringValue("shape");
				return;
			case ShapeType.GeoShape:
				writer.WriteStringValue("geo_shape");
				return;
		}

		writer.WriteNullValue();
	}
}

[JsonConverter(typeof(UserAgentPropertyConverter))]
public enum UserAgentProperty
{
	[EnumMember(Value = "version")]
	Version,
	[EnumMember(Value = "os")]
	Os,
	[EnumMember(Value = "original")]
	Original,
	[EnumMember(Value = "name")]
	Name,
	[EnumMember(Value = "device")]
	Device
}

internal sealed class UserAgentPropertyConverter : JsonConverter<UserAgentProperty>
{
	public override UserAgentProperty Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
	{
		var enumString = reader.GetString();
		switch (enumString)
		{
			case "version":
				return UserAgentProperty.Version;
			case "os":
				return UserAgentProperty.Os;
			case "original":
				return UserAgentProperty.Original;
			case "name":
				return UserAgentProperty.Name;
			case "device":
				return UserAgentProperty.Device;
		}

		ThrowHelper.ThrowJsonException();
		return default;
	}

	public override void Write(Utf8JsonWriter writer, UserAgentProperty value, JsonSerializerOptions options)
	{
		switch (value)
		{
			case UserAgentProperty.Version:
				writer.WriteStringValue("version");
				return;
			case UserAgentProperty.Os:
				writer.WriteStringValue("os");
				return;
			case UserAgentProperty.Original:
				writer.WriteStringValue("original");
				return;
			case UserAgentProperty.Name:
				writer.WriteStringValue("name");
				return;
			case UserAgentProperty.Device:
				writer.WriteStringValue("device");
				return;
		}

		writer.WriteNullValue();
	}
}