// Licensed to Elasticsearch B.V under one or more agreements.
// Elasticsearch B.V licenses this file to you under the Apache 2.0 License.
// See the LICENSE file in the project root for more information.
//
// ███╗   ██╗ ██████╗ ████████╗██╗ ██████╗███████╗
// ████╗  ██║██╔═══██╗╚══██╔══╝██║██╔════╝██╔════╝
// ██╔██╗ ██║██║   ██║   ██║   ██║██║     █████╗
// ██║╚██╗██║██║   ██║   ██║   ██║██║     ██╔══╝
// ██║ ╚████║╚██████╔╝   ██║   ██║╚██████╗███████╗
// ╚═╝  ╚═══╝ ╚═════╝    ╚═╝   ╚═╝ ╚═════╝╚══════╝
// ------------------------------------------------
//
// This file is automatically generated.
// Please do not edit these files manually.
//
// ------------------------------------------------

#nullable restore

using Elastic.Clients.Elasticsearch.Core;
using Elastic.Clients.Elasticsearch.Serialization;
using Elastic.Transport;
using System;
using System.Runtime.Serialization;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace Elastic.Clients.Elasticsearch.IndexManagement;

[JsonConverter(typeof(FeatureConverter))]
public enum Feature
{
	[EnumMember(Value = "settings")]
	Settings,
	[EnumMember(Value = "mappings")]
	Mappings,
	[EnumMember(Value = "aliases")]
	Aliases
}

internal sealed partial class FeatureConverter : System.Text.Json.Serialization.JsonConverter<Feature>
{
	private static readonly System.Text.Json.JsonEncodedText MemberSettings = System.Text.Json.JsonEncodedText.Encode("settings");
	private static readonly System.Text.Json.JsonEncodedText MemberMappings = System.Text.Json.JsonEncodedText.Encode("mappings");
	private static readonly System.Text.Json.JsonEncodedText MemberAliases = System.Text.Json.JsonEncodedText.Encode("aliases");

	public override Feature Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberSettings))
		{
			return Feature.Settings;
		}

		if (reader.ValueTextEquals(MemberMappings))
		{
			return Feature.Mappings;
		}

		if (reader.ValueTextEquals(MemberAliases))
		{
			return Feature.Aliases;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberSettings.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return Feature.Settings;
		}

		if (string.Equals(value, MemberMappings.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return Feature.Mappings;
		}

		if (string.Equals(value, MemberAliases.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return Feature.Aliases;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(Feature)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, Feature value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case Feature.Settings:
				writer.WriteStringValue(MemberSettings);
				break;
			case Feature.Mappings:
				writer.WriteStringValue(MemberMappings);
				break;
			case Feature.Aliases:
				writer.WriteStringValue(MemberAliases);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(Feature)}'.");
		}
	}
}

[JsonConverter(typeof(IndexCheckOnStartupConverter))]
public enum IndexCheckOnStartup
{
	[EnumMember(Value = "true")]
	True,
	[EnumMember(Value = "false")]
	False,
	[EnumMember(Value = "checksum")]
	Checksum
}

internal sealed partial class IndexCheckOnStartupConverter : System.Text.Json.Serialization.JsonConverter<IndexCheckOnStartup>
{
	private static readonly System.Text.Json.JsonEncodedText MemberTrue = System.Text.Json.JsonEncodedText.Encode("true");
	private static readonly System.Text.Json.JsonEncodedText MemberFalse = System.Text.Json.JsonEncodedText.Encode("false");
	private static readonly System.Text.Json.JsonEncodedText MemberChecksum = System.Text.Json.JsonEncodedText.Encode("checksum");

	public override IndexCheckOnStartup Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		if (reader.ValueTextEquals(MemberTrue))
		{
			return IndexCheckOnStartup.True;
		}

		if (reader.ValueTextEquals(MemberFalse))
		{
			return IndexCheckOnStartup.False;
		}

		if (reader.ValueTextEquals(MemberChecksum))
		{
			return IndexCheckOnStartup.Checksum;
		}

		if (reader.TokenType is not System.Text.Json.JsonTokenType.String)
		{
			throw new System.Text.Json.JsonException($"Unknown member of type '{reader.TokenType}' for enum '{nameof(IndexCheckOnStartup)}'.");
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberTrue.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return IndexCheckOnStartup.True;
		}

		if (string.Equals(value, MemberFalse.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return IndexCheckOnStartup.False;
		}

		if (string.Equals(value, MemberChecksum.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return IndexCheckOnStartup.Checksum;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(IndexCheckOnStartup)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, IndexCheckOnStartup value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case IndexCheckOnStartup.True:
				writer.WriteRawValue(MemberTrue.EncodedUtf8Bytes);
				break;
			case IndexCheckOnStartup.False:
				writer.WriteRawValue(MemberFalse.EncodedUtf8Bytes);
				break;
			case IndexCheckOnStartup.Checksum:
				writer.WriteStringValue(MemberChecksum);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(IndexCheckOnStartup)}'.");
		}
	}
}

[JsonConverter(typeof(IndexMetadataStateConverter))]
public enum IndexMetadataState
{
	[EnumMember(Value = "open")]
	Open,
	[EnumMember(Value = "close")]
	Close
}

internal sealed partial class IndexMetadataStateConverter : System.Text.Json.Serialization.JsonConverter<IndexMetadataState>
{
	private static readonly System.Text.Json.JsonEncodedText MemberOpen = System.Text.Json.JsonEncodedText.Encode("open");
	private static readonly System.Text.Json.JsonEncodedText MemberClose = System.Text.Json.JsonEncodedText.Encode("close");

	public override IndexMetadataState Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberOpen))
		{
			return IndexMetadataState.Open;
		}

		if (reader.ValueTextEquals(MemberClose))
		{
			return IndexMetadataState.Close;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberOpen.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return IndexMetadataState.Open;
		}

		if (string.Equals(value, MemberClose.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return IndexMetadataState.Close;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(IndexMetadataState)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, IndexMetadataState value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case IndexMetadataState.Open:
				writer.WriteStringValue(MemberOpen);
				break;
			case IndexMetadataState.Close:
				writer.WriteStringValue(MemberClose);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(IndexMetadataState)}'.");
		}
	}
}

[JsonConverter(typeof(IndexRoutingAllocationOptionsConverter))]
public enum IndexRoutingAllocationOptions
{
	[EnumMember(Value = "primaries")]
	Primaries,
	[EnumMember(Value = "none")]
	None,
	[EnumMember(Value = "new_primaries")]
	NewPrimaries,
	[EnumMember(Value = "all")]
	All
}

internal sealed partial class IndexRoutingAllocationOptionsConverter : System.Text.Json.Serialization.JsonConverter<IndexRoutingAllocationOptions>
{
	private static readonly System.Text.Json.JsonEncodedText MemberPrimaries = System.Text.Json.JsonEncodedText.Encode("primaries");
	private static readonly System.Text.Json.JsonEncodedText MemberNone = System.Text.Json.JsonEncodedText.Encode("none");
	private static readonly System.Text.Json.JsonEncodedText MemberNewPrimaries = System.Text.Json.JsonEncodedText.Encode("new_primaries");
	private static readonly System.Text.Json.JsonEncodedText MemberAll = System.Text.Json.JsonEncodedText.Encode("all");

	public override IndexRoutingAllocationOptions Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberPrimaries))
		{
			return IndexRoutingAllocationOptions.Primaries;
		}

		if (reader.ValueTextEquals(MemberNone))
		{
			return IndexRoutingAllocationOptions.None;
		}

		if (reader.ValueTextEquals(MemberNewPrimaries))
		{
			return IndexRoutingAllocationOptions.NewPrimaries;
		}

		if (reader.ValueTextEquals(MemberAll))
		{
			return IndexRoutingAllocationOptions.All;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberPrimaries.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return IndexRoutingAllocationOptions.Primaries;
		}

		if (string.Equals(value, MemberNone.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return IndexRoutingAllocationOptions.None;
		}

		if (string.Equals(value, MemberNewPrimaries.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return IndexRoutingAllocationOptions.NewPrimaries;
		}

		if (string.Equals(value, MemberAll.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return IndexRoutingAllocationOptions.All;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(IndexRoutingAllocationOptions)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, IndexRoutingAllocationOptions value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case IndexRoutingAllocationOptions.Primaries:
				writer.WriteStringValue(MemberPrimaries);
				break;
			case IndexRoutingAllocationOptions.None:
				writer.WriteStringValue(MemberNone);
				break;
			case IndexRoutingAllocationOptions.NewPrimaries:
				writer.WriteStringValue(MemberNewPrimaries);
				break;
			case IndexRoutingAllocationOptions.All:
				writer.WriteStringValue(MemberAll);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(IndexRoutingAllocationOptions)}'.");
		}
	}
}

[JsonConverter(typeof(IndexRoutingRebalanceOptionsConverter))]
public enum IndexRoutingRebalanceOptions
{
	[EnumMember(Value = "replicas")]
	Replicas,
	[EnumMember(Value = "primaries")]
	Primaries,
	[EnumMember(Value = "none")]
	None,
	[EnumMember(Value = "all")]
	All
}

internal sealed partial class IndexRoutingRebalanceOptionsConverter : System.Text.Json.Serialization.JsonConverter<IndexRoutingRebalanceOptions>
{
	private static readonly System.Text.Json.JsonEncodedText MemberReplicas = System.Text.Json.JsonEncodedText.Encode("replicas");
	private static readonly System.Text.Json.JsonEncodedText MemberPrimaries = System.Text.Json.JsonEncodedText.Encode("primaries");
	private static readonly System.Text.Json.JsonEncodedText MemberNone = System.Text.Json.JsonEncodedText.Encode("none");
	private static readonly System.Text.Json.JsonEncodedText MemberAll = System.Text.Json.JsonEncodedText.Encode("all");

	public override IndexRoutingRebalanceOptions Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberReplicas))
		{
			return IndexRoutingRebalanceOptions.Replicas;
		}

		if (reader.ValueTextEquals(MemberPrimaries))
		{
			return IndexRoutingRebalanceOptions.Primaries;
		}

		if (reader.ValueTextEquals(MemberNone))
		{
			return IndexRoutingRebalanceOptions.None;
		}

		if (reader.ValueTextEquals(MemberAll))
		{
			return IndexRoutingRebalanceOptions.All;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberReplicas.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return IndexRoutingRebalanceOptions.Replicas;
		}

		if (string.Equals(value, MemberPrimaries.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return IndexRoutingRebalanceOptions.Primaries;
		}

		if (string.Equals(value, MemberNone.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return IndexRoutingRebalanceOptions.None;
		}

		if (string.Equals(value, MemberAll.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return IndexRoutingRebalanceOptions.All;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(IndexRoutingRebalanceOptions)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, IndexRoutingRebalanceOptions value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case IndexRoutingRebalanceOptions.Replicas:
				writer.WriteStringValue(MemberReplicas);
				break;
			case IndexRoutingRebalanceOptions.Primaries:
				writer.WriteStringValue(MemberPrimaries);
				break;
			case IndexRoutingRebalanceOptions.None:
				writer.WriteStringValue(MemberNone);
				break;
			case IndexRoutingRebalanceOptions.All:
				writer.WriteStringValue(MemberAll);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(IndexRoutingRebalanceOptions)}'.");
		}
	}
}

[JsonConverter(typeof(ManagedByConverter))]
public enum ManagedBy
{
	[EnumMember(Value = "Unmanaged")]
	Unmanaged,
	[EnumMember(Value = "Index Lifecycle Management")]
	Ilm,
	[EnumMember(Value = "Data stream lifecycle")]
	Datastream
}

internal sealed partial class ManagedByConverter : System.Text.Json.Serialization.JsonConverter<ManagedBy>
{
	private static readonly System.Text.Json.JsonEncodedText MemberUnmanaged = System.Text.Json.JsonEncodedText.Encode("Unmanaged");
	private static readonly System.Text.Json.JsonEncodedText MemberIlm = System.Text.Json.JsonEncodedText.Encode("Index Lifecycle Management");
	private static readonly System.Text.Json.JsonEncodedText MemberDatastream = System.Text.Json.JsonEncodedText.Encode("Data stream lifecycle");

	public override ManagedBy Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberUnmanaged))
		{
			return ManagedBy.Unmanaged;
		}

		if (reader.ValueTextEquals(MemberIlm))
		{
			return ManagedBy.Ilm;
		}

		if (reader.ValueTextEquals(MemberDatastream))
		{
			return ManagedBy.Datastream;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberUnmanaged.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return ManagedBy.Unmanaged;
		}

		if (string.Equals(value, MemberIlm.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return ManagedBy.Ilm;
		}

		if (string.Equals(value, MemberDatastream.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return ManagedBy.Datastream;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(ManagedBy)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, ManagedBy value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case ManagedBy.Unmanaged:
				writer.WriteStringValue(MemberUnmanaged);
				break;
			case ManagedBy.Ilm:
				writer.WriteStringValue(MemberIlm);
				break;
			case ManagedBy.Datastream:
				writer.WriteStringValue(MemberDatastream);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(ManagedBy)}'.");
		}
	}
}

[JsonConverter(typeof(NumericFielddataFormatConverter))]
public enum NumericFielddataFormat
{
	[EnumMember(Value = "disabled")]
	Disabled,
	[EnumMember(Value = "array")]
	Array
}

internal sealed partial class NumericFielddataFormatConverter : System.Text.Json.Serialization.JsonConverter<NumericFielddataFormat>
{
	private static readonly System.Text.Json.JsonEncodedText MemberDisabled = System.Text.Json.JsonEncodedText.Encode("disabled");
	private static readonly System.Text.Json.JsonEncodedText MemberArray = System.Text.Json.JsonEncodedText.Encode("array");

	public override NumericFielddataFormat Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberDisabled))
		{
			return NumericFielddataFormat.Disabled;
		}

		if (reader.ValueTextEquals(MemberArray))
		{
			return NumericFielddataFormat.Array;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberDisabled.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return NumericFielddataFormat.Disabled;
		}

		if (string.Equals(value, MemberArray.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return NumericFielddataFormat.Array;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(NumericFielddataFormat)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, NumericFielddataFormat value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case NumericFielddataFormat.Disabled:
				writer.WriteStringValue(MemberDisabled);
				break;
			case NumericFielddataFormat.Array:
				writer.WriteStringValue(MemberArray);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(NumericFielddataFormat)}'.");
		}
	}
}

[JsonConverter(typeof(SegmentSortMissingConverter))]
public enum SegmentSortMissing
{
	[EnumMember(Value = "_last")]
	Last,
	[EnumMember(Value = "_first")]
	First
}

internal sealed partial class SegmentSortMissingConverter : System.Text.Json.Serialization.JsonConverter<SegmentSortMissing>
{
	private static readonly System.Text.Json.JsonEncodedText MemberLast = System.Text.Json.JsonEncodedText.Encode("_last");
	private static readonly System.Text.Json.JsonEncodedText MemberFirst = System.Text.Json.JsonEncodedText.Encode("_first");

	public override SegmentSortMissing Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberLast))
		{
			return SegmentSortMissing.Last;
		}

		if (reader.ValueTextEquals(MemberFirst))
		{
			return SegmentSortMissing.First;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberLast.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return SegmentSortMissing.Last;
		}

		if (string.Equals(value, MemberFirst.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return SegmentSortMissing.First;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(SegmentSortMissing)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, SegmentSortMissing value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case SegmentSortMissing.Last:
				writer.WriteStringValue(MemberLast);
				break;
			case SegmentSortMissing.First:
				writer.WriteStringValue(MemberFirst);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(SegmentSortMissing)}'.");
		}
	}
}

[JsonConverter(typeof(SegmentSortModeConverter))]
public enum SegmentSortMode
{
	[EnumMember(Value = "min")]
	Min,
	[EnumMember(Value = "max")]
	Max
}

internal sealed partial class SegmentSortModeConverter : System.Text.Json.Serialization.JsonConverter<SegmentSortMode>
{
	private static readonly System.Text.Json.JsonEncodedText MemberMin = System.Text.Json.JsonEncodedText.Encode("min");
	private static readonly System.Text.Json.JsonEncodedText MemberMin1 = System.Text.Json.JsonEncodedText.Encode("MIN");
	private static readonly System.Text.Json.JsonEncodedText MemberMax = System.Text.Json.JsonEncodedText.Encode("max");
	private static readonly System.Text.Json.JsonEncodedText MemberMax1 = System.Text.Json.JsonEncodedText.Encode("MAX");

	public override SegmentSortMode Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberMin) || reader.ValueTextEquals(MemberMin1))
		{
			return SegmentSortMode.Min;
		}

		if (reader.ValueTextEquals(MemberMax) || reader.ValueTextEquals(MemberMax1))
		{
			return SegmentSortMode.Max;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberMin.Value, System.StringComparison.OrdinalIgnoreCase) || string.Equals(value, MemberMin1.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return SegmentSortMode.Min;
		}

		if (string.Equals(value, MemberMax.Value, System.StringComparison.OrdinalIgnoreCase) || string.Equals(value, MemberMax1.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return SegmentSortMode.Max;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(SegmentSortMode)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, SegmentSortMode value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case SegmentSortMode.Min:
				writer.WriteStringValue(MemberMin);
				break;
			case SegmentSortMode.Max:
				writer.WriteStringValue(MemberMax);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(SegmentSortMode)}'.");
		}
	}
}

[JsonConverter(typeof(SegmentSortOrderConverter))]
public enum SegmentSortOrder
{
	[EnumMember(Value = "desc")]
	Desc,
	[EnumMember(Value = "asc")]
	Asc
}

internal sealed partial class SegmentSortOrderConverter : System.Text.Json.Serialization.JsonConverter<SegmentSortOrder>
{
	private static readonly System.Text.Json.JsonEncodedText MemberDesc = System.Text.Json.JsonEncodedText.Encode("desc");
	private static readonly System.Text.Json.JsonEncodedText MemberDesc1 = System.Text.Json.JsonEncodedText.Encode("DESC");
	private static readonly System.Text.Json.JsonEncodedText MemberAsc = System.Text.Json.JsonEncodedText.Encode("asc");
	private static readonly System.Text.Json.JsonEncodedText MemberAsc1 = System.Text.Json.JsonEncodedText.Encode("ASC");

	public override SegmentSortOrder Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberDesc) || reader.ValueTextEquals(MemberDesc1))
		{
			return SegmentSortOrder.Desc;
		}

		if (reader.ValueTextEquals(MemberAsc) || reader.ValueTextEquals(MemberAsc1))
		{
			return SegmentSortOrder.Asc;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberDesc.Value, System.StringComparison.OrdinalIgnoreCase) || string.Equals(value, MemberDesc1.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return SegmentSortOrder.Desc;
		}

		if (string.Equals(value, MemberAsc.Value, System.StringComparison.OrdinalIgnoreCase) || string.Equals(value, MemberAsc1.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return SegmentSortOrder.Asc;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(SegmentSortOrder)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, SegmentSortOrder value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case SegmentSortOrder.Desc:
				writer.WriteStringValue(MemberDesc);
				break;
			case SegmentSortOrder.Asc:
				writer.WriteStringValue(MemberAsc);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(SegmentSortOrder)}'.");
		}
	}
}

[JsonConverter(typeof(ShardRoutingStateConverter))]
public enum ShardRoutingState
{
	[EnumMember(Value = "UNASSIGNED")]
	Unassigned,
	[EnumMember(Value = "STARTED")]
	Started,
	[EnumMember(Value = "RELOCATING")]
	Relocating,
	[EnumMember(Value = "INITIALIZING")]
	Initializing
}

internal sealed partial class ShardRoutingStateConverter : System.Text.Json.Serialization.JsonConverter<ShardRoutingState>
{
	private static readonly System.Text.Json.JsonEncodedText MemberUnassigned = System.Text.Json.JsonEncodedText.Encode("UNASSIGNED");
	private static readonly System.Text.Json.JsonEncodedText MemberStarted = System.Text.Json.JsonEncodedText.Encode("STARTED");
	private static readonly System.Text.Json.JsonEncodedText MemberRelocating = System.Text.Json.JsonEncodedText.Encode("RELOCATING");
	private static readonly System.Text.Json.JsonEncodedText MemberInitializing = System.Text.Json.JsonEncodedText.Encode("INITIALIZING");

	public override ShardRoutingState Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberUnassigned))
		{
			return ShardRoutingState.Unassigned;
		}

		if (reader.ValueTextEquals(MemberStarted))
		{
			return ShardRoutingState.Started;
		}

		if (reader.ValueTextEquals(MemberRelocating))
		{
			return ShardRoutingState.Relocating;
		}

		if (reader.ValueTextEquals(MemberInitializing))
		{
			return ShardRoutingState.Initializing;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberUnassigned.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return ShardRoutingState.Unassigned;
		}

		if (string.Equals(value, MemberStarted.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return ShardRoutingState.Started;
		}

		if (string.Equals(value, MemberRelocating.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return ShardRoutingState.Relocating;
		}

		if (string.Equals(value, MemberInitializing.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return ShardRoutingState.Initializing;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(ShardRoutingState)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, ShardRoutingState value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case ShardRoutingState.Unassigned:
				writer.WriteStringValue(MemberUnassigned);
				break;
			case ShardRoutingState.Started:
				writer.WriteStringValue(MemberStarted);
				break;
			case ShardRoutingState.Relocating:
				writer.WriteStringValue(MemberRelocating);
				break;
			case ShardRoutingState.Initializing:
				writer.WriteStringValue(MemberInitializing);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(ShardRoutingState)}'.");
		}
	}
}

[JsonConverter(typeof(ShardStoreAllocationConverter))]
public enum ShardStoreAllocation
{
	[EnumMember(Value = "unused")]
	Unused,
	[EnumMember(Value = "replica")]
	Replica,
	[EnumMember(Value = "primary")]
	Primary
}

internal sealed partial class ShardStoreAllocationConverter : System.Text.Json.Serialization.JsonConverter<ShardStoreAllocation>
{
	private static readonly System.Text.Json.JsonEncodedText MemberUnused = System.Text.Json.JsonEncodedText.Encode("unused");
	private static readonly System.Text.Json.JsonEncodedText MemberReplica = System.Text.Json.JsonEncodedText.Encode("replica");
	private static readonly System.Text.Json.JsonEncodedText MemberPrimary = System.Text.Json.JsonEncodedText.Encode("primary");

	public override ShardStoreAllocation Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberUnused))
		{
			return ShardStoreAllocation.Unused;
		}

		if (reader.ValueTextEquals(MemberReplica))
		{
			return ShardStoreAllocation.Replica;
		}

		if (reader.ValueTextEquals(MemberPrimary))
		{
			return ShardStoreAllocation.Primary;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberUnused.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return ShardStoreAllocation.Unused;
		}

		if (string.Equals(value, MemberReplica.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return ShardStoreAllocation.Replica;
		}

		if (string.Equals(value, MemberPrimary.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return ShardStoreAllocation.Primary;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(ShardStoreAllocation)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, ShardStoreAllocation value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case ShardStoreAllocation.Unused:
				writer.WriteStringValue(MemberUnused);
				break;
			case ShardStoreAllocation.Replica:
				writer.WriteStringValue(MemberReplica);
				break;
			case ShardStoreAllocation.Primary:
				writer.WriteStringValue(MemberPrimary);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(ShardStoreAllocation)}'.");
		}
	}
}

[JsonConverter(typeof(ShardStoreStatusConverter))]
public enum ShardStoreStatus
{
	/// <summary>
	/// <para>
	/// One or more replica shards are unassigned.
	/// </para>
	/// </summary>
	[EnumMember(Value = "yellow")]
	Yellow,
	/// <summary>
	/// <para>
	/// The primary shard is unassigned.
	/// </para>
	/// </summary>
	[EnumMember(Value = "red")]
	Red,
	/// <summary>
	/// <para>
	/// The primary shard and all replica shards are assigned.
	/// </para>
	/// </summary>
	[EnumMember(Value = "green")]
	Green,
	/// <summary>
	/// <para>
	/// Return all shards, regardless of health status.
	/// </para>
	/// </summary>
	[EnumMember(Value = "all")]
	All
}

internal sealed partial class ShardStoreStatusConverter : System.Text.Json.Serialization.JsonConverter<ShardStoreStatus>
{
	private static readonly System.Text.Json.JsonEncodedText MemberYellow = System.Text.Json.JsonEncodedText.Encode("yellow");
	private static readonly System.Text.Json.JsonEncodedText MemberRed = System.Text.Json.JsonEncodedText.Encode("red");
	private static readonly System.Text.Json.JsonEncodedText MemberGreen = System.Text.Json.JsonEncodedText.Encode("green");
	private static readonly System.Text.Json.JsonEncodedText MemberAll = System.Text.Json.JsonEncodedText.Encode("all");

	public override ShardStoreStatus Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberYellow))
		{
			return ShardStoreStatus.Yellow;
		}

		if (reader.ValueTextEquals(MemberRed))
		{
			return ShardStoreStatus.Red;
		}

		if (reader.ValueTextEquals(MemberGreen))
		{
			return ShardStoreStatus.Green;
		}

		if (reader.ValueTextEquals(MemberAll))
		{
			return ShardStoreStatus.All;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberYellow.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return ShardStoreStatus.Yellow;
		}

		if (string.Equals(value, MemberRed.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return ShardStoreStatus.Red;
		}

		if (string.Equals(value, MemberGreen.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return ShardStoreStatus.Green;
		}

		if (string.Equals(value, MemberAll.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return ShardStoreStatus.All;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(ShardStoreStatus)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, ShardStoreStatus value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case ShardStoreStatus.Yellow:
				writer.WriteStringValue(MemberYellow);
				break;
			case ShardStoreStatus.Red:
				writer.WriteStringValue(MemberRed);
				break;
			case ShardStoreStatus.Green:
				writer.WriteStringValue(MemberGreen);
				break;
			case ShardStoreStatus.All:
				writer.WriteStringValue(MemberAll);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(ShardStoreStatus)}'.");
		}
	}
}

[JsonConverter(typeof(EnumStructConverter<StorageType>))]
public readonly partial struct StorageType : IEnumStruct<StorageType>
{
	public StorageType(string value) => Value = value;
#if NET7_0_OR_GREATER
	static StorageType IEnumStruct<StorageType>.Create(string value) => value;
#else
	StorageType IEnumStruct<StorageType>.Create(string value) => value;
#endif
	public readonly string Value { get; }

	/// <summary>
	/// <para>
	/// The NIO FS type stores the shard index on the file system (maps to Lucene NIOFSDirectory) using NIO. It allows multiple
	/// threads to read from the same file concurrently. It is not recommended on Windows because of a bug in the SUN Java
	/// implementation and disables some optimizations for heap memory usage.
	/// </para>
	/// </summary>
	public static StorageType Niofs { get; } = new StorageType("niofs");

	/// <summary>
	/// <para>
	/// The MMap FS type stores the shard index on the file system (maps to Lucene MMapDirectory) by mapping a file into
	/// memory (mmap). Memory mapping uses up a portion of the virtual memory address space in your process equal to the size
	/// of the file being mapped. Before using this class, be sure you have allowed plenty of virtual address space.
	/// </para>
	/// </summary>
	public static StorageType Mmapfs { get; } = new StorageType("mmapfs");

	/// <summary>
	/// <para>
	/// The hybridfs type is a hybrid of niofs and mmapfs, which chooses the best file system type for each type of file
	/// based on the read access pattern. Currently only the Lucene term dictionary, norms and doc values files are memory
	/// mapped. All other files are opened using Lucene NIOFSDirectory. Similarly to mmapfs be sure you have allowed
	/// plenty of virtual address space.
	/// </para>
	/// </summary>
	public static StorageType Hybridfs { get; } = new StorageType("hybridfs");

	/// <summary>
	/// <para>
	/// Default file system implementation. This will pick the best implementation depending on the operating environment, which
	/// is currently hybridfs on all supported systems but is subject to change.
	/// </para>
	/// </summary>
	public static StorageType Fs { get; } = new StorageType("fs");

	public override string ToString() => Value ?? string.Empty;

	public static implicit operator string(StorageType storageType) => storageType.Value;
	public static implicit operator StorageType(string value) => new(value);

	public override int GetHashCode() => Value.GetHashCode();
	public override bool Equals(object obj) => obj is StorageType other && this.Equals(other);
	public bool Equals(StorageType other) => Value == other.Value;

	public static bool operator ==(StorageType a, StorageType b) => a.Equals(b);
	public static bool operator !=(StorageType a, StorageType b) => !(a == b);
}

[JsonConverter(typeof(TranslogDurabilityConverter))]
public enum TranslogDurability
{
	/// <summary>
	/// <para>
	/// (default) fsync and commit after every request. In the event of hardware failure, all acknowledged writes
	/// will already have been committed to disk.
	/// </para>
	/// </summary>
	[EnumMember(Value = "request")]
	Request,
	/// <summary>
	/// <para>
	/// fsync and commit in the background every sync_interval. In the event of a failure, all acknowledged writes
	/// since the last automatic commit will be discarded.
	/// </para>
	/// </summary>
	[EnumMember(Value = "async")]
	Async
}

internal sealed partial class TranslogDurabilityConverter : System.Text.Json.Serialization.JsonConverter<TranslogDurability>
{
	private static readonly System.Text.Json.JsonEncodedText MemberRequest = System.Text.Json.JsonEncodedText.Encode("request");
	private static readonly System.Text.Json.JsonEncodedText MemberRequest1 = System.Text.Json.JsonEncodedText.Encode("REQUEST");
	private static readonly System.Text.Json.JsonEncodedText MemberAsync = System.Text.Json.JsonEncodedText.Encode("async");
	private static readonly System.Text.Json.JsonEncodedText MemberAsync1 = System.Text.Json.JsonEncodedText.Encode("ASYNC");

	public override TranslogDurability Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberRequest) || reader.ValueTextEquals(MemberRequest1))
		{
			return TranslogDurability.Request;
		}

		if (reader.ValueTextEquals(MemberAsync) || reader.ValueTextEquals(MemberAsync1))
		{
			return TranslogDurability.Async;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberRequest.Value, System.StringComparison.OrdinalIgnoreCase) || string.Equals(value, MemberRequest1.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return TranslogDurability.Request;
		}

		if (string.Equals(value, MemberAsync.Value, System.StringComparison.OrdinalIgnoreCase) || string.Equals(value, MemberAsync1.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return TranslogDurability.Async;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(TranslogDurability)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, TranslogDurability value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case TranslogDurability.Request:
				writer.WriteStringValue(MemberRequest);
				break;
			case TranslogDurability.Async:
				writer.WriteStringValue(MemberAsync);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(TranslogDurability)}'.");
		}
	}
}