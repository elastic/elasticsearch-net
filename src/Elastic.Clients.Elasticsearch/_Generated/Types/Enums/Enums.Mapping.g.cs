// Licensed to Elasticsearch B.V under one or more agreements.
// Elasticsearch B.V licenses this file to you under the Apache 2.0 License.
// See the LICENSE file in the project root for more information.
//
// ███╗   ██╗ ██████╗ ████████╗██╗ ██████╗███████╗
// ████╗  ██║██╔═══██╗╚══██╔══╝██║██╔════╝██╔════╝
// ██╔██╗ ██║██║   ██║   ██║   ██║██║     █████╗
// ██║╚██╗██║██║   ██║   ██║   ██║██║     ██╔══╝
// ██║ ╚████║╚██████╔╝   ██║   ██║╚██████╗███████╗
// ╚═╝  ╚═══╝ ╚═════╝    ╚═╝   ╚═╝ ╚═════╝╚══════╝
// ------------------------------------------------
//
// This file is automatically generated.
// Please do not edit these files manually.
//
// ------------------------------------------------

#nullable restore

using Elastic.Clients.Elasticsearch.Core;
using Elastic.Clients.Elasticsearch.Serialization;
using Elastic.Transport;
using System;
using System.Runtime.Serialization;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace Elastic.Clients.Elasticsearch.Mapping;

[JsonConverter(typeof(DenseVectorElementTypeConverter))]
public enum DenseVectorElementType
{
	/// <summary>
	/// <para>
	/// Indexes a 4-byte floating-point value per dimension.
	/// </para>
	/// </summary>
	[EnumMember(Value = "float")]
	Float,
	/// <summary>
	/// <para>
	/// Indexes a 1-byte integer value per dimension.
	/// </para>
	/// </summary>
	[EnumMember(Value = "byte")]
	Byte,
	/// <summary>
	/// <para>
	/// Indexes a single bit per dimension. Useful for very high-dimensional vectors or models that specifically support
	/// bit vectors.
	/// </para>
	/// <para>
	/// NOTE: when using <c>bit</c>, the number of dimensions must be a multiple of <c>8</c> and must represent the number of bits.
	/// </para>
	/// </summary>
	[EnumMember(Value = "bit")]
	Bit
}

internal sealed partial class DenseVectorElementTypeConverter : System.Text.Json.Serialization.JsonConverter<DenseVectorElementType>
{
	private static readonly System.Text.Json.JsonEncodedText MemberFloat = System.Text.Json.JsonEncodedText.Encode("float");
	private static readonly System.Text.Json.JsonEncodedText MemberByte = System.Text.Json.JsonEncodedText.Encode("byte");
	private static readonly System.Text.Json.JsonEncodedText MemberBit = System.Text.Json.JsonEncodedText.Encode("bit");

	public override DenseVectorElementType Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberFloat))
		{
			return DenseVectorElementType.Float;
		}

		if (reader.ValueTextEquals(MemberByte))
		{
			return DenseVectorElementType.Byte;
		}

		if (reader.ValueTextEquals(MemberBit))
		{
			return DenseVectorElementType.Bit;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberFloat.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return DenseVectorElementType.Float;
		}

		if (string.Equals(value, MemberByte.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return DenseVectorElementType.Byte;
		}

		if (string.Equals(value, MemberBit.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return DenseVectorElementType.Bit;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(DenseVectorElementType)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, DenseVectorElementType value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case DenseVectorElementType.Float:
				writer.WriteStringValue(MemberFloat);
				break;
			case DenseVectorElementType.Byte:
				writer.WriteStringValue(MemberByte);
				break;
			case DenseVectorElementType.Bit:
				writer.WriteStringValue(MemberBit);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(DenseVectorElementType)}'.");
		}
	}
}

[JsonConverter(typeof(DenseVectorIndexOptionsTypeConverter))]
public enum DenseVectorIndexOptionsType
{
	/// <summary>
	/// <para>
	/// The default index type for <c>float</c> vectors. This utilizes the HNSW algorithm in addition to automatically scalar
	/// quantization for scalable approximate kNN search with <c>element_type</c> of <c>float</c>.
	/// </para>
	/// <para>
	/// This can reduce the memory footprint by 4x at the cost of some accuracy.
	/// </para>
	/// </summary>
	[EnumMember(Value = "int8_hnsw")]
	Int8Hnsw,
	/// <summary>
	/// <para>
	/// This utilizes a brute-force search algorithm in addition to automatically scalar quantization. Only supports
	/// <c>element_type</c> of <c>float</c>.
	/// </para>
	/// </summary>
	[EnumMember(Value = "int8_flat")]
	Int8Flat,
	/// <summary>
	/// <para>
	/// This utilizes the HNSW algorithm in addition to automatically scalar quantization for scalable approximate kNN
	/// search with <c>element_type</c> of <c>float</c>.
	/// </para>
	/// <para>
	/// This can reduce the memory footprint by 8x at the cost of some accuracy.
	/// </para>
	/// </summary>
	[EnumMember(Value = "int4_hnsw")]
	Int4Hnsw,
	/// <summary>
	/// <para>
	/// This utilizes a brute-force search algorithm in addition to automatically half-byte scalar quantization.
	/// Only supports <c>element_type</c> of <c>float</c>.
	/// </para>
	/// </summary>
	[EnumMember(Value = "int4_flat")]
	Int4Flat,
	/// <summary>
	/// <para>
	/// This utilizes the HNSW algorithm for scalable approximate kNN search. This supports all <c>element_type</c> values.
	/// </para>
	/// </summary>
	[EnumMember(Value = "hnsw")]
	Hnsw,
	/// <summary>
	/// <para>
	/// This utilizes a brute-force search algorithm for exact kNN search. This supports all <c>element_type</c> values.
	/// </para>
	/// </summary>
	[EnumMember(Value = "flat")]
	Flat
}

internal sealed partial class DenseVectorIndexOptionsTypeConverter : System.Text.Json.Serialization.JsonConverter<DenseVectorIndexOptionsType>
{
	private static readonly System.Text.Json.JsonEncodedText MemberInt8Hnsw = System.Text.Json.JsonEncodedText.Encode("int8_hnsw");
	private static readonly System.Text.Json.JsonEncodedText MemberInt8Flat = System.Text.Json.JsonEncodedText.Encode("int8_flat");
	private static readonly System.Text.Json.JsonEncodedText MemberInt4Hnsw = System.Text.Json.JsonEncodedText.Encode("int4_hnsw");
	private static readonly System.Text.Json.JsonEncodedText MemberInt4Flat = System.Text.Json.JsonEncodedText.Encode("int4_flat");
	private static readonly System.Text.Json.JsonEncodedText MemberHnsw = System.Text.Json.JsonEncodedText.Encode("hnsw");
	private static readonly System.Text.Json.JsonEncodedText MemberFlat = System.Text.Json.JsonEncodedText.Encode("flat");

	public override DenseVectorIndexOptionsType Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberInt8Hnsw))
		{
			return DenseVectorIndexOptionsType.Int8Hnsw;
		}

		if (reader.ValueTextEquals(MemberInt8Flat))
		{
			return DenseVectorIndexOptionsType.Int8Flat;
		}

		if (reader.ValueTextEquals(MemberInt4Hnsw))
		{
			return DenseVectorIndexOptionsType.Int4Hnsw;
		}

		if (reader.ValueTextEquals(MemberInt4Flat))
		{
			return DenseVectorIndexOptionsType.Int4Flat;
		}

		if (reader.ValueTextEquals(MemberHnsw))
		{
			return DenseVectorIndexOptionsType.Hnsw;
		}

		if (reader.ValueTextEquals(MemberFlat))
		{
			return DenseVectorIndexOptionsType.Flat;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberInt8Hnsw.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return DenseVectorIndexOptionsType.Int8Hnsw;
		}

		if (string.Equals(value, MemberInt8Flat.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return DenseVectorIndexOptionsType.Int8Flat;
		}

		if (string.Equals(value, MemberInt4Hnsw.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return DenseVectorIndexOptionsType.Int4Hnsw;
		}

		if (string.Equals(value, MemberInt4Flat.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return DenseVectorIndexOptionsType.Int4Flat;
		}

		if (string.Equals(value, MemberHnsw.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return DenseVectorIndexOptionsType.Hnsw;
		}

		if (string.Equals(value, MemberFlat.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return DenseVectorIndexOptionsType.Flat;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(DenseVectorIndexOptionsType)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, DenseVectorIndexOptionsType value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case DenseVectorIndexOptionsType.Int8Hnsw:
				writer.WriteStringValue(MemberInt8Hnsw);
				break;
			case DenseVectorIndexOptionsType.Int8Flat:
				writer.WriteStringValue(MemberInt8Flat);
				break;
			case DenseVectorIndexOptionsType.Int4Hnsw:
				writer.WriteStringValue(MemberInt4Hnsw);
				break;
			case DenseVectorIndexOptionsType.Int4Flat:
				writer.WriteStringValue(MemberInt4Flat);
				break;
			case DenseVectorIndexOptionsType.Hnsw:
				writer.WriteStringValue(MemberHnsw);
				break;
			case DenseVectorIndexOptionsType.Flat:
				writer.WriteStringValue(MemberFlat);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(DenseVectorIndexOptionsType)}'.");
		}
	}
}

[JsonConverter(typeof(DenseVectorSimilarityConverter))]
public enum DenseVectorSimilarity
{
	/// <summary>
	/// <para>
	/// Computes the maximum inner product of two vectors. This is similar to <c>dot_product</c>, but doesn't require vectors
	/// to be normalized. This means that each vector’s magnitude can significantly effect the score.
	/// </para>
	/// <para>
	/// The document <c>_score</c> is adjusted to prevent negative values. For <c>max_inner_product</c> values <c>&lt; 0</c>, the <c>_score</c>
	/// is <c>1 / (1 + -1 * max_inner_product(query, vector))</c>. For non-negative <c>max_inner_product</c> results the <c>_score</c>
	/// is calculated <c>max_inner_product(query, vector) + 1</c>.
	/// </para>
	/// </summary>
	[EnumMember(Value = "max_inner_product")]
	MaxInnerProduct,
	/// <summary>
	/// <para>
	/// Computes similarity based on the <c>L2</c> distance (also known as Euclidean distance) between the vectors.
	/// </para>
	/// <para>
	/// The document <c>_score</c> is computed as <c>1 / (1 + l2_norm(query, vector)^2)</c>.
	/// </para>
	/// <para>
	/// For <c>bit</c> vectors, instead of using <c>l2_norm</c>, the <c>hamming</c> distance between the vectors is used.
	/// </para>
	/// <para>
	/// The <c>_score</c> transformation is <c>(numBits - hamming(a, b)) / numBits</c>.
	/// </para>
	/// </summary>
	[EnumMember(Value = "l2_norm")]
	L2Norm,
	/// <summary>
	/// <para>
	/// Computes the dot product of two unit vectors. This option provides an optimized way to perform cosine similarity.
	/// The constraints and computed score are defined by <c>element_type</c>.
	/// </para>
	/// <para>
	/// When <c>element_type</c> is <c>float</c>, all vectors must be unit length, including both document and query vectors.
	/// </para>
	/// <para>
	/// The document <c>_score</c> is computed as <c>(1 + dot_product(query, vector)) / 2</c>.
	/// </para>
	/// <para>
	/// When <c>element_type</c> is <c>byte</c>, all vectors must have the same length including both document and query vectors or
	/// results will be inaccurate.
	/// </para>
	/// <para>
	/// The document <c>_score</c> is computed as <c>0.5 + (dot_product(query, vector) / (32768 * dims))</c> where <c>dims</c> is the
	/// number of dimensions per vector.
	/// </para>
	/// </summary>
	[EnumMember(Value = "dot_product")]
	DotProduct,
	/// <summary>
	/// <para>
	/// Computes the cosine similarity. During indexing Elasticsearch automatically normalizes vectors with <c>cosine</c>
	/// similarity to unit length. This allows to internally use <c>dot_product</c> for computing similarity, which is more
	/// efficient. Original un-normalized vectors can be still accessed through scripts.
	/// </para>
	/// <para>
	/// The document <c>_score</c> is computed as <c>(1 + cosine(query, vector)) / 2</c>.
	/// </para>
	/// <para>
	/// The <c>cosine</c> similarity does not allow vectors with zero magnitude, since cosine is not defined in this case.
	/// </para>
	/// </summary>
	[EnumMember(Value = "cosine")]
	Cosine
}

internal sealed partial class DenseVectorSimilarityConverter : System.Text.Json.Serialization.JsonConverter<DenseVectorSimilarity>
{
	private static readonly System.Text.Json.JsonEncodedText MemberMaxInnerProduct = System.Text.Json.JsonEncodedText.Encode("max_inner_product");
	private static readonly System.Text.Json.JsonEncodedText MemberL2Norm = System.Text.Json.JsonEncodedText.Encode("l2_norm");
	private static readonly System.Text.Json.JsonEncodedText MemberDotProduct = System.Text.Json.JsonEncodedText.Encode("dot_product");
	private static readonly System.Text.Json.JsonEncodedText MemberCosine = System.Text.Json.JsonEncodedText.Encode("cosine");

	public override DenseVectorSimilarity Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberMaxInnerProduct))
		{
			return DenseVectorSimilarity.MaxInnerProduct;
		}

		if (reader.ValueTextEquals(MemberL2Norm))
		{
			return DenseVectorSimilarity.L2Norm;
		}

		if (reader.ValueTextEquals(MemberDotProduct))
		{
			return DenseVectorSimilarity.DotProduct;
		}

		if (reader.ValueTextEquals(MemberCosine))
		{
			return DenseVectorSimilarity.Cosine;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberMaxInnerProduct.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return DenseVectorSimilarity.MaxInnerProduct;
		}

		if (string.Equals(value, MemberL2Norm.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return DenseVectorSimilarity.L2Norm;
		}

		if (string.Equals(value, MemberDotProduct.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return DenseVectorSimilarity.DotProduct;
		}

		if (string.Equals(value, MemberCosine.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return DenseVectorSimilarity.Cosine;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(DenseVectorSimilarity)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, DenseVectorSimilarity value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case DenseVectorSimilarity.MaxInnerProduct:
				writer.WriteStringValue(MemberMaxInnerProduct);
				break;
			case DenseVectorSimilarity.L2Norm:
				writer.WriteStringValue(MemberL2Norm);
				break;
			case DenseVectorSimilarity.DotProduct:
				writer.WriteStringValue(MemberDotProduct);
				break;
			case DenseVectorSimilarity.Cosine:
				writer.WriteStringValue(MemberCosine);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(DenseVectorSimilarity)}'.");
		}
	}
}

[JsonConverter(typeof(DynamicMappingConverter))]
public enum DynamicMapping
{
	[EnumMember(Value = "true")]
	True,
	[EnumMember(Value = "strict")]
	Strict,
	[EnumMember(Value = "runtime")]
	Runtime,
	[EnumMember(Value = "false")]
	False
}

internal sealed partial class DynamicMappingConverter : System.Text.Json.Serialization.JsonConverter<DynamicMapping>
{
	private static readonly System.Text.Json.JsonEncodedText MemberTrue = System.Text.Json.JsonEncodedText.Encode("true");
	private static readonly System.Text.Json.JsonEncodedText MemberStrict = System.Text.Json.JsonEncodedText.Encode("strict");
	private static readonly System.Text.Json.JsonEncodedText MemberRuntime = System.Text.Json.JsonEncodedText.Encode("runtime");
	private static readonly System.Text.Json.JsonEncodedText MemberFalse = System.Text.Json.JsonEncodedText.Encode("false");

	public override DynamicMapping Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		if (reader.ValueTextEquals(MemberTrue))
		{
			return DynamicMapping.True;
		}

		if (reader.ValueTextEquals(MemberStrict))
		{
			return DynamicMapping.Strict;
		}

		if (reader.ValueTextEquals(MemberRuntime))
		{
			return DynamicMapping.Runtime;
		}

		if (reader.ValueTextEquals(MemberFalse))
		{
			return DynamicMapping.False;
		}

		if (reader.TokenType is not System.Text.Json.JsonTokenType.String)
		{
			throw new System.Text.Json.JsonException($"Unknown member of type '{reader.TokenType}' for enum '{nameof(DynamicMapping)}'.");
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberTrue.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return DynamicMapping.True;
		}

		if (string.Equals(value, MemberStrict.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return DynamicMapping.Strict;
		}

		if (string.Equals(value, MemberRuntime.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return DynamicMapping.Runtime;
		}

		if (string.Equals(value, MemberFalse.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return DynamicMapping.False;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(DynamicMapping)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, DynamicMapping value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case DynamicMapping.True:
				writer.WriteRawValue(MemberTrue.EncodedUtf8Bytes);
				break;
			case DynamicMapping.Strict:
				writer.WriteStringValue(MemberStrict);
				break;
			case DynamicMapping.Runtime:
				writer.WriteStringValue(MemberRuntime);
				break;
			case DynamicMapping.False:
				writer.WriteRawValue(MemberFalse.EncodedUtf8Bytes);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(DynamicMapping)}'.");
		}
	}
}

[JsonConverter(typeof(FieldTypeConverter))]
public enum FieldType
{
	[EnumMember(Value = "version")]
	Version,
	[EnumMember(Value = "token_count")]
	TokenCount,
	[EnumMember(Value = "text")]
	Text,
	[EnumMember(Value = "sparse_vector")]
	SparseVector,
	[EnumMember(Value = "short")]
	Short,
	[EnumMember(Value = "shape")]
	Shape,
	[EnumMember(Value = "semantic_text")]
	SemanticText,
	[EnumMember(Value = "search_as_you_type")]
	SearchAsYouType,
	[EnumMember(Value = "scaled_float")]
	ScaledFloat,
	[EnumMember(Value = "rank_features")]
	RankFeatures,
	[EnumMember(Value = "rank_feature")]
	RankFeature,
	[EnumMember(Value = "percolator")]
	Percolator,
	[EnumMember(Value = "passthrough")]
	Passthrough,
	[EnumMember(Value = "object")]
	Object,
	[EnumMember(Value = "none")]
	None,
	[EnumMember(Value = "nested")]
	Nested,
	[EnumMember(Value = "murmur3")]
	Murmur3,
	[EnumMember(Value = "match_only_text")]
	MatchOnlyText,
	[EnumMember(Value = "long_range")]
	LongRange,
	[EnumMember(Value = "long")]
	Long,
	[EnumMember(Value = "keyword")]
	Keyword,
	[EnumMember(Value = "join")]
	Join,
	[EnumMember(Value = "ip_range")]
	IpRange,
	[EnumMember(Value = "ip")]
	Ip,
	[EnumMember(Value = "integer_range")]
	IntegerRange,
	[EnumMember(Value = "integer")]
	Integer,
	[EnumMember(Value = "icu_collation_keyword")]
	IcuCollationKeyword,
	[EnumMember(Value = "histogram")]
	Histogram,
	[EnumMember(Value = "half_float")]
	HalfFloat,
	[EnumMember(Value = "geo_shape")]
	GeoShape,
	[EnumMember(Value = "geo_point")]
	GeoPoint,
	[EnumMember(Value = "float_range")]
	FloatRange,
	[EnumMember(Value = "float")]
	Float,
	[EnumMember(Value = "flattened")]
	Flattened,
	[EnumMember(Value = "double_range")]
	DoubleRange,
	[EnumMember(Value = "double")]
	Double,
	[EnumMember(Value = "dense_vector")]
	DenseVector,
	[EnumMember(Value = "date_range")]
	DateRange,
	[EnumMember(Value = "date_nanos")]
	DateNanos,
	[EnumMember(Value = "date")]
	Date,
	[EnumMember(Value = "constant_keyword")]
	ConstantKeyword,
	[EnumMember(Value = "completion")]
	Completion,
	[EnumMember(Value = "byte")]
	Byte,
	[EnumMember(Value = "boolean")]
	Boolean,
	[EnumMember(Value = "binary")]
	Binary,
	[EnumMember(Value = "alias")]
	Alias,
	[EnumMember(Value = "aggregate_metric_double")]
	AggregateMetricDouble
}

internal sealed partial class FieldTypeConverter : System.Text.Json.Serialization.JsonConverter<FieldType>
{
	private static readonly System.Text.Json.JsonEncodedText MemberVersion = System.Text.Json.JsonEncodedText.Encode("version");
	private static readonly System.Text.Json.JsonEncodedText MemberTokenCount = System.Text.Json.JsonEncodedText.Encode("token_count");
	private static readonly System.Text.Json.JsonEncodedText MemberText = System.Text.Json.JsonEncodedText.Encode("text");
	private static readonly System.Text.Json.JsonEncodedText MemberSparseVector = System.Text.Json.JsonEncodedText.Encode("sparse_vector");
	private static readonly System.Text.Json.JsonEncodedText MemberShort = System.Text.Json.JsonEncodedText.Encode("short");
	private static readonly System.Text.Json.JsonEncodedText MemberShape = System.Text.Json.JsonEncodedText.Encode("shape");
	private static readonly System.Text.Json.JsonEncodedText MemberSemanticText = System.Text.Json.JsonEncodedText.Encode("semantic_text");
	private static readonly System.Text.Json.JsonEncodedText MemberSearchAsYouType = System.Text.Json.JsonEncodedText.Encode("search_as_you_type");
	private static readonly System.Text.Json.JsonEncodedText MemberScaledFloat = System.Text.Json.JsonEncodedText.Encode("scaled_float");
	private static readonly System.Text.Json.JsonEncodedText MemberRankFeatures = System.Text.Json.JsonEncodedText.Encode("rank_features");
	private static readonly System.Text.Json.JsonEncodedText MemberRankFeature = System.Text.Json.JsonEncodedText.Encode("rank_feature");
	private static readonly System.Text.Json.JsonEncodedText MemberPercolator = System.Text.Json.JsonEncodedText.Encode("percolator");
	private static readonly System.Text.Json.JsonEncodedText MemberPassthrough = System.Text.Json.JsonEncodedText.Encode("passthrough");
	private static readonly System.Text.Json.JsonEncodedText MemberObject = System.Text.Json.JsonEncodedText.Encode("object");
	private static readonly System.Text.Json.JsonEncodedText MemberNone = System.Text.Json.JsonEncodedText.Encode("none");
	private static readonly System.Text.Json.JsonEncodedText MemberNested = System.Text.Json.JsonEncodedText.Encode("nested");
	private static readonly System.Text.Json.JsonEncodedText MemberMurmur3 = System.Text.Json.JsonEncodedText.Encode("murmur3");
	private static readonly System.Text.Json.JsonEncodedText MemberMatchOnlyText = System.Text.Json.JsonEncodedText.Encode("match_only_text");
	private static readonly System.Text.Json.JsonEncodedText MemberLongRange = System.Text.Json.JsonEncodedText.Encode("long_range");
	private static readonly System.Text.Json.JsonEncodedText MemberLong = System.Text.Json.JsonEncodedText.Encode("long");
	private static readonly System.Text.Json.JsonEncodedText MemberKeyword = System.Text.Json.JsonEncodedText.Encode("keyword");
	private static readonly System.Text.Json.JsonEncodedText MemberJoin = System.Text.Json.JsonEncodedText.Encode("join");
	private static readonly System.Text.Json.JsonEncodedText MemberIpRange = System.Text.Json.JsonEncodedText.Encode("ip_range");
	private static readonly System.Text.Json.JsonEncodedText MemberIp = System.Text.Json.JsonEncodedText.Encode("ip");
	private static readonly System.Text.Json.JsonEncodedText MemberIntegerRange = System.Text.Json.JsonEncodedText.Encode("integer_range");
	private static readonly System.Text.Json.JsonEncodedText MemberInteger = System.Text.Json.JsonEncodedText.Encode("integer");
	private static readonly System.Text.Json.JsonEncodedText MemberIcuCollationKeyword = System.Text.Json.JsonEncodedText.Encode("icu_collation_keyword");
	private static readonly System.Text.Json.JsonEncodedText MemberHistogram = System.Text.Json.JsonEncodedText.Encode("histogram");
	private static readonly System.Text.Json.JsonEncodedText MemberHalfFloat = System.Text.Json.JsonEncodedText.Encode("half_float");
	private static readonly System.Text.Json.JsonEncodedText MemberGeoShape = System.Text.Json.JsonEncodedText.Encode("geo_shape");
	private static readonly System.Text.Json.JsonEncodedText MemberGeoPoint = System.Text.Json.JsonEncodedText.Encode("geo_point");
	private static readonly System.Text.Json.JsonEncodedText MemberFloatRange = System.Text.Json.JsonEncodedText.Encode("float_range");
	private static readonly System.Text.Json.JsonEncodedText MemberFloat = System.Text.Json.JsonEncodedText.Encode("float");
	private static readonly System.Text.Json.JsonEncodedText MemberFlattened = System.Text.Json.JsonEncodedText.Encode("flattened");
	private static readonly System.Text.Json.JsonEncodedText MemberDoubleRange = System.Text.Json.JsonEncodedText.Encode("double_range");
	private static readonly System.Text.Json.JsonEncodedText MemberDouble = System.Text.Json.JsonEncodedText.Encode("double");
	private static readonly System.Text.Json.JsonEncodedText MemberDenseVector = System.Text.Json.JsonEncodedText.Encode("dense_vector");
	private static readonly System.Text.Json.JsonEncodedText MemberDateRange = System.Text.Json.JsonEncodedText.Encode("date_range");
	private static readonly System.Text.Json.JsonEncodedText MemberDateNanos = System.Text.Json.JsonEncodedText.Encode("date_nanos");
	private static readonly System.Text.Json.JsonEncodedText MemberDate = System.Text.Json.JsonEncodedText.Encode("date");
	private static readonly System.Text.Json.JsonEncodedText MemberConstantKeyword = System.Text.Json.JsonEncodedText.Encode("constant_keyword");
	private static readonly System.Text.Json.JsonEncodedText MemberCompletion = System.Text.Json.JsonEncodedText.Encode("completion");
	private static readonly System.Text.Json.JsonEncodedText MemberByte = System.Text.Json.JsonEncodedText.Encode("byte");
	private static readonly System.Text.Json.JsonEncodedText MemberBoolean = System.Text.Json.JsonEncodedText.Encode("boolean");
	private static readonly System.Text.Json.JsonEncodedText MemberBinary = System.Text.Json.JsonEncodedText.Encode("binary");
	private static readonly System.Text.Json.JsonEncodedText MemberAlias = System.Text.Json.JsonEncodedText.Encode("alias");
	private static readonly System.Text.Json.JsonEncodedText MemberAggregateMetricDouble = System.Text.Json.JsonEncodedText.Encode("aggregate_metric_double");

	public override FieldType Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberVersion))
		{
			return FieldType.Version;
		}

		if (reader.ValueTextEquals(MemberTokenCount))
		{
			return FieldType.TokenCount;
		}

		if (reader.ValueTextEquals(MemberText))
		{
			return FieldType.Text;
		}

		if (reader.ValueTextEquals(MemberSparseVector))
		{
			return FieldType.SparseVector;
		}

		if (reader.ValueTextEquals(MemberShort))
		{
			return FieldType.Short;
		}

		if (reader.ValueTextEquals(MemberShape))
		{
			return FieldType.Shape;
		}

		if (reader.ValueTextEquals(MemberSemanticText))
		{
			return FieldType.SemanticText;
		}

		if (reader.ValueTextEquals(MemberSearchAsYouType))
		{
			return FieldType.SearchAsYouType;
		}

		if (reader.ValueTextEquals(MemberScaledFloat))
		{
			return FieldType.ScaledFloat;
		}

		if (reader.ValueTextEquals(MemberRankFeatures))
		{
			return FieldType.RankFeatures;
		}

		if (reader.ValueTextEquals(MemberRankFeature))
		{
			return FieldType.RankFeature;
		}

		if (reader.ValueTextEquals(MemberPercolator))
		{
			return FieldType.Percolator;
		}

		if (reader.ValueTextEquals(MemberPassthrough))
		{
			return FieldType.Passthrough;
		}

		if (reader.ValueTextEquals(MemberObject))
		{
			return FieldType.Object;
		}

		if (reader.ValueTextEquals(MemberNone))
		{
			return FieldType.None;
		}

		if (reader.ValueTextEquals(MemberNested))
		{
			return FieldType.Nested;
		}

		if (reader.ValueTextEquals(MemberMurmur3))
		{
			return FieldType.Murmur3;
		}

		if (reader.ValueTextEquals(MemberMatchOnlyText))
		{
			return FieldType.MatchOnlyText;
		}

		if (reader.ValueTextEquals(MemberLongRange))
		{
			return FieldType.LongRange;
		}

		if (reader.ValueTextEquals(MemberLong))
		{
			return FieldType.Long;
		}

		if (reader.ValueTextEquals(MemberKeyword))
		{
			return FieldType.Keyword;
		}

		if (reader.ValueTextEquals(MemberJoin))
		{
			return FieldType.Join;
		}

		if (reader.ValueTextEquals(MemberIpRange))
		{
			return FieldType.IpRange;
		}

		if (reader.ValueTextEquals(MemberIp))
		{
			return FieldType.Ip;
		}

		if (reader.ValueTextEquals(MemberIntegerRange))
		{
			return FieldType.IntegerRange;
		}

		if (reader.ValueTextEquals(MemberInteger))
		{
			return FieldType.Integer;
		}

		if (reader.ValueTextEquals(MemberIcuCollationKeyword))
		{
			return FieldType.IcuCollationKeyword;
		}

		if (reader.ValueTextEquals(MemberHistogram))
		{
			return FieldType.Histogram;
		}

		if (reader.ValueTextEquals(MemberHalfFloat))
		{
			return FieldType.HalfFloat;
		}

		if (reader.ValueTextEquals(MemberGeoShape))
		{
			return FieldType.GeoShape;
		}

		if (reader.ValueTextEquals(MemberGeoPoint))
		{
			return FieldType.GeoPoint;
		}

		if (reader.ValueTextEquals(MemberFloatRange))
		{
			return FieldType.FloatRange;
		}

		if (reader.ValueTextEquals(MemberFloat))
		{
			return FieldType.Float;
		}

		if (reader.ValueTextEquals(MemberFlattened))
		{
			return FieldType.Flattened;
		}

		if (reader.ValueTextEquals(MemberDoubleRange))
		{
			return FieldType.DoubleRange;
		}

		if (reader.ValueTextEquals(MemberDouble))
		{
			return FieldType.Double;
		}

		if (reader.ValueTextEquals(MemberDenseVector))
		{
			return FieldType.DenseVector;
		}

		if (reader.ValueTextEquals(MemberDateRange))
		{
			return FieldType.DateRange;
		}

		if (reader.ValueTextEquals(MemberDateNanos))
		{
			return FieldType.DateNanos;
		}

		if (reader.ValueTextEquals(MemberDate))
		{
			return FieldType.Date;
		}

		if (reader.ValueTextEquals(MemberConstantKeyword))
		{
			return FieldType.ConstantKeyword;
		}

		if (reader.ValueTextEquals(MemberCompletion))
		{
			return FieldType.Completion;
		}

		if (reader.ValueTextEquals(MemberByte))
		{
			return FieldType.Byte;
		}

		if (reader.ValueTextEquals(MemberBoolean))
		{
			return FieldType.Boolean;
		}

		if (reader.ValueTextEquals(MemberBinary))
		{
			return FieldType.Binary;
		}

		if (reader.ValueTextEquals(MemberAlias))
		{
			return FieldType.Alias;
		}

		if (reader.ValueTextEquals(MemberAggregateMetricDouble))
		{
			return FieldType.AggregateMetricDouble;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberVersion.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return FieldType.Version;
		}

		if (string.Equals(value, MemberTokenCount.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return FieldType.TokenCount;
		}

		if (string.Equals(value, MemberText.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return FieldType.Text;
		}

		if (string.Equals(value, MemberSparseVector.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return FieldType.SparseVector;
		}

		if (string.Equals(value, MemberShort.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return FieldType.Short;
		}

		if (string.Equals(value, MemberShape.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return FieldType.Shape;
		}

		if (string.Equals(value, MemberSemanticText.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return FieldType.SemanticText;
		}

		if (string.Equals(value, MemberSearchAsYouType.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return FieldType.SearchAsYouType;
		}

		if (string.Equals(value, MemberScaledFloat.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return FieldType.ScaledFloat;
		}

		if (string.Equals(value, MemberRankFeatures.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return FieldType.RankFeatures;
		}

		if (string.Equals(value, MemberRankFeature.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return FieldType.RankFeature;
		}

		if (string.Equals(value, MemberPercolator.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return FieldType.Percolator;
		}

		if (string.Equals(value, MemberPassthrough.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return FieldType.Passthrough;
		}

		if (string.Equals(value, MemberObject.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return FieldType.Object;
		}

		if (string.Equals(value, MemberNone.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return FieldType.None;
		}

		if (string.Equals(value, MemberNested.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return FieldType.Nested;
		}

		if (string.Equals(value, MemberMurmur3.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return FieldType.Murmur3;
		}

		if (string.Equals(value, MemberMatchOnlyText.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return FieldType.MatchOnlyText;
		}

		if (string.Equals(value, MemberLongRange.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return FieldType.LongRange;
		}

		if (string.Equals(value, MemberLong.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return FieldType.Long;
		}

		if (string.Equals(value, MemberKeyword.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return FieldType.Keyword;
		}

		if (string.Equals(value, MemberJoin.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return FieldType.Join;
		}

		if (string.Equals(value, MemberIpRange.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return FieldType.IpRange;
		}

		if (string.Equals(value, MemberIp.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return FieldType.Ip;
		}

		if (string.Equals(value, MemberIntegerRange.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return FieldType.IntegerRange;
		}

		if (string.Equals(value, MemberInteger.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return FieldType.Integer;
		}

		if (string.Equals(value, MemberIcuCollationKeyword.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return FieldType.IcuCollationKeyword;
		}

		if (string.Equals(value, MemberHistogram.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return FieldType.Histogram;
		}

		if (string.Equals(value, MemberHalfFloat.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return FieldType.HalfFloat;
		}

		if (string.Equals(value, MemberGeoShape.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return FieldType.GeoShape;
		}

		if (string.Equals(value, MemberGeoPoint.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return FieldType.GeoPoint;
		}

		if (string.Equals(value, MemberFloatRange.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return FieldType.FloatRange;
		}

		if (string.Equals(value, MemberFloat.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return FieldType.Float;
		}

		if (string.Equals(value, MemberFlattened.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return FieldType.Flattened;
		}

		if (string.Equals(value, MemberDoubleRange.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return FieldType.DoubleRange;
		}

		if (string.Equals(value, MemberDouble.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return FieldType.Double;
		}

		if (string.Equals(value, MemberDenseVector.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return FieldType.DenseVector;
		}

		if (string.Equals(value, MemberDateRange.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return FieldType.DateRange;
		}

		if (string.Equals(value, MemberDateNanos.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return FieldType.DateNanos;
		}

		if (string.Equals(value, MemberDate.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return FieldType.Date;
		}

		if (string.Equals(value, MemberConstantKeyword.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return FieldType.ConstantKeyword;
		}

		if (string.Equals(value, MemberCompletion.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return FieldType.Completion;
		}

		if (string.Equals(value, MemberByte.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return FieldType.Byte;
		}

		if (string.Equals(value, MemberBoolean.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return FieldType.Boolean;
		}

		if (string.Equals(value, MemberBinary.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return FieldType.Binary;
		}

		if (string.Equals(value, MemberAlias.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return FieldType.Alias;
		}

		if (string.Equals(value, MemberAggregateMetricDouble.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return FieldType.AggregateMetricDouble;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(FieldType)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, FieldType value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case FieldType.Version:
				writer.WriteStringValue(MemberVersion);
				break;
			case FieldType.TokenCount:
				writer.WriteStringValue(MemberTokenCount);
				break;
			case FieldType.Text:
				writer.WriteStringValue(MemberText);
				break;
			case FieldType.SparseVector:
				writer.WriteStringValue(MemberSparseVector);
				break;
			case FieldType.Short:
				writer.WriteStringValue(MemberShort);
				break;
			case FieldType.Shape:
				writer.WriteStringValue(MemberShape);
				break;
			case FieldType.SemanticText:
				writer.WriteStringValue(MemberSemanticText);
				break;
			case FieldType.SearchAsYouType:
				writer.WriteStringValue(MemberSearchAsYouType);
				break;
			case FieldType.ScaledFloat:
				writer.WriteStringValue(MemberScaledFloat);
				break;
			case FieldType.RankFeatures:
				writer.WriteStringValue(MemberRankFeatures);
				break;
			case FieldType.RankFeature:
				writer.WriteStringValue(MemberRankFeature);
				break;
			case FieldType.Percolator:
				writer.WriteStringValue(MemberPercolator);
				break;
			case FieldType.Passthrough:
				writer.WriteStringValue(MemberPassthrough);
				break;
			case FieldType.Object:
				writer.WriteStringValue(MemberObject);
				break;
			case FieldType.None:
				writer.WriteStringValue(MemberNone);
				break;
			case FieldType.Nested:
				writer.WriteStringValue(MemberNested);
				break;
			case FieldType.Murmur3:
				writer.WriteStringValue(MemberMurmur3);
				break;
			case FieldType.MatchOnlyText:
				writer.WriteStringValue(MemberMatchOnlyText);
				break;
			case FieldType.LongRange:
				writer.WriteStringValue(MemberLongRange);
				break;
			case FieldType.Long:
				writer.WriteStringValue(MemberLong);
				break;
			case FieldType.Keyword:
				writer.WriteStringValue(MemberKeyword);
				break;
			case FieldType.Join:
				writer.WriteStringValue(MemberJoin);
				break;
			case FieldType.IpRange:
				writer.WriteStringValue(MemberIpRange);
				break;
			case FieldType.Ip:
				writer.WriteStringValue(MemberIp);
				break;
			case FieldType.IntegerRange:
				writer.WriteStringValue(MemberIntegerRange);
				break;
			case FieldType.Integer:
				writer.WriteStringValue(MemberInteger);
				break;
			case FieldType.IcuCollationKeyword:
				writer.WriteStringValue(MemberIcuCollationKeyword);
				break;
			case FieldType.Histogram:
				writer.WriteStringValue(MemberHistogram);
				break;
			case FieldType.HalfFloat:
				writer.WriteStringValue(MemberHalfFloat);
				break;
			case FieldType.GeoShape:
				writer.WriteStringValue(MemberGeoShape);
				break;
			case FieldType.GeoPoint:
				writer.WriteStringValue(MemberGeoPoint);
				break;
			case FieldType.FloatRange:
				writer.WriteStringValue(MemberFloatRange);
				break;
			case FieldType.Float:
				writer.WriteStringValue(MemberFloat);
				break;
			case FieldType.Flattened:
				writer.WriteStringValue(MemberFlattened);
				break;
			case FieldType.DoubleRange:
				writer.WriteStringValue(MemberDoubleRange);
				break;
			case FieldType.Double:
				writer.WriteStringValue(MemberDouble);
				break;
			case FieldType.DenseVector:
				writer.WriteStringValue(MemberDenseVector);
				break;
			case FieldType.DateRange:
				writer.WriteStringValue(MemberDateRange);
				break;
			case FieldType.DateNanos:
				writer.WriteStringValue(MemberDateNanos);
				break;
			case FieldType.Date:
				writer.WriteStringValue(MemberDate);
				break;
			case FieldType.ConstantKeyword:
				writer.WriteStringValue(MemberConstantKeyword);
				break;
			case FieldType.Completion:
				writer.WriteStringValue(MemberCompletion);
				break;
			case FieldType.Byte:
				writer.WriteStringValue(MemberByte);
				break;
			case FieldType.Boolean:
				writer.WriteStringValue(MemberBoolean);
				break;
			case FieldType.Binary:
				writer.WriteStringValue(MemberBinary);
				break;
			case FieldType.Alias:
				writer.WriteStringValue(MemberAlias);
				break;
			case FieldType.AggregateMetricDouble:
				writer.WriteStringValue(MemberAggregateMetricDouble);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(FieldType)}'.");
		}
	}
}

[JsonConverter(typeof(GeoOrientationConverter))]
public enum GeoOrientation
{
	[EnumMember(Value = "right")]
	Right,
	[EnumMember(Value = "left")]
	Left
}

internal sealed partial class GeoOrientationConverter : System.Text.Json.Serialization.JsonConverter<GeoOrientation>
{
	private static readonly System.Text.Json.JsonEncodedText MemberRight = System.Text.Json.JsonEncodedText.Encode("right");
	private static readonly System.Text.Json.JsonEncodedText MemberRight1 = System.Text.Json.JsonEncodedText.Encode("RIGHT");
	private static readonly System.Text.Json.JsonEncodedText MemberRight2 = System.Text.Json.JsonEncodedText.Encode("counterclockwise");
	private static readonly System.Text.Json.JsonEncodedText MemberRight3 = System.Text.Json.JsonEncodedText.Encode("ccw");
	private static readonly System.Text.Json.JsonEncodedText MemberLeft = System.Text.Json.JsonEncodedText.Encode("left");
	private static readonly System.Text.Json.JsonEncodedText MemberLeft1 = System.Text.Json.JsonEncodedText.Encode("LEFT");
	private static readonly System.Text.Json.JsonEncodedText MemberLeft2 = System.Text.Json.JsonEncodedText.Encode("clockwise");
	private static readonly System.Text.Json.JsonEncodedText MemberLeft3 = System.Text.Json.JsonEncodedText.Encode("cw");

	public override GeoOrientation Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberRight) || reader.ValueTextEquals(MemberRight1) || reader.ValueTextEquals(MemberRight2) || reader.ValueTextEquals(MemberRight3))
		{
			return GeoOrientation.Right;
		}

		if (reader.ValueTextEquals(MemberLeft) || reader.ValueTextEquals(MemberLeft1) || reader.ValueTextEquals(MemberLeft2) || reader.ValueTextEquals(MemberLeft3))
		{
			return GeoOrientation.Left;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberRight.Value, System.StringComparison.OrdinalIgnoreCase) || string.Equals(value, MemberRight1.Value, System.StringComparison.OrdinalIgnoreCase) || string.Equals(value, MemberRight2.Value, System.StringComparison.OrdinalIgnoreCase) || string.Equals(value, MemberRight3.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return GeoOrientation.Right;
		}

		if (string.Equals(value, MemberLeft.Value, System.StringComparison.OrdinalIgnoreCase) || string.Equals(value, MemberLeft1.Value, System.StringComparison.OrdinalIgnoreCase) || string.Equals(value, MemberLeft2.Value, System.StringComparison.OrdinalIgnoreCase) || string.Equals(value, MemberLeft3.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return GeoOrientation.Left;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(GeoOrientation)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, GeoOrientation value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case GeoOrientation.Right:
				writer.WriteStringValue(MemberRight);
				break;
			case GeoOrientation.Left:
				writer.WriteStringValue(MemberLeft);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(GeoOrientation)}'.");
		}
	}
}

[JsonConverter(typeof(GeoStrategyConverter))]
public enum GeoStrategy
{
	[EnumMember(Value = "term")]
	Term,
	[EnumMember(Value = "recursive")]
	Recursive
}

internal sealed partial class GeoStrategyConverter : System.Text.Json.Serialization.JsonConverter<GeoStrategy>
{
	private static readonly System.Text.Json.JsonEncodedText MemberTerm = System.Text.Json.JsonEncodedText.Encode("term");
	private static readonly System.Text.Json.JsonEncodedText MemberRecursive = System.Text.Json.JsonEncodedText.Encode("recursive");

	public override GeoStrategy Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberTerm))
		{
			return GeoStrategy.Term;
		}

		if (reader.ValueTextEquals(MemberRecursive))
		{
			return GeoStrategy.Recursive;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberTerm.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return GeoStrategy.Term;
		}

		if (string.Equals(value, MemberRecursive.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return GeoStrategy.Recursive;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(GeoStrategy)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, GeoStrategy value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case GeoStrategy.Term:
				writer.WriteStringValue(MemberTerm);
				break;
			case GeoStrategy.Recursive:
				writer.WriteStringValue(MemberRecursive);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(GeoStrategy)}'.");
		}
	}
}

[JsonConverter(typeof(IndexOptionsConverter))]
public enum IndexOptions
{
	[EnumMember(Value = "positions")]
	Positions,
	[EnumMember(Value = "offsets")]
	Offsets,
	[EnumMember(Value = "freqs")]
	Freqs,
	[EnumMember(Value = "docs")]
	Docs
}

internal sealed partial class IndexOptionsConverter : System.Text.Json.Serialization.JsonConverter<IndexOptions>
{
	private static readonly System.Text.Json.JsonEncodedText MemberPositions = System.Text.Json.JsonEncodedText.Encode("positions");
	private static readonly System.Text.Json.JsonEncodedText MemberOffsets = System.Text.Json.JsonEncodedText.Encode("offsets");
	private static readonly System.Text.Json.JsonEncodedText MemberFreqs = System.Text.Json.JsonEncodedText.Encode("freqs");
	private static readonly System.Text.Json.JsonEncodedText MemberDocs = System.Text.Json.JsonEncodedText.Encode("docs");

	public override IndexOptions Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberPositions))
		{
			return IndexOptions.Positions;
		}

		if (reader.ValueTextEquals(MemberOffsets))
		{
			return IndexOptions.Offsets;
		}

		if (reader.ValueTextEquals(MemberFreqs))
		{
			return IndexOptions.Freqs;
		}

		if (reader.ValueTextEquals(MemberDocs))
		{
			return IndexOptions.Docs;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberPositions.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return IndexOptions.Positions;
		}

		if (string.Equals(value, MemberOffsets.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return IndexOptions.Offsets;
		}

		if (string.Equals(value, MemberFreqs.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return IndexOptions.Freqs;
		}

		if (string.Equals(value, MemberDocs.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return IndexOptions.Docs;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(IndexOptions)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, IndexOptions value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case IndexOptions.Positions:
				writer.WriteStringValue(MemberPositions);
				break;
			case IndexOptions.Offsets:
				writer.WriteStringValue(MemberOffsets);
				break;
			case IndexOptions.Freqs:
				writer.WriteStringValue(MemberFreqs);
				break;
			case IndexOptions.Docs:
				writer.WriteStringValue(MemberDocs);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(IndexOptions)}'.");
		}
	}
}

[JsonConverter(typeof(MatchTypeConverter))]
public enum MatchType
{
	[EnumMember(Value = "simple")]
	Simple,
	[EnumMember(Value = "regex")]
	Regex
}

internal sealed partial class MatchTypeConverter : System.Text.Json.Serialization.JsonConverter<MatchType>
{
	private static readonly System.Text.Json.JsonEncodedText MemberSimple = System.Text.Json.JsonEncodedText.Encode("simple");
	private static readonly System.Text.Json.JsonEncodedText MemberRegex = System.Text.Json.JsonEncodedText.Encode("regex");

	public override MatchType Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberSimple))
		{
			return MatchType.Simple;
		}

		if (reader.ValueTextEquals(MemberRegex))
		{
			return MatchType.Regex;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberSimple.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return MatchType.Simple;
		}

		if (string.Equals(value, MemberRegex.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return MatchType.Regex;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(MatchType)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, MatchType value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case MatchType.Simple:
				writer.WriteStringValue(MemberSimple);
				break;
			case MatchType.Regex:
				writer.WriteStringValue(MemberRegex);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(MatchType)}'.");
		}
	}
}

[JsonConverter(typeof(OnScriptErrorConverter))]
public enum OnScriptError
{
	[EnumMember(Value = "fail")]
	Fail,
	[EnumMember(Value = "continue")]
	Continue
}

internal sealed partial class OnScriptErrorConverter : System.Text.Json.Serialization.JsonConverter<OnScriptError>
{
	private static readonly System.Text.Json.JsonEncodedText MemberFail = System.Text.Json.JsonEncodedText.Encode("fail");
	private static readonly System.Text.Json.JsonEncodedText MemberContinue = System.Text.Json.JsonEncodedText.Encode("continue");

	public override OnScriptError Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberFail))
		{
			return OnScriptError.Fail;
		}

		if (reader.ValueTextEquals(MemberContinue))
		{
			return OnScriptError.Continue;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberFail.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return OnScriptError.Fail;
		}

		if (string.Equals(value, MemberContinue.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return OnScriptError.Continue;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(OnScriptError)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, OnScriptError value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case OnScriptError.Fail:
				writer.WriteStringValue(MemberFail);
				break;
			case OnScriptError.Continue:
				writer.WriteStringValue(MemberContinue);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(OnScriptError)}'.");
		}
	}
}

[JsonConverter(typeof(RuntimeFieldTypeConverter))]
public enum RuntimeFieldType
{
	[EnumMember(Value = "lookup")]
	Lookup,
	[EnumMember(Value = "long")]
	Long,
	[EnumMember(Value = "keyword")]
	Keyword,
	[EnumMember(Value = "ip")]
	Ip,
	[EnumMember(Value = "geo_point")]
	GeoPoint,
	[EnumMember(Value = "double")]
	Double,
	[EnumMember(Value = "date")]
	Date,
	[EnumMember(Value = "composite")]
	Composite,
	[EnumMember(Value = "boolean")]
	Boolean
}

internal sealed partial class RuntimeFieldTypeConverter : System.Text.Json.Serialization.JsonConverter<RuntimeFieldType>
{
	private static readonly System.Text.Json.JsonEncodedText MemberLookup = System.Text.Json.JsonEncodedText.Encode("lookup");
	private static readonly System.Text.Json.JsonEncodedText MemberLong = System.Text.Json.JsonEncodedText.Encode("long");
	private static readonly System.Text.Json.JsonEncodedText MemberKeyword = System.Text.Json.JsonEncodedText.Encode("keyword");
	private static readonly System.Text.Json.JsonEncodedText MemberIp = System.Text.Json.JsonEncodedText.Encode("ip");
	private static readonly System.Text.Json.JsonEncodedText MemberGeoPoint = System.Text.Json.JsonEncodedText.Encode("geo_point");
	private static readonly System.Text.Json.JsonEncodedText MemberDouble = System.Text.Json.JsonEncodedText.Encode("double");
	private static readonly System.Text.Json.JsonEncodedText MemberDate = System.Text.Json.JsonEncodedText.Encode("date");
	private static readonly System.Text.Json.JsonEncodedText MemberComposite = System.Text.Json.JsonEncodedText.Encode("composite");
	private static readonly System.Text.Json.JsonEncodedText MemberBoolean = System.Text.Json.JsonEncodedText.Encode("boolean");

	public override RuntimeFieldType Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberLookup))
		{
			return RuntimeFieldType.Lookup;
		}

		if (reader.ValueTextEquals(MemberLong))
		{
			return RuntimeFieldType.Long;
		}

		if (reader.ValueTextEquals(MemberKeyword))
		{
			return RuntimeFieldType.Keyword;
		}

		if (reader.ValueTextEquals(MemberIp))
		{
			return RuntimeFieldType.Ip;
		}

		if (reader.ValueTextEquals(MemberGeoPoint))
		{
			return RuntimeFieldType.GeoPoint;
		}

		if (reader.ValueTextEquals(MemberDouble))
		{
			return RuntimeFieldType.Double;
		}

		if (reader.ValueTextEquals(MemberDate))
		{
			return RuntimeFieldType.Date;
		}

		if (reader.ValueTextEquals(MemberComposite))
		{
			return RuntimeFieldType.Composite;
		}

		if (reader.ValueTextEquals(MemberBoolean))
		{
			return RuntimeFieldType.Boolean;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberLookup.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return RuntimeFieldType.Lookup;
		}

		if (string.Equals(value, MemberLong.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return RuntimeFieldType.Long;
		}

		if (string.Equals(value, MemberKeyword.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return RuntimeFieldType.Keyword;
		}

		if (string.Equals(value, MemberIp.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return RuntimeFieldType.Ip;
		}

		if (string.Equals(value, MemberGeoPoint.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return RuntimeFieldType.GeoPoint;
		}

		if (string.Equals(value, MemberDouble.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return RuntimeFieldType.Double;
		}

		if (string.Equals(value, MemberDate.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return RuntimeFieldType.Date;
		}

		if (string.Equals(value, MemberComposite.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return RuntimeFieldType.Composite;
		}

		if (string.Equals(value, MemberBoolean.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return RuntimeFieldType.Boolean;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(RuntimeFieldType)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, RuntimeFieldType value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case RuntimeFieldType.Lookup:
				writer.WriteStringValue(MemberLookup);
				break;
			case RuntimeFieldType.Long:
				writer.WriteStringValue(MemberLong);
				break;
			case RuntimeFieldType.Keyword:
				writer.WriteStringValue(MemberKeyword);
				break;
			case RuntimeFieldType.Ip:
				writer.WriteStringValue(MemberIp);
				break;
			case RuntimeFieldType.GeoPoint:
				writer.WriteStringValue(MemberGeoPoint);
				break;
			case RuntimeFieldType.Double:
				writer.WriteStringValue(MemberDouble);
				break;
			case RuntimeFieldType.Date:
				writer.WriteStringValue(MemberDate);
				break;
			case RuntimeFieldType.Composite:
				writer.WriteStringValue(MemberComposite);
				break;
			case RuntimeFieldType.Boolean:
				writer.WriteStringValue(MemberBoolean);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(RuntimeFieldType)}'.");
		}
	}
}

[JsonConverter(typeof(SourceFieldModeConverter))]
public enum SourceFieldMode
{
	/// <summary>
	/// <para>
	/// Instead of storing source documents on disk exactly as you send them,
	/// Elasticsearch can reconstruct source content on the fly upon retrieval.
	/// </para>
	/// </summary>
	[EnumMember(Value = "synthetic")]
	Synthetic,
	[EnumMember(Value = "stored")]
	Stored,
	[EnumMember(Value = "disabled")]
	Disabled
}

internal sealed partial class SourceFieldModeConverter : System.Text.Json.Serialization.JsonConverter<SourceFieldMode>
{
	private static readonly System.Text.Json.JsonEncodedText MemberSynthetic = System.Text.Json.JsonEncodedText.Encode("synthetic");
	private static readonly System.Text.Json.JsonEncodedText MemberStored = System.Text.Json.JsonEncodedText.Encode("stored");
	private static readonly System.Text.Json.JsonEncodedText MemberDisabled = System.Text.Json.JsonEncodedText.Encode("disabled");

	public override SourceFieldMode Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberSynthetic))
		{
			return SourceFieldMode.Synthetic;
		}

		if (reader.ValueTextEquals(MemberStored))
		{
			return SourceFieldMode.Stored;
		}

		if (reader.ValueTextEquals(MemberDisabled))
		{
			return SourceFieldMode.Disabled;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberSynthetic.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return SourceFieldMode.Synthetic;
		}

		if (string.Equals(value, MemberStored.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return SourceFieldMode.Stored;
		}

		if (string.Equals(value, MemberDisabled.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return SourceFieldMode.Disabled;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(SourceFieldMode)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, SourceFieldMode value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case SourceFieldMode.Synthetic:
				writer.WriteStringValue(MemberSynthetic);
				break;
			case SourceFieldMode.Stored:
				writer.WriteStringValue(MemberStored);
				break;
			case SourceFieldMode.Disabled:
				writer.WriteStringValue(MemberDisabled);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(SourceFieldMode)}'.");
		}
	}
}

[JsonConverter(typeof(TermVectorOptionConverter))]
public enum TermVectorOption
{
	[EnumMember(Value = "yes")]
	Yes,
	[EnumMember(Value = "with_positions_payloads")]
	WithPositionsPayloads,
	[EnumMember(Value = "with_positions_offsets_payloads")]
	WithPositionsOffsetsPayloads,
	[EnumMember(Value = "with_positions_offsets")]
	WithPositionsOffsets,
	[EnumMember(Value = "with_positions")]
	WithPositions,
	[EnumMember(Value = "with_offsets")]
	WithOffsets,
	[EnumMember(Value = "no")]
	No
}

internal sealed partial class TermVectorOptionConverter : System.Text.Json.Serialization.JsonConverter<TermVectorOption>
{
	private static readonly System.Text.Json.JsonEncodedText MemberYes = System.Text.Json.JsonEncodedText.Encode("yes");
	private static readonly System.Text.Json.JsonEncodedText MemberWithPositionsPayloads = System.Text.Json.JsonEncodedText.Encode("with_positions_payloads");
	private static readonly System.Text.Json.JsonEncodedText MemberWithPositionsOffsetsPayloads = System.Text.Json.JsonEncodedText.Encode("with_positions_offsets_payloads");
	private static readonly System.Text.Json.JsonEncodedText MemberWithPositionsOffsets = System.Text.Json.JsonEncodedText.Encode("with_positions_offsets");
	private static readonly System.Text.Json.JsonEncodedText MemberWithPositions = System.Text.Json.JsonEncodedText.Encode("with_positions");
	private static readonly System.Text.Json.JsonEncodedText MemberWithOffsets = System.Text.Json.JsonEncodedText.Encode("with_offsets");
	private static readonly System.Text.Json.JsonEncodedText MemberNo = System.Text.Json.JsonEncodedText.Encode("no");

	public override TermVectorOption Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberYes))
		{
			return TermVectorOption.Yes;
		}

		if (reader.ValueTextEquals(MemberWithPositionsPayloads))
		{
			return TermVectorOption.WithPositionsPayloads;
		}

		if (reader.ValueTextEquals(MemberWithPositionsOffsetsPayloads))
		{
			return TermVectorOption.WithPositionsOffsetsPayloads;
		}

		if (reader.ValueTextEquals(MemberWithPositionsOffsets))
		{
			return TermVectorOption.WithPositionsOffsets;
		}

		if (reader.ValueTextEquals(MemberWithPositions))
		{
			return TermVectorOption.WithPositions;
		}

		if (reader.ValueTextEquals(MemberWithOffsets))
		{
			return TermVectorOption.WithOffsets;
		}

		if (reader.ValueTextEquals(MemberNo))
		{
			return TermVectorOption.No;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberYes.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return TermVectorOption.Yes;
		}

		if (string.Equals(value, MemberWithPositionsPayloads.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return TermVectorOption.WithPositionsPayloads;
		}

		if (string.Equals(value, MemberWithPositionsOffsetsPayloads.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return TermVectorOption.WithPositionsOffsetsPayloads;
		}

		if (string.Equals(value, MemberWithPositionsOffsets.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return TermVectorOption.WithPositionsOffsets;
		}

		if (string.Equals(value, MemberWithPositions.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return TermVectorOption.WithPositions;
		}

		if (string.Equals(value, MemberWithOffsets.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return TermVectorOption.WithOffsets;
		}

		if (string.Equals(value, MemberNo.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return TermVectorOption.No;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(TermVectorOption)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, TermVectorOption value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case TermVectorOption.Yes:
				writer.WriteStringValue(MemberYes);
				break;
			case TermVectorOption.WithPositionsPayloads:
				writer.WriteStringValue(MemberWithPositionsPayloads);
				break;
			case TermVectorOption.WithPositionsOffsetsPayloads:
				writer.WriteStringValue(MemberWithPositionsOffsetsPayloads);
				break;
			case TermVectorOption.WithPositionsOffsets:
				writer.WriteStringValue(MemberWithPositionsOffsets);
				break;
			case TermVectorOption.WithPositions:
				writer.WriteStringValue(MemberWithPositions);
				break;
			case TermVectorOption.WithOffsets:
				writer.WriteStringValue(MemberWithOffsets);
				break;
			case TermVectorOption.No:
				writer.WriteStringValue(MemberNo);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(TermVectorOption)}'.");
		}
	}
}

[JsonConverter(typeof(TimeSeriesMetricTypeConverter))]
public enum TimeSeriesMetricType
{
	[EnumMember(Value = "summary")]
	Summary,
	[EnumMember(Value = "position")]
	Position,
	[EnumMember(Value = "histogram")]
	Histogram,
	[EnumMember(Value = "gauge")]
	Gauge,
	[EnumMember(Value = "counter")]
	Counter
}

internal sealed partial class TimeSeriesMetricTypeConverter : System.Text.Json.Serialization.JsonConverter<TimeSeriesMetricType>
{
	private static readonly System.Text.Json.JsonEncodedText MemberSummary = System.Text.Json.JsonEncodedText.Encode("summary");
	private static readonly System.Text.Json.JsonEncodedText MemberPosition = System.Text.Json.JsonEncodedText.Encode("position");
	private static readonly System.Text.Json.JsonEncodedText MemberHistogram = System.Text.Json.JsonEncodedText.Encode("histogram");
	private static readonly System.Text.Json.JsonEncodedText MemberGauge = System.Text.Json.JsonEncodedText.Encode("gauge");
	private static readonly System.Text.Json.JsonEncodedText MemberCounter = System.Text.Json.JsonEncodedText.Encode("counter");

	public override TimeSeriesMetricType Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberSummary))
		{
			return TimeSeriesMetricType.Summary;
		}

		if (reader.ValueTextEquals(MemberPosition))
		{
			return TimeSeriesMetricType.Position;
		}

		if (reader.ValueTextEquals(MemberHistogram))
		{
			return TimeSeriesMetricType.Histogram;
		}

		if (reader.ValueTextEquals(MemberGauge))
		{
			return TimeSeriesMetricType.Gauge;
		}

		if (reader.ValueTextEquals(MemberCounter))
		{
			return TimeSeriesMetricType.Counter;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberSummary.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return TimeSeriesMetricType.Summary;
		}

		if (string.Equals(value, MemberPosition.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return TimeSeriesMetricType.Position;
		}

		if (string.Equals(value, MemberHistogram.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return TimeSeriesMetricType.Histogram;
		}

		if (string.Equals(value, MemberGauge.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return TimeSeriesMetricType.Gauge;
		}

		if (string.Equals(value, MemberCounter.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return TimeSeriesMetricType.Counter;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(TimeSeriesMetricType)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, TimeSeriesMetricType value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case TimeSeriesMetricType.Summary:
				writer.WriteStringValue(MemberSummary);
				break;
			case TimeSeriesMetricType.Position:
				writer.WriteStringValue(MemberPosition);
				break;
			case TimeSeriesMetricType.Histogram:
				writer.WriteStringValue(MemberHistogram);
				break;
			case TimeSeriesMetricType.Gauge:
				writer.WriteStringValue(MemberGauge);
				break;
			case TimeSeriesMetricType.Counter:
				writer.WriteStringValue(MemberCounter);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(TimeSeriesMetricType)}'.");
		}
	}
}