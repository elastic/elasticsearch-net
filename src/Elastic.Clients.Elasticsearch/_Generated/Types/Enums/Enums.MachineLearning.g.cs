// Licensed to Elasticsearch B.V under one or more agreements.
// Elasticsearch B.V licenses this file to you under the Apache 2.0 License.
// See the LICENSE file in the project root for more information.
//
// ███╗   ██╗ ██████╗ ████████╗██╗ ██████╗███████╗
// ████╗  ██║██╔═══██╗╚══██╔══╝██║██╔════╝██╔════╝
// ██╔██╗ ██║██║   ██║   ██║   ██║██║     █████╗
// ██║╚██╗██║██║   ██║   ██║   ██║██║     ██╔══╝
// ██║ ╚████║╚██████╔╝   ██║   ██║╚██████╗███████╗
// ╚═╝  ╚═══╝ ╚═════╝    ╚═╝   ╚═╝ ╚═════╝╚══════╝
// ------------------------------------------------
//
// This file is automatically generated.
// Please do not edit these files manually.
//
// ------------------------------------------------

#nullable restore

using Elastic.Clients.Elasticsearch.Core;
using Elastic.Clients.Elasticsearch.Serialization;
using Elastic.Transport;
using System;
using System.Runtime.Serialization;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace Elastic.Clients.Elasticsearch.MachineLearning;

[JsonConverter(typeof(AppliesToConverter))]
public enum AppliesTo
{
	[EnumMember(Value = "typical")]
	Typical,
	[EnumMember(Value = "time")]
	Time,
	[EnumMember(Value = "diff_from_typical")]
	DiffFromTypical,
	[EnumMember(Value = "actual")]
	Actual
}

internal sealed partial class AppliesToConverter : System.Text.Json.Serialization.JsonConverter<AppliesTo>
{
	private static readonly System.Text.Json.JsonEncodedText MemberTypical = System.Text.Json.JsonEncodedText.Encode("typical");
	private static readonly System.Text.Json.JsonEncodedText MemberTime = System.Text.Json.JsonEncodedText.Encode("time");
	private static readonly System.Text.Json.JsonEncodedText MemberDiffFromTypical = System.Text.Json.JsonEncodedText.Encode("diff_from_typical");
	private static readonly System.Text.Json.JsonEncodedText MemberActual = System.Text.Json.JsonEncodedText.Encode("actual");

	public override AppliesTo Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberTypical))
		{
			return AppliesTo.Typical;
		}

		if (reader.ValueTextEquals(MemberTime))
		{
			return AppliesTo.Time;
		}

		if (reader.ValueTextEquals(MemberDiffFromTypical))
		{
			return AppliesTo.DiffFromTypical;
		}

		if (reader.ValueTextEquals(MemberActual))
		{
			return AppliesTo.Actual;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberTypical.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return AppliesTo.Typical;
		}

		if (string.Equals(value, MemberTime.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return AppliesTo.Time;
		}

		if (string.Equals(value, MemberDiffFromTypical.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return AppliesTo.DiffFromTypical;
		}

		if (string.Equals(value, MemberActual.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return AppliesTo.Actual;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(AppliesTo)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, AppliesTo value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case AppliesTo.Typical:
				writer.WriteStringValue(MemberTypical);
				break;
			case AppliesTo.Time:
				writer.WriteStringValue(MemberTime);
				break;
			case AppliesTo.DiffFromTypical:
				writer.WriteStringValue(MemberDiffFromTypical);
				break;
			case AppliesTo.Actual:
				writer.WriteStringValue(MemberActual);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(AppliesTo)}'.");
		}
	}
}

[JsonConverter(typeof(CategorizationStatusConverter))]
public enum CategorizationStatus
{
	[EnumMember(Value = "warn")]
	Warn,
	[EnumMember(Value = "ok")]
	Ok
}

internal sealed partial class CategorizationStatusConverter : System.Text.Json.Serialization.JsonConverter<CategorizationStatus>
{
	private static readonly System.Text.Json.JsonEncodedText MemberWarn = System.Text.Json.JsonEncodedText.Encode("warn");
	private static readonly System.Text.Json.JsonEncodedText MemberOk = System.Text.Json.JsonEncodedText.Encode("ok");

	public override CategorizationStatus Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberWarn))
		{
			return CategorizationStatus.Warn;
		}

		if (reader.ValueTextEquals(MemberOk))
		{
			return CategorizationStatus.Ok;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberWarn.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return CategorizationStatus.Warn;
		}

		if (string.Equals(value, MemberOk.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return CategorizationStatus.Ok;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(CategorizationStatus)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, CategorizationStatus value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case CategorizationStatus.Warn:
				writer.WriteStringValue(MemberWarn);
				break;
			case CategorizationStatus.Ok:
				writer.WriteStringValue(MemberOk);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(CategorizationStatus)}'.");
		}
	}
}

[JsonConverter(typeof(ChunkingModeConverter))]
public enum ChunkingMode
{
	[EnumMember(Value = "off")]
	Off,
	[EnumMember(Value = "manual")]
	Manual,
	[EnumMember(Value = "auto")]
	Auto
}

internal sealed partial class ChunkingModeConverter : System.Text.Json.Serialization.JsonConverter<ChunkingMode>
{
	private static readonly System.Text.Json.JsonEncodedText MemberOff = System.Text.Json.JsonEncodedText.Encode("off");
	private static readonly System.Text.Json.JsonEncodedText MemberManual = System.Text.Json.JsonEncodedText.Encode("manual");
	private static readonly System.Text.Json.JsonEncodedText MemberAuto = System.Text.Json.JsonEncodedText.Encode("auto");

	public override ChunkingMode Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberOff))
		{
			return ChunkingMode.Off;
		}

		if (reader.ValueTextEquals(MemberManual))
		{
			return ChunkingMode.Manual;
		}

		if (reader.ValueTextEquals(MemberAuto))
		{
			return ChunkingMode.Auto;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberOff.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return ChunkingMode.Off;
		}

		if (string.Equals(value, MemberManual.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return ChunkingMode.Manual;
		}

		if (string.Equals(value, MemberAuto.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return ChunkingMode.Auto;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(ChunkingMode)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, ChunkingMode value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case ChunkingMode.Off:
				writer.WriteStringValue(MemberOff);
				break;
			case ChunkingMode.Manual:
				writer.WriteStringValue(MemberManual);
				break;
			case ChunkingMode.Auto:
				writer.WriteStringValue(MemberAuto);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(ChunkingMode)}'.");
		}
	}
}

[JsonConverter(typeof(ConditionOperatorConverter))]
public enum ConditionOperator
{
	[EnumMember(Value = "lte")]
	Lte,
	[EnumMember(Value = "lt")]
	Lt,
	[EnumMember(Value = "gte")]
	Gte,
	[EnumMember(Value = "gt")]
	Gt
}

internal sealed partial class ConditionOperatorConverter : System.Text.Json.Serialization.JsonConverter<ConditionOperator>
{
	private static readonly System.Text.Json.JsonEncodedText MemberLte = System.Text.Json.JsonEncodedText.Encode("lte");
	private static readonly System.Text.Json.JsonEncodedText MemberLt = System.Text.Json.JsonEncodedText.Encode("lt");
	private static readonly System.Text.Json.JsonEncodedText MemberGte = System.Text.Json.JsonEncodedText.Encode("gte");
	private static readonly System.Text.Json.JsonEncodedText MemberGt = System.Text.Json.JsonEncodedText.Encode("gt");

	public override ConditionOperator Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberLte))
		{
			return ConditionOperator.Lte;
		}

		if (reader.ValueTextEquals(MemberLt))
		{
			return ConditionOperator.Lt;
		}

		if (reader.ValueTextEquals(MemberGte))
		{
			return ConditionOperator.Gte;
		}

		if (reader.ValueTextEquals(MemberGt))
		{
			return ConditionOperator.Gt;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberLte.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return ConditionOperator.Lte;
		}

		if (string.Equals(value, MemberLt.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return ConditionOperator.Lt;
		}

		if (string.Equals(value, MemberGte.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return ConditionOperator.Gte;
		}

		if (string.Equals(value, MemberGt.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return ConditionOperator.Gt;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(ConditionOperator)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, ConditionOperator value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case ConditionOperator.Lte:
				writer.WriteStringValue(MemberLte);
				break;
			case ConditionOperator.Lt:
				writer.WriteStringValue(MemberLt);
				break;
			case ConditionOperator.Gte:
				writer.WriteStringValue(MemberGte);
				break;
			case ConditionOperator.Gt:
				writer.WriteStringValue(MemberGt);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(ConditionOperator)}'.");
		}
	}
}

[JsonConverter(typeof(DatafeedStateConverter))]
public enum DatafeedState
{
	[EnumMember(Value = "stopping")]
	Stopping,
	[EnumMember(Value = "stopped")]
	Stopped,
	[EnumMember(Value = "starting")]
	Starting,
	[EnumMember(Value = "started")]
	Started
}

internal sealed partial class DatafeedStateConverter : System.Text.Json.Serialization.JsonConverter<DatafeedState>
{
	private static readonly System.Text.Json.JsonEncodedText MemberStopping = System.Text.Json.JsonEncodedText.Encode("stopping");
	private static readonly System.Text.Json.JsonEncodedText MemberStopped = System.Text.Json.JsonEncodedText.Encode("stopped");
	private static readonly System.Text.Json.JsonEncodedText MemberStarting = System.Text.Json.JsonEncodedText.Encode("starting");
	private static readonly System.Text.Json.JsonEncodedText MemberStarted = System.Text.Json.JsonEncodedText.Encode("started");

	public override DatafeedState Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberStopping))
		{
			return DatafeedState.Stopping;
		}

		if (reader.ValueTextEquals(MemberStopped))
		{
			return DatafeedState.Stopped;
		}

		if (reader.ValueTextEquals(MemberStarting))
		{
			return DatafeedState.Starting;
		}

		if (reader.ValueTextEquals(MemberStarted))
		{
			return DatafeedState.Started;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberStopping.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return DatafeedState.Stopping;
		}

		if (string.Equals(value, MemberStopped.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return DatafeedState.Stopped;
		}

		if (string.Equals(value, MemberStarting.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return DatafeedState.Starting;
		}

		if (string.Equals(value, MemberStarted.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return DatafeedState.Started;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(DatafeedState)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, DatafeedState value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case DatafeedState.Stopping:
				writer.WriteStringValue(MemberStopping);
				break;
			case DatafeedState.Stopped:
				writer.WriteStringValue(MemberStopped);
				break;
			case DatafeedState.Starting:
				writer.WriteStringValue(MemberStarting);
				break;
			case DatafeedState.Started:
				writer.WriteStringValue(MemberStarted);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(DatafeedState)}'.");
		}
	}
}

[JsonConverter(typeof(DataframeStateConverter))]
public enum DataframeState
{
	[EnumMember(Value = "stopping")]
	Stopping,
	[EnumMember(Value = "stopped")]
	Stopped,
	[EnumMember(Value = "starting")]
	Starting,
	[EnumMember(Value = "started")]
	Started,
	[EnumMember(Value = "failed")]
	Failed
}

internal sealed partial class DataframeStateConverter : System.Text.Json.Serialization.JsonConverter<DataframeState>
{
	private static readonly System.Text.Json.JsonEncodedText MemberStopping = System.Text.Json.JsonEncodedText.Encode("stopping");
	private static readonly System.Text.Json.JsonEncodedText MemberStopped = System.Text.Json.JsonEncodedText.Encode("stopped");
	private static readonly System.Text.Json.JsonEncodedText MemberStarting = System.Text.Json.JsonEncodedText.Encode("starting");
	private static readonly System.Text.Json.JsonEncodedText MemberStarted = System.Text.Json.JsonEncodedText.Encode("started");
	private static readonly System.Text.Json.JsonEncodedText MemberFailed = System.Text.Json.JsonEncodedText.Encode("failed");

	public override DataframeState Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberStopping))
		{
			return DataframeState.Stopping;
		}

		if (reader.ValueTextEquals(MemberStopped))
		{
			return DataframeState.Stopped;
		}

		if (reader.ValueTextEquals(MemberStarting))
		{
			return DataframeState.Starting;
		}

		if (reader.ValueTextEquals(MemberStarted))
		{
			return DataframeState.Started;
		}

		if (reader.ValueTextEquals(MemberFailed))
		{
			return DataframeState.Failed;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberStopping.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return DataframeState.Stopping;
		}

		if (string.Equals(value, MemberStopped.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return DataframeState.Stopped;
		}

		if (string.Equals(value, MemberStarting.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return DataframeState.Starting;
		}

		if (string.Equals(value, MemberStarted.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return DataframeState.Started;
		}

		if (string.Equals(value, MemberFailed.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return DataframeState.Failed;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(DataframeState)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, DataframeState value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case DataframeState.Stopping:
				writer.WriteStringValue(MemberStopping);
				break;
			case DataframeState.Stopped:
				writer.WriteStringValue(MemberStopped);
				break;
			case DataframeState.Starting:
				writer.WriteStringValue(MemberStarting);
				break;
			case DataframeState.Started:
				writer.WriteStringValue(MemberStarted);
				break;
			case DataframeState.Failed:
				writer.WriteStringValue(MemberFailed);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(DataframeState)}'.");
		}
	}
}

[JsonConverter(typeof(DeploymentAllocationStateConverter))]
public enum DeploymentAllocationState
{
	/// <summary>
	/// <para>
	/// Trained model deployment is starting but it is not yet deployed on any nodes.
	/// </para>
	/// </summary>
	[EnumMember(Value = "starting")]
	Starting,
	/// <summary>
	/// <para>
	/// The trained model is started on at least one node.
	/// </para>
	/// </summary>
	[EnumMember(Value = "started")]
	Started,
	/// <summary>
	/// <para>
	/// Trained model deployment has started on all valid nodes.
	/// </para>
	/// </summary>
	[EnumMember(Value = "fully_allocated")]
	FullyAllocated
}

internal sealed partial class DeploymentAllocationStateConverter : System.Text.Json.Serialization.JsonConverter<DeploymentAllocationState>
{
	private static readonly System.Text.Json.JsonEncodedText MemberStarting = System.Text.Json.JsonEncodedText.Encode("starting");
	private static readonly System.Text.Json.JsonEncodedText MemberStarted = System.Text.Json.JsonEncodedText.Encode("started");
	private static readonly System.Text.Json.JsonEncodedText MemberFullyAllocated = System.Text.Json.JsonEncodedText.Encode("fully_allocated");

	public override DeploymentAllocationState Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberStarting))
		{
			return DeploymentAllocationState.Starting;
		}

		if (reader.ValueTextEquals(MemberStarted))
		{
			return DeploymentAllocationState.Started;
		}

		if (reader.ValueTextEquals(MemberFullyAllocated))
		{
			return DeploymentAllocationState.FullyAllocated;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberStarting.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return DeploymentAllocationState.Starting;
		}

		if (string.Equals(value, MemberStarted.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return DeploymentAllocationState.Started;
		}

		if (string.Equals(value, MemberFullyAllocated.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return DeploymentAllocationState.FullyAllocated;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(DeploymentAllocationState)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, DeploymentAllocationState value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case DeploymentAllocationState.Starting:
				writer.WriteStringValue(MemberStarting);
				break;
			case DeploymentAllocationState.Started:
				writer.WriteStringValue(MemberStarted);
				break;
			case DeploymentAllocationState.FullyAllocated:
				writer.WriteStringValue(MemberFullyAllocated);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(DeploymentAllocationState)}'.");
		}
	}
}

[JsonConverter(typeof(DeploymentAssignmentStateConverter))]
public enum DeploymentAssignmentState
{
	/// <summary>
	/// <para>
	/// The deployment is preparing to stop and deallocate the model from the relevant nodes.
	/// </para>
	/// </summary>
	[EnumMember(Value = "stopping")]
	Stopping,
	/// <summary>
	/// <para>
	/// The deployment has recently started but is not yet usable; the model is not allocated on any nodes.
	/// </para>
	/// </summary>
	[EnumMember(Value = "starting")]
	Starting,
	/// <summary>
	/// <para>
	/// The deployment is usable; at least one node has the model allocated.
	/// </para>
	/// </summary>
	[EnumMember(Value = "started")]
	Started,
	/// <summary>
	/// <para>
	/// The deployment is on a failed state and must be re-deployed.
	/// </para>
	/// </summary>
	[EnumMember(Value = "failed")]
	Failed
}

internal sealed partial class DeploymentAssignmentStateConverter : System.Text.Json.Serialization.JsonConverter<DeploymentAssignmentState>
{
	private static readonly System.Text.Json.JsonEncodedText MemberStopping = System.Text.Json.JsonEncodedText.Encode("stopping");
	private static readonly System.Text.Json.JsonEncodedText MemberStarting = System.Text.Json.JsonEncodedText.Encode("starting");
	private static readonly System.Text.Json.JsonEncodedText MemberStarted = System.Text.Json.JsonEncodedText.Encode("started");
	private static readonly System.Text.Json.JsonEncodedText MemberFailed = System.Text.Json.JsonEncodedText.Encode("failed");

	public override DeploymentAssignmentState Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberStopping))
		{
			return DeploymentAssignmentState.Stopping;
		}

		if (reader.ValueTextEquals(MemberStarting))
		{
			return DeploymentAssignmentState.Starting;
		}

		if (reader.ValueTextEquals(MemberStarted))
		{
			return DeploymentAssignmentState.Started;
		}

		if (reader.ValueTextEquals(MemberFailed))
		{
			return DeploymentAssignmentState.Failed;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberStopping.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return DeploymentAssignmentState.Stopping;
		}

		if (string.Equals(value, MemberStarting.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return DeploymentAssignmentState.Starting;
		}

		if (string.Equals(value, MemberStarted.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return DeploymentAssignmentState.Started;
		}

		if (string.Equals(value, MemberFailed.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return DeploymentAssignmentState.Failed;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(DeploymentAssignmentState)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, DeploymentAssignmentState value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case DeploymentAssignmentState.Stopping:
				writer.WriteStringValue(MemberStopping);
				break;
			case DeploymentAssignmentState.Starting:
				writer.WriteStringValue(MemberStarting);
				break;
			case DeploymentAssignmentState.Started:
				writer.WriteStringValue(MemberStarted);
				break;
			case DeploymentAssignmentState.Failed:
				writer.WriteStringValue(MemberFailed);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(DeploymentAssignmentState)}'.");
		}
	}
}

[JsonConverter(typeof(ExcludeFrequentConverter))]
public enum ExcludeFrequent
{
	[EnumMember(Value = "over")]
	Over,
	[EnumMember(Value = "none")]
	None,
	[EnumMember(Value = "by")]
	By,
	[EnumMember(Value = "all")]
	All
}

internal sealed partial class ExcludeFrequentConverter : System.Text.Json.Serialization.JsonConverter<ExcludeFrequent>
{
	private static readonly System.Text.Json.JsonEncodedText MemberOver = System.Text.Json.JsonEncodedText.Encode("over");
	private static readonly System.Text.Json.JsonEncodedText MemberNone = System.Text.Json.JsonEncodedText.Encode("none");
	private static readonly System.Text.Json.JsonEncodedText MemberBy = System.Text.Json.JsonEncodedText.Encode("by");
	private static readonly System.Text.Json.JsonEncodedText MemberAll = System.Text.Json.JsonEncodedText.Encode("all");

	public override ExcludeFrequent Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberOver))
		{
			return ExcludeFrequent.Over;
		}

		if (reader.ValueTextEquals(MemberNone))
		{
			return ExcludeFrequent.None;
		}

		if (reader.ValueTextEquals(MemberBy))
		{
			return ExcludeFrequent.By;
		}

		if (reader.ValueTextEquals(MemberAll))
		{
			return ExcludeFrequent.All;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberOver.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return ExcludeFrequent.Over;
		}

		if (string.Equals(value, MemberNone.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return ExcludeFrequent.None;
		}

		if (string.Equals(value, MemberBy.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return ExcludeFrequent.By;
		}

		if (string.Equals(value, MemberAll.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return ExcludeFrequent.All;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(ExcludeFrequent)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, ExcludeFrequent value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case ExcludeFrequent.Over:
				writer.WriteStringValue(MemberOver);
				break;
			case ExcludeFrequent.None:
				writer.WriteStringValue(MemberNone);
				break;
			case ExcludeFrequent.By:
				writer.WriteStringValue(MemberBy);
				break;
			case ExcludeFrequent.All:
				writer.WriteStringValue(MemberAll);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(ExcludeFrequent)}'.");
		}
	}
}

[JsonConverter(typeof(FilterTypeConverter))]
public enum FilterType
{
	[EnumMember(Value = "include")]
	Include,
	[EnumMember(Value = "exclude")]
	Exclude
}

internal sealed partial class FilterTypeConverter : System.Text.Json.Serialization.JsonConverter<FilterType>
{
	private static readonly System.Text.Json.JsonEncodedText MemberInclude = System.Text.Json.JsonEncodedText.Encode("include");
	private static readonly System.Text.Json.JsonEncodedText MemberExclude = System.Text.Json.JsonEncodedText.Encode("exclude");

	public override FilterType Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberInclude))
		{
			return FilterType.Include;
		}

		if (reader.ValueTextEquals(MemberExclude))
		{
			return FilterType.Exclude;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberInclude.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return FilterType.Include;
		}

		if (string.Equals(value, MemberExclude.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return FilterType.Exclude;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(FilterType)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, FilterType value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case FilterType.Include:
				writer.WriteStringValue(MemberInclude);
				break;
			case FilterType.Exclude:
				writer.WriteStringValue(MemberExclude);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(FilterType)}'.");
		}
	}
}

[JsonConverter(typeof(IncludeConverter))]
public enum Include
{
	/// <summary>
	/// <para>
	/// Includes the total feature importance for the training data set. The
	/// baseline and total feature importance values are returned in the metadata
	/// field in the response body.
	/// </para>
	/// </summary>
	[EnumMember(Value = "total_feature_importance")]
	TotalFeatureImportance,
	/// <summary>
	/// <para>
	/// Includes the information about hyperparameters used to train the model.
	/// This information consists of the value, the absolute and relative
	/// importance of the hyperparameter as well as an indicator of whether it was
	/// specified by the user or tuned during hyperparameter optimization.
	/// </para>
	/// </summary>
	[EnumMember(Value = "hyperparameters")]
	Hyperparameters,
	/// <summary>
	/// <para>
	/// Includes the baseline for feature importance values.
	/// </para>
	/// </summary>
	[EnumMember(Value = "feature_importance_baseline")]
	FeatureImportanceBaseline,
	/// <summary>
	/// <para>
	/// Includes the model definition status.
	/// </para>
	/// </summary>
	[EnumMember(Value = "definition_status")]
	DefinitionStatus,
	/// <summary>
	/// <para>
	/// Includes the model definition.
	/// </para>
	/// </summary>
	[EnumMember(Value = "definition")]
	Definition
}

internal sealed partial class IncludeConverter : System.Text.Json.Serialization.JsonConverter<Include>
{
	private static readonly System.Text.Json.JsonEncodedText MemberTotalFeatureImportance = System.Text.Json.JsonEncodedText.Encode("total_feature_importance");
	private static readonly System.Text.Json.JsonEncodedText MemberHyperparameters = System.Text.Json.JsonEncodedText.Encode("hyperparameters");
	private static readonly System.Text.Json.JsonEncodedText MemberFeatureImportanceBaseline = System.Text.Json.JsonEncodedText.Encode("feature_importance_baseline");
	private static readonly System.Text.Json.JsonEncodedText MemberDefinitionStatus = System.Text.Json.JsonEncodedText.Encode("definition_status");
	private static readonly System.Text.Json.JsonEncodedText MemberDefinition = System.Text.Json.JsonEncodedText.Encode("definition");

	public override Include Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberTotalFeatureImportance))
		{
			return Include.TotalFeatureImportance;
		}

		if (reader.ValueTextEquals(MemberHyperparameters))
		{
			return Include.Hyperparameters;
		}

		if (reader.ValueTextEquals(MemberFeatureImportanceBaseline))
		{
			return Include.FeatureImportanceBaseline;
		}

		if (reader.ValueTextEquals(MemberDefinitionStatus))
		{
			return Include.DefinitionStatus;
		}

		if (reader.ValueTextEquals(MemberDefinition))
		{
			return Include.Definition;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberTotalFeatureImportance.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return Include.TotalFeatureImportance;
		}

		if (string.Equals(value, MemberHyperparameters.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return Include.Hyperparameters;
		}

		if (string.Equals(value, MemberFeatureImportanceBaseline.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return Include.FeatureImportanceBaseline;
		}

		if (string.Equals(value, MemberDefinitionStatus.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return Include.DefinitionStatus;
		}

		if (string.Equals(value, MemberDefinition.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return Include.Definition;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(Include)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, Include value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case Include.TotalFeatureImportance:
				writer.WriteStringValue(MemberTotalFeatureImportance);
				break;
			case Include.Hyperparameters:
				writer.WriteStringValue(MemberHyperparameters);
				break;
			case Include.FeatureImportanceBaseline:
				writer.WriteStringValue(MemberFeatureImportanceBaseline);
				break;
			case Include.DefinitionStatus:
				writer.WriteStringValue(MemberDefinitionStatus);
				break;
			case Include.Definition:
				writer.WriteStringValue(MemberDefinition);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(Include)}'.");
		}
	}
}

[JsonConverter(typeof(JobBlockedReasonConverter))]
public enum JobBlockedReason
{
	[EnumMember(Value = "revert")]
	Revert,
	[EnumMember(Value = "reset")]
	Reset,
	[EnumMember(Value = "delete")]
	Delete
}

internal sealed partial class JobBlockedReasonConverter : System.Text.Json.Serialization.JsonConverter<JobBlockedReason>
{
	private static readonly System.Text.Json.JsonEncodedText MemberRevert = System.Text.Json.JsonEncodedText.Encode("revert");
	private static readonly System.Text.Json.JsonEncodedText MemberReset = System.Text.Json.JsonEncodedText.Encode("reset");
	private static readonly System.Text.Json.JsonEncodedText MemberDelete = System.Text.Json.JsonEncodedText.Encode("delete");

	public override JobBlockedReason Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberRevert))
		{
			return JobBlockedReason.Revert;
		}

		if (reader.ValueTextEquals(MemberReset))
		{
			return JobBlockedReason.Reset;
		}

		if (reader.ValueTextEquals(MemberDelete))
		{
			return JobBlockedReason.Delete;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberRevert.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return JobBlockedReason.Revert;
		}

		if (string.Equals(value, MemberReset.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return JobBlockedReason.Reset;
		}

		if (string.Equals(value, MemberDelete.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return JobBlockedReason.Delete;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(JobBlockedReason)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, JobBlockedReason value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case JobBlockedReason.Revert:
				writer.WriteStringValue(MemberRevert);
				break;
			case JobBlockedReason.Reset:
				writer.WriteStringValue(MemberReset);
				break;
			case JobBlockedReason.Delete:
				writer.WriteStringValue(MemberDelete);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(JobBlockedReason)}'.");
		}
	}
}

[JsonConverter(typeof(JobStateConverter))]
public enum JobState
{
	/// <summary>
	/// <para>
	/// The job open action is in progress and has not yet completed.
	/// </para>
	/// </summary>
	[EnumMember(Value = "opening")]
	Opening,
	/// <summary>
	/// <para>
	/// The job is available to receive and process data.
	/// </para>
	/// </summary>
	[EnumMember(Value = "opened")]
	Opened,
	/// <summary>
	/// <para>
	/// The job did not finish successfully due to an error.
	/// This situation can occur due to invalid input data, a fatal error occurring during the analysis, or an external interaction such as the process being killed by the Linux out of memory (OOM) killer.
	/// If the job had irrevocably failed, it must be force closed and then deleted.
	/// If the datafeed can be corrected, the job can be closed and then re-opened.
	/// </para>
	/// </summary>
	[EnumMember(Value = "failed")]
	Failed,
	/// <summary>
	/// <para>
	/// The job close action is in progress and has not yet completed. A closing job cannot accept further data.
	/// </para>
	/// </summary>
	[EnumMember(Value = "closing")]
	Closing,
	/// <summary>
	/// <para>
	/// The job finished successfully with its model state persisted. The job must be opened before it can accept further data.
	/// </para>
	/// </summary>
	[EnumMember(Value = "closed")]
	Closed
}

internal sealed partial class JobStateConverter : System.Text.Json.Serialization.JsonConverter<JobState>
{
	private static readonly System.Text.Json.JsonEncodedText MemberOpening = System.Text.Json.JsonEncodedText.Encode("opening");
	private static readonly System.Text.Json.JsonEncodedText MemberOpened = System.Text.Json.JsonEncodedText.Encode("opened");
	private static readonly System.Text.Json.JsonEncodedText MemberFailed = System.Text.Json.JsonEncodedText.Encode("failed");
	private static readonly System.Text.Json.JsonEncodedText MemberClosing = System.Text.Json.JsonEncodedText.Encode("closing");
	private static readonly System.Text.Json.JsonEncodedText MemberClosed = System.Text.Json.JsonEncodedText.Encode("closed");

	public override JobState Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberOpening))
		{
			return JobState.Opening;
		}

		if (reader.ValueTextEquals(MemberOpened))
		{
			return JobState.Opened;
		}

		if (reader.ValueTextEquals(MemberFailed))
		{
			return JobState.Failed;
		}

		if (reader.ValueTextEquals(MemberClosing))
		{
			return JobState.Closing;
		}

		if (reader.ValueTextEquals(MemberClosed))
		{
			return JobState.Closed;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberOpening.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return JobState.Opening;
		}

		if (string.Equals(value, MemberOpened.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return JobState.Opened;
		}

		if (string.Equals(value, MemberFailed.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return JobState.Failed;
		}

		if (string.Equals(value, MemberClosing.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return JobState.Closing;
		}

		if (string.Equals(value, MemberClosed.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return JobState.Closed;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(JobState)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, JobState value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case JobState.Opening:
				writer.WriteStringValue(MemberOpening);
				break;
			case JobState.Opened:
				writer.WriteStringValue(MemberOpened);
				break;
			case JobState.Failed:
				writer.WriteStringValue(MemberFailed);
				break;
			case JobState.Closing:
				writer.WriteStringValue(MemberClosing);
				break;
			case JobState.Closed:
				writer.WriteStringValue(MemberClosed);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(JobState)}'.");
		}
	}
}

[JsonConverter(typeof(MemoryStatusConverter))]
public enum MemoryStatus
{
	[EnumMember(Value = "soft_limit")]
	SoftLimit,
	[EnumMember(Value = "ok")]
	Ok,
	[EnumMember(Value = "hard_limit")]
	HardLimit
}

internal sealed partial class MemoryStatusConverter : System.Text.Json.Serialization.JsonConverter<MemoryStatus>
{
	private static readonly System.Text.Json.JsonEncodedText MemberSoftLimit = System.Text.Json.JsonEncodedText.Encode("soft_limit");
	private static readonly System.Text.Json.JsonEncodedText MemberOk = System.Text.Json.JsonEncodedText.Encode("ok");
	private static readonly System.Text.Json.JsonEncodedText MemberHardLimit = System.Text.Json.JsonEncodedText.Encode("hard_limit");

	public override MemoryStatus Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberSoftLimit))
		{
			return MemoryStatus.SoftLimit;
		}

		if (reader.ValueTextEquals(MemberOk))
		{
			return MemoryStatus.Ok;
		}

		if (reader.ValueTextEquals(MemberHardLimit))
		{
			return MemoryStatus.HardLimit;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberSoftLimit.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return MemoryStatus.SoftLimit;
		}

		if (string.Equals(value, MemberOk.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return MemoryStatus.Ok;
		}

		if (string.Equals(value, MemberHardLimit.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return MemoryStatus.HardLimit;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(MemoryStatus)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, MemoryStatus value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case MemoryStatus.SoftLimit:
				writer.WriteStringValue(MemberSoftLimit);
				break;
			case MemoryStatus.Ok:
				writer.WriteStringValue(MemberOk);
				break;
			case MemoryStatus.HardLimit:
				writer.WriteStringValue(MemberHardLimit);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(MemoryStatus)}'.");
		}
	}
}

[JsonConverter(typeof(RoutingStateConverter))]
public enum RoutingState
{
	/// <summary>
	/// <para>
	/// The trained model is being deallocated from this node.
	/// </para>
	/// </summary>
	[EnumMember(Value = "stopping")]
	Stopping,
	/// <summary>
	/// <para>
	/// The trained model is fully deallocated from this node.
	/// </para>
	/// </summary>
	[EnumMember(Value = "stopped")]
	Stopped,
	/// <summary>
	/// <para>
	/// The trained model is attempting to allocate on this node; inference requests are not yet accepted.
	/// </para>
	/// </summary>
	[EnumMember(Value = "starting")]
	Starting,
	/// <summary>
	/// <para>
	/// The trained model is allocated and ready to accept inference requests.
	/// </para>
	/// </summary>
	[EnumMember(Value = "started")]
	Started,
	/// <summary>
	/// <para>
	/// The allocation attempt failed.
	/// </para>
	/// </summary>
	[EnumMember(Value = "failed")]
	Failed
}

internal sealed partial class RoutingStateConverter : System.Text.Json.Serialization.JsonConverter<RoutingState>
{
	private static readonly System.Text.Json.JsonEncodedText MemberStopping = System.Text.Json.JsonEncodedText.Encode("stopping");
	private static readonly System.Text.Json.JsonEncodedText MemberStopped = System.Text.Json.JsonEncodedText.Encode("stopped");
	private static readonly System.Text.Json.JsonEncodedText MemberStarting = System.Text.Json.JsonEncodedText.Encode("starting");
	private static readonly System.Text.Json.JsonEncodedText MemberStarted = System.Text.Json.JsonEncodedText.Encode("started");
	private static readonly System.Text.Json.JsonEncodedText MemberFailed = System.Text.Json.JsonEncodedText.Encode("failed");

	public override RoutingState Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberStopping))
		{
			return RoutingState.Stopping;
		}

		if (reader.ValueTextEquals(MemberStopped))
		{
			return RoutingState.Stopped;
		}

		if (reader.ValueTextEquals(MemberStarting))
		{
			return RoutingState.Starting;
		}

		if (reader.ValueTextEquals(MemberStarted))
		{
			return RoutingState.Started;
		}

		if (reader.ValueTextEquals(MemberFailed))
		{
			return RoutingState.Failed;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberStopping.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return RoutingState.Stopping;
		}

		if (string.Equals(value, MemberStopped.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return RoutingState.Stopped;
		}

		if (string.Equals(value, MemberStarting.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return RoutingState.Starting;
		}

		if (string.Equals(value, MemberStarted.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return RoutingState.Started;
		}

		if (string.Equals(value, MemberFailed.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return RoutingState.Failed;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(RoutingState)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, RoutingState value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case RoutingState.Stopping:
				writer.WriteStringValue(MemberStopping);
				break;
			case RoutingState.Stopped:
				writer.WriteStringValue(MemberStopped);
				break;
			case RoutingState.Starting:
				writer.WriteStringValue(MemberStarting);
				break;
			case RoutingState.Started:
				writer.WriteStringValue(MemberStarted);
				break;
			case RoutingState.Failed:
				writer.WriteStringValue(MemberFailed);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(RoutingState)}'.");
		}
	}
}

[JsonConverter(typeof(RuleActionConverter))]
public enum RuleAction
{
	/// <summary>
	/// <para>
	/// The result will not be created. Unless you also specify <c>skip_model_update</c>, the model will be updated as usual with the corresponding series value.
	/// </para>
	/// </summary>
	[EnumMember(Value = "skip_result")]
	SkipResult,
	/// <summary>
	/// <para>
	/// The value for that series will not be used to update the model. Unless you also specify <c>skip_result</c>, the results will be created as usual. This action is suitable when certain values are expected to be consistently anomalous and they affect the model in a way that negatively impacts the rest of the results.
	/// </para>
	/// </summary>
	[EnumMember(Value = "skip_model_update")]
	SkipModelUpdate
}

internal sealed partial class RuleActionConverter : System.Text.Json.Serialization.JsonConverter<RuleAction>
{
	private static readonly System.Text.Json.JsonEncodedText MemberSkipResult = System.Text.Json.JsonEncodedText.Encode("skip_result");
	private static readonly System.Text.Json.JsonEncodedText MemberSkipModelUpdate = System.Text.Json.JsonEncodedText.Encode("skip_model_update");

	public override RuleAction Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberSkipResult))
		{
			return RuleAction.SkipResult;
		}

		if (reader.ValueTextEquals(MemberSkipModelUpdate))
		{
			return RuleAction.SkipModelUpdate;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberSkipResult.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return RuleAction.SkipResult;
		}

		if (string.Equals(value, MemberSkipModelUpdate.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return RuleAction.SkipModelUpdate;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(RuleAction)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, RuleAction value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case RuleAction.SkipResult:
				writer.WriteStringValue(MemberSkipResult);
				break;
			case RuleAction.SkipModelUpdate:
				writer.WriteStringValue(MemberSkipModelUpdate);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(RuleAction)}'.");
		}
	}
}

[JsonConverter(typeof(SnapshotUpgradeStateConverter))]
public enum SnapshotUpgradeState
{
	[EnumMember(Value = "stopped")]
	Stopped,
	[EnumMember(Value = "saving_new_state")]
	SavingNewState,
	[EnumMember(Value = "loading_old_state")]
	LoadingOldState,
	[EnumMember(Value = "failed")]
	Failed
}

internal sealed partial class SnapshotUpgradeStateConverter : System.Text.Json.Serialization.JsonConverter<SnapshotUpgradeState>
{
	private static readonly System.Text.Json.JsonEncodedText MemberStopped = System.Text.Json.JsonEncodedText.Encode("stopped");
	private static readonly System.Text.Json.JsonEncodedText MemberSavingNewState = System.Text.Json.JsonEncodedText.Encode("saving_new_state");
	private static readonly System.Text.Json.JsonEncodedText MemberLoadingOldState = System.Text.Json.JsonEncodedText.Encode("loading_old_state");
	private static readonly System.Text.Json.JsonEncodedText MemberFailed = System.Text.Json.JsonEncodedText.Encode("failed");

	public override SnapshotUpgradeState Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberStopped))
		{
			return SnapshotUpgradeState.Stopped;
		}

		if (reader.ValueTextEquals(MemberSavingNewState))
		{
			return SnapshotUpgradeState.SavingNewState;
		}

		if (reader.ValueTextEquals(MemberLoadingOldState))
		{
			return SnapshotUpgradeState.LoadingOldState;
		}

		if (reader.ValueTextEquals(MemberFailed))
		{
			return SnapshotUpgradeState.Failed;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberStopped.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return SnapshotUpgradeState.Stopped;
		}

		if (string.Equals(value, MemberSavingNewState.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return SnapshotUpgradeState.SavingNewState;
		}

		if (string.Equals(value, MemberLoadingOldState.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return SnapshotUpgradeState.LoadingOldState;
		}

		if (string.Equals(value, MemberFailed.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return SnapshotUpgradeState.Failed;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(SnapshotUpgradeState)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, SnapshotUpgradeState value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case SnapshotUpgradeState.Stopped:
				writer.WriteStringValue(MemberStopped);
				break;
			case SnapshotUpgradeState.SavingNewState:
				writer.WriteStringValue(MemberSavingNewState);
				break;
			case SnapshotUpgradeState.LoadingOldState:
				writer.WriteStringValue(MemberLoadingOldState);
				break;
			case SnapshotUpgradeState.Failed:
				writer.WriteStringValue(MemberFailed);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(SnapshotUpgradeState)}'.");
		}
	}
}

[JsonConverter(typeof(TokenizationTruncateConverter))]
public enum TokenizationTruncate
{
	[EnumMember(Value = "second")]
	Second,
	[EnumMember(Value = "none")]
	None,
	[EnumMember(Value = "first")]
	First
}

internal sealed partial class TokenizationTruncateConverter : System.Text.Json.Serialization.JsonConverter<TokenizationTruncate>
{
	private static readonly System.Text.Json.JsonEncodedText MemberSecond = System.Text.Json.JsonEncodedText.Encode("second");
	private static readonly System.Text.Json.JsonEncodedText MemberNone = System.Text.Json.JsonEncodedText.Encode("none");
	private static readonly System.Text.Json.JsonEncodedText MemberFirst = System.Text.Json.JsonEncodedText.Encode("first");

	public override TokenizationTruncate Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberSecond))
		{
			return TokenizationTruncate.Second;
		}

		if (reader.ValueTextEquals(MemberNone))
		{
			return TokenizationTruncate.None;
		}

		if (reader.ValueTextEquals(MemberFirst))
		{
			return TokenizationTruncate.First;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberSecond.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return TokenizationTruncate.Second;
		}

		if (string.Equals(value, MemberNone.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return TokenizationTruncate.None;
		}

		if (string.Equals(value, MemberFirst.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return TokenizationTruncate.First;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(TokenizationTruncate)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, TokenizationTruncate value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case TokenizationTruncate.Second:
				writer.WriteStringValue(MemberSecond);
				break;
			case TokenizationTruncate.None:
				writer.WriteStringValue(MemberNone);
				break;
			case TokenizationTruncate.First:
				writer.WriteStringValue(MemberFirst);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(TokenizationTruncate)}'.");
		}
	}
}

[JsonConverter(typeof(TrainedModelTypeConverter))]
public enum TrainedModelType
{
	/// <summary>
	/// <para>
	/// The model definition is an ensemble model of decision trees.
	/// </para>
	/// </summary>
	[EnumMember(Value = "tree_ensemble")]
	TreeEnsemble,
	/// <summary>
	/// <para>
	/// The stored definition is a PyTorch (specifically a TorchScript) model.
	/// Currently only NLP models are supported.
	/// </para>
	/// </summary>
	[EnumMember(Value = "pytorch")]
	Pytorch,
	/// <summary>
	/// <para>
	/// A special type reserved for language identification models.
	/// </para>
	/// </summary>
	[EnumMember(Value = "lang_ident")]
	LangIdent
}

internal sealed partial class TrainedModelTypeConverter : System.Text.Json.Serialization.JsonConverter<TrainedModelType>
{
	private static readonly System.Text.Json.JsonEncodedText MemberTreeEnsemble = System.Text.Json.JsonEncodedText.Encode("tree_ensemble");
	private static readonly System.Text.Json.JsonEncodedText MemberPytorch = System.Text.Json.JsonEncodedText.Encode("pytorch");
	private static readonly System.Text.Json.JsonEncodedText MemberLangIdent = System.Text.Json.JsonEncodedText.Encode("lang_ident");

	public override TrainedModelType Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberTreeEnsemble))
		{
			return TrainedModelType.TreeEnsemble;
		}

		if (reader.ValueTextEquals(MemberPytorch))
		{
			return TrainedModelType.Pytorch;
		}

		if (reader.ValueTextEquals(MemberLangIdent))
		{
			return TrainedModelType.LangIdent;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberTreeEnsemble.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return TrainedModelType.TreeEnsemble;
		}

		if (string.Equals(value, MemberPytorch.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return TrainedModelType.Pytorch;
		}

		if (string.Equals(value, MemberLangIdent.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return TrainedModelType.LangIdent;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(TrainedModelType)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, TrainedModelType value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case TrainedModelType.TreeEnsemble:
				writer.WriteStringValue(MemberTreeEnsemble);
				break;
			case TrainedModelType.Pytorch:
				writer.WriteStringValue(MemberPytorch);
				break;
			case TrainedModelType.LangIdent:
				writer.WriteStringValue(MemberLangIdent);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(TrainedModelType)}'.");
		}
	}
}

[JsonConverter(typeof(TrainingPriorityConverter))]
public enum TrainingPriority
{
	[EnumMember(Value = "normal")]
	Normal,
	[EnumMember(Value = "low")]
	Low
}

internal sealed partial class TrainingPriorityConverter : System.Text.Json.Serialization.JsonConverter<TrainingPriority>
{
	private static readonly System.Text.Json.JsonEncodedText MemberNormal = System.Text.Json.JsonEncodedText.Encode("normal");
	private static readonly System.Text.Json.JsonEncodedText MemberLow = System.Text.Json.JsonEncodedText.Encode("low");

	public override TrainingPriority Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberNormal))
		{
			return TrainingPriority.Normal;
		}

		if (reader.ValueTextEquals(MemberLow))
		{
			return TrainingPriority.Low;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberNormal.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return TrainingPriority.Normal;
		}

		if (string.Equals(value, MemberLow.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return TrainingPriority.Low;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(TrainingPriority)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, TrainingPriority value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case TrainingPriority.Normal:
				writer.WriteStringValue(MemberNormal);
				break;
			case TrainingPriority.Low:
				writer.WriteStringValue(MemberLow);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(TrainingPriority)}'.");
		}
	}
}