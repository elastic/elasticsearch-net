// Licensed to Elasticsearch B.V under one or more agreements.
// Elasticsearch B.V licenses this file to you under the Apache 2.0 License.
// See the LICENSE file in the project root for more information.
//
// ███╗   ██╗ ██████╗ ████████╗██╗ ██████╗███████╗
// ████╗  ██║██╔═══██╗╚══██╔══╝██║██╔════╝██╔════╝
// ██╔██╗ ██║██║   ██║   ██║   ██║██║     █████╗
// ██║╚██╗██║██║   ██║   ██║   ██║██║     ██╔══╝
// ██║ ╚████║╚██████╔╝   ██║   ██║╚██████╗███████╗
// ╚═╝  ╚═══╝ ╚═════╝    ╚═╝   ╚═╝ ╚═════╝╚══════╝
// ------------------------------------------------
//
// This file is automatically generated.
// Please do not edit these files manually.
//
// ------------------------------------------------

#nullable restore

using Elastic.Clients.Elasticsearch.Core;
using Elastic.Clients.Elasticsearch.Serialization;
using Elastic.Transport;
using System;
using System.Runtime.Serialization;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace Elastic.Clients.Elasticsearch.Analysis;

[JsonConverter(typeof(CjkBigramIgnoredScriptConverter))]
public enum CjkBigramIgnoredScript
{
	[EnumMember(Value = "katakana")]
	Katakana,
	[EnumMember(Value = "hiragana")]
	Hiragana,
	[EnumMember(Value = "hangul")]
	Hangul,
	[EnumMember(Value = "han")]
	Han
}

internal sealed class CjkBigramIgnoredScriptConverter : JsonConverter<CjkBigramIgnoredScript>
{
	public override CjkBigramIgnoredScript Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
	{
		var enumString = reader.GetString();
		switch (enumString)
		{
			case "katakana":
				return CjkBigramIgnoredScript.Katakana;
			case "hiragana":
				return CjkBigramIgnoredScript.Hiragana;
			case "hangul":
				return CjkBigramIgnoredScript.Hangul;
			case "han":
				return CjkBigramIgnoredScript.Han;
		}

		ThrowHelper.ThrowJsonException();
		return default;
	}

	public override void Write(Utf8JsonWriter writer, CjkBigramIgnoredScript value, JsonSerializerOptions options)
	{
		switch (value)
		{
			case CjkBigramIgnoredScript.Katakana:
				writer.WriteStringValue("katakana");
				return;
			case CjkBigramIgnoredScript.Hiragana:
				writer.WriteStringValue("hiragana");
				return;
			case CjkBigramIgnoredScript.Hangul:
				writer.WriteStringValue("hangul");
				return;
			case CjkBigramIgnoredScript.Han:
				writer.WriteStringValue("han");
				return;
		}

		writer.WriteNullValue();
	}
}

[JsonConverter(typeof(DelimitedPayloadEncodingConverter))]
public enum DelimitedPayloadEncoding
{
	[EnumMember(Value = "int")]
	Integer,
	[EnumMember(Value = "identity")]
	Identity,
	[EnumMember(Value = "float")]
	Float
}

internal sealed class DelimitedPayloadEncodingConverter : JsonConverter<DelimitedPayloadEncoding>
{
	public override DelimitedPayloadEncoding Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
	{
		var enumString = reader.GetString();
		switch (enumString)
		{
			case "int":
				return DelimitedPayloadEncoding.Integer;
			case "identity":
				return DelimitedPayloadEncoding.Identity;
			case "float":
				return DelimitedPayloadEncoding.Float;
		}

		ThrowHelper.ThrowJsonException();
		return default;
	}

	public override void Write(Utf8JsonWriter writer, DelimitedPayloadEncoding value, JsonSerializerOptions options)
	{
		switch (value)
		{
			case DelimitedPayloadEncoding.Integer:
				writer.WriteStringValue("int");
				return;
			case DelimitedPayloadEncoding.Identity:
				writer.WriteStringValue("identity");
				return;
			case DelimitedPayloadEncoding.Float:
				writer.WriteStringValue("float");
				return;
		}

		writer.WriteNullValue();
	}
}

[JsonConverter(typeof(EdgeNGramSideConverter))]
public enum EdgeNGramSide
{
	[EnumMember(Value = "front")]
	Front,
	[EnumMember(Value = "back")]
	Back
}

internal sealed class EdgeNGramSideConverter : JsonConverter<EdgeNGramSide>
{
	public override EdgeNGramSide Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
	{
		var enumString = reader.GetString();
		switch (enumString)
		{
			case "front":
				return EdgeNGramSide.Front;
			case "back":
				return EdgeNGramSide.Back;
		}

		ThrowHelper.ThrowJsonException();
		return default;
	}

	public override void Write(Utf8JsonWriter writer, EdgeNGramSide value, JsonSerializerOptions options)
	{
		switch (value)
		{
			case EdgeNGramSide.Front:
				writer.WriteStringValue("front");
				return;
			case EdgeNGramSide.Back:
				writer.WriteStringValue("back");
				return;
		}

		writer.WriteNullValue();
	}
}

[JsonConverter(typeof(IcuCollationAlternateConverter))]
public enum IcuCollationAlternate
{
	[EnumMember(Value = "shifted")]
	Shifted,
	[EnumMember(Value = "non-ignorable")]
	NonIgnorable
}

internal sealed class IcuCollationAlternateConverter : JsonConverter<IcuCollationAlternate>
{
	public override IcuCollationAlternate Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
	{
		var enumString = reader.GetString();
		switch (enumString)
		{
			case "shifted":
				return IcuCollationAlternate.Shifted;
			case "non-ignorable":
				return IcuCollationAlternate.NonIgnorable;
		}

		ThrowHelper.ThrowJsonException();
		return default;
	}

	public override void Write(Utf8JsonWriter writer, IcuCollationAlternate value, JsonSerializerOptions options)
	{
		switch (value)
		{
			case IcuCollationAlternate.Shifted:
				writer.WriteStringValue("shifted");
				return;
			case IcuCollationAlternate.NonIgnorable:
				writer.WriteStringValue("non-ignorable");
				return;
		}

		writer.WriteNullValue();
	}
}

[JsonConverter(typeof(IcuCollationCaseFirstConverter))]
public enum IcuCollationCaseFirst
{
	[EnumMember(Value = "upper")]
	Upper,
	[EnumMember(Value = "lower")]
	Lower
}

internal sealed class IcuCollationCaseFirstConverter : JsonConverter<IcuCollationCaseFirst>
{
	public override IcuCollationCaseFirst Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
	{
		var enumString = reader.GetString();
		switch (enumString)
		{
			case "upper":
				return IcuCollationCaseFirst.Upper;
			case "lower":
				return IcuCollationCaseFirst.Lower;
		}

		ThrowHelper.ThrowJsonException();
		return default;
	}

	public override void Write(Utf8JsonWriter writer, IcuCollationCaseFirst value, JsonSerializerOptions options)
	{
		switch (value)
		{
			case IcuCollationCaseFirst.Upper:
				writer.WriteStringValue("upper");
				return;
			case IcuCollationCaseFirst.Lower:
				writer.WriteStringValue("lower");
				return;
		}

		writer.WriteNullValue();
	}
}

[JsonConverter(typeof(IcuCollationDecompositionConverter))]
public enum IcuCollationDecomposition
{
	[EnumMember(Value = "no")]
	No,
	[EnumMember(Value = "identical")]
	Identical
}

internal sealed class IcuCollationDecompositionConverter : JsonConverter<IcuCollationDecomposition>
{
	public override IcuCollationDecomposition Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
	{
		var enumString = reader.GetString();
		switch (enumString)
		{
			case "no":
				return IcuCollationDecomposition.No;
			case "identical":
				return IcuCollationDecomposition.Identical;
		}

		ThrowHelper.ThrowJsonException();
		return default;
	}

	public override void Write(Utf8JsonWriter writer, IcuCollationDecomposition value, JsonSerializerOptions options)
	{
		switch (value)
		{
			case IcuCollationDecomposition.No:
				writer.WriteStringValue("no");
				return;
			case IcuCollationDecomposition.Identical:
				writer.WriteStringValue("identical");
				return;
		}

		writer.WriteNullValue();
	}
}

[JsonConverter(typeof(IcuCollationStrengthConverter))]
public enum IcuCollationStrength
{
	[EnumMember(Value = "tertiary")]
	Tertiary,
	[EnumMember(Value = "secondary")]
	Secondary,
	[EnumMember(Value = "quaternary")]
	Quaternary,
	[EnumMember(Value = "primary")]
	Primary,
	[EnumMember(Value = "identical")]
	Identical
}

internal sealed class IcuCollationStrengthConverter : JsonConverter<IcuCollationStrength>
{
	public override IcuCollationStrength Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
	{
		var enumString = reader.GetString();
		switch (enumString)
		{
			case "tertiary":
				return IcuCollationStrength.Tertiary;
			case "secondary":
				return IcuCollationStrength.Secondary;
			case "quaternary":
				return IcuCollationStrength.Quaternary;
			case "primary":
				return IcuCollationStrength.Primary;
			case "identical":
				return IcuCollationStrength.Identical;
		}

		ThrowHelper.ThrowJsonException();
		return default;
	}

	public override void Write(Utf8JsonWriter writer, IcuCollationStrength value, JsonSerializerOptions options)
	{
		switch (value)
		{
			case IcuCollationStrength.Tertiary:
				writer.WriteStringValue("tertiary");
				return;
			case IcuCollationStrength.Secondary:
				writer.WriteStringValue("secondary");
				return;
			case IcuCollationStrength.Quaternary:
				writer.WriteStringValue("quaternary");
				return;
			case IcuCollationStrength.Primary:
				writer.WriteStringValue("primary");
				return;
			case IcuCollationStrength.Identical:
				writer.WriteStringValue("identical");
				return;
		}

		writer.WriteNullValue();
	}
}

[JsonConverter(typeof(IcuNormalizationModeConverter))]
public enum IcuNormalizationMode
{
	[EnumMember(Value = "decompose")]
	Decompose,
	[EnumMember(Value = "compose")]
	Compose
}

internal sealed class IcuNormalizationModeConverter : JsonConverter<IcuNormalizationMode>
{
	public override IcuNormalizationMode Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
	{
		var enumString = reader.GetString();
		switch (enumString)
		{
			case "decompose":
				return IcuNormalizationMode.Decompose;
			case "compose":
				return IcuNormalizationMode.Compose;
		}

		ThrowHelper.ThrowJsonException();
		return default;
	}

	public override void Write(Utf8JsonWriter writer, IcuNormalizationMode value, JsonSerializerOptions options)
	{
		switch (value)
		{
			case IcuNormalizationMode.Decompose:
				writer.WriteStringValue("decompose");
				return;
			case IcuNormalizationMode.Compose:
				writer.WriteStringValue("compose");
				return;
		}

		writer.WriteNullValue();
	}
}

[JsonConverter(typeof(IcuNormalizationTypeConverter))]
public enum IcuNormalizationType
{
	[EnumMember(Value = "nfkc_cf")]
	NfkcCf,
	[EnumMember(Value = "nfkc")]
	Nfkc,
	[EnumMember(Value = "nfc")]
	Nfc
}

internal sealed class IcuNormalizationTypeConverter : JsonConverter<IcuNormalizationType>
{
	public override IcuNormalizationType Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
	{
		var enumString = reader.GetString();
		switch (enumString)
		{
			case "nfkc_cf":
				return IcuNormalizationType.NfkcCf;
			case "nfkc":
				return IcuNormalizationType.Nfkc;
			case "nfc":
				return IcuNormalizationType.Nfc;
		}

		ThrowHelper.ThrowJsonException();
		return default;
	}

	public override void Write(Utf8JsonWriter writer, IcuNormalizationType value, JsonSerializerOptions options)
	{
		switch (value)
		{
			case IcuNormalizationType.NfkcCf:
				writer.WriteStringValue("nfkc_cf");
				return;
			case IcuNormalizationType.Nfkc:
				writer.WriteStringValue("nfkc");
				return;
			case IcuNormalizationType.Nfc:
				writer.WriteStringValue("nfc");
				return;
		}

		writer.WriteNullValue();
	}
}

[JsonConverter(typeof(IcuTransformDirectionConverter))]
public enum IcuTransformDirection
{
	[EnumMember(Value = "reverse")]
	Reverse,
	[EnumMember(Value = "forward")]
	Forward
}

internal sealed class IcuTransformDirectionConverter : JsonConverter<IcuTransformDirection>
{
	public override IcuTransformDirection Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
	{
		var enumString = reader.GetString();
		switch (enumString)
		{
			case "reverse":
				return IcuTransformDirection.Reverse;
			case "forward":
				return IcuTransformDirection.Forward;
		}

		ThrowHelper.ThrowJsonException();
		return default;
	}

	public override void Write(Utf8JsonWriter writer, IcuTransformDirection value, JsonSerializerOptions options)
	{
		switch (value)
		{
			case IcuTransformDirection.Reverse:
				writer.WriteStringValue("reverse");
				return;
			case IcuTransformDirection.Forward:
				writer.WriteStringValue("forward");
				return;
		}

		writer.WriteNullValue();
	}
}

[JsonConverter(typeof(KeepTypesModeConverter))]
public enum KeepTypesMode
{
	[EnumMember(Value = "include")]
	Include,
	[EnumMember(Value = "exclude")]
	Exclude
}

internal sealed class KeepTypesModeConverter : JsonConverter<KeepTypesMode>
{
	public override KeepTypesMode Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
	{
		var enumString = reader.GetString();
		switch (enumString)
		{
			case "include":
				return KeepTypesMode.Include;
			case "exclude":
				return KeepTypesMode.Exclude;
		}

		ThrowHelper.ThrowJsonException();
		return default;
	}

	public override void Write(Utf8JsonWriter writer, KeepTypesMode value, JsonSerializerOptions options)
	{
		switch (value)
		{
			case KeepTypesMode.Include:
				writer.WriteStringValue("include");
				return;
			case KeepTypesMode.Exclude:
				writer.WriteStringValue("exclude");
				return;
		}

		writer.WriteNullValue();
	}
}

[JsonConverter(typeof(KuromojiTokenizationModeConverter))]
public enum KuromojiTokenizationMode
{
	[EnumMember(Value = "search")]
	Search,
	[EnumMember(Value = "normal")]
	Normal,
	[EnumMember(Value = "extended")]
	Extended
}

internal sealed class KuromojiTokenizationModeConverter : JsonConverter<KuromojiTokenizationMode>
{
	public override KuromojiTokenizationMode Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
	{
		var enumString = reader.GetString();
		switch (enumString)
		{
			case "search":
				return KuromojiTokenizationMode.Search;
			case "normal":
				return KuromojiTokenizationMode.Normal;
			case "extended":
				return KuromojiTokenizationMode.Extended;
		}

		ThrowHelper.ThrowJsonException();
		return default;
	}

	public override void Write(Utf8JsonWriter writer, KuromojiTokenizationMode value, JsonSerializerOptions options)
	{
		switch (value)
		{
			case KuromojiTokenizationMode.Search:
				writer.WriteStringValue("search");
				return;
			case KuromojiTokenizationMode.Normal:
				writer.WriteStringValue("normal");
				return;
			case KuromojiTokenizationMode.Extended:
				writer.WriteStringValue("extended");
				return;
		}

		writer.WriteNullValue();
	}
}

[JsonConverter(typeof(LowercaseTokenFilterLanguagesConverter))]
public enum LowercaseTokenFilterLanguages
{
	[EnumMember(Value = "turkish")]
	Turkish,
	[EnumMember(Value = "irish")]
	Irish,
	[EnumMember(Value = "greek")]
	Greek
}

internal sealed class LowercaseTokenFilterLanguagesConverter : JsonConverter<LowercaseTokenFilterLanguages>
{
	public override LowercaseTokenFilterLanguages Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
	{
		var enumString = reader.GetString();
		switch (enumString)
		{
			case "turkish":
				return LowercaseTokenFilterLanguages.Turkish;
			case "irish":
				return LowercaseTokenFilterLanguages.Irish;
			case "greek":
				return LowercaseTokenFilterLanguages.Greek;
		}

		ThrowHelper.ThrowJsonException();
		return default;
	}

	public override void Write(Utf8JsonWriter writer, LowercaseTokenFilterLanguages value, JsonSerializerOptions options)
	{
		switch (value)
		{
			case LowercaseTokenFilterLanguages.Turkish:
				writer.WriteStringValue("turkish");
				return;
			case LowercaseTokenFilterLanguages.Irish:
				writer.WriteStringValue("irish");
				return;
			case LowercaseTokenFilterLanguages.Greek:
				writer.WriteStringValue("greek");
				return;
		}

		writer.WriteNullValue();
	}
}

[JsonConverter(typeof(NoriDecompoundModeConverter))]
public enum NoriDecompoundMode
{
	[EnumMember(Value = "none")]
	None,
	[EnumMember(Value = "mixed")]
	Mixed,
	[EnumMember(Value = "discard")]
	Discard
}

internal sealed class NoriDecompoundModeConverter : JsonConverter<NoriDecompoundMode>
{
	public override NoriDecompoundMode Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
	{
		var enumString = reader.GetString();
		switch (enumString)
		{
			case "none":
				return NoriDecompoundMode.None;
			case "mixed":
				return NoriDecompoundMode.Mixed;
			case "discard":
				return NoriDecompoundMode.Discard;
		}

		ThrowHelper.ThrowJsonException();
		return default;
	}

	public override void Write(Utf8JsonWriter writer, NoriDecompoundMode value, JsonSerializerOptions options)
	{
		switch (value)
		{
			case NoriDecompoundMode.None:
				writer.WriteStringValue("none");
				return;
			case NoriDecompoundMode.Mixed:
				writer.WriteStringValue("mixed");
				return;
			case NoriDecompoundMode.Discard:
				writer.WriteStringValue("discard");
				return;
		}

		writer.WriteNullValue();
	}
}

[JsonConverter(typeof(PhoneticEncoderConverter))]
public enum PhoneticEncoder
{
	[EnumMember(Value = "soundex")]
	Soundex,
	[EnumMember(Value = "refined_soundex")]
	RefinedSoundex,
	[EnumMember(Value = "nysiis")]
	Nysiis,
	[EnumMember(Value = "metaphone")]
	Metaphone,
	[EnumMember(Value = "koelnerphonetik")]
	Koelnerphonetik,
	[EnumMember(Value = "haasephonetik")]
	Haasephonetik,
	[EnumMember(Value = "double_metaphone")]
	DoubleMetaphone,
	[EnumMember(Value = "daitch_mokotoff")]
	DaitchMokotoff,
	[EnumMember(Value = "cologne")]
	Cologne,
	[EnumMember(Value = "caverphone2")]
	Caverphone2,
	[EnumMember(Value = "caverphone1")]
	Caverphone1,
	[EnumMember(Value = "beider_morse")]
	BeiderMorse
}

internal sealed class PhoneticEncoderConverter : JsonConverter<PhoneticEncoder>
{
	public override PhoneticEncoder Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
	{
		var enumString = reader.GetString();
		switch (enumString)
		{
			case "soundex":
				return PhoneticEncoder.Soundex;
			case "refined_soundex":
				return PhoneticEncoder.RefinedSoundex;
			case "nysiis":
				return PhoneticEncoder.Nysiis;
			case "metaphone":
				return PhoneticEncoder.Metaphone;
			case "koelnerphonetik":
				return PhoneticEncoder.Koelnerphonetik;
			case "haasephonetik":
				return PhoneticEncoder.Haasephonetik;
			case "double_metaphone":
				return PhoneticEncoder.DoubleMetaphone;
			case "daitch_mokotoff":
				return PhoneticEncoder.DaitchMokotoff;
			case "cologne":
				return PhoneticEncoder.Cologne;
			case "caverphone2":
				return PhoneticEncoder.Caverphone2;
			case "caverphone1":
				return PhoneticEncoder.Caverphone1;
			case "beider_morse":
				return PhoneticEncoder.BeiderMorse;
		}

		ThrowHelper.ThrowJsonException();
		return default;
	}

	public override void Write(Utf8JsonWriter writer, PhoneticEncoder value, JsonSerializerOptions options)
	{
		switch (value)
		{
			case PhoneticEncoder.Soundex:
				writer.WriteStringValue("soundex");
				return;
			case PhoneticEncoder.RefinedSoundex:
				writer.WriteStringValue("refined_soundex");
				return;
			case PhoneticEncoder.Nysiis:
				writer.WriteStringValue("nysiis");
				return;
			case PhoneticEncoder.Metaphone:
				writer.WriteStringValue("metaphone");
				return;
			case PhoneticEncoder.Koelnerphonetik:
				writer.WriteStringValue("koelnerphonetik");
				return;
			case PhoneticEncoder.Haasephonetik:
				writer.WriteStringValue("haasephonetik");
				return;
			case PhoneticEncoder.DoubleMetaphone:
				writer.WriteStringValue("double_metaphone");
				return;
			case PhoneticEncoder.DaitchMokotoff:
				writer.WriteStringValue("daitch_mokotoff");
				return;
			case PhoneticEncoder.Cologne:
				writer.WriteStringValue("cologne");
				return;
			case PhoneticEncoder.Caverphone2:
				writer.WriteStringValue("caverphone2");
				return;
			case PhoneticEncoder.Caverphone1:
				writer.WriteStringValue("caverphone1");
				return;
			case PhoneticEncoder.BeiderMorse:
				writer.WriteStringValue("beider_morse");
				return;
		}

		writer.WriteNullValue();
	}
}

[JsonConverter(typeof(PhoneticLanguageConverter))]
public enum PhoneticLanguage
{
	[EnumMember(Value = "spanish")]
	Spanish,
	[EnumMember(Value = "russian")]
	Russian,
	[EnumMember(Value = "romanian")]
	Romanian,
	[EnumMember(Value = "polish")]
	Polish,
	[EnumMember(Value = "hungarian")]
	Hungarian,
	[EnumMember(Value = "hebrew")]
	Hebrew,
	[EnumMember(Value = "german")]
	German,
	[EnumMember(Value = "french")]
	French,
	[EnumMember(Value = "english")]
	English,
	[EnumMember(Value = "cyrillic")]
	Cyrillic,
	[EnumMember(Value = "common")]
	Common,
	[EnumMember(Value = "any")]
	Any
}

internal sealed class PhoneticLanguageConverter : JsonConverter<PhoneticLanguage>
{
	public override PhoneticLanguage Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
	{
		var enumString = reader.GetString();
		switch (enumString)
		{
			case "spanish":
				return PhoneticLanguage.Spanish;
			case "russian":
				return PhoneticLanguage.Russian;
			case "romanian":
				return PhoneticLanguage.Romanian;
			case "polish":
				return PhoneticLanguage.Polish;
			case "hungarian":
				return PhoneticLanguage.Hungarian;
			case "hebrew":
				return PhoneticLanguage.Hebrew;
			case "german":
				return PhoneticLanguage.German;
			case "french":
				return PhoneticLanguage.French;
			case "english":
				return PhoneticLanguage.English;
			case "cyrillic":
				return PhoneticLanguage.Cyrillic;
			case "common":
				return PhoneticLanguage.Common;
			case "any":
				return PhoneticLanguage.Any;
		}

		ThrowHelper.ThrowJsonException();
		return default;
	}

	public override void Write(Utf8JsonWriter writer, PhoneticLanguage value, JsonSerializerOptions options)
	{
		switch (value)
		{
			case PhoneticLanguage.Spanish:
				writer.WriteStringValue("spanish");
				return;
			case PhoneticLanguage.Russian:
				writer.WriteStringValue("russian");
				return;
			case PhoneticLanguage.Romanian:
				writer.WriteStringValue("romanian");
				return;
			case PhoneticLanguage.Polish:
				writer.WriteStringValue("polish");
				return;
			case PhoneticLanguage.Hungarian:
				writer.WriteStringValue("hungarian");
				return;
			case PhoneticLanguage.Hebrew:
				writer.WriteStringValue("hebrew");
				return;
			case PhoneticLanguage.German:
				writer.WriteStringValue("german");
				return;
			case PhoneticLanguage.French:
				writer.WriteStringValue("french");
				return;
			case PhoneticLanguage.English:
				writer.WriteStringValue("english");
				return;
			case PhoneticLanguage.Cyrillic:
				writer.WriteStringValue("cyrillic");
				return;
			case PhoneticLanguage.Common:
				writer.WriteStringValue("common");
				return;
			case PhoneticLanguage.Any:
				writer.WriteStringValue("any");
				return;
		}

		writer.WriteNullValue();
	}
}

[JsonConverter(typeof(PhoneticNameTypeConverter))]
public enum PhoneticNameType
{
	[EnumMember(Value = "sephardic")]
	Sephardic,
	[EnumMember(Value = "generic")]
	Generic,
	[EnumMember(Value = "ashkenazi")]
	Ashkenazi
}

internal sealed class PhoneticNameTypeConverter : JsonConverter<PhoneticNameType>
{
	public override PhoneticNameType Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
	{
		var enumString = reader.GetString();
		switch (enumString)
		{
			case "sephardic":
				return PhoneticNameType.Sephardic;
			case "generic":
				return PhoneticNameType.Generic;
			case "ashkenazi":
				return PhoneticNameType.Ashkenazi;
		}

		ThrowHelper.ThrowJsonException();
		return default;
	}

	public override void Write(Utf8JsonWriter writer, PhoneticNameType value, JsonSerializerOptions options)
	{
		switch (value)
		{
			case PhoneticNameType.Sephardic:
				writer.WriteStringValue("sephardic");
				return;
			case PhoneticNameType.Generic:
				writer.WriteStringValue("generic");
				return;
			case PhoneticNameType.Ashkenazi:
				writer.WriteStringValue("ashkenazi");
				return;
		}

		writer.WriteNullValue();
	}
}

[JsonConverter(typeof(PhoneticRuleTypeConverter))]
public enum PhoneticRuleType
{
	[EnumMember(Value = "exact")]
	Exact,
	[EnumMember(Value = "approx")]
	Approx
}

internal sealed class PhoneticRuleTypeConverter : JsonConverter<PhoneticRuleType>
{
	public override PhoneticRuleType Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
	{
		var enumString = reader.GetString();
		switch (enumString)
		{
			case "exact":
				return PhoneticRuleType.Exact;
			case "approx":
				return PhoneticRuleType.Approx;
		}

		ThrowHelper.ThrowJsonException();
		return default;
	}

	public override void Write(Utf8JsonWriter writer, PhoneticRuleType value, JsonSerializerOptions options)
	{
		switch (value)
		{
			case PhoneticRuleType.Exact:
				writer.WriteStringValue("exact");
				return;
			case PhoneticRuleType.Approx:
				writer.WriteStringValue("approx");
				return;
		}

		writer.WriteNullValue();
	}
}

[JsonConverter(typeof(SnowballLanguageConverter))]
public enum SnowballLanguage
{
	[EnumMember(Value = "Turkish")]
	Turkish,
	[EnumMember(Value = "Swedish")]
	Swedish,
	[EnumMember(Value = "Spanish")]
	Spanish,
	[EnumMember(Value = "Serbian")]
	Serbian,
	[EnumMember(Value = "Russian")]
	Russian,
	[EnumMember(Value = "Romanian")]
	Romanian,
	[EnumMember(Value = "Portuguese")]
	Portuguese,
	[EnumMember(Value = "Porter")]
	Porter,
	[EnumMember(Value = "Norwegian")]
	Norwegian,
	[EnumMember(Value = "Lovins")]
	Lovins,
	[EnumMember(Value = "Lithuanian")]
	Lithuanian,
	[EnumMember(Value = "Kp")]
	Kp,
	[EnumMember(Value = "Italian")]
	Italian,
	[EnumMember(Value = "Irish")]
	Irish,
	[EnumMember(Value = "Hungarian")]
	Hungarian,
	[EnumMember(Value = "German2")]
	German2,
	[EnumMember(Value = "German")]
	German,
	[EnumMember(Value = "French")]
	French,
	[EnumMember(Value = "Finnish")]
	Finnish,
	[EnumMember(Value = "Estonian")]
	Estonian,
	[EnumMember(Value = "English")]
	English,
	[EnumMember(Value = "Dutch")]
	Dutch,
	[EnumMember(Value = "Danish")]
	Danish,
	[EnumMember(Value = "Catalan")]
	Catalan,
	[EnumMember(Value = "Basque")]
	Basque,
	[EnumMember(Value = "Armenian")]
	Armenian,
	[EnumMember(Value = "Arabic")]
	Arabic
}

internal sealed class SnowballLanguageConverter : JsonConverter<SnowballLanguage>
{
	public override SnowballLanguage Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
	{
		var enumString = reader.GetString();
		switch (enumString)
		{
			case "Turkish":
				return SnowballLanguage.Turkish;
			case "Swedish":
				return SnowballLanguage.Swedish;
			case "Spanish":
				return SnowballLanguage.Spanish;
			case "Serbian":
				return SnowballLanguage.Serbian;
			case "Russian":
				return SnowballLanguage.Russian;
			case "Romanian":
				return SnowballLanguage.Romanian;
			case "Portuguese":
				return SnowballLanguage.Portuguese;
			case "Porter":
				return SnowballLanguage.Porter;
			case "Norwegian":
				return SnowballLanguage.Norwegian;
			case "Lovins":
				return SnowballLanguage.Lovins;
			case "Lithuanian":
				return SnowballLanguage.Lithuanian;
			case "Kp":
				return SnowballLanguage.Kp;
			case "Italian":
				return SnowballLanguage.Italian;
			case "Irish":
				return SnowballLanguage.Irish;
			case "Hungarian":
				return SnowballLanguage.Hungarian;
			case "German2":
				return SnowballLanguage.German2;
			case "German":
				return SnowballLanguage.German;
			case "French":
				return SnowballLanguage.French;
			case "Finnish":
				return SnowballLanguage.Finnish;
			case "Estonian":
				return SnowballLanguage.Estonian;
			case "English":
				return SnowballLanguage.English;
			case "Dutch":
				return SnowballLanguage.Dutch;
			case "Danish":
				return SnowballLanguage.Danish;
			case "Catalan":
				return SnowballLanguage.Catalan;
			case "Basque":
				return SnowballLanguage.Basque;
			case "Armenian":
				return SnowballLanguage.Armenian;
			case "Arabic":
				return SnowballLanguage.Arabic;
		}

		ThrowHelper.ThrowJsonException();
		return default;
	}

	public override void Write(Utf8JsonWriter writer, SnowballLanguage value, JsonSerializerOptions options)
	{
		switch (value)
		{
			case SnowballLanguage.Turkish:
				writer.WriteStringValue("Turkish");
				return;
			case SnowballLanguage.Swedish:
				writer.WriteStringValue("Swedish");
				return;
			case SnowballLanguage.Spanish:
				writer.WriteStringValue("Spanish");
				return;
			case SnowballLanguage.Serbian:
				writer.WriteStringValue("Serbian");
				return;
			case SnowballLanguage.Russian:
				writer.WriteStringValue("Russian");
				return;
			case SnowballLanguage.Romanian:
				writer.WriteStringValue("Romanian");
				return;
			case SnowballLanguage.Portuguese:
				writer.WriteStringValue("Portuguese");
				return;
			case SnowballLanguage.Porter:
				writer.WriteStringValue("Porter");
				return;
			case SnowballLanguage.Norwegian:
				writer.WriteStringValue("Norwegian");
				return;
			case SnowballLanguage.Lovins:
				writer.WriteStringValue("Lovins");
				return;
			case SnowballLanguage.Lithuanian:
				writer.WriteStringValue("Lithuanian");
				return;
			case SnowballLanguage.Kp:
				writer.WriteStringValue("Kp");
				return;
			case SnowballLanguage.Italian:
				writer.WriteStringValue("Italian");
				return;
			case SnowballLanguage.Irish:
				writer.WriteStringValue("Irish");
				return;
			case SnowballLanguage.Hungarian:
				writer.WriteStringValue("Hungarian");
				return;
			case SnowballLanguage.German2:
				writer.WriteStringValue("German2");
				return;
			case SnowballLanguage.German:
				writer.WriteStringValue("German");
				return;
			case SnowballLanguage.French:
				writer.WriteStringValue("French");
				return;
			case SnowballLanguage.Finnish:
				writer.WriteStringValue("Finnish");
				return;
			case SnowballLanguage.Estonian:
				writer.WriteStringValue("Estonian");
				return;
			case SnowballLanguage.English:
				writer.WriteStringValue("English");
				return;
			case SnowballLanguage.Dutch:
				writer.WriteStringValue("Dutch");
				return;
			case SnowballLanguage.Danish:
				writer.WriteStringValue("Danish");
				return;
			case SnowballLanguage.Catalan:
				writer.WriteStringValue("Catalan");
				return;
			case SnowballLanguage.Basque:
				writer.WriteStringValue("Basque");
				return;
			case SnowballLanguage.Armenian:
				writer.WriteStringValue("Armenian");
				return;
			case SnowballLanguage.Arabic:
				writer.WriteStringValue("Arabic");
				return;
		}

		writer.WriteNullValue();
	}
}

[JsonConverter(typeof(StopWordLanguageConverter))]
public enum StopWordLanguage
{
	[EnumMember(Value = "_turkish_")]
	Turkish,
	[EnumMember(Value = "_thai_")]
	Thai,
	[EnumMember(Value = "_swedish_")]
	Swedish,
	[EnumMember(Value = "_spanish_")]
	Spanish,
	[EnumMember(Value = "_sorani_")]
	Sorani,
	[EnumMember(Value = "_serbian_")]
	Serbian,
	[EnumMember(Value = "_russian_")]
	Russian,
	[EnumMember(Value = "_romanian_")]
	Romanian,
	[EnumMember(Value = "_portuguese_")]
	Portuguese,
	[EnumMember(Value = "_persian_")]
	Persian,
	[EnumMember(Value = "_norwegian_")]
	Norwegian,
	[EnumMember(Value = "_none_")]
	None,
	[EnumMember(Value = "_lithuanian_")]
	Lithuanian,
	[EnumMember(Value = "_latvian_")]
	Latvian,
	[EnumMember(Value = "_italian_")]
	Italian,
	[EnumMember(Value = "_irish_")]
	Irish,
	[EnumMember(Value = "_indonesian_")]
	Indonesian,
	[EnumMember(Value = "_hungarian_")]
	Hungarian,
	[EnumMember(Value = "_hindi_")]
	Hindi,
	[EnumMember(Value = "_greek_")]
	Greek,
	[EnumMember(Value = "_german_")]
	German,
	[EnumMember(Value = "_galician_")]
	Galician,
	[EnumMember(Value = "_french_")]
	French,
	[EnumMember(Value = "_finnish_")]
	Finnish,
	[EnumMember(Value = "_estonian_")]
	Estonian,
	[EnumMember(Value = "_english_")]
	English,
	[EnumMember(Value = "_dutch_")]
	Dutch,
	[EnumMember(Value = "_danish_")]
	Danish,
	[EnumMember(Value = "_czech_")]
	Czech,
	[EnumMember(Value = "_cjk_")]
	Cjk,
	[EnumMember(Value = "_catalan_")]
	Catalan,
	[EnumMember(Value = "_bulgarian_")]
	Bulgarian,
	[EnumMember(Value = "_brazilian_")]
	Brazilian,
	[EnumMember(Value = "_bengali_")]
	Bengali,
	[EnumMember(Value = "_basque_")]
	Basque,
	[EnumMember(Value = "_armenian_")]
	Armenian,
	[EnumMember(Value = "_arabic_")]
	Arabic
}

internal sealed class StopWordLanguageConverter : JsonConverter<StopWordLanguage>
{
	public override StopWordLanguage Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
	{
		var enumString = reader.GetString();
		switch (enumString)
		{
			case "_turkish_":
				return StopWordLanguage.Turkish;
			case "_thai_":
				return StopWordLanguage.Thai;
			case "_swedish_":
				return StopWordLanguage.Swedish;
			case "_spanish_":
				return StopWordLanguage.Spanish;
			case "_sorani_":
				return StopWordLanguage.Sorani;
			case "_serbian_":
				return StopWordLanguage.Serbian;
			case "_russian_":
				return StopWordLanguage.Russian;
			case "_romanian_":
				return StopWordLanguage.Romanian;
			case "_portuguese_":
				return StopWordLanguage.Portuguese;
			case "_persian_":
				return StopWordLanguage.Persian;
			case "_norwegian_":
				return StopWordLanguage.Norwegian;
			case "_none_":
				return StopWordLanguage.None;
			case "_lithuanian_":
				return StopWordLanguage.Lithuanian;
			case "_latvian_":
				return StopWordLanguage.Latvian;
			case "_italian_":
				return StopWordLanguage.Italian;
			case "_irish_":
				return StopWordLanguage.Irish;
			case "_indonesian_":
				return StopWordLanguage.Indonesian;
			case "_hungarian_":
				return StopWordLanguage.Hungarian;
			case "_hindi_":
				return StopWordLanguage.Hindi;
			case "_greek_":
				return StopWordLanguage.Greek;
			case "_german_":
				return StopWordLanguage.German;
			case "_galician_":
				return StopWordLanguage.Galician;
			case "_french_":
				return StopWordLanguage.French;
			case "_finnish_":
				return StopWordLanguage.Finnish;
			case "_estonian_":
				return StopWordLanguage.Estonian;
			case "_english_":
				return StopWordLanguage.English;
			case "_dutch_":
				return StopWordLanguage.Dutch;
			case "_danish_":
				return StopWordLanguage.Danish;
			case "_czech_":
				return StopWordLanguage.Czech;
			case "_cjk_":
				return StopWordLanguage.Cjk;
			case "_catalan_":
				return StopWordLanguage.Catalan;
			case "_bulgarian_":
				return StopWordLanguage.Bulgarian;
			case "_brazilian_":
				return StopWordLanguage.Brazilian;
			case "_bengali_":
				return StopWordLanguage.Bengali;
			case "_basque_":
				return StopWordLanguage.Basque;
			case "_armenian_":
				return StopWordLanguage.Armenian;
			case "_arabic_":
				return StopWordLanguage.Arabic;
		}

		ThrowHelper.ThrowJsonException();
		return default;
	}

	public override void Write(Utf8JsonWriter writer, StopWordLanguage value, JsonSerializerOptions options)
	{
		switch (value)
		{
			case StopWordLanguage.Turkish:
				writer.WriteStringValue("_turkish_");
				return;
			case StopWordLanguage.Thai:
				writer.WriteStringValue("_thai_");
				return;
			case StopWordLanguage.Swedish:
				writer.WriteStringValue("_swedish_");
				return;
			case StopWordLanguage.Spanish:
				writer.WriteStringValue("_spanish_");
				return;
			case StopWordLanguage.Sorani:
				writer.WriteStringValue("_sorani_");
				return;
			case StopWordLanguage.Serbian:
				writer.WriteStringValue("_serbian_");
				return;
			case StopWordLanguage.Russian:
				writer.WriteStringValue("_russian_");
				return;
			case StopWordLanguage.Romanian:
				writer.WriteStringValue("_romanian_");
				return;
			case StopWordLanguage.Portuguese:
				writer.WriteStringValue("_portuguese_");
				return;
			case StopWordLanguage.Persian:
				writer.WriteStringValue("_persian_");
				return;
			case StopWordLanguage.Norwegian:
				writer.WriteStringValue("_norwegian_");
				return;
			case StopWordLanguage.None:
				writer.WriteStringValue("_none_");
				return;
			case StopWordLanguage.Lithuanian:
				writer.WriteStringValue("_lithuanian_");
				return;
			case StopWordLanguage.Latvian:
				writer.WriteStringValue("_latvian_");
				return;
			case StopWordLanguage.Italian:
				writer.WriteStringValue("_italian_");
				return;
			case StopWordLanguage.Irish:
				writer.WriteStringValue("_irish_");
				return;
			case StopWordLanguage.Indonesian:
				writer.WriteStringValue("_indonesian_");
				return;
			case StopWordLanguage.Hungarian:
				writer.WriteStringValue("_hungarian_");
				return;
			case StopWordLanguage.Hindi:
				writer.WriteStringValue("_hindi_");
				return;
			case StopWordLanguage.Greek:
				writer.WriteStringValue("_greek_");
				return;
			case StopWordLanguage.German:
				writer.WriteStringValue("_german_");
				return;
			case StopWordLanguage.Galician:
				writer.WriteStringValue("_galician_");
				return;
			case StopWordLanguage.French:
				writer.WriteStringValue("_french_");
				return;
			case StopWordLanguage.Finnish:
				writer.WriteStringValue("_finnish_");
				return;
			case StopWordLanguage.Estonian:
				writer.WriteStringValue("_estonian_");
				return;
			case StopWordLanguage.English:
				writer.WriteStringValue("_english_");
				return;
			case StopWordLanguage.Dutch:
				writer.WriteStringValue("_dutch_");
				return;
			case StopWordLanguage.Danish:
				writer.WriteStringValue("_danish_");
				return;
			case StopWordLanguage.Czech:
				writer.WriteStringValue("_czech_");
				return;
			case StopWordLanguage.Cjk:
				writer.WriteStringValue("_cjk_");
				return;
			case StopWordLanguage.Catalan:
				writer.WriteStringValue("_catalan_");
				return;
			case StopWordLanguage.Bulgarian:
				writer.WriteStringValue("_bulgarian_");
				return;
			case StopWordLanguage.Brazilian:
				writer.WriteStringValue("_brazilian_");
				return;
			case StopWordLanguage.Bengali:
				writer.WriteStringValue("_bengali_");
				return;
			case StopWordLanguage.Basque:
				writer.WriteStringValue("_basque_");
				return;
			case StopWordLanguage.Armenian:
				writer.WriteStringValue("_armenian_");
				return;
			case StopWordLanguage.Arabic:
				writer.WriteStringValue("_arabic_");
				return;
		}

		writer.WriteNullValue();
	}
}

[JsonConverter(typeof(SynonymFormatConverter))]
public enum SynonymFormat
{
	[EnumMember(Value = "wordnet")]
	Wordnet,
	[EnumMember(Value = "solr")]
	Solr
}

internal sealed class SynonymFormatConverter : JsonConverter<SynonymFormat>
{
	public override SynonymFormat Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
	{
		var enumString = reader.GetString();
		switch (enumString)
		{
			case "wordnet":
				return SynonymFormat.Wordnet;
			case "solr":
				return SynonymFormat.Solr;
		}

		ThrowHelper.ThrowJsonException();
		return default;
	}

	public override void Write(Utf8JsonWriter writer, SynonymFormat value, JsonSerializerOptions options)
	{
		switch (value)
		{
			case SynonymFormat.Wordnet:
				writer.WriteStringValue("wordnet");
				return;
			case SynonymFormat.Solr:
				writer.WriteStringValue("solr");
				return;
		}

		writer.WriteNullValue();
	}
}

[JsonConverter(typeof(TokenCharConverter))]
public enum TokenChar
{
	[EnumMember(Value = "whitespace")]
	Whitespace,
	[EnumMember(Value = "symbol")]
	Symbol,
	[EnumMember(Value = "punctuation")]
	Punctuation,
	[EnumMember(Value = "letter")]
	Letter,
	[EnumMember(Value = "digit")]
	Digit,
	[EnumMember(Value = "custom")]
	Custom
}

internal sealed class TokenCharConverter : JsonConverter<TokenChar>
{
	public override TokenChar Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
	{
		var enumString = reader.GetString();
		switch (enumString)
		{
			case "whitespace":
				return TokenChar.Whitespace;
			case "symbol":
				return TokenChar.Symbol;
			case "punctuation":
				return TokenChar.Punctuation;
			case "letter":
				return TokenChar.Letter;
			case "digit":
				return TokenChar.Digit;
			case "custom":
				return TokenChar.Custom;
		}

		ThrowHelper.ThrowJsonException();
		return default;
	}

	public override void Write(Utf8JsonWriter writer, TokenChar value, JsonSerializerOptions options)
	{
		switch (value)
		{
			case TokenChar.Whitespace:
				writer.WriteStringValue("whitespace");
				return;
			case TokenChar.Symbol:
				writer.WriteStringValue("symbol");
				return;
			case TokenChar.Punctuation:
				writer.WriteStringValue("punctuation");
				return;
			case TokenChar.Letter:
				writer.WriteStringValue("letter");
				return;
			case TokenChar.Digit:
				writer.WriteStringValue("digit");
				return;
			case TokenChar.Custom:
				writer.WriteStringValue("custom");
				return;
		}

		writer.WriteNullValue();
	}
}