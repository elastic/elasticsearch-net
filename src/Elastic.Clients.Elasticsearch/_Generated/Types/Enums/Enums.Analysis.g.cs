// Licensed to Elasticsearch B.V under one or more agreements.
// Elasticsearch B.V licenses this file to you under the Apache 2.0 License.
// See the LICENSE file in the project root for more information.
//
// ███╗   ██╗ ██████╗ ████████╗██╗ ██████╗███████╗
// ████╗  ██║██╔═══██╗╚══██╔══╝██║██╔════╝██╔════╝
// ██╔██╗ ██║██║   ██║   ██║   ██║██║     █████╗
// ██║╚██╗██║██║   ██║   ██║   ██║██║     ██╔══╝
// ██║ ╚████║╚██████╔╝   ██║   ██║╚██████╗███████╗
// ╚═╝  ╚═══╝ ╚═════╝    ╚═╝   ╚═╝ ╚═════╝╚══════╝
// ------------------------------------------------
//
// This file is automatically generated.
// Please do not edit these files manually.
//
// ------------------------------------------------

#nullable restore

using Elastic.Clients.Elasticsearch.Core;
using Elastic.Clients.Elasticsearch.Serialization;
using Elastic.Transport;
using System;
using System.Runtime.Serialization;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace Elastic.Clients.Elasticsearch.Analysis;

[JsonConverter(typeof(DelimitedPayloadEncodingConverter))]
public enum DelimitedPayloadEncoding
{
	[EnumMember(Value = "int")]
	Integer,
	[EnumMember(Value = "identity")]
	Identity,
	[EnumMember(Value = "float")]
	Float
}

internal sealed partial class DelimitedPayloadEncodingConverter : System.Text.Json.Serialization.JsonConverter<DelimitedPayloadEncoding>
{
	private static readonly System.Text.Json.JsonEncodedText MemberInteger = System.Text.Json.JsonEncodedText.Encode("int");
	private static readonly System.Text.Json.JsonEncodedText MemberIdentity = System.Text.Json.JsonEncodedText.Encode("identity");
	private static readonly System.Text.Json.JsonEncodedText MemberFloat = System.Text.Json.JsonEncodedText.Encode("float");

	public override DelimitedPayloadEncoding Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberInteger))
		{
			return DelimitedPayloadEncoding.Integer;
		}

		if (reader.ValueTextEquals(MemberIdentity))
		{
			return DelimitedPayloadEncoding.Identity;
		}

		if (reader.ValueTextEquals(MemberFloat))
		{
			return DelimitedPayloadEncoding.Float;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberInteger.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return DelimitedPayloadEncoding.Integer;
		}

		if (string.Equals(value, MemberIdentity.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return DelimitedPayloadEncoding.Identity;
		}

		if (string.Equals(value, MemberFloat.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return DelimitedPayloadEncoding.Float;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(DelimitedPayloadEncoding)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, DelimitedPayloadEncoding value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case DelimitedPayloadEncoding.Integer:
				writer.WriteStringValue(MemberInteger);
				break;
			case DelimitedPayloadEncoding.Identity:
				writer.WriteStringValue(MemberIdentity);
				break;
			case DelimitedPayloadEncoding.Float:
				writer.WriteStringValue(MemberFloat);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(DelimitedPayloadEncoding)}'.");
		}
	}
}

[JsonConverter(typeof(EdgeNGramSideConverter))]
public enum EdgeNGramSide
{
	[EnumMember(Value = "front")]
	Front,
	[EnumMember(Value = "back")]
	Back
}

internal sealed partial class EdgeNGramSideConverter : System.Text.Json.Serialization.JsonConverter<EdgeNGramSide>
{
	private static readonly System.Text.Json.JsonEncodedText MemberFront = System.Text.Json.JsonEncodedText.Encode("front");
	private static readonly System.Text.Json.JsonEncodedText MemberBack = System.Text.Json.JsonEncodedText.Encode("back");

	public override EdgeNGramSide Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberFront))
		{
			return EdgeNGramSide.Front;
		}

		if (reader.ValueTextEquals(MemberBack))
		{
			return EdgeNGramSide.Back;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberFront.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return EdgeNGramSide.Front;
		}

		if (string.Equals(value, MemberBack.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return EdgeNGramSide.Back;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(EdgeNGramSide)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, EdgeNGramSide value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case EdgeNGramSide.Front:
				writer.WriteStringValue(MemberFront);
				break;
			case EdgeNGramSide.Back:
				writer.WriteStringValue(MemberBack);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(EdgeNGramSide)}'.");
		}
	}
}

[JsonConverter(typeof(IcuCollationAlternateConverter))]
public enum IcuCollationAlternate
{
	[EnumMember(Value = "shifted")]
	Shifted,
	[EnumMember(Value = "non-ignorable")]
	NonIgnorable
}

internal sealed partial class IcuCollationAlternateConverter : System.Text.Json.Serialization.JsonConverter<IcuCollationAlternate>
{
	private static readonly System.Text.Json.JsonEncodedText MemberShifted = System.Text.Json.JsonEncodedText.Encode("shifted");
	private static readonly System.Text.Json.JsonEncodedText MemberNonIgnorable = System.Text.Json.JsonEncodedText.Encode("non-ignorable");

	public override IcuCollationAlternate Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberShifted))
		{
			return IcuCollationAlternate.Shifted;
		}

		if (reader.ValueTextEquals(MemberNonIgnorable))
		{
			return IcuCollationAlternate.NonIgnorable;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberShifted.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return IcuCollationAlternate.Shifted;
		}

		if (string.Equals(value, MemberNonIgnorable.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return IcuCollationAlternate.NonIgnorable;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(IcuCollationAlternate)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, IcuCollationAlternate value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case IcuCollationAlternate.Shifted:
				writer.WriteStringValue(MemberShifted);
				break;
			case IcuCollationAlternate.NonIgnorable:
				writer.WriteStringValue(MemberNonIgnorable);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(IcuCollationAlternate)}'.");
		}
	}
}

[JsonConverter(typeof(IcuCollationCaseFirstConverter))]
public enum IcuCollationCaseFirst
{
	[EnumMember(Value = "upper")]
	Upper,
	[EnumMember(Value = "lower")]
	Lower
}

internal sealed partial class IcuCollationCaseFirstConverter : System.Text.Json.Serialization.JsonConverter<IcuCollationCaseFirst>
{
	private static readonly System.Text.Json.JsonEncodedText MemberUpper = System.Text.Json.JsonEncodedText.Encode("upper");
	private static readonly System.Text.Json.JsonEncodedText MemberLower = System.Text.Json.JsonEncodedText.Encode("lower");

	public override IcuCollationCaseFirst Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberUpper))
		{
			return IcuCollationCaseFirst.Upper;
		}

		if (reader.ValueTextEquals(MemberLower))
		{
			return IcuCollationCaseFirst.Lower;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberUpper.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return IcuCollationCaseFirst.Upper;
		}

		if (string.Equals(value, MemberLower.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return IcuCollationCaseFirst.Lower;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(IcuCollationCaseFirst)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, IcuCollationCaseFirst value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case IcuCollationCaseFirst.Upper:
				writer.WriteStringValue(MemberUpper);
				break;
			case IcuCollationCaseFirst.Lower:
				writer.WriteStringValue(MemberLower);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(IcuCollationCaseFirst)}'.");
		}
	}
}

[JsonConverter(typeof(IcuCollationDecompositionConverter))]
public enum IcuCollationDecomposition
{
	[EnumMember(Value = "no")]
	No,
	[EnumMember(Value = "identical")]
	Identical
}

internal sealed partial class IcuCollationDecompositionConverter : System.Text.Json.Serialization.JsonConverter<IcuCollationDecomposition>
{
	private static readonly System.Text.Json.JsonEncodedText MemberNo = System.Text.Json.JsonEncodedText.Encode("no");
	private static readonly System.Text.Json.JsonEncodedText MemberIdentical = System.Text.Json.JsonEncodedText.Encode("identical");

	public override IcuCollationDecomposition Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberNo))
		{
			return IcuCollationDecomposition.No;
		}

		if (reader.ValueTextEquals(MemberIdentical))
		{
			return IcuCollationDecomposition.Identical;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberNo.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return IcuCollationDecomposition.No;
		}

		if (string.Equals(value, MemberIdentical.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return IcuCollationDecomposition.Identical;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(IcuCollationDecomposition)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, IcuCollationDecomposition value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case IcuCollationDecomposition.No:
				writer.WriteStringValue(MemberNo);
				break;
			case IcuCollationDecomposition.Identical:
				writer.WriteStringValue(MemberIdentical);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(IcuCollationDecomposition)}'.");
		}
	}
}

[JsonConverter(typeof(IcuCollationStrengthConverter))]
public enum IcuCollationStrength
{
	[EnumMember(Value = "tertiary")]
	Tertiary,
	[EnumMember(Value = "secondary")]
	Secondary,
	[EnumMember(Value = "quaternary")]
	Quaternary,
	[EnumMember(Value = "primary")]
	Primary,
	[EnumMember(Value = "identical")]
	Identical
}

internal sealed partial class IcuCollationStrengthConverter : System.Text.Json.Serialization.JsonConverter<IcuCollationStrength>
{
	private static readonly System.Text.Json.JsonEncodedText MemberTertiary = System.Text.Json.JsonEncodedText.Encode("tertiary");
	private static readonly System.Text.Json.JsonEncodedText MemberSecondary = System.Text.Json.JsonEncodedText.Encode("secondary");
	private static readonly System.Text.Json.JsonEncodedText MemberQuaternary = System.Text.Json.JsonEncodedText.Encode("quaternary");
	private static readonly System.Text.Json.JsonEncodedText MemberPrimary = System.Text.Json.JsonEncodedText.Encode("primary");
	private static readonly System.Text.Json.JsonEncodedText MemberIdentical = System.Text.Json.JsonEncodedText.Encode("identical");

	public override IcuCollationStrength Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberTertiary))
		{
			return IcuCollationStrength.Tertiary;
		}

		if (reader.ValueTextEquals(MemberSecondary))
		{
			return IcuCollationStrength.Secondary;
		}

		if (reader.ValueTextEquals(MemberQuaternary))
		{
			return IcuCollationStrength.Quaternary;
		}

		if (reader.ValueTextEquals(MemberPrimary))
		{
			return IcuCollationStrength.Primary;
		}

		if (reader.ValueTextEquals(MemberIdentical))
		{
			return IcuCollationStrength.Identical;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberTertiary.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return IcuCollationStrength.Tertiary;
		}

		if (string.Equals(value, MemberSecondary.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return IcuCollationStrength.Secondary;
		}

		if (string.Equals(value, MemberQuaternary.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return IcuCollationStrength.Quaternary;
		}

		if (string.Equals(value, MemberPrimary.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return IcuCollationStrength.Primary;
		}

		if (string.Equals(value, MemberIdentical.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return IcuCollationStrength.Identical;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(IcuCollationStrength)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, IcuCollationStrength value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case IcuCollationStrength.Tertiary:
				writer.WriteStringValue(MemberTertiary);
				break;
			case IcuCollationStrength.Secondary:
				writer.WriteStringValue(MemberSecondary);
				break;
			case IcuCollationStrength.Quaternary:
				writer.WriteStringValue(MemberQuaternary);
				break;
			case IcuCollationStrength.Primary:
				writer.WriteStringValue(MemberPrimary);
				break;
			case IcuCollationStrength.Identical:
				writer.WriteStringValue(MemberIdentical);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(IcuCollationStrength)}'.");
		}
	}
}

[JsonConverter(typeof(IcuNormalizationModeConverter))]
public enum IcuNormalizationMode
{
	[EnumMember(Value = "decompose")]
	Decompose,
	[EnumMember(Value = "compose")]
	Compose
}

internal sealed partial class IcuNormalizationModeConverter : System.Text.Json.Serialization.JsonConverter<IcuNormalizationMode>
{
	private static readonly System.Text.Json.JsonEncodedText MemberDecompose = System.Text.Json.JsonEncodedText.Encode("decompose");
	private static readonly System.Text.Json.JsonEncodedText MemberCompose = System.Text.Json.JsonEncodedText.Encode("compose");

	public override IcuNormalizationMode Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberDecompose))
		{
			return IcuNormalizationMode.Decompose;
		}

		if (reader.ValueTextEquals(MemberCompose))
		{
			return IcuNormalizationMode.Compose;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberDecompose.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return IcuNormalizationMode.Decompose;
		}

		if (string.Equals(value, MemberCompose.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return IcuNormalizationMode.Compose;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(IcuNormalizationMode)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, IcuNormalizationMode value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case IcuNormalizationMode.Decompose:
				writer.WriteStringValue(MemberDecompose);
				break;
			case IcuNormalizationMode.Compose:
				writer.WriteStringValue(MemberCompose);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(IcuNormalizationMode)}'.");
		}
	}
}

[JsonConverter(typeof(IcuNormalizationTypeConverter))]
public enum IcuNormalizationType
{
	[EnumMember(Value = "nfkc_cf")]
	NfkcCf,
	[EnumMember(Value = "nfkc")]
	Nfkc,
	[EnumMember(Value = "nfc")]
	Nfc
}

internal sealed partial class IcuNormalizationTypeConverter : System.Text.Json.Serialization.JsonConverter<IcuNormalizationType>
{
	private static readonly System.Text.Json.JsonEncodedText MemberNfkcCf = System.Text.Json.JsonEncodedText.Encode("nfkc_cf");
	private static readonly System.Text.Json.JsonEncodedText MemberNfkc = System.Text.Json.JsonEncodedText.Encode("nfkc");
	private static readonly System.Text.Json.JsonEncodedText MemberNfc = System.Text.Json.JsonEncodedText.Encode("nfc");

	public override IcuNormalizationType Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberNfkcCf))
		{
			return IcuNormalizationType.NfkcCf;
		}

		if (reader.ValueTextEquals(MemberNfkc))
		{
			return IcuNormalizationType.Nfkc;
		}

		if (reader.ValueTextEquals(MemberNfc))
		{
			return IcuNormalizationType.Nfc;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberNfkcCf.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return IcuNormalizationType.NfkcCf;
		}

		if (string.Equals(value, MemberNfkc.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return IcuNormalizationType.Nfkc;
		}

		if (string.Equals(value, MemberNfc.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return IcuNormalizationType.Nfc;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(IcuNormalizationType)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, IcuNormalizationType value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case IcuNormalizationType.NfkcCf:
				writer.WriteStringValue(MemberNfkcCf);
				break;
			case IcuNormalizationType.Nfkc:
				writer.WriteStringValue(MemberNfkc);
				break;
			case IcuNormalizationType.Nfc:
				writer.WriteStringValue(MemberNfc);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(IcuNormalizationType)}'.");
		}
	}
}

[JsonConverter(typeof(IcuTransformDirectionConverter))]
public enum IcuTransformDirection
{
	[EnumMember(Value = "reverse")]
	Reverse,
	[EnumMember(Value = "forward")]
	Forward
}

internal sealed partial class IcuTransformDirectionConverter : System.Text.Json.Serialization.JsonConverter<IcuTransformDirection>
{
	private static readonly System.Text.Json.JsonEncodedText MemberReverse = System.Text.Json.JsonEncodedText.Encode("reverse");
	private static readonly System.Text.Json.JsonEncodedText MemberForward = System.Text.Json.JsonEncodedText.Encode("forward");

	public override IcuTransformDirection Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberReverse))
		{
			return IcuTransformDirection.Reverse;
		}

		if (reader.ValueTextEquals(MemberForward))
		{
			return IcuTransformDirection.Forward;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberReverse.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return IcuTransformDirection.Reverse;
		}

		if (string.Equals(value, MemberForward.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return IcuTransformDirection.Forward;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(IcuTransformDirection)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, IcuTransformDirection value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case IcuTransformDirection.Reverse:
				writer.WriteStringValue(MemberReverse);
				break;
			case IcuTransformDirection.Forward:
				writer.WriteStringValue(MemberForward);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(IcuTransformDirection)}'.");
		}
	}
}

[JsonConverter(typeof(KeepTypesModeConverter))]
public enum KeepTypesMode
{
	[EnumMember(Value = "include")]
	Include,
	[EnumMember(Value = "exclude")]
	Exclude
}

internal sealed partial class KeepTypesModeConverter : System.Text.Json.Serialization.JsonConverter<KeepTypesMode>
{
	private static readonly System.Text.Json.JsonEncodedText MemberInclude = System.Text.Json.JsonEncodedText.Encode("include");
	private static readonly System.Text.Json.JsonEncodedText MemberExclude = System.Text.Json.JsonEncodedText.Encode("exclude");

	public override KeepTypesMode Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberInclude))
		{
			return KeepTypesMode.Include;
		}

		if (reader.ValueTextEquals(MemberExclude))
		{
			return KeepTypesMode.Exclude;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberInclude.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return KeepTypesMode.Include;
		}

		if (string.Equals(value, MemberExclude.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return KeepTypesMode.Exclude;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(KeepTypesMode)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, KeepTypesMode value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case KeepTypesMode.Include:
				writer.WriteStringValue(MemberInclude);
				break;
			case KeepTypesMode.Exclude:
				writer.WriteStringValue(MemberExclude);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(KeepTypesMode)}'.");
		}
	}
}

[JsonConverter(typeof(KuromojiTokenizationModeConverter))]
public enum KuromojiTokenizationMode
{
	[EnumMember(Value = "search")]
	Search,
	[EnumMember(Value = "normal")]
	Normal,
	[EnumMember(Value = "extended")]
	Extended
}

internal sealed partial class KuromojiTokenizationModeConverter : System.Text.Json.Serialization.JsonConverter<KuromojiTokenizationMode>
{
	private static readonly System.Text.Json.JsonEncodedText MemberSearch = System.Text.Json.JsonEncodedText.Encode("search");
	private static readonly System.Text.Json.JsonEncodedText MemberNormal = System.Text.Json.JsonEncodedText.Encode("normal");
	private static readonly System.Text.Json.JsonEncodedText MemberExtended = System.Text.Json.JsonEncodedText.Encode("extended");

	public override KuromojiTokenizationMode Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberSearch))
		{
			return KuromojiTokenizationMode.Search;
		}

		if (reader.ValueTextEquals(MemberNormal))
		{
			return KuromojiTokenizationMode.Normal;
		}

		if (reader.ValueTextEquals(MemberExtended))
		{
			return KuromojiTokenizationMode.Extended;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberSearch.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return KuromojiTokenizationMode.Search;
		}

		if (string.Equals(value, MemberNormal.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return KuromojiTokenizationMode.Normal;
		}

		if (string.Equals(value, MemberExtended.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return KuromojiTokenizationMode.Extended;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(KuromojiTokenizationMode)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, KuromojiTokenizationMode value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case KuromojiTokenizationMode.Search:
				writer.WriteStringValue(MemberSearch);
				break;
			case KuromojiTokenizationMode.Normal:
				writer.WriteStringValue(MemberNormal);
				break;
			case KuromojiTokenizationMode.Extended:
				writer.WriteStringValue(MemberExtended);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(KuromojiTokenizationMode)}'.");
		}
	}
}

[JsonConverter(typeof(LanguageConverter))]
public enum Language
{
	[EnumMember(Value = "Turkish")]
	Turkish,
	[EnumMember(Value = "Thai")]
	Thai,
	[EnumMember(Value = "Swedish")]
	Swedish,
	[EnumMember(Value = "Spanish")]
	Spanish,
	[EnumMember(Value = "Sorani")]
	Sorani,
	[EnumMember(Value = "Russian")]
	Russian,
	[EnumMember(Value = "Romanian")]
	Romanian,
	[EnumMember(Value = "Portuguese")]
	Portuguese,
	[EnumMember(Value = "Persian")]
	Persian,
	[EnumMember(Value = "Norwegian")]
	Norwegian,
	[EnumMember(Value = "Latvian")]
	Latvian,
	[EnumMember(Value = "Italian")]
	Italian,
	[EnumMember(Value = "Irish")]
	Irish,
	[EnumMember(Value = "Indonesian")]
	Indonesian,
	[EnumMember(Value = "Hungarian")]
	Hungarian,
	[EnumMember(Value = "Hindi")]
	Hindi,
	[EnumMember(Value = "Greek")]
	Greek,
	[EnumMember(Value = "German")]
	German,
	[EnumMember(Value = "Galician")]
	Galician,
	[EnumMember(Value = "French")]
	French,
	[EnumMember(Value = "Finnish")]
	Finnish,
	[EnumMember(Value = "Estonian")]
	Estonian,
	[EnumMember(Value = "English")]
	English,
	[EnumMember(Value = "Dutch")]
	Dutch,
	[EnumMember(Value = "Danish")]
	Danish,
	[EnumMember(Value = "Czech")]
	Czech,
	[EnumMember(Value = "Cjk")]
	Cjk,
	[EnumMember(Value = "Chinese")]
	Chinese,
	[EnumMember(Value = "Catalan")]
	Catalan,
	[EnumMember(Value = "Bulgarian")]
	Bulgarian,
	[EnumMember(Value = "Brazilian")]
	Brazilian,
	[EnumMember(Value = "Basque")]
	Basque,
	[EnumMember(Value = "Armenian")]
	Armenian,
	[EnumMember(Value = "Arabic")]
	Arabic
}

internal sealed partial class LanguageConverter : System.Text.Json.Serialization.JsonConverter<Language>
{
	private static readonly System.Text.Json.JsonEncodedText MemberTurkish = System.Text.Json.JsonEncodedText.Encode("Turkish");
	private static readonly System.Text.Json.JsonEncodedText MemberThai = System.Text.Json.JsonEncodedText.Encode("Thai");
	private static readonly System.Text.Json.JsonEncodedText MemberSwedish = System.Text.Json.JsonEncodedText.Encode("Swedish");
	private static readonly System.Text.Json.JsonEncodedText MemberSpanish = System.Text.Json.JsonEncodedText.Encode("Spanish");
	private static readonly System.Text.Json.JsonEncodedText MemberSorani = System.Text.Json.JsonEncodedText.Encode("Sorani");
	private static readonly System.Text.Json.JsonEncodedText MemberRussian = System.Text.Json.JsonEncodedText.Encode("Russian");
	private static readonly System.Text.Json.JsonEncodedText MemberRomanian = System.Text.Json.JsonEncodedText.Encode("Romanian");
	private static readonly System.Text.Json.JsonEncodedText MemberPortuguese = System.Text.Json.JsonEncodedText.Encode("Portuguese");
	private static readonly System.Text.Json.JsonEncodedText MemberPersian = System.Text.Json.JsonEncodedText.Encode("Persian");
	private static readonly System.Text.Json.JsonEncodedText MemberNorwegian = System.Text.Json.JsonEncodedText.Encode("Norwegian");
	private static readonly System.Text.Json.JsonEncodedText MemberLatvian = System.Text.Json.JsonEncodedText.Encode("Latvian");
	private static readonly System.Text.Json.JsonEncodedText MemberItalian = System.Text.Json.JsonEncodedText.Encode("Italian");
	private static readonly System.Text.Json.JsonEncodedText MemberIrish = System.Text.Json.JsonEncodedText.Encode("Irish");
	private static readonly System.Text.Json.JsonEncodedText MemberIndonesian = System.Text.Json.JsonEncodedText.Encode("Indonesian");
	private static readonly System.Text.Json.JsonEncodedText MemberHungarian = System.Text.Json.JsonEncodedText.Encode("Hungarian");
	private static readonly System.Text.Json.JsonEncodedText MemberHindi = System.Text.Json.JsonEncodedText.Encode("Hindi");
	private static readonly System.Text.Json.JsonEncodedText MemberGreek = System.Text.Json.JsonEncodedText.Encode("Greek");
	private static readonly System.Text.Json.JsonEncodedText MemberGerman = System.Text.Json.JsonEncodedText.Encode("German");
	private static readonly System.Text.Json.JsonEncodedText MemberGalician = System.Text.Json.JsonEncodedText.Encode("Galician");
	private static readonly System.Text.Json.JsonEncodedText MemberFrench = System.Text.Json.JsonEncodedText.Encode("French");
	private static readonly System.Text.Json.JsonEncodedText MemberFinnish = System.Text.Json.JsonEncodedText.Encode("Finnish");
	private static readonly System.Text.Json.JsonEncodedText MemberEstonian = System.Text.Json.JsonEncodedText.Encode("Estonian");
	private static readonly System.Text.Json.JsonEncodedText MemberEnglish = System.Text.Json.JsonEncodedText.Encode("English");
	private static readonly System.Text.Json.JsonEncodedText MemberDutch = System.Text.Json.JsonEncodedText.Encode("Dutch");
	private static readonly System.Text.Json.JsonEncodedText MemberDanish = System.Text.Json.JsonEncodedText.Encode("Danish");
	private static readonly System.Text.Json.JsonEncodedText MemberCzech = System.Text.Json.JsonEncodedText.Encode("Czech");
	private static readonly System.Text.Json.JsonEncodedText MemberCjk = System.Text.Json.JsonEncodedText.Encode("Cjk");
	private static readonly System.Text.Json.JsonEncodedText MemberChinese = System.Text.Json.JsonEncodedText.Encode("Chinese");
	private static readonly System.Text.Json.JsonEncodedText MemberCatalan = System.Text.Json.JsonEncodedText.Encode("Catalan");
	private static readonly System.Text.Json.JsonEncodedText MemberBulgarian = System.Text.Json.JsonEncodedText.Encode("Bulgarian");
	private static readonly System.Text.Json.JsonEncodedText MemberBrazilian = System.Text.Json.JsonEncodedText.Encode("Brazilian");
	private static readonly System.Text.Json.JsonEncodedText MemberBasque = System.Text.Json.JsonEncodedText.Encode("Basque");
	private static readonly System.Text.Json.JsonEncodedText MemberArmenian = System.Text.Json.JsonEncodedText.Encode("Armenian");
	private static readonly System.Text.Json.JsonEncodedText MemberArabic = System.Text.Json.JsonEncodedText.Encode("Arabic");

	public override Language Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberTurkish))
		{
			return Language.Turkish;
		}

		if (reader.ValueTextEquals(MemberThai))
		{
			return Language.Thai;
		}

		if (reader.ValueTextEquals(MemberSwedish))
		{
			return Language.Swedish;
		}

		if (reader.ValueTextEquals(MemberSpanish))
		{
			return Language.Spanish;
		}

		if (reader.ValueTextEquals(MemberSorani))
		{
			return Language.Sorani;
		}

		if (reader.ValueTextEquals(MemberRussian))
		{
			return Language.Russian;
		}

		if (reader.ValueTextEquals(MemberRomanian))
		{
			return Language.Romanian;
		}

		if (reader.ValueTextEquals(MemberPortuguese))
		{
			return Language.Portuguese;
		}

		if (reader.ValueTextEquals(MemberPersian))
		{
			return Language.Persian;
		}

		if (reader.ValueTextEquals(MemberNorwegian))
		{
			return Language.Norwegian;
		}

		if (reader.ValueTextEquals(MemberLatvian))
		{
			return Language.Latvian;
		}

		if (reader.ValueTextEquals(MemberItalian))
		{
			return Language.Italian;
		}

		if (reader.ValueTextEquals(MemberIrish))
		{
			return Language.Irish;
		}

		if (reader.ValueTextEquals(MemberIndonesian))
		{
			return Language.Indonesian;
		}

		if (reader.ValueTextEquals(MemberHungarian))
		{
			return Language.Hungarian;
		}

		if (reader.ValueTextEquals(MemberHindi))
		{
			return Language.Hindi;
		}

		if (reader.ValueTextEquals(MemberGreek))
		{
			return Language.Greek;
		}

		if (reader.ValueTextEquals(MemberGerman))
		{
			return Language.German;
		}

		if (reader.ValueTextEquals(MemberGalician))
		{
			return Language.Galician;
		}

		if (reader.ValueTextEquals(MemberFrench))
		{
			return Language.French;
		}

		if (reader.ValueTextEquals(MemberFinnish))
		{
			return Language.Finnish;
		}

		if (reader.ValueTextEquals(MemberEstonian))
		{
			return Language.Estonian;
		}

		if (reader.ValueTextEquals(MemberEnglish))
		{
			return Language.English;
		}

		if (reader.ValueTextEquals(MemberDutch))
		{
			return Language.Dutch;
		}

		if (reader.ValueTextEquals(MemberDanish))
		{
			return Language.Danish;
		}

		if (reader.ValueTextEquals(MemberCzech))
		{
			return Language.Czech;
		}

		if (reader.ValueTextEquals(MemberCjk))
		{
			return Language.Cjk;
		}

		if (reader.ValueTextEquals(MemberChinese))
		{
			return Language.Chinese;
		}

		if (reader.ValueTextEquals(MemberCatalan))
		{
			return Language.Catalan;
		}

		if (reader.ValueTextEquals(MemberBulgarian))
		{
			return Language.Bulgarian;
		}

		if (reader.ValueTextEquals(MemberBrazilian))
		{
			return Language.Brazilian;
		}

		if (reader.ValueTextEquals(MemberBasque))
		{
			return Language.Basque;
		}

		if (reader.ValueTextEquals(MemberArmenian))
		{
			return Language.Armenian;
		}

		if (reader.ValueTextEquals(MemberArabic))
		{
			return Language.Arabic;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberTurkish.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return Language.Turkish;
		}

		if (string.Equals(value, MemberThai.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return Language.Thai;
		}

		if (string.Equals(value, MemberSwedish.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return Language.Swedish;
		}

		if (string.Equals(value, MemberSpanish.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return Language.Spanish;
		}

		if (string.Equals(value, MemberSorani.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return Language.Sorani;
		}

		if (string.Equals(value, MemberRussian.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return Language.Russian;
		}

		if (string.Equals(value, MemberRomanian.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return Language.Romanian;
		}

		if (string.Equals(value, MemberPortuguese.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return Language.Portuguese;
		}

		if (string.Equals(value, MemberPersian.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return Language.Persian;
		}

		if (string.Equals(value, MemberNorwegian.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return Language.Norwegian;
		}

		if (string.Equals(value, MemberLatvian.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return Language.Latvian;
		}

		if (string.Equals(value, MemberItalian.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return Language.Italian;
		}

		if (string.Equals(value, MemberIrish.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return Language.Irish;
		}

		if (string.Equals(value, MemberIndonesian.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return Language.Indonesian;
		}

		if (string.Equals(value, MemberHungarian.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return Language.Hungarian;
		}

		if (string.Equals(value, MemberHindi.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return Language.Hindi;
		}

		if (string.Equals(value, MemberGreek.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return Language.Greek;
		}

		if (string.Equals(value, MemberGerman.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return Language.German;
		}

		if (string.Equals(value, MemberGalician.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return Language.Galician;
		}

		if (string.Equals(value, MemberFrench.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return Language.French;
		}

		if (string.Equals(value, MemberFinnish.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return Language.Finnish;
		}

		if (string.Equals(value, MemberEstonian.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return Language.Estonian;
		}

		if (string.Equals(value, MemberEnglish.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return Language.English;
		}

		if (string.Equals(value, MemberDutch.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return Language.Dutch;
		}

		if (string.Equals(value, MemberDanish.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return Language.Danish;
		}

		if (string.Equals(value, MemberCzech.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return Language.Czech;
		}

		if (string.Equals(value, MemberCjk.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return Language.Cjk;
		}

		if (string.Equals(value, MemberChinese.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return Language.Chinese;
		}

		if (string.Equals(value, MemberCatalan.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return Language.Catalan;
		}

		if (string.Equals(value, MemberBulgarian.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return Language.Bulgarian;
		}

		if (string.Equals(value, MemberBrazilian.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return Language.Brazilian;
		}

		if (string.Equals(value, MemberBasque.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return Language.Basque;
		}

		if (string.Equals(value, MemberArmenian.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return Language.Armenian;
		}

		if (string.Equals(value, MemberArabic.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return Language.Arabic;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(Language)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, Language value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case Language.Turkish:
				writer.WriteStringValue(MemberTurkish);
				break;
			case Language.Thai:
				writer.WriteStringValue(MemberThai);
				break;
			case Language.Swedish:
				writer.WriteStringValue(MemberSwedish);
				break;
			case Language.Spanish:
				writer.WriteStringValue(MemberSpanish);
				break;
			case Language.Sorani:
				writer.WriteStringValue(MemberSorani);
				break;
			case Language.Russian:
				writer.WriteStringValue(MemberRussian);
				break;
			case Language.Romanian:
				writer.WriteStringValue(MemberRomanian);
				break;
			case Language.Portuguese:
				writer.WriteStringValue(MemberPortuguese);
				break;
			case Language.Persian:
				writer.WriteStringValue(MemberPersian);
				break;
			case Language.Norwegian:
				writer.WriteStringValue(MemberNorwegian);
				break;
			case Language.Latvian:
				writer.WriteStringValue(MemberLatvian);
				break;
			case Language.Italian:
				writer.WriteStringValue(MemberItalian);
				break;
			case Language.Irish:
				writer.WriteStringValue(MemberIrish);
				break;
			case Language.Indonesian:
				writer.WriteStringValue(MemberIndonesian);
				break;
			case Language.Hungarian:
				writer.WriteStringValue(MemberHungarian);
				break;
			case Language.Hindi:
				writer.WriteStringValue(MemberHindi);
				break;
			case Language.Greek:
				writer.WriteStringValue(MemberGreek);
				break;
			case Language.German:
				writer.WriteStringValue(MemberGerman);
				break;
			case Language.Galician:
				writer.WriteStringValue(MemberGalician);
				break;
			case Language.French:
				writer.WriteStringValue(MemberFrench);
				break;
			case Language.Finnish:
				writer.WriteStringValue(MemberFinnish);
				break;
			case Language.Estonian:
				writer.WriteStringValue(MemberEstonian);
				break;
			case Language.English:
				writer.WriteStringValue(MemberEnglish);
				break;
			case Language.Dutch:
				writer.WriteStringValue(MemberDutch);
				break;
			case Language.Danish:
				writer.WriteStringValue(MemberDanish);
				break;
			case Language.Czech:
				writer.WriteStringValue(MemberCzech);
				break;
			case Language.Cjk:
				writer.WriteStringValue(MemberCjk);
				break;
			case Language.Chinese:
				writer.WriteStringValue(MemberChinese);
				break;
			case Language.Catalan:
				writer.WriteStringValue(MemberCatalan);
				break;
			case Language.Bulgarian:
				writer.WriteStringValue(MemberBulgarian);
				break;
			case Language.Brazilian:
				writer.WriteStringValue(MemberBrazilian);
				break;
			case Language.Basque:
				writer.WriteStringValue(MemberBasque);
				break;
			case Language.Armenian:
				writer.WriteStringValue(MemberArmenian);
				break;
			case Language.Arabic:
				writer.WriteStringValue(MemberArabic);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(Language)}'.");
		}
	}
}

[JsonConverter(typeof(NoriDecompoundModeConverter))]
public enum NoriDecompoundMode
{
	[EnumMember(Value = "none")]
	None,
	[EnumMember(Value = "mixed")]
	Mixed,
	[EnumMember(Value = "discard")]
	Discard
}

internal sealed partial class NoriDecompoundModeConverter : System.Text.Json.Serialization.JsonConverter<NoriDecompoundMode>
{
	private static readonly System.Text.Json.JsonEncodedText MemberNone = System.Text.Json.JsonEncodedText.Encode("none");
	private static readonly System.Text.Json.JsonEncodedText MemberMixed = System.Text.Json.JsonEncodedText.Encode("mixed");
	private static readonly System.Text.Json.JsonEncodedText MemberDiscard = System.Text.Json.JsonEncodedText.Encode("discard");

	public override NoriDecompoundMode Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberNone))
		{
			return NoriDecompoundMode.None;
		}

		if (reader.ValueTextEquals(MemberMixed))
		{
			return NoriDecompoundMode.Mixed;
		}

		if (reader.ValueTextEquals(MemberDiscard))
		{
			return NoriDecompoundMode.Discard;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberNone.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return NoriDecompoundMode.None;
		}

		if (string.Equals(value, MemberMixed.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return NoriDecompoundMode.Mixed;
		}

		if (string.Equals(value, MemberDiscard.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return NoriDecompoundMode.Discard;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(NoriDecompoundMode)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, NoriDecompoundMode value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case NoriDecompoundMode.None:
				writer.WriteStringValue(MemberNone);
				break;
			case NoriDecompoundMode.Mixed:
				writer.WriteStringValue(MemberMixed);
				break;
			case NoriDecompoundMode.Discard:
				writer.WriteStringValue(MemberDiscard);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(NoriDecompoundMode)}'.");
		}
	}
}

[JsonConverter(typeof(PhoneticEncoderConverter))]
public enum PhoneticEncoder
{
	[EnumMember(Value = "soundex")]
	Soundex,
	[EnumMember(Value = "refined_soundex")]
	RefinedSoundex,
	[EnumMember(Value = "nysiis")]
	Nysiis,
	[EnumMember(Value = "metaphone")]
	Metaphone,
	[EnumMember(Value = "koelnerphonetik")]
	Koelnerphonetik,
	[EnumMember(Value = "haasephonetik")]
	Haasephonetik,
	[EnumMember(Value = "double_metaphone")]
	DoubleMetaphone,
	[EnumMember(Value = "daitch_mokotoff")]
	DaitchMokotoff,
	[EnumMember(Value = "cologne")]
	Cologne,
	[EnumMember(Value = "caverphone2")]
	Caverphone2,
	[EnumMember(Value = "caverphone1")]
	Caverphone1,
	[EnumMember(Value = "beider_morse")]
	BeiderMorse
}

internal sealed partial class PhoneticEncoderConverter : System.Text.Json.Serialization.JsonConverter<PhoneticEncoder>
{
	private static readonly System.Text.Json.JsonEncodedText MemberSoundex = System.Text.Json.JsonEncodedText.Encode("soundex");
	private static readonly System.Text.Json.JsonEncodedText MemberRefinedSoundex = System.Text.Json.JsonEncodedText.Encode("refined_soundex");
	private static readonly System.Text.Json.JsonEncodedText MemberNysiis = System.Text.Json.JsonEncodedText.Encode("nysiis");
	private static readonly System.Text.Json.JsonEncodedText MemberMetaphone = System.Text.Json.JsonEncodedText.Encode("metaphone");
	private static readonly System.Text.Json.JsonEncodedText MemberKoelnerphonetik = System.Text.Json.JsonEncodedText.Encode("koelnerphonetik");
	private static readonly System.Text.Json.JsonEncodedText MemberHaasephonetik = System.Text.Json.JsonEncodedText.Encode("haasephonetik");
	private static readonly System.Text.Json.JsonEncodedText MemberDoubleMetaphone = System.Text.Json.JsonEncodedText.Encode("double_metaphone");
	private static readonly System.Text.Json.JsonEncodedText MemberDaitchMokotoff = System.Text.Json.JsonEncodedText.Encode("daitch_mokotoff");
	private static readonly System.Text.Json.JsonEncodedText MemberCologne = System.Text.Json.JsonEncodedText.Encode("cologne");
	private static readonly System.Text.Json.JsonEncodedText MemberCaverphone2 = System.Text.Json.JsonEncodedText.Encode("caverphone2");
	private static readonly System.Text.Json.JsonEncodedText MemberCaverphone1 = System.Text.Json.JsonEncodedText.Encode("caverphone1");
	private static readonly System.Text.Json.JsonEncodedText MemberBeiderMorse = System.Text.Json.JsonEncodedText.Encode("beider_morse");

	public override PhoneticEncoder Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberSoundex))
		{
			return PhoneticEncoder.Soundex;
		}

		if (reader.ValueTextEquals(MemberRefinedSoundex))
		{
			return PhoneticEncoder.RefinedSoundex;
		}

		if (reader.ValueTextEquals(MemberNysiis))
		{
			return PhoneticEncoder.Nysiis;
		}

		if (reader.ValueTextEquals(MemberMetaphone))
		{
			return PhoneticEncoder.Metaphone;
		}

		if (reader.ValueTextEquals(MemberKoelnerphonetik))
		{
			return PhoneticEncoder.Koelnerphonetik;
		}

		if (reader.ValueTextEquals(MemberHaasephonetik))
		{
			return PhoneticEncoder.Haasephonetik;
		}

		if (reader.ValueTextEquals(MemberDoubleMetaphone))
		{
			return PhoneticEncoder.DoubleMetaphone;
		}

		if (reader.ValueTextEquals(MemberDaitchMokotoff))
		{
			return PhoneticEncoder.DaitchMokotoff;
		}

		if (reader.ValueTextEquals(MemberCologne))
		{
			return PhoneticEncoder.Cologne;
		}

		if (reader.ValueTextEquals(MemberCaverphone2))
		{
			return PhoneticEncoder.Caverphone2;
		}

		if (reader.ValueTextEquals(MemberCaverphone1))
		{
			return PhoneticEncoder.Caverphone1;
		}

		if (reader.ValueTextEquals(MemberBeiderMorse))
		{
			return PhoneticEncoder.BeiderMorse;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberSoundex.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return PhoneticEncoder.Soundex;
		}

		if (string.Equals(value, MemberRefinedSoundex.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return PhoneticEncoder.RefinedSoundex;
		}

		if (string.Equals(value, MemberNysiis.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return PhoneticEncoder.Nysiis;
		}

		if (string.Equals(value, MemberMetaphone.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return PhoneticEncoder.Metaphone;
		}

		if (string.Equals(value, MemberKoelnerphonetik.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return PhoneticEncoder.Koelnerphonetik;
		}

		if (string.Equals(value, MemberHaasephonetik.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return PhoneticEncoder.Haasephonetik;
		}

		if (string.Equals(value, MemberDoubleMetaphone.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return PhoneticEncoder.DoubleMetaphone;
		}

		if (string.Equals(value, MemberDaitchMokotoff.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return PhoneticEncoder.DaitchMokotoff;
		}

		if (string.Equals(value, MemberCologne.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return PhoneticEncoder.Cologne;
		}

		if (string.Equals(value, MemberCaverphone2.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return PhoneticEncoder.Caverphone2;
		}

		if (string.Equals(value, MemberCaverphone1.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return PhoneticEncoder.Caverphone1;
		}

		if (string.Equals(value, MemberBeiderMorse.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return PhoneticEncoder.BeiderMorse;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(PhoneticEncoder)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, PhoneticEncoder value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case PhoneticEncoder.Soundex:
				writer.WriteStringValue(MemberSoundex);
				break;
			case PhoneticEncoder.RefinedSoundex:
				writer.WriteStringValue(MemberRefinedSoundex);
				break;
			case PhoneticEncoder.Nysiis:
				writer.WriteStringValue(MemberNysiis);
				break;
			case PhoneticEncoder.Metaphone:
				writer.WriteStringValue(MemberMetaphone);
				break;
			case PhoneticEncoder.Koelnerphonetik:
				writer.WriteStringValue(MemberKoelnerphonetik);
				break;
			case PhoneticEncoder.Haasephonetik:
				writer.WriteStringValue(MemberHaasephonetik);
				break;
			case PhoneticEncoder.DoubleMetaphone:
				writer.WriteStringValue(MemberDoubleMetaphone);
				break;
			case PhoneticEncoder.DaitchMokotoff:
				writer.WriteStringValue(MemberDaitchMokotoff);
				break;
			case PhoneticEncoder.Cologne:
				writer.WriteStringValue(MemberCologne);
				break;
			case PhoneticEncoder.Caverphone2:
				writer.WriteStringValue(MemberCaverphone2);
				break;
			case PhoneticEncoder.Caverphone1:
				writer.WriteStringValue(MemberCaverphone1);
				break;
			case PhoneticEncoder.BeiderMorse:
				writer.WriteStringValue(MemberBeiderMorse);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(PhoneticEncoder)}'.");
		}
	}
}

[JsonConverter(typeof(PhoneticLanguageConverter))]
public enum PhoneticLanguage
{
	[EnumMember(Value = "spanish")]
	Spanish,
	[EnumMember(Value = "russian")]
	Russian,
	[EnumMember(Value = "romanian")]
	Romanian,
	[EnumMember(Value = "polish")]
	Polish,
	[EnumMember(Value = "hungarian")]
	Hungarian,
	[EnumMember(Value = "hebrew")]
	Hebrew,
	[EnumMember(Value = "german")]
	German,
	[EnumMember(Value = "french")]
	French,
	[EnumMember(Value = "english")]
	English,
	[EnumMember(Value = "cyrillic")]
	Cyrillic,
	[EnumMember(Value = "common")]
	Common,
	[EnumMember(Value = "any")]
	Any
}

internal sealed partial class PhoneticLanguageConverter : System.Text.Json.Serialization.JsonConverter<PhoneticLanguage>
{
	private static readonly System.Text.Json.JsonEncodedText MemberSpanish = System.Text.Json.JsonEncodedText.Encode("spanish");
	private static readonly System.Text.Json.JsonEncodedText MemberRussian = System.Text.Json.JsonEncodedText.Encode("russian");
	private static readonly System.Text.Json.JsonEncodedText MemberRomanian = System.Text.Json.JsonEncodedText.Encode("romanian");
	private static readonly System.Text.Json.JsonEncodedText MemberPolish = System.Text.Json.JsonEncodedText.Encode("polish");
	private static readonly System.Text.Json.JsonEncodedText MemberHungarian = System.Text.Json.JsonEncodedText.Encode("hungarian");
	private static readonly System.Text.Json.JsonEncodedText MemberHebrew = System.Text.Json.JsonEncodedText.Encode("hebrew");
	private static readonly System.Text.Json.JsonEncodedText MemberGerman = System.Text.Json.JsonEncodedText.Encode("german");
	private static readonly System.Text.Json.JsonEncodedText MemberFrench = System.Text.Json.JsonEncodedText.Encode("french");
	private static readonly System.Text.Json.JsonEncodedText MemberEnglish = System.Text.Json.JsonEncodedText.Encode("english");
	private static readonly System.Text.Json.JsonEncodedText MemberCyrillic = System.Text.Json.JsonEncodedText.Encode("cyrillic");
	private static readonly System.Text.Json.JsonEncodedText MemberCommon = System.Text.Json.JsonEncodedText.Encode("common");
	private static readonly System.Text.Json.JsonEncodedText MemberAny = System.Text.Json.JsonEncodedText.Encode("any");

	public override PhoneticLanguage Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberSpanish))
		{
			return PhoneticLanguage.Spanish;
		}

		if (reader.ValueTextEquals(MemberRussian))
		{
			return PhoneticLanguage.Russian;
		}

		if (reader.ValueTextEquals(MemberRomanian))
		{
			return PhoneticLanguage.Romanian;
		}

		if (reader.ValueTextEquals(MemberPolish))
		{
			return PhoneticLanguage.Polish;
		}

		if (reader.ValueTextEquals(MemberHungarian))
		{
			return PhoneticLanguage.Hungarian;
		}

		if (reader.ValueTextEquals(MemberHebrew))
		{
			return PhoneticLanguage.Hebrew;
		}

		if (reader.ValueTextEquals(MemberGerman))
		{
			return PhoneticLanguage.German;
		}

		if (reader.ValueTextEquals(MemberFrench))
		{
			return PhoneticLanguage.French;
		}

		if (reader.ValueTextEquals(MemberEnglish))
		{
			return PhoneticLanguage.English;
		}

		if (reader.ValueTextEquals(MemberCyrillic))
		{
			return PhoneticLanguage.Cyrillic;
		}

		if (reader.ValueTextEquals(MemberCommon))
		{
			return PhoneticLanguage.Common;
		}

		if (reader.ValueTextEquals(MemberAny))
		{
			return PhoneticLanguage.Any;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberSpanish.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return PhoneticLanguage.Spanish;
		}

		if (string.Equals(value, MemberRussian.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return PhoneticLanguage.Russian;
		}

		if (string.Equals(value, MemberRomanian.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return PhoneticLanguage.Romanian;
		}

		if (string.Equals(value, MemberPolish.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return PhoneticLanguage.Polish;
		}

		if (string.Equals(value, MemberHungarian.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return PhoneticLanguage.Hungarian;
		}

		if (string.Equals(value, MemberHebrew.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return PhoneticLanguage.Hebrew;
		}

		if (string.Equals(value, MemberGerman.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return PhoneticLanguage.German;
		}

		if (string.Equals(value, MemberFrench.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return PhoneticLanguage.French;
		}

		if (string.Equals(value, MemberEnglish.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return PhoneticLanguage.English;
		}

		if (string.Equals(value, MemberCyrillic.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return PhoneticLanguage.Cyrillic;
		}

		if (string.Equals(value, MemberCommon.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return PhoneticLanguage.Common;
		}

		if (string.Equals(value, MemberAny.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return PhoneticLanguage.Any;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(PhoneticLanguage)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, PhoneticLanguage value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case PhoneticLanguage.Spanish:
				writer.WriteStringValue(MemberSpanish);
				break;
			case PhoneticLanguage.Russian:
				writer.WriteStringValue(MemberRussian);
				break;
			case PhoneticLanguage.Romanian:
				writer.WriteStringValue(MemberRomanian);
				break;
			case PhoneticLanguage.Polish:
				writer.WriteStringValue(MemberPolish);
				break;
			case PhoneticLanguage.Hungarian:
				writer.WriteStringValue(MemberHungarian);
				break;
			case PhoneticLanguage.Hebrew:
				writer.WriteStringValue(MemberHebrew);
				break;
			case PhoneticLanguage.German:
				writer.WriteStringValue(MemberGerman);
				break;
			case PhoneticLanguage.French:
				writer.WriteStringValue(MemberFrench);
				break;
			case PhoneticLanguage.English:
				writer.WriteStringValue(MemberEnglish);
				break;
			case PhoneticLanguage.Cyrillic:
				writer.WriteStringValue(MemberCyrillic);
				break;
			case PhoneticLanguage.Common:
				writer.WriteStringValue(MemberCommon);
				break;
			case PhoneticLanguage.Any:
				writer.WriteStringValue(MemberAny);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(PhoneticLanguage)}'.");
		}
	}
}

[JsonConverter(typeof(PhoneticNameTypeConverter))]
public enum PhoneticNameType
{
	[EnumMember(Value = "sephardic")]
	Sephardic,
	[EnumMember(Value = "generic")]
	Generic,
	[EnumMember(Value = "ashkenazi")]
	Ashkenazi
}

internal sealed partial class PhoneticNameTypeConverter : System.Text.Json.Serialization.JsonConverter<PhoneticNameType>
{
	private static readonly System.Text.Json.JsonEncodedText MemberSephardic = System.Text.Json.JsonEncodedText.Encode("sephardic");
	private static readonly System.Text.Json.JsonEncodedText MemberGeneric = System.Text.Json.JsonEncodedText.Encode("generic");
	private static readonly System.Text.Json.JsonEncodedText MemberAshkenazi = System.Text.Json.JsonEncodedText.Encode("ashkenazi");

	public override PhoneticNameType Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberSephardic))
		{
			return PhoneticNameType.Sephardic;
		}

		if (reader.ValueTextEquals(MemberGeneric))
		{
			return PhoneticNameType.Generic;
		}

		if (reader.ValueTextEquals(MemberAshkenazi))
		{
			return PhoneticNameType.Ashkenazi;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberSephardic.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return PhoneticNameType.Sephardic;
		}

		if (string.Equals(value, MemberGeneric.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return PhoneticNameType.Generic;
		}

		if (string.Equals(value, MemberAshkenazi.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return PhoneticNameType.Ashkenazi;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(PhoneticNameType)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, PhoneticNameType value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case PhoneticNameType.Sephardic:
				writer.WriteStringValue(MemberSephardic);
				break;
			case PhoneticNameType.Generic:
				writer.WriteStringValue(MemberGeneric);
				break;
			case PhoneticNameType.Ashkenazi:
				writer.WriteStringValue(MemberAshkenazi);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(PhoneticNameType)}'.");
		}
	}
}

[JsonConverter(typeof(PhoneticRuleTypeConverter))]
public enum PhoneticRuleType
{
	[EnumMember(Value = "exact")]
	Exact,
	[EnumMember(Value = "approx")]
	Approx
}

internal sealed partial class PhoneticRuleTypeConverter : System.Text.Json.Serialization.JsonConverter<PhoneticRuleType>
{
	private static readonly System.Text.Json.JsonEncodedText MemberExact = System.Text.Json.JsonEncodedText.Encode("exact");
	private static readonly System.Text.Json.JsonEncodedText MemberApprox = System.Text.Json.JsonEncodedText.Encode("approx");

	public override PhoneticRuleType Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberExact))
		{
			return PhoneticRuleType.Exact;
		}

		if (reader.ValueTextEquals(MemberApprox))
		{
			return PhoneticRuleType.Approx;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberExact.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return PhoneticRuleType.Exact;
		}

		if (string.Equals(value, MemberApprox.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return PhoneticRuleType.Approx;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(PhoneticRuleType)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, PhoneticRuleType value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case PhoneticRuleType.Exact:
				writer.WriteStringValue(MemberExact);
				break;
			case PhoneticRuleType.Approx:
				writer.WriteStringValue(MemberApprox);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(PhoneticRuleType)}'.");
		}
	}
}

[JsonConverter(typeof(SnowballLanguageConverter))]
public enum SnowballLanguage
{
	[EnumMember(Value = "Turkish")]
	Turkish,
	[EnumMember(Value = "Swedish")]
	Swedish,
	[EnumMember(Value = "Spanish")]
	Spanish,
	[EnumMember(Value = "Russian")]
	Russian,
	[EnumMember(Value = "Romanian")]
	Romanian,
	[EnumMember(Value = "Portuguese")]
	Portuguese,
	[EnumMember(Value = "Porter")]
	Porter,
	[EnumMember(Value = "Norwegian")]
	Norwegian,
	[EnumMember(Value = "Lovins")]
	Lovins,
	[EnumMember(Value = "Kp")]
	Kp,
	[EnumMember(Value = "Italian")]
	Italian,
	[EnumMember(Value = "Hungarian")]
	Hungarian,
	[EnumMember(Value = "German2")]
	German2,
	[EnumMember(Value = "German")]
	German,
	[EnumMember(Value = "French")]
	French,
	[EnumMember(Value = "Finnish")]
	Finnish,
	[EnumMember(Value = "English")]
	English,
	[EnumMember(Value = "Dutch")]
	Dutch,
	[EnumMember(Value = "Danish")]
	Danish,
	[EnumMember(Value = "Catalan")]
	Catalan,
	[EnumMember(Value = "Basque")]
	Basque,
	[EnumMember(Value = "Armenian")]
	Armenian
}

internal sealed partial class SnowballLanguageConverter : System.Text.Json.Serialization.JsonConverter<SnowballLanguage>
{
	private static readonly System.Text.Json.JsonEncodedText MemberTurkish = System.Text.Json.JsonEncodedText.Encode("Turkish");
	private static readonly System.Text.Json.JsonEncodedText MemberSwedish = System.Text.Json.JsonEncodedText.Encode("Swedish");
	private static readonly System.Text.Json.JsonEncodedText MemberSpanish = System.Text.Json.JsonEncodedText.Encode("Spanish");
	private static readonly System.Text.Json.JsonEncodedText MemberRussian = System.Text.Json.JsonEncodedText.Encode("Russian");
	private static readonly System.Text.Json.JsonEncodedText MemberRomanian = System.Text.Json.JsonEncodedText.Encode("Romanian");
	private static readonly System.Text.Json.JsonEncodedText MemberPortuguese = System.Text.Json.JsonEncodedText.Encode("Portuguese");
	private static readonly System.Text.Json.JsonEncodedText MemberPorter = System.Text.Json.JsonEncodedText.Encode("Porter");
	private static readonly System.Text.Json.JsonEncodedText MemberNorwegian = System.Text.Json.JsonEncodedText.Encode("Norwegian");
	private static readonly System.Text.Json.JsonEncodedText MemberLovins = System.Text.Json.JsonEncodedText.Encode("Lovins");
	private static readonly System.Text.Json.JsonEncodedText MemberKp = System.Text.Json.JsonEncodedText.Encode("Kp");
	private static readonly System.Text.Json.JsonEncodedText MemberItalian = System.Text.Json.JsonEncodedText.Encode("Italian");
	private static readonly System.Text.Json.JsonEncodedText MemberHungarian = System.Text.Json.JsonEncodedText.Encode("Hungarian");
	private static readonly System.Text.Json.JsonEncodedText MemberGerman2 = System.Text.Json.JsonEncodedText.Encode("German2");
	private static readonly System.Text.Json.JsonEncodedText MemberGerman = System.Text.Json.JsonEncodedText.Encode("German");
	private static readonly System.Text.Json.JsonEncodedText MemberFrench = System.Text.Json.JsonEncodedText.Encode("French");
	private static readonly System.Text.Json.JsonEncodedText MemberFinnish = System.Text.Json.JsonEncodedText.Encode("Finnish");
	private static readonly System.Text.Json.JsonEncodedText MemberEnglish = System.Text.Json.JsonEncodedText.Encode("English");
	private static readonly System.Text.Json.JsonEncodedText MemberDutch = System.Text.Json.JsonEncodedText.Encode("Dutch");
	private static readonly System.Text.Json.JsonEncodedText MemberDanish = System.Text.Json.JsonEncodedText.Encode("Danish");
	private static readonly System.Text.Json.JsonEncodedText MemberCatalan = System.Text.Json.JsonEncodedText.Encode("Catalan");
	private static readonly System.Text.Json.JsonEncodedText MemberBasque = System.Text.Json.JsonEncodedText.Encode("Basque");
	private static readonly System.Text.Json.JsonEncodedText MemberArmenian = System.Text.Json.JsonEncodedText.Encode("Armenian");

	public override SnowballLanguage Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberTurkish))
		{
			return SnowballLanguage.Turkish;
		}

		if (reader.ValueTextEquals(MemberSwedish))
		{
			return SnowballLanguage.Swedish;
		}

		if (reader.ValueTextEquals(MemberSpanish))
		{
			return SnowballLanguage.Spanish;
		}

		if (reader.ValueTextEquals(MemberRussian))
		{
			return SnowballLanguage.Russian;
		}

		if (reader.ValueTextEquals(MemberRomanian))
		{
			return SnowballLanguage.Romanian;
		}

		if (reader.ValueTextEquals(MemberPortuguese))
		{
			return SnowballLanguage.Portuguese;
		}

		if (reader.ValueTextEquals(MemberPorter))
		{
			return SnowballLanguage.Porter;
		}

		if (reader.ValueTextEquals(MemberNorwegian))
		{
			return SnowballLanguage.Norwegian;
		}

		if (reader.ValueTextEquals(MemberLovins))
		{
			return SnowballLanguage.Lovins;
		}

		if (reader.ValueTextEquals(MemberKp))
		{
			return SnowballLanguage.Kp;
		}

		if (reader.ValueTextEquals(MemberItalian))
		{
			return SnowballLanguage.Italian;
		}

		if (reader.ValueTextEquals(MemberHungarian))
		{
			return SnowballLanguage.Hungarian;
		}

		if (reader.ValueTextEquals(MemberGerman2))
		{
			return SnowballLanguage.German2;
		}

		if (reader.ValueTextEquals(MemberGerman))
		{
			return SnowballLanguage.German;
		}

		if (reader.ValueTextEquals(MemberFrench))
		{
			return SnowballLanguage.French;
		}

		if (reader.ValueTextEquals(MemberFinnish))
		{
			return SnowballLanguage.Finnish;
		}

		if (reader.ValueTextEquals(MemberEnglish))
		{
			return SnowballLanguage.English;
		}

		if (reader.ValueTextEquals(MemberDutch))
		{
			return SnowballLanguage.Dutch;
		}

		if (reader.ValueTextEquals(MemberDanish))
		{
			return SnowballLanguage.Danish;
		}

		if (reader.ValueTextEquals(MemberCatalan))
		{
			return SnowballLanguage.Catalan;
		}

		if (reader.ValueTextEquals(MemberBasque))
		{
			return SnowballLanguage.Basque;
		}

		if (reader.ValueTextEquals(MemberArmenian))
		{
			return SnowballLanguage.Armenian;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberTurkish.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return SnowballLanguage.Turkish;
		}

		if (string.Equals(value, MemberSwedish.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return SnowballLanguage.Swedish;
		}

		if (string.Equals(value, MemberSpanish.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return SnowballLanguage.Spanish;
		}

		if (string.Equals(value, MemberRussian.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return SnowballLanguage.Russian;
		}

		if (string.Equals(value, MemberRomanian.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return SnowballLanguage.Romanian;
		}

		if (string.Equals(value, MemberPortuguese.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return SnowballLanguage.Portuguese;
		}

		if (string.Equals(value, MemberPorter.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return SnowballLanguage.Porter;
		}

		if (string.Equals(value, MemberNorwegian.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return SnowballLanguage.Norwegian;
		}

		if (string.Equals(value, MemberLovins.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return SnowballLanguage.Lovins;
		}

		if (string.Equals(value, MemberKp.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return SnowballLanguage.Kp;
		}

		if (string.Equals(value, MemberItalian.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return SnowballLanguage.Italian;
		}

		if (string.Equals(value, MemberHungarian.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return SnowballLanguage.Hungarian;
		}

		if (string.Equals(value, MemberGerman2.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return SnowballLanguage.German2;
		}

		if (string.Equals(value, MemberGerman.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return SnowballLanguage.German;
		}

		if (string.Equals(value, MemberFrench.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return SnowballLanguage.French;
		}

		if (string.Equals(value, MemberFinnish.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return SnowballLanguage.Finnish;
		}

		if (string.Equals(value, MemberEnglish.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return SnowballLanguage.English;
		}

		if (string.Equals(value, MemberDutch.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return SnowballLanguage.Dutch;
		}

		if (string.Equals(value, MemberDanish.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return SnowballLanguage.Danish;
		}

		if (string.Equals(value, MemberCatalan.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return SnowballLanguage.Catalan;
		}

		if (string.Equals(value, MemberBasque.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return SnowballLanguage.Basque;
		}

		if (string.Equals(value, MemberArmenian.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return SnowballLanguage.Armenian;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(SnowballLanguage)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, SnowballLanguage value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case SnowballLanguage.Turkish:
				writer.WriteStringValue(MemberTurkish);
				break;
			case SnowballLanguage.Swedish:
				writer.WriteStringValue(MemberSwedish);
				break;
			case SnowballLanguage.Spanish:
				writer.WriteStringValue(MemberSpanish);
				break;
			case SnowballLanguage.Russian:
				writer.WriteStringValue(MemberRussian);
				break;
			case SnowballLanguage.Romanian:
				writer.WriteStringValue(MemberRomanian);
				break;
			case SnowballLanguage.Portuguese:
				writer.WriteStringValue(MemberPortuguese);
				break;
			case SnowballLanguage.Porter:
				writer.WriteStringValue(MemberPorter);
				break;
			case SnowballLanguage.Norwegian:
				writer.WriteStringValue(MemberNorwegian);
				break;
			case SnowballLanguage.Lovins:
				writer.WriteStringValue(MemberLovins);
				break;
			case SnowballLanguage.Kp:
				writer.WriteStringValue(MemberKp);
				break;
			case SnowballLanguage.Italian:
				writer.WriteStringValue(MemberItalian);
				break;
			case SnowballLanguage.Hungarian:
				writer.WriteStringValue(MemberHungarian);
				break;
			case SnowballLanguage.German2:
				writer.WriteStringValue(MemberGerman2);
				break;
			case SnowballLanguage.German:
				writer.WriteStringValue(MemberGerman);
				break;
			case SnowballLanguage.French:
				writer.WriteStringValue(MemberFrench);
				break;
			case SnowballLanguage.Finnish:
				writer.WriteStringValue(MemberFinnish);
				break;
			case SnowballLanguage.English:
				writer.WriteStringValue(MemberEnglish);
				break;
			case SnowballLanguage.Dutch:
				writer.WriteStringValue(MemberDutch);
				break;
			case SnowballLanguage.Danish:
				writer.WriteStringValue(MemberDanish);
				break;
			case SnowballLanguage.Catalan:
				writer.WriteStringValue(MemberCatalan);
				break;
			case SnowballLanguage.Basque:
				writer.WriteStringValue(MemberBasque);
				break;
			case SnowballLanguage.Armenian:
				writer.WriteStringValue(MemberArmenian);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(SnowballLanguage)}'.");
		}
	}
}

[JsonConverter(typeof(SynonymFormatConverter))]
public enum SynonymFormat
{
	[EnumMember(Value = "wordnet")]
	Wordnet,
	[EnumMember(Value = "solr")]
	Solr
}

internal sealed partial class SynonymFormatConverter : System.Text.Json.Serialization.JsonConverter<SynonymFormat>
{
	private static readonly System.Text.Json.JsonEncodedText MemberWordnet = System.Text.Json.JsonEncodedText.Encode("wordnet");
	private static readonly System.Text.Json.JsonEncodedText MemberSolr = System.Text.Json.JsonEncodedText.Encode("solr");

	public override SynonymFormat Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberWordnet))
		{
			return SynonymFormat.Wordnet;
		}

		if (reader.ValueTextEquals(MemberSolr))
		{
			return SynonymFormat.Solr;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberWordnet.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return SynonymFormat.Wordnet;
		}

		if (string.Equals(value, MemberSolr.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return SynonymFormat.Solr;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(SynonymFormat)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, SynonymFormat value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case SynonymFormat.Wordnet:
				writer.WriteStringValue(MemberWordnet);
				break;
			case SynonymFormat.Solr:
				writer.WriteStringValue(MemberSolr);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(SynonymFormat)}'.");
		}
	}
}

[JsonConverter(typeof(TokenCharConverter))]
public enum TokenChar
{
	[EnumMember(Value = "whitespace")]
	Whitespace,
	[EnumMember(Value = "symbol")]
	Symbol,
	[EnumMember(Value = "punctuation")]
	Punctuation,
	[EnumMember(Value = "letter")]
	Letter,
	[EnumMember(Value = "digit")]
	Digit,
	[EnumMember(Value = "custom")]
	Custom
}

internal sealed partial class TokenCharConverter : System.Text.Json.Serialization.JsonConverter<TokenChar>
{
	private static readonly System.Text.Json.JsonEncodedText MemberWhitespace = System.Text.Json.JsonEncodedText.Encode("whitespace");
	private static readonly System.Text.Json.JsonEncodedText MemberSymbol = System.Text.Json.JsonEncodedText.Encode("symbol");
	private static readonly System.Text.Json.JsonEncodedText MemberPunctuation = System.Text.Json.JsonEncodedText.Encode("punctuation");
	private static readonly System.Text.Json.JsonEncodedText MemberLetter = System.Text.Json.JsonEncodedText.Encode("letter");
	private static readonly System.Text.Json.JsonEncodedText MemberDigit = System.Text.Json.JsonEncodedText.Encode("digit");
	private static readonly System.Text.Json.JsonEncodedText MemberCustom = System.Text.Json.JsonEncodedText.Encode("custom");

	public override TokenChar Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberWhitespace))
		{
			return TokenChar.Whitespace;
		}

		if (reader.ValueTextEquals(MemberSymbol))
		{
			return TokenChar.Symbol;
		}

		if (reader.ValueTextEquals(MemberPunctuation))
		{
			return TokenChar.Punctuation;
		}

		if (reader.ValueTextEquals(MemberLetter))
		{
			return TokenChar.Letter;
		}

		if (reader.ValueTextEquals(MemberDigit))
		{
			return TokenChar.Digit;
		}

		if (reader.ValueTextEquals(MemberCustom))
		{
			return TokenChar.Custom;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberWhitespace.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return TokenChar.Whitespace;
		}

		if (string.Equals(value, MemberSymbol.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return TokenChar.Symbol;
		}

		if (string.Equals(value, MemberPunctuation.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return TokenChar.Punctuation;
		}

		if (string.Equals(value, MemberLetter.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return TokenChar.Letter;
		}

		if (string.Equals(value, MemberDigit.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return TokenChar.Digit;
		}

		if (string.Equals(value, MemberCustom.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return TokenChar.Custom;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(TokenChar)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, TokenChar value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case TokenChar.Whitespace:
				writer.WriteStringValue(MemberWhitespace);
				break;
			case TokenChar.Symbol:
				writer.WriteStringValue(MemberSymbol);
				break;
			case TokenChar.Punctuation:
				writer.WriteStringValue(MemberPunctuation);
				break;
			case TokenChar.Letter:
				writer.WriteStringValue(MemberLetter);
				break;
			case TokenChar.Digit:
				writer.WriteStringValue(MemberDigit);
				break;
			case TokenChar.Custom:
				writer.WriteStringValue(MemberCustom);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(TokenChar)}'.");
		}
	}
}