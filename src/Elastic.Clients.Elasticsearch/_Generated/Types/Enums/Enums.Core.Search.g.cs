// Licensed to Elasticsearch B.V under one or more agreements.
// Elasticsearch B.V licenses this file to you under the Apache 2.0 License.
// See the LICENSE file in the project root for more information.
//
// ███╗   ██╗ ██████╗ ████████╗██╗ ██████╗███████╗
// ████╗  ██║██╔═══██╗╚══██╔══╝██║██╔════╝██╔════╝
// ██╔██╗ ██║██║   ██║   ██║   ██║██║     █████╗
// ██║╚██╗██║██║   ██║   ██║   ██║██║     ██╔══╝
// ██║ ╚████║╚██████╔╝   ██║   ██║╚██████╗███████╗
// ╚═╝  ╚═══╝ ╚═════╝    ╚═╝   ╚═╝ ╚═════╝╚══════╝
// ------------------------------------------------
//
// This file is automatically generated.
// Please do not edit these files manually.
//
// ------------------------------------------------

#nullable restore

using Elastic.Clients.Elasticsearch.Core;
using Elastic.Clients.Elasticsearch.Serialization;
using Elastic.Transport;
using System;
using System.Runtime.Serialization;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace Elastic.Clients.Elasticsearch.Core.Search;

[JsonConverter(typeof(BoundaryScannerConverter))]
public enum BoundaryScanner
{
	/// <summary>
	/// <para>Break highlighted fragments at the next word boundary, as determined by Java’s `BreakIterator`.<br/>You can specify the locale to use with `boundary_scanner_locale`.</para>
	/// </summary>
	[EnumMember(Value = "word")]
	Word,
	/// <summary>
	/// <para>Break highlighted fragments at the next sentence boundary, as determined by Java’s `BreakIterator`.<br/>You can specify the locale to use with `boundary_scanner_locale`.<br/>When used with the `unified` highlighter, the `sentence` scanner splits sentences bigger than `fragment_size` at the first word boundary next to fragment_size.<br/>You can set `fragment_size` to `0` to never split any sentence.</para>
	/// </summary>
	[EnumMember(Value = "sentence")]
	Sentence,
	/// <summary>
	/// <para>Use the characters specified by `boundary_chars` as highlighting boundaries.<br/>The `boundary_max_scan` setting controls how far to scan for boundary characters.<br/>Only valid for the `fvh` highlighter.</para>
	/// </summary>
	[EnumMember(Value = "chars")]
	Chars
}

internal sealed class BoundaryScannerConverter : JsonConverter<BoundaryScanner>
{
	public override BoundaryScanner Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
	{
		var enumString = reader.GetString();
		switch (enumString)
		{
			case "word":
				return BoundaryScanner.Word;
			case "sentence":
				return BoundaryScanner.Sentence;
			case "chars":
				return BoundaryScanner.Chars;
		}

		ThrowHelper.ThrowJsonException();
		return default;
	}

	public override void Write(Utf8JsonWriter writer, BoundaryScanner value, JsonSerializerOptions options)
	{
		switch (value)
		{
			case BoundaryScanner.Word:
				writer.WriteStringValue("word");
				return;
			case BoundaryScanner.Sentence:
				writer.WriteStringValue("sentence");
				return;
			case BoundaryScanner.Chars:
				writer.WriteStringValue("chars");
				return;
		}

		writer.WriteNullValue();
	}
}

[JsonConverter(typeof(HighlighterEncoderConverter))]
public enum HighlighterEncoder
{
	[EnumMember(Value = "html")]
	Html,
	[EnumMember(Value = "default")]
	Default
}

internal sealed class HighlighterEncoderConverter : JsonConverter<HighlighterEncoder>
{
	public override HighlighterEncoder Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
	{
		var enumString = reader.GetString();
		switch (enumString)
		{
			case "html":
				return HighlighterEncoder.Html;
			case "default":
				return HighlighterEncoder.Default;
		}

		ThrowHelper.ThrowJsonException();
		return default;
	}

	public override void Write(Utf8JsonWriter writer, HighlighterEncoder value, JsonSerializerOptions options)
	{
		switch (value)
		{
			case HighlighterEncoder.Html:
				writer.WriteStringValue("html");
				return;
			case HighlighterEncoder.Default:
				writer.WriteStringValue("default");
				return;
		}

		writer.WriteNullValue();
	}
}

[JsonConverter(typeof(HighlighterFragmenterConverter))]
public enum HighlighterFragmenter
{
	[EnumMember(Value = "span")]
	Span,
	[EnumMember(Value = "simple")]
	Simple
}

internal sealed class HighlighterFragmenterConverter : JsonConverter<HighlighterFragmenter>
{
	public override HighlighterFragmenter Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
	{
		var enumString = reader.GetString();
		switch (enumString)
		{
			case "span":
				return HighlighterFragmenter.Span;
			case "simple":
				return HighlighterFragmenter.Simple;
		}

		ThrowHelper.ThrowJsonException();
		return default;
	}

	public override void Write(Utf8JsonWriter writer, HighlighterFragmenter value, JsonSerializerOptions options)
	{
		switch (value)
		{
			case HighlighterFragmenter.Span:
				writer.WriteStringValue("span");
				return;
			case HighlighterFragmenter.Simple:
				writer.WriteStringValue("simple");
				return;
		}

		writer.WriteNullValue();
	}
}

[JsonConverter(typeof(HighlighterOrderConverter))]
public enum HighlighterOrder
{
	[EnumMember(Value = "score")]
	Score
}

internal sealed class HighlighterOrderConverter : JsonConverter<HighlighterOrder>
{
	public override HighlighterOrder Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
	{
		var enumString = reader.GetString();
		switch (enumString)
		{
			case "score":
				return HighlighterOrder.Score;
		}

		ThrowHelper.ThrowJsonException();
		return default;
	}

	public override void Write(Utf8JsonWriter writer, HighlighterOrder value, JsonSerializerOptions options)
	{
		switch (value)
		{
			case HighlighterOrder.Score:
				writer.WriteStringValue("score");
				return;
		}

		writer.WriteNullValue();
	}
}

[JsonConverter(typeof(HighlighterTagsSchemaConverter))]
public enum HighlighterTagsSchema
{
	[EnumMember(Value = "styled")]
	Styled
}

internal sealed class HighlighterTagsSchemaConverter : JsonConverter<HighlighterTagsSchema>
{
	public override HighlighterTagsSchema Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
	{
		var enumString = reader.GetString();
		switch (enumString)
		{
			case "styled":
				return HighlighterTagsSchema.Styled;
		}

		ThrowHelper.ThrowJsonException();
		return default;
	}

	public override void Write(Utf8JsonWriter writer, HighlighterTagsSchema value, JsonSerializerOptions options)
	{
		switch (value)
		{
			case HighlighterTagsSchema.Styled:
				writer.WriteStringValue("styled");
				return;
		}

		writer.WriteNullValue();
	}
}

[JsonConverter(typeof(EnumStructConverter<HighlighterType>))]
public readonly partial struct HighlighterType : IEnumStruct<HighlighterType>
{
	public HighlighterType(string value) => Value = value;

	HighlighterType IEnumStruct<HighlighterType>.Create(string value) => value;

	public readonly string Value { get; }

	/// <summary>
	/// <para>The unified highlighter uses the Lucene Unified Highlighter.</para>
	/// </summary>
	public static HighlighterType Unified { get; } = new HighlighterType("unified");

	/// <summary>
	/// <para>The `plain` highlighter uses the standard Lucene highlighter</para>
	/// </summary>
	public static HighlighterType Plain { get; } = new HighlighterType("plain");

	/// <summary>
	/// <para>The fvh highlighter uses the Lucene Fast Vector highlighter.</para>
	/// </summary>
	public static HighlighterType FastVector { get; } = new HighlighterType("fvh");

	public override string ToString() => Value ?? string.Empty;

	public static implicit operator string(HighlighterType highlighterType) => highlighterType.Value;
	public static implicit operator HighlighterType(string value) => new(value);

	public override int GetHashCode() => Value.GetHashCode();
	public override bool Equals(object obj) => obj is HighlighterType other && this.Equals(other);
	public bool Equals(HighlighterType other) => Value == other.Value;

	public static bool operator ==(HighlighterType a, HighlighterType b) => a.Equals(b);
	public static bool operator !=(HighlighterType a, HighlighterType b) => !(a == b);
}

[JsonConverter(typeof(ScoreModeConverter))]
public enum ScoreMode
{
	/// <summary>
	/// <para>Add the original score and the rescore query score.</para>
	/// </summary>
	[EnumMember(Value = "total")]
	Total,
	/// <summary>
	/// <para>Multiply the original score by the rescore query score.<br/>Useful for `function` query rescores.</para>
	/// </summary>
	[EnumMember(Value = "multiply")]
	Multiply,
	/// <summary>
	/// <para>Take the min of the original score and the rescore query score.</para>
	/// </summary>
	[EnumMember(Value = "min")]
	Min,
	/// <summary>
	/// <para>Take the max of original score and the rescore query score.</para>
	/// </summary>
	[EnumMember(Value = "max")]
	Max,
	/// <summary>
	/// <para>Average the original score and the rescore query score.</para>
	/// </summary>
	[EnumMember(Value = "avg")]
	Avg
}

internal sealed class ScoreModeConverter : JsonConverter<ScoreMode>
{
	public override ScoreMode Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
	{
		var enumString = reader.GetString();
		switch (enumString)
		{
			case "total":
				return ScoreMode.Total;
			case "multiply":
				return ScoreMode.Multiply;
			case "min":
				return ScoreMode.Min;
			case "max":
				return ScoreMode.Max;
			case "avg":
				return ScoreMode.Avg;
		}

		ThrowHelper.ThrowJsonException();
		return default;
	}

	public override void Write(Utf8JsonWriter writer, ScoreMode value, JsonSerializerOptions options)
	{
		switch (value)
		{
			case ScoreMode.Total:
				writer.WriteStringValue("total");
				return;
			case ScoreMode.Multiply:
				writer.WriteStringValue("multiply");
				return;
			case ScoreMode.Min:
				writer.WriteStringValue("min");
				return;
			case ScoreMode.Max:
				writer.WriteStringValue("max");
				return;
			case ScoreMode.Avg:
				writer.WriteStringValue("avg");
				return;
		}

		writer.WriteNullValue();
	}
}

[JsonConverter(typeof(StringDistanceConverter))]
public enum StringDistance
{
	/// <summary>
	/// <para>String distance algorithm based on character n-grams.</para>
	/// </summary>
	[EnumMember(Value = "ngram")]
	Ngram,
	/// <summary>
	/// <para>String distance algorithm based on the Levenshtein edit distance algorithm.</para>
	/// </summary>
	[EnumMember(Value = "levenshtein")]
	Levenshtein,
	/// <summary>
	/// <para>String distance algorithm based on Jaro-Winkler algorithm.</para>
	/// </summary>
	[EnumMember(Value = "jaro_winkler")]
	JaroWinkler,
	/// <summary>
	/// <para>Based on the Damerau-Levenshtein algorithm, but highly optimized for comparing string distance for terms inside the index.</para>
	/// </summary>
	[EnumMember(Value = "internal")]
	Internal,
	/// <summary>
	/// <para>String distance algorithm based on Damerau-Levenshtein algorithm.</para>
	/// </summary>
	[EnumMember(Value = "damerau_levenshtein")]
	DamerauLevenshtein
}

internal sealed class StringDistanceConverter : JsonConverter<StringDistance>
{
	public override StringDistance Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
	{
		var enumString = reader.GetString();
		switch (enumString)
		{
			case "ngram":
				return StringDistance.Ngram;
			case "levenshtein":
				return StringDistance.Levenshtein;
			case "jaro_winkler":
				return StringDistance.JaroWinkler;
			case "internal":
				return StringDistance.Internal;
			case "damerau_levenshtein":
				return StringDistance.DamerauLevenshtein;
		}

		ThrowHelper.ThrowJsonException();
		return default;
	}

	public override void Write(Utf8JsonWriter writer, StringDistance value, JsonSerializerOptions options)
	{
		switch (value)
		{
			case StringDistance.Ngram:
				writer.WriteStringValue("ngram");
				return;
			case StringDistance.Levenshtein:
				writer.WriteStringValue("levenshtein");
				return;
			case StringDistance.JaroWinkler:
				writer.WriteStringValue("jaro_winkler");
				return;
			case StringDistance.Internal:
				writer.WriteStringValue("internal");
				return;
			case StringDistance.DamerauLevenshtein:
				writer.WriteStringValue("damerau_levenshtein");
				return;
		}

		writer.WriteNullValue();
	}
}

[JsonConverter(typeof(SuggestSortConverter))]
public enum SuggestSort
{
	/// <summary>
	/// <para>Sort by score first, then document frequency and then the term itself.</para>
	/// </summary>
	[EnumMember(Value = "score")]
	Score,
	/// <summary>
	/// <para>Sort by document frequency first, then similarity score and then the term itself.</para>
	/// </summary>
	[EnumMember(Value = "frequency")]
	Frequency
}

internal sealed class SuggestSortConverter : JsonConverter<SuggestSort>
{
	public override SuggestSort Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
	{
		var enumString = reader.GetString();
		switch (enumString)
		{
			case "score":
				return SuggestSort.Score;
			case "frequency":
				return SuggestSort.Frequency;
		}

		ThrowHelper.ThrowJsonException();
		return default;
	}

	public override void Write(Utf8JsonWriter writer, SuggestSort value, JsonSerializerOptions options)
	{
		switch (value)
		{
			case SuggestSort.Score:
				writer.WriteStringValue("score");
				return;
			case SuggestSort.Frequency:
				writer.WriteStringValue("frequency");
				return;
		}

		writer.WriteNullValue();
	}
}

[JsonConverter(typeof(TotalHitsRelationConverter))]
public enum TotalHitsRelation
{
	/// <summary>
	/// <para>Lower bound, including returned events or sequences</para>
	/// </summary>
	[EnumMember(Value = "gte")]
	Gte,
	/// <summary>
	/// <para>Accurate</para>
	/// </summary>
	[EnumMember(Value = "eq")]
	Eq
}

internal sealed class TotalHitsRelationConverter : JsonConverter<TotalHitsRelation>
{
	public override TotalHitsRelation Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
	{
		var enumString = reader.GetString();
		switch (enumString)
		{
			case "gte":
				return TotalHitsRelation.Gte;
			case "eq":
				return TotalHitsRelation.Eq;
		}

		ThrowHelper.ThrowJsonException();
		return default;
	}

	public override void Write(Utf8JsonWriter writer, TotalHitsRelation value, JsonSerializerOptions options)
	{
		switch (value)
		{
			case TotalHitsRelation.Gte:
				writer.WriteStringValue("gte");
				return;
			case TotalHitsRelation.Eq:
				writer.WriteStringValue("eq");
				return;
		}

		writer.WriteNullValue();
	}
}