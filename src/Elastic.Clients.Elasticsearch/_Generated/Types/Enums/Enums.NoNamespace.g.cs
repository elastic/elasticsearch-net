// Licensed to Elasticsearch B.V under one or more agreements.
// Elasticsearch B.V licenses this file to you under the Apache 2.0 License.
// See the LICENSE file in the project root for more information.
//
// ███╗   ██╗ ██████╗ ████████╗██╗ ██████╗███████╗
// ████╗  ██║██╔═══██╗╚══██╔══╝██║██╔════╝██╔════╝
// ██╔██╗ ██║██║   ██║   ██║   ██║██║     █████╗
// ██║╚██╗██║██║   ██║   ██║   ██║██║     ██╔══╝
// ██║ ╚████║╚██████╔╝   ██║   ██║╚██████╗███████╗
// ╚═╝  ╚═══╝ ╚═════╝    ╚═╝   ╚═╝ ╚═════╝╚══════╝
// ------------------------------------------------
//
// This file is automatically generated.
// Please do not edit these files manually.
//
// ------------------------------------------------

#nullable restore

using Elastic.Clients.Elasticsearch.Core;
using Elastic.Clients.Elasticsearch.Serialization;
using Elastic.Transport;
using System;
using System.Runtime.Serialization;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace Elastic.Clients.Elasticsearch;

[JsonConverter(typeof(ClusterInfoTargetConverter))]
public enum ClusterInfoTarget
{
	[EnumMember(Value = "thread_pool")]
	ThreadPool,
	[EnumMember(Value = "script")]
	Script,
	[EnumMember(Value = "ingest")]
	Ingest,
	[EnumMember(Value = "http")]
	Http,
	[EnumMember(Value = "_all")]
	All
}

internal sealed partial class ClusterInfoTargetConverter : System.Text.Json.Serialization.JsonConverter<ClusterInfoTarget>
{
	private static readonly System.Text.Json.JsonEncodedText MemberThreadPool = System.Text.Json.JsonEncodedText.Encode("thread_pool");
	private static readonly System.Text.Json.JsonEncodedText MemberScript = System.Text.Json.JsonEncodedText.Encode("script");
	private static readonly System.Text.Json.JsonEncodedText MemberIngest = System.Text.Json.JsonEncodedText.Encode("ingest");
	private static readonly System.Text.Json.JsonEncodedText MemberHttp = System.Text.Json.JsonEncodedText.Encode("http");
	private static readonly System.Text.Json.JsonEncodedText MemberAll = System.Text.Json.JsonEncodedText.Encode("_all");

	public override ClusterInfoTarget Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberThreadPool))
		{
			return ClusterInfoTarget.ThreadPool;
		}

		if (reader.ValueTextEquals(MemberScript))
		{
			return ClusterInfoTarget.Script;
		}

		if (reader.ValueTextEquals(MemberIngest))
		{
			return ClusterInfoTarget.Ingest;
		}

		if (reader.ValueTextEquals(MemberHttp))
		{
			return ClusterInfoTarget.Http;
		}

		if (reader.ValueTextEquals(MemberAll))
		{
			return ClusterInfoTarget.All;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberThreadPool.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return ClusterInfoTarget.ThreadPool;
		}

		if (string.Equals(value, MemberScript.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return ClusterInfoTarget.Script;
		}

		if (string.Equals(value, MemberIngest.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return ClusterInfoTarget.Ingest;
		}

		if (string.Equals(value, MemberHttp.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return ClusterInfoTarget.Http;
		}

		if (string.Equals(value, MemberAll.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return ClusterInfoTarget.All;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(ClusterInfoTarget)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, ClusterInfoTarget value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case ClusterInfoTarget.ThreadPool:
				writer.WriteStringValue(MemberThreadPool);
				break;
			case ClusterInfoTarget.Script:
				writer.WriteStringValue(MemberScript);
				break;
			case ClusterInfoTarget.Ingest:
				writer.WriteStringValue(MemberIngest);
				break;
			case ClusterInfoTarget.Http:
				writer.WriteStringValue(MemberHttp);
				break;
			case ClusterInfoTarget.All:
				writer.WriteStringValue(MemberAll);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(ClusterInfoTarget)}'.");
		}
	}
}

[JsonConverter(typeof(ClusterSearchStatusConverter))]
public enum ClusterSearchStatus
{
	[EnumMember(Value = "successful")]
	Successful,
	[EnumMember(Value = "skipped")]
	Skipped,
	[EnumMember(Value = "running")]
	Running,
	[EnumMember(Value = "partial")]
	Partial,
	[EnumMember(Value = "failed")]
	Failed
}

internal sealed partial class ClusterSearchStatusConverter : System.Text.Json.Serialization.JsonConverter<ClusterSearchStatus>
{
	private static readonly System.Text.Json.JsonEncodedText MemberSuccessful = System.Text.Json.JsonEncodedText.Encode("successful");
	private static readonly System.Text.Json.JsonEncodedText MemberSkipped = System.Text.Json.JsonEncodedText.Encode("skipped");
	private static readonly System.Text.Json.JsonEncodedText MemberRunning = System.Text.Json.JsonEncodedText.Encode("running");
	private static readonly System.Text.Json.JsonEncodedText MemberPartial = System.Text.Json.JsonEncodedText.Encode("partial");
	private static readonly System.Text.Json.JsonEncodedText MemberFailed = System.Text.Json.JsonEncodedText.Encode("failed");

	public override ClusterSearchStatus Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberSuccessful))
		{
			return ClusterSearchStatus.Successful;
		}

		if (reader.ValueTextEquals(MemberSkipped))
		{
			return ClusterSearchStatus.Skipped;
		}

		if (reader.ValueTextEquals(MemberRunning))
		{
			return ClusterSearchStatus.Running;
		}

		if (reader.ValueTextEquals(MemberPartial))
		{
			return ClusterSearchStatus.Partial;
		}

		if (reader.ValueTextEquals(MemberFailed))
		{
			return ClusterSearchStatus.Failed;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberSuccessful.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return ClusterSearchStatus.Successful;
		}

		if (string.Equals(value, MemberSkipped.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return ClusterSearchStatus.Skipped;
		}

		if (string.Equals(value, MemberRunning.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return ClusterSearchStatus.Running;
		}

		if (string.Equals(value, MemberPartial.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return ClusterSearchStatus.Partial;
		}

		if (string.Equals(value, MemberFailed.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return ClusterSearchStatus.Failed;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(ClusterSearchStatus)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, ClusterSearchStatus value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case ClusterSearchStatus.Successful:
				writer.WriteStringValue(MemberSuccessful);
				break;
			case ClusterSearchStatus.Skipped:
				writer.WriteStringValue(MemberSkipped);
				break;
			case ClusterSearchStatus.Running:
				writer.WriteStringValue(MemberRunning);
				break;
			case ClusterSearchStatus.Partial:
				writer.WriteStringValue(MemberPartial);
				break;
			case ClusterSearchStatus.Failed:
				writer.WriteStringValue(MemberFailed);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(ClusterSearchStatus)}'.");
		}
	}
}

[JsonConverter(typeof(ConflictsConverter))]
public enum Conflicts
{
	/// <summary>
	/// <para>
	/// Continue reindexing even if there are conflicts.
	/// </para>
	/// </summary>
	[EnumMember(Value = "proceed")]
	Proceed,
	/// <summary>
	/// <para>
	/// Stop reindexing if there are conflicts.
	/// </para>
	/// </summary>
	[EnumMember(Value = "abort")]
	Abort
}

internal sealed partial class ConflictsConverter : System.Text.Json.Serialization.JsonConverter<Conflicts>
{
	private static readonly System.Text.Json.JsonEncodedText MemberProceed = System.Text.Json.JsonEncodedText.Encode("proceed");
	private static readonly System.Text.Json.JsonEncodedText MemberAbort = System.Text.Json.JsonEncodedText.Encode("abort");

	public override Conflicts Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberProceed))
		{
			return Conflicts.Proceed;
		}

		if (reader.ValueTextEquals(MemberAbort))
		{
			return Conflicts.Abort;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberProceed.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return Conflicts.Proceed;
		}

		if (string.Equals(value, MemberAbort.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return Conflicts.Abort;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(Conflicts)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, Conflicts value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case Conflicts.Proceed:
				writer.WriteStringValue(MemberProceed);
				break;
			case Conflicts.Abort:
				writer.WriteStringValue(MemberAbort);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(Conflicts)}'.");
		}
	}
}

[JsonConverter(typeof(DFIIndependenceMeasureConverter))]
public enum DFIIndependenceMeasure
{
	[EnumMember(Value = "standardized")]
	Standardized,
	[EnumMember(Value = "saturated")]
	Saturated,
	[EnumMember(Value = "chisquared")]
	Chisquared
}

internal sealed partial class DFIIndependenceMeasureConverter : System.Text.Json.Serialization.JsonConverter<DFIIndependenceMeasure>
{
	private static readonly System.Text.Json.JsonEncodedText MemberStandardized = System.Text.Json.JsonEncodedText.Encode("standardized");
	private static readonly System.Text.Json.JsonEncodedText MemberSaturated = System.Text.Json.JsonEncodedText.Encode("saturated");
	private static readonly System.Text.Json.JsonEncodedText MemberChisquared = System.Text.Json.JsonEncodedText.Encode("chisquared");

	public override DFIIndependenceMeasure Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberStandardized))
		{
			return DFIIndependenceMeasure.Standardized;
		}

		if (reader.ValueTextEquals(MemberSaturated))
		{
			return DFIIndependenceMeasure.Saturated;
		}

		if (reader.ValueTextEquals(MemberChisquared))
		{
			return DFIIndependenceMeasure.Chisquared;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberStandardized.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return DFIIndependenceMeasure.Standardized;
		}

		if (string.Equals(value, MemberSaturated.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return DFIIndependenceMeasure.Saturated;
		}

		if (string.Equals(value, MemberChisquared.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return DFIIndependenceMeasure.Chisquared;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(DFIIndependenceMeasure)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, DFIIndependenceMeasure value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case DFIIndependenceMeasure.Standardized:
				writer.WriteStringValue(MemberStandardized);
				break;
			case DFIIndependenceMeasure.Saturated:
				writer.WriteStringValue(MemberSaturated);
				break;
			case DFIIndependenceMeasure.Chisquared:
				writer.WriteStringValue(MemberChisquared);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(DFIIndependenceMeasure)}'.");
		}
	}
}

[JsonConverter(typeof(DFRAfterEffectConverter))]
public enum DFRAfterEffect
{
	[EnumMember(Value = "no")]
	No,
	[EnumMember(Value = "l")]
	l,
	[EnumMember(Value = "b")]
	b
}

internal sealed partial class DFRAfterEffectConverter : System.Text.Json.Serialization.JsonConverter<DFRAfterEffect>
{
	private static readonly System.Text.Json.JsonEncodedText MemberNo = System.Text.Json.JsonEncodedText.Encode("no");
	private static readonly System.Text.Json.JsonEncodedText Memberl = System.Text.Json.JsonEncodedText.Encode("l");
	private static readonly System.Text.Json.JsonEncodedText Memberb = System.Text.Json.JsonEncodedText.Encode("b");

	public override DFRAfterEffect Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberNo))
		{
			return DFRAfterEffect.No;
		}

		if (reader.ValueTextEquals(Memberl))
		{
			return DFRAfterEffect.l;
		}

		if (reader.ValueTextEquals(Memberb))
		{
			return DFRAfterEffect.b;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberNo.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return DFRAfterEffect.No;
		}

		if (string.Equals(value, Memberl.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return DFRAfterEffect.l;
		}

		if (string.Equals(value, Memberb.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return DFRAfterEffect.b;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(DFRAfterEffect)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, DFRAfterEffect value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case DFRAfterEffect.No:
				writer.WriteStringValue(MemberNo);
				break;
			case DFRAfterEffect.l:
				writer.WriteStringValue(Memberl);
				break;
			case DFRAfterEffect.b:
				writer.WriteStringValue(Memberb);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(DFRAfterEffect)}'.");
		}
	}
}

[JsonConverter(typeof(DFRBasicModelConverter))]
public enum DFRBasicModel
{
	[EnumMember(Value = "p")]
	p,
	[EnumMember(Value = "ine")]
	Ine,
	[EnumMember(Value = "in")]
	In,
	[EnumMember(Value = "if")]
	If,
	[EnumMember(Value = "g")]
	g,
	[EnumMember(Value = "d")]
	d,
	[EnumMember(Value = "be")]
	Be
}

internal sealed partial class DFRBasicModelConverter : System.Text.Json.Serialization.JsonConverter<DFRBasicModel>
{
	private static readonly System.Text.Json.JsonEncodedText Memberp = System.Text.Json.JsonEncodedText.Encode("p");
	private static readonly System.Text.Json.JsonEncodedText MemberIne = System.Text.Json.JsonEncodedText.Encode("ine");
	private static readonly System.Text.Json.JsonEncodedText MemberIn = System.Text.Json.JsonEncodedText.Encode("in");
	private static readonly System.Text.Json.JsonEncodedText MemberIf = System.Text.Json.JsonEncodedText.Encode("if");
	private static readonly System.Text.Json.JsonEncodedText Memberg = System.Text.Json.JsonEncodedText.Encode("g");
	private static readonly System.Text.Json.JsonEncodedText Memberd = System.Text.Json.JsonEncodedText.Encode("d");
	private static readonly System.Text.Json.JsonEncodedText MemberBe = System.Text.Json.JsonEncodedText.Encode("be");

	public override DFRBasicModel Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(Memberp))
		{
			return DFRBasicModel.p;
		}

		if (reader.ValueTextEquals(MemberIne))
		{
			return DFRBasicModel.Ine;
		}

		if (reader.ValueTextEquals(MemberIn))
		{
			return DFRBasicModel.In;
		}

		if (reader.ValueTextEquals(MemberIf))
		{
			return DFRBasicModel.If;
		}

		if (reader.ValueTextEquals(Memberg))
		{
			return DFRBasicModel.g;
		}

		if (reader.ValueTextEquals(Memberd))
		{
			return DFRBasicModel.d;
		}

		if (reader.ValueTextEquals(MemberBe))
		{
			return DFRBasicModel.Be;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, Memberp.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return DFRBasicModel.p;
		}

		if (string.Equals(value, MemberIne.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return DFRBasicModel.Ine;
		}

		if (string.Equals(value, MemberIn.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return DFRBasicModel.In;
		}

		if (string.Equals(value, MemberIf.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return DFRBasicModel.If;
		}

		if (string.Equals(value, Memberg.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return DFRBasicModel.g;
		}

		if (string.Equals(value, Memberd.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return DFRBasicModel.d;
		}

		if (string.Equals(value, MemberBe.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return DFRBasicModel.Be;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(DFRBasicModel)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, DFRBasicModel value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case DFRBasicModel.p:
				writer.WriteStringValue(Memberp);
				break;
			case DFRBasicModel.Ine:
				writer.WriteStringValue(MemberIne);
				break;
			case DFRBasicModel.In:
				writer.WriteStringValue(MemberIn);
				break;
			case DFRBasicModel.If:
				writer.WriteStringValue(MemberIf);
				break;
			case DFRBasicModel.g:
				writer.WriteStringValue(Memberg);
				break;
			case DFRBasicModel.d:
				writer.WriteStringValue(Memberd);
				break;
			case DFRBasicModel.Be:
				writer.WriteStringValue(MemberBe);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(DFRBasicModel)}'.");
		}
	}
}

[JsonConverter(typeof(DistanceUnitConverter))]
public enum DistanceUnit
{
	[EnumMember(Value = "yd")]
	Yards,
	[EnumMember(Value = "nmi")]
	NauticMiles,
	[EnumMember(Value = "mm")]
	Millimeters,
	[EnumMember(Value = "mi")]
	Miles,
	[EnumMember(Value = "m")]
	Meters,
	[EnumMember(Value = "km")]
	Kilometers,
	[EnumMember(Value = "in")]
	Inches,
	[EnumMember(Value = "ft")]
	Feet,
	[EnumMember(Value = "cm")]
	Centimeters
}

internal sealed partial class DistanceUnitConverter : System.Text.Json.Serialization.JsonConverter<DistanceUnit>
{
	private static readonly System.Text.Json.JsonEncodedText MemberYards = System.Text.Json.JsonEncodedText.Encode("yd");
	private static readonly System.Text.Json.JsonEncodedText MemberNauticMiles = System.Text.Json.JsonEncodedText.Encode("nmi");
	private static readonly System.Text.Json.JsonEncodedText MemberMillimeters = System.Text.Json.JsonEncodedText.Encode("mm");
	private static readonly System.Text.Json.JsonEncodedText MemberMiles = System.Text.Json.JsonEncodedText.Encode("mi");
	private static readonly System.Text.Json.JsonEncodedText MemberMeters = System.Text.Json.JsonEncodedText.Encode("m");
	private static readonly System.Text.Json.JsonEncodedText MemberKilometers = System.Text.Json.JsonEncodedText.Encode("km");
	private static readonly System.Text.Json.JsonEncodedText MemberInches = System.Text.Json.JsonEncodedText.Encode("in");
	private static readonly System.Text.Json.JsonEncodedText MemberFeet = System.Text.Json.JsonEncodedText.Encode("ft");
	private static readonly System.Text.Json.JsonEncodedText MemberCentimeters = System.Text.Json.JsonEncodedText.Encode("cm");

	public override DistanceUnit Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberYards))
		{
			return DistanceUnit.Yards;
		}

		if (reader.ValueTextEquals(MemberNauticMiles))
		{
			return DistanceUnit.NauticMiles;
		}

		if (reader.ValueTextEquals(MemberMillimeters))
		{
			return DistanceUnit.Millimeters;
		}

		if (reader.ValueTextEquals(MemberMiles))
		{
			return DistanceUnit.Miles;
		}

		if (reader.ValueTextEquals(MemberMeters))
		{
			return DistanceUnit.Meters;
		}

		if (reader.ValueTextEquals(MemberKilometers))
		{
			return DistanceUnit.Kilometers;
		}

		if (reader.ValueTextEquals(MemberInches))
		{
			return DistanceUnit.Inches;
		}

		if (reader.ValueTextEquals(MemberFeet))
		{
			return DistanceUnit.Feet;
		}

		if (reader.ValueTextEquals(MemberCentimeters))
		{
			return DistanceUnit.Centimeters;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberYards.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return DistanceUnit.Yards;
		}

		if (string.Equals(value, MemberNauticMiles.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return DistanceUnit.NauticMiles;
		}

		if (string.Equals(value, MemberMillimeters.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return DistanceUnit.Millimeters;
		}

		if (string.Equals(value, MemberMiles.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return DistanceUnit.Miles;
		}

		if (string.Equals(value, MemberMeters.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return DistanceUnit.Meters;
		}

		if (string.Equals(value, MemberKilometers.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return DistanceUnit.Kilometers;
		}

		if (string.Equals(value, MemberInches.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return DistanceUnit.Inches;
		}

		if (string.Equals(value, MemberFeet.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return DistanceUnit.Feet;
		}

		if (string.Equals(value, MemberCentimeters.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return DistanceUnit.Centimeters;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(DistanceUnit)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, DistanceUnit value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case DistanceUnit.Yards:
				writer.WriteStringValue(MemberYards);
				break;
			case DistanceUnit.NauticMiles:
				writer.WriteStringValue(MemberNauticMiles);
				break;
			case DistanceUnit.Millimeters:
				writer.WriteStringValue(MemberMillimeters);
				break;
			case DistanceUnit.Miles:
				writer.WriteStringValue(MemberMiles);
				break;
			case DistanceUnit.Meters:
				writer.WriteStringValue(MemberMeters);
				break;
			case DistanceUnit.Kilometers:
				writer.WriteStringValue(MemberKilometers);
				break;
			case DistanceUnit.Inches:
				writer.WriteStringValue(MemberInches);
				break;
			case DistanceUnit.Feet:
				writer.WriteStringValue(MemberFeet);
				break;
			case DistanceUnit.Centimeters:
				writer.WriteStringValue(MemberCentimeters);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(DistanceUnit)}'.");
		}
	}
}

[JsonConverter(typeof(ExpandWildcardConverter))]
public enum ExpandWildcard
{
	/// <summary>
	/// <para>
	/// Match open, non-hidden indices. Also matches any non-hidden data stream.
	/// </para>
	/// </summary>
	[EnumMember(Value = "open")]
	Open,
	/// <summary>
	/// <para>
	/// Wildcard expressions are not accepted.
	/// </para>
	/// </summary>
	[EnumMember(Value = "none")]
	None,
	/// <summary>
	/// <para>
	/// Match hidden data streams and hidden indices. Must be combined with open, closed, or both.
	/// </para>
	/// </summary>
	[EnumMember(Value = "hidden")]
	Hidden,
	/// <summary>
	/// <para>
	/// Match closed, non-hidden indices. Also matches any non-hidden data stream. Data streams cannot be closed.
	/// </para>
	/// </summary>
	[EnumMember(Value = "closed")]
	Closed,
	/// <summary>
	/// <para>
	/// Match any data stream or index, including hidden ones.
	/// </para>
	/// </summary>
	[EnumMember(Value = "all")]
	All
}

internal sealed partial class ExpandWildcardConverter : System.Text.Json.Serialization.JsonConverter<ExpandWildcard>
{
	private static readonly System.Text.Json.JsonEncodedText MemberOpen = System.Text.Json.JsonEncodedText.Encode("open");
	private static readonly System.Text.Json.JsonEncodedText MemberNone = System.Text.Json.JsonEncodedText.Encode("none");
	private static readonly System.Text.Json.JsonEncodedText MemberHidden = System.Text.Json.JsonEncodedText.Encode("hidden");
	private static readonly System.Text.Json.JsonEncodedText MemberClosed = System.Text.Json.JsonEncodedText.Encode("closed");
	private static readonly System.Text.Json.JsonEncodedText MemberAll = System.Text.Json.JsonEncodedText.Encode("all");

	public override ExpandWildcard Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberOpen))
		{
			return ExpandWildcard.Open;
		}

		if (reader.ValueTextEquals(MemberNone))
		{
			return ExpandWildcard.None;
		}

		if (reader.ValueTextEquals(MemberHidden))
		{
			return ExpandWildcard.Hidden;
		}

		if (reader.ValueTextEquals(MemberClosed))
		{
			return ExpandWildcard.Closed;
		}

		if (reader.ValueTextEquals(MemberAll))
		{
			return ExpandWildcard.All;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberOpen.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return ExpandWildcard.Open;
		}

		if (string.Equals(value, MemberNone.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return ExpandWildcard.None;
		}

		if (string.Equals(value, MemberHidden.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return ExpandWildcard.Hidden;
		}

		if (string.Equals(value, MemberClosed.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return ExpandWildcard.Closed;
		}

		if (string.Equals(value, MemberAll.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return ExpandWildcard.All;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(ExpandWildcard)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, ExpandWildcard value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case ExpandWildcard.Open:
				writer.WriteStringValue(MemberOpen);
				break;
			case ExpandWildcard.None:
				writer.WriteStringValue(MemberNone);
				break;
			case ExpandWildcard.Hidden:
				writer.WriteStringValue(MemberHidden);
				break;
			case ExpandWildcard.Closed:
				writer.WriteStringValue(MemberClosed);
				break;
			case ExpandWildcard.All:
				writer.WriteStringValue(MemberAll);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(ExpandWildcard)}'.");
		}
	}
}

[JsonConverter(typeof(FieldSortNumericTypeConverter))]
public enum FieldSortNumericType
{
	[EnumMember(Value = "long")]
	Long,
	[EnumMember(Value = "double")]
	Double,
	[EnumMember(Value = "date_nanos")]
	DateNanos,
	[EnumMember(Value = "date")]
	Date
}

internal sealed partial class FieldSortNumericTypeConverter : System.Text.Json.Serialization.JsonConverter<FieldSortNumericType>
{
	private static readonly System.Text.Json.JsonEncodedText MemberLong = System.Text.Json.JsonEncodedText.Encode("long");
	private static readonly System.Text.Json.JsonEncodedText MemberDouble = System.Text.Json.JsonEncodedText.Encode("double");
	private static readonly System.Text.Json.JsonEncodedText MemberDateNanos = System.Text.Json.JsonEncodedText.Encode("date_nanos");
	private static readonly System.Text.Json.JsonEncodedText MemberDate = System.Text.Json.JsonEncodedText.Encode("date");

	public override FieldSortNumericType Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberLong))
		{
			return FieldSortNumericType.Long;
		}

		if (reader.ValueTextEquals(MemberDouble))
		{
			return FieldSortNumericType.Double;
		}

		if (reader.ValueTextEquals(MemberDateNanos))
		{
			return FieldSortNumericType.DateNanos;
		}

		if (reader.ValueTextEquals(MemberDate))
		{
			return FieldSortNumericType.Date;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberLong.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return FieldSortNumericType.Long;
		}

		if (string.Equals(value, MemberDouble.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return FieldSortNumericType.Double;
		}

		if (string.Equals(value, MemberDateNanos.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return FieldSortNumericType.DateNanos;
		}

		if (string.Equals(value, MemberDate.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return FieldSortNumericType.Date;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(FieldSortNumericType)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, FieldSortNumericType value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case FieldSortNumericType.Long:
				writer.WriteStringValue(MemberLong);
				break;
			case FieldSortNumericType.Double:
				writer.WriteStringValue(MemberDouble);
				break;
			case FieldSortNumericType.DateNanos:
				writer.WriteStringValue(MemberDateNanos);
				break;
			case FieldSortNumericType.Date:
				writer.WriteStringValue(MemberDate);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(FieldSortNumericType)}'.");
		}
	}
}

[JsonConverter(typeof(GeoDistanceTypeConverter))]
public enum GeoDistanceType
{
	/// <summary>
	/// <para>
	/// The <c>plane</c> calculation is faster but less accurate.
	/// </para>
	/// </summary>
	[EnumMember(Value = "plane")]
	Plane,
	/// <summary>
	/// <para>
	/// The <c>arc</c> calculation is the most accurate.
	/// </para>
	/// </summary>
	[EnumMember(Value = "arc")]
	Arc
}

internal sealed partial class GeoDistanceTypeConverter : System.Text.Json.Serialization.JsonConverter<GeoDistanceType>
{
	private static readonly System.Text.Json.JsonEncodedText MemberPlane = System.Text.Json.JsonEncodedText.Encode("plane");
	private static readonly System.Text.Json.JsonEncodedText MemberArc = System.Text.Json.JsonEncodedText.Encode("arc");

	public override GeoDistanceType Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberPlane))
		{
			return GeoDistanceType.Plane;
		}

		if (reader.ValueTextEquals(MemberArc))
		{
			return GeoDistanceType.Arc;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberPlane.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return GeoDistanceType.Plane;
		}

		if (string.Equals(value, MemberArc.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return GeoDistanceType.Arc;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(GeoDistanceType)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, GeoDistanceType value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case GeoDistanceType.Plane:
				writer.WriteStringValue(MemberPlane);
				break;
			case GeoDistanceType.Arc:
				writer.WriteStringValue(MemberArc);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(GeoDistanceType)}'.");
		}
	}
}

[JsonConverter(typeof(GeoShapeRelationConverter))]
public enum GeoShapeRelation
{
	/// <summary>
	/// <para>
	/// Return all documents whose <c>geo_shape</c> or <c>geo_point</c> field is within the query geometry.
	/// Line geometries are not supported.
	/// </para>
	/// </summary>
	[EnumMember(Value = "within")]
	Within,
	/// <summary>
	/// <para>
	/// Return all documents whose <c>geo_shape</c> or <c>geo_point</c> field intersects the query geometry.
	/// </para>
	/// </summary>
	[EnumMember(Value = "intersects")]
	Intersects,
	/// <summary>
	/// <para>
	/// Return all documents whose <c>geo_shape</c> or <c>geo_point</c> field has nothing in common with the query geometry.
	/// </para>
	/// </summary>
	[EnumMember(Value = "disjoint")]
	Disjoint,
	/// <summary>
	/// <para>
	/// Return all documents whose <c>geo_shape</c> or <c>geo_point</c> field contains the query geometry.
	/// </para>
	/// </summary>
	[EnumMember(Value = "contains")]
	Contains
}

internal sealed partial class GeoShapeRelationConverter : System.Text.Json.Serialization.JsonConverter<GeoShapeRelation>
{
	private static readonly System.Text.Json.JsonEncodedText MemberWithin = System.Text.Json.JsonEncodedText.Encode("within");
	private static readonly System.Text.Json.JsonEncodedText MemberIntersects = System.Text.Json.JsonEncodedText.Encode("intersects");
	private static readonly System.Text.Json.JsonEncodedText MemberDisjoint = System.Text.Json.JsonEncodedText.Encode("disjoint");
	private static readonly System.Text.Json.JsonEncodedText MemberContains = System.Text.Json.JsonEncodedText.Encode("contains");

	public override GeoShapeRelation Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberWithin))
		{
			return GeoShapeRelation.Within;
		}

		if (reader.ValueTextEquals(MemberIntersects))
		{
			return GeoShapeRelation.Intersects;
		}

		if (reader.ValueTextEquals(MemberDisjoint))
		{
			return GeoShapeRelation.Disjoint;
		}

		if (reader.ValueTextEquals(MemberContains))
		{
			return GeoShapeRelation.Contains;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberWithin.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return GeoShapeRelation.Within;
		}

		if (string.Equals(value, MemberIntersects.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return GeoShapeRelation.Intersects;
		}

		if (string.Equals(value, MemberDisjoint.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return GeoShapeRelation.Disjoint;
		}

		if (string.Equals(value, MemberContains.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return GeoShapeRelation.Contains;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(GeoShapeRelation)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, GeoShapeRelation value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case GeoShapeRelation.Within:
				writer.WriteStringValue(MemberWithin);
				break;
			case GeoShapeRelation.Intersects:
				writer.WriteStringValue(MemberIntersects);
				break;
			case GeoShapeRelation.Disjoint:
				writer.WriteStringValue(MemberDisjoint);
				break;
			case GeoShapeRelation.Contains:
				writer.WriteStringValue(MemberContains);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(GeoShapeRelation)}'.");
		}
	}
}

[JsonConverter(typeof(HealthStatusConverter))]
public enum HealthStatus
{
	/// <summary>
	/// <para>
	/// All primary shards are assigned, but one or more replica shards are unassigned. If a node in the cluster fails, some data could be unavailable until that node is repaired.
	/// </para>
	/// </summary>
	[EnumMember(Value = "yellow")]
	Yellow,
	/// <summary>
	/// <para>
	/// One or more primary shards are unassigned, so some data is unavailable. This can occur briefly during cluster startup as primary shards are assigned.
	/// </para>
	/// </summary>
	[EnumMember(Value = "red")]
	Red,
	/// <summary>
	/// <para>
	/// All shards are assigned.
	/// </para>
	/// </summary>
	[EnumMember(Value = "green")]
	Green
}

internal sealed partial class HealthStatusConverter : System.Text.Json.Serialization.JsonConverter<HealthStatus>
{
	private static readonly System.Text.Json.JsonEncodedText MemberYellow = System.Text.Json.JsonEncodedText.Encode("yellow");
	private static readonly System.Text.Json.JsonEncodedText MemberYellow1 = System.Text.Json.JsonEncodedText.Encode("YELLOW");
	private static readonly System.Text.Json.JsonEncodedText MemberRed = System.Text.Json.JsonEncodedText.Encode("red");
	private static readonly System.Text.Json.JsonEncodedText MemberRed1 = System.Text.Json.JsonEncodedText.Encode("RED");
	private static readonly System.Text.Json.JsonEncodedText MemberGreen = System.Text.Json.JsonEncodedText.Encode("green");
	private static readonly System.Text.Json.JsonEncodedText MemberGreen1 = System.Text.Json.JsonEncodedText.Encode("GREEN");

	public override HealthStatus Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberYellow) || reader.ValueTextEquals(MemberYellow1))
		{
			return HealthStatus.Yellow;
		}

		if (reader.ValueTextEquals(MemberRed) || reader.ValueTextEquals(MemberRed1))
		{
			return HealthStatus.Red;
		}

		if (reader.ValueTextEquals(MemberGreen) || reader.ValueTextEquals(MemberGreen1))
		{
			return HealthStatus.Green;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberYellow.Value, System.StringComparison.OrdinalIgnoreCase) || string.Equals(value, MemberYellow1.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return HealthStatus.Yellow;
		}

		if (string.Equals(value, MemberRed.Value, System.StringComparison.OrdinalIgnoreCase) || string.Equals(value, MemberRed1.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return HealthStatus.Red;
		}

		if (string.Equals(value, MemberGreen.Value, System.StringComparison.OrdinalIgnoreCase) || string.Equals(value, MemberGreen1.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return HealthStatus.Green;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(HealthStatus)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, HealthStatus value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case HealthStatus.Yellow:
				writer.WriteStringValue(MemberYellow);
				break;
			case HealthStatus.Red:
				writer.WriteStringValue(MemberRed);
				break;
			case HealthStatus.Green:
				writer.WriteStringValue(MemberGreen);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(HealthStatus)}'.");
		}
	}
}

[JsonConverter(typeof(IBDistributionConverter))]
public enum IBDistribution
{
	[EnumMember(Value = "spl")]
	Spl,
	[EnumMember(Value = "ll")]
	Ll
}

internal sealed partial class IBDistributionConverter : System.Text.Json.Serialization.JsonConverter<IBDistribution>
{
	private static readonly System.Text.Json.JsonEncodedText MemberSpl = System.Text.Json.JsonEncodedText.Encode("spl");
	private static readonly System.Text.Json.JsonEncodedText MemberLl = System.Text.Json.JsonEncodedText.Encode("ll");

	public override IBDistribution Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberSpl))
		{
			return IBDistribution.Spl;
		}

		if (reader.ValueTextEquals(MemberLl))
		{
			return IBDistribution.Ll;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberSpl.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return IBDistribution.Spl;
		}

		if (string.Equals(value, MemberLl.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return IBDistribution.Ll;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(IBDistribution)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, IBDistribution value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case IBDistribution.Spl:
				writer.WriteStringValue(MemberSpl);
				break;
			case IBDistribution.Ll:
				writer.WriteStringValue(MemberLl);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(IBDistribution)}'.");
		}
	}
}

[JsonConverter(typeof(IBLambdaConverter))]
public enum IBLambda
{
	[EnumMember(Value = "ttf")]
	Ttf,
	[EnumMember(Value = "df")]
	Df
}

internal sealed partial class IBLambdaConverter : System.Text.Json.Serialization.JsonConverter<IBLambda>
{
	private static readonly System.Text.Json.JsonEncodedText MemberTtf = System.Text.Json.JsonEncodedText.Encode("ttf");
	private static readonly System.Text.Json.JsonEncodedText MemberDf = System.Text.Json.JsonEncodedText.Encode("df");

	public override IBLambda Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberTtf))
		{
			return IBLambda.Ttf;
		}

		if (reader.ValueTextEquals(MemberDf))
		{
			return IBLambda.Df;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberTtf.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return IBLambda.Ttf;
		}

		if (string.Equals(value, MemberDf.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return IBLambda.Df;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(IBLambda)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, IBLambda value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case IBLambda.Ttf:
				writer.WriteStringValue(MemberTtf);
				break;
			case IBLambda.Df:
				writer.WriteStringValue(MemberDf);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(IBLambda)}'.");
		}
	}
}

[JsonConverter(typeof(LevelConverter))]
public enum Level
{
	[EnumMember(Value = "shards")]
	Shards,
	[EnumMember(Value = "indices")]
	Indices,
	[EnumMember(Value = "cluster")]
	Cluster
}

internal sealed partial class LevelConverter : System.Text.Json.Serialization.JsonConverter<Level>
{
	private static readonly System.Text.Json.JsonEncodedText MemberShards = System.Text.Json.JsonEncodedText.Encode("shards");
	private static readonly System.Text.Json.JsonEncodedText MemberIndices = System.Text.Json.JsonEncodedText.Encode("indices");
	private static readonly System.Text.Json.JsonEncodedText MemberCluster = System.Text.Json.JsonEncodedText.Encode("cluster");

	public override Level Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberShards))
		{
			return Level.Shards;
		}

		if (reader.ValueTextEquals(MemberIndices))
		{
			return Level.Indices;
		}

		if (reader.ValueTextEquals(MemberCluster))
		{
			return Level.Cluster;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberShards.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return Level.Shards;
		}

		if (string.Equals(value, MemberIndices.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return Level.Indices;
		}

		if (string.Equals(value, MemberCluster.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return Level.Cluster;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(Level)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, Level value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case Level.Shards:
				writer.WriteStringValue(MemberShards);
				break;
			case Level.Indices:
				writer.WriteStringValue(MemberIndices);
				break;
			case Level.Cluster:
				writer.WriteStringValue(MemberCluster);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(Level)}'.");
		}
	}
}

[JsonConverter(typeof(LifecycleOperationModeConverter))]
public enum LifecycleOperationMode
{
	[EnumMember(Value = "STOPPING")]
	Stopping,
	[EnumMember(Value = "STOPPED")]
	Stopped,
	[EnumMember(Value = "RUNNING")]
	Running
}

internal sealed partial class LifecycleOperationModeConverter : System.Text.Json.Serialization.JsonConverter<LifecycleOperationMode>
{
	private static readonly System.Text.Json.JsonEncodedText MemberStopping = System.Text.Json.JsonEncodedText.Encode("STOPPING");
	private static readonly System.Text.Json.JsonEncodedText MemberStopped = System.Text.Json.JsonEncodedText.Encode("STOPPED");
	private static readonly System.Text.Json.JsonEncodedText MemberRunning = System.Text.Json.JsonEncodedText.Encode("RUNNING");

	public override LifecycleOperationMode Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberStopping))
		{
			return LifecycleOperationMode.Stopping;
		}

		if (reader.ValueTextEquals(MemberStopped))
		{
			return LifecycleOperationMode.Stopped;
		}

		if (reader.ValueTextEquals(MemberRunning))
		{
			return LifecycleOperationMode.Running;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberStopping.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return LifecycleOperationMode.Stopping;
		}

		if (string.Equals(value, MemberStopped.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return LifecycleOperationMode.Stopped;
		}

		if (string.Equals(value, MemberRunning.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return LifecycleOperationMode.Running;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(LifecycleOperationMode)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, LifecycleOperationMode value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case LifecycleOperationMode.Stopping:
				writer.WriteStringValue(MemberStopping);
				break;
			case LifecycleOperationMode.Stopped:
				writer.WriteStringValue(MemberStopped);
				break;
			case LifecycleOperationMode.Running:
				writer.WriteStringValue(MemberRunning);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(LifecycleOperationMode)}'.");
		}
	}
}

[JsonConverter(typeof(NodeRoleConverter))]
public enum NodeRole
{
	[EnumMember(Value = "voting_only")]
	VotingOnly,
	[EnumMember(Value = "transform")]
	Transform,
	[EnumMember(Value = "remote_cluster_client")]
	RemoteClusterClient,
	[EnumMember(Value = "ml")]
	Ml,
	[EnumMember(Value = "master")]
	Master,
	[EnumMember(Value = "ingest")]
	Ingest,
	[EnumMember(Value = "data_warm")]
	DataWarm,
	[EnumMember(Value = "data_hot")]
	DataHot,
	[EnumMember(Value = "data_frozen")]
	DataFrozen,
	[EnumMember(Value = "data_content")]
	DataContent,
	[EnumMember(Value = "data_cold")]
	DataCold,
	[EnumMember(Value = "data")]
	Data,
	[EnumMember(Value = "coordinating_only")]
	CoordinatingOnly,
	[EnumMember(Value = "client")]
	Client
}

internal sealed partial class NodeRoleConverter : System.Text.Json.Serialization.JsonConverter<NodeRole>
{
	private static readonly System.Text.Json.JsonEncodedText MemberVotingOnly = System.Text.Json.JsonEncodedText.Encode("voting_only");
	private static readonly System.Text.Json.JsonEncodedText MemberTransform = System.Text.Json.JsonEncodedText.Encode("transform");
	private static readonly System.Text.Json.JsonEncodedText MemberRemoteClusterClient = System.Text.Json.JsonEncodedText.Encode("remote_cluster_client");
	private static readonly System.Text.Json.JsonEncodedText MemberMl = System.Text.Json.JsonEncodedText.Encode("ml");
	private static readonly System.Text.Json.JsonEncodedText MemberMaster = System.Text.Json.JsonEncodedText.Encode("master");
	private static readonly System.Text.Json.JsonEncodedText MemberIngest = System.Text.Json.JsonEncodedText.Encode("ingest");
	private static readonly System.Text.Json.JsonEncodedText MemberDataWarm = System.Text.Json.JsonEncodedText.Encode("data_warm");
	private static readonly System.Text.Json.JsonEncodedText MemberDataHot = System.Text.Json.JsonEncodedText.Encode("data_hot");
	private static readonly System.Text.Json.JsonEncodedText MemberDataFrozen = System.Text.Json.JsonEncodedText.Encode("data_frozen");
	private static readonly System.Text.Json.JsonEncodedText MemberDataContent = System.Text.Json.JsonEncodedText.Encode("data_content");
	private static readonly System.Text.Json.JsonEncodedText MemberDataCold = System.Text.Json.JsonEncodedText.Encode("data_cold");
	private static readonly System.Text.Json.JsonEncodedText MemberData = System.Text.Json.JsonEncodedText.Encode("data");
	private static readonly System.Text.Json.JsonEncodedText MemberCoordinatingOnly = System.Text.Json.JsonEncodedText.Encode("coordinating_only");
	private static readonly System.Text.Json.JsonEncodedText MemberClient = System.Text.Json.JsonEncodedText.Encode("client");

	public override NodeRole Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberVotingOnly))
		{
			return NodeRole.VotingOnly;
		}

		if (reader.ValueTextEquals(MemberTransform))
		{
			return NodeRole.Transform;
		}

		if (reader.ValueTextEquals(MemberRemoteClusterClient))
		{
			return NodeRole.RemoteClusterClient;
		}

		if (reader.ValueTextEquals(MemberMl))
		{
			return NodeRole.Ml;
		}

		if (reader.ValueTextEquals(MemberMaster))
		{
			return NodeRole.Master;
		}

		if (reader.ValueTextEquals(MemberIngest))
		{
			return NodeRole.Ingest;
		}

		if (reader.ValueTextEquals(MemberDataWarm))
		{
			return NodeRole.DataWarm;
		}

		if (reader.ValueTextEquals(MemberDataHot))
		{
			return NodeRole.DataHot;
		}

		if (reader.ValueTextEquals(MemberDataFrozen))
		{
			return NodeRole.DataFrozen;
		}

		if (reader.ValueTextEquals(MemberDataContent))
		{
			return NodeRole.DataContent;
		}

		if (reader.ValueTextEquals(MemberDataCold))
		{
			return NodeRole.DataCold;
		}

		if (reader.ValueTextEquals(MemberData))
		{
			return NodeRole.Data;
		}

		if (reader.ValueTextEquals(MemberCoordinatingOnly))
		{
			return NodeRole.CoordinatingOnly;
		}

		if (reader.ValueTextEquals(MemberClient))
		{
			return NodeRole.Client;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberVotingOnly.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return NodeRole.VotingOnly;
		}

		if (string.Equals(value, MemberTransform.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return NodeRole.Transform;
		}

		if (string.Equals(value, MemberRemoteClusterClient.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return NodeRole.RemoteClusterClient;
		}

		if (string.Equals(value, MemberMl.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return NodeRole.Ml;
		}

		if (string.Equals(value, MemberMaster.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return NodeRole.Master;
		}

		if (string.Equals(value, MemberIngest.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return NodeRole.Ingest;
		}

		if (string.Equals(value, MemberDataWarm.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return NodeRole.DataWarm;
		}

		if (string.Equals(value, MemberDataHot.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return NodeRole.DataHot;
		}

		if (string.Equals(value, MemberDataFrozen.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return NodeRole.DataFrozen;
		}

		if (string.Equals(value, MemberDataContent.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return NodeRole.DataContent;
		}

		if (string.Equals(value, MemberDataCold.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return NodeRole.DataCold;
		}

		if (string.Equals(value, MemberData.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return NodeRole.Data;
		}

		if (string.Equals(value, MemberCoordinatingOnly.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return NodeRole.CoordinatingOnly;
		}

		if (string.Equals(value, MemberClient.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return NodeRole.Client;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(NodeRole)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, NodeRole value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case NodeRole.VotingOnly:
				writer.WriteStringValue(MemberVotingOnly);
				break;
			case NodeRole.Transform:
				writer.WriteStringValue(MemberTransform);
				break;
			case NodeRole.RemoteClusterClient:
				writer.WriteStringValue(MemberRemoteClusterClient);
				break;
			case NodeRole.Ml:
				writer.WriteStringValue(MemberMl);
				break;
			case NodeRole.Master:
				writer.WriteStringValue(MemberMaster);
				break;
			case NodeRole.Ingest:
				writer.WriteStringValue(MemberIngest);
				break;
			case NodeRole.DataWarm:
				writer.WriteStringValue(MemberDataWarm);
				break;
			case NodeRole.DataHot:
				writer.WriteStringValue(MemberDataHot);
				break;
			case NodeRole.DataFrozen:
				writer.WriteStringValue(MemberDataFrozen);
				break;
			case NodeRole.DataContent:
				writer.WriteStringValue(MemberDataContent);
				break;
			case NodeRole.DataCold:
				writer.WriteStringValue(MemberDataCold);
				break;
			case NodeRole.Data:
				writer.WriteStringValue(MemberData);
				break;
			case NodeRole.CoordinatingOnly:
				writer.WriteStringValue(MemberCoordinatingOnly);
				break;
			case NodeRole.Client:
				writer.WriteStringValue(MemberClient);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(NodeRole)}'.");
		}
	}
}

[JsonConverter(typeof(NormalizationConverter))]
public enum Normalization
{
	[EnumMember(Value = "z")]
	z,
	[EnumMember(Value = "no")]
	No,
	[EnumMember(Value = "h3")]
	H3,
	[EnumMember(Value = "h2")]
	H2,
	[EnumMember(Value = "h1")]
	H1
}

internal sealed partial class NormalizationConverter : System.Text.Json.Serialization.JsonConverter<Normalization>
{
	private static readonly System.Text.Json.JsonEncodedText Memberz = System.Text.Json.JsonEncodedText.Encode("z");
	private static readonly System.Text.Json.JsonEncodedText MemberNo = System.Text.Json.JsonEncodedText.Encode("no");
	private static readonly System.Text.Json.JsonEncodedText MemberH3 = System.Text.Json.JsonEncodedText.Encode("h3");
	private static readonly System.Text.Json.JsonEncodedText MemberH2 = System.Text.Json.JsonEncodedText.Encode("h2");
	private static readonly System.Text.Json.JsonEncodedText MemberH1 = System.Text.Json.JsonEncodedText.Encode("h1");

	public override Normalization Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(Memberz))
		{
			return Normalization.z;
		}

		if (reader.ValueTextEquals(MemberNo))
		{
			return Normalization.No;
		}

		if (reader.ValueTextEquals(MemberH3))
		{
			return Normalization.H3;
		}

		if (reader.ValueTextEquals(MemberH2))
		{
			return Normalization.H2;
		}

		if (reader.ValueTextEquals(MemberH1))
		{
			return Normalization.H1;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, Memberz.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return Normalization.z;
		}

		if (string.Equals(value, MemberNo.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return Normalization.No;
		}

		if (string.Equals(value, MemberH3.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return Normalization.H3;
		}

		if (string.Equals(value, MemberH2.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return Normalization.H2;
		}

		if (string.Equals(value, MemberH1.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return Normalization.H1;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(Normalization)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, Normalization value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case Normalization.z:
				writer.WriteStringValue(Memberz);
				break;
			case Normalization.No:
				writer.WriteStringValue(MemberNo);
				break;
			case Normalization.H3:
				writer.WriteStringValue(MemberH3);
				break;
			case Normalization.H2:
				writer.WriteStringValue(MemberH2);
				break;
			case Normalization.H1:
				writer.WriteStringValue(MemberH1);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(Normalization)}'.");
		}
	}
}

[JsonConverter(typeof(ResultConverter))]
public enum Result
{
	[EnumMember(Value = "updated")]
	Updated,
	[EnumMember(Value = "not_found")]
	NotFound,
	[EnumMember(Value = "noop")]
	NoOp,
	[EnumMember(Value = "deleted")]
	Deleted,
	[EnumMember(Value = "created")]
	Created
}

internal sealed partial class ResultConverter : System.Text.Json.Serialization.JsonConverter<Result>
{
	private static readonly System.Text.Json.JsonEncodedText MemberUpdated = System.Text.Json.JsonEncodedText.Encode("updated");
	private static readonly System.Text.Json.JsonEncodedText MemberNotFound = System.Text.Json.JsonEncodedText.Encode("not_found");
	private static readonly System.Text.Json.JsonEncodedText MemberNoOp = System.Text.Json.JsonEncodedText.Encode("noop");
	private static readonly System.Text.Json.JsonEncodedText MemberDeleted = System.Text.Json.JsonEncodedText.Encode("deleted");
	private static readonly System.Text.Json.JsonEncodedText MemberCreated = System.Text.Json.JsonEncodedText.Encode("created");

	public override Result Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberUpdated))
		{
			return Result.Updated;
		}

		if (reader.ValueTextEquals(MemberNotFound))
		{
			return Result.NotFound;
		}

		if (reader.ValueTextEquals(MemberNoOp))
		{
			return Result.NoOp;
		}

		if (reader.ValueTextEquals(MemberDeleted))
		{
			return Result.Deleted;
		}

		if (reader.ValueTextEquals(MemberCreated))
		{
			return Result.Created;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberUpdated.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return Result.Updated;
		}

		if (string.Equals(value, MemberNotFound.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return Result.NotFound;
		}

		if (string.Equals(value, MemberNoOp.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return Result.NoOp;
		}

		if (string.Equals(value, MemberDeleted.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return Result.Deleted;
		}

		if (string.Equals(value, MemberCreated.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return Result.Created;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(Result)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, Result value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case Result.Updated:
				writer.WriteStringValue(MemberUpdated);
				break;
			case Result.NotFound:
				writer.WriteStringValue(MemberNotFound);
				break;
			case Result.NoOp:
				writer.WriteStringValue(MemberNoOp);
				break;
			case Result.Deleted:
				writer.WriteStringValue(MemberDeleted);
				break;
			case Result.Created:
				writer.WriteStringValue(MemberCreated);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(Result)}'.");
		}
	}
}

[JsonConverter(typeof(EnumStructConverter<ScriptLanguage>))]
public readonly partial struct ScriptLanguage : IEnumStruct<ScriptLanguage>
{
	public ScriptLanguage(string value) => Value = value;
#if NET7_0_OR_GREATER
	static ScriptLanguage IEnumStruct<ScriptLanguage>.Create(string value) => value;
#else
	ScriptLanguage IEnumStruct<ScriptLanguage>.Create(string value) => value;
#endif
	public readonly string Value { get; }

	/// <summary>
	/// <para>
	/// Painless scripting language, purpose-built for Elasticsearch.
	/// </para>
	/// </summary>
	public static ScriptLanguage Painless { get; } = new ScriptLanguage("painless");

	/// <summary>
	/// <para>
	/// Mustache templated, used for templates.
	/// </para>
	/// </summary>
	public static ScriptLanguage Mustache { get; } = new ScriptLanguage("mustache");

	/// <summary>
	/// <para>
	/// Expert Java API
	/// </para>
	/// </summary>
	public static ScriptLanguage Java { get; } = new ScriptLanguage("java");

	/// <summary>
	/// <para>
	/// Lucene’s expressions language, compiles a JavaScript expression to bytecode.
	/// </para>
	/// </summary>
	public static ScriptLanguage Expression { get; } = new ScriptLanguage("expression");

	public override string ToString() => Value ?? string.Empty;

	public static implicit operator string(ScriptLanguage scriptLanguage) => scriptLanguage.Value;
	public static implicit operator ScriptLanguage(string value) => new(value);

	public override int GetHashCode() => Value.GetHashCode();
	public override bool Equals(object obj) => obj is ScriptLanguage other && this.Equals(other);
	public bool Equals(ScriptLanguage other) => Value == other.Value;

	public static bool operator ==(ScriptLanguage a, ScriptLanguage b) => a.Equals(b);
	public static bool operator !=(ScriptLanguage a, ScriptLanguage b) => !(a == b);
}

[JsonConverter(typeof(ScriptSortTypeConverter))]
public enum ScriptSortType
{
	[EnumMember(Value = "version")]
	Version,
	[EnumMember(Value = "string")]
	String,
	[EnumMember(Value = "number")]
	Number
}

internal sealed partial class ScriptSortTypeConverter : System.Text.Json.Serialization.JsonConverter<ScriptSortType>
{
	private static readonly System.Text.Json.JsonEncodedText MemberVersion = System.Text.Json.JsonEncodedText.Encode("version");
	private static readonly System.Text.Json.JsonEncodedText MemberString = System.Text.Json.JsonEncodedText.Encode("string");
	private static readonly System.Text.Json.JsonEncodedText MemberNumber = System.Text.Json.JsonEncodedText.Encode("number");

	public override ScriptSortType Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberVersion))
		{
			return ScriptSortType.Version;
		}

		if (reader.ValueTextEquals(MemberString))
		{
			return ScriptSortType.String;
		}

		if (reader.ValueTextEquals(MemberNumber))
		{
			return ScriptSortType.Number;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberVersion.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return ScriptSortType.Version;
		}

		if (string.Equals(value, MemberString.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return ScriptSortType.String;
		}

		if (string.Equals(value, MemberNumber.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return ScriptSortType.Number;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(ScriptSortType)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, ScriptSortType value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case ScriptSortType.Version:
				writer.WriteStringValue(MemberVersion);
				break;
			case ScriptSortType.String:
				writer.WriteStringValue(MemberString);
				break;
			case ScriptSortType.Number:
				writer.WriteStringValue(MemberNumber);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(ScriptSortType)}'.");
		}
	}
}

[JsonConverter(typeof(SearchTypeConverter))]
public enum SearchType
{
	/// <summary>
	/// <para>
	/// Documents are scored using local term and document frequencies for the shard. This is usually faster but less accurate.
	/// </para>
	/// </summary>
	[EnumMember(Value = "query_then_fetch")]
	QueryThenFetch,
	/// <summary>
	/// <para>
	/// Documents are scored using global term and document frequencies across all shards. This is usually slower but more accurate.
	/// </para>
	/// </summary>
	[EnumMember(Value = "dfs_query_then_fetch")]
	DfsQueryThenFetch
}

internal sealed partial class SearchTypeConverter : System.Text.Json.Serialization.JsonConverter<SearchType>
{
	private static readonly System.Text.Json.JsonEncodedText MemberQueryThenFetch = System.Text.Json.JsonEncodedText.Encode("query_then_fetch");
	private static readonly System.Text.Json.JsonEncodedText MemberDfsQueryThenFetch = System.Text.Json.JsonEncodedText.Encode("dfs_query_then_fetch");

	public override SearchType Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberQueryThenFetch))
		{
			return SearchType.QueryThenFetch;
		}

		if (reader.ValueTextEquals(MemberDfsQueryThenFetch))
		{
			return SearchType.DfsQueryThenFetch;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberQueryThenFetch.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return SearchType.QueryThenFetch;
		}

		if (string.Equals(value, MemberDfsQueryThenFetch.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return SearchType.DfsQueryThenFetch;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(SearchType)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, SearchType value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case SearchType.QueryThenFetch:
				writer.WriteStringValue(MemberQueryThenFetch);
				break;
			case SearchType.DfsQueryThenFetch:
				writer.WriteStringValue(MemberDfsQueryThenFetch);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(SearchType)}'.");
		}
	}
}

[JsonConverter(typeof(SlicesCalculationConverter))]
public enum SlicesCalculation
{
	/// <summary>
	/// <para>
	/// Let Elasticsearch choose a reasonable number for most data streams and indices.
	/// </para>
	/// </summary>
	[EnumMember(Value = "auto")]
	Auto
}

internal sealed partial class SlicesCalculationConverter : System.Text.Json.Serialization.JsonConverter<SlicesCalculation>
{
	private static readonly System.Text.Json.JsonEncodedText MemberAuto = System.Text.Json.JsonEncodedText.Encode("auto");

	public override SlicesCalculation Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberAuto))
		{
			return SlicesCalculation.Auto;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberAuto.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return SlicesCalculation.Auto;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(SlicesCalculation)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, SlicesCalculation value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case SlicesCalculation.Auto:
				writer.WriteStringValue(MemberAuto);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(SlicesCalculation)}'.");
		}
	}
}

[JsonConverter(typeof(SortModeConverter))]
public enum SortMode
{
	[EnumMember(Value = "sum")]
	Sum,
	[EnumMember(Value = "min")]
	Min,
	[EnumMember(Value = "median")]
	Median,
	[EnumMember(Value = "max")]
	Max,
	[EnumMember(Value = "avg")]
	Avg
}

internal sealed partial class SortModeConverter : System.Text.Json.Serialization.JsonConverter<SortMode>
{
	private static readonly System.Text.Json.JsonEncodedText MemberSum = System.Text.Json.JsonEncodedText.Encode("sum");
	private static readonly System.Text.Json.JsonEncodedText MemberMin = System.Text.Json.JsonEncodedText.Encode("min");
	private static readonly System.Text.Json.JsonEncodedText MemberMedian = System.Text.Json.JsonEncodedText.Encode("median");
	private static readonly System.Text.Json.JsonEncodedText MemberMax = System.Text.Json.JsonEncodedText.Encode("max");
	private static readonly System.Text.Json.JsonEncodedText MemberAvg = System.Text.Json.JsonEncodedText.Encode("avg");

	public override SortMode Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberSum))
		{
			return SortMode.Sum;
		}

		if (reader.ValueTextEquals(MemberMin))
		{
			return SortMode.Min;
		}

		if (reader.ValueTextEquals(MemberMedian))
		{
			return SortMode.Median;
		}

		if (reader.ValueTextEquals(MemberMax))
		{
			return SortMode.Max;
		}

		if (reader.ValueTextEquals(MemberAvg))
		{
			return SortMode.Avg;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberSum.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return SortMode.Sum;
		}

		if (string.Equals(value, MemberMin.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return SortMode.Min;
		}

		if (string.Equals(value, MemberMedian.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return SortMode.Median;
		}

		if (string.Equals(value, MemberMax.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return SortMode.Max;
		}

		if (string.Equals(value, MemberAvg.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return SortMode.Avg;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(SortMode)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, SortMode value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case SortMode.Sum:
				writer.WriteStringValue(MemberSum);
				break;
			case SortMode.Min:
				writer.WriteStringValue(MemberMin);
				break;
			case SortMode.Median:
				writer.WriteStringValue(MemberMedian);
				break;
			case SortMode.Max:
				writer.WriteStringValue(MemberMax);
				break;
			case SortMode.Avg:
				writer.WriteStringValue(MemberAvg);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(SortMode)}'.");
		}
	}
}

[JsonConverter(typeof(SortOrderConverter))]
public enum SortOrder
{
	/// <summary>
	/// <para>
	/// Descending (largest to smallest)
	/// </para>
	/// </summary>
	[EnumMember(Value = "desc")]
	Desc,
	/// <summary>
	/// <para>
	/// Ascending (smallest to largest)
	/// </para>
	/// </summary>
	[EnumMember(Value = "asc")]
	Asc
}

internal sealed partial class SortOrderConverter : System.Text.Json.Serialization.JsonConverter<SortOrder>
{
	private static readonly System.Text.Json.JsonEncodedText MemberDesc = System.Text.Json.JsonEncodedText.Encode("desc");
	private static readonly System.Text.Json.JsonEncodedText MemberAsc = System.Text.Json.JsonEncodedText.Encode("asc");

	public override SortOrder Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberDesc))
		{
			return SortOrder.Desc;
		}

		if (reader.ValueTextEquals(MemberAsc))
		{
			return SortOrder.Asc;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberDesc.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return SortOrder.Desc;
		}

		if (string.Equals(value, MemberAsc.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return SortOrder.Asc;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(SortOrder)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, SortOrder value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case SortOrder.Desc:
				writer.WriteStringValue(MemberDesc);
				break;
			case SortOrder.Asc:
				writer.WriteStringValue(MemberAsc);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(SortOrder)}'.");
		}
	}
}

[JsonConverter(typeof(SuggestModeConverter))]
public enum SuggestMode
{
	/// <summary>
	/// <para>
	/// Only suggest terms that occur in more docs on the shard than the original term.
	/// </para>
	/// </summary>
	[EnumMember(Value = "popular")]
	Popular,
	/// <summary>
	/// <para>
	/// Only generate suggestions for terms that are not in the shard.
	/// </para>
	/// </summary>
	[EnumMember(Value = "missing")]
	Missing,
	/// <summary>
	/// <para>
	/// Suggest any matching suggestions based on terms in the suggest text.
	/// </para>
	/// </summary>
	[EnumMember(Value = "always")]
	Always
}

internal sealed partial class SuggestModeConverter : System.Text.Json.Serialization.JsonConverter<SuggestMode>
{
	private static readonly System.Text.Json.JsonEncodedText MemberPopular = System.Text.Json.JsonEncodedText.Encode("popular");
	private static readonly System.Text.Json.JsonEncodedText MemberMissing = System.Text.Json.JsonEncodedText.Encode("missing");
	private static readonly System.Text.Json.JsonEncodedText MemberAlways = System.Text.Json.JsonEncodedText.Encode("always");

	public override SuggestMode Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberPopular))
		{
			return SuggestMode.Popular;
		}

		if (reader.ValueTextEquals(MemberMissing))
		{
			return SuggestMode.Missing;
		}

		if (reader.ValueTextEquals(MemberAlways))
		{
			return SuggestMode.Always;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberPopular.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return SuggestMode.Popular;
		}

		if (string.Equals(value, MemberMissing.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return SuggestMode.Missing;
		}

		if (string.Equals(value, MemberAlways.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return SuggestMode.Always;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(SuggestMode)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, SuggestMode value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case SuggestMode.Popular:
				writer.WriteStringValue(MemberPopular);
				break;
			case SuggestMode.Missing:
				writer.WriteStringValue(MemberMissing);
				break;
			case SuggestMode.Always:
				writer.WriteStringValue(MemberAlways);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(SuggestMode)}'.");
		}
	}
}

[JsonConverter(typeof(ThreadTypeConverter))]
public enum ThreadType
{
	[EnumMember(Value = "wait")]
	Wait,
	[EnumMember(Value = "mem")]
	Mem,
	[EnumMember(Value = "gpu")]
	Gpu,
	[EnumMember(Value = "cpu")]
	Cpu,
	[EnumMember(Value = "block")]
	Block
}

internal sealed partial class ThreadTypeConverter : System.Text.Json.Serialization.JsonConverter<ThreadType>
{
	private static readonly System.Text.Json.JsonEncodedText MemberWait = System.Text.Json.JsonEncodedText.Encode("wait");
	private static readonly System.Text.Json.JsonEncodedText MemberMem = System.Text.Json.JsonEncodedText.Encode("mem");
	private static readonly System.Text.Json.JsonEncodedText MemberGpu = System.Text.Json.JsonEncodedText.Encode("gpu");
	private static readonly System.Text.Json.JsonEncodedText MemberCpu = System.Text.Json.JsonEncodedText.Encode("cpu");
	private static readonly System.Text.Json.JsonEncodedText MemberBlock = System.Text.Json.JsonEncodedText.Encode("block");

	public override ThreadType Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberWait))
		{
			return ThreadType.Wait;
		}

		if (reader.ValueTextEquals(MemberMem))
		{
			return ThreadType.Mem;
		}

		if (reader.ValueTextEquals(MemberGpu))
		{
			return ThreadType.Gpu;
		}

		if (reader.ValueTextEquals(MemberCpu))
		{
			return ThreadType.Cpu;
		}

		if (reader.ValueTextEquals(MemberBlock))
		{
			return ThreadType.Block;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberWait.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return ThreadType.Wait;
		}

		if (string.Equals(value, MemberMem.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return ThreadType.Mem;
		}

		if (string.Equals(value, MemberGpu.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return ThreadType.Gpu;
		}

		if (string.Equals(value, MemberCpu.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return ThreadType.Cpu;
		}

		if (string.Equals(value, MemberBlock.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return ThreadType.Block;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(ThreadType)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, ThreadType value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case ThreadType.Wait:
				writer.WriteStringValue(MemberWait);
				break;
			case ThreadType.Mem:
				writer.WriteStringValue(MemberMem);
				break;
			case ThreadType.Gpu:
				writer.WriteStringValue(MemberGpu);
				break;
			case ThreadType.Cpu:
				writer.WriteStringValue(MemberCpu);
				break;
			case ThreadType.Block:
				writer.WriteStringValue(MemberBlock);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(ThreadType)}'.");
		}
	}
}

[JsonConverter(typeof(TimeUnitConverter))]
public enum TimeUnit
{
	[EnumMember(Value = "s")]
	Seconds,
	[EnumMember(Value = "nanos")]
	Nanoseconds,
	[EnumMember(Value = "m")]
	Minutes,
	[EnumMember(Value = "ms")]
	Milliseconds,
	[EnumMember(Value = "micros")]
	Microseconds,
	[EnumMember(Value = "h")]
	Hours,
	[EnumMember(Value = "d")]
	Days
}

internal sealed partial class TimeUnitConverter : System.Text.Json.Serialization.JsonConverter<TimeUnit>
{
	private static readonly System.Text.Json.JsonEncodedText MemberSeconds = System.Text.Json.JsonEncodedText.Encode("s");
	private static readonly System.Text.Json.JsonEncodedText MemberNanoseconds = System.Text.Json.JsonEncodedText.Encode("nanos");
	private static readonly System.Text.Json.JsonEncodedText MemberMinutes = System.Text.Json.JsonEncodedText.Encode("m");
	private static readonly System.Text.Json.JsonEncodedText MemberMilliseconds = System.Text.Json.JsonEncodedText.Encode("ms");
	private static readonly System.Text.Json.JsonEncodedText MemberMicroseconds = System.Text.Json.JsonEncodedText.Encode("micros");
	private static readonly System.Text.Json.JsonEncodedText MemberHours = System.Text.Json.JsonEncodedText.Encode("h");
	private static readonly System.Text.Json.JsonEncodedText MemberDays = System.Text.Json.JsonEncodedText.Encode("d");

	public override TimeUnit Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberSeconds))
		{
			return TimeUnit.Seconds;
		}

		if (reader.ValueTextEquals(MemberNanoseconds))
		{
			return TimeUnit.Nanoseconds;
		}

		if (reader.ValueTextEquals(MemberMinutes))
		{
			return TimeUnit.Minutes;
		}

		if (reader.ValueTextEquals(MemberMilliseconds))
		{
			return TimeUnit.Milliseconds;
		}

		if (reader.ValueTextEquals(MemberMicroseconds))
		{
			return TimeUnit.Microseconds;
		}

		if (reader.ValueTextEquals(MemberHours))
		{
			return TimeUnit.Hours;
		}

		if (reader.ValueTextEquals(MemberDays))
		{
			return TimeUnit.Days;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberSeconds.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return TimeUnit.Seconds;
		}

		if (string.Equals(value, MemberNanoseconds.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return TimeUnit.Nanoseconds;
		}

		if (string.Equals(value, MemberMinutes.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return TimeUnit.Minutes;
		}

		if (string.Equals(value, MemberMilliseconds.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return TimeUnit.Milliseconds;
		}

		if (string.Equals(value, MemberMicroseconds.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return TimeUnit.Microseconds;
		}

		if (string.Equals(value, MemberHours.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return TimeUnit.Hours;
		}

		if (string.Equals(value, MemberDays.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return TimeUnit.Days;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(TimeUnit)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, TimeUnit value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case TimeUnit.Seconds:
				writer.WriteStringValue(MemberSeconds);
				break;
			case TimeUnit.Nanoseconds:
				writer.WriteStringValue(MemberNanoseconds);
				break;
			case TimeUnit.Minutes:
				writer.WriteStringValue(MemberMinutes);
				break;
			case TimeUnit.Milliseconds:
				writer.WriteStringValue(MemberMilliseconds);
				break;
			case TimeUnit.Microseconds:
				writer.WriteStringValue(MemberMicroseconds);
				break;
			case TimeUnit.Hours:
				writer.WriteStringValue(MemberHours);
				break;
			case TimeUnit.Days:
				writer.WriteStringValue(MemberDays);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(TimeUnit)}'.");
		}
	}
}

[JsonConverter(typeof(VersionTypeConverter))]
public enum VersionType
{
	/// <summary>
	/// <para>
	/// Use internal versioning that starts at 1 and increments with each update or delete.
	/// </para>
	/// </summary>
	[EnumMember(Value = "internal")]
	Internal,
	[EnumMember(Value = "force")]
	Force,
	/// <summary>
	/// <para>
	/// Only index the document if the given version is equal or higher than the version of the stored document or if there is no existing document.
	/// Note: the external_gte version type is meant for special use cases and should be used with care.
	/// If used incorrectly, it can result in loss of data.
	/// </para>
	/// </summary>
	[EnumMember(Value = "external_gte")]
	ExternalGte,
	/// <summary>
	/// <para>
	/// Only index the document if the given version is strictly higher than the version of the stored document or if there is no existing document.
	/// </para>
	/// </summary>
	[EnumMember(Value = "external")]
	External
}

internal sealed partial class VersionTypeConverter : System.Text.Json.Serialization.JsonConverter<VersionType>
{
	private static readonly System.Text.Json.JsonEncodedText MemberInternal = System.Text.Json.JsonEncodedText.Encode("internal");
	private static readonly System.Text.Json.JsonEncodedText MemberForce = System.Text.Json.JsonEncodedText.Encode("force");
	private static readonly System.Text.Json.JsonEncodedText MemberExternalGte = System.Text.Json.JsonEncodedText.Encode("external_gte");
	private static readonly System.Text.Json.JsonEncodedText MemberExternal = System.Text.Json.JsonEncodedText.Encode("external");

	public override VersionType Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberInternal))
		{
			return VersionType.Internal;
		}

		if (reader.ValueTextEquals(MemberForce))
		{
			return VersionType.Force;
		}

		if (reader.ValueTextEquals(MemberExternalGte))
		{
			return VersionType.ExternalGte;
		}

		if (reader.ValueTextEquals(MemberExternal))
		{
			return VersionType.External;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberInternal.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return VersionType.Internal;
		}

		if (string.Equals(value, MemberForce.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return VersionType.Force;
		}

		if (string.Equals(value, MemberExternalGte.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return VersionType.ExternalGte;
		}

		if (string.Equals(value, MemberExternal.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return VersionType.External;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(VersionType)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, VersionType value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case VersionType.Internal:
				writer.WriteStringValue(MemberInternal);
				break;
			case VersionType.Force:
				writer.WriteStringValue(MemberForce);
				break;
			case VersionType.ExternalGte:
				writer.WriteStringValue(MemberExternalGte);
				break;
			case VersionType.External:
				writer.WriteStringValue(MemberExternal);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(VersionType)}'.");
		}
	}
}

[JsonConverter(typeof(WaitForEventsConverter))]
public enum WaitForEvents
{
	[EnumMember(Value = "urgent")]
	Urgent,
	[EnumMember(Value = "normal")]
	Normal,
	[EnumMember(Value = "low")]
	Low,
	[EnumMember(Value = "languid")]
	Languid,
	[EnumMember(Value = "immediate")]
	Immediate,
	[EnumMember(Value = "high")]
	High
}

internal sealed partial class WaitForEventsConverter : System.Text.Json.Serialization.JsonConverter<WaitForEvents>
{
	private static readonly System.Text.Json.JsonEncodedText MemberUrgent = System.Text.Json.JsonEncodedText.Encode("urgent");
	private static readonly System.Text.Json.JsonEncodedText MemberNormal = System.Text.Json.JsonEncodedText.Encode("normal");
	private static readonly System.Text.Json.JsonEncodedText MemberLow = System.Text.Json.JsonEncodedText.Encode("low");
	private static readonly System.Text.Json.JsonEncodedText MemberLanguid = System.Text.Json.JsonEncodedText.Encode("languid");
	private static readonly System.Text.Json.JsonEncodedText MemberImmediate = System.Text.Json.JsonEncodedText.Encode("immediate");
	private static readonly System.Text.Json.JsonEncodedText MemberHigh = System.Text.Json.JsonEncodedText.Encode("high");

	public override WaitForEvents Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberUrgent))
		{
			return WaitForEvents.Urgent;
		}

		if (reader.ValueTextEquals(MemberNormal))
		{
			return WaitForEvents.Normal;
		}

		if (reader.ValueTextEquals(MemberLow))
		{
			return WaitForEvents.Low;
		}

		if (reader.ValueTextEquals(MemberLanguid))
		{
			return WaitForEvents.Languid;
		}

		if (reader.ValueTextEquals(MemberImmediate))
		{
			return WaitForEvents.Immediate;
		}

		if (reader.ValueTextEquals(MemberHigh))
		{
			return WaitForEvents.High;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberUrgent.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return WaitForEvents.Urgent;
		}

		if (string.Equals(value, MemberNormal.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return WaitForEvents.Normal;
		}

		if (string.Equals(value, MemberLow.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return WaitForEvents.Low;
		}

		if (string.Equals(value, MemberLanguid.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return WaitForEvents.Languid;
		}

		if (string.Equals(value, MemberImmediate.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return WaitForEvents.Immediate;
		}

		if (string.Equals(value, MemberHigh.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return WaitForEvents.High;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(WaitForEvents)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, WaitForEvents value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case WaitForEvents.Urgent:
				writer.WriteStringValue(MemberUrgent);
				break;
			case WaitForEvents.Normal:
				writer.WriteStringValue(MemberNormal);
				break;
			case WaitForEvents.Low:
				writer.WriteStringValue(MemberLow);
				break;
			case WaitForEvents.Languid:
				writer.WriteStringValue(MemberLanguid);
				break;
			case WaitForEvents.Immediate:
				writer.WriteStringValue(MemberImmediate);
				break;
			case WaitForEvents.High:
				writer.WriteStringValue(MemberHigh);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(WaitForEvents)}'.");
		}
	}
}