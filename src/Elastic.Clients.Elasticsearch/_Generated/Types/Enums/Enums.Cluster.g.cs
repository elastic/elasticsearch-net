// Licensed to Elasticsearch B.V under one or more agreements.
// Elasticsearch B.V licenses this file to you under the Apache 2.0 License.
// See the LICENSE file in the project root for more information.
//
// ███╗   ██╗ ██████╗ ████████╗██╗ ██████╗███████╗
// ████╗  ██║██╔═══██╗╚══██╔══╝██║██╔════╝██╔════╝
// ██╔██╗ ██║██║   ██║   ██║   ██║██║     █████╗
// ██║╚██╗██║██║   ██║   ██║   ██║██║     ██╔══╝
// ██║ ╚████║╚██████╔╝   ██║   ██║╚██████╗███████╗
// ╚═╝  ╚═══╝ ╚═════╝    ╚═╝   ╚═╝ ╚═════╝╚══════╝
// ------------------------------------------------
//
// This file is automatically generated.
// Please do not edit these files manually.
//
// ------------------------------------------------

#nullable restore

using Elastic.Clients.Elasticsearch.Core;
using Elastic.Clients.Elasticsearch.Serialization;
using Elastic.Transport;
using System;
using System.Runtime.Serialization;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace Elastic.Clients.Elasticsearch.Cluster;

[JsonConverter(typeof(AllocationExplainDecisionConverter))]
public enum AllocationExplainDecision
{
	[EnumMember(Value = "YES")]
	Yes,
	[EnumMember(Value = "THROTTLE")]
	Throttle,
	[EnumMember(Value = "NO")]
	No,
	[EnumMember(Value = "ALWAYS")]
	Always
}

internal sealed partial class AllocationExplainDecisionConverter : System.Text.Json.Serialization.JsonConverter<AllocationExplainDecision>
{
	private static readonly System.Text.Json.JsonEncodedText MemberYes = System.Text.Json.JsonEncodedText.Encode("YES");
	private static readonly System.Text.Json.JsonEncodedText MemberThrottle = System.Text.Json.JsonEncodedText.Encode("THROTTLE");
	private static readonly System.Text.Json.JsonEncodedText MemberNo = System.Text.Json.JsonEncodedText.Encode("NO");
	private static readonly System.Text.Json.JsonEncodedText MemberAlways = System.Text.Json.JsonEncodedText.Encode("ALWAYS");

	public override AllocationExplainDecision Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberYes))
		{
			return AllocationExplainDecision.Yes;
		}

		if (reader.ValueTextEquals(MemberThrottle))
		{
			return AllocationExplainDecision.Throttle;
		}

		if (reader.ValueTextEquals(MemberNo))
		{
			return AllocationExplainDecision.No;
		}

		if (reader.ValueTextEquals(MemberAlways))
		{
			return AllocationExplainDecision.Always;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberYes.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return AllocationExplainDecision.Yes;
		}

		if (string.Equals(value, MemberThrottle.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return AllocationExplainDecision.Throttle;
		}

		if (string.Equals(value, MemberNo.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return AllocationExplainDecision.No;
		}

		if (string.Equals(value, MemberAlways.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return AllocationExplainDecision.Always;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(AllocationExplainDecision)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, AllocationExplainDecision value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case AllocationExplainDecision.Yes:
				writer.WriteStringValue(MemberYes);
				break;
			case AllocationExplainDecision.Throttle:
				writer.WriteStringValue(MemberThrottle);
				break;
			case AllocationExplainDecision.No:
				writer.WriteStringValue(MemberNo);
				break;
			case AllocationExplainDecision.Always:
				writer.WriteStringValue(MemberAlways);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(AllocationExplainDecision)}'.");
		}
	}
}

[JsonConverter(typeof(DecisionConverter))]
public enum Decision
{
	[EnumMember(Value = "yes")]
	Yes,
	[EnumMember(Value = "worse_balance")]
	WorseBalance,
	[EnumMember(Value = "throttled")]
	Throttled,
	[EnumMember(Value = "no_valid_shard_copy")]
	NoValidShardCopy,
	[EnumMember(Value = "no_attempt")]
	NoAttempt,
	[EnumMember(Value = "no")]
	No,
	[EnumMember(Value = "awaiting_info")]
	AwaitingInfo,
	[EnumMember(Value = "allocation_delayed")]
	AllocationDelayed
}

internal sealed partial class DecisionConverter : System.Text.Json.Serialization.JsonConverter<Decision>
{
	private static readonly System.Text.Json.JsonEncodedText MemberYes = System.Text.Json.JsonEncodedText.Encode("yes");
	private static readonly System.Text.Json.JsonEncodedText MemberWorseBalance = System.Text.Json.JsonEncodedText.Encode("worse_balance");
	private static readonly System.Text.Json.JsonEncodedText MemberThrottled = System.Text.Json.JsonEncodedText.Encode("throttled");
	private static readonly System.Text.Json.JsonEncodedText MemberNoValidShardCopy = System.Text.Json.JsonEncodedText.Encode("no_valid_shard_copy");
	private static readonly System.Text.Json.JsonEncodedText MemberNoAttempt = System.Text.Json.JsonEncodedText.Encode("no_attempt");
	private static readonly System.Text.Json.JsonEncodedText MemberNo = System.Text.Json.JsonEncodedText.Encode("no");
	private static readonly System.Text.Json.JsonEncodedText MemberAwaitingInfo = System.Text.Json.JsonEncodedText.Encode("awaiting_info");
	private static readonly System.Text.Json.JsonEncodedText MemberAllocationDelayed = System.Text.Json.JsonEncodedText.Encode("allocation_delayed");

	public override Decision Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberYes))
		{
			return Decision.Yes;
		}

		if (reader.ValueTextEquals(MemberWorseBalance))
		{
			return Decision.WorseBalance;
		}

		if (reader.ValueTextEquals(MemberThrottled))
		{
			return Decision.Throttled;
		}

		if (reader.ValueTextEquals(MemberNoValidShardCopy))
		{
			return Decision.NoValidShardCopy;
		}

		if (reader.ValueTextEquals(MemberNoAttempt))
		{
			return Decision.NoAttempt;
		}

		if (reader.ValueTextEquals(MemberNo))
		{
			return Decision.No;
		}

		if (reader.ValueTextEquals(MemberAwaitingInfo))
		{
			return Decision.AwaitingInfo;
		}

		if (reader.ValueTextEquals(MemberAllocationDelayed))
		{
			return Decision.AllocationDelayed;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberYes.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return Decision.Yes;
		}

		if (string.Equals(value, MemberWorseBalance.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return Decision.WorseBalance;
		}

		if (string.Equals(value, MemberThrottled.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return Decision.Throttled;
		}

		if (string.Equals(value, MemberNoValidShardCopy.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return Decision.NoValidShardCopy;
		}

		if (string.Equals(value, MemberNoAttempt.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return Decision.NoAttempt;
		}

		if (string.Equals(value, MemberNo.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return Decision.No;
		}

		if (string.Equals(value, MemberAwaitingInfo.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return Decision.AwaitingInfo;
		}

		if (string.Equals(value, MemberAllocationDelayed.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return Decision.AllocationDelayed;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(Decision)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, Decision value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case Decision.Yes:
				writer.WriteStringValue(MemberYes);
				break;
			case Decision.WorseBalance:
				writer.WriteStringValue(MemberWorseBalance);
				break;
			case Decision.Throttled:
				writer.WriteStringValue(MemberThrottled);
				break;
			case Decision.NoValidShardCopy:
				writer.WriteStringValue(MemberNoValidShardCopy);
				break;
			case Decision.NoAttempt:
				writer.WriteStringValue(MemberNoAttempt);
				break;
			case Decision.No:
				writer.WriteStringValue(MemberNo);
				break;
			case Decision.AwaitingInfo:
				writer.WriteStringValue(MemberAwaitingInfo);
				break;
			case Decision.AllocationDelayed:
				writer.WriteStringValue(MemberAllocationDelayed);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(Decision)}'.");
		}
	}
}

[JsonConverter(typeof(UnassignedInformationReasonConverter))]
public enum UnassignedInformationReason
{
	[EnumMember(Value = "REROUTE_CANCELLED")]
	RerouteCancelled,
	[EnumMember(Value = "REPLICA_ADDED")]
	ReplicaAdded,
	[EnumMember(Value = "REINITIALIZED")]
	Reinitialized,
	[EnumMember(Value = "REALLOCATED_REPLICA")]
	ReallocatedReplica,
	[EnumMember(Value = "PRIMARY_FAILED")]
	PrimaryFailed,
	[EnumMember(Value = "NODE_LEFT")]
	NodeLeft,
	[EnumMember(Value = "NEW_INDEX_RESTORED")]
	NewIndexRestored,
	[EnumMember(Value = "MANUAL_ALLOCATION")]
	ManualAllocation,
	[EnumMember(Value = "INDEX_REOPENED")]
	IndexReopened,
	[EnumMember(Value = "INDEX_CREATED")]
	IndexCreated,
	[EnumMember(Value = "FORCED_EMPTY_PRIMARY")]
	ForcedEmptyPrimary,
	[EnumMember(Value = "EXISTING_INDEX_RESTORED")]
	ExistingIndexRestored,
	[EnumMember(Value = "DANGLING_INDEX_IMPORTED")]
	DanglingIndexImported,
	[EnumMember(Value = "CLUSTER_RECOVERED")]
	ClusterRecovered,
	[EnumMember(Value = "ALLOCATION_FAILED")]
	AllocationFailed
}

internal sealed partial class UnassignedInformationReasonConverter : System.Text.Json.Serialization.JsonConverter<UnassignedInformationReason>
{
	private static readonly System.Text.Json.JsonEncodedText MemberRerouteCancelled = System.Text.Json.JsonEncodedText.Encode("REROUTE_CANCELLED");
	private static readonly System.Text.Json.JsonEncodedText MemberReplicaAdded = System.Text.Json.JsonEncodedText.Encode("REPLICA_ADDED");
	private static readonly System.Text.Json.JsonEncodedText MemberReinitialized = System.Text.Json.JsonEncodedText.Encode("REINITIALIZED");
	private static readonly System.Text.Json.JsonEncodedText MemberReallocatedReplica = System.Text.Json.JsonEncodedText.Encode("REALLOCATED_REPLICA");
	private static readonly System.Text.Json.JsonEncodedText MemberPrimaryFailed = System.Text.Json.JsonEncodedText.Encode("PRIMARY_FAILED");
	private static readonly System.Text.Json.JsonEncodedText MemberNodeLeft = System.Text.Json.JsonEncodedText.Encode("NODE_LEFT");
	private static readonly System.Text.Json.JsonEncodedText MemberNewIndexRestored = System.Text.Json.JsonEncodedText.Encode("NEW_INDEX_RESTORED");
	private static readonly System.Text.Json.JsonEncodedText MemberManualAllocation = System.Text.Json.JsonEncodedText.Encode("MANUAL_ALLOCATION");
	private static readonly System.Text.Json.JsonEncodedText MemberIndexReopened = System.Text.Json.JsonEncodedText.Encode("INDEX_REOPENED");
	private static readonly System.Text.Json.JsonEncodedText MemberIndexCreated = System.Text.Json.JsonEncodedText.Encode("INDEX_CREATED");
	private static readonly System.Text.Json.JsonEncodedText MemberForcedEmptyPrimary = System.Text.Json.JsonEncodedText.Encode("FORCED_EMPTY_PRIMARY");
	private static readonly System.Text.Json.JsonEncodedText MemberExistingIndexRestored = System.Text.Json.JsonEncodedText.Encode("EXISTING_INDEX_RESTORED");
	private static readonly System.Text.Json.JsonEncodedText MemberDanglingIndexImported = System.Text.Json.JsonEncodedText.Encode("DANGLING_INDEX_IMPORTED");
	private static readonly System.Text.Json.JsonEncodedText MemberClusterRecovered = System.Text.Json.JsonEncodedText.Encode("CLUSTER_RECOVERED");
	private static readonly System.Text.Json.JsonEncodedText MemberAllocationFailed = System.Text.Json.JsonEncodedText.Encode("ALLOCATION_FAILED");

	public override UnassignedInformationReason Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.String);
		if (reader.ValueTextEquals(MemberRerouteCancelled))
		{
			return UnassignedInformationReason.RerouteCancelled;
		}

		if (reader.ValueTextEquals(MemberReplicaAdded))
		{
			return UnassignedInformationReason.ReplicaAdded;
		}

		if (reader.ValueTextEquals(MemberReinitialized))
		{
			return UnassignedInformationReason.Reinitialized;
		}

		if (reader.ValueTextEquals(MemberReallocatedReplica))
		{
			return UnassignedInformationReason.ReallocatedReplica;
		}

		if (reader.ValueTextEquals(MemberPrimaryFailed))
		{
			return UnassignedInformationReason.PrimaryFailed;
		}

		if (reader.ValueTextEquals(MemberNodeLeft))
		{
			return UnassignedInformationReason.NodeLeft;
		}

		if (reader.ValueTextEquals(MemberNewIndexRestored))
		{
			return UnassignedInformationReason.NewIndexRestored;
		}

		if (reader.ValueTextEquals(MemberManualAllocation))
		{
			return UnassignedInformationReason.ManualAllocation;
		}

		if (reader.ValueTextEquals(MemberIndexReopened))
		{
			return UnassignedInformationReason.IndexReopened;
		}

		if (reader.ValueTextEquals(MemberIndexCreated))
		{
			return UnassignedInformationReason.IndexCreated;
		}

		if (reader.ValueTextEquals(MemberForcedEmptyPrimary))
		{
			return UnassignedInformationReason.ForcedEmptyPrimary;
		}

		if (reader.ValueTextEquals(MemberExistingIndexRestored))
		{
			return UnassignedInformationReason.ExistingIndexRestored;
		}

		if (reader.ValueTextEquals(MemberDanglingIndexImported))
		{
			return UnassignedInformationReason.DanglingIndexImported;
		}

		if (reader.ValueTextEquals(MemberClusterRecovered))
		{
			return UnassignedInformationReason.ClusterRecovered;
		}

		if (reader.ValueTextEquals(MemberAllocationFailed))
		{
			return UnassignedInformationReason.AllocationFailed;
		}

		var value = reader.GetString()!;
		if (string.Equals(value, MemberRerouteCancelled.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return UnassignedInformationReason.RerouteCancelled;
		}

		if (string.Equals(value, MemberReplicaAdded.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return UnassignedInformationReason.ReplicaAdded;
		}

		if (string.Equals(value, MemberReinitialized.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return UnassignedInformationReason.Reinitialized;
		}

		if (string.Equals(value, MemberReallocatedReplica.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return UnassignedInformationReason.ReallocatedReplica;
		}

		if (string.Equals(value, MemberPrimaryFailed.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return UnassignedInformationReason.PrimaryFailed;
		}

		if (string.Equals(value, MemberNodeLeft.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return UnassignedInformationReason.NodeLeft;
		}

		if (string.Equals(value, MemberNewIndexRestored.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return UnassignedInformationReason.NewIndexRestored;
		}

		if (string.Equals(value, MemberManualAllocation.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return UnassignedInformationReason.ManualAllocation;
		}

		if (string.Equals(value, MemberIndexReopened.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return UnassignedInformationReason.IndexReopened;
		}

		if (string.Equals(value, MemberIndexCreated.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return UnassignedInformationReason.IndexCreated;
		}

		if (string.Equals(value, MemberForcedEmptyPrimary.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return UnassignedInformationReason.ForcedEmptyPrimary;
		}

		if (string.Equals(value, MemberExistingIndexRestored.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return UnassignedInformationReason.ExistingIndexRestored;
		}

		if (string.Equals(value, MemberDanglingIndexImported.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return UnassignedInformationReason.DanglingIndexImported;
		}

		if (string.Equals(value, MemberClusterRecovered.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return UnassignedInformationReason.ClusterRecovered;
		}

		if (string.Equals(value, MemberAllocationFailed.Value, System.StringComparison.OrdinalIgnoreCase))
		{
			return UnassignedInformationReason.AllocationFailed;
		}

		throw new System.Text.Json.JsonException($"Unknown member '{value}' for enum '{nameof(UnassignedInformationReason)}'.");
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, UnassignedInformationReason value, System.Text.Json.JsonSerializerOptions options)
	{
		switch (value)
		{
			case UnassignedInformationReason.RerouteCancelled:
				writer.WriteStringValue(MemberRerouteCancelled);
				break;
			case UnassignedInformationReason.ReplicaAdded:
				writer.WriteStringValue(MemberReplicaAdded);
				break;
			case UnassignedInformationReason.Reinitialized:
				writer.WriteStringValue(MemberReinitialized);
				break;
			case UnassignedInformationReason.ReallocatedReplica:
				writer.WriteStringValue(MemberReallocatedReplica);
				break;
			case UnassignedInformationReason.PrimaryFailed:
				writer.WriteStringValue(MemberPrimaryFailed);
				break;
			case UnassignedInformationReason.NodeLeft:
				writer.WriteStringValue(MemberNodeLeft);
				break;
			case UnassignedInformationReason.NewIndexRestored:
				writer.WriteStringValue(MemberNewIndexRestored);
				break;
			case UnassignedInformationReason.ManualAllocation:
				writer.WriteStringValue(MemberManualAllocation);
				break;
			case UnassignedInformationReason.IndexReopened:
				writer.WriteStringValue(MemberIndexReopened);
				break;
			case UnassignedInformationReason.IndexCreated:
				writer.WriteStringValue(MemberIndexCreated);
				break;
			case UnassignedInformationReason.ForcedEmptyPrimary:
				writer.WriteStringValue(MemberForcedEmptyPrimary);
				break;
			case UnassignedInformationReason.ExistingIndexRestored:
				writer.WriteStringValue(MemberExistingIndexRestored);
				break;
			case UnassignedInformationReason.DanglingIndexImported:
				writer.WriteStringValue(MemberDanglingIndexImported);
				break;
			case UnassignedInformationReason.ClusterRecovered:
				writer.WriteStringValue(MemberClusterRecovered);
				break;
			case UnassignedInformationReason.AllocationFailed:
				writer.WriteStringValue(MemberAllocationFailed);
				break;
			default:
				throw new System.Text.Json.JsonException($"Invalid value '{value}' for enum '{nameof(UnassignedInformationReason)}'.");
		}
	}
}