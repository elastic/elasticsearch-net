// Licensed to Elasticsearch B.V under one or more agreements.
// Elasticsearch B.V licenses this file to you under the Apache 2.0 License.
// See the LICENSE file in the project root for more information.
//
// ███╗   ██╗ ██████╗ ████████╗██╗ ██████╗███████╗
// ████╗  ██║██╔═══██╗╚══██╔══╝██║██╔════╝██╔════╝
// ██╔██╗ ██║██║   ██║   ██║   ██║██║     █████╗
// ██║╚██╗██║██║   ██║   ██║   ██║██║     ██╔══╝
// ██║ ╚████║╚██████╔╝   ██║   ██║╚██████╗███████╗
// ╚═╝  ╚═══╝ ╚═════╝    ╚═╝   ╚═╝ ╚═════╝╚══════╝
// ------------------------------------------------
//
// This file is automatically generated.
// Please do not edit these files manually.
//
// ------------------------------------------------

#nullable restore

using Elastic.Clients.Elasticsearch.Fluent;
using Elastic.Clients.Elasticsearch.Serialization;
using System;
using System.Collections.Generic;
using System.Linq.Expressions;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace Elastic.Clients.Elasticsearch.Core.Search;

public sealed partial class Highlight
{
	/// <summary>
	/// <para>A string that contains each boundary character.</para>
	/// </summary>
	[JsonInclude, JsonPropertyName("boundary_chars")]
	public string? BoundaryChars { get; set; }

	/// <summary>
	/// <para>How far to scan for boundary characters.</para>
	/// </summary>
	[JsonInclude, JsonPropertyName("boundary_max_scan")]
	public int? BoundaryMaxScan { get; set; }

	/// <summary>
	/// <para>Specifies how to break the highlighted fragments: chars, sentence, or word.<br/>Only valid for the unified and fvh highlighters.<br/>Defaults to `sentence` for the `unified` highlighter. Defaults to `chars` for the `fvh` highlighter.</para>
	/// </summary>
	[JsonInclude, JsonPropertyName("boundary_scanner")]
	public Elastic.Clients.Elasticsearch.Core.Search.BoundaryScanner? BoundaryScanner { get; set; }

	/// <summary>
	/// <para>Controls which locale is used to search for sentence and word boundaries.<br/>This parameter takes a form of a language tag, for example: `"en-US"`, `"fr-FR"`, `"ja-JP"`.</para>
	/// </summary>
	[JsonInclude, JsonPropertyName("boundary_scanner_locale")]
	public string? BoundaryScannerLocale { get; set; }
	[JsonInclude, JsonPropertyName("encoder")]
	public Elastic.Clients.Elasticsearch.Core.Search.HighlighterEncoder? Encoder { get; set; }
	[JsonInclude, JsonPropertyName("fields")]
	public IDictionary<Elastic.Clients.Elasticsearch.Field, Elastic.Clients.Elasticsearch.Core.Search.HighlightField> Fields { get; set; }

	/// <summary>
	/// <para>Specifies how text should be broken up in highlight snippets: `simple` or `span`.<br/>Only valid for the `plain` highlighter.</para>
	/// </summary>
	[JsonInclude, JsonPropertyName("fragmenter")]
	public Elastic.Clients.Elasticsearch.Core.Search.HighlighterFragmenter? Fragmenter { get; set; }

	/// <summary>
	/// <para>The size of the highlighted fragment in characters.</para>
	/// </summary>
	[JsonInclude, JsonPropertyName("fragment_size")]
	public int? FragmentSize { get; set; }
	[JsonInclude, JsonPropertyName("highlight_filter")]
	public bool? HighlightFilter { get; set; }

	/// <summary>
	/// <para>Highlight matches for a query other than the search query.<br/>This is especially useful if you use a rescore query because those are not taken into account by highlighting by default.</para>
	/// </summary>
	[JsonInclude, JsonPropertyName("highlight_query")]
	public Elastic.Clients.Elasticsearch.QueryDsl.Query? HighlightQuery { get; set; }

	/// <summary>
	/// <para>If set to a non-negative value, highlighting stops at this defined maximum limit.<br/>The rest of the text is not processed, thus not highlighted and no error is returned<br/>The `max_analyzed_offset` query setting does not override the `index.highlight.max_analyzed_offset` setting, which prevails when it’s set to lower value than the query setting.</para>
	/// </summary>
	[JsonInclude, JsonPropertyName("max_analyzed_offset")]
	public int? MaxAnalyzedOffset { get; set; }
	[JsonInclude, JsonPropertyName("max_fragment_length")]
	public int? MaxFragmentLength { get; set; }

	/// <summary>
	/// <para>The amount of text you want to return from the beginning of the field if there are no matching fragments to highlight.</para>
	/// </summary>
	[JsonInclude, JsonPropertyName("no_match_size")]
	public int? NoMatchSize { get; set; }

	/// <summary>
	/// <para>The maximum number of fragments to return.<br/>If the number of fragments is set to `0`, no fragments are returned.<br/>Instead, the entire field contents are highlighted and returned.<br/>This can be handy when you need to highlight short texts such as a title or address, but fragmentation is not required.<br/>If `number_of_fragments` is `0`, `fragment_size` is ignored.</para>
	/// </summary>
	[JsonInclude, JsonPropertyName("number_of_fragments")]
	public int? NumberOfFragments { get; set; }
	[JsonInclude, JsonPropertyName("options")]
	public IDictionary<string, object>? Options { get; set; }

	/// <summary>
	/// <para>Sorts highlighted fragments by score when set to `score`.<br/>By default, fragments will be output in the order they appear in the field (order: `none`).<br/>Setting this option to `score` will output the most relevant fragments first.<br/>Each highlighter applies its own logic to compute relevancy scores.</para>
	/// </summary>
	[JsonInclude, JsonPropertyName("order")]
	public Elastic.Clients.Elasticsearch.Core.Search.HighlighterOrder? Order { get; set; }

	/// <summary>
	/// <para>Controls the number of matching phrases in a document that are considered.<br/>Prevents the `fvh` highlighter from analyzing too many phrases and consuming too much memory.<br/>When using `matched_fields`, `phrase_limit` phrases per matched field are considered. Raising the limit increases query time and consumes more memory.<br/>Only supported by the `fvh` highlighter.</para>
	/// </summary>
	[JsonInclude, JsonPropertyName("phrase_limit")]
	public int? PhraseLimit { get; set; }

	/// <summary>
	/// <para>Use in conjunction with `pre_tags` to define the HTML tags to use for the highlighted text.<br/>By default, highlighted text is wrapped in `<em>` and `</em>` tags.</para>
	/// </summary>
	[JsonInclude, JsonPropertyName("post_tags")]
	public ICollection<string>? PostTags { get; set; }

	/// <summary>
	/// <para>Use in conjunction with `post_tags` to define the HTML tags to use for the highlighted text.<br/>By default, highlighted text is wrapped in `<em>` and `</em>` tags.</para>
	/// </summary>
	[JsonInclude, JsonPropertyName("pre_tags")]
	public ICollection<string>? PreTags { get; set; }

	/// <summary>
	/// <para>By default, only fields that contains a query match are highlighted.<br/>Set to `false` to highlight all fields.</para>
	/// </summary>
	[JsonInclude, JsonPropertyName("require_field_match")]
	public bool? RequireFieldMatch { get; set; }

	/// <summary>
	/// <para>Set to `styled` to use the built-in tag schema.</para>
	/// </summary>
	[JsonInclude, JsonPropertyName("tags_schema")]
	public Elastic.Clients.Elasticsearch.Core.Search.HighlighterTagsSchema? TagsSchema { get; set; }
	[JsonInclude, JsonPropertyName("type")]
	public Elastic.Clients.Elasticsearch.Core.Search.HighlighterType? Type { get; set; }
}

public sealed partial class HighlightDescriptor<TDocument> : SerializableDescriptor<HighlightDescriptor<TDocument>>
{
	internal HighlightDescriptor(Action<HighlightDescriptor<TDocument>> configure) => configure.Invoke(this);

	public HighlightDescriptor() : base()
	{
	}

	private string? BoundaryCharsValue { get; set; }
	private int? BoundaryMaxScanValue { get; set; }
	private Elastic.Clients.Elasticsearch.Core.Search.BoundaryScanner? BoundaryScannerValue { get; set; }
	private string? BoundaryScannerLocaleValue { get; set; }
	private Elastic.Clients.Elasticsearch.Core.Search.HighlighterEncoder? EncoderValue { get; set; }
	private IDictionary<Elastic.Clients.Elasticsearch.Field, Elastic.Clients.Elasticsearch.Core.Search.HighlightFieldDescriptor<TDocument>> FieldsValue { get; set; }
	private Elastic.Clients.Elasticsearch.Core.Search.HighlighterFragmenter? FragmenterValue { get; set; }
	private int? FragmentSizeValue { get; set; }
	private bool? HighlightFilterValue { get; set; }
	private Elastic.Clients.Elasticsearch.QueryDsl.Query? HighlightQueryValue { get; set; }
	private Elastic.Clients.Elasticsearch.QueryDsl.QueryDescriptor<TDocument> HighlightQueryDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.QueryDsl.QueryDescriptor<TDocument>> HighlightQueryDescriptorAction { get; set; }
	private int? MaxAnalyzedOffsetValue { get; set; }
	private int? MaxFragmentLengthValue { get; set; }
	private int? NoMatchSizeValue { get; set; }
	private int? NumberOfFragmentsValue { get; set; }
	private IDictionary<string, object>? OptionsValue { get; set; }
	private Elastic.Clients.Elasticsearch.Core.Search.HighlighterOrder? OrderValue { get; set; }
	private int? PhraseLimitValue { get; set; }
	private ICollection<string>? PostTagsValue { get; set; }
	private ICollection<string>? PreTagsValue { get; set; }
	private bool? RequireFieldMatchValue { get; set; }
	private Elastic.Clients.Elasticsearch.Core.Search.HighlighterTagsSchema? TagsSchemaValue { get; set; }
	private Elastic.Clients.Elasticsearch.Core.Search.HighlighterType? TypeValue { get; set; }

	/// <summary>
	/// <para>A string that contains each boundary character.</para>
	/// </summary>
	public HighlightDescriptor<TDocument> BoundaryChars(string? boundaryChars)
	{
		BoundaryCharsValue = boundaryChars;
		return Self;
	}

	/// <summary>
	/// <para>How far to scan for boundary characters.</para>
	/// </summary>
	public HighlightDescriptor<TDocument> BoundaryMaxScan(int? boundaryMaxScan)
	{
		BoundaryMaxScanValue = boundaryMaxScan;
		return Self;
	}

	/// <summary>
	/// <para>Specifies how to break the highlighted fragments: chars, sentence, or word.<br/>Only valid for the unified and fvh highlighters.<br/>Defaults to `sentence` for the `unified` highlighter. Defaults to `chars` for the `fvh` highlighter.</para>
	/// </summary>
	public HighlightDescriptor<TDocument> BoundaryScanner(Elastic.Clients.Elasticsearch.Core.Search.BoundaryScanner? boundaryScanner)
	{
		BoundaryScannerValue = boundaryScanner;
		return Self;
	}

	/// <summary>
	/// <para>Controls which locale is used to search for sentence and word boundaries.<br/>This parameter takes a form of a language tag, for example: `"en-US"`, `"fr-FR"`, `"ja-JP"`.</para>
	/// </summary>
	public HighlightDescriptor<TDocument> BoundaryScannerLocale(string? boundaryScannerLocale)
	{
		BoundaryScannerLocaleValue = boundaryScannerLocale;
		return Self;
	}

	public HighlightDescriptor<TDocument> Encoder(Elastic.Clients.Elasticsearch.Core.Search.HighlighterEncoder? encoder)
	{
		EncoderValue = encoder;
		return Self;
	}

	public HighlightDescriptor<TDocument> Fields(Func<FluentDescriptorDictionary<Elastic.Clients.Elasticsearch.Field, Elastic.Clients.Elasticsearch.Core.Search.HighlightFieldDescriptor<TDocument>>, FluentDescriptorDictionary<Elastic.Clients.Elasticsearch.Field, Elastic.Clients.Elasticsearch.Core.Search.HighlightFieldDescriptor<TDocument>>> selector)
	{
		FieldsValue = selector?.Invoke(new FluentDescriptorDictionary<Elastic.Clients.Elasticsearch.Field, Elastic.Clients.Elasticsearch.Core.Search.HighlightFieldDescriptor<TDocument>>());
		return Self;
	}

	/// <summary>
	/// <para>Specifies how text should be broken up in highlight snippets: `simple` or `span`.<br/>Only valid for the `plain` highlighter.</para>
	/// </summary>
	public HighlightDescriptor<TDocument> Fragmenter(Elastic.Clients.Elasticsearch.Core.Search.HighlighterFragmenter? fragmenter)
	{
		FragmenterValue = fragmenter;
		return Self;
	}

	/// <summary>
	/// <para>The size of the highlighted fragment in characters.</para>
	/// </summary>
	public HighlightDescriptor<TDocument> FragmentSize(int? fragmentSize)
	{
		FragmentSizeValue = fragmentSize;
		return Self;
	}

	public HighlightDescriptor<TDocument> HighlightFilter(bool? highlightFilter = true)
	{
		HighlightFilterValue = highlightFilter;
		return Self;
	}

	/// <summary>
	/// <para>Highlight matches for a query other than the search query.<br/>This is especially useful if you use a rescore query because those are not taken into account by highlighting by default.</para>
	/// </summary>
	public HighlightDescriptor<TDocument> HighlightQuery(Elastic.Clients.Elasticsearch.QueryDsl.Query? highlightQuery)
	{
		HighlightQueryDescriptor = null;
		HighlightQueryDescriptorAction = null;
		HighlightQueryValue = highlightQuery;
		return Self;
	}

	public HighlightDescriptor<TDocument> HighlightQuery(Elastic.Clients.Elasticsearch.QueryDsl.QueryDescriptor<TDocument> descriptor)
	{
		HighlightQueryValue = null;
		HighlightQueryDescriptorAction = null;
		HighlightQueryDescriptor = descriptor;
		return Self;
	}

	public HighlightDescriptor<TDocument> HighlightQuery(Action<Elastic.Clients.Elasticsearch.QueryDsl.QueryDescriptor<TDocument>> configure)
	{
		HighlightQueryValue = null;
		HighlightQueryDescriptor = null;
		HighlightQueryDescriptorAction = configure;
		return Self;
	}

	/// <summary>
	/// <para>If set to a non-negative value, highlighting stops at this defined maximum limit.<br/>The rest of the text is not processed, thus not highlighted and no error is returned<br/>The `max_analyzed_offset` query setting does not override the `index.highlight.max_analyzed_offset` setting, which prevails when it’s set to lower value than the query setting.</para>
	/// </summary>
	public HighlightDescriptor<TDocument> MaxAnalyzedOffset(int? maxAnalyzedOffset)
	{
		MaxAnalyzedOffsetValue = maxAnalyzedOffset;
		return Self;
	}

	public HighlightDescriptor<TDocument> MaxFragmentLength(int? maxFragmentLength)
	{
		MaxFragmentLengthValue = maxFragmentLength;
		return Self;
	}

	/// <summary>
	/// <para>The amount of text you want to return from the beginning of the field if there are no matching fragments to highlight.</para>
	/// </summary>
	public HighlightDescriptor<TDocument> NoMatchSize(int? noMatchSize)
	{
		NoMatchSizeValue = noMatchSize;
		return Self;
	}

	/// <summary>
	/// <para>The maximum number of fragments to return.<br/>If the number of fragments is set to `0`, no fragments are returned.<br/>Instead, the entire field contents are highlighted and returned.<br/>This can be handy when you need to highlight short texts such as a title or address, but fragmentation is not required.<br/>If `number_of_fragments` is `0`, `fragment_size` is ignored.</para>
	/// </summary>
	public HighlightDescriptor<TDocument> NumberOfFragments(int? numberOfFragments)
	{
		NumberOfFragmentsValue = numberOfFragments;
		return Self;
	}

	public HighlightDescriptor<TDocument> Options(Func<FluentDictionary<string, object>, FluentDictionary<string, object>> selector)
	{
		OptionsValue = selector?.Invoke(new FluentDictionary<string, object>());
		return Self;
	}

	/// <summary>
	/// <para>Sorts highlighted fragments by score when set to `score`.<br/>By default, fragments will be output in the order they appear in the field (order: `none`).<br/>Setting this option to `score` will output the most relevant fragments first.<br/>Each highlighter applies its own logic to compute relevancy scores.</para>
	/// </summary>
	public HighlightDescriptor<TDocument> Order(Elastic.Clients.Elasticsearch.Core.Search.HighlighterOrder? order)
	{
		OrderValue = order;
		return Self;
	}

	/// <summary>
	/// <para>Controls the number of matching phrases in a document that are considered.<br/>Prevents the `fvh` highlighter from analyzing too many phrases and consuming too much memory.<br/>When using `matched_fields`, `phrase_limit` phrases per matched field are considered. Raising the limit increases query time and consumes more memory.<br/>Only supported by the `fvh` highlighter.</para>
	/// </summary>
	public HighlightDescriptor<TDocument> PhraseLimit(int? phraseLimit)
	{
		PhraseLimitValue = phraseLimit;
		return Self;
	}

	/// <summary>
	/// <para>Use in conjunction with `pre_tags` to define the HTML tags to use for the highlighted text.<br/>By default, highlighted text is wrapped in `<em>` and `</em>` tags.</para>
	/// </summary>
	public HighlightDescriptor<TDocument> PostTags(ICollection<string>? postTags)
	{
		PostTagsValue = postTags;
		return Self;
	}

	/// <summary>
	/// <para>Use in conjunction with `post_tags` to define the HTML tags to use for the highlighted text.<br/>By default, highlighted text is wrapped in `<em>` and `</em>` tags.</para>
	/// </summary>
	public HighlightDescriptor<TDocument> PreTags(ICollection<string>? preTags)
	{
		PreTagsValue = preTags;
		return Self;
	}

	/// <summary>
	/// <para>By default, only fields that contains a query match are highlighted.<br/>Set to `false` to highlight all fields.</para>
	/// </summary>
	public HighlightDescriptor<TDocument> RequireFieldMatch(bool? requireFieldMatch = true)
	{
		RequireFieldMatchValue = requireFieldMatch;
		return Self;
	}

	/// <summary>
	/// <para>Set to `styled` to use the built-in tag schema.</para>
	/// </summary>
	public HighlightDescriptor<TDocument> TagsSchema(Elastic.Clients.Elasticsearch.Core.Search.HighlighterTagsSchema? tagsSchema)
	{
		TagsSchemaValue = tagsSchema;
		return Self;
	}

	public HighlightDescriptor<TDocument> Type(Elastic.Clients.Elasticsearch.Core.Search.HighlighterType? type)
	{
		TypeValue = type;
		return Self;
	}

	protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
	{
		writer.WriteStartObject();
		if (!string.IsNullOrEmpty(BoundaryCharsValue))
		{
			writer.WritePropertyName("boundary_chars");
			writer.WriteStringValue(BoundaryCharsValue);
		}

		if (BoundaryMaxScanValue.HasValue)
		{
			writer.WritePropertyName("boundary_max_scan");
			writer.WriteNumberValue(BoundaryMaxScanValue.Value);
		}

		if (BoundaryScannerValue is not null)
		{
			writer.WritePropertyName("boundary_scanner");
			JsonSerializer.Serialize(writer, BoundaryScannerValue, options);
		}

		if (!string.IsNullOrEmpty(BoundaryScannerLocaleValue))
		{
			writer.WritePropertyName("boundary_scanner_locale");
			writer.WriteStringValue(BoundaryScannerLocaleValue);
		}

		if (EncoderValue is not null)
		{
			writer.WritePropertyName("encoder");
			JsonSerializer.Serialize(writer, EncoderValue, options);
		}

		writer.WritePropertyName("fields");
		JsonSerializer.Serialize(writer, FieldsValue, options);
		if (FragmenterValue is not null)
		{
			writer.WritePropertyName("fragmenter");
			JsonSerializer.Serialize(writer, FragmenterValue, options);
		}

		if (FragmentSizeValue.HasValue)
		{
			writer.WritePropertyName("fragment_size");
			writer.WriteNumberValue(FragmentSizeValue.Value);
		}

		if (HighlightFilterValue.HasValue)
		{
			writer.WritePropertyName("highlight_filter");
			writer.WriteBooleanValue(HighlightFilterValue.Value);
		}

		if (HighlightQueryDescriptor is not null)
		{
			writer.WritePropertyName("highlight_query");
			JsonSerializer.Serialize(writer, HighlightQueryDescriptor, options);
		}
		else if (HighlightQueryDescriptorAction is not null)
		{
			writer.WritePropertyName("highlight_query");
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.QueryDsl.QueryDescriptor<TDocument>(HighlightQueryDescriptorAction), options);
		}
		else if (HighlightQueryValue is not null)
		{
			writer.WritePropertyName("highlight_query");
			JsonSerializer.Serialize(writer, HighlightQueryValue, options);
		}

		if (MaxAnalyzedOffsetValue.HasValue)
		{
			writer.WritePropertyName("max_analyzed_offset");
			writer.WriteNumberValue(MaxAnalyzedOffsetValue.Value);
		}

		if (MaxFragmentLengthValue.HasValue)
		{
			writer.WritePropertyName("max_fragment_length");
			writer.WriteNumberValue(MaxFragmentLengthValue.Value);
		}

		if (NoMatchSizeValue.HasValue)
		{
			writer.WritePropertyName("no_match_size");
			writer.WriteNumberValue(NoMatchSizeValue.Value);
		}

		if (NumberOfFragmentsValue.HasValue)
		{
			writer.WritePropertyName("number_of_fragments");
			writer.WriteNumberValue(NumberOfFragmentsValue.Value);
		}

		if (OptionsValue is not null)
		{
			writer.WritePropertyName("options");
			JsonSerializer.Serialize(writer, OptionsValue, options);
		}

		if (OrderValue is not null)
		{
			writer.WritePropertyName("order");
			JsonSerializer.Serialize(writer, OrderValue, options);
		}

		if (PhraseLimitValue.HasValue)
		{
			writer.WritePropertyName("phrase_limit");
			writer.WriteNumberValue(PhraseLimitValue.Value);
		}

		if (PostTagsValue is not null)
		{
			writer.WritePropertyName("post_tags");
			JsonSerializer.Serialize(writer, PostTagsValue, options);
		}

		if (PreTagsValue is not null)
		{
			writer.WritePropertyName("pre_tags");
			JsonSerializer.Serialize(writer, PreTagsValue, options);
		}

		if (RequireFieldMatchValue.HasValue)
		{
			writer.WritePropertyName("require_field_match");
			writer.WriteBooleanValue(RequireFieldMatchValue.Value);
		}

		if (TagsSchemaValue is not null)
		{
			writer.WritePropertyName("tags_schema");
			JsonSerializer.Serialize(writer, TagsSchemaValue, options);
		}

		if (TypeValue is not null)
		{
			writer.WritePropertyName("type");
			JsonSerializer.Serialize(writer, TypeValue, options);
		}

		writer.WriteEndObject();
	}
}

public sealed partial class HighlightDescriptor : SerializableDescriptor<HighlightDescriptor>
{
	internal HighlightDescriptor(Action<HighlightDescriptor> configure) => configure.Invoke(this);

	public HighlightDescriptor() : base()
	{
	}

	private string? BoundaryCharsValue { get; set; }
	private int? BoundaryMaxScanValue { get; set; }
	private Elastic.Clients.Elasticsearch.Core.Search.BoundaryScanner? BoundaryScannerValue { get; set; }
	private string? BoundaryScannerLocaleValue { get; set; }
	private Elastic.Clients.Elasticsearch.Core.Search.HighlighterEncoder? EncoderValue { get; set; }
	private IDictionary<Elastic.Clients.Elasticsearch.Field, Elastic.Clients.Elasticsearch.Core.Search.HighlightFieldDescriptor> FieldsValue { get; set; }
	private Elastic.Clients.Elasticsearch.Core.Search.HighlighterFragmenter? FragmenterValue { get; set; }
	private int? FragmentSizeValue { get; set; }
	private bool? HighlightFilterValue { get; set; }
	private Elastic.Clients.Elasticsearch.QueryDsl.Query? HighlightQueryValue { get; set; }
	private Elastic.Clients.Elasticsearch.QueryDsl.QueryDescriptor HighlightQueryDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.QueryDsl.QueryDescriptor> HighlightQueryDescriptorAction { get; set; }
	private int? MaxAnalyzedOffsetValue { get; set; }
	private int? MaxFragmentLengthValue { get; set; }
	private int? NoMatchSizeValue { get; set; }
	private int? NumberOfFragmentsValue { get; set; }
	private IDictionary<string, object>? OptionsValue { get; set; }
	private Elastic.Clients.Elasticsearch.Core.Search.HighlighterOrder? OrderValue { get; set; }
	private int? PhraseLimitValue { get; set; }
	private ICollection<string>? PostTagsValue { get; set; }
	private ICollection<string>? PreTagsValue { get; set; }
	private bool? RequireFieldMatchValue { get; set; }
	private Elastic.Clients.Elasticsearch.Core.Search.HighlighterTagsSchema? TagsSchemaValue { get; set; }
	private Elastic.Clients.Elasticsearch.Core.Search.HighlighterType? TypeValue { get; set; }

	/// <summary>
	/// <para>A string that contains each boundary character.</para>
	/// </summary>
	public HighlightDescriptor BoundaryChars(string? boundaryChars)
	{
		BoundaryCharsValue = boundaryChars;
		return Self;
	}

	/// <summary>
	/// <para>How far to scan for boundary characters.</para>
	/// </summary>
	public HighlightDescriptor BoundaryMaxScan(int? boundaryMaxScan)
	{
		BoundaryMaxScanValue = boundaryMaxScan;
		return Self;
	}

	/// <summary>
	/// <para>Specifies how to break the highlighted fragments: chars, sentence, or word.<br/>Only valid for the unified and fvh highlighters.<br/>Defaults to `sentence` for the `unified` highlighter. Defaults to `chars` for the `fvh` highlighter.</para>
	/// </summary>
	public HighlightDescriptor BoundaryScanner(Elastic.Clients.Elasticsearch.Core.Search.BoundaryScanner? boundaryScanner)
	{
		BoundaryScannerValue = boundaryScanner;
		return Self;
	}

	/// <summary>
	/// <para>Controls which locale is used to search for sentence and word boundaries.<br/>This parameter takes a form of a language tag, for example: `"en-US"`, `"fr-FR"`, `"ja-JP"`.</para>
	/// </summary>
	public HighlightDescriptor BoundaryScannerLocale(string? boundaryScannerLocale)
	{
		BoundaryScannerLocaleValue = boundaryScannerLocale;
		return Self;
	}

	public HighlightDescriptor Encoder(Elastic.Clients.Elasticsearch.Core.Search.HighlighterEncoder? encoder)
	{
		EncoderValue = encoder;
		return Self;
	}

	public HighlightDescriptor Fields(Func<FluentDescriptorDictionary<Elastic.Clients.Elasticsearch.Field, Elastic.Clients.Elasticsearch.Core.Search.HighlightFieldDescriptor>, FluentDescriptorDictionary<Elastic.Clients.Elasticsearch.Field, Elastic.Clients.Elasticsearch.Core.Search.HighlightFieldDescriptor>> selector)
	{
		FieldsValue = selector?.Invoke(new FluentDescriptorDictionary<Elastic.Clients.Elasticsearch.Field, Elastic.Clients.Elasticsearch.Core.Search.HighlightFieldDescriptor>());
		return Self;
	}

	/// <summary>
	/// <para>Specifies how text should be broken up in highlight snippets: `simple` or `span`.<br/>Only valid for the `plain` highlighter.</para>
	/// </summary>
	public HighlightDescriptor Fragmenter(Elastic.Clients.Elasticsearch.Core.Search.HighlighterFragmenter? fragmenter)
	{
		FragmenterValue = fragmenter;
		return Self;
	}

	/// <summary>
	/// <para>The size of the highlighted fragment in characters.</para>
	/// </summary>
	public HighlightDescriptor FragmentSize(int? fragmentSize)
	{
		FragmentSizeValue = fragmentSize;
		return Self;
	}

	public HighlightDescriptor HighlightFilter(bool? highlightFilter = true)
	{
		HighlightFilterValue = highlightFilter;
		return Self;
	}

	/// <summary>
	/// <para>Highlight matches for a query other than the search query.<br/>This is especially useful if you use a rescore query because those are not taken into account by highlighting by default.</para>
	/// </summary>
	public HighlightDescriptor HighlightQuery(Elastic.Clients.Elasticsearch.QueryDsl.Query? highlightQuery)
	{
		HighlightQueryDescriptor = null;
		HighlightQueryDescriptorAction = null;
		HighlightQueryValue = highlightQuery;
		return Self;
	}

	public HighlightDescriptor HighlightQuery(Elastic.Clients.Elasticsearch.QueryDsl.QueryDescriptor descriptor)
	{
		HighlightQueryValue = null;
		HighlightQueryDescriptorAction = null;
		HighlightQueryDescriptor = descriptor;
		return Self;
	}

	public HighlightDescriptor HighlightQuery(Action<Elastic.Clients.Elasticsearch.QueryDsl.QueryDescriptor> configure)
	{
		HighlightQueryValue = null;
		HighlightQueryDescriptor = null;
		HighlightQueryDescriptorAction = configure;
		return Self;
	}

	/// <summary>
	/// <para>If set to a non-negative value, highlighting stops at this defined maximum limit.<br/>The rest of the text is not processed, thus not highlighted and no error is returned<br/>The `max_analyzed_offset` query setting does not override the `index.highlight.max_analyzed_offset` setting, which prevails when it’s set to lower value than the query setting.</para>
	/// </summary>
	public HighlightDescriptor MaxAnalyzedOffset(int? maxAnalyzedOffset)
	{
		MaxAnalyzedOffsetValue = maxAnalyzedOffset;
		return Self;
	}

	public HighlightDescriptor MaxFragmentLength(int? maxFragmentLength)
	{
		MaxFragmentLengthValue = maxFragmentLength;
		return Self;
	}

	/// <summary>
	/// <para>The amount of text you want to return from the beginning of the field if there are no matching fragments to highlight.</para>
	/// </summary>
	public HighlightDescriptor NoMatchSize(int? noMatchSize)
	{
		NoMatchSizeValue = noMatchSize;
		return Self;
	}

	/// <summary>
	/// <para>The maximum number of fragments to return.<br/>If the number of fragments is set to `0`, no fragments are returned.<br/>Instead, the entire field contents are highlighted and returned.<br/>This can be handy when you need to highlight short texts such as a title or address, but fragmentation is not required.<br/>If `number_of_fragments` is `0`, `fragment_size` is ignored.</para>
	/// </summary>
	public HighlightDescriptor NumberOfFragments(int? numberOfFragments)
	{
		NumberOfFragmentsValue = numberOfFragments;
		return Self;
	}

	public HighlightDescriptor Options(Func<FluentDictionary<string, object>, FluentDictionary<string, object>> selector)
	{
		OptionsValue = selector?.Invoke(new FluentDictionary<string, object>());
		return Self;
	}

	/// <summary>
	/// <para>Sorts highlighted fragments by score when set to `score`.<br/>By default, fragments will be output in the order they appear in the field (order: `none`).<br/>Setting this option to `score` will output the most relevant fragments first.<br/>Each highlighter applies its own logic to compute relevancy scores.</para>
	/// </summary>
	public HighlightDescriptor Order(Elastic.Clients.Elasticsearch.Core.Search.HighlighterOrder? order)
	{
		OrderValue = order;
		return Self;
	}

	/// <summary>
	/// <para>Controls the number of matching phrases in a document that are considered.<br/>Prevents the `fvh` highlighter from analyzing too many phrases and consuming too much memory.<br/>When using `matched_fields`, `phrase_limit` phrases per matched field are considered. Raising the limit increases query time and consumes more memory.<br/>Only supported by the `fvh` highlighter.</para>
	/// </summary>
	public HighlightDescriptor PhraseLimit(int? phraseLimit)
	{
		PhraseLimitValue = phraseLimit;
		return Self;
	}

	/// <summary>
	/// <para>Use in conjunction with `pre_tags` to define the HTML tags to use for the highlighted text.<br/>By default, highlighted text is wrapped in `<em>` and `</em>` tags.</para>
	/// </summary>
	public HighlightDescriptor PostTags(ICollection<string>? postTags)
	{
		PostTagsValue = postTags;
		return Self;
	}

	/// <summary>
	/// <para>Use in conjunction with `post_tags` to define the HTML tags to use for the highlighted text.<br/>By default, highlighted text is wrapped in `<em>` and `</em>` tags.</para>
	/// </summary>
	public HighlightDescriptor PreTags(ICollection<string>? preTags)
	{
		PreTagsValue = preTags;
		return Self;
	}

	/// <summary>
	/// <para>By default, only fields that contains a query match are highlighted.<br/>Set to `false` to highlight all fields.</para>
	/// </summary>
	public HighlightDescriptor RequireFieldMatch(bool? requireFieldMatch = true)
	{
		RequireFieldMatchValue = requireFieldMatch;
		return Self;
	}

	/// <summary>
	/// <para>Set to `styled` to use the built-in tag schema.</para>
	/// </summary>
	public HighlightDescriptor TagsSchema(Elastic.Clients.Elasticsearch.Core.Search.HighlighterTagsSchema? tagsSchema)
	{
		TagsSchemaValue = tagsSchema;
		return Self;
	}

	public HighlightDescriptor Type(Elastic.Clients.Elasticsearch.Core.Search.HighlighterType? type)
	{
		TypeValue = type;
		return Self;
	}

	protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
	{
		writer.WriteStartObject();
		if (!string.IsNullOrEmpty(BoundaryCharsValue))
		{
			writer.WritePropertyName("boundary_chars");
			writer.WriteStringValue(BoundaryCharsValue);
		}

		if (BoundaryMaxScanValue.HasValue)
		{
			writer.WritePropertyName("boundary_max_scan");
			writer.WriteNumberValue(BoundaryMaxScanValue.Value);
		}

		if (BoundaryScannerValue is not null)
		{
			writer.WritePropertyName("boundary_scanner");
			JsonSerializer.Serialize(writer, BoundaryScannerValue, options);
		}

		if (!string.IsNullOrEmpty(BoundaryScannerLocaleValue))
		{
			writer.WritePropertyName("boundary_scanner_locale");
			writer.WriteStringValue(BoundaryScannerLocaleValue);
		}

		if (EncoderValue is not null)
		{
			writer.WritePropertyName("encoder");
			JsonSerializer.Serialize(writer, EncoderValue, options);
		}

		writer.WritePropertyName("fields");
		JsonSerializer.Serialize(writer, FieldsValue, options);
		if (FragmenterValue is not null)
		{
			writer.WritePropertyName("fragmenter");
			JsonSerializer.Serialize(writer, FragmenterValue, options);
		}

		if (FragmentSizeValue.HasValue)
		{
			writer.WritePropertyName("fragment_size");
			writer.WriteNumberValue(FragmentSizeValue.Value);
		}

		if (HighlightFilterValue.HasValue)
		{
			writer.WritePropertyName("highlight_filter");
			writer.WriteBooleanValue(HighlightFilterValue.Value);
		}

		if (HighlightQueryDescriptor is not null)
		{
			writer.WritePropertyName("highlight_query");
			JsonSerializer.Serialize(writer, HighlightQueryDescriptor, options);
		}
		else if (HighlightQueryDescriptorAction is not null)
		{
			writer.WritePropertyName("highlight_query");
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.QueryDsl.QueryDescriptor(HighlightQueryDescriptorAction), options);
		}
		else if (HighlightQueryValue is not null)
		{
			writer.WritePropertyName("highlight_query");
			JsonSerializer.Serialize(writer, HighlightQueryValue, options);
		}

		if (MaxAnalyzedOffsetValue.HasValue)
		{
			writer.WritePropertyName("max_analyzed_offset");
			writer.WriteNumberValue(MaxAnalyzedOffsetValue.Value);
		}

		if (MaxFragmentLengthValue.HasValue)
		{
			writer.WritePropertyName("max_fragment_length");
			writer.WriteNumberValue(MaxFragmentLengthValue.Value);
		}

		if (NoMatchSizeValue.HasValue)
		{
			writer.WritePropertyName("no_match_size");
			writer.WriteNumberValue(NoMatchSizeValue.Value);
		}

		if (NumberOfFragmentsValue.HasValue)
		{
			writer.WritePropertyName("number_of_fragments");
			writer.WriteNumberValue(NumberOfFragmentsValue.Value);
		}

		if (OptionsValue is not null)
		{
			writer.WritePropertyName("options");
			JsonSerializer.Serialize(writer, OptionsValue, options);
		}

		if (OrderValue is not null)
		{
			writer.WritePropertyName("order");
			JsonSerializer.Serialize(writer, OrderValue, options);
		}

		if (PhraseLimitValue.HasValue)
		{
			writer.WritePropertyName("phrase_limit");
			writer.WriteNumberValue(PhraseLimitValue.Value);
		}

		if (PostTagsValue is not null)
		{
			writer.WritePropertyName("post_tags");
			JsonSerializer.Serialize(writer, PostTagsValue, options);
		}

		if (PreTagsValue is not null)
		{
			writer.WritePropertyName("pre_tags");
			JsonSerializer.Serialize(writer, PreTagsValue, options);
		}

		if (RequireFieldMatchValue.HasValue)
		{
			writer.WritePropertyName("require_field_match");
			writer.WriteBooleanValue(RequireFieldMatchValue.Value);
		}

		if (TagsSchemaValue is not null)
		{
			writer.WritePropertyName("tags_schema");
			JsonSerializer.Serialize(writer, TagsSchemaValue, options);
		}

		if (TypeValue is not null)
		{
			writer.WritePropertyName("type");
			JsonSerializer.Serialize(writer, TypeValue, options);
		}

		writer.WriteEndObject();
	}
}