// Licensed to Elasticsearch B.V under one or more agreements.
// Elasticsearch B.V licenses this file to you under the Apache 2.0 License.
// See the LICENSE file in the project root for more information.
//
// ███╗   ██╗ ██████╗ ████████╗██╗ ██████╗███████╗
// ████╗  ██║██╔═══██╗╚══██╔══╝██║██╔════╝██╔════╝
// ██╔██╗ ██║██║   ██║   ██║   ██║██║     █████╗
// ██║╚██╗██║██║   ██║   ██║   ██║██║     ██╔══╝
// ██║ ╚████║╚██████╔╝   ██║   ██║╚██████╗███████╗
// ╚═╝  ╚═══╝ ╚═════╝    ╚═╝   ╚═╝ ╚═════╝╚══════╝
// ------------------------------------------------
//
// This file is automatically generated.
// Please do not edit these files manually.
//
// ------------------------------------------------

#nullable restore

using Elastic.Clients.Elasticsearch.Fluent;
using Elastic.Clients.Elasticsearch.Serialization;
using System;
using System.Collections.Generic;
using System.Linq.Expressions;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace Elastic.Clients.Elasticsearch.Core.Search;

internal sealed partial class HighlightFieldConverter : System.Text.Json.Serialization.JsonConverter<HighlightField>
{
	private static readonly System.Text.Json.JsonEncodedText PropBoundaryChars = System.Text.Json.JsonEncodedText.Encode("boundary_chars");
	private static readonly System.Text.Json.JsonEncodedText PropBoundaryMaxScan = System.Text.Json.JsonEncodedText.Encode("boundary_max_scan");
	private static readonly System.Text.Json.JsonEncodedText PropBoundaryScanner = System.Text.Json.JsonEncodedText.Encode("boundary_scanner");
	private static readonly System.Text.Json.JsonEncodedText PropBoundaryScannerLocale = System.Text.Json.JsonEncodedText.Encode("boundary_scanner_locale");
	private static readonly System.Text.Json.JsonEncodedText PropFragmenter = System.Text.Json.JsonEncodedText.Encode("fragmenter");
	private static readonly System.Text.Json.JsonEncodedText PropFragmentOffset = System.Text.Json.JsonEncodedText.Encode("fragment_offset");
	private static readonly System.Text.Json.JsonEncodedText PropFragmentSize = System.Text.Json.JsonEncodedText.Encode("fragment_size");
	private static readonly System.Text.Json.JsonEncodedText PropHighlightFilter = System.Text.Json.JsonEncodedText.Encode("highlight_filter");
	private static readonly System.Text.Json.JsonEncodedText PropHighlightQuery = System.Text.Json.JsonEncodedText.Encode("highlight_query");
	private static readonly System.Text.Json.JsonEncodedText PropMatchedFields = System.Text.Json.JsonEncodedText.Encode("matched_fields");
	private static readonly System.Text.Json.JsonEncodedText PropMaxAnalyzedOffset = System.Text.Json.JsonEncodedText.Encode("max_analyzed_offset");
	private static readonly System.Text.Json.JsonEncodedText PropMaxFragmentLength = System.Text.Json.JsonEncodedText.Encode("max_fragment_length");
	private static readonly System.Text.Json.JsonEncodedText PropNoMatchSize = System.Text.Json.JsonEncodedText.Encode("no_match_size");
	private static readonly System.Text.Json.JsonEncodedText PropNumberOfFragments = System.Text.Json.JsonEncodedText.Encode("number_of_fragments");
	private static readonly System.Text.Json.JsonEncodedText PropOptions = System.Text.Json.JsonEncodedText.Encode("options");
	private static readonly System.Text.Json.JsonEncodedText PropOrder = System.Text.Json.JsonEncodedText.Encode("order");
	private static readonly System.Text.Json.JsonEncodedText PropPhraseLimit = System.Text.Json.JsonEncodedText.Encode("phrase_limit");
	private static readonly System.Text.Json.JsonEncodedText PropPostTags = System.Text.Json.JsonEncodedText.Encode("post_tags");
	private static readonly System.Text.Json.JsonEncodedText PropPreTags = System.Text.Json.JsonEncodedText.Encode("pre_tags");
	private static readonly System.Text.Json.JsonEncodedText PropRequireFieldMatch = System.Text.Json.JsonEncodedText.Encode("require_field_match");
	private static readonly System.Text.Json.JsonEncodedText PropTagsSchema = System.Text.Json.JsonEncodedText.Encode("tags_schema");
	private static readonly System.Text.Json.JsonEncodedText PropType = System.Text.Json.JsonEncodedText.Encode("type");

	public override HighlightField Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
	{
		reader.ValidateToken(System.Text.Json.JsonTokenType.StartObject);
		LocalJsonValue<string?> propBoundaryChars = default;
		LocalJsonValue<int?> propBoundaryMaxScan = default;
		LocalJsonValue<Elastic.Clients.Elasticsearch.Core.Search.BoundaryScanner?> propBoundaryScanner = default;
		LocalJsonValue<string?> propBoundaryScannerLocale = default;
		LocalJsonValue<Elastic.Clients.Elasticsearch.Core.Search.HighlighterFragmenter?> propFragmenter = default;
		LocalJsonValue<int?> propFragmentOffset = default;
		LocalJsonValue<int?> propFragmentSize = default;
		LocalJsonValue<bool?> propHighlightFilter = default;
		LocalJsonValue<Elastic.Clients.Elasticsearch.QueryDsl.Query?> propHighlightQuery = default;
		LocalJsonValue<Elastic.Clients.Elasticsearch.Fields?> propMatchedFields = default;
		LocalJsonValue<int?> propMaxAnalyzedOffset = default;
		LocalJsonValue<int?> propMaxFragmentLength = default;
		LocalJsonValue<int?> propNoMatchSize = default;
		LocalJsonValue<int?> propNumberOfFragments = default;
		LocalJsonValue<IDictionary<string, object>?> propOptions = default;
		LocalJsonValue<Elastic.Clients.Elasticsearch.Core.Search.HighlighterOrder?> propOrder = default;
		LocalJsonValue<int?> propPhraseLimit = default;
		LocalJsonValue<ICollection<string>?> propPostTags = default;
		LocalJsonValue<ICollection<string>?> propPreTags = default;
		LocalJsonValue<bool?> propRequireFieldMatch = default;
		LocalJsonValue<Elastic.Clients.Elasticsearch.Core.Search.HighlighterTagsSchema?> propTagsSchema = default;
		LocalJsonValue<Elastic.Clients.Elasticsearch.Core.Search.HighlighterType?> propType = default;
		while (reader.Read() && reader.TokenType is System.Text.Json.JsonTokenType.PropertyName)
		{
			if (propBoundaryChars.TryReadProperty(ref reader, options, PropBoundaryChars, null))
			{
				continue;
			}

			if (propBoundaryMaxScan.TryReadProperty(ref reader, options, PropBoundaryMaxScan, null))
			{
				continue;
			}

			if (propBoundaryScanner.TryReadProperty(ref reader, options, PropBoundaryScanner, null))
			{
				continue;
			}

			if (propBoundaryScannerLocale.TryReadProperty(ref reader, options, PropBoundaryScannerLocale, null))
			{
				continue;
			}

			if (propFragmenter.TryReadProperty(ref reader, options, PropFragmenter, null))
			{
				continue;
			}

			if (propFragmentOffset.TryReadProperty(ref reader, options, PropFragmentOffset, null))
			{
				continue;
			}

			if (propFragmentSize.TryReadProperty(ref reader, options, PropFragmentSize, null))
			{
				continue;
			}

			if (propHighlightFilter.TryReadProperty(ref reader, options, PropHighlightFilter, null))
			{
				continue;
			}

			if (propHighlightQuery.TryReadProperty(ref reader, options, PropHighlightQuery, null))
			{
				continue;
			}

			if (propMatchedFields.TryReadProperty(ref reader, options, PropMatchedFields, static Elastic.Clients.Elasticsearch.Fields? (ref System.Text.Json.Utf8JsonReader r, System.Text.Json.JsonSerializerOptions o) => r.ReadValueEx<Elastic.Clients.Elasticsearch.Fields?>(o, typeof(SingleOrManyFieldsMarker))))
			{
				continue;
			}

			if (propMaxAnalyzedOffset.TryReadProperty(ref reader, options, PropMaxAnalyzedOffset, null))
			{
				continue;
			}

			if (propMaxFragmentLength.TryReadProperty(ref reader, options, PropMaxFragmentLength, null))
			{
				continue;
			}

			if (propNoMatchSize.TryReadProperty(ref reader, options, PropNoMatchSize, null))
			{
				continue;
			}

			if (propNumberOfFragments.TryReadProperty(ref reader, options, PropNumberOfFragments, null))
			{
				continue;
			}

			if (propOptions.TryReadProperty(ref reader, options, PropOptions, static IDictionary<string, object>? (ref System.Text.Json.Utf8JsonReader r, System.Text.Json.JsonSerializerOptions o) => r.ReadDictionaryValue<string, object>(o, null, null)))
			{
				continue;
			}

			if (propOrder.TryReadProperty(ref reader, options, PropOrder, null))
			{
				continue;
			}

			if (propPhraseLimit.TryReadProperty(ref reader, options, PropPhraseLimit, null))
			{
				continue;
			}

			if (propPostTags.TryReadProperty(ref reader, options, PropPostTags, static ICollection<string>? (ref System.Text.Json.Utf8JsonReader r, System.Text.Json.JsonSerializerOptions o) => r.ReadCollectionValue<string>(o, null)))
			{
				continue;
			}

			if (propPreTags.TryReadProperty(ref reader, options, PropPreTags, static ICollection<string>? (ref System.Text.Json.Utf8JsonReader r, System.Text.Json.JsonSerializerOptions o) => r.ReadCollectionValue<string>(o, null)))
			{
				continue;
			}

			if (propRequireFieldMatch.TryReadProperty(ref reader, options, PropRequireFieldMatch, null))
			{
				continue;
			}

			if (propTagsSchema.TryReadProperty(ref reader, options, PropTagsSchema, null))
			{
				continue;
			}

			if (propType.TryReadProperty(ref reader, options, PropType, null))
			{
				continue;
			}

			throw new System.Text.Json.JsonException($"Unknown JSON property '{reader.GetString()}' for type '{typeToConvert.Name}'.");
		}

		reader.ValidateToken(System.Text.Json.JsonTokenType.EndObject);
		return new HighlightField
		{
			BoundaryChars = propBoundaryChars.Value
,
			BoundaryMaxScan = propBoundaryMaxScan.Value
,
			BoundaryScanner = propBoundaryScanner.Value
,
			BoundaryScannerLocale = propBoundaryScannerLocale.Value
,
			Fragmenter = propFragmenter.Value
,
			FragmentOffset = propFragmentOffset.Value
,
			FragmentSize = propFragmentSize.Value
,
			HighlightFilter = propHighlightFilter.Value
,
			HighlightQuery = propHighlightQuery.Value
,
			MatchedFields = propMatchedFields.Value
,
			MaxAnalyzedOffset = propMaxAnalyzedOffset.Value
,
			MaxFragmentLength = propMaxFragmentLength.Value
,
			NoMatchSize = propNoMatchSize.Value
,
			NumberOfFragments = propNumberOfFragments.Value
,
			Options = propOptions.Value
,
			Order = propOrder.Value
,
			PhraseLimit = propPhraseLimit.Value
,
			PostTags = propPostTags.Value
,
			PreTags = propPreTags.Value
,
			RequireFieldMatch = propRequireFieldMatch.Value
,
			TagsSchema = propTagsSchema.Value
,
			Type = propType.Value
		};
	}

	public override void Write(System.Text.Json.Utf8JsonWriter writer, HighlightField value, System.Text.Json.JsonSerializerOptions options)
	{
		writer.WriteStartObject();
		writer.WriteProperty(options, PropBoundaryChars, value.BoundaryChars, null, null);
		writer.WriteProperty(options, PropBoundaryMaxScan, value.BoundaryMaxScan, null, null);
		writer.WriteProperty(options, PropBoundaryScanner, value.BoundaryScanner, null, null);
		writer.WriteProperty(options, PropBoundaryScannerLocale, value.BoundaryScannerLocale, null, null);
		writer.WriteProperty(options, PropFragmenter, value.Fragmenter, null, null);
		writer.WriteProperty(options, PropFragmentOffset, value.FragmentOffset, null, null);
		writer.WriteProperty(options, PropFragmentSize, value.FragmentSize, null, null);
		writer.WriteProperty(options, PropHighlightFilter, value.HighlightFilter, null, null);
		writer.WriteProperty(options, PropHighlightQuery, value.HighlightQuery, null, null);
		writer.WriteProperty(options, PropMatchedFields, value.MatchedFields, null, static (System.Text.Json.Utf8JsonWriter w, System.Text.Json.JsonSerializerOptions o, Elastic.Clients.Elasticsearch.Fields? v) => w.WriteValueEx<Elastic.Clients.Elasticsearch.Fields?>(o, v, typeof(SingleOrManyFieldsMarker)));
		writer.WriteProperty(options, PropMaxAnalyzedOffset, value.MaxAnalyzedOffset, null, null);
		writer.WriteProperty(options, PropMaxFragmentLength, value.MaxFragmentLength, null, null);
		writer.WriteProperty(options, PropNoMatchSize, value.NoMatchSize, null, null);
		writer.WriteProperty(options, PropNumberOfFragments, value.NumberOfFragments, null, null);
		writer.WriteProperty(options, PropOptions, value.Options, null, static (System.Text.Json.Utf8JsonWriter w, System.Text.Json.JsonSerializerOptions o, IDictionary<string, object>? v) => w.WriteDictionaryValue<string, object>(o, v, null, null));
		writer.WriteProperty(options, PropOrder, value.Order, null, null);
		writer.WriteProperty(options, PropPhraseLimit, value.PhraseLimit, null, null);
		writer.WriteProperty(options, PropPostTags, value.PostTags, null, static (System.Text.Json.Utf8JsonWriter w, System.Text.Json.JsonSerializerOptions o, ICollection<string>? v) => w.WriteCollectionValue<string>(o, v, null));
		writer.WriteProperty(options, PropPreTags, value.PreTags, null, static (System.Text.Json.Utf8JsonWriter w, System.Text.Json.JsonSerializerOptions o, ICollection<string>? v) => w.WriteCollectionValue<string>(o, v, null));
		writer.WriteProperty(options, PropRequireFieldMatch, value.RequireFieldMatch, null, null);
		writer.WriteProperty(options, PropTagsSchema, value.TagsSchema, null, null);
		writer.WriteProperty(options, PropType, value.Type, null, null);
		writer.WriteEndObject();
	}
}

[JsonConverter(typeof(HighlightFieldConverter))]
public sealed partial class HighlightField
{
	/// <summary>
	/// <para>
	/// A string that contains each boundary character.
	/// </para>
	/// </summary>
	public string? BoundaryChars { get; set; }

	/// <summary>
	/// <para>
	/// How far to scan for boundary characters.
	/// </para>
	/// </summary>
	public int? BoundaryMaxScan { get; set; }

	/// <summary>
	/// <para>
	/// Specifies how to break the highlighted fragments: chars, sentence, or word.
	/// Only valid for the unified and fvh highlighters.
	/// Defaults to <c>sentence</c> for the <c>unified</c> highlighter. Defaults to <c>chars</c> for the <c>fvh</c> highlighter.
	/// </para>
	/// </summary>
	public Elastic.Clients.Elasticsearch.Core.Search.BoundaryScanner? BoundaryScanner { get; set; }

	/// <summary>
	/// <para>
	/// Controls which locale is used to search for sentence and word boundaries.
	/// This parameter takes a form of a language tag, for example: <c>"en-US"</c>, <c>"fr-FR"</c>, <c>"ja-JP"</c>.
	/// </para>
	/// </summary>
	public string? BoundaryScannerLocale { get; set; }

	/// <summary>
	/// <para>
	/// Specifies how text should be broken up in highlight snippets: <c>simple</c> or <c>span</c>.
	/// Only valid for the <c>plain</c> highlighter.
	/// </para>
	/// </summary>
	public Elastic.Clients.Elasticsearch.Core.Search.HighlighterFragmenter? Fragmenter { get; set; }
	public int? FragmentOffset { get; set; }

	/// <summary>
	/// <para>
	/// The size of the highlighted fragment in characters.
	/// </para>
	/// </summary>
	public int? FragmentSize { get; set; }
	public bool? HighlightFilter { get; set; }

	/// <summary>
	/// <para>
	/// Highlight matches for a query other than the search query.
	/// This is especially useful if you use a rescore query because those are not taken into account by highlighting by default.
	/// </para>
	/// </summary>
	public Elastic.Clients.Elasticsearch.QueryDsl.Query? HighlightQuery { get; set; }
	public Elastic.Clients.Elasticsearch.Fields? MatchedFields { get; set; }

	/// <summary>
	/// <para>
	/// If set to a non-negative value, highlighting stops at this defined maximum limit.
	/// The rest of the text is not processed, thus not highlighted and no error is returned
	/// The <c>max_analyzed_offset</c> query setting does not override the <c>index.highlight.max_analyzed_offset</c> setting, which prevails when it’s set to lower value than the query setting.
	/// </para>
	/// </summary>
	public int? MaxAnalyzedOffset { get; set; }
	public int? MaxFragmentLength { get; set; }

	/// <summary>
	/// <para>
	/// The amount of text you want to return from the beginning of the field if there are no matching fragments to highlight.
	/// </para>
	/// </summary>
	public int? NoMatchSize { get; set; }

	/// <summary>
	/// <para>
	/// The maximum number of fragments to return.
	/// If the number of fragments is set to <c>0</c>, no fragments are returned.
	/// Instead, the entire field contents are highlighted and returned.
	/// This can be handy when you need to highlight short texts such as a title or address, but fragmentation is not required.
	/// If <c>number_of_fragments</c> is <c>0</c>, <c>fragment_size</c> is ignored.
	/// </para>
	/// </summary>
	public int? NumberOfFragments { get; set; }
	public IDictionary<string, object>? Options { get; set; }

	/// <summary>
	/// <para>
	/// Sorts highlighted fragments by score when set to <c>score</c>.
	/// By default, fragments will be output in the order they appear in the field (order: <c>none</c>).
	/// Setting this option to <c>score</c> will output the most relevant fragments first.
	/// Each highlighter applies its own logic to compute relevancy scores.
	/// </para>
	/// </summary>
	public Elastic.Clients.Elasticsearch.Core.Search.HighlighterOrder? Order { get; set; }

	/// <summary>
	/// <para>
	/// Controls the number of matching phrases in a document that are considered.
	/// Prevents the <c>fvh</c> highlighter from analyzing too many phrases and consuming too much memory.
	/// When using <c>matched_fields</c>, <c>phrase_limit</c> phrases per matched field are considered. Raising the limit increases query time and consumes more memory.
	/// Only supported by the <c>fvh</c> highlighter.
	/// </para>
	/// </summary>
	public int? PhraseLimit { get; set; }

	/// <summary>
	/// <para>
	/// Use in conjunction with <c>pre_tags</c> to define the HTML tags to use for the highlighted text.
	/// By default, highlighted text is wrapped in <c>&lt;em></c> and <c>&lt;/em></c> tags.
	/// </para>
	/// </summary>
	public ICollection<string>? PostTags { get; set; }

	/// <summary>
	/// <para>
	/// Use in conjunction with <c>post_tags</c> to define the HTML tags to use for the highlighted text.
	/// By default, highlighted text is wrapped in <c>&lt;em></c> and <c>&lt;/em></c> tags.
	/// </para>
	/// </summary>
	public ICollection<string>? PreTags { get; set; }

	/// <summary>
	/// <para>
	/// By default, only fields that contains a query match are highlighted.
	/// Set to <c>false</c> to highlight all fields.
	/// </para>
	/// </summary>
	public bool? RequireFieldMatch { get; set; }

	/// <summary>
	/// <para>
	/// Set to <c>styled</c> to use the built-in tag schema.
	/// </para>
	/// </summary>
	public Elastic.Clients.Elasticsearch.Core.Search.HighlighterTagsSchema? TagsSchema { get; set; }
	public Elastic.Clients.Elasticsearch.Core.Search.HighlighterType? Type { get; set; }
}

public sealed partial class HighlightFieldDescriptor<TDocument> : SerializableDescriptor<HighlightFieldDescriptor<TDocument>>
{
	internal HighlightFieldDescriptor(Action<HighlightFieldDescriptor<TDocument>> configure) => configure.Invoke(this);

	public HighlightFieldDescriptor() : base()
	{
	}

	private string? BoundaryCharsValue { get; set; }
	private int? BoundaryMaxScanValue { get; set; }
	private Elastic.Clients.Elasticsearch.Core.Search.BoundaryScanner? BoundaryScannerValue { get; set; }
	private string? BoundaryScannerLocaleValue { get; set; }
	private Elastic.Clients.Elasticsearch.Core.Search.HighlighterFragmenter? FragmenterValue { get; set; }
	private int? FragmentOffsetValue { get; set; }
	private int? FragmentSizeValue { get; set; }
	private bool? HighlightFilterValue { get; set; }
	private Elastic.Clients.Elasticsearch.QueryDsl.Query? HighlightQueryValue { get; set; }
	private Elastic.Clients.Elasticsearch.QueryDsl.QueryDescriptor<TDocument> HighlightQueryDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.QueryDsl.QueryDescriptor<TDocument>> HighlightQueryDescriptorAction { get; set; }
	private Elastic.Clients.Elasticsearch.Fields? MatchedFieldsValue { get; set; }
	private int? MaxAnalyzedOffsetValue { get; set; }
	private int? MaxFragmentLengthValue { get; set; }
	private int? NoMatchSizeValue { get; set; }
	private int? NumberOfFragmentsValue { get; set; }
	private IDictionary<string, object>? OptionsValue { get; set; }
	private Elastic.Clients.Elasticsearch.Core.Search.HighlighterOrder? OrderValue { get; set; }
	private int? PhraseLimitValue { get; set; }
	private ICollection<string>? PostTagsValue { get; set; }
	private ICollection<string>? PreTagsValue { get; set; }
	private bool? RequireFieldMatchValue { get; set; }
	private Elastic.Clients.Elasticsearch.Core.Search.HighlighterTagsSchema? TagsSchemaValue { get; set; }
	private Elastic.Clients.Elasticsearch.Core.Search.HighlighterType? TypeValue { get; set; }

	/// <summary>
	/// <para>
	/// A string that contains each boundary character.
	/// </para>
	/// </summary>
	public HighlightFieldDescriptor<TDocument> BoundaryChars(string? boundaryChars)
	{
		BoundaryCharsValue = boundaryChars;
		return Self;
	}

	/// <summary>
	/// <para>
	/// How far to scan for boundary characters.
	/// </para>
	/// </summary>
	public HighlightFieldDescriptor<TDocument> BoundaryMaxScan(int? boundaryMaxScan)
	{
		BoundaryMaxScanValue = boundaryMaxScan;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Specifies how to break the highlighted fragments: chars, sentence, or word.
	/// Only valid for the unified and fvh highlighters.
	/// Defaults to <c>sentence</c> for the <c>unified</c> highlighter. Defaults to <c>chars</c> for the <c>fvh</c> highlighter.
	/// </para>
	/// </summary>
	public HighlightFieldDescriptor<TDocument> BoundaryScanner(Elastic.Clients.Elasticsearch.Core.Search.BoundaryScanner? boundaryScanner)
	{
		BoundaryScannerValue = boundaryScanner;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Controls which locale is used to search for sentence and word boundaries.
	/// This parameter takes a form of a language tag, for example: <c>"en-US"</c>, <c>"fr-FR"</c>, <c>"ja-JP"</c>.
	/// </para>
	/// </summary>
	public HighlightFieldDescriptor<TDocument> BoundaryScannerLocale(string? boundaryScannerLocale)
	{
		BoundaryScannerLocaleValue = boundaryScannerLocale;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Specifies how text should be broken up in highlight snippets: <c>simple</c> or <c>span</c>.
	/// Only valid for the <c>plain</c> highlighter.
	/// </para>
	/// </summary>
	public HighlightFieldDescriptor<TDocument> Fragmenter(Elastic.Clients.Elasticsearch.Core.Search.HighlighterFragmenter? fragmenter)
	{
		FragmenterValue = fragmenter;
		return Self;
	}

	public HighlightFieldDescriptor<TDocument> FragmentOffset(int? fragmentOffset)
	{
		FragmentOffsetValue = fragmentOffset;
		return Self;
	}

	/// <summary>
	/// <para>
	/// The size of the highlighted fragment in characters.
	/// </para>
	/// </summary>
	public HighlightFieldDescriptor<TDocument> FragmentSize(int? fragmentSize)
	{
		FragmentSizeValue = fragmentSize;
		return Self;
	}

	public HighlightFieldDescriptor<TDocument> HighlightFilter(bool? highlightFilter = true)
	{
		HighlightFilterValue = highlightFilter;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Highlight matches for a query other than the search query.
	/// This is especially useful if you use a rescore query because those are not taken into account by highlighting by default.
	/// </para>
	/// </summary>
	public HighlightFieldDescriptor<TDocument> HighlightQuery(Elastic.Clients.Elasticsearch.QueryDsl.Query? highlightQuery)
	{
		HighlightQueryDescriptor = null;
		HighlightQueryDescriptorAction = null;
		HighlightQueryValue = highlightQuery;
		return Self;
	}

	public HighlightFieldDescriptor<TDocument> HighlightQuery(Elastic.Clients.Elasticsearch.QueryDsl.QueryDescriptor<TDocument> descriptor)
	{
		HighlightQueryValue = null;
		HighlightQueryDescriptorAction = null;
		HighlightQueryDescriptor = descriptor;
		return Self;
	}

	public HighlightFieldDescriptor<TDocument> HighlightQuery(Action<Elastic.Clients.Elasticsearch.QueryDsl.QueryDescriptor<TDocument>> configure)
	{
		HighlightQueryValue = null;
		HighlightQueryDescriptor = null;
		HighlightQueryDescriptorAction = configure;
		return Self;
	}

	public HighlightFieldDescriptor<TDocument> MatchedFields(Elastic.Clients.Elasticsearch.Fields? matchedFields)
	{
		MatchedFieldsValue = matchedFields;
		return Self;
	}

	/// <summary>
	/// <para>
	/// If set to a non-negative value, highlighting stops at this defined maximum limit.
	/// The rest of the text is not processed, thus not highlighted and no error is returned
	/// The <c>max_analyzed_offset</c> query setting does not override the <c>index.highlight.max_analyzed_offset</c> setting, which prevails when it’s set to lower value than the query setting.
	/// </para>
	/// </summary>
	public HighlightFieldDescriptor<TDocument> MaxAnalyzedOffset(int? maxAnalyzedOffset)
	{
		MaxAnalyzedOffsetValue = maxAnalyzedOffset;
		return Self;
	}

	public HighlightFieldDescriptor<TDocument> MaxFragmentLength(int? maxFragmentLength)
	{
		MaxFragmentLengthValue = maxFragmentLength;
		return Self;
	}

	/// <summary>
	/// <para>
	/// The amount of text you want to return from the beginning of the field if there are no matching fragments to highlight.
	/// </para>
	/// </summary>
	public HighlightFieldDescriptor<TDocument> NoMatchSize(int? noMatchSize)
	{
		NoMatchSizeValue = noMatchSize;
		return Self;
	}

	/// <summary>
	/// <para>
	/// The maximum number of fragments to return.
	/// If the number of fragments is set to <c>0</c>, no fragments are returned.
	/// Instead, the entire field contents are highlighted and returned.
	/// This can be handy when you need to highlight short texts such as a title or address, but fragmentation is not required.
	/// If <c>number_of_fragments</c> is <c>0</c>, <c>fragment_size</c> is ignored.
	/// </para>
	/// </summary>
	public HighlightFieldDescriptor<TDocument> NumberOfFragments(int? numberOfFragments)
	{
		NumberOfFragmentsValue = numberOfFragments;
		return Self;
	}

	public HighlightFieldDescriptor<TDocument> Options(Func<FluentDictionary<string, object>, FluentDictionary<string, object>> selector)
	{
		OptionsValue = selector?.Invoke(new FluentDictionary<string, object>());
		return Self;
	}

	/// <summary>
	/// <para>
	/// Sorts highlighted fragments by score when set to <c>score</c>.
	/// By default, fragments will be output in the order they appear in the field (order: <c>none</c>).
	/// Setting this option to <c>score</c> will output the most relevant fragments first.
	/// Each highlighter applies its own logic to compute relevancy scores.
	/// </para>
	/// </summary>
	public HighlightFieldDescriptor<TDocument> Order(Elastic.Clients.Elasticsearch.Core.Search.HighlighterOrder? order)
	{
		OrderValue = order;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Controls the number of matching phrases in a document that are considered.
	/// Prevents the <c>fvh</c> highlighter from analyzing too many phrases and consuming too much memory.
	/// When using <c>matched_fields</c>, <c>phrase_limit</c> phrases per matched field are considered. Raising the limit increases query time and consumes more memory.
	/// Only supported by the <c>fvh</c> highlighter.
	/// </para>
	/// </summary>
	public HighlightFieldDescriptor<TDocument> PhraseLimit(int? phraseLimit)
	{
		PhraseLimitValue = phraseLimit;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Use in conjunction with <c>pre_tags</c> to define the HTML tags to use for the highlighted text.
	/// By default, highlighted text is wrapped in <c>&lt;em></c> and <c>&lt;/em></c> tags.
	/// </para>
	/// </summary>
	public HighlightFieldDescriptor<TDocument> PostTags(ICollection<string>? postTags)
	{
		PostTagsValue = postTags;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Use in conjunction with <c>post_tags</c> to define the HTML tags to use for the highlighted text.
	/// By default, highlighted text is wrapped in <c>&lt;em></c> and <c>&lt;/em></c> tags.
	/// </para>
	/// </summary>
	public HighlightFieldDescriptor<TDocument> PreTags(ICollection<string>? preTags)
	{
		PreTagsValue = preTags;
		return Self;
	}

	/// <summary>
	/// <para>
	/// By default, only fields that contains a query match are highlighted.
	/// Set to <c>false</c> to highlight all fields.
	/// </para>
	/// </summary>
	public HighlightFieldDescriptor<TDocument> RequireFieldMatch(bool? requireFieldMatch = true)
	{
		RequireFieldMatchValue = requireFieldMatch;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Set to <c>styled</c> to use the built-in tag schema.
	/// </para>
	/// </summary>
	public HighlightFieldDescriptor<TDocument> TagsSchema(Elastic.Clients.Elasticsearch.Core.Search.HighlighterTagsSchema? tagsSchema)
	{
		TagsSchemaValue = tagsSchema;
		return Self;
	}

	public HighlightFieldDescriptor<TDocument> Type(Elastic.Clients.Elasticsearch.Core.Search.HighlighterType? type)
	{
		TypeValue = type;
		return Self;
	}

	protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
	{
		writer.WriteStartObject();
		if (!string.IsNullOrEmpty(BoundaryCharsValue))
		{
			writer.WritePropertyName("boundary_chars");
			writer.WriteStringValue(BoundaryCharsValue);
		}

		if (BoundaryMaxScanValue.HasValue)
		{
			writer.WritePropertyName("boundary_max_scan");
			writer.WriteNumberValue(BoundaryMaxScanValue.Value);
		}

		if (BoundaryScannerValue is not null)
		{
			writer.WritePropertyName("boundary_scanner");
			JsonSerializer.Serialize(writer, BoundaryScannerValue, options);
		}

		if (!string.IsNullOrEmpty(BoundaryScannerLocaleValue))
		{
			writer.WritePropertyName("boundary_scanner_locale");
			writer.WriteStringValue(BoundaryScannerLocaleValue);
		}

		if (FragmenterValue is not null)
		{
			writer.WritePropertyName("fragmenter");
			JsonSerializer.Serialize(writer, FragmenterValue, options);
		}

		if (FragmentOffsetValue.HasValue)
		{
			writer.WritePropertyName("fragment_offset");
			writer.WriteNumberValue(FragmentOffsetValue.Value);
		}

		if (FragmentSizeValue.HasValue)
		{
			writer.WritePropertyName("fragment_size");
			writer.WriteNumberValue(FragmentSizeValue.Value);
		}

		if (HighlightFilterValue.HasValue)
		{
			writer.WritePropertyName("highlight_filter");
			writer.WriteBooleanValue(HighlightFilterValue.Value);
		}

		if (HighlightQueryDescriptor is not null)
		{
			writer.WritePropertyName("highlight_query");
			JsonSerializer.Serialize(writer, HighlightQueryDescriptor, options);
		}
		else if (HighlightQueryDescriptorAction is not null)
		{
			writer.WritePropertyName("highlight_query");
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.QueryDsl.QueryDescriptor<TDocument>(HighlightQueryDescriptorAction), options);
		}
		else if (HighlightQueryValue is not null)
		{
			writer.WritePropertyName("highlight_query");
			JsonSerializer.Serialize(writer, HighlightQueryValue, options);
		}

		if (MatchedFieldsValue is not null)
		{
			writer.WritePropertyName("matched_fields");
			JsonSerializer.Serialize(writer, MatchedFieldsValue, options);
		}

		if (MaxAnalyzedOffsetValue.HasValue)
		{
			writer.WritePropertyName("max_analyzed_offset");
			writer.WriteNumberValue(MaxAnalyzedOffsetValue.Value);
		}

		if (MaxFragmentLengthValue.HasValue)
		{
			writer.WritePropertyName("max_fragment_length");
			writer.WriteNumberValue(MaxFragmentLengthValue.Value);
		}

		if (NoMatchSizeValue.HasValue)
		{
			writer.WritePropertyName("no_match_size");
			writer.WriteNumberValue(NoMatchSizeValue.Value);
		}

		if (NumberOfFragmentsValue.HasValue)
		{
			writer.WritePropertyName("number_of_fragments");
			writer.WriteNumberValue(NumberOfFragmentsValue.Value);
		}

		if (OptionsValue is not null)
		{
			writer.WritePropertyName("options");
			JsonSerializer.Serialize(writer, OptionsValue, options);
		}

		if (OrderValue is not null)
		{
			writer.WritePropertyName("order");
			JsonSerializer.Serialize(writer, OrderValue, options);
		}

		if (PhraseLimitValue.HasValue)
		{
			writer.WritePropertyName("phrase_limit");
			writer.WriteNumberValue(PhraseLimitValue.Value);
		}

		if (PostTagsValue is not null)
		{
			writer.WritePropertyName("post_tags");
			JsonSerializer.Serialize(writer, PostTagsValue, options);
		}

		if (PreTagsValue is not null)
		{
			writer.WritePropertyName("pre_tags");
			JsonSerializer.Serialize(writer, PreTagsValue, options);
		}

		if (RequireFieldMatchValue.HasValue)
		{
			writer.WritePropertyName("require_field_match");
			writer.WriteBooleanValue(RequireFieldMatchValue.Value);
		}

		if (TagsSchemaValue is not null)
		{
			writer.WritePropertyName("tags_schema");
			JsonSerializer.Serialize(writer, TagsSchemaValue, options);
		}

		if (TypeValue is not null)
		{
			writer.WritePropertyName("type");
			JsonSerializer.Serialize(writer, TypeValue, options);
		}

		writer.WriteEndObject();
	}
}

public sealed partial class HighlightFieldDescriptor : SerializableDescriptor<HighlightFieldDescriptor>
{
	internal HighlightFieldDescriptor(Action<HighlightFieldDescriptor> configure) => configure.Invoke(this);

	public HighlightFieldDescriptor() : base()
	{
	}

	private string? BoundaryCharsValue { get; set; }
	private int? BoundaryMaxScanValue { get; set; }
	private Elastic.Clients.Elasticsearch.Core.Search.BoundaryScanner? BoundaryScannerValue { get; set; }
	private string? BoundaryScannerLocaleValue { get; set; }
	private Elastic.Clients.Elasticsearch.Core.Search.HighlighterFragmenter? FragmenterValue { get; set; }
	private int? FragmentOffsetValue { get; set; }
	private int? FragmentSizeValue { get; set; }
	private bool? HighlightFilterValue { get; set; }
	private Elastic.Clients.Elasticsearch.QueryDsl.Query? HighlightQueryValue { get; set; }
	private Elastic.Clients.Elasticsearch.QueryDsl.QueryDescriptor HighlightQueryDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.QueryDsl.QueryDescriptor> HighlightQueryDescriptorAction { get; set; }
	private Elastic.Clients.Elasticsearch.Fields? MatchedFieldsValue { get; set; }
	private int? MaxAnalyzedOffsetValue { get; set; }
	private int? MaxFragmentLengthValue { get; set; }
	private int? NoMatchSizeValue { get; set; }
	private int? NumberOfFragmentsValue { get; set; }
	private IDictionary<string, object>? OptionsValue { get; set; }
	private Elastic.Clients.Elasticsearch.Core.Search.HighlighterOrder? OrderValue { get; set; }
	private int? PhraseLimitValue { get; set; }
	private ICollection<string>? PostTagsValue { get; set; }
	private ICollection<string>? PreTagsValue { get; set; }
	private bool? RequireFieldMatchValue { get; set; }
	private Elastic.Clients.Elasticsearch.Core.Search.HighlighterTagsSchema? TagsSchemaValue { get; set; }
	private Elastic.Clients.Elasticsearch.Core.Search.HighlighterType? TypeValue { get; set; }

	/// <summary>
	/// <para>
	/// A string that contains each boundary character.
	/// </para>
	/// </summary>
	public HighlightFieldDescriptor BoundaryChars(string? boundaryChars)
	{
		BoundaryCharsValue = boundaryChars;
		return Self;
	}

	/// <summary>
	/// <para>
	/// How far to scan for boundary characters.
	/// </para>
	/// </summary>
	public HighlightFieldDescriptor BoundaryMaxScan(int? boundaryMaxScan)
	{
		BoundaryMaxScanValue = boundaryMaxScan;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Specifies how to break the highlighted fragments: chars, sentence, or word.
	/// Only valid for the unified and fvh highlighters.
	/// Defaults to <c>sentence</c> for the <c>unified</c> highlighter. Defaults to <c>chars</c> for the <c>fvh</c> highlighter.
	/// </para>
	/// </summary>
	public HighlightFieldDescriptor BoundaryScanner(Elastic.Clients.Elasticsearch.Core.Search.BoundaryScanner? boundaryScanner)
	{
		BoundaryScannerValue = boundaryScanner;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Controls which locale is used to search for sentence and word boundaries.
	/// This parameter takes a form of a language tag, for example: <c>"en-US"</c>, <c>"fr-FR"</c>, <c>"ja-JP"</c>.
	/// </para>
	/// </summary>
	public HighlightFieldDescriptor BoundaryScannerLocale(string? boundaryScannerLocale)
	{
		BoundaryScannerLocaleValue = boundaryScannerLocale;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Specifies how text should be broken up in highlight snippets: <c>simple</c> or <c>span</c>.
	/// Only valid for the <c>plain</c> highlighter.
	/// </para>
	/// </summary>
	public HighlightFieldDescriptor Fragmenter(Elastic.Clients.Elasticsearch.Core.Search.HighlighterFragmenter? fragmenter)
	{
		FragmenterValue = fragmenter;
		return Self;
	}

	public HighlightFieldDescriptor FragmentOffset(int? fragmentOffset)
	{
		FragmentOffsetValue = fragmentOffset;
		return Self;
	}

	/// <summary>
	/// <para>
	/// The size of the highlighted fragment in characters.
	/// </para>
	/// </summary>
	public HighlightFieldDescriptor FragmentSize(int? fragmentSize)
	{
		FragmentSizeValue = fragmentSize;
		return Self;
	}

	public HighlightFieldDescriptor HighlightFilter(bool? highlightFilter = true)
	{
		HighlightFilterValue = highlightFilter;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Highlight matches for a query other than the search query.
	/// This is especially useful if you use a rescore query because those are not taken into account by highlighting by default.
	/// </para>
	/// </summary>
	public HighlightFieldDescriptor HighlightQuery(Elastic.Clients.Elasticsearch.QueryDsl.Query? highlightQuery)
	{
		HighlightQueryDescriptor = null;
		HighlightQueryDescriptorAction = null;
		HighlightQueryValue = highlightQuery;
		return Self;
	}

	public HighlightFieldDescriptor HighlightQuery(Elastic.Clients.Elasticsearch.QueryDsl.QueryDescriptor descriptor)
	{
		HighlightQueryValue = null;
		HighlightQueryDescriptorAction = null;
		HighlightQueryDescriptor = descriptor;
		return Self;
	}

	public HighlightFieldDescriptor HighlightQuery(Action<Elastic.Clients.Elasticsearch.QueryDsl.QueryDescriptor> configure)
	{
		HighlightQueryValue = null;
		HighlightQueryDescriptor = null;
		HighlightQueryDescriptorAction = configure;
		return Self;
	}

	public HighlightFieldDescriptor MatchedFields(Elastic.Clients.Elasticsearch.Fields? matchedFields)
	{
		MatchedFieldsValue = matchedFields;
		return Self;
	}

	/// <summary>
	/// <para>
	/// If set to a non-negative value, highlighting stops at this defined maximum limit.
	/// The rest of the text is not processed, thus not highlighted and no error is returned
	/// The <c>max_analyzed_offset</c> query setting does not override the <c>index.highlight.max_analyzed_offset</c> setting, which prevails when it’s set to lower value than the query setting.
	/// </para>
	/// </summary>
	public HighlightFieldDescriptor MaxAnalyzedOffset(int? maxAnalyzedOffset)
	{
		MaxAnalyzedOffsetValue = maxAnalyzedOffset;
		return Self;
	}

	public HighlightFieldDescriptor MaxFragmentLength(int? maxFragmentLength)
	{
		MaxFragmentLengthValue = maxFragmentLength;
		return Self;
	}

	/// <summary>
	/// <para>
	/// The amount of text you want to return from the beginning of the field if there are no matching fragments to highlight.
	/// </para>
	/// </summary>
	public HighlightFieldDescriptor NoMatchSize(int? noMatchSize)
	{
		NoMatchSizeValue = noMatchSize;
		return Self;
	}

	/// <summary>
	/// <para>
	/// The maximum number of fragments to return.
	/// If the number of fragments is set to <c>0</c>, no fragments are returned.
	/// Instead, the entire field contents are highlighted and returned.
	/// This can be handy when you need to highlight short texts such as a title or address, but fragmentation is not required.
	/// If <c>number_of_fragments</c> is <c>0</c>, <c>fragment_size</c> is ignored.
	/// </para>
	/// </summary>
	public HighlightFieldDescriptor NumberOfFragments(int? numberOfFragments)
	{
		NumberOfFragmentsValue = numberOfFragments;
		return Self;
	}

	public HighlightFieldDescriptor Options(Func<FluentDictionary<string, object>, FluentDictionary<string, object>> selector)
	{
		OptionsValue = selector?.Invoke(new FluentDictionary<string, object>());
		return Self;
	}

	/// <summary>
	/// <para>
	/// Sorts highlighted fragments by score when set to <c>score</c>.
	/// By default, fragments will be output in the order they appear in the field (order: <c>none</c>).
	/// Setting this option to <c>score</c> will output the most relevant fragments first.
	/// Each highlighter applies its own logic to compute relevancy scores.
	/// </para>
	/// </summary>
	public HighlightFieldDescriptor Order(Elastic.Clients.Elasticsearch.Core.Search.HighlighterOrder? order)
	{
		OrderValue = order;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Controls the number of matching phrases in a document that are considered.
	/// Prevents the <c>fvh</c> highlighter from analyzing too many phrases and consuming too much memory.
	/// When using <c>matched_fields</c>, <c>phrase_limit</c> phrases per matched field are considered. Raising the limit increases query time and consumes more memory.
	/// Only supported by the <c>fvh</c> highlighter.
	/// </para>
	/// </summary>
	public HighlightFieldDescriptor PhraseLimit(int? phraseLimit)
	{
		PhraseLimitValue = phraseLimit;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Use in conjunction with <c>pre_tags</c> to define the HTML tags to use for the highlighted text.
	/// By default, highlighted text is wrapped in <c>&lt;em></c> and <c>&lt;/em></c> tags.
	/// </para>
	/// </summary>
	public HighlightFieldDescriptor PostTags(ICollection<string>? postTags)
	{
		PostTagsValue = postTags;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Use in conjunction with <c>post_tags</c> to define the HTML tags to use for the highlighted text.
	/// By default, highlighted text is wrapped in <c>&lt;em></c> and <c>&lt;/em></c> tags.
	/// </para>
	/// </summary>
	public HighlightFieldDescriptor PreTags(ICollection<string>? preTags)
	{
		PreTagsValue = preTags;
		return Self;
	}

	/// <summary>
	/// <para>
	/// By default, only fields that contains a query match are highlighted.
	/// Set to <c>false</c> to highlight all fields.
	/// </para>
	/// </summary>
	public HighlightFieldDescriptor RequireFieldMatch(bool? requireFieldMatch = true)
	{
		RequireFieldMatchValue = requireFieldMatch;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Set to <c>styled</c> to use the built-in tag schema.
	/// </para>
	/// </summary>
	public HighlightFieldDescriptor TagsSchema(Elastic.Clients.Elasticsearch.Core.Search.HighlighterTagsSchema? tagsSchema)
	{
		TagsSchemaValue = tagsSchema;
		return Self;
	}

	public HighlightFieldDescriptor Type(Elastic.Clients.Elasticsearch.Core.Search.HighlighterType? type)
	{
		TypeValue = type;
		return Self;
	}

	protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
	{
		writer.WriteStartObject();
		if (!string.IsNullOrEmpty(BoundaryCharsValue))
		{
			writer.WritePropertyName("boundary_chars");
			writer.WriteStringValue(BoundaryCharsValue);
		}

		if (BoundaryMaxScanValue.HasValue)
		{
			writer.WritePropertyName("boundary_max_scan");
			writer.WriteNumberValue(BoundaryMaxScanValue.Value);
		}

		if (BoundaryScannerValue is not null)
		{
			writer.WritePropertyName("boundary_scanner");
			JsonSerializer.Serialize(writer, BoundaryScannerValue, options);
		}

		if (!string.IsNullOrEmpty(BoundaryScannerLocaleValue))
		{
			writer.WritePropertyName("boundary_scanner_locale");
			writer.WriteStringValue(BoundaryScannerLocaleValue);
		}

		if (FragmenterValue is not null)
		{
			writer.WritePropertyName("fragmenter");
			JsonSerializer.Serialize(writer, FragmenterValue, options);
		}

		if (FragmentOffsetValue.HasValue)
		{
			writer.WritePropertyName("fragment_offset");
			writer.WriteNumberValue(FragmentOffsetValue.Value);
		}

		if (FragmentSizeValue.HasValue)
		{
			writer.WritePropertyName("fragment_size");
			writer.WriteNumberValue(FragmentSizeValue.Value);
		}

		if (HighlightFilterValue.HasValue)
		{
			writer.WritePropertyName("highlight_filter");
			writer.WriteBooleanValue(HighlightFilterValue.Value);
		}

		if (HighlightQueryDescriptor is not null)
		{
			writer.WritePropertyName("highlight_query");
			JsonSerializer.Serialize(writer, HighlightQueryDescriptor, options);
		}
		else if (HighlightQueryDescriptorAction is not null)
		{
			writer.WritePropertyName("highlight_query");
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.QueryDsl.QueryDescriptor(HighlightQueryDescriptorAction), options);
		}
		else if (HighlightQueryValue is not null)
		{
			writer.WritePropertyName("highlight_query");
			JsonSerializer.Serialize(writer, HighlightQueryValue, options);
		}

		if (MatchedFieldsValue is not null)
		{
			writer.WritePropertyName("matched_fields");
			JsonSerializer.Serialize(writer, MatchedFieldsValue, options);
		}

		if (MaxAnalyzedOffsetValue.HasValue)
		{
			writer.WritePropertyName("max_analyzed_offset");
			writer.WriteNumberValue(MaxAnalyzedOffsetValue.Value);
		}

		if (MaxFragmentLengthValue.HasValue)
		{
			writer.WritePropertyName("max_fragment_length");
			writer.WriteNumberValue(MaxFragmentLengthValue.Value);
		}

		if (NoMatchSizeValue.HasValue)
		{
			writer.WritePropertyName("no_match_size");
			writer.WriteNumberValue(NoMatchSizeValue.Value);
		}

		if (NumberOfFragmentsValue.HasValue)
		{
			writer.WritePropertyName("number_of_fragments");
			writer.WriteNumberValue(NumberOfFragmentsValue.Value);
		}

		if (OptionsValue is not null)
		{
			writer.WritePropertyName("options");
			JsonSerializer.Serialize(writer, OptionsValue, options);
		}

		if (OrderValue is not null)
		{
			writer.WritePropertyName("order");
			JsonSerializer.Serialize(writer, OrderValue, options);
		}

		if (PhraseLimitValue.HasValue)
		{
			writer.WritePropertyName("phrase_limit");
			writer.WriteNumberValue(PhraseLimitValue.Value);
		}

		if (PostTagsValue is not null)
		{
			writer.WritePropertyName("post_tags");
			JsonSerializer.Serialize(writer, PostTagsValue, options);
		}

		if (PreTagsValue is not null)
		{
			writer.WritePropertyName("pre_tags");
			JsonSerializer.Serialize(writer, PreTagsValue, options);
		}

		if (RequireFieldMatchValue.HasValue)
		{
			writer.WritePropertyName("require_field_match");
			writer.WriteBooleanValue(RequireFieldMatchValue.Value);
		}

		if (TagsSchemaValue is not null)
		{
			writer.WritePropertyName("tags_schema");
			JsonSerializer.Serialize(writer, TagsSchemaValue, options);
		}

		if (TypeValue is not null)
		{
			writer.WritePropertyName("type");
			JsonSerializer.Serialize(writer, TypeValue, options);
		}

		writer.WriteEndObject();
	}
}