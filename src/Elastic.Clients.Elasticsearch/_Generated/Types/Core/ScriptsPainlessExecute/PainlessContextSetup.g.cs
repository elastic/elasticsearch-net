// Licensed to Elasticsearch B.V under one or more agreements.
// Elasticsearch B.V licenses this file to you under the Apache 2.0 License.
// See the LICENSE file in the project root for more information.
//
// ███╗   ██╗ ██████╗ ████████╗██╗ ██████╗███████╗
// ████╗  ██║██╔═══██╗╚══██╔══╝██║██╔════╝██╔════╝
// ██╔██╗ ██║██║   ██║   ██║   ██║██║     █████╗
// ██║╚██╗██║██║   ██║   ██║   ██║██║     ██╔══╝
// ██║ ╚████║╚██████╔╝   ██║   ██║╚██████╗███████╗
// ╚═╝  ╚═══╝ ╚═════╝    ╚═╝   ╚═╝ ╚═════╝╚══════╝
// ------------------------------------------------
//
// This file is automatically generated.
// Please do not edit these files manually.
//
// ------------------------------------------------

#nullable restore

using Elastic.Clients.Elasticsearch.Fluent;
using Elastic.Clients.Elasticsearch.Serialization;
using System;
using System.Collections.Generic;
using System.Linq.Expressions;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace Elastic.Clients.Elasticsearch.Core.ScriptsPainlessExecute;

public sealed partial class PainlessContextSetup
{
	/// <summary>
	/// <para>
	/// Document that's temporarily indexed in-memory and accessible from the script.
	/// </para>
	/// </summary>
	[JsonInclude, JsonPropertyName("document")]
	public object Document { get; set; }

	/// <summary>
	/// <para>
	/// Index containing a mapping that's compatible with the indexed document.
	/// You may specify a remote index by prefixing the index with the remote cluster alias.
	/// For example, <c>remote1:my_index</c> indicates that you want to run the painless script against the "my_index" index on the "remote1" cluster.
	/// This request will be forwarded to the "remote1" cluster if you have configured a connection to that remote cluster.
	/// </para>
	/// <para>
	/// NOTE: Wildcards are not accepted in the index expression for this endpoint.
	/// The expression <c>*:myindex</c> will return the error "No such remote cluster" and the expression <c>logs*</c> or <c>remote1:logs*</c> will return the error "index not found".
	/// </para>
	/// </summary>
	[JsonInclude, JsonPropertyName("index")]
	public Elastic.Clients.Elasticsearch.IndexName Index { get; set; }

	/// <summary>
	/// <para>
	/// Use this parameter to specify a query for computing a score.
	/// </para>
	/// </summary>
	[JsonInclude, JsonPropertyName("query")]
	public Elastic.Clients.Elasticsearch.QueryDsl.Query? Query { get; set; }
}

public sealed partial class PainlessContextSetupDescriptor<TDocument> : SerializableDescriptor<PainlessContextSetupDescriptor<TDocument>>
{
	internal PainlessContextSetupDescriptor(Action<PainlessContextSetupDescriptor<TDocument>> configure) => configure.Invoke(this);

	public PainlessContextSetupDescriptor() : base()
	{
	}

	private object DocumentValue { get; set; }
	private Elastic.Clients.Elasticsearch.IndexName IndexValue { get; set; }
	private Elastic.Clients.Elasticsearch.QueryDsl.Query? QueryValue { get; set; }
	private Elastic.Clients.Elasticsearch.QueryDsl.QueryDescriptor<TDocument> QueryDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.QueryDsl.QueryDescriptor<TDocument>> QueryDescriptorAction { get; set; }

	/// <summary>
	/// <para>
	/// Document that's temporarily indexed in-memory and accessible from the script.
	/// </para>
	/// </summary>
	public PainlessContextSetupDescriptor<TDocument> Document(object document)
	{
		DocumentValue = document;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Index containing a mapping that's compatible with the indexed document.
	/// You may specify a remote index by prefixing the index with the remote cluster alias.
	/// For example, <c>remote1:my_index</c> indicates that you want to run the painless script against the "my_index" index on the "remote1" cluster.
	/// This request will be forwarded to the "remote1" cluster if you have configured a connection to that remote cluster.
	/// </para>
	/// <para>
	/// NOTE: Wildcards are not accepted in the index expression for this endpoint.
	/// The expression <c>*:myindex</c> will return the error "No such remote cluster" and the expression <c>logs*</c> or <c>remote1:logs*</c> will return the error "index not found".
	/// </para>
	/// </summary>
	public PainlessContextSetupDescriptor<TDocument> Index(Elastic.Clients.Elasticsearch.IndexName index)
	{
		IndexValue = index;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Use this parameter to specify a query for computing a score.
	/// </para>
	/// </summary>
	public PainlessContextSetupDescriptor<TDocument> Query(Elastic.Clients.Elasticsearch.QueryDsl.Query? query)
	{
		QueryDescriptor = null;
		QueryDescriptorAction = null;
		QueryValue = query;
		return Self;
	}

	public PainlessContextSetupDescriptor<TDocument> Query(Elastic.Clients.Elasticsearch.QueryDsl.QueryDescriptor<TDocument> descriptor)
	{
		QueryValue = null;
		QueryDescriptorAction = null;
		QueryDescriptor = descriptor;
		return Self;
	}

	public PainlessContextSetupDescriptor<TDocument> Query(Action<Elastic.Clients.Elasticsearch.QueryDsl.QueryDescriptor<TDocument>> configure)
	{
		QueryValue = null;
		QueryDescriptor = null;
		QueryDescriptorAction = configure;
		return Self;
	}

	protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
	{
		writer.WriteStartObject();
		writer.WritePropertyName("document");
		JsonSerializer.Serialize(writer, DocumentValue, options);
		writer.WritePropertyName("index");
		JsonSerializer.Serialize(writer, IndexValue, options);
		if (QueryDescriptor is not null)
		{
			writer.WritePropertyName("query");
			JsonSerializer.Serialize(writer, QueryDescriptor, options);
		}
		else if (QueryDescriptorAction is not null)
		{
			writer.WritePropertyName("query");
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.QueryDsl.QueryDescriptor<TDocument>(QueryDescriptorAction), options);
		}
		else if (QueryValue is not null)
		{
			writer.WritePropertyName("query");
			JsonSerializer.Serialize(writer, QueryValue, options);
		}

		writer.WriteEndObject();
	}
}

public sealed partial class PainlessContextSetupDescriptor : SerializableDescriptor<PainlessContextSetupDescriptor>
{
	internal PainlessContextSetupDescriptor(Action<PainlessContextSetupDescriptor> configure) => configure.Invoke(this);

	public PainlessContextSetupDescriptor() : base()
	{
	}

	private object DocumentValue { get; set; }
	private Elastic.Clients.Elasticsearch.IndexName IndexValue { get; set; }
	private Elastic.Clients.Elasticsearch.QueryDsl.Query? QueryValue { get; set; }
	private Elastic.Clients.Elasticsearch.QueryDsl.QueryDescriptor QueryDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.QueryDsl.QueryDescriptor> QueryDescriptorAction { get; set; }

	/// <summary>
	/// <para>
	/// Document that's temporarily indexed in-memory and accessible from the script.
	/// </para>
	/// </summary>
	public PainlessContextSetupDescriptor Document(object document)
	{
		DocumentValue = document;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Index containing a mapping that's compatible with the indexed document.
	/// You may specify a remote index by prefixing the index with the remote cluster alias.
	/// For example, <c>remote1:my_index</c> indicates that you want to run the painless script against the "my_index" index on the "remote1" cluster.
	/// This request will be forwarded to the "remote1" cluster if you have configured a connection to that remote cluster.
	/// </para>
	/// <para>
	/// NOTE: Wildcards are not accepted in the index expression for this endpoint.
	/// The expression <c>*:myindex</c> will return the error "No such remote cluster" and the expression <c>logs*</c> or <c>remote1:logs*</c> will return the error "index not found".
	/// </para>
	/// </summary>
	public PainlessContextSetupDescriptor Index(Elastic.Clients.Elasticsearch.IndexName index)
	{
		IndexValue = index;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Use this parameter to specify a query for computing a score.
	/// </para>
	/// </summary>
	public PainlessContextSetupDescriptor Query(Elastic.Clients.Elasticsearch.QueryDsl.Query? query)
	{
		QueryDescriptor = null;
		QueryDescriptorAction = null;
		QueryValue = query;
		return Self;
	}

	public PainlessContextSetupDescriptor Query(Elastic.Clients.Elasticsearch.QueryDsl.QueryDescriptor descriptor)
	{
		QueryValue = null;
		QueryDescriptorAction = null;
		QueryDescriptor = descriptor;
		return Self;
	}

	public PainlessContextSetupDescriptor Query(Action<Elastic.Clients.Elasticsearch.QueryDsl.QueryDescriptor> configure)
	{
		QueryValue = null;
		QueryDescriptor = null;
		QueryDescriptorAction = configure;
		return Self;
	}

	protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
	{
		writer.WriteStartObject();
		writer.WritePropertyName("document");
		JsonSerializer.Serialize(writer, DocumentValue, options);
		writer.WritePropertyName("index");
		JsonSerializer.Serialize(writer, IndexValue, options);
		if (QueryDescriptor is not null)
		{
			writer.WritePropertyName("query");
			JsonSerializer.Serialize(writer, QueryDescriptor, options);
		}
		else if (QueryDescriptorAction is not null)
		{
			writer.WritePropertyName("query");
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.QueryDsl.QueryDescriptor(QueryDescriptorAction), options);
		}
		else if (QueryValue is not null)
		{
			writer.WritePropertyName("query");
			JsonSerializer.Serialize(writer, QueryValue, options);
		}

		writer.WriteEndObject();
	}
}