// Licensed to Elasticsearch B.V under one or more agreements.
// Elasticsearch B.V licenses this file to you under the Apache 2.0 License.
// See the LICENSE file in the project root for more information.
//
// ███╗   ██╗ ██████╗ ████████╗██╗ ██████╗███████╗
// ████╗  ██║██╔═══██╗╚══██╔══╝██║██╔════╝██╔════╝
// ██╔██╗ ██║██║   ██║   ██║   ██║██║     █████╗
// ██║╚██╗██║██║   ██║   ██║   ██║██║     ██╔══╝
// ██║ ╚████║╚██████╔╝   ██║   ██║╚██████╗███████╗
// ╚═╝  ╚═══╝ ╚═════╝    ╚═╝   ╚═╝ ╚═════╝╚══════╝
// ------------------------------------------------
//
// This file is automatically generated.
// Please do not edit these files manually.
//
// ------------------------------------------------

using System;
using System.Collections.Generic;
using System.Linq.Expressions;
using System.Text.Json;
using System.Text.Json.Serialization;

#nullable restore
namespace Elastic.Clients.Elasticsearch.Ingest
{
	public interface IProcessorContainerVariant
	{
		string ProcessorContainerVariantName { get; }
	}

	[JsonConverter(typeof(ProcessorContainerConverter))]
	public partial class ProcessorContainer : IContainer
	{
		public ProcessorContainer(IProcessorContainerVariant variant) => Variant = variant ?? throw new ArgumentNullException(nameof(variant));
		internal IProcessorContainerVariant Variant { get; }
	}

	internal sealed class ProcessorContainerConverter : JsonConverter<ProcessorContainer>
	{
		public override ProcessorContainer Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			var readerCopy = reader;
			readerCopy.Read();
			if (readerCopy.TokenType != JsonTokenType.PropertyName)
			{
				throw new JsonException();
			}

			var propertyName = readerCopy.GetString();
			if (propertyName == "attachment")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.AttachmentProcessor?>(ref reader, options);
				return new ProcessorContainer(variant);
			}

			if (propertyName == "append")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.AppendProcessor?>(ref reader, options);
				return new ProcessorContainer(variant);
			}

			if (propertyName == "csv")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.CsvProcessor?>(ref reader, options);
				return new ProcessorContainer(variant);
			}

			if (propertyName == "convert")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.ConvertProcessor?>(ref reader, options);
				return new ProcessorContainer(variant);
			}

			if (propertyName == "date")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.DateProcessor?>(ref reader, options);
				return new ProcessorContainer(variant);
			}

			if (propertyName == "date_index_name")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.DateIndexNameProcessor?>(ref reader, options);
				return new ProcessorContainer(variant);
			}

			if (propertyName == "dot_expander")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.DotExpanderProcessor?>(ref reader, options);
				return new ProcessorContainer(variant);
			}

			if (propertyName == "enrich")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.EnrichProcessor?>(ref reader, options);
				return new ProcessorContainer(variant);
			}

			if (propertyName == "fail")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.FailProcessor?>(ref reader, options);
				return new ProcessorContainer(variant);
			}

			if (propertyName == "foreach")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.ForeachProcessor?>(ref reader, options);
				return new ProcessorContainer(variant);
			}

			if (propertyName == "json")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.JsonProcessor?>(ref reader, options);
				return new ProcessorContainer(variant);
			}

			if (propertyName == "user_agent")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.UserAgentProcessor?>(ref reader, options);
				return new ProcessorContainer(variant);
			}

			if (propertyName == "kv")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.KeyValueProcessor?>(ref reader, options);
				return new ProcessorContainer(variant);
			}

			if (propertyName == "geoip")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.GeoIpProcessor?>(ref reader, options);
				return new ProcessorContainer(variant);
			}

			if (propertyName == "grok")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.GrokProcessor?>(ref reader, options);
				return new ProcessorContainer(variant);
			}

			if (propertyName == "gsub")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.GsubProcessor?>(ref reader, options);
				return new ProcessorContainer(variant);
			}

			if (propertyName == "join")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.JoinProcessor?>(ref reader, options);
				return new ProcessorContainer(variant);
			}

			if (propertyName == "lowercase")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.LowercaseProcessor?>(ref reader, options);
				return new ProcessorContainer(variant);
			}

			if (propertyName == "remove")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.RemoveProcessor?>(ref reader, options);
				return new ProcessorContainer(variant);
			}

			if (propertyName == "rename")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.RenameProcessor?>(ref reader, options);
				return new ProcessorContainer(variant);
			}

			if (propertyName == "set")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.SetProcessor?>(ref reader, options);
				return new ProcessorContainer(variant);
			}

			if (propertyName == "sort")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.SortProcessor?>(ref reader, options);
				return new ProcessorContainer(variant);
			}

			if (propertyName == "split")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.SplitProcessor?>(ref reader, options);
				return new ProcessorContainer(variant);
			}

			if (propertyName == "trim")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.TrimProcessor?>(ref reader, options);
				return new ProcessorContainer(variant);
			}

			if (propertyName == "uppercase")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.UppercaseProcessor?>(ref reader, options);
				return new ProcessorContainer(variant);
			}

			if (propertyName == "urldecode")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.UrlDecodeProcessor?>(ref reader, options);
				return new ProcessorContainer(variant);
			}

			if (propertyName == "bytes")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.BytesProcessor?>(ref reader, options);
				return new ProcessorContainer(variant);
			}

			if (propertyName == "dissect")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.DissectProcessor?>(ref reader, options);
				return new ProcessorContainer(variant);
			}

			if (propertyName == "set_security_user")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.SetSecurityUserProcessor?>(ref reader, options);
				return new ProcessorContainer(variant);
			}

			if (propertyName == "pipeline")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.PipelineProcessor?>(ref reader, options);
				return new ProcessorContainer(variant);
			}

			if (propertyName == "drop")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.DropProcessor?>(ref reader, options);
				return new ProcessorContainer(variant);
			}

			if (propertyName == "circle")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.CircleProcessor?>(ref reader, options);
				return new ProcessorContainer(variant);
			}

			if (propertyName == "inference")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.InferenceProcessor?>(ref reader, options);
				return new ProcessorContainer(variant);
			}

			throw new JsonException();
		}

		public override void Write(Utf8JsonWriter writer, ProcessorContainer value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName(value.Variant.ProcessorContainerVariantName);
			switch (value.Variant)
			{
				case Elastic.Clients.Elasticsearch.Ingest.AttachmentProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.AppendProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.CsvProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.ConvertProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.DateProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.DateIndexNameProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.DotExpanderProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.EnrichProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.FailProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.ForeachProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.JsonProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.UserAgentProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.KeyValueProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.GeoIpProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.GrokProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.GsubProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.JoinProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.LowercaseProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.RemoveProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.RenameProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.SetProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.SortProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.SplitProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.TrimProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.UppercaseProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.UrlDecodeProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.BytesProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.DissectProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.SetSecurityUserProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.PipelineProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.DropProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.CircleProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.InferenceProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
			}

			writer.WriteEndObject();
		}
	}

	public sealed partial class ProcessorContainerDescriptor<TDocument> : DescriptorBase<ProcessorContainerDescriptor<TDocument>>
	{
		public ProcessorContainerDescriptor()
		{
		}

		internal ProcessorContainerDescriptor(Action<ProcessorContainerDescriptor<TDocument>> configure) => configure.Invoke(this);
		internal bool ContainsVariant { get; private set; }

		internal string ContainedVariantName { get; private set; }

		internal ProcessorContainer Container { get; private set; }

		internal object ContainerVariantDescriptorAction { get; private set; }

		private void Set(object descriptorAction, string variantName)
		{
			if (ContainsVariant)
				throw new Exception("TODO");
			ContainerVariantDescriptorAction = descriptorAction;
			ContainedVariantName = variantName;
			ContainsVariant = true;
		}

		private void Set(IProcessorContainerVariant variant, string variantName)
		{
			if (ContainsVariant)
				throw new Exception("TODO");
			Container = new ProcessorContainer(variant);
			ContainedVariantName = variantName;
			ContainsVariant = true;
		}

		public void Attachment(AttachmentProcessor variant) => Set(variant, "attachment");
		public void Attachment(Action<AttachmentProcessorDescriptor<TDocument>> configure) => Set(configure, "attachment");
		public void Append(AppendProcessor variant) => Set(variant, "append");
		public void Append(Action<AppendProcessorDescriptor<TDocument>> configure) => Set(configure, "append");
		public void Csv(CsvProcessor variant) => Set(variant, "csv");
		public void Csv(Action<CsvProcessorDescriptor<TDocument>> configure) => Set(configure, "csv");
		public void Convert(ConvertProcessor variant) => Set(variant, "convert");
		public void Convert(Action<ConvertProcessorDescriptor<TDocument>> configure) => Set(configure, "convert");
		public void Date(DateProcessor variant) => Set(variant, "date");
		public void Date(Action<DateProcessorDescriptor<TDocument>> configure) => Set(configure, "date");
		public void DateIndexName(DateIndexNameProcessor variant) => Set(variant, "date_index_name");
		public void DateIndexName(Action<DateIndexNameProcessorDescriptor<TDocument>> configure) => Set(configure, "date_index_name");
		public void DotExpander(DotExpanderProcessor variant) => Set(variant, "dot_expander");
		public void DotExpander(Action<DotExpanderProcessorDescriptor<TDocument>> configure) => Set(configure, "dot_expander");
		public void Enrich(EnrichProcessor variant) => Set(variant, "enrich");
		public void Enrich(Action<EnrichProcessorDescriptor<TDocument>> configure) => Set(configure, "enrich");
		public void Fail(FailProcessor variant) => Set(variant, "fail");
		public void Fail(Action<FailProcessorDescriptor> configure) => Set(configure, "fail");
		public void Foreach(ForeachProcessor variant) => Set(variant, "foreach");
		public void Foreach(Action<ForeachProcessorDescriptor<TDocument>> configure) => Set(configure, "foreach");
		public void Json(JsonProcessor variant) => Set(variant, "json");
		public void Json(Action<JsonProcessorDescriptor<TDocument>> configure) => Set(configure, "json");
		public void UserAgent(UserAgentProcessor variant) => Set(variant, "user_agent");
		public void UserAgent(Action<UserAgentProcessorDescriptor<TDocument>> configure) => Set(configure, "user_agent");
		public void Kv(KeyValueProcessor variant) => Set(variant, "kv");
		public void Kv(Action<KeyValueProcessorDescriptor<TDocument>> configure) => Set(configure, "kv");
		public void Geoip(GeoIpProcessor variant) => Set(variant, "geoip");
		public void Geoip(Action<GeoIpProcessorDescriptor<TDocument>> configure) => Set(configure, "geoip");
		public void Grok(GrokProcessor variant) => Set(variant, "grok");
		public void Grok(Action<GrokProcessorDescriptor<TDocument>> configure) => Set(configure, "grok");
		public void Gsub(GsubProcessor variant) => Set(variant, "gsub");
		public void Gsub(Action<GsubProcessorDescriptor<TDocument>> configure) => Set(configure, "gsub");
		public void Join(JoinProcessor variant) => Set(variant, "join");
		public void Join(Action<JoinProcessorDescriptor<TDocument>> configure) => Set(configure, "join");
		public void Lowercase(LowercaseProcessor variant) => Set(variant, "lowercase");
		public void Lowercase(Action<LowercaseProcessorDescriptor<TDocument>> configure) => Set(configure, "lowercase");
		public void Remove(RemoveProcessor variant) => Set(variant, "remove");
		public void Remove(Action<RemoveProcessorDescriptor<TDocument>> configure) => Set(configure, "remove");
		public void Rename(RenameProcessor variant) => Set(variant, "rename");
		public void Rename(Action<RenameProcessorDescriptor<TDocument>> configure) => Set(configure, "rename");
		public void Set(SetProcessor variant) => Set(variant, "set");
		public void Set(Action<SetProcessorDescriptor<TDocument>> configure) => Set(configure, "set");
		public void Sort(SortProcessor variant) => Set(variant, "sort");
		public void Sort(Action<SortProcessorDescriptor<TDocument>> configure) => Set(configure, "sort");
		public void Split(SplitProcessor variant) => Set(variant, "split");
		public void Split(Action<SplitProcessorDescriptor<TDocument>> configure) => Set(configure, "split");
		public void Trim(TrimProcessor variant) => Set(variant, "trim");
		public void Trim(Action<TrimProcessorDescriptor<TDocument>> configure) => Set(configure, "trim");
		public void Uppercase(UppercaseProcessor variant) => Set(variant, "uppercase");
		public void Uppercase(Action<UppercaseProcessorDescriptor<TDocument>> configure) => Set(configure, "uppercase");
		public void Urldecode(UrlDecodeProcessor variant) => Set(variant, "urldecode");
		public void Urldecode(Action<UrlDecodeProcessorDescriptor<TDocument>> configure) => Set(configure, "urldecode");
		public void Bytes(BytesProcessor variant) => Set(variant, "bytes");
		public void Bytes(Action<BytesProcessorDescriptor<TDocument>> configure) => Set(configure, "bytes");
		public void Dissect(DissectProcessor variant) => Set(variant, "dissect");
		public void Dissect(Action<DissectProcessorDescriptor<TDocument>> configure) => Set(configure, "dissect");
		public void SetSecurityUser(SetSecurityUserProcessor variant) => Set(variant, "set_security_user");
		public void SetSecurityUser(Action<SetSecurityUserProcessorDescriptor<TDocument>> configure) => Set(configure, "set_security_user");
		public void Pipeline(PipelineProcessor variant) => Set(variant, "pipeline");
		public void Pipeline(Action<PipelineProcessorDescriptor> configure) => Set(configure, "pipeline");
		public void Drop(DropProcessor variant) => Set(variant, "drop");
		public void Drop(Action<DropProcessorDescriptor> configure) => Set(configure, "drop");
		public void Circle(CircleProcessor variant) => Set(variant, "circle");
		public void Circle(Action<CircleProcessorDescriptor<TDocument>> configure) => Set(configure, "circle");
		public void Inference(InferenceProcessor variant) => Set(variant, "inference");
		public void Inference(Action<InferenceProcessorDescriptor<TDocument>> configure) => Set(configure, "inference");
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			if (!ContainsVariant)
			{
				writer.WriteNullValue();
				return;
			}

			if (Container is not null)
			{
				JsonSerializer.Serialize(writer, Container, options);
				return;
			}

			writer.WriteStartObject();
			writer.WritePropertyName(ContainedVariantName);
			writer.WriteStartObject();
			if (ContainedVariantName == "attachment")
			{
				var descriptor = new AttachmentProcessorDescriptor<TDocument>();
				((Action<AttachmentProcessorDescriptor<TDocument>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "append")
			{
				var descriptor = new AppendProcessorDescriptor<TDocument>();
				((Action<AppendProcessorDescriptor<TDocument>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "csv")
			{
				var descriptor = new CsvProcessorDescriptor<TDocument>();
				((Action<CsvProcessorDescriptor<TDocument>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "convert")
			{
				var descriptor = new ConvertProcessorDescriptor<TDocument>();
				((Action<ConvertProcessorDescriptor<TDocument>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "date")
			{
				var descriptor = new DateProcessorDescriptor<TDocument>();
				((Action<DateProcessorDescriptor<TDocument>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "date_index_name")
			{
				var descriptor = new DateIndexNameProcessorDescriptor<TDocument>();
				((Action<DateIndexNameProcessorDescriptor<TDocument>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "dot_expander")
			{
				var descriptor = new DotExpanderProcessorDescriptor<TDocument>();
				((Action<DotExpanderProcessorDescriptor<TDocument>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "enrich")
			{
				var descriptor = new EnrichProcessorDescriptor<TDocument>();
				((Action<EnrichProcessorDescriptor<TDocument>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "fail")
			{
				var descriptor = new FailProcessorDescriptor();
				((Action<FailProcessorDescriptor>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "foreach")
			{
				var descriptor = new ForeachProcessorDescriptor<TDocument>();
				((Action<ForeachProcessorDescriptor<TDocument>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "json")
			{
				var descriptor = new JsonProcessorDescriptor<TDocument>();
				((Action<JsonProcessorDescriptor<TDocument>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "user_agent")
			{
				var descriptor = new UserAgentProcessorDescriptor<TDocument>();
				((Action<UserAgentProcessorDescriptor<TDocument>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "kv")
			{
				var descriptor = new KeyValueProcessorDescriptor<TDocument>();
				((Action<KeyValueProcessorDescriptor<TDocument>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "geoip")
			{
				var descriptor = new GeoIpProcessorDescriptor<TDocument>();
				((Action<GeoIpProcessorDescriptor<TDocument>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "grok")
			{
				var descriptor = new GrokProcessorDescriptor<TDocument>();
				((Action<GrokProcessorDescriptor<TDocument>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "gsub")
			{
				var descriptor = new GsubProcessorDescriptor<TDocument>();
				((Action<GsubProcessorDescriptor<TDocument>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "join")
			{
				var descriptor = new JoinProcessorDescriptor<TDocument>();
				((Action<JoinProcessorDescriptor<TDocument>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "lowercase")
			{
				var descriptor = new LowercaseProcessorDescriptor<TDocument>();
				((Action<LowercaseProcessorDescriptor<TDocument>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "remove")
			{
				var descriptor = new RemoveProcessorDescriptor<TDocument>();
				((Action<RemoveProcessorDescriptor<TDocument>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "rename")
			{
				var descriptor = new RenameProcessorDescriptor<TDocument>();
				((Action<RenameProcessorDescriptor<TDocument>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "set")
			{
				var descriptor = new SetProcessorDescriptor<TDocument>();
				((Action<SetProcessorDescriptor<TDocument>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "sort")
			{
				var descriptor = new SortProcessorDescriptor<TDocument>();
				((Action<SortProcessorDescriptor<TDocument>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "split")
			{
				var descriptor = new SplitProcessorDescriptor<TDocument>();
				((Action<SplitProcessorDescriptor<TDocument>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "trim")
			{
				var descriptor = new TrimProcessorDescriptor<TDocument>();
				((Action<TrimProcessorDescriptor<TDocument>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "uppercase")
			{
				var descriptor = new UppercaseProcessorDescriptor<TDocument>();
				((Action<UppercaseProcessorDescriptor<TDocument>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "urldecode")
			{
				var descriptor = new UrlDecodeProcessorDescriptor<TDocument>();
				((Action<UrlDecodeProcessorDescriptor<TDocument>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "bytes")
			{
				var descriptor = new BytesProcessorDescriptor<TDocument>();
				((Action<BytesProcessorDescriptor<TDocument>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "dissect")
			{
				var descriptor = new DissectProcessorDescriptor<TDocument>();
				((Action<DissectProcessorDescriptor<TDocument>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "set_security_user")
			{
				var descriptor = new SetSecurityUserProcessorDescriptor<TDocument>();
				((Action<SetSecurityUserProcessorDescriptor<TDocument>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "pipeline")
			{
				var descriptor = new PipelineProcessorDescriptor();
				((Action<PipelineProcessorDescriptor>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "drop")
			{
				var descriptor = new DropProcessorDescriptor();
				((Action<DropProcessorDescriptor>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "circle")
			{
				var descriptor = new CircleProcessorDescriptor<TDocument>();
				((Action<CircleProcessorDescriptor<TDocument>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "inference")
			{
				var descriptor = new InferenceProcessorDescriptor<TDocument>();
				((Action<InferenceProcessorDescriptor<TDocument>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			writer.WriteEndObject();
			writer.WriteEndObject();
			void Finalise()
			{
				writer.WriteEndObject();
				writer.WriteEndObject();
			}
		}
	}
}