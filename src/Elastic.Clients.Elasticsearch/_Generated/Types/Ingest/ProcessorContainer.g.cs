// Licensed to Elasticsearch B.V under one or more agreements.
// Elasticsearch B.V licenses this file to you under the Apache 2.0 License.
// See the LICENSE file in the project root for more information.
//
// ███╗   ██╗ ██████╗ ████████╗██╗ ██████╗███████╗
// ████╗  ██║██╔═══██╗╚══██╔══╝██║██╔════╝██╔════╝
// ██╔██╗ ██║██║   ██║   ██║   ██║██║     █████╗
// ██║╚██╗██║██║   ██║   ██║   ██║██║     ██╔══╝
// ██║ ╚████║╚██████╔╝   ██║   ██║╚██████╗███████╗
// ╚═╝  ╚═══╝ ╚═════╝    ╚═╝   ╚═╝ ╚═════╝╚══════╝
// ------------------------------------------------
//
// This file is automatically generated.
// Please do not edit these files manually.
//
// ------------------------------------------------

using System;
using System.Collections.Generic;
using System.Linq.Expressions;
using System.Text.Json;
using System.Text.Json.Serialization;

#nullable restore
namespace Elastic.Clients.Elasticsearch.Ingest
{
	public interface IProcessorContainerVariant
	{
		string ProcessorContainerVariantName { get; }
	}

	[JsonConverter(typeof(ProcessorContainerConverter))]
	public partial class ProcessorContainer : IContainer
	{
		public ProcessorContainer(IProcessorContainerVariant variant) => Variant = variant ?? throw new ArgumentNullException(nameof(variant));
		internal IProcessorContainerVariant Variant { get; }
	}

	internal sealed class ProcessorContainerConverter : JsonConverter<ProcessorContainer>
	{
		public override ProcessorContainer Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			var readerCopy = reader;
			readerCopy.Read();
			if (readerCopy.TokenType != JsonTokenType.PropertyName)
			{
				throw new JsonException();
			}

			var propertyName = readerCopy.GetString();
			if (propertyName == "append")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.AppendProcessor?>(ref reader, options);
				return new ProcessorContainer(variant);
			}

			if (propertyName == "attachment")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.AttachmentProcessor?>(ref reader, options);
				return new ProcessorContainer(variant);
			}

			if (propertyName == "bytes")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.BytesProcessor?>(ref reader, options);
				return new ProcessorContainer(variant);
			}

			if (propertyName == "circle")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.CircleProcessor?>(ref reader, options);
				return new ProcessorContainer(variant);
			}

			if (propertyName == "convert")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.ConvertProcessor?>(ref reader, options);
				return new ProcessorContainer(variant);
			}

			if (propertyName == "csv")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.CsvProcessor?>(ref reader, options);
				return new ProcessorContainer(variant);
			}

			if (propertyName == "date")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.DateProcessor?>(ref reader, options);
				return new ProcessorContainer(variant);
			}

			if (propertyName == "date_index_name")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.DateIndexNameProcessor?>(ref reader, options);
				return new ProcessorContainer(variant);
			}

			if (propertyName == "dissect")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.DissectProcessor?>(ref reader, options);
				return new ProcessorContainer(variant);
			}

			if (propertyName == "dot_expander")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.DotExpanderProcessor?>(ref reader, options);
				return new ProcessorContainer(variant);
			}

			if (propertyName == "drop")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.DropProcessor?>(ref reader, options);
				return new ProcessorContainer(variant);
			}

			if (propertyName == "enrich")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.EnrichProcessor?>(ref reader, options);
				return new ProcessorContainer(variant);
			}

			if (propertyName == "fail")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.FailProcessor?>(ref reader, options);
				return new ProcessorContainer(variant);
			}

			if (propertyName == "foreach")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.ForeachProcessor?>(ref reader, options);
				return new ProcessorContainer(variant);
			}

			if (propertyName == "geoip")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.GeoIpProcessor?>(ref reader, options);
				return new ProcessorContainer(variant);
			}

			if (propertyName == "grok")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.GrokProcessor?>(ref reader, options);
				return new ProcessorContainer(variant);
			}

			if (propertyName == "gsub")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.GsubProcessor?>(ref reader, options);
				return new ProcessorContainer(variant);
			}

			if (propertyName == "inference")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.InferenceProcessor?>(ref reader, options);
				return new ProcessorContainer(variant);
			}

			if (propertyName == "join")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.JoinProcessor?>(ref reader, options);
				return new ProcessorContainer(variant);
			}

			if (propertyName == "json")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.JsonProcessor?>(ref reader, options);
				return new ProcessorContainer(variant);
			}

			if (propertyName == "kv")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.KeyValueProcessor?>(ref reader, options);
				return new ProcessorContainer(variant);
			}

			if (propertyName == "lowercase")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.LowercaseProcessor?>(ref reader, options);
				return new ProcessorContainer(variant);
			}

			if (propertyName == "pipeline")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.PipelineProcessor?>(ref reader, options);
				return new ProcessorContainer(variant);
			}

			if (propertyName == "remove")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.RemoveProcessor?>(ref reader, options);
				return new ProcessorContainer(variant);
			}

			if (propertyName == "rename")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.RenameProcessor?>(ref reader, options);
				return new ProcessorContainer(variant);
			}

			if (propertyName == "set")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.SetProcessor?>(ref reader, options);
				return new ProcessorContainer(variant);
			}

			if (propertyName == "set_security_user")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.SetSecurityUserProcessor?>(ref reader, options);
				return new ProcessorContainer(variant);
			}

			if (propertyName == "sort")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.SortProcessor?>(ref reader, options);
				return new ProcessorContainer(variant);
			}

			if (propertyName == "split")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.SplitProcessor?>(ref reader, options);
				return new ProcessorContainer(variant);
			}

			if (propertyName == "trim")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.TrimProcessor?>(ref reader, options);
				return new ProcessorContainer(variant);
			}

			if (propertyName == "uppercase")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.UppercaseProcessor?>(ref reader, options);
				return new ProcessorContainer(variant);
			}

			if (propertyName == "urldecode")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.UrlDecodeProcessor?>(ref reader, options);
				return new ProcessorContainer(variant);
			}

			if (propertyName == "user_agent")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.UserAgentProcessor?>(ref reader, options);
				return new ProcessorContainer(variant);
			}

			throw new JsonException();
		}

		public override void Write(Utf8JsonWriter writer, ProcessorContainer value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName(value.Variant.ProcessorContainerVariantName);
			switch (value.Variant)
			{
				case Elastic.Clients.Elasticsearch.Ingest.AppendProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.AttachmentProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.BytesProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.CircleProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.ConvertProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.CsvProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.DateProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.DateIndexNameProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.DissectProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.DotExpanderProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.DropProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.EnrichProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.FailProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.ForeachProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.GeoIpProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.GrokProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.GsubProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.InferenceProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.JoinProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.JsonProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.KeyValueProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.LowercaseProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.PipelineProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.RemoveProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.RenameProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.SetProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.SetSecurityUserProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.SortProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.SplitProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.TrimProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.UppercaseProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.UrlDecodeProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.UserAgentProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
			}

			writer.WriteEndObject();
		}
	}

	public sealed partial class ProcessorContainerDescriptor<TDocument> : SerializableDescriptorBase<ProcessorContainerDescriptor<TDocument>>
	{
		internal ProcessorContainerDescriptor(Action<ProcessorContainerDescriptor<TDocument>> configure) => configure.Invoke(this);
		public ProcessorContainerDescriptor() : base()
		{
		}

		internal bool ContainsVariant { get; private set; }

		internal string ContainedVariantName { get; private set; }

		internal ProcessorContainer Container { get; private set; }

		internal Descriptor Descriptor { get; private set; }

		internal Type DescriptorType { get; private set; }

		private void Set<T>(Action<T> descriptorAction, string variantName)
			where T : Descriptor, new()
		{
			if (ContainsVariant)
				throw new Exception("TODO");
			ContainedVariantName = variantName;
			ContainsVariant = true;
			DescriptorType = typeof(T);
			var descriptor = new T();
			descriptorAction?.Invoke(descriptor);
			Descriptor = descriptor;
		}

		private void Set(IProcessorContainerVariant variant, string variantName)
		{
			if (ContainsVariant)
				throw new Exception("TODO");
			Container = new ProcessorContainer(variant);
			ContainedVariantName = variantName;
			ContainsVariant = true;
		}

		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			if (!ContainsVariant)
			{
				writer.WriteNullValue();
				return;
			}

			if (Container is not null)
			{
				JsonSerializer.Serialize(writer, Container, options);
				return;
			}

			writer.WriteStartObject();
			writer.WritePropertyName(ContainedVariantName);
			JsonSerializer.Serialize(writer, Descriptor, DescriptorType, options);
			writer.WriteEndObject();
		}

		public void Append(AppendProcessor variant) => Set(variant, "append");
		public void Append(Action<AppendProcessorDescriptor<TDocument>> configure) => Set(configure, "append");
		public void Attachment(AttachmentProcessor variant) => Set(variant, "attachment");
		public void Attachment(Action<AttachmentProcessorDescriptor<TDocument>> configure) => Set(configure, "attachment");
		public void Bytes(BytesProcessor variant) => Set(variant, "bytes");
		public void Bytes(Action<BytesProcessorDescriptor<TDocument>> configure) => Set(configure, "bytes");
		public void Circle(CircleProcessor variant) => Set(variant, "circle");
		public void Circle(Action<CircleProcessorDescriptor<TDocument>> configure) => Set(configure, "circle");
		public void Convert(ConvertProcessor variant) => Set(variant, "convert");
		public void Convert(Action<ConvertProcessorDescriptor<TDocument>> configure) => Set(configure, "convert");
		public void Csv(CsvProcessor variant) => Set(variant, "csv");
		public void Csv(Action<CsvProcessorDescriptor<TDocument>> configure) => Set(configure, "csv");
		public void Date(DateProcessor variant) => Set(variant, "date");
		public void Date(Action<DateProcessorDescriptor<TDocument>> configure) => Set(configure, "date");
		public void DateIndexName(DateIndexNameProcessor variant) => Set(variant, "date_index_name");
		public void DateIndexName(Action<DateIndexNameProcessorDescriptor<TDocument>> configure) => Set(configure, "date_index_name");
		public void Dissect(DissectProcessor variant) => Set(variant, "dissect");
		public void Dissect(Action<DissectProcessorDescriptor<TDocument>> configure) => Set(configure, "dissect");
		public void DotExpander(DotExpanderProcessor variant) => Set(variant, "dot_expander");
		public void DotExpander(Action<DotExpanderProcessorDescriptor<TDocument>> configure) => Set(configure, "dot_expander");
		public void Drop(DropProcessor variant) => Set(variant, "drop");
		public void Drop(Action<DropProcessorDescriptor> configure) => Set(configure, "drop");
		public void Enrich(EnrichProcessor variant) => Set(variant, "enrich");
		public void Enrich(Action<EnrichProcessorDescriptor<TDocument>> configure) => Set(configure, "enrich");
		public void Fail(FailProcessor variant) => Set(variant, "fail");
		public void Fail(Action<FailProcessorDescriptor> configure) => Set(configure, "fail");
		public void Foreach(ForeachProcessor variant) => Set(variant, "foreach");
		public void Foreach(Action<ForeachProcessorDescriptor<TDocument>> configure) => Set(configure, "foreach");
		public void Geoip(GeoIpProcessor variant) => Set(variant, "geoip");
		public void Geoip(Action<GeoIpProcessorDescriptor<TDocument>> configure) => Set(configure, "geoip");
		public void Grok(GrokProcessor variant) => Set(variant, "grok");
		public void Grok(Action<GrokProcessorDescriptor<TDocument>> configure) => Set(configure, "grok");
		public void Gsub(GsubProcessor variant) => Set(variant, "gsub");
		public void Gsub(Action<GsubProcessorDescriptor<TDocument>> configure) => Set(configure, "gsub");
		public void Inference(InferenceProcessor variant) => Set(variant, "inference");
		public void Inference(Action<InferenceProcessorDescriptor<TDocument>> configure) => Set(configure, "inference");
		public void Join(JoinProcessor variant) => Set(variant, "join");
		public void Join(Action<JoinProcessorDescriptor<TDocument>> configure) => Set(configure, "join");
		public void Json(JsonProcessor variant) => Set(variant, "json");
		public void Json(Action<JsonProcessorDescriptor<TDocument>> configure) => Set(configure, "json");
		public void Kv(KeyValueProcessor variant) => Set(variant, "kv");
		public void Kv(Action<KeyValueProcessorDescriptor<TDocument>> configure) => Set(configure, "kv");
		public void Lowercase(LowercaseProcessor variant) => Set(variant, "lowercase");
		public void Lowercase(Action<LowercaseProcessorDescriptor<TDocument>> configure) => Set(configure, "lowercase");
		public void Pipeline(PipelineProcessor variant) => Set(variant, "pipeline");
		public void Pipeline(Action<PipelineProcessorDescriptor> configure) => Set(configure, "pipeline");
		public void Remove(RemoveProcessor variant) => Set(variant, "remove");
		public void Remove(Action<RemoveProcessorDescriptor<TDocument>> configure) => Set(configure, "remove");
		public void Rename(RenameProcessor variant) => Set(variant, "rename");
		public void Rename(Action<RenameProcessorDescriptor<TDocument>> configure) => Set(configure, "rename");
		public void Set(SetProcessor variant) => Set(variant, "set");
		public void Set(Action<SetProcessorDescriptor<TDocument>> configure) => Set(configure, "set");
		public void SetSecurityUser(SetSecurityUserProcessor variant) => Set(variant, "set_security_user");
		public void SetSecurityUser(Action<SetSecurityUserProcessorDescriptor<TDocument>> configure) => Set(configure, "set_security_user");
		public void Sort(SortProcessor variant) => Set(variant, "sort");
		public void Sort(Action<SortProcessorDescriptor<TDocument>> configure) => Set(configure, "sort");
		public void Split(SplitProcessor variant) => Set(variant, "split");
		public void Split(Action<SplitProcessorDescriptor<TDocument>> configure) => Set(configure, "split");
		public void Trim(TrimProcessor variant) => Set(variant, "trim");
		public void Trim(Action<TrimProcessorDescriptor<TDocument>> configure) => Set(configure, "trim");
		public void Uppercase(UppercaseProcessor variant) => Set(variant, "uppercase");
		public void Uppercase(Action<UppercaseProcessorDescriptor<TDocument>> configure) => Set(configure, "uppercase");
		public void Urldecode(UrlDecodeProcessor variant) => Set(variant, "urldecode");
		public void Urldecode(Action<UrlDecodeProcessorDescriptor<TDocument>> configure) => Set(configure, "urldecode");
		public void UserAgent(UserAgentProcessor variant) => Set(variant, "user_agent");
		public void UserAgent(Action<UserAgentProcessorDescriptor<TDocument>> configure) => Set(configure, "user_agent");
	}

	public sealed partial class ProcessorContainerDescriptor : SerializableDescriptorBase<ProcessorContainerDescriptor>
	{
		internal ProcessorContainerDescriptor(Action<ProcessorContainerDescriptor> configure) => configure.Invoke(this);
		public ProcessorContainerDescriptor() : base()
		{
		}

		internal bool ContainsVariant { get; private set; }

		internal string ContainedVariantName { get; private set; }

		internal ProcessorContainer Container { get; private set; }

		internal Descriptor Descriptor { get; private set; }

		internal Type DescriptorType { get; private set; }

		private void Set<T>(Action<T> descriptorAction, string variantName)
			where T : Descriptor, new()
		{
			if (ContainsVariant)
				throw new Exception("TODO");
			ContainedVariantName = variantName;
			ContainsVariant = true;
			DescriptorType = typeof(T);
			var descriptor = new T();
			descriptorAction?.Invoke(descriptor);
			Descriptor = descriptor;
		}

		private void Set(IProcessorContainerVariant variant, string variantName)
		{
			if (ContainsVariant)
				throw new Exception("TODO");
			Container = new ProcessorContainer(variant);
			ContainedVariantName = variantName;
			ContainsVariant = true;
		}

		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			if (!ContainsVariant)
			{
				writer.WriteNullValue();
				return;
			}

			if (Container is not null)
			{
				JsonSerializer.Serialize(writer, Container, options);
				return;
			}

			writer.WriteStartObject();
			writer.WritePropertyName(ContainedVariantName);
			JsonSerializer.Serialize(writer, Descriptor, DescriptorType, options);
			writer.WriteEndObject();
		}

		public void Append(AppendProcessor variant) => Set(variant, "append");
		public void Append(Action<AppendProcessorDescriptor> configure) => Set(configure, "append");
		public void Append<TDocument>(Action<AppendProcessorDescriptor<TDocument>> configure) => Set(configure, "append");
		public void Attachment(AttachmentProcessor variant) => Set(variant, "attachment");
		public void Attachment(Action<AttachmentProcessorDescriptor> configure) => Set(configure, "attachment");
		public void Attachment<TDocument>(Action<AttachmentProcessorDescriptor<TDocument>> configure) => Set(configure, "attachment");
		public void Bytes(BytesProcessor variant) => Set(variant, "bytes");
		public void Bytes(Action<BytesProcessorDescriptor> configure) => Set(configure, "bytes");
		public void Bytes<TDocument>(Action<BytesProcessorDescriptor<TDocument>> configure) => Set(configure, "bytes");
		public void Circle(CircleProcessor variant) => Set(variant, "circle");
		public void Circle(Action<CircleProcessorDescriptor> configure) => Set(configure, "circle");
		public void Circle<TDocument>(Action<CircleProcessorDescriptor<TDocument>> configure) => Set(configure, "circle");
		public void Convert(ConvertProcessor variant) => Set(variant, "convert");
		public void Convert(Action<ConvertProcessorDescriptor> configure) => Set(configure, "convert");
		public void Convert<TDocument>(Action<ConvertProcessorDescriptor<TDocument>> configure) => Set(configure, "convert");
		public void Csv(CsvProcessor variant) => Set(variant, "csv");
		public void Csv(Action<CsvProcessorDescriptor> configure) => Set(configure, "csv");
		public void Csv<TDocument>(Action<CsvProcessorDescriptor<TDocument>> configure) => Set(configure, "csv");
		public void Date(DateProcessor variant) => Set(variant, "date");
		public void Date(Action<DateProcessorDescriptor> configure) => Set(configure, "date");
		public void Date<TDocument>(Action<DateProcessorDescriptor<TDocument>> configure) => Set(configure, "date");
		public void DateIndexName(DateIndexNameProcessor variant) => Set(variant, "date_index_name");
		public void DateIndexName(Action<DateIndexNameProcessorDescriptor> configure) => Set(configure, "date_index_name");
		public void DateIndexName<TDocument>(Action<DateIndexNameProcessorDescriptor<TDocument>> configure) => Set(configure, "date_index_name");
		public void Dissect(DissectProcessor variant) => Set(variant, "dissect");
		public void Dissect(Action<DissectProcessorDescriptor> configure) => Set(configure, "dissect");
		public void Dissect<TDocument>(Action<DissectProcessorDescriptor<TDocument>> configure) => Set(configure, "dissect");
		public void DotExpander(DotExpanderProcessor variant) => Set(variant, "dot_expander");
		public void DotExpander(Action<DotExpanderProcessorDescriptor> configure) => Set(configure, "dot_expander");
		public void DotExpander<TDocument>(Action<DotExpanderProcessorDescriptor<TDocument>> configure) => Set(configure, "dot_expander");
		public void Drop(DropProcessor variant) => Set(variant, "drop");
		public void Drop(Action<DropProcessorDescriptor> configure) => Set(configure, "drop");
		public void Enrich(EnrichProcessor variant) => Set(variant, "enrich");
		public void Enrich(Action<EnrichProcessorDescriptor> configure) => Set(configure, "enrich");
		public void Enrich<TDocument>(Action<EnrichProcessorDescriptor<TDocument>> configure) => Set(configure, "enrich");
		public void Fail(FailProcessor variant) => Set(variant, "fail");
		public void Fail(Action<FailProcessorDescriptor> configure) => Set(configure, "fail");
		public void Foreach(ForeachProcessor variant) => Set(variant, "foreach");
		public void Foreach(Action<ForeachProcessorDescriptor> configure) => Set(configure, "foreach");
		public void Foreach<TDocument>(Action<ForeachProcessorDescriptor<TDocument>> configure) => Set(configure, "foreach");
		public void Geoip(GeoIpProcessor variant) => Set(variant, "geoip");
		public void Geoip(Action<GeoIpProcessorDescriptor> configure) => Set(configure, "geoip");
		public void Geoip<TDocument>(Action<GeoIpProcessorDescriptor<TDocument>> configure) => Set(configure, "geoip");
		public void Grok(GrokProcessor variant) => Set(variant, "grok");
		public void Grok(Action<GrokProcessorDescriptor> configure) => Set(configure, "grok");
		public void Grok<TDocument>(Action<GrokProcessorDescriptor<TDocument>> configure) => Set(configure, "grok");
		public void Gsub(GsubProcessor variant) => Set(variant, "gsub");
		public void Gsub(Action<GsubProcessorDescriptor> configure) => Set(configure, "gsub");
		public void Gsub<TDocument>(Action<GsubProcessorDescriptor<TDocument>> configure) => Set(configure, "gsub");
		public void Inference(InferenceProcessor variant) => Set(variant, "inference");
		public void Inference(Action<InferenceProcessorDescriptor> configure) => Set(configure, "inference");
		public void Inference<TDocument>(Action<InferenceProcessorDescriptor<TDocument>> configure) => Set(configure, "inference");
		public void Join(JoinProcessor variant) => Set(variant, "join");
		public void Join(Action<JoinProcessorDescriptor> configure) => Set(configure, "join");
		public void Join<TDocument>(Action<JoinProcessorDescriptor<TDocument>> configure) => Set(configure, "join");
		public void Json(JsonProcessor variant) => Set(variant, "json");
		public void Json(Action<JsonProcessorDescriptor> configure) => Set(configure, "json");
		public void Json<TDocument>(Action<JsonProcessorDescriptor<TDocument>> configure) => Set(configure, "json");
		public void Kv(KeyValueProcessor variant) => Set(variant, "kv");
		public void Kv(Action<KeyValueProcessorDescriptor> configure) => Set(configure, "kv");
		public void Kv<TDocument>(Action<KeyValueProcessorDescriptor<TDocument>> configure) => Set(configure, "kv");
		public void Lowercase(LowercaseProcessor variant) => Set(variant, "lowercase");
		public void Lowercase(Action<LowercaseProcessorDescriptor> configure) => Set(configure, "lowercase");
		public void Lowercase<TDocument>(Action<LowercaseProcessorDescriptor<TDocument>> configure) => Set(configure, "lowercase");
		public void Pipeline(PipelineProcessor variant) => Set(variant, "pipeline");
		public void Pipeline(Action<PipelineProcessorDescriptor> configure) => Set(configure, "pipeline");
		public void Remove(RemoveProcessor variant) => Set(variant, "remove");
		public void Remove(Action<RemoveProcessorDescriptor> configure) => Set(configure, "remove");
		public void Remove<TDocument>(Action<RemoveProcessorDescriptor<TDocument>> configure) => Set(configure, "remove");
		public void Rename(RenameProcessor variant) => Set(variant, "rename");
		public void Rename(Action<RenameProcessorDescriptor> configure) => Set(configure, "rename");
		public void Rename<TDocument>(Action<RenameProcessorDescriptor<TDocument>> configure) => Set(configure, "rename");
		public void Set(SetProcessor variant) => Set(variant, "set");
		public void Set(Action<SetProcessorDescriptor> configure) => Set(configure, "set");
		public void Set<TDocument>(Action<SetProcessorDescriptor<TDocument>> configure) => Set(configure, "set");
		public void SetSecurityUser(SetSecurityUserProcessor variant) => Set(variant, "set_security_user");
		public void SetSecurityUser(Action<SetSecurityUserProcessorDescriptor> configure) => Set(configure, "set_security_user");
		public void SetSecurityUser<TDocument>(Action<SetSecurityUserProcessorDescriptor<TDocument>> configure) => Set(configure, "set_security_user");
		public void Sort(SortProcessor variant) => Set(variant, "sort");
		public void Sort(Action<SortProcessorDescriptor> configure) => Set(configure, "sort");
		public void Sort<TDocument>(Action<SortProcessorDescriptor<TDocument>> configure) => Set(configure, "sort");
		public void Split(SplitProcessor variant) => Set(variant, "split");
		public void Split(Action<SplitProcessorDescriptor> configure) => Set(configure, "split");
		public void Split<TDocument>(Action<SplitProcessorDescriptor<TDocument>> configure) => Set(configure, "split");
		public void Trim(TrimProcessor variant) => Set(variant, "trim");
		public void Trim(Action<TrimProcessorDescriptor> configure) => Set(configure, "trim");
		public void Trim<TDocument>(Action<TrimProcessorDescriptor<TDocument>> configure) => Set(configure, "trim");
		public void Uppercase(UppercaseProcessor variant) => Set(variant, "uppercase");
		public void Uppercase(Action<UppercaseProcessorDescriptor> configure) => Set(configure, "uppercase");
		public void Uppercase<TDocument>(Action<UppercaseProcessorDescriptor<TDocument>> configure) => Set(configure, "uppercase");
		public void Urldecode(UrlDecodeProcessor variant) => Set(variant, "urldecode");
		public void Urldecode(Action<UrlDecodeProcessorDescriptor> configure) => Set(configure, "urldecode");
		public void Urldecode<TDocument>(Action<UrlDecodeProcessorDescriptor<TDocument>> configure) => Set(configure, "urldecode");
		public void UserAgent(UserAgentProcessor variant) => Set(variant, "user_agent");
		public void UserAgent(Action<UserAgentProcessorDescriptor> configure) => Set(configure, "user_agent");
		public void UserAgent<TDocument>(Action<UserAgentProcessorDescriptor<TDocument>> configure) => Set(configure, "user_agent");
	}
}