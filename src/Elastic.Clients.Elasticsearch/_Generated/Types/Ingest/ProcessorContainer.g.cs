// Licensed to Elasticsearch B.V under one or more agreements.
// Elasticsearch B.V licenses this file to you under the Apache 2.0 License.
// See the LICENSE file in the project root for more information.
//
// ███╗   ██╗ ██████╗ ████████╗██╗ ██████╗███████╗
// ████╗  ██║██╔═══██╗╚══██╔══╝██║██╔════╝██╔════╝
// ██╔██╗ ██║██║   ██║   ██║   ██║██║     █████╗
// ██║╚██╗██║██║   ██║   ██║   ██║██║     ██╔══╝
// ██║ ╚████║╚██████╔╝   ██║   ██║╚██████╗███████╗
// ╚═╝  ╚═══╝ ╚═════╝    ╚═╝   ╚═╝ ╚═════╝╚══════╝
// ------------------------------------------------
//
// This file is automatically generated.
// Please do not edit these files manually.
//
// ------------------------------------------------

using System;
using System.Collections.Generic;
using System.Linq.Expressions;
using System.Text.Json;
using System.Text.Json.Serialization;

#nullable restore
namespace Elastic.Clients.Elasticsearch.Ingest
{
	public interface IProcessorVariant
	{
	}

	[JsonConverter(typeof(ProcessorContainerConverter))]
	public sealed partial class ProcessorContainer
	{
		internal ProcessorContainer(string variantName, IProcessorVariant variant)
		{
			if (variantName is null)
				throw new ArgumentNullException(nameof(variantName));
			if (variant is null)
				throw new ArgumentNullException(nameof(variant));
			if (string.IsNullOrWhiteSpace(variantName))
				throw new ArgumentException("Variant name must not be empty or whitespace.");
			VariantName = variantName;
			Variant = variant;
		}

		internal IProcessorVariant Variant { get; }

		internal string VariantName { get; }

		public static ProcessorContainer Append(Elastic.Clients.Elasticsearch.Ingest.AppendProcessor appendProcessor) => new ProcessorContainer("append", appendProcessor);
		public static ProcessorContainer Attachment(Elastic.Clients.Elasticsearch.Ingest.AttachmentProcessor attachmentProcessor) => new ProcessorContainer("attachment", attachmentProcessor);
		public static ProcessorContainer Bytes(Elastic.Clients.Elasticsearch.Ingest.BytesProcessor bytesProcessor) => new ProcessorContainer("bytes", bytesProcessor);
		public static ProcessorContainer Circle(Elastic.Clients.Elasticsearch.Ingest.CircleProcessor circleProcessor) => new ProcessorContainer("circle", circleProcessor);
		public static ProcessorContainer Convert(Elastic.Clients.Elasticsearch.Ingest.ConvertProcessor convertProcessor) => new ProcessorContainer("convert", convertProcessor);
		public static ProcessorContainer Csv(Elastic.Clients.Elasticsearch.Ingest.CsvProcessor csvProcessor) => new ProcessorContainer("csv", csvProcessor);
		public static ProcessorContainer Date(Elastic.Clients.Elasticsearch.Ingest.DateProcessor dateProcessor) => new ProcessorContainer("date", dateProcessor);
		public static ProcessorContainer DateIndexName(Elastic.Clients.Elasticsearch.Ingest.DateIndexNameProcessor dateIndexNameProcessor) => new ProcessorContainer("date_index_name", dateIndexNameProcessor);
		public static ProcessorContainer Dissect(Elastic.Clients.Elasticsearch.Ingest.DissectProcessor dissectProcessor) => new ProcessorContainer("dissect", dissectProcessor);
		public static ProcessorContainer DotExpander(Elastic.Clients.Elasticsearch.Ingest.DotExpanderProcessor dotExpanderProcessor) => new ProcessorContainer("dot_expander", dotExpanderProcessor);
		public static ProcessorContainer Drop(Elastic.Clients.Elasticsearch.Ingest.DropProcessor dropProcessor) => new ProcessorContainer("drop", dropProcessor);
		public static ProcessorContainer Enrich(Elastic.Clients.Elasticsearch.Ingest.EnrichProcessor enrichProcessor) => new ProcessorContainer("enrich", enrichProcessor);
		public static ProcessorContainer Fail(Elastic.Clients.Elasticsearch.Ingest.FailProcessor failProcessor) => new ProcessorContainer("fail", failProcessor);
		public static ProcessorContainer Foreach(Elastic.Clients.Elasticsearch.Ingest.ForeachProcessor foreachProcessor) => new ProcessorContainer("foreach", foreachProcessor);
		public static ProcessorContainer Geoip(Elastic.Clients.Elasticsearch.Ingest.GeoIpProcessor geoIpProcessor) => new ProcessorContainer("geoip", geoIpProcessor);
		public static ProcessorContainer Grok(Elastic.Clients.Elasticsearch.Ingest.GrokProcessor grokProcessor) => new ProcessorContainer("grok", grokProcessor);
		public static ProcessorContainer Gsub(Elastic.Clients.Elasticsearch.Ingest.GsubProcessor gsubProcessor) => new ProcessorContainer("gsub", gsubProcessor);
		public static ProcessorContainer Inference(Elastic.Clients.Elasticsearch.Ingest.InferenceProcessor inferenceProcessor) => new ProcessorContainer("inference", inferenceProcessor);
		public static ProcessorContainer Join(Elastic.Clients.Elasticsearch.Ingest.JoinProcessor joinProcessor) => new ProcessorContainer("join", joinProcessor);
		public static ProcessorContainer Json(Elastic.Clients.Elasticsearch.Ingest.JsonProcessor jsonProcessor) => new ProcessorContainer("json", jsonProcessor);
		public static ProcessorContainer Kv(Elastic.Clients.Elasticsearch.Ingest.KeyValueProcessor keyValueProcessor) => new ProcessorContainer("kv", keyValueProcessor);
		public static ProcessorContainer Lowercase(Elastic.Clients.Elasticsearch.Ingest.LowercaseProcessor lowercaseProcessor) => new ProcessorContainer("lowercase", lowercaseProcessor);
		public static ProcessorContainer Pipeline(Elastic.Clients.Elasticsearch.Ingest.PipelineProcessor pipelineProcessor) => new ProcessorContainer("pipeline", pipelineProcessor);
		public static ProcessorContainer Remove(Elastic.Clients.Elasticsearch.Ingest.RemoveProcessor removeProcessor) => new ProcessorContainer("remove", removeProcessor);
		public static ProcessorContainer Rename(Elastic.Clients.Elasticsearch.Ingest.RenameProcessor renameProcessor) => new ProcessorContainer("rename", renameProcessor);
		public static ProcessorContainer Set(Elastic.Clients.Elasticsearch.Ingest.SetProcessor setProcessor) => new ProcessorContainer("set", setProcessor);
		public static ProcessorContainer SetSecurityUser(Elastic.Clients.Elasticsearch.Ingest.SetSecurityUserProcessor setSecurityUserProcessor) => new ProcessorContainer("set_security_user", setSecurityUserProcessor);
		public static ProcessorContainer Sort(Elastic.Clients.Elasticsearch.Ingest.SortProcessor sortProcessor) => new ProcessorContainer("sort", sortProcessor);
		public static ProcessorContainer Split(Elastic.Clients.Elasticsearch.Ingest.SplitProcessor splitProcessor) => new ProcessorContainer("split", splitProcessor);
		public static ProcessorContainer Trim(Elastic.Clients.Elasticsearch.Ingest.TrimProcessor trimProcessor) => new ProcessorContainer("trim", trimProcessor);
		public static ProcessorContainer Uppercase(Elastic.Clients.Elasticsearch.Ingest.UppercaseProcessor uppercaseProcessor) => new ProcessorContainer("uppercase", uppercaseProcessor);
		public static ProcessorContainer Urldecode(Elastic.Clients.Elasticsearch.Ingest.UrlDecodeProcessor urlDecodeProcessor) => new ProcessorContainer("urldecode", urlDecodeProcessor);
		public static ProcessorContainer UserAgent(Elastic.Clients.Elasticsearch.Ingest.UserAgentProcessor userAgentProcessor) => new ProcessorContainer("user_agent", userAgentProcessor);
	}

	internal sealed class ProcessorContainerConverter : JsonConverter<ProcessorContainer>
	{
		public override ProcessorContainer Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			if (reader.TokenType != JsonTokenType.StartObject)
			{
				throw new JsonException("Expected start token.");
			}

			reader.Read();
			if (reader.TokenType != JsonTokenType.PropertyName)
			{
				throw new JsonException("Expected property name token.");
			}

			var propertyName = reader.GetString();
			reader.Read();
			if (propertyName == "append")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.AppendProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(propertyName, variant);
			}

			if (propertyName == "attachment")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.AttachmentProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(propertyName, variant);
			}

			if (propertyName == "bytes")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.BytesProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(propertyName, variant);
			}

			if (propertyName == "circle")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.CircleProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(propertyName, variant);
			}

			if (propertyName == "convert")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.ConvertProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(propertyName, variant);
			}

			if (propertyName == "csv")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.CsvProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(propertyName, variant);
			}

			if (propertyName == "date")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.DateProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(propertyName, variant);
			}

			if (propertyName == "date_index_name")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.DateIndexNameProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(propertyName, variant);
			}

			if (propertyName == "dissect")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.DissectProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(propertyName, variant);
			}

			if (propertyName == "dot_expander")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.DotExpanderProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(propertyName, variant);
			}

			if (propertyName == "drop")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.DropProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(propertyName, variant);
			}

			if (propertyName == "enrich")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.EnrichProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(propertyName, variant);
			}

			if (propertyName == "fail")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.FailProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(propertyName, variant);
			}

			if (propertyName == "foreach")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.ForeachProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(propertyName, variant);
			}

			if (propertyName == "geoip")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.GeoIpProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(propertyName, variant);
			}

			if (propertyName == "grok")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.GrokProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(propertyName, variant);
			}

			if (propertyName == "gsub")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.GsubProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(propertyName, variant);
			}

			if (propertyName == "inference")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.InferenceProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(propertyName, variant);
			}

			if (propertyName == "join")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.JoinProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(propertyName, variant);
			}

			if (propertyName == "json")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.JsonProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(propertyName, variant);
			}

			if (propertyName == "kv")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.KeyValueProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(propertyName, variant);
			}

			if (propertyName == "lowercase")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.LowercaseProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(propertyName, variant);
			}

			if (propertyName == "pipeline")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.PipelineProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(propertyName, variant);
			}

			if (propertyName == "remove")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.RemoveProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(propertyName, variant);
			}

			if (propertyName == "rename")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.RenameProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(propertyName, variant);
			}

			if (propertyName == "set")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.SetProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(propertyName, variant);
			}

			if (propertyName == "set_security_user")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.SetSecurityUserProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(propertyName, variant);
			}

			if (propertyName == "sort")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.SortProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(propertyName, variant);
			}

			if (propertyName == "split")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.SplitProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(propertyName, variant);
			}

			if (propertyName == "trim")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.TrimProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(propertyName, variant);
			}

			if (propertyName == "uppercase")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.UppercaseProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(propertyName, variant);
			}

			if (propertyName == "urldecode")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.UrlDecodeProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(propertyName, variant);
			}

			if (propertyName == "user_agent")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.UserAgentProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(propertyName, variant);
			}

			throw new JsonException();
		}

		public override void Write(Utf8JsonWriter writer, ProcessorContainer value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName(value.VariantName);
			switch (value.VariantName)
			{
				case "append":
					JsonSerializer.Serialize<Elastic.Clients.Elasticsearch.Ingest.AppendProcessor>(writer, (Elastic.Clients.Elasticsearch.Ingest.AppendProcessor)value.Variant, options);
					break;
				case "attachment":
					JsonSerializer.Serialize<Elastic.Clients.Elasticsearch.Ingest.AttachmentProcessor>(writer, (Elastic.Clients.Elasticsearch.Ingest.AttachmentProcessor)value.Variant, options);
					break;
				case "bytes":
					JsonSerializer.Serialize<Elastic.Clients.Elasticsearch.Ingest.BytesProcessor>(writer, (Elastic.Clients.Elasticsearch.Ingest.BytesProcessor)value.Variant, options);
					break;
				case "circle":
					JsonSerializer.Serialize<Elastic.Clients.Elasticsearch.Ingest.CircleProcessor>(writer, (Elastic.Clients.Elasticsearch.Ingest.CircleProcessor)value.Variant, options);
					break;
				case "convert":
					JsonSerializer.Serialize<Elastic.Clients.Elasticsearch.Ingest.ConvertProcessor>(writer, (Elastic.Clients.Elasticsearch.Ingest.ConvertProcessor)value.Variant, options);
					break;
				case "csv":
					JsonSerializer.Serialize<Elastic.Clients.Elasticsearch.Ingest.CsvProcessor>(writer, (Elastic.Clients.Elasticsearch.Ingest.CsvProcessor)value.Variant, options);
					break;
				case "date":
					JsonSerializer.Serialize<Elastic.Clients.Elasticsearch.Ingest.DateProcessor>(writer, (Elastic.Clients.Elasticsearch.Ingest.DateProcessor)value.Variant, options);
					break;
				case "date_index_name":
					JsonSerializer.Serialize<Elastic.Clients.Elasticsearch.Ingest.DateIndexNameProcessor>(writer, (Elastic.Clients.Elasticsearch.Ingest.DateIndexNameProcessor)value.Variant, options);
					break;
				case "dissect":
					JsonSerializer.Serialize<Elastic.Clients.Elasticsearch.Ingest.DissectProcessor>(writer, (Elastic.Clients.Elasticsearch.Ingest.DissectProcessor)value.Variant, options);
					break;
				case "dot_expander":
					JsonSerializer.Serialize<Elastic.Clients.Elasticsearch.Ingest.DotExpanderProcessor>(writer, (Elastic.Clients.Elasticsearch.Ingest.DotExpanderProcessor)value.Variant, options);
					break;
				case "drop":
					JsonSerializer.Serialize<Elastic.Clients.Elasticsearch.Ingest.DropProcessor>(writer, (Elastic.Clients.Elasticsearch.Ingest.DropProcessor)value.Variant, options);
					break;
				case "enrich":
					JsonSerializer.Serialize<Elastic.Clients.Elasticsearch.Ingest.EnrichProcessor>(writer, (Elastic.Clients.Elasticsearch.Ingest.EnrichProcessor)value.Variant, options);
					break;
				case "fail":
					JsonSerializer.Serialize<Elastic.Clients.Elasticsearch.Ingest.FailProcessor>(writer, (Elastic.Clients.Elasticsearch.Ingest.FailProcessor)value.Variant, options);
					break;
				case "foreach":
					JsonSerializer.Serialize<Elastic.Clients.Elasticsearch.Ingest.ForeachProcessor>(writer, (Elastic.Clients.Elasticsearch.Ingest.ForeachProcessor)value.Variant, options);
					break;
				case "geoip":
					JsonSerializer.Serialize<Elastic.Clients.Elasticsearch.Ingest.GeoIpProcessor>(writer, (Elastic.Clients.Elasticsearch.Ingest.GeoIpProcessor)value.Variant, options);
					break;
				case "grok":
					JsonSerializer.Serialize<Elastic.Clients.Elasticsearch.Ingest.GrokProcessor>(writer, (Elastic.Clients.Elasticsearch.Ingest.GrokProcessor)value.Variant, options);
					break;
				case "gsub":
					JsonSerializer.Serialize<Elastic.Clients.Elasticsearch.Ingest.GsubProcessor>(writer, (Elastic.Clients.Elasticsearch.Ingest.GsubProcessor)value.Variant, options);
					break;
				case "inference":
					JsonSerializer.Serialize<Elastic.Clients.Elasticsearch.Ingest.InferenceProcessor>(writer, (Elastic.Clients.Elasticsearch.Ingest.InferenceProcessor)value.Variant, options);
					break;
				case "join":
					JsonSerializer.Serialize<Elastic.Clients.Elasticsearch.Ingest.JoinProcessor>(writer, (Elastic.Clients.Elasticsearch.Ingest.JoinProcessor)value.Variant, options);
					break;
				case "json":
					JsonSerializer.Serialize<Elastic.Clients.Elasticsearch.Ingest.JsonProcessor>(writer, (Elastic.Clients.Elasticsearch.Ingest.JsonProcessor)value.Variant, options);
					break;
				case "kv":
					JsonSerializer.Serialize<Elastic.Clients.Elasticsearch.Ingest.KeyValueProcessor>(writer, (Elastic.Clients.Elasticsearch.Ingest.KeyValueProcessor)value.Variant, options);
					break;
				case "lowercase":
					JsonSerializer.Serialize<Elastic.Clients.Elasticsearch.Ingest.LowercaseProcessor>(writer, (Elastic.Clients.Elasticsearch.Ingest.LowercaseProcessor)value.Variant, options);
					break;
				case "pipeline":
					JsonSerializer.Serialize<Elastic.Clients.Elasticsearch.Ingest.PipelineProcessor>(writer, (Elastic.Clients.Elasticsearch.Ingest.PipelineProcessor)value.Variant, options);
					break;
				case "remove":
					JsonSerializer.Serialize<Elastic.Clients.Elasticsearch.Ingest.RemoveProcessor>(writer, (Elastic.Clients.Elasticsearch.Ingest.RemoveProcessor)value.Variant, options);
					break;
				case "rename":
					JsonSerializer.Serialize<Elastic.Clients.Elasticsearch.Ingest.RenameProcessor>(writer, (Elastic.Clients.Elasticsearch.Ingest.RenameProcessor)value.Variant, options);
					break;
				case "set":
					JsonSerializer.Serialize<Elastic.Clients.Elasticsearch.Ingest.SetProcessor>(writer, (Elastic.Clients.Elasticsearch.Ingest.SetProcessor)value.Variant, options);
					break;
				case "set_security_user":
					JsonSerializer.Serialize<Elastic.Clients.Elasticsearch.Ingest.SetSecurityUserProcessor>(writer, (Elastic.Clients.Elasticsearch.Ingest.SetSecurityUserProcessor)value.Variant, options);
					break;
				case "sort":
					JsonSerializer.Serialize<Elastic.Clients.Elasticsearch.Ingest.SortProcessor>(writer, (Elastic.Clients.Elasticsearch.Ingest.SortProcessor)value.Variant, options);
					break;
				case "split":
					JsonSerializer.Serialize<Elastic.Clients.Elasticsearch.Ingest.SplitProcessor>(writer, (Elastic.Clients.Elasticsearch.Ingest.SplitProcessor)value.Variant, options);
					break;
				case "trim":
					JsonSerializer.Serialize<Elastic.Clients.Elasticsearch.Ingest.TrimProcessor>(writer, (Elastic.Clients.Elasticsearch.Ingest.TrimProcessor)value.Variant, options);
					break;
				case "uppercase":
					JsonSerializer.Serialize<Elastic.Clients.Elasticsearch.Ingest.UppercaseProcessor>(writer, (Elastic.Clients.Elasticsearch.Ingest.UppercaseProcessor)value.Variant, options);
					break;
				case "urldecode":
					JsonSerializer.Serialize<Elastic.Clients.Elasticsearch.Ingest.UrlDecodeProcessor>(writer, (Elastic.Clients.Elasticsearch.Ingest.UrlDecodeProcessor)value.Variant, options);
					break;
				case "user_agent":
					JsonSerializer.Serialize<Elastic.Clients.Elasticsearch.Ingest.UserAgentProcessor>(writer, (Elastic.Clients.Elasticsearch.Ingest.UserAgentProcessor)value.Variant, options);
					break;
			}

			writer.WriteEndObject();
		}
	}

	public sealed partial class ProcessorContainerDescriptor<TDocument> : SerializableDescriptorBase<ProcessorContainerDescriptor<TDocument>>
	{
		internal ProcessorContainerDescriptor(Action<ProcessorContainerDescriptor<TDocument>> configure) => configure.Invoke(this);
		public ProcessorContainerDescriptor() : base()
		{
		}

		private bool ContainsVariant { get; set; }

		private string ContainedVariantName { get; set; }

		private object Variant { get; set; }

		private Descriptor Descriptor { get; set; }

		private void Set<T>(Action<T> descriptorAction, string variantName)
			where T : Descriptor
		{
			if (ContainsVariant)
				throw new InvalidOperationException("A variant has already been assigned to the ProcessorContainerDescriptor. Only a single ProcessorContainer variant can be added to this container type.");
			ContainedVariantName = variantName;
			ContainsVariant = true;
			var descriptor = (T)Activator.CreateInstance(typeof(T), true);
			descriptorAction?.Invoke(descriptor);
			Descriptor = descriptor;
		}

		private void Set(IProcessorVariant variant, string variantName)
		{
			if (ContainsVariant)
				throw new Exception("A variant has already been assigned to the ProcessorContainerDescriptor. Only a single ProcessorContainer variant can be added to this container type.");
			Variant = variant;
			ContainedVariantName = variantName;
			ContainsVariant = true;
		}

		public void Append(AppendProcessor variant) => Set(variant, "append");
		public void Append(Action<AppendProcessorDescriptor<TDocument>> configure) => Set(configure, "append");
		public void Attachment(AttachmentProcessor variant) => Set(variant, "attachment");
		public void Attachment(Action<AttachmentProcessorDescriptor<TDocument>> configure) => Set(configure, "attachment");
		public void Bytes(BytesProcessor variant) => Set(variant, "bytes");
		public void Bytes(Action<BytesProcessorDescriptor<TDocument>> configure) => Set(configure, "bytes");
		public void Circle(CircleProcessor variant) => Set(variant, "circle");
		public void Circle(Action<CircleProcessorDescriptor<TDocument>> configure) => Set(configure, "circle");
		public void Convert(ConvertProcessor variant) => Set(variant, "convert");
		public void Convert(Action<ConvertProcessorDescriptor<TDocument>> configure) => Set(configure, "convert");
		public void Csv(CsvProcessor variant) => Set(variant, "csv");
		public void Csv(Action<CsvProcessorDescriptor<TDocument>> configure) => Set(configure, "csv");
		public void Date(DateProcessor variant) => Set(variant, "date");
		public void Date(Action<DateProcessorDescriptor<TDocument>> configure) => Set(configure, "date");
		public void DateIndexName(DateIndexNameProcessor variant) => Set(variant, "date_index_name");
		public void DateIndexName(Action<DateIndexNameProcessorDescriptor<TDocument>> configure) => Set(configure, "date_index_name");
		public void Dissect(DissectProcessor variant) => Set(variant, "dissect");
		public void Dissect(Action<DissectProcessorDescriptor<TDocument>> configure) => Set(configure, "dissect");
		public void DotExpander(DotExpanderProcessor variant) => Set(variant, "dot_expander");
		public void DotExpander(Action<DotExpanderProcessorDescriptor<TDocument>> configure) => Set(configure, "dot_expander");
		public void Drop(DropProcessor variant) => Set(variant, "drop");
		public void Drop(Action<DropProcessorDescriptor<TDocument>> configure) => Set(configure, "drop");
		public void Enrich(EnrichProcessor variant) => Set(variant, "enrich");
		public void Enrich(Action<EnrichProcessorDescriptor<TDocument>> configure) => Set(configure, "enrich");
		public void Fail(FailProcessor variant) => Set(variant, "fail");
		public void Fail(Action<FailProcessorDescriptor<TDocument>> configure) => Set(configure, "fail");
		public void Foreach(ForeachProcessor variant) => Set(variant, "foreach");
		public void Foreach(Action<ForeachProcessorDescriptor<TDocument>> configure) => Set(configure, "foreach");
		public void Geoip(GeoIpProcessor variant) => Set(variant, "geoip");
		public void Geoip(Action<GeoIpProcessorDescriptor<TDocument>> configure) => Set(configure, "geoip");
		public void Grok(GrokProcessor variant) => Set(variant, "grok");
		public void Grok(Action<GrokProcessorDescriptor<TDocument>> configure) => Set(configure, "grok");
		public void Gsub(GsubProcessor variant) => Set(variant, "gsub");
		public void Gsub(Action<GsubProcessorDescriptor<TDocument>> configure) => Set(configure, "gsub");
		public void Inference(InferenceProcessor variant) => Set(variant, "inference");
		public void Inference(Action<InferenceProcessorDescriptor<TDocument>> configure) => Set(configure, "inference");
		public void Join(JoinProcessor variant) => Set(variant, "join");
		public void Join(Action<JoinProcessorDescriptor<TDocument>> configure) => Set(configure, "join");
		public void Json(JsonProcessor variant) => Set(variant, "json");
		public void Json(Action<JsonProcessorDescriptor<TDocument>> configure) => Set(configure, "json");
		public void Kv(KeyValueProcessor variant) => Set(variant, "kv");
		public void Kv(Action<KeyValueProcessorDescriptor<TDocument>> configure) => Set(configure, "kv");
		public void Lowercase(LowercaseProcessor variant) => Set(variant, "lowercase");
		public void Lowercase(Action<LowercaseProcessorDescriptor<TDocument>> configure) => Set(configure, "lowercase");
		public void Pipeline(PipelineProcessor variant) => Set(variant, "pipeline");
		public void Pipeline(Action<PipelineProcessorDescriptor<TDocument>> configure) => Set(configure, "pipeline");
		public void Remove(RemoveProcessor variant) => Set(variant, "remove");
		public void Remove(Action<RemoveProcessorDescriptor<TDocument>> configure) => Set(configure, "remove");
		public void Rename(RenameProcessor variant) => Set(variant, "rename");
		public void Rename(Action<RenameProcessorDescriptor<TDocument>> configure) => Set(configure, "rename");
		public void Set(SetProcessor variant) => Set(variant, "set");
		public void Set(Action<SetProcessorDescriptor<TDocument>> configure) => Set(configure, "set");
		public void SetSecurityUser(SetSecurityUserProcessor variant) => Set(variant, "set_security_user");
		public void SetSecurityUser(Action<SetSecurityUserProcessorDescriptor<TDocument>> configure) => Set(configure, "set_security_user");
		public void Sort(SortProcessor variant) => Set(variant, "sort");
		public void Sort(Action<SortProcessorDescriptor<TDocument>> configure) => Set(configure, "sort");
		public void Split(SplitProcessor variant) => Set(variant, "split");
		public void Split(Action<SplitProcessorDescriptor<TDocument>> configure) => Set(configure, "split");
		public void Trim(TrimProcessor variant) => Set(variant, "trim");
		public void Trim(Action<TrimProcessorDescriptor<TDocument>> configure) => Set(configure, "trim");
		public void Uppercase(UppercaseProcessor variant) => Set(variant, "uppercase");
		public void Uppercase(Action<UppercaseProcessorDescriptor<TDocument>> configure) => Set(configure, "uppercase");
		public void Urldecode(UrlDecodeProcessor variant) => Set(variant, "urldecode");
		public void Urldecode(Action<UrlDecodeProcessorDescriptor<TDocument>> configure) => Set(configure, "urldecode");
		public void UserAgent(UserAgentProcessor variant) => Set(variant, "user_agent");
		public void UserAgent(Action<UserAgentProcessorDescriptor<TDocument>> configure) => Set(configure, "user_agent");
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			if (!ContainsVariant)
			{
				writer.WriteNullValue();
				return;
			}

			writer.WriteStartObject();
			writer.WritePropertyName(ContainedVariantName);
			if (Variant is not null)
			{
				JsonSerializer.Serialize(writer, Variant, Variant.GetType(), options);
			}
			else
			{
				JsonSerializer.Serialize(writer, Descriptor, Descriptor.GetType(), options);
			}

			writer.WriteEndObject();
		}
	}

	public sealed partial class ProcessorContainerDescriptor : SerializableDescriptorBase<ProcessorContainerDescriptor>
	{
		internal ProcessorContainerDescriptor(Action<ProcessorContainerDescriptor> configure) => configure.Invoke(this);
		public ProcessorContainerDescriptor() : base()
		{
		}

		private bool ContainsVariant { get; set; }

		private string ContainedVariantName { get; set; }

		private object Variant { get; set; }

		private Descriptor Descriptor { get; set; }

		private void Set<T>(Action<T> descriptorAction, string variantName)
			where T : Descriptor
		{
			if (ContainsVariant)
				throw new InvalidOperationException("A variant has already been assigned to the ProcessorContainerDescriptor. Only a single ProcessorContainer variant can be added to this container type.");
			ContainedVariantName = variantName;
			ContainsVariant = true;
			var descriptor = (T)Activator.CreateInstance(typeof(T), true);
			descriptorAction?.Invoke(descriptor);
			Descriptor = descriptor;
		}

		private void Set(IProcessorVariant variant, string variantName)
		{
			if (ContainsVariant)
				throw new Exception("A variant has already been assigned to the ProcessorContainerDescriptor. Only a single ProcessorContainer variant can be added to this container type.");
			Variant = variant;
			ContainedVariantName = variantName;
			ContainsVariant = true;
		}

		public void Append(AppendProcessor variant) => Set(variant, "append");
		public void Append(Action<AppendProcessorDescriptor> configure) => Set(configure, "append");
		public void Append<TDocument>(Action<AppendProcessorDescriptor<TDocument>> configure) => Set(configure, "append");
		public void Attachment(AttachmentProcessor variant) => Set(variant, "attachment");
		public void Attachment(Action<AttachmentProcessorDescriptor> configure) => Set(configure, "attachment");
		public void Attachment<TDocument>(Action<AttachmentProcessorDescriptor<TDocument>> configure) => Set(configure, "attachment");
		public void Bytes(BytesProcessor variant) => Set(variant, "bytes");
		public void Bytes(Action<BytesProcessorDescriptor> configure) => Set(configure, "bytes");
		public void Bytes<TDocument>(Action<BytesProcessorDescriptor<TDocument>> configure) => Set(configure, "bytes");
		public void Circle(CircleProcessor variant) => Set(variant, "circle");
		public void Circle(Action<CircleProcessorDescriptor> configure) => Set(configure, "circle");
		public void Circle<TDocument>(Action<CircleProcessorDescriptor<TDocument>> configure) => Set(configure, "circle");
		public void Convert(ConvertProcessor variant) => Set(variant, "convert");
		public void Convert(Action<ConvertProcessorDescriptor> configure) => Set(configure, "convert");
		public void Convert<TDocument>(Action<ConvertProcessorDescriptor<TDocument>> configure) => Set(configure, "convert");
		public void Csv(CsvProcessor variant) => Set(variant, "csv");
		public void Csv(Action<CsvProcessorDescriptor> configure) => Set(configure, "csv");
		public void Csv<TDocument>(Action<CsvProcessorDescriptor<TDocument>> configure) => Set(configure, "csv");
		public void Date(DateProcessor variant) => Set(variant, "date");
		public void Date(Action<DateProcessorDescriptor> configure) => Set(configure, "date");
		public void Date<TDocument>(Action<DateProcessorDescriptor<TDocument>> configure) => Set(configure, "date");
		public void DateIndexName(DateIndexNameProcessor variant) => Set(variant, "date_index_name");
		public void DateIndexName(Action<DateIndexNameProcessorDescriptor> configure) => Set(configure, "date_index_name");
		public void DateIndexName<TDocument>(Action<DateIndexNameProcessorDescriptor<TDocument>> configure) => Set(configure, "date_index_name");
		public void Dissect(DissectProcessor variant) => Set(variant, "dissect");
		public void Dissect(Action<DissectProcessorDescriptor> configure) => Set(configure, "dissect");
		public void Dissect<TDocument>(Action<DissectProcessorDescriptor<TDocument>> configure) => Set(configure, "dissect");
		public void DotExpander(DotExpanderProcessor variant) => Set(variant, "dot_expander");
		public void DotExpander(Action<DotExpanderProcessorDescriptor> configure) => Set(configure, "dot_expander");
		public void DotExpander<TDocument>(Action<DotExpanderProcessorDescriptor<TDocument>> configure) => Set(configure, "dot_expander");
		public void Drop(DropProcessor variant) => Set(variant, "drop");
		public void Drop(Action<DropProcessorDescriptor> configure) => Set(configure, "drop");
		public void Drop<TDocument>(Action<DropProcessorDescriptor<TDocument>> configure) => Set(configure, "drop");
		public void Enrich(EnrichProcessor variant) => Set(variant, "enrich");
		public void Enrich(Action<EnrichProcessorDescriptor> configure) => Set(configure, "enrich");
		public void Enrich<TDocument>(Action<EnrichProcessorDescriptor<TDocument>> configure) => Set(configure, "enrich");
		public void Fail(FailProcessor variant) => Set(variant, "fail");
		public void Fail(Action<FailProcessorDescriptor> configure) => Set(configure, "fail");
		public void Fail<TDocument>(Action<FailProcessorDescriptor<TDocument>> configure) => Set(configure, "fail");
		public void Foreach(ForeachProcessor variant) => Set(variant, "foreach");
		public void Foreach(Action<ForeachProcessorDescriptor> configure) => Set(configure, "foreach");
		public void Foreach<TDocument>(Action<ForeachProcessorDescriptor<TDocument>> configure) => Set(configure, "foreach");
		public void Geoip(GeoIpProcessor variant) => Set(variant, "geoip");
		public void Geoip(Action<GeoIpProcessorDescriptor> configure) => Set(configure, "geoip");
		public void Geoip<TDocument>(Action<GeoIpProcessorDescriptor<TDocument>> configure) => Set(configure, "geoip");
		public void Grok(GrokProcessor variant) => Set(variant, "grok");
		public void Grok(Action<GrokProcessorDescriptor> configure) => Set(configure, "grok");
		public void Grok<TDocument>(Action<GrokProcessorDescriptor<TDocument>> configure) => Set(configure, "grok");
		public void Gsub(GsubProcessor variant) => Set(variant, "gsub");
		public void Gsub(Action<GsubProcessorDescriptor> configure) => Set(configure, "gsub");
		public void Gsub<TDocument>(Action<GsubProcessorDescriptor<TDocument>> configure) => Set(configure, "gsub");
		public void Inference(InferenceProcessor variant) => Set(variant, "inference");
		public void Inference(Action<InferenceProcessorDescriptor> configure) => Set(configure, "inference");
		public void Inference<TDocument>(Action<InferenceProcessorDescriptor<TDocument>> configure) => Set(configure, "inference");
		public void Join(JoinProcessor variant) => Set(variant, "join");
		public void Join(Action<JoinProcessorDescriptor> configure) => Set(configure, "join");
		public void Join<TDocument>(Action<JoinProcessorDescriptor<TDocument>> configure) => Set(configure, "join");
		public void Json(JsonProcessor variant) => Set(variant, "json");
		public void Json(Action<JsonProcessorDescriptor> configure) => Set(configure, "json");
		public void Json<TDocument>(Action<JsonProcessorDescriptor<TDocument>> configure) => Set(configure, "json");
		public void Kv(KeyValueProcessor variant) => Set(variant, "kv");
		public void Kv(Action<KeyValueProcessorDescriptor> configure) => Set(configure, "kv");
		public void Kv<TDocument>(Action<KeyValueProcessorDescriptor<TDocument>> configure) => Set(configure, "kv");
		public void Lowercase(LowercaseProcessor variant) => Set(variant, "lowercase");
		public void Lowercase(Action<LowercaseProcessorDescriptor> configure) => Set(configure, "lowercase");
		public void Lowercase<TDocument>(Action<LowercaseProcessorDescriptor<TDocument>> configure) => Set(configure, "lowercase");
		public void Pipeline(PipelineProcessor variant) => Set(variant, "pipeline");
		public void Pipeline(Action<PipelineProcessorDescriptor> configure) => Set(configure, "pipeline");
		public void Pipeline<TDocument>(Action<PipelineProcessorDescriptor<TDocument>> configure) => Set(configure, "pipeline");
		public void Remove(RemoveProcessor variant) => Set(variant, "remove");
		public void Remove(Action<RemoveProcessorDescriptor> configure) => Set(configure, "remove");
		public void Remove<TDocument>(Action<RemoveProcessorDescriptor<TDocument>> configure) => Set(configure, "remove");
		public void Rename(RenameProcessor variant) => Set(variant, "rename");
		public void Rename(Action<RenameProcessorDescriptor> configure) => Set(configure, "rename");
		public void Rename<TDocument>(Action<RenameProcessorDescriptor<TDocument>> configure) => Set(configure, "rename");
		public void Set(SetProcessor variant) => Set(variant, "set");
		public void Set(Action<SetProcessorDescriptor> configure) => Set(configure, "set");
		public void Set<TDocument>(Action<SetProcessorDescriptor<TDocument>> configure) => Set(configure, "set");
		public void SetSecurityUser(SetSecurityUserProcessor variant) => Set(variant, "set_security_user");
		public void SetSecurityUser(Action<SetSecurityUserProcessorDescriptor> configure) => Set(configure, "set_security_user");
		public void SetSecurityUser<TDocument>(Action<SetSecurityUserProcessorDescriptor<TDocument>> configure) => Set(configure, "set_security_user");
		public void Sort(SortProcessor variant) => Set(variant, "sort");
		public void Sort(Action<SortProcessorDescriptor> configure) => Set(configure, "sort");
		public void Sort<TDocument>(Action<SortProcessorDescriptor<TDocument>> configure) => Set(configure, "sort");
		public void Split(SplitProcessor variant) => Set(variant, "split");
		public void Split(Action<SplitProcessorDescriptor> configure) => Set(configure, "split");
		public void Split<TDocument>(Action<SplitProcessorDescriptor<TDocument>> configure) => Set(configure, "split");
		public void Trim(TrimProcessor variant) => Set(variant, "trim");
		public void Trim(Action<TrimProcessorDescriptor> configure) => Set(configure, "trim");
		public void Trim<TDocument>(Action<TrimProcessorDescriptor<TDocument>> configure) => Set(configure, "trim");
		public void Uppercase(UppercaseProcessor variant) => Set(variant, "uppercase");
		public void Uppercase(Action<UppercaseProcessorDescriptor> configure) => Set(configure, "uppercase");
		public void Uppercase<TDocument>(Action<UppercaseProcessorDescriptor<TDocument>> configure) => Set(configure, "uppercase");
		public void Urldecode(UrlDecodeProcessor variant) => Set(variant, "urldecode");
		public void Urldecode(Action<UrlDecodeProcessorDescriptor> configure) => Set(configure, "urldecode");
		public void Urldecode<TDocument>(Action<UrlDecodeProcessorDescriptor<TDocument>> configure) => Set(configure, "urldecode");
		public void UserAgent(UserAgentProcessor variant) => Set(variant, "user_agent");
		public void UserAgent(Action<UserAgentProcessorDescriptor> configure) => Set(configure, "user_agent");
		public void UserAgent<TDocument>(Action<UserAgentProcessorDescriptor<TDocument>> configure) => Set(configure, "user_agent");
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			if (!ContainsVariant)
			{
				writer.WriteNullValue();
				return;
			}

			writer.WriteStartObject();
			writer.WritePropertyName(ContainedVariantName);
			if (Variant is not null)
			{
				JsonSerializer.Serialize(writer, Variant, Variant.GetType(), options);
			}
			else
			{
				JsonSerializer.Serialize(writer, Descriptor, Descriptor.GetType(), options);
			}

			writer.WriteEndObject();
		}
	}
}