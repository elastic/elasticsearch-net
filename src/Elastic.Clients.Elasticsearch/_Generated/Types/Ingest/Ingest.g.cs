// Licensed to Elasticsearch B.V under one or more agreements.
// Elasticsearch B.V licenses this file to you under the Apache 2.0 License.
// See the LICENSE file in the project root for more information.
//
// ███╗   ██╗ ██████╗ ████████╗██╗ ██████╗███████╗
// ████╗  ██║██╔═══██╗╚══██╔══╝██║██╔════╝██╔════╝
// ██╔██╗ ██║██║   ██║   ██║   ██║██║     █████╗
// ██║╚██╗██║██║   ██║   ██║   ██║██║     ██╔══╝
// ██║ ╚████║╚██████╔╝   ██║   ██║╚██████╗███████╗
// ╚═╝  ╚═══╝ ╚═════╝    ╚═╝   ╚═╝ ╚═════╝╚══════╝
// ------------------------------------------------
//
// This file is automatically generated.
// Please do not edit these files manually.
//
// ------------------------------------------------

using System;
using System.Collections.Generic;
using System.Text.Json;
using System.Text.Json.Serialization;

#nullable restore
namespace Elastic.Clients.Elasticsearch.Ingest
{
	public partial class AppendProcessor : Ingest.ProcessorBase, IProcessorContainerVariant
	{
		[JsonIgnore]
		string Ingest.IProcessorContainerVariant.ProcessorContainerVariantName => "append";
		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("value")]
		public IEnumerable<object> Value { get; set; }

		[JsonInclude]
		[JsonPropertyName("allow_duplicates")]
		public bool? AllowDuplicates { get; set; }
	}

	[JsonConverter(typeof(AppendProcessorDescriptorConverter))]
	public sealed partial class AppendProcessorDescriptor : DescriptorBase<AppendProcessorDescriptor>, IProcessorContainerVariantDescriptor
	{
		public AppendProcessorDescriptor()
		{
		}

		internal AppendProcessorDescriptor(Action<AppendProcessorDescriptor> configure) => configure.Invoke(this);
		internal string FieldValue { get; private set; }

		internal IEnumerable<object> ValueValue { get; private set; }

		internal bool? AllowDuplicatesValue { get; private set; }

		public AppendProcessorDescriptor Field(string field) => Assign(field, (a, v) => a.FieldValue = v);
		public AppendProcessorDescriptor Value(IEnumerable<object> value) => Assign(value, (a, v) => a.ValueValue = v);
		public AppendProcessorDescriptor AllowDuplicates(bool? allowDuplicates = true) => Assign(allowDuplicates, (a, v) => a.AllowDuplicatesValue = v);
	}

	internal sealed class AppendProcessorDescriptorConverter : JsonConverter<AppendProcessorDescriptor>
	{
		public override AppendProcessorDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, AppendProcessorDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, value.FieldValue, options);
			writer.WritePropertyName("value");
			JsonSerializer.Serialize(writer, value.ValueValue, options);
			if (value.AllowDuplicatesValue.HasValue)
			{
				writer.WritePropertyName("allow_duplicates");
				writer.WriteBooleanValue(value.AllowDuplicatesValue.Value);
			}

			writer.WriteEndObject();
		}
	}

	public partial class AttachmentProcessor : Ingest.ProcessorBase, IProcessorContainerVariant
	{
		[JsonIgnore]
		string Ingest.IProcessorContainerVariant.ProcessorContainerVariantName => "attachment";
		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("ignore_missing")]
		public bool? IgnoreMissing { get; set; }

		[JsonInclude]
		[JsonPropertyName("indexed_chars")]
		public long? IndexedChars { get; set; }

		[JsonInclude]
		[JsonPropertyName("indexed_chars_field")]
		public string? IndexedCharsField { get; set; }

		[JsonInclude]
		[JsonPropertyName("properties")]
		public IEnumerable<string>? Properties { get; set; }

		[JsonInclude]
		[JsonPropertyName("target_field")]
		public string? TargetField { get; set; }

		[JsonInclude]
		[JsonPropertyName("resource_name")]
		public string? ResourceName { get; set; }
	}

	[JsonConverter(typeof(AttachmentProcessorDescriptorConverter))]
	public sealed partial class AttachmentProcessorDescriptor : DescriptorBase<AttachmentProcessorDescriptor>, IProcessorContainerVariantDescriptor
	{
		public AttachmentProcessorDescriptor()
		{
		}

		internal AttachmentProcessorDescriptor(Action<AttachmentProcessorDescriptor> configure) => configure.Invoke(this);
		internal string FieldValue { get; private set; }

		internal bool? IgnoreMissingValue { get; private set; }

		internal long? IndexedCharsValue { get; private set; }

		internal string? IndexedCharsFieldValue { get; private set; }

		internal IEnumerable<string>? PropertiesValue { get; private set; }

		internal string? TargetFieldValue { get; private set; }

		internal string? ResourceNameValue { get; private set; }

		public AttachmentProcessorDescriptor Field(string field) => Assign(field, (a, v) => a.FieldValue = v);
		public AttachmentProcessorDescriptor IgnoreMissing(bool? ignoreMissing = true) => Assign(ignoreMissing, (a, v) => a.IgnoreMissingValue = v);
		public AttachmentProcessorDescriptor IndexedChars(long? indexedChars) => Assign(indexedChars, (a, v) => a.IndexedCharsValue = v);
		public AttachmentProcessorDescriptor IndexedCharsField(string? indexedCharsField) => Assign(indexedCharsField, (a, v) => a.IndexedCharsFieldValue = v);
		public AttachmentProcessorDescriptor Properties(IEnumerable<string>? properties) => Assign(properties, (a, v) => a.PropertiesValue = v);
		public AttachmentProcessorDescriptor TargetField(string? targetField) => Assign(targetField, (a, v) => a.TargetFieldValue = v);
		public AttachmentProcessorDescriptor ResourceName(string? resourceName) => Assign(resourceName, (a, v) => a.ResourceNameValue = v);
	}

	internal sealed class AttachmentProcessorDescriptorConverter : JsonConverter<AttachmentProcessorDescriptor>
	{
		public override AttachmentProcessorDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, AttachmentProcessorDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, value.FieldValue, options);
			if (value.IgnoreMissingValue.HasValue)
			{
				writer.WritePropertyName("ignore_missing");
				writer.WriteBooleanValue(value.IgnoreMissingValue.Value);
			}

			if (value.IndexedCharsValue.HasValue)
			{
				writer.WritePropertyName("indexed_chars");
				writer.WriteNumberValue(value.IndexedCharsValue.Value);
			}

			if (value.IndexedCharsFieldValue is not null)
			{
				writer.WritePropertyName("indexed_chars_field");
				JsonSerializer.Serialize(writer, value.IndexedCharsFieldValue, options);
			}

			if (value.PropertiesValue is not null)
			{
				writer.WritePropertyName("properties");
				JsonSerializer.Serialize(writer, value.PropertiesValue, options);
			}

			if (value.TargetFieldValue is not null)
			{
				writer.WritePropertyName("target_field");
				JsonSerializer.Serialize(writer, value.TargetFieldValue, options);
			}

			if (!string.IsNullOrEmpty(value.ResourceNameValue))
			{
				writer.WritePropertyName("resource_name");
				writer.WriteStringValue(value.ResourceNameValue);
			}

			writer.WriteEndObject();
		}
	}

	public partial class BytesProcessor : Ingest.ProcessorBase, IProcessorContainerVariant
	{
		[JsonIgnore]
		string Ingest.IProcessorContainerVariant.ProcessorContainerVariantName => "bytes";
		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("ignore_missing")]
		public bool? IgnoreMissing { get; set; }

		[JsonInclude]
		[JsonPropertyName("target_field")]
		public string? TargetField { get; set; }
	}

	[JsonConverter(typeof(BytesProcessorDescriptorConverter))]
	public sealed partial class BytesProcessorDescriptor : DescriptorBase<BytesProcessorDescriptor>, IProcessorContainerVariantDescriptor
	{
		public BytesProcessorDescriptor()
		{
		}

		internal BytesProcessorDescriptor(Action<BytesProcessorDescriptor> configure) => configure.Invoke(this);
		internal string FieldValue { get; private set; }

		internal bool? IgnoreMissingValue { get; private set; }

		internal string? TargetFieldValue { get; private set; }

		public BytesProcessorDescriptor Field(string field) => Assign(field, (a, v) => a.FieldValue = v);
		public BytesProcessorDescriptor IgnoreMissing(bool? ignoreMissing = true) => Assign(ignoreMissing, (a, v) => a.IgnoreMissingValue = v);
		public BytesProcessorDescriptor TargetField(string? targetField) => Assign(targetField, (a, v) => a.TargetFieldValue = v);
	}

	internal sealed class BytesProcessorDescriptorConverter : JsonConverter<BytesProcessorDescriptor>
	{
		public override BytesProcessorDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, BytesProcessorDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, value.FieldValue, options);
			if (value.IgnoreMissingValue.HasValue)
			{
				writer.WritePropertyName("ignore_missing");
				writer.WriteBooleanValue(value.IgnoreMissingValue.Value);
			}

			if (value.TargetFieldValue is not null)
			{
				writer.WritePropertyName("target_field");
				JsonSerializer.Serialize(writer, value.TargetFieldValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class CircleProcessor : Ingest.ProcessorBase, IProcessorContainerVariant
	{
		[JsonIgnore]
		string Ingest.IProcessorContainerVariant.ProcessorContainerVariantName => "circle";
		[JsonInclude]
		[JsonPropertyName("error_distance")]
		public double ErrorDistance { get; set; }

		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("ignore_missing")]
		public bool IgnoreMissing { get; set; }

		[JsonInclude]
		[JsonPropertyName("shape_type")]
		public Elastic.Clients.Elasticsearch.Ingest.ShapeType ShapeType { get; set; }

		[JsonInclude]
		[JsonPropertyName("target_field")]
		public string TargetField { get; set; }
	}

	[JsonConverter(typeof(CircleProcessorDescriptorConverter))]
	public sealed partial class CircleProcessorDescriptor : DescriptorBase<CircleProcessorDescriptor>, IProcessorContainerVariantDescriptor
	{
		public CircleProcessorDescriptor()
		{
		}

		internal CircleProcessorDescriptor(Action<CircleProcessorDescriptor> configure) => configure.Invoke(this);
		internal double ErrorDistanceValue { get; private set; }

		internal string FieldValue { get; private set; }

		internal bool IgnoreMissingValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Ingest.ShapeType ShapeTypeValue { get; private set; }

		internal string TargetFieldValue { get; private set; }

		public CircleProcessorDescriptor ErrorDistance(double errorDistance) => Assign(errorDistance, (a, v) => a.ErrorDistanceValue = v);
		public CircleProcessorDescriptor Field(string field) => Assign(field, (a, v) => a.FieldValue = v);
		public CircleProcessorDescriptor IgnoreMissing(bool ignoreMissing = true) => Assign(ignoreMissing, (a, v) => a.IgnoreMissingValue = v);
		public CircleProcessorDescriptor ShapeType(Elastic.Clients.Elasticsearch.Ingest.ShapeType shapeType) => Assign(shapeType, (a, v) => a.ShapeTypeValue = v);
		public CircleProcessorDescriptor TargetField(string targetField) => Assign(targetField, (a, v) => a.TargetFieldValue = v);
	}

	internal sealed class CircleProcessorDescriptorConverter : JsonConverter<CircleProcessorDescriptor>
	{
		public override CircleProcessorDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, CircleProcessorDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("error_distance");
			writer.WriteNumberValue(value.ErrorDistanceValue);
			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, value.FieldValue, options);
			writer.WritePropertyName("ignore_missing");
			writer.WriteBooleanValue(value.IgnoreMissingValue);
			writer.WritePropertyName("shape_type");
			JsonSerializer.Serialize(writer, value.ShapeTypeValue, options);
			writer.WritePropertyName("target_field");
			JsonSerializer.Serialize(writer, value.TargetFieldValue, options);
			writer.WriteEndObject();
		}
	}

	public partial class ConvertProcessor : Ingest.ProcessorBase, IProcessorContainerVariant
	{
		[JsonIgnore]
		string Ingest.IProcessorContainerVariant.ProcessorContainerVariantName => "convert";
		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("ignore_missing")]
		public bool? IgnoreMissing { get; set; }

		[JsonInclude]
		[JsonPropertyName("target_field")]
		public string TargetField { get; set; }

		[JsonInclude]
		[JsonPropertyName("type")]
		public Elastic.Clients.Elasticsearch.Ingest.ConvertType Type { get; set; }
	}

	[JsonConverter(typeof(ConvertProcessorDescriptorConverter))]
	public sealed partial class ConvertProcessorDescriptor : DescriptorBase<ConvertProcessorDescriptor>, IProcessorContainerVariantDescriptor
	{
		public ConvertProcessorDescriptor()
		{
		}

		internal ConvertProcessorDescriptor(Action<ConvertProcessorDescriptor> configure) => configure.Invoke(this);
		internal string FieldValue { get; private set; }

		internal bool? IgnoreMissingValue { get; private set; }

		internal string TargetFieldValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Ingest.ConvertType TypeValue { get; private set; }

		public ConvertProcessorDescriptor Field(string field) => Assign(field, (a, v) => a.FieldValue = v);
		public ConvertProcessorDescriptor IgnoreMissing(bool? ignoreMissing = true) => Assign(ignoreMissing, (a, v) => a.IgnoreMissingValue = v);
		public ConvertProcessorDescriptor TargetField(string targetField) => Assign(targetField, (a, v) => a.TargetFieldValue = v);
		public ConvertProcessorDescriptor Type(Elastic.Clients.Elasticsearch.Ingest.ConvertType type) => Assign(type, (a, v) => a.TypeValue = v);
	}

	internal sealed class ConvertProcessorDescriptorConverter : JsonConverter<ConvertProcessorDescriptor>
	{
		public override ConvertProcessorDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, ConvertProcessorDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, value.FieldValue, options);
			if (value.IgnoreMissingValue.HasValue)
			{
				writer.WritePropertyName("ignore_missing");
				writer.WriteBooleanValue(value.IgnoreMissingValue.Value);
			}

			writer.WritePropertyName("target_field");
			JsonSerializer.Serialize(writer, value.TargetFieldValue, options);
			writer.WritePropertyName("type");
			JsonSerializer.Serialize(writer, value.TypeValue, options);
			writer.WriteEndObject();
		}
	}

	public partial class CsvProcessor : Ingest.ProcessorBase, IProcessorContainerVariant
	{
		[JsonIgnore]
		string Ingest.IProcessorContainerVariant.ProcessorContainerVariantName => "csv";
		[JsonInclude]
		[JsonPropertyName("empty_value")]
		public object EmptyValue { get; set; }

		[JsonInclude]
		[JsonPropertyName("description")]
		public string? Description { get; set; }

		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("ignore_missing")]
		public bool? IgnoreMissing { get; set; }

		[JsonInclude]
		[JsonPropertyName("quote")]
		public string? Quote { get; set; }

		[JsonInclude]
		[JsonPropertyName("separator")]
		public string? Separator { get; set; }

		[JsonInclude]
		[JsonPropertyName("target_fields")]
		public Elastic.Clients.Elasticsearch.Fields TargetFields { get; set; }

		[JsonInclude]
		[JsonPropertyName("trim")]
		public bool Trim { get; set; }
	}

	[JsonConverter(typeof(CsvProcessorDescriptorConverter))]
	public sealed partial class CsvProcessorDescriptor : DescriptorBase<CsvProcessorDescriptor>, IProcessorContainerVariantDescriptor
	{
		public CsvProcessorDescriptor()
		{
		}

		internal CsvProcessorDescriptor(Action<CsvProcessorDescriptor> configure) => configure.Invoke(this);
		internal object EmptyValueValue { get; private set; }

		internal string? DescriptionValue { get; private set; }

		internal string FieldValue { get; private set; }

		internal bool? IgnoreMissingValue { get; private set; }

		internal string? QuoteValue { get; private set; }

		internal string? SeparatorValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Fields TargetFieldsValue { get; private set; }

		internal bool TrimValue { get; private set; }

		public CsvProcessorDescriptor EmptyValue(object emptyValue) => Assign(emptyValue, (a, v) => a.EmptyValueValue = v);
		public CsvProcessorDescriptor Description(string? description) => Assign(description, (a, v) => a.DescriptionValue = v);
		public CsvProcessorDescriptor Field(string field) => Assign(field, (a, v) => a.FieldValue = v);
		public CsvProcessorDescriptor IgnoreMissing(bool? ignoreMissing = true) => Assign(ignoreMissing, (a, v) => a.IgnoreMissingValue = v);
		public CsvProcessorDescriptor Quote(string? quote) => Assign(quote, (a, v) => a.QuoteValue = v);
		public CsvProcessorDescriptor Separator(string? separator) => Assign(separator, (a, v) => a.SeparatorValue = v);
		public CsvProcessorDescriptor TargetFields(Elastic.Clients.Elasticsearch.Fields targetFields) => Assign(targetFields, (a, v) => a.TargetFieldsValue = v);
		public CsvProcessorDescriptor Trim(bool trim = true) => Assign(trim, (a, v) => a.TrimValue = v);
	}

	internal sealed class CsvProcessorDescriptorConverter : JsonConverter<CsvProcessorDescriptor>
	{
		public override CsvProcessorDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, CsvProcessorDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (!string.IsNullOrEmpty(value.DescriptionValue))
			{
				writer.WritePropertyName("description");
				writer.WriteStringValue(value.DescriptionValue);
			}

			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, value.FieldValue, options);
			if (value.IgnoreMissingValue.HasValue)
			{
				writer.WritePropertyName("ignore_missing");
				writer.WriteBooleanValue(value.IgnoreMissingValue.Value);
			}

			if (!string.IsNullOrEmpty(value.QuoteValue))
			{
				writer.WritePropertyName("quote");
				writer.WriteStringValue(value.QuoteValue);
			}

			if (!string.IsNullOrEmpty(value.SeparatorValue))
			{
				writer.WritePropertyName("separator");
				writer.WriteStringValue(value.SeparatorValue);
			}

			writer.WritePropertyName("target_fields");
			JsonSerializer.Serialize(writer, value.TargetFieldsValue, options);
			writer.WritePropertyName("trim");
			writer.WriteBooleanValue(value.TrimValue);
			writer.WriteEndObject();
		}
	}

	public partial class DateIndexNameProcessor : Ingest.ProcessorBase, IProcessorContainerVariant
	{
		[JsonIgnore]
		string Ingest.IProcessorContainerVariant.ProcessorContainerVariantName => "date_index_name";
		[JsonInclude]
		[JsonPropertyName("date_formats")]
		public IEnumerable<string> DateFormats { get; set; }

		[JsonInclude]
		[JsonPropertyName("date_rounding")]
		public Union<string, Elastic.Clients.Elasticsearch.Ingest.DateRounding> DateRounding { get; set; }

		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("index_name_format")]
		public string IndexNameFormat { get; set; }

		[JsonInclude]
		[JsonPropertyName("index_name_prefix")]
		public string IndexNamePrefix { get; set; }

		[JsonInclude]
		[JsonPropertyName("locale")]
		public string Locale { get; set; }

		[JsonInclude]
		[JsonPropertyName("timezone")]
		public string Timezone { get; set; }
	}

	[JsonConverter(typeof(DateIndexNameProcessorDescriptorConverter))]
	public sealed partial class DateIndexNameProcessorDescriptor : DescriptorBase<DateIndexNameProcessorDescriptor>, IProcessorContainerVariantDescriptor
	{
		public DateIndexNameProcessorDescriptor()
		{
		}

		internal DateIndexNameProcessorDescriptor(Action<DateIndexNameProcessorDescriptor> configure) => configure.Invoke(this);
		internal IEnumerable<string> DateFormatsValue { get; private set; }

		internal Union<string, Elastic.Clients.Elasticsearch.Ingest.DateRounding> DateRoundingValue { get; private set; }

		internal string FieldValue { get; private set; }

		internal string IndexNameFormatValue { get; private set; }

		internal string IndexNamePrefixValue { get; private set; }

		internal string LocaleValue { get; private set; }

		internal string TimezoneValue { get; private set; }

		public DateIndexNameProcessorDescriptor DateFormats(IEnumerable<string> dateFormats) => Assign(dateFormats, (a, v) => a.DateFormatsValue = v);
		public DateIndexNameProcessorDescriptor DateRounding(Union<string, Elastic.Clients.Elasticsearch.Ingest.DateRounding> dateRounding) => Assign(dateRounding, (a, v) => a.DateRoundingValue = v);
		public DateIndexNameProcessorDescriptor Field(string field) => Assign(field, (a, v) => a.FieldValue = v);
		public DateIndexNameProcessorDescriptor IndexNameFormat(string indexNameFormat) => Assign(indexNameFormat, (a, v) => a.IndexNameFormatValue = v);
		public DateIndexNameProcessorDescriptor IndexNamePrefix(string indexNamePrefix) => Assign(indexNamePrefix, (a, v) => a.IndexNamePrefixValue = v);
		public DateIndexNameProcessorDescriptor Locale(string locale) => Assign(locale, (a, v) => a.LocaleValue = v);
		public DateIndexNameProcessorDescriptor Timezone(string timezone) => Assign(timezone, (a, v) => a.TimezoneValue = v);
	}

	internal sealed class DateIndexNameProcessorDescriptorConverter : JsonConverter<DateIndexNameProcessorDescriptor>
	{
		public override DateIndexNameProcessorDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, DateIndexNameProcessorDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("date_formats");
			JsonSerializer.Serialize(writer, value.DateFormatsValue, options);
			writer.WritePropertyName("date_rounding");
			JsonSerializer.Serialize(writer, value.DateRoundingValue, options);
			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, value.FieldValue, options);
			writer.WritePropertyName("index_name_format");
			writer.WriteStringValue(value.IndexNameFormatValue);
			writer.WritePropertyName("index_name_prefix");
			writer.WriteStringValue(value.IndexNamePrefixValue);
			writer.WritePropertyName("locale");
			writer.WriteStringValue(value.LocaleValue);
			writer.WritePropertyName("timezone");
			writer.WriteStringValue(value.TimezoneValue);
			writer.WriteEndObject();
		}
	}

	public partial class DateProcessor : Ingest.ProcessorBase, IProcessorContainerVariant
	{
		[JsonIgnore]
		string Ingest.IProcessorContainerVariant.ProcessorContainerVariantName => "date";
		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("formats")]
		public IEnumerable<string> Formats { get; set; }

		[JsonInclude]
		[JsonPropertyName("locale")]
		public string? Locale { get; set; }

		[JsonInclude]
		[JsonPropertyName("target_field")]
		public string? TargetField { get; set; }

		[JsonInclude]
		[JsonPropertyName("timezone")]
		public string? Timezone { get; set; }
	}

	[JsonConverter(typeof(DateProcessorDescriptorConverter))]
	public sealed partial class DateProcessorDescriptor : DescriptorBase<DateProcessorDescriptor>, IProcessorContainerVariantDescriptor
	{
		public DateProcessorDescriptor()
		{
		}

		internal DateProcessorDescriptor(Action<DateProcessorDescriptor> configure) => configure.Invoke(this);
		internal string FieldValue { get; private set; }

		internal IEnumerable<string> FormatsValue { get; private set; }

		internal string? LocaleValue { get; private set; }

		internal string? TargetFieldValue { get; private set; }

		internal string? TimezoneValue { get; private set; }

		public DateProcessorDescriptor Field(string field) => Assign(field, (a, v) => a.FieldValue = v);
		public DateProcessorDescriptor Formats(IEnumerable<string> formats) => Assign(formats, (a, v) => a.FormatsValue = v);
		public DateProcessorDescriptor Locale(string? locale) => Assign(locale, (a, v) => a.LocaleValue = v);
		public DateProcessorDescriptor TargetField(string? targetField) => Assign(targetField, (a, v) => a.TargetFieldValue = v);
		public DateProcessorDescriptor Timezone(string? timezone) => Assign(timezone, (a, v) => a.TimezoneValue = v);
	}

	internal sealed class DateProcessorDescriptorConverter : JsonConverter<DateProcessorDescriptor>
	{
		public override DateProcessorDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, DateProcessorDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, value.FieldValue, options);
			writer.WritePropertyName("formats");
			JsonSerializer.Serialize(writer, value.FormatsValue, options);
			if (!string.IsNullOrEmpty(value.LocaleValue))
			{
				writer.WritePropertyName("locale");
				writer.WriteStringValue(value.LocaleValue);
			}

			if (value.TargetFieldValue is not null)
			{
				writer.WritePropertyName("target_field");
				JsonSerializer.Serialize(writer, value.TargetFieldValue, options);
			}

			if (!string.IsNullOrEmpty(value.TimezoneValue))
			{
				writer.WritePropertyName("timezone");
				writer.WriteStringValue(value.TimezoneValue);
			}

			writer.WriteEndObject();
		}
	}

	public partial class DissectProcessor : Ingest.ProcessorBase, IProcessorContainerVariant
	{
		[JsonIgnore]
		string Ingest.IProcessorContainerVariant.ProcessorContainerVariantName => "dissect";
		[JsonInclude]
		[JsonPropertyName("append_separator")]
		public string AppendSeparator { get; set; }

		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("ignore_missing")]
		public bool IgnoreMissing { get; set; }

		[JsonInclude]
		[JsonPropertyName("pattern")]
		public string Pattern { get; set; }
	}

	[JsonConverter(typeof(DissectProcessorDescriptorConverter))]
	public sealed partial class DissectProcessorDescriptor : DescriptorBase<DissectProcessorDescriptor>, IProcessorContainerVariantDescriptor
	{
		public DissectProcessorDescriptor()
		{
		}

		internal DissectProcessorDescriptor(Action<DissectProcessorDescriptor> configure) => configure.Invoke(this);
		internal string AppendSeparatorValue { get; private set; }

		internal string FieldValue { get; private set; }

		internal bool IgnoreMissingValue { get; private set; }

		internal string PatternValue { get; private set; }

		public DissectProcessorDescriptor AppendSeparator(string appendSeparator) => Assign(appendSeparator, (a, v) => a.AppendSeparatorValue = v);
		public DissectProcessorDescriptor Field(string field) => Assign(field, (a, v) => a.FieldValue = v);
		public DissectProcessorDescriptor IgnoreMissing(bool ignoreMissing = true) => Assign(ignoreMissing, (a, v) => a.IgnoreMissingValue = v);
		public DissectProcessorDescriptor Pattern(string pattern) => Assign(pattern, (a, v) => a.PatternValue = v);
	}

	internal sealed class DissectProcessorDescriptorConverter : JsonConverter<DissectProcessorDescriptor>
	{
		public override DissectProcessorDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, DissectProcessorDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("append_separator");
			writer.WriteStringValue(value.AppendSeparatorValue);
			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, value.FieldValue, options);
			writer.WritePropertyName("ignore_missing");
			writer.WriteBooleanValue(value.IgnoreMissingValue);
			writer.WritePropertyName("pattern");
			writer.WriteStringValue(value.PatternValue);
			writer.WriteEndObject();
		}
	}

	public partial class DotExpanderProcessor : Ingest.ProcessorBase, IProcessorContainerVariant
	{
		[JsonIgnore]
		string Ingest.IProcessorContainerVariant.ProcessorContainerVariantName => "dot_expander";
		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("path")]
		public string? Path { get; set; }
	}

	[JsonConverter(typeof(DotExpanderProcessorDescriptorConverter))]
	public sealed partial class DotExpanderProcessorDescriptor : DescriptorBase<DotExpanderProcessorDescriptor>, IProcessorContainerVariantDescriptor
	{
		public DotExpanderProcessorDescriptor()
		{
		}

		internal DotExpanderProcessorDescriptor(Action<DotExpanderProcessorDescriptor> configure) => configure.Invoke(this);
		internal string FieldValue { get; private set; }

		internal string? PathValue { get; private set; }

		public DotExpanderProcessorDescriptor Field(string field) => Assign(field, (a, v) => a.FieldValue = v);
		public DotExpanderProcessorDescriptor Path(string? path) => Assign(path, (a, v) => a.PathValue = v);
	}

	internal sealed class DotExpanderProcessorDescriptorConverter : JsonConverter<DotExpanderProcessorDescriptor>
	{
		public override DotExpanderProcessorDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, DotExpanderProcessorDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, value.FieldValue, options);
			if (!string.IsNullOrEmpty(value.PathValue))
			{
				writer.WritePropertyName("path");
				writer.WriteStringValue(value.PathValue);
			}

			writer.WriteEndObject();
		}
	}

	public partial class DropProcessor : Ingest.ProcessorBase, IProcessorContainerVariant
	{
		[JsonIgnore]
		string Ingest.IProcessorContainerVariant.ProcessorContainerVariantName => "drop";
	}

	[JsonConverter(typeof(DropProcessorDescriptorConverter))]
	public sealed partial class DropProcessorDescriptor : DescriptorBase<DropProcessorDescriptor>, IProcessorContainerVariantDescriptor
	{
		public DropProcessorDescriptor()
		{
		}

		internal DropProcessorDescriptor(Action<DropProcessorDescriptor> configure) => configure.Invoke(this);
	}

	internal sealed class DropProcessorDescriptorConverter : JsonConverter<DropProcessorDescriptor>
	{
		public override DropProcessorDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, DropProcessorDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WriteEndObject();
		}
	}

	public partial class EnrichProcessor : Ingest.ProcessorBase, IProcessorContainerVariant
	{
		[JsonIgnore]
		string Ingest.IProcessorContainerVariant.ProcessorContainerVariantName => "enrich";
		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("ignore_missing")]
		public bool? IgnoreMissing { get; set; }

		[JsonInclude]
		[JsonPropertyName("max_matches")]
		public int? MaxMatches { get; set; }

		[JsonInclude]
		[JsonPropertyName("override")]
		public bool? Override { get; set; }

		[JsonInclude]
		[JsonPropertyName("policy_name")]
		public string PolicyName { get; set; }

		[JsonInclude]
		[JsonPropertyName("shape_relation")]
		public Elastic.Clients.Elasticsearch.GeoShapeRelation? ShapeRelation { get; set; }

		[JsonInclude]
		[JsonPropertyName("target_field")]
		public string TargetField { get; set; }
	}

	[JsonConverter(typeof(EnrichProcessorDescriptorConverter))]
	public sealed partial class EnrichProcessorDescriptor : DescriptorBase<EnrichProcessorDescriptor>, IProcessorContainerVariantDescriptor
	{
		public EnrichProcessorDescriptor()
		{
		}

		internal EnrichProcessorDescriptor(Action<EnrichProcessorDescriptor> configure) => configure.Invoke(this);
		internal string FieldValue { get; private set; }

		internal bool? IgnoreMissingValue { get; private set; }

		internal int? MaxMatchesValue { get; private set; }

		internal bool? OverrideValue { get; private set; }

		internal string PolicyNameValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.GeoShapeRelation? ShapeRelationValue { get; private set; }

		internal string TargetFieldValue { get; private set; }

		public EnrichProcessorDescriptor Field(string field) => Assign(field, (a, v) => a.FieldValue = v);
		public EnrichProcessorDescriptor IgnoreMissing(bool? ignoreMissing = true) => Assign(ignoreMissing, (a, v) => a.IgnoreMissingValue = v);
		public EnrichProcessorDescriptor MaxMatches(int? maxMatches) => Assign(maxMatches, (a, v) => a.MaxMatchesValue = v);
		public EnrichProcessorDescriptor Override(bool? overrideValue = true) => Assign(overrideValue, (a, v) => a.OverrideValue = v);
		public EnrichProcessorDescriptor PolicyName(string policyName) => Assign(policyName, (a, v) => a.PolicyNameValue = v);
		public EnrichProcessorDescriptor ShapeRelation(Elastic.Clients.Elasticsearch.GeoShapeRelation? shapeRelation) => Assign(shapeRelation, (a, v) => a.ShapeRelationValue = v);
		public EnrichProcessorDescriptor TargetField(string targetField) => Assign(targetField, (a, v) => a.TargetFieldValue = v);
	}

	internal sealed class EnrichProcessorDescriptorConverter : JsonConverter<EnrichProcessorDescriptor>
	{
		public override EnrichProcessorDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, EnrichProcessorDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, value.FieldValue, options);
			if (value.IgnoreMissingValue.HasValue)
			{
				writer.WritePropertyName("ignore_missing");
				writer.WriteBooleanValue(value.IgnoreMissingValue.Value);
			}

			if (value.MaxMatchesValue.HasValue)
			{
				writer.WritePropertyName("max_matches");
				writer.WriteNumberValue(value.MaxMatchesValue.Value);
			}

			if (value.OverrideValue.HasValue)
			{
				writer.WritePropertyName("override");
				writer.WriteBooleanValue(value.OverrideValue.Value);
			}

			writer.WritePropertyName("policy_name");
			writer.WriteStringValue(value.PolicyNameValue);
			if (value.ShapeRelationValue is not null)
			{
				writer.WritePropertyName("shape_relation");
				JsonSerializer.Serialize(writer, value.ShapeRelationValue, options);
			}

			writer.WritePropertyName("target_field");
			JsonSerializer.Serialize(writer, value.TargetFieldValue, options);
			writer.WriteEndObject();
		}
	}

	public partial class FailProcessor : Ingest.ProcessorBase, IProcessorContainerVariant
	{
		[JsonIgnore]
		string Ingest.IProcessorContainerVariant.ProcessorContainerVariantName => "fail";
		[JsonInclude]
		[JsonPropertyName("message")]
		public string Message { get; set; }
	}

	[JsonConverter(typeof(FailProcessorDescriptorConverter))]
	public sealed partial class FailProcessorDescriptor : DescriptorBase<FailProcessorDescriptor>, IProcessorContainerVariantDescriptor
	{
		public FailProcessorDescriptor()
		{
		}

		internal FailProcessorDescriptor(Action<FailProcessorDescriptor> configure) => configure.Invoke(this);
		internal string MessageValue { get; private set; }

		public FailProcessorDescriptor Message(string message) => Assign(message, (a, v) => a.MessageValue = v);
	}

	internal sealed class FailProcessorDescriptorConverter : JsonConverter<FailProcessorDescriptor>
	{
		public override FailProcessorDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, FailProcessorDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("message");
			writer.WriteStringValue(value.MessageValue);
			writer.WriteEndObject();
		}
	}

	public partial class ForeachProcessor : Ingest.ProcessorBase, IProcessorContainerVariant
	{
		[JsonIgnore]
		string Ingest.IProcessorContainerVariant.ProcessorContainerVariantName => "foreach";
		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("ignore_missing")]
		public bool? IgnoreMissing { get; set; }

		[JsonInclude]
		[JsonPropertyName("processor")]
		public Elastic.Clients.Elasticsearch.Ingest.ProcessorContainer Processor { get; set; }
	}

	[JsonConverter(typeof(ForeachProcessorDescriptorConverter))]
	public sealed partial class ForeachProcessorDescriptor : DescriptorBase<ForeachProcessorDescriptor>, IProcessorContainerVariantDescriptor
	{
		public ForeachProcessorDescriptor()
		{
		}

		internal ForeachProcessorDescriptor(Action<ForeachProcessorDescriptor> configure) => configure.Invoke(this);
		internal string FieldValue { get; private set; }

		internal bool? IgnoreMissingValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Ingest.ProcessorContainer ProcessorValue { get; private set; }

		internal ProcessorContainerDescriptor ProcessorDescriptor { get; private set; }

		internal Action<ProcessorContainerDescriptor> ProcessorDescriptorAction { get; private set; }

		public ForeachProcessorDescriptor Field(string field) => Assign(field, (a, v) => a.FieldValue = v);
		public ForeachProcessorDescriptor IgnoreMissing(bool? ignoreMissing = true) => Assign(ignoreMissing, (a, v) => a.IgnoreMissingValue = v);
		public ForeachProcessorDescriptor Processor(Elastic.Clients.Elasticsearch.Ingest.ProcessorContainer processor)
		{
			ProcessorDescriptor = null;
			ProcessorDescriptorAction = null;
			return Assign(processor, (a, v) => a.ProcessorValue = v);
		}

		public ForeachProcessorDescriptor Processor(Elastic.Clients.Elasticsearch.Ingest.ProcessorContainerDescriptor descriptor)
		{
			ProcessorValue = null;
			ProcessorDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.ProcessorDescriptor = v);
		}

		public ForeachProcessorDescriptor Processor(Action<Elastic.Clients.Elasticsearch.Ingest.ProcessorContainerDescriptor> configure)
		{
			ProcessorValue = null;
			ProcessorDescriptorAction = null;
			return Assign(configure, (a, v) => a.ProcessorDescriptorAction = v);
		}
	}

	internal sealed class ForeachProcessorDescriptorConverter : JsonConverter<ForeachProcessorDescriptor>
	{
		public override ForeachProcessorDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, ForeachProcessorDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, value.FieldValue, options);
			if (value.IgnoreMissingValue.HasValue)
			{
				writer.WritePropertyName("ignore_missing");
				writer.WriteBooleanValue(value.IgnoreMissingValue.Value);
			}

			if (value.ProcessorDescriptor is not null)
			{
				writer.WritePropertyName("processor");
				JsonSerializer.Serialize(writer, value.ProcessorDescriptor, options);
			}
			else if (value.ProcessorDescriptorAction is not null)
			{
				writer.WritePropertyName("processor");
				JsonSerializer.Serialize(writer, new ProcessorContainerDescriptor(value.ProcessorDescriptorAction), options);
			}
			else
			{
				writer.WritePropertyName("processor");
				JsonSerializer.Serialize(writer, value.ProcessorValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class GeoIpProcessor : Ingest.ProcessorBase, IProcessorContainerVariant
	{
		[JsonIgnore]
		string Ingest.IProcessorContainerVariant.ProcessorContainerVariantName => "geoip";
		[JsonInclude]
		[JsonPropertyName("database_file")]
		public string DatabaseFile { get; set; }

		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("first_only")]
		public bool FirstOnly { get; set; }

		[JsonInclude]
		[JsonPropertyName("ignore_missing")]
		public bool IgnoreMissing { get; set; }

		[JsonInclude]
		[JsonPropertyName("properties")]
		public IEnumerable<string> Properties { get; set; }

		[JsonInclude]
		[JsonPropertyName("target_field")]
		public string TargetField { get; set; }
	}

	[JsonConverter(typeof(GeoIpProcessorDescriptorConverter))]
	public sealed partial class GeoIpProcessorDescriptor : DescriptorBase<GeoIpProcessorDescriptor>, IProcessorContainerVariantDescriptor
	{
		public GeoIpProcessorDescriptor()
		{
		}

		internal GeoIpProcessorDescriptor(Action<GeoIpProcessorDescriptor> configure) => configure.Invoke(this);
		internal string DatabaseFileValue { get; private set; }

		internal string FieldValue { get; private set; }

		internal bool FirstOnlyValue { get; private set; }

		internal bool IgnoreMissingValue { get; private set; }

		internal IEnumerable<string> PropertiesValue { get; private set; }

		internal string TargetFieldValue { get; private set; }

		public GeoIpProcessorDescriptor DatabaseFile(string databaseFile) => Assign(databaseFile, (a, v) => a.DatabaseFileValue = v);
		public GeoIpProcessorDescriptor Field(string field) => Assign(field, (a, v) => a.FieldValue = v);
		public GeoIpProcessorDescriptor FirstOnly(bool firstOnly = true) => Assign(firstOnly, (a, v) => a.FirstOnlyValue = v);
		public GeoIpProcessorDescriptor IgnoreMissing(bool ignoreMissing = true) => Assign(ignoreMissing, (a, v) => a.IgnoreMissingValue = v);
		public GeoIpProcessorDescriptor Properties(IEnumerable<string> properties) => Assign(properties, (a, v) => a.PropertiesValue = v);
		public GeoIpProcessorDescriptor TargetField(string targetField) => Assign(targetField, (a, v) => a.TargetFieldValue = v);
	}

	internal sealed class GeoIpProcessorDescriptorConverter : JsonConverter<GeoIpProcessorDescriptor>
	{
		public override GeoIpProcessorDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, GeoIpProcessorDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("database_file");
			writer.WriteStringValue(value.DatabaseFileValue);
			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, value.FieldValue, options);
			writer.WritePropertyName("first_only");
			writer.WriteBooleanValue(value.FirstOnlyValue);
			writer.WritePropertyName("ignore_missing");
			writer.WriteBooleanValue(value.IgnoreMissingValue);
			writer.WritePropertyName("properties");
			JsonSerializer.Serialize(writer, value.PropertiesValue, options);
			writer.WritePropertyName("target_field");
			JsonSerializer.Serialize(writer, value.TargetFieldValue, options);
			writer.WriteEndObject();
		}
	}

	public partial class GrokProcessor : Ingest.ProcessorBase, IProcessorContainerVariant
	{
		[JsonIgnore]
		string Ingest.IProcessorContainerVariant.ProcessorContainerVariantName => "grok";
		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("ignore_missing")]
		public bool? IgnoreMissing { get; set; }

		[JsonInclude]
		[JsonPropertyName("pattern_definitions")]
		public Dictionary<string, string> PatternDefinitions { get; set; }

		[JsonInclude]
		[JsonPropertyName("patterns")]
		public IEnumerable<string> Patterns { get; set; }

		[JsonInclude]
		[JsonPropertyName("trace_match")]
		public bool? TraceMatch { get; set; }
	}

	[JsonConverter(typeof(GrokProcessorDescriptorConverter))]
	public sealed partial class GrokProcessorDescriptor : DescriptorBase<GrokProcessorDescriptor>, IProcessorContainerVariantDescriptor
	{
		public GrokProcessorDescriptor()
		{
		}

		internal GrokProcessorDescriptor(Action<GrokProcessorDescriptor> configure) => configure.Invoke(this);
		internal string FieldValue { get; private set; }

		internal bool? IgnoreMissingValue { get; private set; }

		internal Dictionary<string, string> PatternDefinitionsValue { get; private set; }

		internal IEnumerable<string> PatternsValue { get; private set; }

		internal bool? TraceMatchValue { get; private set; }

		public GrokProcessorDescriptor Field(string field) => Assign(field, (a, v) => a.FieldValue = v);
		public GrokProcessorDescriptor IgnoreMissing(bool? ignoreMissing = true) => Assign(ignoreMissing, (a, v) => a.IgnoreMissingValue = v);
		public GrokProcessorDescriptor PatternDefinitions(Func<FluentDictionary<string, string>, FluentDictionary<string, string>> selector) => Assign(selector, (a, v) => a.PatternDefinitionsValue = v?.Invoke(new FluentDictionary<string, string>()));
		public GrokProcessorDescriptor Patterns(IEnumerable<string> patterns) => Assign(patterns, (a, v) => a.PatternsValue = v);
		public GrokProcessorDescriptor TraceMatch(bool? traceMatch = true) => Assign(traceMatch, (a, v) => a.TraceMatchValue = v);
	}

	internal sealed class GrokProcessorDescriptorConverter : JsonConverter<GrokProcessorDescriptor>
	{
		public override GrokProcessorDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, GrokProcessorDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, value.FieldValue, options);
			if (value.IgnoreMissingValue.HasValue)
			{
				writer.WritePropertyName("ignore_missing");
				writer.WriteBooleanValue(value.IgnoreMissingValue.Value);
			}

			writer.WritePropertyName("pattern_definitions");
			JsonSerializer.Serialize(writer, value.PatternDefinitionsValue, options);
			writer.WritePropertyName("patterns");
			JsonSerializer.Serialize(writer, value.PatternsValue, options);
			if (value.TraceMatchValue.HasValue)
			{
				writer.WritePropertyName("trace_match");
				writer.WriteBooleanValue(value.TraceMatchValue.Value);
			}

			writer.WriteEndObject();
		}
	}

	public partial class GsubProcessor : Ingest.ProcessorBase, IProcessorContainerVariant
	{
		[JsonIgnore]
		string Ingest.IProcessorContainerVariant.ProcessorContainerVariantName => "gsub";
		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("ignore_missing")]
		public bool? IgnoreMissing { get; set; }

		[JsonInclude]
		[JsonPropertyName("pattern")]
		public string Pattern { get; set; }

		[JsonInclude]
		[JsonPropertyName("replacement")]
		public string Replacement { get; set; }

		[JsonInclude]
		[JsonPropertyName("target_field")]
		public string? TargetField { get; set; }
	}

	[JsonConverter(typeof(GsubProcessorDescriptorConverter))]
	public sealed partial class GsubProcessorDescriptor : DescriptorBase<GsubProcessorDescriptor>, IProcessorContainerVariantDescriptor
	{
		public GsubProcessorDescriptor()
		{
		}

		internal GsubProcessorDescriptor(Action<GsubProcessorDescriptor> configure) => configure.Invoke(this);
		internal string FieldValue { get; private set; }

		internal bool? IgnoreMissingValue { get; private set; }

		internal string PatternValue { get; private set; }

		internal string ReplacementValue { get; private set; }

		internal string? TargetFieldValue { get; private set; }

		public GsubProcessorDescriptor Field(string field) => Assign(field, (a, v) => a.FieldValue = v);
		public GsubProcessorDescriptor IgnoreMissing(bool? ignoreMissing = true) => Assign(ignoreMissing, (a, v) => a.IgnoreMissingValue = v);
		public GsubProcessorDescriptor Pattern(string pattern) => Assign(pattern, (a, v) => a.PatternValue = v);
		public GsubProcessorDescriptor Replacement(string replacement) => Assign(replacement, (a, v) => a.ReplacementValue = v);
		public GsubProcessorDescriptor TargetField(string? targetField) => Assign(targetField, (a, v) => a.TargetFieldValue = v);
	}

	internal sealed class GsubProcessorDescriptorConverter : JsonConverter<GsubProcessorDescriptor>
	{
		public override GsubProcessorDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, GsubProcessorDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, value.FieldValue, options);
			if (value.IgnoreMissingValue.HasValue)
			{
				writer.WritePropertyName("ignore_missing");
				writer.WriteBooleanValue(value.IgnoreMissingValue.Value);
			}

			writer.WritePropertyName("pattern");
			writer.WriteStringValue(value.PatternValue);
			writer.WritePropertyName("replacement");
			writer.WriteStringValue(value.ReplacementValue);
			if (value.TargetFieldValue is not null)
			{
				writer.WritePropertyName("target_field");
				JsonSerializer.Serialize(writer, value.TargetFieldValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class InferenceConfig
	{
		[JsonInclude]
		[JsonPropertyName("regression")]
		public Elastic.Clients.Elasticsearch.Ingest.InferenceConfigRegression? Regression { get; set; }
	}

	[JsonConverter(typeof(InferenceConfigDescriptorConverter))]
	public sealed partial class InferenceConfigDescriptor : DescriptorBase<InferenceConfigDescriptor>
	{
		public InferenceConfigDescriptor()
		{
		}

		internal InferenceConfigDescriptor(Action<InferenceConfigDescriptor> configure) => configure.Invoke(this);
		internal Elastic.Clients.Elasticsearch.Ingest.InferenceConfigRegression? RegressionValue { get; private set; }

		internal InferenceConfigRegressionDescriptor RegressionDescriptor { get; private set; }

		internal Action<InferenceConfigRegressionDescriptor> RegressionDescriptorAction { get; private set; }

		public InferenceConfigDescriptor Regression(Elastic.Clients.Elasticsearch.Ingest.InferenceConfigRegression? regression)
		{
			RegressionDescriptor = null;
			RegressionDescriptorAction = null;
			return Assign(regression, (a, v) => a.RegressionValue = v);
		}

		public InferenceConfigDescriptor Regression(Elastic.Clients.Elasticsearch.Ingest.InferenceConfigRegressionDescriptor descriptor)
		{
			RegressionValue = null;
			RegressionDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.RegressionDescriptor = v);
		}

		public InferenceConfigDescriptor Regression(Action<Elastic.Clients.Elasticsearch.Ingest.InferenceConfigRegressionDescriptor> configure)
		{
			RegressionValue = null;
			RegressionDescriptorAction = null;
			return Assign(configure, (a, v) => a.RegressionDescriptorAction = v);
		}
	}

	internal sealed class InferenceConfigDescriptorConverter : JsonConverter<InferenceConfigDescriptor>
	{
		public override InferenceConfigDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, InferenceConfigDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value.RegressionDescriptor is not null)
			{
				writer.WritePropertyName("regression");
				JsonSerializer.Serialize(writer, value.RegressionDescriptor, options);
			}
			else if (value.RegressionDescriptorAction is not null)
			{
				writer.WritePropertyName("regression");
				JsonSerializer.Serialize(writer, new InferenceConfigRegressionDescriptor(value.RegressionDescriptorAction), options);
			}
			else if (value.RegressionValue is not null)
			{
				writer.WritePropertyName("regression");
				JsonSerializer.Serialize(writer, value.RegressionValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class InferenceConfigRegression
	{
		[JsonInclude]
		[JsonPropertyName("results_field")]
		public string ResultsField { get; set; }
	}

	[JsonConverter(typeof(InferenceConfigRegressionDescriptorConverter))]
	public sealed partial class InferenceConfigRegressionDescriptor : DescriptorBase<InferenceConfigRegressionDescriptor>
	{
		public InferenceConfigRegressionDescriptor()
		{
		}

		internal InferenceConfigRegressionDescriptor(Action<InferenceConfigRegressionDescriptor> configure) => configure.Invoke(this);
		internal string ResultsFieldValue { get; private set; }

		public InferenceConfigRegressionDescriptor ResultsField(string resultsField) => Assign(resultsField, (a, v) => a.ResultsFieldValue = v);
	}

	internal sealed class InferenceConfigRegressionDescriptorConverter : JsonConverter<InferenceConfigRegressionDescriptor>
	{
		public override InferenceConfigRegressionDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, InferenceConfigRegressionDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("results_field");
			writer.WriteStringValue(value.ResultsFieldValue);
			writer.WriteEndObject();
		}
	}

	public partial class InferenceProcessor : Ingest.ProcessorBase, IProcessorContainerVariant
	{
		[JsonIgnore]
		string Ingest.IProcessorContainerVariant.ProcessorContainerVariantName => "inference";
		[JsonInclude]
		[JsonPropertyName("model_id")]
		public Elastic.Clients.Elasticsearch.Id ModelId { get; set; }

		[JsonInclude]
		[JsonPropertyName("target_field")]
		public string TargetField { get; set; }

		[JsonInclude]
		[JsonPropertyName("field_map")]
		public Dictionary<string, object>? FieldMap { get; set; }

		[JsonInclude]
		[JsonPropertyName("inference_config")]
		public Elastic.Clients.Elasticsearch.Ingest.InferenceConfig? InferenceConfig { get; set; }
	}

	[JsonConverter(typeof(InferenceProcessorDescriptorConverter))]
	public sealed partial class InferenceProcessorDescriptor : DescriptorBase<InferenceProcessorDescriptor>, IProcessorContainerVariantDescriptor
	{
		public InferenceProcessorDescriptor()
		{
		}

		internal InferenceProcessorDescriptor(Action<InferenceProcessorDescriptor> configure) => configure.Invoke(this);
		internal Elastic.Clients.Elasticsearch.Id ModelIdValue { get; private set; }

		internal string TargetFieldValue { get; private set; }

		internal Dictionary<string, object>? FieldMapValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Ingest.InferenceConfig? InferenceConfigValue { get; private set; }

		internal InferenceConfigDescriptor InferenceConfigDescriptor { get; private set; }

		internal Action<InferenceConfigDescriptor> InferenceConfigDescriptorAction { get; private set; }

		public InferenceProcessorDescriptor ModelId(Elastic.Clients.Elasticsearch.Id modelId) => Assign(modelId, (a, v) => a.ModelIdValue = v);
		public InferenceProcessorDescriptor TargetField(string targetField) => Assign(targetField, (a, v) => a.TargetFieldValue = v);
		public InferenceProcessorDescriptor FieldMap(Func<FluentDictionary<string?, object?>, FluentDictionary<string?, object?>> selector) => Assign(selector, (a, v) => a.FieldMapValue = v?.Invoke(new FluentDictionary<string?, object?>()));
		public InferenceProcessorDescriptor InferenceConfig(Elastic.Clients.Elasticsearch.Ingest.InferenceConfig? inferenceConfig)
		{
			InferenceConfigDescriptor = null;
			InferenceConfigDescriptorAction = null;
			return Assign(inferenceConfig, (a, v) => a.InferenceConfigValue = v);
		}

		public InferenceProcessorDescriptor InferenceConfig(Elastic.Clients.Elasticsearch.Ingest.InferenceConfigDescriptor descriptor)
		{
			InferenceConfigValue = null;
			InferenceConfigDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.InferenceConfigDescriptor = v);
		}

		public InferenceProcessorDescriptor InferenceConfig(Action<Elastic.Clients.Elasticsearch.Ingest.InferenceConfigDescriptor> configure)
		{
			InferenceConfigValue = null;
			InferenceConfigDescriptorAction = null;
			return Assign(configure, (a, v) => a.InferenceConfigDescriptorAction = v);
		}
	}

	internal sealed class InferenceProcessorDescriptorConverter : JsonConverter<InferenceProcessorDescriptor>
	{
		public override InferenceProcessorDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, InferenceProcessorDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("model_id");
			JsonSerializer.Serialize(writer, value.ModelIdValue, options);
			writer.WritePropertyName("target_field");
			JsonSerializer.Serialize(writer, value.TargetFieldValue, options);
			if (value.FieldMapValue is not null)
			{
				writer.WritePropertyName("field_map");
				JsonSerializer.Serialize(writer, value.FieldMapValue, options);
			}

			if (value.InferenceConfigDescriptor is not null)
			{
				writer.WritePropertyName("inference_config");
				JsonSerializer.Serialize(writer, value.InferenceConfigDescriptor, options);
			}
			else if (value.InferenceConfigDescriptorAction is not null)
			{
				writer.WritePropertyName("inference_config");
				JsonSerializer.Serialize(writer, new InferenceConfigDescriptor(value.InferenceConfigDescriptorAction), options);
			}
			else if (value.InferenceConfigValue is not null)
			{
				writer.WritePropertyName("inference_config");
				JsonSerializer.Serialize(writer, value.InferenceConfigValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class JoinProcessor : Ingest.ProcessorBase, IProcessorContainerVariant
	{
		[JsonIgnore]
		string Ingest.IProcessorContainerVariant.ProcessorContainerVariantName => "join";
		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("separator")]
		public string Separator { get; set; }

		[JsonInclude]
		[JsonPropertyName("target_field")]
		public string? TargetField { get; set; }
	}

	[JsonConverter(typeof(JoinProcessorDescriptorConverter))]
	public sealed partial class JoinProcessorDescriptor : DescriptorBase<JoinProcessorDescriptor>, IProcessorContainerVariantDescriptor
	{
		public JoinProcessorDescriptor()
		{
		}

		internal JoinProcessorDescriptor(Action<JoinProcessorDescriptor> configure) => configure.Invoke(this);
		internal string FieldValue { get; private set; }

		internal string SeparatorValue { get; private set; }

		internal string? TargetFieldValue { get; private set; }

		public JoinProcessorDescriptor Field(string field) => Assign(field, (a, v) => a.FieldValue = v);
		public JoinProcessorDescriptor Separator(string separator) => Assign(separator, (a, v) => a.SeparatorValue = v);
		public JoinProcessorDescriptor TargetField(string? targetField) => Assign(targetField, (a, v) => a.TargetFieldValue = v);
	}

	internal sealed class JoinProcessorDescriptorConverter : JsonConverter<JoinProcessorDescriptor>
	{
		public override JoinProcessorDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, JoinProcessorDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, value.FieldValue, options);
			writer.WritePropertyName("separator");
			writer.WriteStringValue(value.SeparatorValue);
			if (value.TargetFieldValue is not null)
			{
				writer.WritePropertyName("target_field");
				JsonSerializer.Serialize(writer, value.TargetFieldValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class JsonProcessor : Ingest.ProcessorBase, IProcessorContainerVariant
	{
		[JsonIgnore]
		string Ingest.IProcessorContainerVariant.ProcessorContainerVariantName => "json";
		[JsonInclude]
		[JsonPropertyName("add_to_root")]
		public bool AddToRoot { get; set; }

		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("target_field")]
		public string TargetField { get; set; }
	}

	[JsonConverter(typeof(JsonProcessorDescriptorConverter))]
	public sealed partial class JsonProcessorDescriptor : DescriptorBase<JsonProcessorDescriptor>, IProcessorContainerVariantDescriptor
	{
		public JsonProcessorDescriptor()
		{
		}

		internal JsonProcessorDescriptor(Action<JsonProcessorDescriptor> configure) => configure.Invoke(this);
		internal bool AddToRootValue { get; private set; }

		internal string FieldValue { get; private set; }

		internal string TargetFieldValue { get; private set; }

		public JsonProcessorDescriptor AddToRoot(bool addToRoot = true) => Assign(addToRoot, (a, v) => a.AddToRootValue = v);
		public JsonProcessorDescriptor Field(string field) => Assign(field, (a, v) => a.FieldValue = v);
		public JsonProcessorDescriptor TargetField(string targetField) => Assign(targetField, (a, v) => a.TargetFieldValue = v);
	}

	internal sealed class JsonProcessorDescriptorConverter : JsonConverter<JsonProcessorDescriptor>
	{
		public override JsonProcessorDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, JsonProcessorDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("add_to_root");
			writer.WriteBooleanValue(value.AddToRootValue);
			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, value.FieldValue, options);
			writer.WritePropertyName("target_field");
			JsonSerializer.Serialize(writer, value.TargetFieldValue, options);
			writer.WriteEndObject();
		}
	}

	public partial class KeyValueProcessor : Ingest.ProcessorBase, IProcessorContainerVariant
	{
		[JsonIgnore]
		string Ingest.IProcessorContainerVariant.ProcessorContainerVariantName => "kv";
		[JsonInclude]
		[JsonPropertyName("exclude_keys")]
		public IEnumerable<string>? ExcludeKeys { get; set; }

		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("field_split")]
		public string FieldSplit { get; set; }

		[JsonInclude]
		[JsonPropertyName("ignore_missing")]
		public bool? IgnoreMissing { get; set; }

		[JsonInclude]
		[JsonPropertyName("include_keys")]
		public IEnumerable<string>? IncludeKeys { get; set; }

		[JsonInclude]
		[JsonPropertyName("prefix")]
		public string? Prefix { get; set; }

		[JsonInclude]
		[JsonPropertyName("strip_brackets")]
		public bool? StripBrackets { get; set; }

		[JsonInclude]
		[JsonPropertyName("target_field")]
		public string? TargetField { get; set; }

		[JsonInclude]
		[JsonPropertyName("trim_key")]
		public string? TrimKey { get; set; }

		[JsonInclude]
		[JsonPropertyName("trim_value")]
		public string? TrimValue { get; set; }

		[JsonInclude]
		[JsonPropertyName("value_split")]
		public string ValueSplit { get; set; }
	}

	[JsonConverter(typeof(KeyValueProcessorDescriptorConverter))]
	public sealed partial class KeyValueProcessorDescriptor : DescriptorBase<KeyValueProcessorDescriptor>, IProcessorContainerVariantDescriptor
	{
		public KeyValueProcessorDescriptor()
		{
		}

		internal KeyValueProcessorDescriptor(Action<KeyValueProcessorDescriptor> configure) => configure.Invoke(this);
		internal IEnumerable<string>? ExcludeKeysValue { get; private set; }

		internal string FieldValue { get; private set; }

		internal string FieldSplitValue { get; private set; }

		internal bool? IgnoreMissingValue { get; private set; }

		internal IEnumerable<string>? IncludeKeysValue { get; private set; }

		internal string? PrefixValue { get; private set; }

		internal bool? StripBracketsValue { get; private set; }

		internal string? TargetFieldValue { get; private set; }

		internal string? TrimKeyValue { get; private set; }

		internal string? TrimValueValue { get; private set; }

		internal string ValueSplitValue { get; private set; }

		public KeyValueProcessorDescriptor ExcludeKeys(IEnumerable<string>? excludeKeys) => Assign(excludeKeys, (a, v) => a.ExcludeKeysValue = v);
		public KeyValueProcessorDescriptor Field(string field) => Assign(field, (a, v) => a.FieldValue = v);
		public KeyValueProcessorDescriptor FieldSplit(string fieldSplit) => Assign(fieldSplit, (a, v) => a.FieldSplitValue = v);
		public KeyValueProcessorDescriptor IgnoreMissing(bool? ignoreMissing = true) => Assign(ignoreMissing, (a, v) => a.IgnoreMissingValue = v);
		public KeyValueProcessorDescriptor IncludeKeys(IEnumerable<string>? includeKeys) => Assign(includeKeys, (a, v) => a.IncludeKeysValue = v);
		public KeyValueProcessorDescriptor Prefix(string? prefix) => Assign(prefix, (a, v) => a.PrefixValue = v);
		public KeyValueProcessorDescriptor StripBrackets(bool? stripBrackets = true) => Assign(stripBrackets, (a, v) => a.StripBracketsValue = v);
		public KeyValueProcessorDescriptor TargetField(string? targetField) => Assign(targetField, (a, v) => a.TargetFieldValue = v);
		public KeyValueProcessorDescriptor TrimKey(string? trimKey) => Assign(trimKey, (a, v) => a.TrimKeyValue = v);
		public KeyValueProcessorDescriptor TrimValue(string? trimValue) => Assign(trimValue, (a, v) => a.TrimValueValue = v);
		public KeyValueProcessorDescriptor ValueSplit(string valueSplit) => Assign(valueSplit, (a, v) => a.ValueSplitValue = v);
	}

	internal sealed class KeyValueProcessorDescriptorConverter : JsonConverter<KeyValueProcessorDescriptor>
	{
		public override KeyValueProcessorDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, KeyValueProcessorDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value.ExcludeKeysValue is not null)
			{
				writer.WritePropertyName("exclude_keys");
				JsonSerializer.Serialize(writer, value.ExcludeKeysValue, options);
			}

			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, value.FieldValue, options);
			writer.WritePropertyName("field_split");
			writer.WriteStringValue(value.FieldSplitValue);
			if (value.IgnoreMissingValue.HasValue)
			{
				writer.WritePropertyName("ignore_missing");
				writer.WriteBooleanValue(value.IgnoreMissingValue.Value);
			}

			if (value.IncludeKeysValue is not null)
			{
				writer.WritePropertyName("include_keys");
				JsonSerializer.Serialize(writer, value.IncludeKeysValue, options);
			}

			if (!string.IsNullOrEmpty(value.PrefixValue))
			{
				writer.WritePropertyName("prefix");
				writer.WriteStringValue(value.PrefixValue);
			}

			if (value.StripBracketsValue.HasValue)
			{
				writer.WritePropertyName("strip_brackets");
				writer.WriteBooleanValue(value.StripBracketsValue.Value);
			}

			if (value.TargetFieldValue is not null)
			{
				writer.WritePropertyName("target_field");
				JsonSerializer.Serialize(writer, value.TargetFieldValue, options);
			}

			if (!string.IsNullOrEmpty(value.TrimKeyValue))
			{
				writer.WritePropertyName("trim_key");
				writer.WriteStringValue(value.TrimKeyValue);
			}

			if (!string.IsNullOrEmpty(value.TrimValueValue))
			{
				writer.WritePropertyName("trim_value");
				writer.WriteStringValue(value.TrimValueValue);
			}

			writer.WritePropertyName("value_split");
			writer.WriteStringValue(value.ValueSplitValue);
			writer.WriteEndObject();
		}
	}

	public partial class LowercaseProcessor : Ingest.ProcessorBase, IProcessorContainerVariant
	{
		[JsonIgnore]
		string Ingest.IProcessorContainerVariant.ProcessorContainerVariantName => "lowercase";
		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("ignore_missing")]
		public bool? IgnoreMissing { get; set; }

		[JsonInclude]
		[JsonPropertyName("target_field")]
		public string? TargetField { get; set; }
	}

	[JsonConverter(typeof(LowercaseProcessorDescriptorConverter))]
	public sealed partial class LowercaseProcessorDescriptor : DescriptorBase<LowercaseProcessorDescriptor>, IProcessorContainerVariantDescriptor
	{
		public LowercaseProcessorDescriptor()
		{
		}

		internal LowercaseProcessorDescriptor(Action<LowercaseProcessorDescriptor> configure) => configure.Invoke(this);
		internal string FieldValue { get; private set; }

		internal bool? IgnoreMissingValue { get; private set; }

		internal string? TargetFieldValue { get; private set; }

		public LowercaseProcessorDescriptor Field(string field) => Assign(field, (a, v) => a.FieldValue = v);
		public LowercaseProcessorDescriptor IgnoreMissing(bool? ignoreMissing = true) => Assign(ignoreMissing, (a, v) => a.IgnoreMissingValue = v);
		public LowercaseProcessorDescriptor TargetField(string? targetField) => Assign(targetField, (a, v) => a.TargetFieldValue = v);
	}

	internal sealed class LowercaseProcessorDescriptorConverter : JsonConverter<LowercaseProcessorDescriptor>
	{
		public override LowercaseProcessorDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, LowercaseProcessorDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, value.FieldValue, options);
			if (value.IgnoreMissingValue.HasValue)
			{
				writer.WritePropertyName("ignore_missing");
				writer.WriteBooleanValue(value.IgnoreMissingValue.Value);
			}

			if (value.TargetFieldValue is not null)
			{
				writer.WritePropertyName("target_field");
				JsonSerializer.Serialize(writer, value.TargetFieldValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class Pipeline
	{
		[JsonInclude]
		[JsonPropertyName("description")]
		public string? Description { get; set; }

		[JsonInclude]
		[JsonPropertyName("on_failure")]
		public IEnumerable<Elastic.Clients.Elasticsearch.Ingest.ProcessorContainer>? OnFailure { get; set; }

		[JsonInclude]
		[JsonPropertyName("processors")]
		public IEnumerable<Elastic.Clients.Elasticsearch.Ingest.ProcessorContainer>? Processors { get; set; }

		[JsonInclude]
		[JsonPropertyName("version")]
		public long? Version { get; set; }
	}

	[JsonConverter(typeof(PipelineDescriptorConverter))]
	public sealed partial class PipelineDescriptor : DescriptorBase<PipelineDescriptor>
	{
		public PipelineDescriptor()
		{
		}

		internal PipelineDescriptor(Action<PipelineDescriptor> configure) => configure.Invoke(this);
		internal string? DescriptionValue { get; private set; }

		internal IEnumerable<Elastic.Clients.Elasticsearch.Ingest.ProcessorContainer>? OnFailureValue { get; private set; }

		internal IEnumerable<Elastic.Clients.Elasticsearch.Ingest.ProcessorContainer>? ProcessorsValue { get; private set; }

		internal long? VersionValue { get; private set; }

		public PipelineDescriptor Description(string? description) => Assign(description, (a, v) => a.DescriptionValue = v);
		public PipelineDescriptor OnFailure(IEnumerable<Elastic.Clients.Elasticsearch.Ingest.ProcessorContainer>? onFailure) => Assign(onFailure, (a, v) => a.OnFailureValue = v);
		public PipelineDescriptor Processors(IEnumerable<Elastic.Clients.Elasticsearch.Ingest.ProcessorContainer>? processors) => Assign(processors, (a, v) => a.ProcessorsValue = v);
		public PipelineDescriptor Version(long? version) => Assign(version, (a, v) => a.VersionValue = v);
	}

	internal sealed class PipelineDescriptorConverter : JsonConverter<PipelineDescriptor>
	{
		public override PipelineDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, PipelineDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (!string.IsNullOrEmpty(value.DescriptionValue))
			{
				writer.WritePropertyName("description");
				writer.WriteStringValue(value.DescriptionValue);
			}

			if (value.OnFailureValue is not null)
			{
				writer.WritePropertyName("on_failure");
				JsonSerializer.Serialize(writer, value.OnFailureValue, options);
			}

			if (value.ProcessorsValue is not null)
			{
				writer.WritePropertyName("processors");
				JsonSerializer.Serialize(writer, value.ProcessorsValue, options);
			}

			if (value.VersionValue is not null)
			{
				writer.WritePropertyName("version");
				JsonSerializer.Serialize(writer, value.VersionValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class PipelineProcessor : Ingest.ProcessorBase, IProcessorContainerVariant
	{
		[JsonIgnore]
		string Ingest.IProcessorContainerVariant.ProcessorContainerVariantName => "pipeline";
		[JsonInclude]
		[JsonPropertyName("name")]
		public Elastic.Clients.Elasticsearch.Name Name { get; set; }
	}

	[JsonConverter(typeof(PipelineProcessorDescriptorConverter))]
	public sealed partial class PipelineProcessorDescriptor : DescriptorBase<PipelineProcessorDescriptor>, IProcessorContainerVariantDescriptor
	{
		public PipelineProcessorDescriptor()
		{
		}

		internal PipelineProcessorDescriptor(Action<PipelineProcessorDescriptor> configure) => configure.Invoke(this);
		internal Elastic.Clients.Elasticsearch.Name NameValue { get; private set; }

		public PipelineProcessorDescriptor Name(Elastic.Clients.Elasticsearch.Name name) => Assign(name, (a, v) => a.NameValue = v);
	}

	internal sealed class PipelineProcessorDescriptorConverter : JsonConverter<PipelineProcessorDescriptor>
	{
		public override PipelineProcessorDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, PipelineProcessorDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("name");
			JsonSerializer.Serialize(writer, value.NameValue, options);
			writer.WriteEndObject();
		}
	}

	public abstract partial class ProcessorBase
	{
		[JsonInclude]
		[JsonPropertyName("if")]
		public string? If { get; set; }

		[JsonInclude]
		[JsonPropertyName("ignore_failure")]
		public bool? IgnoreFailure { get; set; }

		[JsonInclude]
		[JsonPropertyName("on_failure")]
		public IEnumerable<Elastic.Clients.Elasticsearch.Ingest.ProcessorContainer>? OnFailure { get; set; }

		[JsonInclude]
		[JsonPropertyName("tag")]
		public string? Tag { get; set; }
	}

	[JsonConverter(typeof(ProcessorBaseDescriptorConverter))]
	public sealed partial class ProcessorBaseDescriptor : DescriptorBase<ProcessorBaseDescriptor>
	{
		public ProcessorBaseDescriptor()
		{
		}

		internal ProcessorBaseDescriptor(Action<ProcessorBaseDescriptor> configure) => configure.Invoke(this);
		internal string? IfValue { get; private set; }

		internal bool? IgnoreFailureValue { get; private set; }

		internal IEnumerable<Elastic.Clients.Elasticsearch.Ingest.ProcessorContainer>? OnFailureValue { get; private set; }

		internal string? TagValue { get; private set; }

		public ProcessorBaseDescriptor If(string? ifValue) => Assign(ifValue, (a, v) => a.IfValue = v);
		public ProcessorBaseDescriptor IgnoreFailure(bool? ignoreFailure = true) => Assign(ignoreFailure, (a, v) => a.IgnoreFailureValue = v);
		public ProcessorBaseDescriptor OnFailure(IEnumerable<Elastic.Clients.Elasticsearch.Ingest.ProcessorContainer>? onFailure) => Assign(onFailure, (a, v) => a.OnFailureValue = v);
		public ProcessorBaseDescriptor Tag(string? tag) => Assign(tag, (a, v) => a.TagValue = v);
	}

	internal sealed class ProcessorBaseDescriptorConverter : JsonConverter<ProcessorBaseDescriptor>
	{
		public override ProcessorBaseDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, ProcessorBaseDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (!string.IsNullOrEmpty(value.IfValue))
			{
				writer.WritePropertyName("if");
				writer.WriteStringValue(value.IfValue);
			}

			if (value.IgnoreFailureValue.HasValue)
			{
				writer.WritePropertyName("ignore_failure");
				writer.WriteBooleanValue(value.IgnoreFailureValue.Value);
			}

			if (value.OnFailureValue is not null)
			{
				writer.WritePropertyName("on_failure");
				JsonSerializer.Serialize(writer, value.OnFailureValue, options);
			}

			if (!string.IsNullOrEmpty(value.TagValue))
			{
				writer.WritePropertyName("tag");
				writer.WriteStringValue(value.TagValue);
			}

			writer.WriteEndObject();
		}
	}

	public interface IProcessorContainerVariant
	{
		string ProcessorContainerVariantName { get; }
	}

	internal interface IProcessorContainerVariantDescriptor
	{
	}

	[JsonConverter(typeof(ProcessorContainerConverter))]
	public partial class ProcessorContainer : IContainer
	{
		public ProcessorContainer(IProcessorContainerVariant variant) => Variant = variant ?? throw new ArgumentNullException(nameof(variant));
		internal IProcessorContainerVariant Variant { get; }
	}

	internal sealed class ProcessorContainerConverter : JsonConverter<ProcessorContainer>
	{
		public override ProcessorContainer Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			reader.Read();
			if (reader.TokenType != JsonTokenType.PropertyName)
			{
				throw new JsonException();
			}

			var propertyName = reader.GetString();
			if (propertyName == "attachment")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.AttachmentProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(variant);
			}

			if (propertyName == "append")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.AppendProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(variant);
			}

			if (propertyName == "csv")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.CsvProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(variant);
			}

			if (propertyName == "convert")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.ConvertProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(variant);
			}

			if (propertyName == "date")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.DateProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(variant);
			}

			if (propertyName == "date_index_name")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.DateIndexNameProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(variant);
			}

			if (propertyName == "dot_expander")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.DotExpanderProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(variant);
			}

			if (propertyName == "enrich")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.EnrichProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(variant);
			}

			if (propertyName == "fail")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.FailProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(variant);
			}

			if (propertyName == "foreach")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.ForeachProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(variant);
			}

			if (propertyName == "json")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.JsonProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(variant);
			}

			if (propertyName == "user_agent")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.UserAgentProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(variant);
			}

			if (propertyName == "kv")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.KeyValueProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(variant);
			}

			if (propertyName == "geoip")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.GeoIpProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(variant);
			}

			if (propertyName == "grok")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.GrokProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(variant);
			}

			if (propertyName == "gsub")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.GsubProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(variant);
			}

			if (propertyName == "join")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.JoinProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(variant);
			}

			if (propertyName == "lowercase")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.LowercaseProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(variant);
			}

			if (propertyName == "remove")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.RemoveProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(variant);
			}

			if (propertyName == "rename")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.RenameProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(variant);
			}

			if (propertyName == "set")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.SetProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(variant);
			}

			if (propertyName == "sort")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.SortProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(variant);
			}

			if (propertyName == "split")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.SplitProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(variant);
			}

			if (propertyName == "trim")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.TrimProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(variant);
			}

			if (propertyName == "uppercase")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.UppercaseProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(variant);
			}

			if (propertyName == "urldecode")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.UrlDecodeProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(variant);
			}

			if (propertyName == "bytes")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.BytesProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(variant);
			}

			if (propertyName == "dissect")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.DissectProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(variant);
			}

			if (propertyName == "set_security_user")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.SetSecurityUserProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(variant);
			}

			if (propertyName == "pipeline")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.PipelineProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(variant);
			}

			if (propertyName == "drop")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.DropProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(variant);
			}

			if (propertyName == "circle")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.CircleProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(variant);
			}

			if (propertyName == "inference")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.InferenceProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(variant);
			}

			throw new JsonException();
		}

		public override void Write(Utf8JsonWriter writer, ProcessorContainer value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName(value.Variant.ProcessorContainerVariantName);
			switch (value.Variant)
			{
				case Elastic.Clients.Elasticsearch.Ingest.AttachmentProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.AppendProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.CsvProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.ConvertProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.DateProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.DateIndexNameProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.DotExpanderProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.EnrichProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.FailProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.ForeachProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.JsonProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.UserAgentProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.KeyValueProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.GeoIpProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.GrokProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.GsubProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.JoinProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.LowercaseProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.RemoveProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.RenameProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.SetProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.SortProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.SplitProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.TrimProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.UppercaseProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.UrlDecodeProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.BytesProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.DissectProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.SetSecurityUserProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.PipelineProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.DropProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.CircleProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.InferenceProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
			}

			writer.WriteEndObject();
		}
	}

	public sealed partial class ProcessorContainerDescriptor : DescriptorBase<ProcessorContainerDescriptor>
	{
		public ProcessorContainerDescriptor()
		{
		}

		internal ProcessorContainerDescriptor(Action<ProcessorContainerDescriptor> configure) => configure.Invoke(this);
	}

	internal sealed class ProcessorContainerDescriptorConverter : JsonConverter<ProcessorContainerDescriptor>
	{
		public override ProcessorContainerDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, ProcessorContainerDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WriteEndObject();
		}
	}

	public partial class RemoveProcessor : Ingest.ProcessorBase, IProcessorContainerVariant
	{
		[JsonIgnore]
		string Ingest.IProcessorContainerVariant.ProcessorContainerVariantName => "remove";
		[JsonInclude]
		[JsonPropertyName("field")]
		public Elastic.Clients.Elasticsearch.Fields Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("ignore_missing")]
		public bool? IgnoreMissing { get; set; }
	}

	[JsonConverter(typeof(RemoveProcessorDescriptorConverter))]
	public sealed partial class RemoveProcessorDescriptor : DescriptorBase<RemoveProcessorDescriptor>, IProcessorContainerVariantDescriptor
	{
		public RemoveProcessorDescriptor()
		{
		}

		internal RemoveProcessorDescriptor(Action<RemoveProcessorDescriptor> configure) => configure.Invoke(this);
		internal Elastic.Clients.Elasticsearch.Fields FieldValue { get; private set; }

		internal bool? IgnoreMissingValue { get; private set; }

		public RemoveProcessorDescriptor Field(Elastic.Clients.Elasticsearch.Fields field) => Assign(field, (a, v) => a.FieldValue = v);
		public RemoveProcessorDescriptor IgnoreMissing(bool? ignoreMissing = true) => Assign(ignoreMissing, (a, v) => a.IgnoreMissingValue = v);
	}

	internal sealed class RemoveProcessorDescriptorConverter : JsonConverter<RemoveProcessorDescriptor>
	{
		public override RemoveProcessorDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, RemoveProcessorDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, value.FieldValue, options);
			if (value.IgnoreMissingValue.HasValue)
			{
				writer.WritePropertyName("ignore_missing");
				writer.WriteBooleanValue(value.IgnoreMissingValue.Value);
			}

			writer.WriteEndObject();
		}
	}

	public partial class RenameProcessor : Ingest.ProcessorBase, IProcessorContainerVariant
	{
		[JsonIgnore]
		string Ingest.IProcessorContainerVariant.ProcessorContainerVariantName => "rename";
		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("ignore_missing")]
		public bool? IgnoreMissing { get; set; }

		[JsonInclude]
		[JsonPropertyName("target_field")]
		public string TargetField { get; set; }
	}

	[JsonConverter(typeof(RenameProcessorDescriptorConverter))]
	public sealed partial class RenameProcessorDescriptor : DescriptorBase<RenameProcessorDescriptor>, IProcessorContainerVariantDescriptor
	{
		public RenameProcessorDescriptor()
		{
		}

		internal RenameProcessorDescriptor(Action<RenameProcessorDescriptor> configure) => configure.Invoke(this);
		internal string FieldValue { get; private set; }

		internal bool? IgnoreMissingValue { get; private set; }

		internal string TargetFieldValue { get; private set; }

		public RenameProcessorDescriptor Field(string field) => Assign(field, (a, v) => a.FieldValue = v);
		public RenameProcessorDescriptor IgnoreMissing(bool? ignoreMissing = true) => Assign(ignoreMissing, (a, v) => a.IgnoreMissingValue = v);
		public RenameProcessorDescriptor TargetField(string targetField) => Assign(targetField, (a, v) => a.TargetFieldValue = v);
	}

	internal sealed class RenameProcessorDescriptorConverter : JsonConverter<RenameProcessorDescriptor>
	{
		public override RenameProcessorDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, RenameProcessorDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, value.FieldValue, options);
			if (value.IgnoreMissingValue.HasValue)
			{
				writer.WritePropertyName("ignore_missing");
				writer.WriteBooleanValue(value.IgnoreMissingValue.Value);
			}

			writer.WritePropertyName("target_field");
			JsonSerializer.Serialize(writer, value.TargetFieldValue, options);
			writer.WriteEndObject();
		}
	}

	public partial class SetProcessor : Ingest.ProcessorBase, IProcessorContainerVariant
	{
		[JsonIgnore]
		string Ingest.IProcessorContainerVariant.ProcessorContainerVariantName => "set";
		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("override")]
		public bool? Override { get; set; }

		[JsonInclude]
		[JsonPropertyName("value")]
		public object Value { get; set; }
	}

	[JsonConverter(typeof(SetProcessorDescriptorConverter))]
	public sealed partial class SetProcessorDescriptor : DescriptorBase<SetProcessorDescriptor>, IProcessorContainerVariantDescriptor
	{
		public SetProcessorDescriptor()
		{
		}

		internal SetProcessorDescriptor(Action<SetProcessorDescriptor> configure) => configure.Invoke(this);
		internal string FieldValue { get; private set; }

		internal bool? OverrideValue { get; private set; }

		internal object ValueValue { get; private set; }

		public SetProcessorDescriptor Field(string field) => Assign(field, (a, v) => a.FieldValue = v);
		public SetProcessorDescriptor Override(bool? overrideValue = true) => Assign(overrideValue, (a, v) => a.OverrideValue = v);
		public SetProcessorDescriptor Value(object value) => Assign(value, (a, v) => a.ValueValue = v);
	}

	internal sealed class SetProcessorDescriptorConverter : JsonConverter<SetProcessorDescriptor>
	{
		public override SetProcessorDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, SetProcessorDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, value.FieldValue, options);
			if (value.OverrideValue.HasValue)
			{
				writer.WritePropertyName("override");
				writer.WriteBooleanValue(value.OverrideValue.Value);
			}

			writer.WriteEndObject();
		}
	}

	public partial class SetSecurityUserProcessor : Ingest.ProcessorBase, IProcessorContainerVariant
	{
		[JsonIgnore]
		string Ingest.IProcessorContainerVariant.ProcessorContainerVariantName => "set_security_user";
		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("properties")]
		public IEnumerable<string>? Properties { get; set; }
	}

	[JsonConverter(typeof(SetSecurityUserProcessorDescriptorConverter))]
	public sealed partial class SetSecurityUserProcessorDescriptor : DescriptorBase<SetSecurityUserProcessorDescriptor>, IProcessorContainerVariantDescriptor
	{
		public SetSecurityUserProcessorDescriptor()
		{
		}

		internal SetSecurityUserProcessorDescriptor(Action<SetSecurityUserProcessorDescriptor> configure) => configure.Invoke(this);
		internal string FieldValue { get; private set; }

		internal IEnumerable<string>? PropertiesValue { get; private set; }

		public SetSecurityUserProcessorDescriptor Field(string field) => Assign(field, (a, v) => a.FieldValue = v);
		public SetSecurityUserProcessorDescriptor Properties(IEnumerable<string>? properties) => Assign(properties, (a, v) => a.PropertiesValue = v);
	}

	internal sealed class SetSecurityUserProcessorDescriptorConverter : JsonConverter<SetSecurityUserProcessorDescriptor>
	{
		public override SetSecurityUserProcessorDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, SetSecurityUserProcessorDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, value.FieldValue, options);
			if (value.PropertiesValue is not null)
			{
				writer.WritePropertyName("properties");
				JsonSerializer.Serialize(writer, value.PropertiesValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class SortProcessor : Ingest.ProcessorBase, IProcessorContainerVariant
	{
		[JsonIgnore]
		string Ingest.IProcessorContainerVariant.ProcessorContainerVariantName => "sort";
		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("order")]
		public Elastic.Clients.Elasticsearch.SortOrder Order { get; set; }

		[JsonInclude]
		[JsonPropertyName("target_field")]
		public string TargetField { get; set; }
	}

	[JsonConverter(typeof(SortProcessorDescriptorConverter))]
	public sealed partial class SortProcessorDescriptor : DescriptorBase<SortProcessorDescriptor>, IProcessorContainerVariantDescriptor
	{
		public SortProcessorDescriptor()
		{
		}

		internal SortProcessorDescriptor(Action<SortProcessorDescriptor> configure) => configure.Invoke(this);
		internal string FieldValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.SortOrder OrderValue { get; private set; }

		internal string TargetFieldValue { get; private set; }

		public SortProcessorDescriptor Field(string field) => Assign(field, (a, v) => a.FieldValue = v);
		public SortProcessorDescriptor Order(Elastic.Clients.Elasticsearch.SortOrder order) => Assign(order, (a, v) => a.OrderValue = v);
		public SortProcessorDescriptor TargetField(string targetField) => Assign(targetField, (a, v) => a.TargetFieldValue = v);
	}

	internal sealed class SortProcessorDescriptorConverter : JsonConverter<SortProcessorDescriptor>
	{
		public override SortProcessorDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, SortProcessorDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, value.FieldValue, options);
			writer.WritePropertyName("order");
			JsonSerializer.Serialize(writer, value.OrderValue, options);
			writer.WritePropertyName("target_field");
			JsonSerializer.Serialize(writer, value.TargetFieldValue, options);
			writer.WriteEndObject();
		}
	}

	public partial class SplitProcessor : Ingest.ProcessorBase, IProcessorContainerVariant
	{
		[JsonIgnore]
		string Ingest.IProcessorContainerVariant.ProcessorContainerVariantName => "split";
		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("ignore_missing")]
		public bool? IgnoreMissing { get; set; }

		[JsonInclude]
		[JsonPropertyName("preserve_trailing")]
		public bool? PreserveTrailing { get; set; }

		[JsonInclude]
		[JsonPropertyName("separator")]
		public string Separator { get; set; }

		[JsonInclude]
		[JsonPropertyName("target_field")]
		public string? TargetField { get; set; }
	}

	[JsonConverter(typeof(SplitProcessorDescriptorConverter))]
	public sealed partial class SplitProcessorDescriptor : DescriptorBase<SplitProcessorDescriptor>, IProcessorContainerVariantDescriptor
	{
		public SplitProcessorDescriptor()
		{
		}

		internal SplitProcessorDescriptor(Action<SplitProcessorDescriptor> configure) => configure.Invoke(this);
		internal string FieldValue { get; private set; }

		internal bool? IgnoreMissingValue { get; private set; }

		internal bool? PreserveTrailingValue { get; private set; }

		internal string SeparatorValue { get; private set; }

		internal string? TargetFieldValue { get; private set; }

		public SplitProcessorDescriptor Field(string field) => Assign(field, (a, v) => a.FieldValue = v);
		public SplitProcessorDescriptor IgnoreMissing(bool? ignoreMissing = true) => Assign(ignoreMissing, (a, v) => a.IgnoreMissingValue = v);
		public SplitProcessorDescriptor PreserveTrailing(bool? preserveTrailing = true) => Assign(preserveTrailing, (a, v) => a.PreserveTrailingValue = v);
		public SplitProcessorDescriptor Separator(string separator) => Assign(separator, (a, v) => a.SeparatorValue = v);
		public SplitProcessorDescriptor TargetField(string? targetField) => Assign(targetField, (a, v) => a.TargetFieldValue = v);
	}

	internal sealed class SplitProcessorDescriptorConverter : JsonConverter<SplitProcessorDescriptor>
	{
		public override SplitProcessorDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, SplitProcessorDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, value.FieldValue, options);
			if (value.IgnoreMissingValue.HasValue)
			{
				writer.WritePropertyName("ignore_missing");
				writer.WriteBooleanValue(value.IgnoreMissingValue.Value);
			}

			if (value.PreserveTrailingValue.HasValue)
			{
				writer.WritePropertyName("preserve_trailing");
				writer.WriteBooleanValue(value.PreserveTrailingValue.Value);
			}

			writer.WritePropertyName("separator");
			writer.WriteStringValue(value.SeparatorValue);
			if (value.TargetFieldValue is not null)
			{
				writer.WritePropertyName("target_field");
				JsonSerializer.Serialize(writer, value.TargetFieldValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class TrimProcessor : Ingest.ProcessorBase, IProcessorContainerVariant
	{
		[JsonIgnore]
		string Ingest.IProcessorContainerVariant.ProcessorContainerVariantName => "trim";
		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("ignore_missing")]
		public bool? IgnoreMissing { get; set; }

		[JsonInclude]
		[JsonPropertyName("target_field")]
		public string? TargetField { get; set; }
	}

	[JsonConverter(typeof(TrimProcessorDescriptorConverter))]
	public sealed partial class TrimProcessorDescriptor : DescriptorBase<TrimProcessorDescriptor>, IProcessorContainerVariantDescriptor
	{
		public TrimProcessorDescriptor()
		{
		}

		internal TrimProcessorDescriptor(Action<TrimProcessorDescriptor> configure) => configure.Invoke(this);
		internal string FieldValue { get; private set; }

		internal bool? IgnoreMissingValue { get; private set; }

		internal string? TargetFieldValue { get; private set; }

		public TrimProcessorDescriptor Field(string field) => Assign(field, (a, v) => a.FieldValue = v);
		public TrimProcessorDescriptor IgnoreMissing(bool? ignoreMissing = true) => Assign(ignoreMissing, (a, v) => a.IgnoreMissingValue = v);
		public TrimProcessorDescriptor TargetField(string? targetField) => Assign(targetField, (a, v) => a.TargetFieldValue = v);
	}

	internal sealed class TrimProcessorDescriptorConverter : JsonConverter<TrimProcessorDescriptor>
	{
		public override TrimProcessorDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, TrimProcessorDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, value.FieldValue, options);
			if (value.IgnoreMissingValue.HasValue)
			{
				writer.WritePropertyName("ignore_missing");
				writer.WriteBooleanValue(value.IgnoreMissingValue.Value);
			}

			if (value.TargetFieldValue is not null)
			{
				writer.WritePropertyName("target_field");
				JsonSerializer.Serialize(writer, value.TargetFieldValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class UppercaseProcessor : Ingest.ProcessorBase, IProcessorContainerVariant
	{
		[JsonIgnore]
		string Ingest.IProcessorContainerVariant.ProcessorContainerVariantName => "uppercase";
		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("ignore_missing")]
		public bool? IgnoreMissing { get; set; }

		[JsonInclude]
		[JsonPropertyName("target_field")]
		public string? TargetField { get; set; }
	}

	[JsonConverter(typeof(UppercaseProcessorDescriptorConverter))]
	public sealed partial class UppercaseProcessorDescriptor : DescriptorBase<UppercaseProcessorDescriptor>, IProcessorContainerVariantDescriptor
	{
		public UppercaseProcessorDescriptor()
		{
		}

		internal UppercaseProcessorDescriptor(Action<UppercaseProcessorDescriptor> configure) => configure.Invoke(this);
		internal string FieldValue { get; private set; }

		internal bool? IgnoreMissingValue { get; private set; }

		internal string? TargetFieldValue { get; private set; }

		public UppercaseProcessorDescriptor Field(string field) => Assign(field, (a, v) => a.FieldValue = v);
		public UppercaseProcessorDescriptor IgnoreMissing(bool? ignoreMissing = true) => Assign(ignoreMissing, (a, v) => a.IgnoreMissingValue = v);
		public UppercaseProcessorDescriptor TargetField(string? targetField) => Assign(targetField, (a, v) => a.TargetFieldValue = v);
	}

	internal sealed class UppercaseProcessorDescriptorConverter : JsonConverter<UppercaseProcessorDescriptor>
	{
		public override UppercaseProcessorDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, UppercaseProcessorDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, value.FieldValue, options);
			if (value.IgnoreMissingValue.HasValue)
			{
				writer.WritePropertyName("ignore_missing");
				writer.WriteBooleanValue(value.IgnoreMissingValue.Value);
			}

			if (value.TargetFieldValue is not null)
			{
				writer.WritePropertyName("target_field");
				JsonSerializer.Serialize(writer, value.TargetFieldValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class UrlDecodeProcessor : Ingest.ProcessorBase, IProcessorContainerVariant
	{
		[JsonIgnore]
		string Ingest.IProcessorContainerVariant.ProcessorContainerVariantName => "urldecode";
		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("ignore_missing")]
		public bool? IgnoreMissing { get; set; }

		[JsonInclude]
		[JsonPropertyName("target_field")]
		public string? TargetField { get; set; }
	}

	[JsonConverter(typeof(UrlDecodeProcessorDescriptorConverter))]
	public sealed partial class UrlDecodeProcessorDescriptor : DescriptorBase<UrlDecodeProcessorDescriptor>, IProcessorContainerVariantDescriptor
	{
		public UrlDecodeProcessorDescriptor()
		{
		}

		internal UrlDecodeProcessorDescriptor(Action<UrlDecodeProcessorDescriptor> configure) => configure.Invoke(this);
		internal string FieldValue { get; private set; }

		internal bool? IgnoreMissingValue { get; private set; }

		internal string? TargetFieldValue { get; private set; }

		public UrlDecodeProcessorDescriptor Field(string field) => Assign(field, (a, v) => a.FieldValue = v);
		public UrlDecodeProcessorDescriptor IgnoreMissing(bool? ignoreMissing = true) => Assign(ignoreMissing, (a, v) => a.IgnoreMissingValue = v);
		public UrlDecodeProcessorDescriptor TargetField(string? targetField) => Assign(targetField, (a, v) => a.TargetFieldValue = v);
	}

	internal sealed class UrlDecodeProcessorDescriptorConverter : JsonConverter<UrlDecodeProcessorDescriptor>
	{
		public override UrlDecodeProcessorDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, UrlDecodeProcessorDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, value.FieldValue, options);
			if (value.IgnoreMissingValue.HasValue)
			{
				writer.WritePropertyName("ignore_missing");
				writer.WriteBooleanValue(value.IgnoreMissingValue.Value);
			}

			if (value.TargetFieldValue is not null)
			{
				writer.WritePropertyName("target_field");
				JsonSerializer.Serialize(writer, value.TargetFieldValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class UserAgentProcessor : Ingest.ProcessorBase, IProcessorContainerVariant
	{
		[JsonIgnore]
		string Ingest.IProcessorContainerVariant.ProcessorContainerVariantName => "user_agent";
		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("ignore_missing")]
		public bool IgnoreMissing { get; set; }

		[JsonInclude]
		[JsonPropertyName("options")]
		public IEnumerable<Elastic.Clients.Elasticsearch.Ingest.UserAgentProperty> Options { get; set; }

		[JsonInclude]
		[JsonPropertyName("regex_file")]
		public string RegexFile { get; set; }

		[JsonInclude]
		[JsonPropertyName("target_field")]
		public string TargetField { get; set; }
	}

	[JsonConverter(typeof(UserAgentProcessorDescriptorConverter))]
	public sealed partial class UserAgentProcessorDescriptor : DescriptorBase<UserAgentProcessorDescriptor>, IProcessorContainerVariantDescriptor
	{
		public UserAgentProcessorDescriptor()
		{
		}

		internal UserAgentProcessorDescriptor(Action<UserAgentProcessorDescriptor> configure) => configure.Invoke(this);
		internal string FieldValue { get; private set; }

		internal bool IgnoreMissingValue { get; private set; }

		internal IEnumerable<Elastic.Clients.Elasticsearch.Ingest.UserAgentProperty> OptionsValue { get; private set; }

		internal string RegexFileValue { get; private set; }

		internal string TargetFieldValue { get; private set; }

		public UserAgentProcessorDescriptor Field(string field) => Assign(field, (a, v) => a.FieldValue = v);
		public UserAgentProcessorDescriptor IgnoreMissing(bool ignoreMissing = true) => Assign(ignoreMissing, (a, v) => a.IgnoreMissingValue = v);
		public UserAgentProcessorDescriptor Options(IEnumerable<Elastic.Clients.Elasticsearch.Ingest.UserAgentProperty> options) => Assign(options, (a, v) => a.OptionsValue = v);
		public UserAgentProcessorDescriptor RegexFile(string regexFile) => Assign(regexFile, (a, v) => a.RegexFileValue = v);
		public UserAgentProcessorDescriptor TargetField(string targetField) => Assign(targetField, (a, v) => a.TargetFieldValue = v);
	}

	internal sealed class UserAgentProcessorDescriptorConverter : JsonConverter<UserAgentProcessorDescriptor>
	{
		public override UserAgentProcessorDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, UserAgentProcessorDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, value.FieldValue, options);
			writer.WritePropertyName("ignore_missing");
			writer.WriteBooleanValue(value.IgnoreMissingValue);
			writer.WritePropertyName("options");
			JsonSerializer.Serialize(writer, value.OptionsValue, options);
			writer.WritePropertyName("regex_file");
			writer.WriteStringValue(value.RegexFileValue);
			writer.WritePropertyName("target_field");
			JsonSerializer.Serialize(writer, value.TargetFieldValue, options);
			writer.WriteEndObject();
		}
	}
}