// Licensed to Elasticsearch B.V under one or more agreements.
// Elasticsearch B.V licenses this file to you under the Apache 2.0 License.
// See the LICENSE file in the project root for more information.
//
// ███╗   ██╗ ██████╗ ████████╗██╗ ██████╗███████╗
// ████╗  ██║██╔═══██╗╚══██╔══╝██║██╔════╝██╔════╝
// ██╔██╗ ██║██║   ██║   ██║   ██║██║     █████╗
// ██║╚██╗██║██║   ██║   ██║   ██║██║     ██╔══╝
// ██║ ╚████║╚██████╔╝   ██║   ██║╚██████╗███████╗
// ╚═╝  ╚═══╝ ╚═════╝    ╚═╝   ╚═╝ ╚═════╝╚══════╝
// ------------------------------------------------
//
// This file is automatically generated.
// Please do not edit these files manually.
//
// ------------------------------------------------

using System;
using System.Collections.Generic;
using System.Text.Json;
using System.Text.Json.Serialization;

#nullable restore
namespace Elastic.Clients.Elasticsearch.Ingest
{
	public partial class AppendProcessor : Ingest.ProcessorBase, IProcessorContainerVariant
	{
		[JsonIgnore]
		string Ingest.IProcessorContainerVariant.ProcessorContainerVariantName => "append";
		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("value")]
		public IEnumerable<object> Value { get; set; }

		[JsonInclude]
		[JsonPropertyName("allow_duplicates")]
		public bool? AllowDuplicates { get; set; }
	}

	public sealed partial class AppendProcessorDescriptor<T> : DescriptorBase<AppendProcessorDescriptor<T>>
	{
		public AppendProcessorDescriptor()
		{
		}

		internal AppendProcessorDescriptor(Action<AppendProcessorDescriptor<T>> configure) => configure.Invoke(this);
		internal string FieldValue { get; private set; }

		internal IEnumerable<object> ValueValue { get; private set; }

		internal bool? AllowDuplicatesValue { get; private set; }

		public AppendProcessorDescriptor<T> Field(string field) => Assign(field, (a, v) => a.FieldValue = v);
		public AppendProcessorDescriptor<T> Value(IEnumerable<object> value) => Assign(value, (a, v) => a.ValueValue = v);
		public AppendProcessorDescriptor<T> AllowDuplicates(bool? allowDuplicates = true) => Assign(allowDuplicates, (a, v) => a.AllowDuplicatesValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, FieldValue, options);
			writer.WritePropertyName("value");
			JsonSerializer.Serialize(writer, ValueValue, options);
			if (AllowDuplicatesValue.HasValue)
			{
				writer.WritePropertyName("allow_duplicates");
				writer.WriteBooleanValue(AllowDuplicatesValue.Value);
			}

			writer.WriteEndObject();
		}
	}

	public partial class AttachmentProcessor : Ingest.ProcessorBase, IProcessorContainerVariant
	{
		[JsonIgnore]
		string Ingest.IProcessorContainerVariant.ProcessorContainerVariantName => "attachment";
		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("ignore_missing")]
		public bool? IgnoreMissing { get; set; }

		[JsonInclude]
		[JsonPropertyName("indexed_chars")]
		public long? IndexedChars { get; set; }

		[JsonInclude]
		[JsonPropertyName("indexed_chars_field")]
		public string? IndexedCharsField { get; set; }

		[JsonInclude]
		[JsonPropertyName("properties")]
		public IEnumerable<string>? Properties { get; set; }

		[JsonInclude]
		[JsonPropertyName("target_field")]
		public string? TargetField { get; set; }

		[JsonInclude]
		[JsonPropertyName("resource_name")]
		public string? ResourceName { get; set; }
	}

	public sealed partial class AttachmentProcessorDescriptor<T> : DescriptorBase<AttachmentProcessorDescriptor<T>>
	{
		public AttachmentProcessorDescriptor()
		{
		}

		internal AttachmentProcessorDescriptor(Action<AttachmentProcessorDescriptor<T>> configure) => configure.Invoke(this);
		internal string FieldValue { get; private set; }

		internal bool? IgnoreMissingValue { get; private set; }

		internal long? IndexedCharsValue { get; private set; }

		internal string? IndexedCharsFieldValue { get; private set; }

		internal IEnumerable<string>? PropertiesValue { get; private set; }

		internal string? TargetFieldValue { get; private set; }

		internal string? ResourceNameValue { get; private set; }

		public AttachmentProcessorDescriptor<T> Field(string field) => Assign(field, (a, v) => a.FieldValue = v);
		public AttachmentProcessorDescriptor<T> IgnoreMissing(bool? ignoreMissing = true) => Assign(ignoreMissing, (a, v) => a.IgnoreMissingValue = v);
		public AttachmentProcessorDescriptor<T> IndexedChars(long? indexedChars) => Assign(indexedChars, (a, v) => a.IndexedCharsValue = v);
		public AttachmentProcessorDescriptor<T> IndexedCharsField(string? indexedCharsField) => Assign(indexedCharsField, (a, v) => a.IndexedCharsFieldValue = v);
		public AttachmentProcessorDescriptor<T> Properties(IEnumerable<string>? properties) => Assign(properties, (a, v) => a.PropertiesValue = v);
		public AttachmentProcessorDescriptor<T> TargetField(string? targetField) => Assign(targetField, (a, v) => a.TargetFieldValue = v);
		public AttachmentProcessorDescriptor<T> ResourceName(string? resourceName) => Assign(resourceName, (a, v) => a.ResourceNameValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, FieldValue, options);
			if (IgnoreMissingValue.HasValue)
			{
				writer.WritePropertyName("ignore_missing");
				writer.WriteBooleanValue(IgnoreMissingValue.Value);
			}

			if (IndexedCharsValue.HasValue)
			{
				writer.WritePropertyName("indexed_chars");
				writer.WriteNumberValue(IndexedCharsValue.Value);
			}

			if (IndexedCharsFieldValue is not null)
			{
				writer.WritePropertyName("indexed_chars_field");
				JsonSerializer.Serialize(writer, IndexedCharsFieldValue, options);
			}

			if (PropertiesValue is not null)
			{
				writer.WritePropertyName("properties");
				JsonSerializer.Serialize(writer, PropertiesValue, options);
			}

			if (TargetFieldValue is not null)
			{
				writer.WritePropertyName("target_field");
				JsonSerializer.Serialize(writer, TargetFieldValue, options);
			}

			if (!string.IsNullOrEmpty(ResourceNameValue))
			{
				writer.WritePropertyName("resource_name");
				writer.WriteStringValue(ResourceNameValue);
			}

			writer.WriteEndObject();
		}
	}

	public partial class BytesProcessor : Ingest.ProcessorBase, IProcessorContainerVariant
	{
		[JsonIgnore]
		string Ingest.IProcessorContainerVariant.ProcessorContainerVariantName => "bytes";
		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("ignore_missing")]
		public bool? IgnoreMissing { get; set; }

		[JsonInclude]
		[JsonPropertyName("target_field")]
		public string? TargetField { get; set; }
	}

	public sealed partial class BytesProcessorDescriptor<T> : DescriptorBase<BytesProcessorDescriptor<T>>
	{
		public BytesProcessorDescriptor()
		{
		}

		internal BytesProcessorDescriptor(Action<BytesProcessorDescriptor<T>> configure) => configure.Invoke(this);
		internal string FieldValue { get; private set; }

		internal bool? IgnoreMissingValue { get; private set; }

		internal string? TargetFieldValue { get; private set; }

		public BytesProcessorDescriptor<T> Field(string field) => Assign(field, (a, v) => a.FieldValue = v);
		public BytesProcessorDescriptor<T> IgnoreMissing(bool? ignoreMissing = true) => Assign(ignoreMissing, (a, v) => a.IgnoreMissingValue = v);
		public BytesProcessorDescriptor<T> TargetField(string? targetField) => Assign(targetField, (a, v) => a.TargetFieldValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, FieldValue, options);
			if (IgnoreMissingValue.HasValue)
			{
				writer.WritePropertyName("ignore_missing");
				writer.WriteBooleanValue(IgnoreMissingValue.Value);
			}

			if (TargetFieldValue is not null)
			{
				writer.WritePropertyName("target_field");
				JsonSerializer.Serialize(writer, TargetFieldValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class CircleProcessor : Ingest.ProcessorBase, IProcessorContainerVariant
	{
		[JsonIgnore]
		string Ingest.IProcessorContainerVariant.ProcessorContainerVariantName => "circle";
		[JsonInclude]
		[JsonPropertyName("error_distance")]
		public double ErrorDistance { get; set; }

		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("ignore_missing")]
		public bool IgnoreMissing { get; set; }

		[JsonInclude]
		[JsonPropertyName("shape_type")]
		public Elastic.Clients.Elasticsearch.Ingest.ShapeType ShapeType { get; set; }

		[JsonInclude]
		[JsonPropertyName("target_field")]
		public string TargetField { get; set; }
	}

	public sealed partial class CircleProcessorDescriptor<T> : DescriptorBase<CircleProcessorDescriptor<T>>
	{
		public CircleProcessorDescriptor()
		{
		}

		internal CircleProcessorDescriptor(Action<CircleProcessorDescriptor<T>> configure) => configure.Invoke(this);
		internal double ErrorDistanceValue { get; private set; }

		internal string FieldValue { get; private set; }

		internal bool IgnoreMissingValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Ingest.ShapeType ShapeTypeValue { get; private set; }

		internal string TargetFieldValue { get; private set; }

		public CircleProcessorDescriptor<T> ErrorDistance(double errorDistance) => Assign(errorDistance, (a, v) => a.ErrorDistanceValue = v);
		public CircleProcessorDescriptor<T> Field(string field) => Assign(field, (a, v) => a.FieldValue = v);
		public CircleProcessorDescriptor<T> IgnoreMissing(bool ignoreMissing = true) => Assign(ignoreMissing, (a, v) => a.IgnoreMissingValue = v);
		public CircleProcessorDescriptor<T> ShapeType(Elastic.Clients.Elasticsearch.Ingest.ShapeType shapeType) => Assign(shapeType, (a, v) => a.ShapeTypeValue = v);
		public CircleProcessorDescriptor<T> TargetField(string targetField) => Assign(targetField, (a, v) => a.TargetFieldValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("error_distance");
			writer.WriteNumberValue(ErrorDistanceValue);
			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, FieldValue, options);
			writer.WritePropertyName("ignore_missing");
			writer.WriteBooleanValue(IgnoreMissingValue);
			writer.WritePropertyName("shape_type");
			JsonSerializer.Serialize(writer, ShapeTypeValue, options);
			writer.WritePropertyName("target_field");
			JsonSerializer.Serialize(writer, TargetFieldValue, options);
			writer.WriteEndObject();
		}
	}

	public partial class ConvertProcessor : Ingest.ProcessorBase, IProcessorContainerVariant
	{
		[JsonIgnore]
		string Ingest.IProcessorContainerVariant.ProcessorContainerVariantName => "convert";
		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("ignore_missing")]
		public bool? IgnoreMissing { get; set; }

		[JsonInclude]
		[JsonPropertyName("target_field")]
		public string TargetField { get; set; }

		[JsonInclude]
		[JsonPropertyName("type")]
		public Elastic.Clients.Elasticsearch.Ingest.ConvertType Type { get; set; }
	}

	public sealed partial class ConvertProcessorDescriptor<T> : DescriptorBase<ConvertProcessorDescriptor<T>>
	{
		public ConvertProcessorDescriptor()
		{
		}

		internal ConvertProcessorDescriptor(Action<ConvertProcessorDescriptor<T>> configure) => configure.Invoke(this);
		internal string FieldValue { get; private set; }

		internal bool? IgnoreMissingValue { get; private set; }

		internal string TargetFieldValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Ingest.ConvertType TypeValue { get; private set; }

		public ConvertProcessorDescriptor<T> Field(string field) => Assign(field, (a, v) => a.FieldValue = v);
		public ConvertProcessorDescriptor<T> IgnoreMissing(bool? ignoreMissing = true) => Assign(ignoreMissing, (a, v) => a.IgnoreMissingValue = v);
		public ConvertProcessorDescriptor<T> TargetField(string targetField) => Assign(targetField, (a, v) => a.TargetFieldValue = v);
		public ConvertProcessorDescriptor<T> Type(Elastic.Clients.Elasticsearch.Ingest.ConvertType type) => Assign(type, (a, v) => a.TypeValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, FieldValue, options);
			if (IgnoreMissingValue.HasValue)
			{
				writer.WritePropertyName("ignore_missing");
				writer.WriteBooleanValue(IgnoreMissingValue.Value);
			}

			writer.WritePropertyName("target_field");
			JsonSerializer.Serialize(writer, TargetFieldValue, options);
			writer.WritePropertyName("type");
			JsonSerializer.Serialize(writer, TypeValue, options);
			writer.WriteEndObject();
		}
	}

	public partial class CsvProcessor : Ingest.ProcessorBase, IProcessorContainerVariant
	{
		[JsonIgnore]
		string Ingest.IProcessorContainerVariant.ProcessorContainerVariantName => "csv";
		[JsonInclude]
		[JsonPropertyName("empty_value")]
		public object EmptyValue { get; set; }

		[JsonInclude]
		[JsonPropertyName("description")]
		public string? Description { get; set; }

		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("ignore_missing")]
		public bool? IgnoreMissing { get; set; }

		[JsonInclude]
		[JsonPropertyName("quote")]
		public string? Quote { get; set; }

		[JsonInclude]
		[JsonPropertyName("separator")]
		public string? Separator { get; set; }

		[JsonInclude]
		[JsonPropertyName("target_fields")]
		public Elastic.Clients.Elasticsearch.Fields TargetFields { get; set; }

		[JsonInclude]
		[JsonPropertyName("trim")]
		public bool Trim { get; set; }
	}

	public sealed partial class CsvProcessorDescriptor<T> : DescriptorBase<CsvProcessorDescriptor<T>>
	{
		public CsvProcessorDescriptor()
		{
		}

		internal CsvProcessorDescriptor(Action<CsvProcessorDescriptor<T>> configure) => configure.Invoke(this);
		internal object EmptyValueValue { get; private set; }

		internal string? DescriptionValue { get; private set; }

		internal string FieldValue { get; private set; }

		internal bool? IgnoreMissingValue { get; private set; }

		internal string? QuoteValue { get; private set; }

		internal string? SeparatorValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Fields TargetFieldsValue { get; private set; }

		internal bool TrimValue { get; private set; }

		public CsvProcessorDescriptor<T> EmptyValue(object emptyValue) => Assign(emptyValue, (a, v) => a.EmptyValueValue = v);
		public CsvProcessorDescriptor<T> Description(string? description) => Assign(description, (a, v) => a.DescriptionValue = v);
		public CsvProcessorDescriptor<T> Field(string field) => Assign(field, (a, v) => a.FieldValue = v);
		public CsvProcessorDescriptor<T> IgnoreMissing(bool? ignoreMissing = true) => Assign(ignoreMissing, (a, v) => a.IgnoreMissingValue = v);
		public CsvProcessorDescriptor<T> Quote(string? quote) => Assign(quote, (a, v) => a.QuoteValue = v);
		public CsvProcessorDescriptor<T> Separator(string? separator) => Assign(separator, (a, v) => a.SeparatorValue = v);
		public CsvProcessorDescriptor<T> TargetFields(Elastic.Clients.Elasticsearch.Fields targetFields) => Assign(targetFields, (a, v) => a.TargetFieldsValue = v);
		public CsvProcessorDescriptor<T> Trim(bool trim = true) => Assign(trim, (a, v) => a.TrimValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (!string.IsNullOrEmpty(DescriptionValue))
			{
				writer.WritePropertyName("description");
				writer.WriteStringValue(DescriptionValue);
			}

			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, FieldValue, options);
			if (IgnoreMissingValue.HasValue)
			{
				writer.WritePropertyName("ignore_missing");
				writer.WriteBooleanValue(IgnoreMissingValue.Value);
			}

			if (!string.IsNullOrEmpty(QuoteValue))
			{
				writer.WritePropertyName("quote");
				writer.WriteStringValue(QuoteValue);
			}

			if (!string.IsNullOrEmpty(SeparatorValue))
			{
				writer.WritePropertyName("separator");
				writer.WriteStringValue(SeparatorValue);
			}

			writer.WritePropertyName("target_fields");
			JsonSerializer.Serialize(writer, TargetFieldsValue, options);
			writer.WritePropertyName("trim");
			writer.WriteBooleanValue(TrimValue);
			writer.WriteEndObject();
		}
	}

	public partial class DateIndexNameProcessor : Ingest.ProcessorBase, IProcessorContainerVariant
	{
		[JsonIgnore]
		string Ingest.IProcessorContainerVariant.ProcessorContainerVariantName => "date_index_name";
		[JsonInclude]
		[JsonPropertyName("date_formats")]
		public IEnumerable<string> DateFormats { get; set; }

		[JsonInclude]
		[JsonPropertyName("date_rounding")]
		public string DateRounding { get; set; }

		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("index_name_format")]
		public string IndexNameFormat { get; set; }

		[JsonInclude]
		[JsonPropertyName("index_name_prefix")]
		public string IndexNamePrefix { get; set; }

		[JsonInclude]
		[JsonPropertyName("locale")]
		public string Locale { get; set; }

		[JsonInclude]
		[JsonPropertyName("timezone")]
		public string Timezone { get; set; }
	}

	public sealed partial class DateIndexNameProcessorDescriptor<T> : DescriptorBase<DateIndexNameProcessorDescriptor<T>>
	{
		public DateIndexNameProcessorDescriptor()
		{
		}

		internal DateIndexNameProcessorDescriptor(Action<DateIndexNameProcessorDescriptor<T>> configure) => configure.Invoke(this);
		internal IEnumerable<string> DateFormatsValue { get; private set; }

		internal string DateRoundingValue { get; private set; }

		internal string FieldValue { get; private set; }

		internal string IndexNameFormatValue { get; private set; }

		internal string IndexNamePrefixValue { get; private set; }

		internal string LocaleValue { get; private set; }

		internal string TimezoneValue { get; private set; }

		public DateIndexNameProcessorDescriptor<T> DateFormats(IEnumerable<string> dateFormats) => Assign(dateFormats, (a, v) => a.DateFormatsValue = v);
		public DateIndexNameProcessorDescriptor<T> DateRounding(string dateRounding) => Assign(dateRounding, (a, v) => a.DateRoundingValue = v);
		public DateIndexNameProcessorDescriptor<T> Field(string field) => Assign(field, (a, v) => a.FieldValue = v);
		public DateIndexNameProcessorDescriptor<T> IndexNameFormat(string indexNameFormat) => Assign(indexNameFormat, (a, v) => a.IndexNameFormatValue = v);
		public DateIndexNameProcessorDescriptor<T> IndexNamePrefix(string indexNamePrefix) => Assign(indexNamePrefix, (a, v) => a.IndexNamePrefixValue = v);
		public DateIndexNameProcessorDescriptor<T> Locale(string locale) => Assign(locale, (a, v) => a.LocaleValue = v);
		public DateIndexNameProcessorDescriptor<T> Timezone(string timezone) => Assign(timezone, (a, v) => a.TimezoneValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("date_formats");
			JsonSerializer.Serialize(writer, DateFormatsValue, options);
			writer.WritePropertyName("date_rounding");
			writer.WriteStringValue(DateRoundingValue);
			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, FieldValue, options);
			writer.WritePropertyName("index_name_format");
			writer.WriteStringValue(IndexNameFormatValue);
			writer.WritePropertyName("index_name_prefix");
			writer.WriteStringValue(IndexNamePrefixValue);
			writer.WritePropertyName("locale");
			writer.WriteStringValue(LocaleValue);
			writer.WritePropertyName("timezone");
			writer.WriteStringValue(TimezoneValue);
			writer.WriteEndObject();
		}
	}

	public partial class DateProcessor : Ingest.ProcessorBase, IProcessorContainerVariant
	{
		[JsonIgnore]
		string Ingest.IProcessorContainerVariant.ProcessorContainerVariantName => "date";
		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("formats")]
		public IEnumerable<string> Formats { get; set; }

		[JsonInclude]
		[JsonPropertyName("locale")]
		public string? Locale { get; set; }

		[JsonInclude]
		[JsonPropertyName("target_field")]
		public string? TargetField { get; set; }

		[JsonInclude]
		[JsonPropertyName("timezone")]
		public string? Timezone { get; set; }
	}

	public sealed partial class DateProcessorDescriptor<T> : DescriptorBase<DateProcessorDescriptor<T>>
	{
		public DateProcessorDescriptor()
		{
		}

		internal DateProcessorDescriptor(Action<DateProcessorDescriptor<T>> configure) => configure.Invoke(this);
		internal string FieldValue { get; private set; }

		internal IEnumerable<string> FormatsValue { get; private set; }

		internal string? LocaleValue { get; private set; }

		internal string? TargetFieldValue { get; private set; }

		internal string? TimezoneValue { get; private set; }

		public DateProcessorDescriptor<T> Field(string field) => Assign(field, (a, v) => a.FieldValue = v);
		public DateProcessorDescriptor<T> Formats(IEnumerable<string> formats) => Assign(formats, (a, v) => a.FormatsValue = v);
		public DateProcessorDescriptor<T> Locale(string? locale) => Assign(locale, (a, v) => a.LocaleValue = v);
		public DateProcessorDescriptor<T> TargetField(string? targetField) => Assign(targetField, (a, v) => a.TargetFieldValue = v);
		public DateProcessorDescriptor<T> Timezone(string? timezone) => Assign(timezone, (a, v) => a.TimezoneValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, FieldValue, options);
			writer.WritePropertyName("formats");
			JsonSerializer.Serialize(writer, FormatsValue, options);
			if (!string.IsNullOrEmpty(LocaleValue))
			{
				writer.WritePropertyName("locale");
				writer.WriteStringValue(LocaleValue);
			}

			if (TargetFieldValue is not null)
			{
				writer.WritePropertyName("target_field");
				JsonSerializer.Serialize(writer, TargetFieldValue, options);
			}

			if (!string.IsNullOrEmpty(TimezoneValue))
			{
				writer.WritePropertyName("timezone");
				writer.WriteStringValue(TimezoneValue);
			}

			writer.WriteEndObject();
		}
	}

	public partial class DissectProcessor : Ingest.ProcessorBase, IProcessorContainerVariant
	{
		[JsonIgnore]
		string Ingest.IProcessorContainerVariant.ProcessorContainerVariantName => "dissect";
		[JsonInclude]
		[JsonPropertyName("append_separator")]
		public string AppendSeparator { get; set; }

		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("ignore_missing")]
		public bool IgnoreMissing { get; set; }

		[JsonInclude]
		[JsonPropertyName("pattern")]
		public string Pattern { get; set; }
	}

	public sealed partial class DissectProcessorDescriptor<T> : DescriptorBase<DissectProcessorDescriptor<T>>
	{
		public DissectProcessorDescriptor()
		{
		}

		internal DissectProcessorDescriptor(Action<DissectProcessorDescriptor<T>> configure) => configure.Invoke(this);
		internal string AppendSeparatorValue { get; private set; }

		internal string FieldValue { get; private set; }

		internal bool IgnoreMissingValue { get; private set; }

		internal string PatternValue { get; private set; }

		public DissectProcessorDescriptor<T> AppendSeparator(string appendSeparator) => Assign(appendSeparator, (a, v) => a.AppendSeparatorValue = v);
		public DissectProcessorDescriptor<T> Field(string field) => Assign(field, (a, v) => a.FieldValue = v);
		public DissectProcessorDescriptor<T> IgnoreMissing(bool ignoreMissing = true) => Assign(ignoreMissing, (a, v) => a.IgnoreMissingValue = v);
		public DissectProcessorDescriptor<T> Pattern(string pattern) => Assign(pattern, (a, v) => a.PatternValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("append_separator");
			writer.WriteStringValue(AppendSeparatorValue);
			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, FieldValue, options);
			writer.WritePropertyName("ignore_missing");
			writer.WriteBooleanValue(IgnoreMissingValue);
			writer.WritePropertyName("pattern");
			writer.WriteStringValue(PatternValue);
			writer.WriteEndObject();
		}
	}

	public partial class DotExpanderProcessor : Ingest.ProcessorBase, IProcessorContainerVariant
	{
		[JsonIgnore]
		string Ingest.IProcessorContainerVariant.ProcessorContainerVariantName => "dot_expander";
		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("path")]
		public string? Path { get; set; }
	}

	public sealed partial class DotExpanderProcessorDescriptor<T> : DescriptorBase<DotExpanderProcessorDescriptor<T>>
	{
		public DotExpanderProcessorDescriptor()
		{
		}

		internal DotExpanderProcessorDescriptor(Action<DotExpanderProcessorDescriptor<T>> configure) => configure.Invoke(this);
		internal string FieldValue { get; private set; }

		internal string? PathValue { get; private set; }

		public DotExpanderProcessorDescriptor<T> Field(string field) => Assign(field, (a, v) => a.FieldValue = v);
		public DotExpanderProcessorDescriptor<T> Path(string? path) => Assign(path, (a, v) => a.PathValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, FieldValue, options);
			if (!string.IsNullOrEmpty(PathValue))
			{
				writer.WritePropertyName("path");
				writer.WriteStringValue(PathValue);
			}

			writer.WriteEndObject();
		}
	}

	public partial class DropProcessor : Ingest.ProcessorBase, IProcessorContainerVariant
	{
		[JsonIgnore]
		string Ingest.IProcessorContainerVariant.ProcessorContainerVariantName => "drop";
	}

	public sealed partial class DropProcessorDescriptor : DescriptorBase<DropProcessorDescriptor>
	{
		public DropProcessorDescriptor()
		{
		}

		internal DropProcessorDescriptor(Action<DropProcessorDescriptor> configure) => configure.Invoke(this);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WriteEndObject();
		}
	}

	public partial class EnrichProcessor : Ingest.ProcessorBase, IProcessorContainerVariant
	{
		[JsonIgnore]
		string Ingest.IProcessorContainerVariant.ProcessorContainerVariantName => "enrich";
		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("ignore_missing")]
		public bool? IgnoreMissing { get; set; }

		[JsonInclude]
		[JsonPropertyName("max_matches")]
		public int? MaxMatches { get; set; }

		[JsonInclude]
		[JsonPropertyName("override")]
		public bool? Override { get; set; }

		[JsonInclude]
		[JsonPropertyName("policy_name")]
		public string PolicyName { get; set; }

		[JsonInclude]
		[JsonPropertyName("shape_relation")]
		public Elastic.Clients.Elasticsearch.GeoShapeRelation? ShapeRelation { get; set; }

		[JsonInclude]
		[JsonPropertyName("target_field")]
		public string TargetField { get; set; }
	}

	public sealed partial class EnrichProcessorDescriptor<T> : DescriptorBase<EnrichProcessorDescriptor<T>>
	{
		public EnrichProcessorDescriptor()
		{
		}

		internal EnrichProcessorDescriptor(Action<EnrichProcessorDescriptor<T>> configure) => configure.Invoke(this);
		internal string FieldValue { get; private set; }

		internal bool? IgnoreMissingValue { get; private set; }

		internal int? MaxMatchesValue { get; private set; }

		internal bool? OverrideValue { get; private set; }

		internal string PolicyNameValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.GeoShapeRelation? ShapeRelationValue { get; private set; }

		internal string TargetFieldValue { get; private set; }

		public EnrichProcessorDescriptor<T> Field(string field) => Assign(field, (a, v) => a.FieldValue = v);
		public EnrichProcessorDescriptor<T> IgnoreMissing(bool? ignoreMissing = true) => Assign(ignoreMissing, (a, v) => a.IgnoreMissingValue = v);
		public EnrichProcessorDescriptor<T> MaxMatches(int? maxMatches) => Assign(maxMatches, (a, v) => a.MaxMatchesValue = v);
		public EnrichProcessorDescriptor<T> Override(bool? overrideValue = true) => Assign(overrideValue, (a, v) => a.OverrideValue = v);
		public EnrichProcessorDescriptor<T> PolicyName(string policyName) => Assign(policyName, (a, v) => a.PolicyNameValue = v);
		public EnrichProcessorDescriptor<T> ShapeRelation(Elastic.Clients.Elasticsearch.GeoShapeRelation? shapeRelation) => Assign(shapeRelation, (a, v) => a.ShapeRelationValue = v);
		public EnrichProcessorDescriptor<T> TargetField(string targetField) => Assign(targetField, (a, v) => a.TargetFieldValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, FieldValue, options);
			if (IgnoreMissingValue.HasValue)
			{
				writer.WritePropertyName("ignore_missing");
				writer.WriteBooleanValue(IgnoreMissingValue.Value);
			}

			if (MaxMatchesValue.HasValue)
			{
				writer.WritePropertyName("max_matches");
				writer.WriteNumberValue(MaxMatchesValue.Value);
			}

			if (OverrideValue.HasValue)
			{
				writer.WritePropertyName("override");
				writer.WriteBooleanValue(OverrideValue.Value);
			}

			writer.WritePropertyName("policy_name");
			writer.WriteStringValue(PolicyNameValue);
			if (ShapeRelationValue is not null)
			{
				writer.WritePropertyName("shape_relation");
				JsonSerializer.Serialize(writer, ShapeRelationValue, options);
			}

			writer.WritePropertyName("target_field");
			JsonSerializer.Serialize(writer, TargetFieldValue, options);
			writer.WriteEndObject();
		}
	}

	public partial class FailProcessor : Ingest.ProcessorBase, IProcessorContainerVariant
	{
		[JsonIgnore]
		string Ingest.IProcessorContainerVariant.ProcessorContainerVariantName => "fail";
		[JsonInclude]
		[JsonPropertyName("message")]
		public string Message { get; set; }
	}

	public sealed partial class FailProcessorDescriptor : DescriptorBase<FailProcessorDescriptor>
	{
		public FailProcessorDescriptor()
		{
		}

		internal FailProcessorDescriptor(Action<FailProcessorDescriptor> configure) => configure.Invoke(this);
		internal string MessageValue { get; private set; }

		public FailProcessorDescriptor Message(string message) => Assign(message, (a, v) => a.MessageValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("message");
			writer.WriteStringValue(MessageValue);
			writer.WriteEndObject();
		}
	}

	public partial class ForeachProcessor : Ingest.ProcessorBase, IProcessorContainerVariant
	{
		[JsonIgnore]
		string Ingest.IProcessorContainerVariant.ProcessorContainerVariantName => "foreach";
		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("ignore_missing")]
		public bool? IgnoreMissing { get; set; }

		[JsonInclude]
		[JsonPropertyName("processor")]
		public Elastic.Clients.Elasticsearch.Ingest.ProcessorContainer Processor { get; set; }
	}

	public sealed partial class ForeachProcessorDescriptor<T> : DescriptorBase<ForeachProcessorDescriptor<T>>
	{
		public ForeachProcessorDescriptor()
		{
		}

		internal ForeachProcessorDescriptor(Action<ForeachProcessorDescriptor<T>> configure) => configure.Invoke(this);
		internal string FieldValue { get; private set; }

		internal bool? IgnoreMissingValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Ingest.ProcessorContainer ProcessorValue { get; private set; }

		internal ProcessorContainerDescriptor<T> ProcessorDescriptor { get; private set; }

		internal Action<ProcessorContainerDescriptor<T>> ProcessorDescriptorAction { get; private set; }

		public ForeachProcessorDescriptor<T> Field(string field) => Assign(field, (a, v) => a.FieldValue = v);
		public ForeachProcessorDescriptor<T> IgnoreMissing(bool? ignoreMissing = true) => Assign(ignoreMissing, (a, v) => a.IgnoreMissingValue = v);
		public ForeachProcessorDescriptor<T> Processor(Elastic.Clients.Elasticsearch.Ingest.ProcessorContainer processor)
		{
			ProcessorDescriptor = null;
			ProcessorDescriptorAction = null;
			return Assign(processor, (a, v) => a.ProcessorValue = v);
		}

		public ForeachProcessorDescriptor<T> Processor(Elastic.Clients.Elasticsearch.Ingest.ProcessorContainerDescriptor<T> descriptor)
		{
			ProcessorValue = null;
			ProcessorDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.ProcessorDescriptor = v);
		}

		public ForeachProcessorDescriptor<T> Processor(Action<Elastic.Clients.Elasticsearch.Ingest.ProcessorContainerDescriptor<T>> configure)
		{
			ProcessorValue = null;
			ProcessorDescriptorAction = null;
			return Assign(configure, (a, v) => a.ProcessorDescriptorAction = v);
		}

		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, FieldValue, options);
			if (IgnoreMissingValue.HasValue)
			{
				writer.WritePropertyName("ignore_missing");
				writer.WriteBooleanValue(IgnoreMissingValue.Value);
			}

			if (ProcessorDescriptor is not null)
			{
				writer.WritePropertyName("processor");
				JsonSerializer.Serialize(writer, ProcessorDescriptor, options);
			}
			else if (ProcessorDescriptorAction is not null)
			{
				writer.WritePropertyName("processor");
				JsonSerializer.Serialize(writer, new ProcessorContainerDescriptor<T>(ProcessorDescriptorAction), options);
			}
			else
			{
				writer.WritePropertyName("processor");
				JsonSerializer.Serialize(writer, ProcessorValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class GeoIpProcessor : Ingest.ProcessorBase, IProcessorContainerVariant
	{
		[JsonIgnore]
		string Ingest.IProcessorContainerVariant.ProcessorContainerVariantName => "geoip";
		[JsonInclude]
		[JsonPropertyName("database_file")]
		public string DatabaseFile { get; set; }

		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("first_only")]
		public bool FirstOnly { get; set; }

		[JsonInclude]
		[JsonPropertyName("ignore_missing")]
		public bool IgnoreMissing { get; set; }

		[JsonInclude]
		[JsonPropertyName("properties")]
		public IEnumerable<string> Properties { get; set; }

		[JsonInclude]
		[JsonPropertyName("target_field")]
		public string TargetField { get; set; }
	}

	public sealed partial class GeoIpProcessorDescriptor<T> : DescriptorBase<GeoIpProcessorDescriptor<T>>
	{
		public GeoIpProcessorDescriptor()
		{
		}

		internal GeoIpProcessorDescriptor(Action<GeoIpProcessorDescriptor<T>> configure) => configure.Invoke(this);
		internal string DatabaseFileValue { get; private set; }

		internal string FieldValue { get; private set; }

		internal bool FirstOnlyValue { get; private set; }

		internal bool IgnoreMissingValue { get; private set; }

		internal IEnumerable<string> PropertiesValue { get; private set; }

		internal string TargetFieldValue { get; private set; }

		public GeoIpProcessorDescriptor<T> DatabaseFile(string databaseFile) => Assign(databaseFile, (a, v) => a.DatabaseFileValue = v);
		public GeoIpProcessorDescriptor<T> Field(string field) => Assign(field, (a, v) => a.FieldValue = v);
		public GeoIpProcessorDescriptor<T> FirstOnly(bool firstOnly = true) => Assign(firstOnly, (a, v) => a.FirstOnlyValue = v);
		public GeoIpProcessorDescriptor<T> IgnoreMissing(bool ignoreMissing = true) => Assign(ignoreMissing, (a, v) => a.IgnoreMissingValue = v);
		public GeoIpProcessorDescriptor<T> Properties(IEnumerable<string> properties) => Assign(properties, (a, v) => a.PropertiesValue = v);
		public GeoIpProcessorDescriptor<T> TargetField(string targetField) => Assign(targetField, (a, v) => a.TargetFieldValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("database_file");
			writer.WriteStringValue(DatabaseFileValue);
			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, FieldValue, options);
			writer.WritePropertyName("first_only");
			writer.WriteBooleanValue(FirstOnlyValue);
			writer.WritePropertyName("ignore_missing");
			writer.WriteBooleanValue(IgnoreMissingValue);
			writer.WritePropertyName("properties");
			JsonSerializer.Serialize(writer, PropertiesValue, options);
			writer.WritePropertyName("target_field");
			JsonSerializer.Serialize(writer, TargetFieldValue, options);
			writer.WriteEndObject();
		}
	}

	public partial class GrokProcessor : Ingest.ProcessorBase, IProcessorContainerVariant
	{
		[JsonIgnore]
		string Ingest.IProcessorContainerVariant.ProcessorContainerVariantName => "grok";
		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("ignore_missing")]
		public bool? IgnoreMissing { get; set; }

		[JsonInclude]
		[JsonPropertyName("pattern_definitions")]
		public Dictionary<string, string> PatternDefinitions { get; set; }

		[JsonInclude]
		[JsonPropertyName("patterns")]
		public IEnumerable<string> Patterns { get; set; }

		[JsonInclude]
		[JsonPropertyName("trace_match")]
		public bool? TraceMatch { get; set; }
	}

	public sealed partial class GrokProcessorDescriptor<T> : DescriptorBase<GrokProcessorDescriptor<T>>
	{
		public GrokProcessorDescriptor()
		{
		}

		internal GrokProcessorDescriptor(Action<GrokProcessorDescriptor<T>> configure) => configure.Invoke(this);
		internal string FieldValue { get; private set; }

		internal bool? IgnoreMissingValue { get; private set; }

		internal Dictionary<string, string> PatternDefinitionsValue { get; private set; }

		internal IEnumerable<string> PatternsValue { get; private set; }

		internal bool? TraceMatchValue { get; private set; }

		public GrokProcessorDescriptor<T> Field(string field) => Assign(field, (a, v) => a.FieldValue = v);
		public GrokProcessorDescriptor<T> IgnoreMissing(bool? ignoreMissing = true) => Assign(ignoreMissing, (a, v) => a.IgnoreMissingValue = v);
		public GrokProcessorDescriptor<T> PatternDefinitions(Func<FluentDictionary<string, string>, FluentDictionary<string, string>> selector) => Assign(selector, (a, v) => a.PatternDefinitionsValue = v?.Invoke(new FluentDictionary<string, string>()));
		public GrokProcessorDescriptor<T> Patterns(IEnumerable<string> patterns) => Assign(patterns, (a, v) => a.PatternsValue = v);
		public GrokProcessorDescriptor<T> TraceMatch(bool? traceMatch = true) => Assign(traceMatch, (a, v) => a.TraceMatchValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, FieldValue, options);
			if (IgnoreMissingValue.HasValue)
			{
				writer.WritePropertyName("ignore_missing");
				writer.WriteBooleanValue(IgnoreMissingValue.Value);
			}

			writer.WritePropertyName("pattern_definitions");
			JsonSerializer.Serialize(writer, PatternDefinitionsValue, options);
			writer.WritePropertyName("patterns");
			JsonSerializer.Serialize(writer, PatternsValue, options);
			if (TraceMatchValue.HasValue)
			{
				writer.WritePropertyName("trace_match");
				writer.WriteBooleanValue(TraceMatchValue.Value);
			}

			writer.WriteEndObject();
		}
	}

	public partial class GsubProcessor : Ingest.ProcessorBase, IProcessorContainerVariant
	{
		[JsonIgnore]
		string Ingest.IProcessorContainerVariant.ProcessorContainerVariantName => "gsub";
		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("ignore_missing")]
		public bool? IgnoreMissing { get; set; }

		[JsonInclude]
		[JsonPropertyName("pattern")]
		public string Pattern { get; set; }

		[JsonInclude]
		[JsonPropertyName("replacement")]
		public string Replacement { get; set; }

		[JsonInclude]
		[JsonPropertyName("target_field")]
		public string? TargetField { get; set; }
	}

	public sealed partial class GsubProcessorDescriptor<T> : DescriptorBase<GsubProcessorDescriptor<T>>
	{
		public GsubProcessorDescriptor()
		{
		}

		internal GsubProcessorDescriptor(Action<GsubProcessorDescriptor<T>> configure) => configure.Invoke(this);
		internal string FieldValue { get; private set; }

		internal bool? IgnoreMissingValue { get; private set; }

		internal string PatternValue { get; private set; }

		internal string ReplacementValue { get; private set; }

		internal string? TargetFieldValue { get; private set; }

		public GsubProcessorDescriptor<T> Field(string field) => Assign(field, (a, v) => a.FieldValue = v);
		public GsubProcessorDescriptor<T> IgnoreMissing(bool? ignoreMissing = true) => Assign(ignoreMissing, (a, v) => a.IgnoreMissingValue = v);
		public GsubProcessorDescriptor<T> Pattern(string pattern) => Assign(pattern, (a, v) => a.PatternValue = v);
		public GsubProcessorDescriptor<T> Replacement(string replacement) => Assign(replacement, (a, v) => a.ReplacementValue = v);
		public GsubProcessorDescriptor<T> TargetField(string? targetField) => Assign(targetField, (a, v) => a.TargetFieldValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, FieldValue, options);
			if (IgnoreMissingValue.HasValue)
			{
				writer.WritePropertyName("ignore_missing");
				writer.WriteBooleanValue(IgnoreMissingValue.Value);
			}

			writer.WritePropertyName("pattern");
			writer.WriteStringValue(PatternValue);
			writer.WritePropertyName("replacement");
			writer.WriteStringValue(ReplacementValue);
			if (TargetFieldValue is not null)
			{
				writer.WritePropertyName("target_field");
				JsonSerializer.Serialize(writer, TargetFieldValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class InferenceConfig
	{
		[JsonInclude]
		[JsonPropertyName("regression")]
		public Elastic.Clients.Elasticsearch.Ingest.InferenceConfigRegression? Regression { get; set; }
	}

	public sealed partial class InferenceConfigDescriptor : DescriptorBase<InferenceConfigDescriptor>
	{
		public InferenceConfigDescriptor()
		{
		}

		internal InferenceConfigDescriptor(Action<InferenceConfigDescriptor> configure) => configure.Invoke(this);
		internal Elastic.Clients.Elasticsearch.Ingest.InferenceConfigRegression? RegressionValue { get; private set; }

		internal InferenceConfigRegressionDescriptor RegressionDescriptor { get; private set; }

		internal Action<InferenceConfigRegressionDescriptor> RegressionDescriptorAction { get; private set; }

		public InferenceConfigDescriptor Regression(Elastic.Clients.Elasticsearch.Ingest.InferenceConfigRegression? regression)
		{
			RegressionDescriptor = null;
			RegressionDescriptorAction = null;
			return Assign(regression, (a, v) => a.RegressionValue = v);
		}

		public InferenceConfigDescriptor Regression(Elastic.Clients.Elasticsearch.Ingest.InferenceConfigRegressionDescriptor descriptor)
		{
			RegressionValue = null;
			RegressionDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.RegressionDescriptor = v);
		}

		public InferenceConfigDescriptor Regression(Action<Elastic.Clients.Elasticsearch.Ingest.InferenceConfigRegressionDescriptor> configure)
		{
			RegressionValue = null;
			RegressionDescriptorAction = null;
			return Assign(configure, (a, v) => a.RegressionDescriptorAction = v);
		}

		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (RegressionDescriptor is not null)
			{
				writer.WritePropertyName("regression");
				JsonSerializer.Serialize(writer, RegressionDescriptor, options);
			}
			else if (RegressionDescriptorAction is not null)
			{
				writer.WritePropertyName("regression");
				JsonSerializer.Serialize(writer, new InferenceConfigRegressionDescriptor(RegressionDescriptorAction), options);
			}
			else if (RegressionValue is not null)
			{
				writer.WritePropertyName("regression");
				JsonSerializer.Serialize(writer, RegressionValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class InferenceConfigRegression
	{
		[JsonInclude]
		[JsonPropertyName("results_field")]
		public string ResultsField { get; set; }
	}

	public sealed partial class InferenceConfigRegressionDescriptor : DescriptorBase<InferenceConfigRegressionDescriptor>
	{
		public InferenceConfigRegressionDescriptor()
		{
		}

		internal InferenceConfigRegressionDescriptor(Action<InferenceConfigRegressionDescriptor> configure) => configure.Invoke(this);
		internal string ResultsFieldValue { get; private set; }

		public InferenceConfigRegressionDescriptor ResultsField(string resultsField) => Assign(resultsField, (a, v) => a.ResultsFieldValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("results_field");
			writer.WriteStringValue(ResultsFieldValue);
			writer.WriteEndObject();
		}
	}

	public partial class InferenceProcessor : Ingest.ProcessorBase, IProcessorContainerVariant
	{
		[JsonIgnore]
		string Ingest.IProcessorContainerVariant.ProcessorContainerVariantName => "inference";
		[JsonInclude]
		[JsonPropertyName("model_id")]
		public Elastic.Clients.Elasticsearch.Id ModelId { get; set; }

		[JsonInclude]
		[JsonPropertyName("target_field")]
		public string TargetField { get; set; }

		[JsonInclude]
		[JsonPropertyName("field_map")]
		public Dictionary<string, object>? FieldMap { get; set; }

		[JsonInclude]
		[JsonPropertyName("inference_config")]
		public Elastic.Clients.Elasticsearch.Ingest.InferenceConfig? InferenceConfig { get; set; }
	}

	public sealed partial class InferenceProcessorDescriptor<T> : DescriptorBase<InferenceProcessorDescriptor<T>>
	{
		public InferenceProcessorDescriptor()
		{
		}

		internal InferenceProcessorDescriptor(Action<InferenceProcessorDescriptor<T>> configure) => configure.Invoke(this);
		internal Elastic.Clients.Elasticsearch.Id ModelIdValue { get; private set; }

		internal string TargetFieldValue { get; private set; }

		internal Dictionary<string, object>? FieldMapValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Ingest.InferenceConfig? InferenceConfigValue { get; private set; }

		internal InferenceConfigDescriptor InferenceConfigDescriptor { get; private set; }

		internal Action<InferenceConfigDescriptor> InferenceConfigDescriptorAction { get; private set; }

		public InferenceProcessorDescriptor<T> ModelId(Elastic.Clients.Elasticsearch.Id modelId) => Assign(modelId, (a, v) => a.ModelIdValue = v);
		public InferenceProcessorDescriptor<T> TargetField(string targetField) => Assign(targetField, (a, v) => a.TargetFieldValue = v);
		public InferenceProcessorDescriptor<T> FieldMap(Func<FluentDictionary<string?, object?>, FluentDictionary<string?, object?>> selector) => Assign(selector, (a, v) => a.FieldMapValue = v?.Invoke(new FluentDictionary<string?, object?>()));
		public InferenceProcessorDescriptor<T> InferenceConfig(Elastic.Clients.Elasticsearch.Ingest.InferenceConfig? inferenceConfig)
		{
			InferenceConfigDescriptor = null;
			InferenceConfigDescriptorAction = null;
			return Assign(inferenceConfig, (a, v) => a.InferenceConfigValue = v);
		}

		public InferenceProcessorDescriptor<T> InferenceConfig(Elastic.Clients.Elasticsearch.Ingest.InferenceConfigDescriptor descriptor)
		{
			InferenceConfigValue = null;
			InferenceConfigDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.InferenceConfigDescriptor = v);
		}

		public InferenceProcessorDescriptor<T> InferenceConfig(Action<Elastic.Clients.Elasticsearch.Ingest.InferenceConfigDescriptor> configure)
		{
			InferenceConfigValue = null;
			InferenceConfigDescriptorAction = null;
			return Assign(configure, (a, v) => a.InferenceConfigDescriptorAction = v);
		}

		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("model_id");
			JsonSerializer.Serialize(writer, ModelIdValue, options);
			writer.WritePropertyName("target_field");
			JsonSerializer.Serialize(writer, TargetFieldValue, options);
			if (FieldMapValue is not null)
			{
				writer.WritePropertyName("field_map");
				JsonSerializer.Serialize(writer, FieldMapValue, options);
			}

			if (InferenceConfigDescriptor is not null)
			{
				writer.WritePropertyName("inference_config");
				JsonSerializer.Serialize(writer, InferenceConfigDescriptor, options);
			}
			else if (InferenceConfigDescriptorAction is not null)
			{
				writer.WritePropertyName("inference_config");
				JsonSerializer.Serialize(writer, new InferenceConfigDescriptor(InferenceConfigDescriptorAction), options);
			}
			else if (InferenceConfigValue is not null)
			{
				writer.WritePropertyName("inference_config");
				JsonSerializer.Serialize(writer, InferenceConfigValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class JoinProcessor : Ingest.ProcessorBase, IProcessorContainerVariant
	{
		[JsonIgnore]
		string Ingest.IProcessorContainerVariant.ProcessorContainerVariantName => "join";
		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("separator")]
		public string Separator { get; set; }

		[JsonInclude]
		[JsonPropertyName("target_field")]
		public string? TargetField { get; set; }
	}

	public sealed partial class JoinProcessorDescriptor<T> : DescriptorBase<JoinProcessorDescriptor<T>>
	{
		public JoinProcessorDescriptor()
		{
		}

		internal JoinProcessorDescriptor(Action<JoinProcessorDescriptor<T>> configure) => configure.Invoke(this);
		internal string FieldValue { get; private set; }

		internal string SeparatorValue { get; private set; }

		internal string? TargetFieldValue { get; private set; }

		public JoinProcessorDescriptor<T> Field(string field) => Assign(field, (a, v) => a.FieldValue = v);
		public JoinProcessorDescriptor<T> Separator(string separator) => Assign(separator, (a, v) => a.SeparatorValue = v);
		public JoinProcessorDescriptor<T> TargetField(string? targetField) => Assign(targetField, (a, v) => a.TargetFieldValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, FieldValue, options);
			writer.WritePropertyName("separator");
			writer.WriteStringValue(SeparatorValue);
			if (TargetFieldValue is not null)
			{
				writer.WritePropertyName("target_field");
				JsonSerializer.Serialize(writer, TargetFieldValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class JsonProcessor : Ingest.ProcessorBase, IProcessorContainerVariant
	{
		[JsonIgnore]
		string Ingest.IProcessorContainerVariant.ProcessorContainerVariantName => "json";
		[JsonInclude]
		[JsonPropertyName("add_to_root")]
		public bool AddToRoot { get; set; }

		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("target_field")]
		public string TargetField { get; set; }
	}

	public sealed partial class JsonProcessorDescriptor<T> : DescriptorBase<JsonProcessorDescriptor<T>>
	{
		public JsonProcessorDescriptor()
		{
		}

		internal JsonProcessorDescriptor(Action<JsonProcessorDescriptor<T>> configure) => configure.Invoke(this);
		internal bool AddToRootValue { get; private set; }

		internal string FieldValue { get; private set; }

		internal string TargetFieldValue { get; private set; }

		public JsonProcessorDescriptor<T> AddToRoot(bool addToRoot = true) => Assign(addToRoot, (a, v) => a.AddToRootValue = v);
		public JsonProcessorDescriptor<T> Field(string field) => Assign(field, (a, v) => a.FieldValue = v);
		public JsonProcessorDescriptor<T> TargetField(string targetField) => Assign(targetField, (a, v) => a.TargetFieldValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("add_to_root");
			writer.WriteBooleanValue(AddToRootValue);
			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, FieldValue, options);
			writer.WritePropertyName("target_field");
			JsonSerializer.Serialize(writer, TargetFieldValue, options);
			writer.WriteEndObject();
		}
	}

	public partial class KeyValueProcessor : Ingest.ProcessorBase, IProcessorContainerVariant
	{
		[JsonIgnore]
		string Ingest.IProcessorContainerVariant.ProcessorContainerVariantName => "kv";
		[JsonInclude]
		[JsonPropertyName("exclude_keys")]
		public IEnumerable<string>? ExcludeKeys { get; set; }

		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("field_split")]
		public string FieldSplit { get; set; }

		[JsonInclude]
		[JsonPropertyName("ignore_missing")]
		public bool? IgnoreMissing { get; set; }

		[JsonInclude]
		[JsonPropertyName("include_keys")]
		public IEnumerable<string>? IncludeKeys { get; set; }

		[JsonInclude]
		[JsonPropertyName("prefix")]
		public string? Prefix { get; set; }

		[JsonInclude]
		[JsonPropertyName("strip_brackets")]
		public bool? StripBrackets { get; set; }

		[JsonInclude]
		[JsonPropertyName("target_field")]
		public string? TargetField { get; set; }

		[JsonInclude]
		[JsonPropertyName("trim_key")]
		public string? TrimKey { get; set; }

		[JsonInclude]
		[JsonPropertyName("trim_value")]
		public string? TrimValue { get; set; }

		[JsonInclude]
		[JsonPropertyName("value_split")]
		public string ValueSplit { get; set; }
	}

	public sealed partial class KeyValueProcessorDescriptor<T> : DescriptorBase<KeyValueProcessorDescriptor<T>>
	{
		public KeyValueProcessorDescriptor()
		{
		}

		internal KeyValueProcessorDescriptor(Action<KeyValueProcessorDescriptor<T>> configure) => configure.Invoke(this);
		internal IEnumerable<string>? ExcludeKeysValue { get; private set; }

		internal string FieldValue { get; private set; }

		internal string FieldSplitValue { get; private set; }

		internal bool? IgnoreMissingValue { get; private set; }

		internal IEnumerable<string>? IncludeKeysValue { get; private set; }

		internal string? PrefixValue { get; private set; }

		internal bool? StripBracketsValue { get; private set; }

		internal string? TargetFieldValue { get; private set; }

		internal string? TrimKeyValue { get; private set; }

		internal string? TrimValueValue { get; private set; }

		internal string ValueSplitValue { get; private set; }

		public KeyValueProcessorDescriptor<T> ExcludeKeys(IEnumerable<string>? excludeKeys) => Assign(excludeKeys, (a, v) => a.ExcludeKeysValue = v);
		public KeyValueProcessorDescriptor<T> Field(string field) => Assign(field, (a, v) => a.FieldValue = v);
		public KeyValueProcessorDescriptor<T> FieldSplit(string fieldSplit) => Assign(fieldSplit, (a, v) => a.FieldSplitValue = v);
		public KeyValueProcessorDescriptor<T> IgnoreMissing(bool? ignoreMissing = true) => Assign(ignoreMissing, (a, v) => a.IgnoreMissingValue = v);
		public KeyValueProcessorDescriptor<T> IncludeKeys(IEnumerable<string>? includeKeys) => Assign(includeKeys, (a, v) => a.IncludeKeysValue = v);
		public KeyValueProcessorDescriptor<T> Prefix(string? prefix) => Assign(prefix, (a, v) => a.PrefixValue = v);
		public KeyValueProcessorDescriptor<T> StripBrackets(bool? stripBrackets = true) => Assign(stripBrackets, (a, v) => a.StripBracketsValue = v);
		public KeyValueProcessorDescriptor<T> TargetField(string? targetField) => Assign(targetField, (a, v) => a.TargetFieldValue = v);
		public KeyValueProcessorDescriptor<T> TrimKey(string? trimKey) => Assign(trimKey, (a, v) => a.TrimKeyValue = v);
		public KeyValueProcessorDescriptor<T> TrimValue(string? trimValue) => Assign(trimValue, (a, v) => a.TrimValueValue = v);
		public KeyValueProcessorDescriptor<T> ValueSplit(string valueSplit) => Assign(valueSplit, (a, v) => a.ValueSplitValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (ExcludeKeysValue is not null)
			{
				writer.WritePropertyName("exclude_keys");
				JsonSerializer.Serialize(writer, ExcludeKeysValue, options);
			}

			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, FieldValue, options);
			writer.WritePropertyName("field_split");
			writer.WriteStringValue(FieldSplitValue);
			if (IgnoreMissingValue.HasValue)
			{
				writer.WritePropertyName("ignore_missing");
				writer.WriteBooleanValue(IgnoreMissingValue.Value);
			}

			if (IncludeKeysValue is not null)
			{
				writer.WritePropertyName("include_keys");
				JsonSerializer.Serialize(writer, IncludeKeysValue, options);
			}

			if (!string.IsNullOrEmpty(PrefixValue))
			{
				writer.WritePropertyName("prefix");
				writer.WriteStringValue(PrefixValue);
			}

			if (StripBracketsValue.HasValue)
			{
				writer.WritePropertyName("strip_brackets");
				writer.WriteBooleanValue(StripBracketsValue.Value);
			}

			if (TargetFieldValue is not null)
			{
				writer.WritePropertyName("target_field");
				JsonSerializer.Serialize(writer, TargetFieldValue, options);
			}

			if (!string.IsNullOrEmpty(TrimKeyValue))
			{
				writer.WritePropertyName("trim_key");
				writer.WriteStringValue(TrimKeyValue);
			}

			if (!string.IsNullOrEmpty(TrimValueValue))
			{
				writer.WritePropertyName("trim_value");
				writer.WriteStringValue(TrimValueValue);
			}

			writer.WritePropertyName("value_split");
			writer.WriteStringValue(ValueSplitValue);
			writer.WriteEndObject();
		}
	}

	public partial class LowercaseProcessor : Ingest.ProcessorBase, IProcessorContainerVariant
	{
		[JsonIgnore]
		string Ingest.IProcessorContainerVariant.ProcessorContainerVariantName => "lowercase";
		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("ignore_missing")]
		public bool? IgnoreMissing { get; set; }

		[JsonInclude]
		[JsonPropertyName("target_field")]
		public string? TargetField { get; set; }
	}

	public sealed partial class LowercaseProcessorDescriptor<T> : DescriptorBase<LowercaseProcessorDescriptor<T>>
	{
		public LowercaseProcessorDescriptor()
		{
		}

		internal LowercaseProcessorDescriptor(Action<LowercaseProcessorDescriptor<T>> configure) => configure.Invoke(this);
		internal string FieldValue { get; private set; }

		internal bool? IgnoreMissingValue { get; private set; }

		internal string? TargetFieldValue { get; private set; }

		public LowercaseProcessorDescriptor<T> Field(string field) => Assign(field, (a, v) => a.FieldValue = v);
		public LowercaseProcessorDescriptor<T> IgnoreMissing(bool? ignoreMissing = true) => Assign(ignoreMissing, (a, v) => a.IgnoreMissingValue = v);
		public LowercaseProcessorDescriptor<T> TargetField(string? targetField) => Assign(targetField, (a, v) => a.TargetFieldValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, FieldValue, options);
			if (IgnoreMissingValue.HasValue)
			{
				writer.WritePropertyName("ignore_missing");
				writer.WriteBooleanValue(IgnoreMissingValue.Value);
			}

			if (TargetFieldValue is not null)
			{
				writer.WritePropertyName("target_field");
				JsonSerializer.Serialize(writer, TargetFieldValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class Pipeline
	{
		[JsonInclude]
		[JsonPropertyName("description")]
		public string? Description { get; set; }

		[JsonInclude]
		[JsonPropertyName("on_failure")]
		public IEnumerable<Elastic.Clients.Elasticsearch.Ingest.ProcessorContainer>? OnFailure { get; set; }

		[JsonInclude]
		[JsonPropertyName("processors")]
		public IEnumerable<Elastic.Clients.Elasticsearch.Ingest.ProcessorContainer>? Processors { get; set; }

		[JsonInclude]
		[JsonPropertyName("version")]
		public long? Version { get; set; }
	}

	public sealed partial class PipelineDescriptor : DescriptorBase<PipelineDescriptor>
	{
		public PipelineDescriptor()
		{
		}

		internal PipelineDescriptor(Action<PipelineDescriptor> configure) => configure.Invoke(this);
		internal string? DescriptionValue { get; private set; }

		internal IEnumerable<Elastic.Clients.Elasticsearch.Ingest.ProcessorContainer>? OnFailureValue { get; private set; }

		internal IEnumerable<Elastic.Clients.Elasticsearch.Ingest.ProcessorContainer>? ProcessorsValue { get; private set; }

		internal long? VersionValue { get; private set; }

		public PipelineDescriptor Description(string? description) => Assign(description, (a, v) => a.DescriptionValue = v);
		public PipelineDescriptor OnFailure(IEnumerable<Elastic.Clients.Elasticsearch.Ingest.ProcessorContainer>? onFailure) => Assign(onFailure, (a, v) => a.OnFailureValue = v);
		public PipelineDescriptor Processors(IEnumerable<Elastic.Clients.Elasticsearch.Ingest.ProcessorContainer>? processors) => Assign(processors, (a, v) => a.ProcessorsValue = v);
		public PipelineDescriptor Version(long? version) => Assign(version, (a, v) => a.VersionValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (!string.IsNullOrEmpty(DescriptionValue))
			{
				writer.WritePropertyName("description");
				writer.WriteStringValue(DescriptionValue);
			}

			if (OnFailureValue is not null)
			{
				writer.WritePropertyName("on_failure");
				JsonSerializer.Serialize(writer, OnFailureValue, options);
			}

			if (ProcessorsValue is not null)
			{
				writer.WritePropertyName("processors");
				JsonSerializer.Serialize(writer, ProcessorsValue, options);
			}

			if (VersionValue is not null)
			{
				writer.WritePropertyName("version");
				JsonSerializer.Serialize(writer, VersionValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class PipelineProcessor : Ingest.ProcessorBase, IProcessorContainerVariant
	{
		[JsonIgnore]
		string Ingest.IProcessorContainerVariant.ProcessorContainerVariantName => "pipeline";
		[JsonInclude]
		[JsonPropertyName("name")]
		public Elastic.Clients.Elasticsearch.Name Name { get; set; }
	}

	public sealed partial class PipelineProcessorDescriptor : DescriptorBase<PipelineProcessorDescriptor>
	{
		public PipelineProcessorDescriptor()
		{
		}

		internal PipelineProcessorDescriptor(Action<PipelineProcessorDescriptor> configure) => configure.Invoke(this);
		internal Elastic.Clients.Elasticsearch.Name NameValue { get; private set; }

		public PipelineProcessorDescriptor Name(Elastic.Clients.Elasticsearch.Name name) => Assign(name, (a, v) => a.NameValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("name");
			JsonSerializer.Serialize(writer, NameValue, options);
			writer.WriteEndObject();
		}
	}

	public abstract partial class ProcessorBase
	{
		[JsonInclude]
		[JsonPropertyName("if")]
		public string? If { get; set; }

		[JsonInclude]
		[JsonPropertyName("ignore_failure")]
		public bool? IgnoreFailure { get; set; }

		[JsonInclude]
		[JsonPropertyName("on_failure")]
		public IEnumerable<Elastic.Clients.Elasticsearch.Ingest.ProcessorContainer>? OnFailure { get; set; }

		[JsonInclude]
		[JsonPropertyName("tag")]
		public string? Tag { get; set; }
	}

	public sealed partial class ProcessorBaseDescriptor : DescriptorBase<ProcessorBaseDescriptor>
	{
		public ProcessorBaseDescriptor()
		{
		}

		internal ProcessorBaseDescriptor(Action<ProcessorBaseDescriptor> configure) => configure.Invoke(this);
		internal string? IfValue { get; private set; }

		internal bool? IgnoreFailureValue { get; private set; }

		internal IEnumerable<Elastic.Clients.Elasticsearch.Ingest.ProcessorContainer>? OnFailureValue { get; private set; }

		internal string? TagValue { get; private set; }

		public ProcessorBaseDescriptor If(string? ifValue) => Assign(ifValue, (a, v) => a.IfValue = v);
		public ProcessorBaseDescriptor IgnoreFailure(bool? ignoreFailure = true) => Assign(ignoreFailure, (a, v) => a.IgnoreFailureValue = v);
		public ProcessorBaseDescriptor OnFailure(IEnumerable<Elastic.Clients.Elasticsearch.Ingest.ProcessorContainer>? onFailure) => Assign(onFailure, (a, v) => a.OnFailureValue = v);
		public ProcessorBaseDescriptor Tag(string? tag) => Assign(tag, (a, v) => a.TagValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (!string.IsNullOrEmpty(IfValue))
			{
				writer.WritePropertyName("if");
				writer.WriteStringValue(IfValue);
			}

			if (IgnoreFailureValue.HasValue)
			{
				writer.WritePropertyName("ignore_failure");
				writer.WriteBooleanValue(IgnoreFailureValue.Value);
			}

			if (OnFailureValue is not null)
			{
				writer.WritePropertyName("on_failure");
				JsonSerializer.Serialize(writer, OnFailureValue, options);
			}

			if (!string.IsNullOrEmpty(TagValue))
			{
				writer.WritePropertyName("tag");
				writer.WriteStringValue(TagValue);
			}

			writer.WriteEndObject();
		}
	}

	public interface IProcessorContainerVariant
	{
		string ProcessorContainerVariantName { get; }
	}

	[JsonConverter(typeof(ProcessorContainerConverter))]
	public partial class ProcessorContainer : IContainer
	{
		public ProcessorContainer(IProcessorContainerVariant variant) => Variant = variant ?? throw new ArgumentNullException(nameof(variant));
		internal IProcessorContainerVariant Variant { get; }
	}

	internal sealed class ProcessorContainerConverter : JsonConverter<ProcessorContainer>
	{
		public override ProcessorContainer Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			reader.Read();
			if (reader.TokenType != JsonTokenType.PropertyName)
			{
				throw new JsonException();
			}

			var propertyName = reader.GetString();
			if (propertyName == "attachment")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.AttachmentProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(variant);
			}

			if (propertyName == "append")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.AppendProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(variant);
			}

			if (propertyName == "csv")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.CsvProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(variant);
			}

			if (propertyName == "convert")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.ConvertProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(variant);
			}

			if (propertyName == "date")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.DateProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(variant);
			}

			if (propertyName == "date_index_name")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.DateIndexNameProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(variant);
			}

			if (propertyName == "dot_expander")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.DotExpanderProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(variant);
			}

			if (propertyName == "enrich")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.EnrichProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(variant);
			}

			if (propertyName == "fail")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.FailProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(variant);
			}

			if (propertyName == "foreach")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.ForeachProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(variant);
			}

			if (propertyName == "json")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.JsonProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(variant);
			}

			if (propertyName == "user_agent")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.UserAgentProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(variant);
			}

			if (propertyName == "kv")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.KeyValueProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(variant);
			}

			if (propertyName == "geoip")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.GeoIpProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(variant);
			}

			if (propertyName == "grok")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.GrokProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(variant);
			}

			if (propertyName == "gsub")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.GsubProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(variant);
			}

			if (propertyName == "join")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.JoinProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(variant);
			}

			if (propertyName == "lowercase")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.LowercaseProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(variant);
			}

			if (propertyName == "remove")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.RemoveProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(variant);
			}

			if (propertyName == "rename")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.RenameProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(variant);
			}

			if (propertyName == "set")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.SetProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(variant);
			}

			if (propertyName == "sort")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.SortProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(variant);
			}

			if (propertyName == "split")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.SplitProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(variant);
			}

			if (propertyName == "trim")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.TrimProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(variant);
			}

			if (propertyName == "uppercase")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.UppercaseProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(variant);
			}

			if (propertyName == "urldecode")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.UrlDecodeProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(variant);
			}

			if (propertyName == "bytes")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.BytesProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(variant);
			}

			if (propertyName == "dissect")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.DissectProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(variant);
			}

			if (propertyName == "set_security_user")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.SetSecurityUserProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(variant);
			}

			if (propertyName == "pipeline")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.PipelineProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(variant);
			}

			if (propertyName == "drop")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.DropProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(variant);
			}

			if (propertyName == "circle")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.CircleProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(variant);
			}

			if (propertyName == "inference")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.InferenceProcessor?>(ref reader, options);
				reader.Read();
				return new ProcessorContainer(variant);
			}

			throw new JsonException();
		}

		public override void Write(Utf8JsonWriter writer, ProcessorContainer value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName(value.Variant.ProcessorContainerVariantName);
			switch (value.Variant)
			{
				case Elastic.Clients.Elasticsearch.Ingest.AttachmentProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.AppendProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.CsvProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.ConvertProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.DateProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.DateIndexNameProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.DotExpanderProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.EnrichProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.FailProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.ForeachProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.JsonProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.UserAgentProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.KeyValueProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.GeoIpProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.GrokProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.GsubProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.JoinProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.LowercaseProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.RemoveProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.RenameProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.SetProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.SortProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.SplitProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.TrimProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.UppercaseProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.UrlDecodeProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.BytesProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.DissectProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.SetSecurityUserProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.PipelineProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.DropProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.CircleProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Ingest.InferenceProcessor variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
			}

			writer.WriteEndObject();
		}
	}

	public sealed partial class ProcessorContainerDescriptor<T> : DescriptorBase<ProcessorContainerDescriptor<T>>
	{
		public ProcessorContainerDescriptor()
		{
		}

		internal ProcessorContainerDescriptor(Action<ProcessorContainerDescriptor<T>> configure) => configure.Invoke(this);
		internal bool ContainsVariant { get; private set; }

		internal string ContainedVariantName { get; private set; }

		internal ProcessorContainer Container { get; private set; }

		internal object ContainerVariantDescriptorAction { get; private set; }

		private void Set(object descriptorAction, string variantName)
		{
			if (ContainsVariant)
				throw new Exception("TODO");
			ContainerVariantDescriptorAction = descriptorAction;
			ContainedVariantName = variantName;
			ContainsVariant = true;
		}

		private void Set(IProcessorContainerVariant variant, string variantName)
		{
			if (ContainsVariant)
				throw new Exception("TODO");
			Container = new ProcessorContainer(variant);
			ContainedVariantName = variantName;
			ContainsVariant = true;
		}

		public void Attachment(AttachmentProcessor variant) => Set(variant, "attachment");
		public void Attachment(Action<AttachmentProcessorDescriptor<T>> configure) => Set(configure, "attachment");
		public void Append(AppendProcessor variant) => Set(variant, "append");
		public void Append(Action<AppendProcessorDescriptor<T>> configure) => Set(configure, "append");
		public void Csv(CsvProcessor variant) => Set(variant, "csv");
		public void Csv(Action<CsvProcessorDescriptor<T>> configure) => Set(configure, "csv");
		public void Convert(ConvertProcessor variant) => Set(variant, "convert");
		public void Convert(Action<ConvertProcessorDescriptor<T>> configure) => Set(configure, "convert");
		public void Date(DateProcessor variant) => Set(variant, "date");
		public void Date(Action<DateProcessorDescriptor<T>> configure) => Set(configure, "date");
		public void DateIndexName(DateIndexNameProcessor variant) => Set(variant, "date_index_name");
		public void DateIndexName(Action<DateIndexNameProcessorDescriptor<T>> configure) => Set(configure, "date_index_name");
		public void DotExpander(DotExpanderProcessor variant) => Set(variant, "dot_expander");
		public void DotExpander(Action<DotExpanderProcessorDescriptor<T>> configure) => Set(configure, "dot_expander");
		public void Enrich(EnrichProcessor variant) => Set(variant, "enrich");
		public void Enrich(Action<EnrichProcessorDescriptor<T>> configure) => Set(configure, "enrich");
		public void Fail(FailProcessor variant) => Set(variant, "fail");
		public void Fail(Action<FailProcessorDescriptor> configure) => Set(configure, "fail");
		public void Foreach(ForeachProcessor variant) => Set(variant, "foreach");
		public void Foreach(Action<ForeachProcessorDescriptor<T>> configure) => Set(configure, "foreach");
		public void Json(JsonProcessor variant) => Set(variant, "json");
		public void Json(Action<JsonProcessorDescriptor<T>> configure) => Set(configure, "json");
		public void UserAgent(UserAgentProcessor variant) => Set(variant, "user_agent");
		public void UserAgent(Action<UserAgentProcessorDescriptor<T>> configure) => Set(configure, "user_agent");
		public void Kv(KeyValueProcessor variant) => Set(variant, "kv");
		public void Kv(Action<KeyValueProcessorDescriptor<T>> configure) => Set(configure, "kv");
		public void Geoip(GeoIpProcessor variant) => Set(variant, "geoip");
		public void Geoip(Action<GeoIpProcessorDescriptor<T>> configure) => Set(configure, "geoip");
		public void Grok(GrokProcessor variant) => Set(variant, "grok");
		public void Grok(Action<GrokProcessorDescriptor<T>> configure) => Set(configure, "grok");
		public void Gsub(GsubProcessor variant) => Set(variant, "gsub");
		public void Gsub(Action<GsubProcessorDescriptor<T>> configure) => Set(configure, "gsub");
		public void Join(JoinProcessor variant) => Set(variant, "join");
		public void Join(Action<JoinProcessorDescriptor<T>> configure) => Set(configure, "join");
		public void Lowercase(LowercaseProcessor variant) => Set(variant, "lowercase");
		public void Lowercase(Action<LowercaseProcessorDescriptor<T>> configure) => Set(configure, "lowercase");
		public void Remove(RemoveProcessor variant) => Set(variant, "remove");
		public void Remove(Action<RemoveProcessorDescriptor<T>> configure) => Set(configure, "remove");
		public void Rename(RenameProcessor variant) => Set(variant, "rename");
		public void Rename(Action<RenameProcessorDescriptor<T>> configure) => Set(configure, "rename");
		public void Set(SetProcessor variant) => Set(variant, "set");
		public void Set(Action<SetProcessorDescriptor<T>> configure) => Set(configure, "set");
		public void Sort(SortProcessor variant) => Set(variant, "sort");
		public void Sort(Action<SortProcessorDescriptor<T>> configure) => Set(configure, "sort");
		public void Split(SplitProcessor variant) => Set(variant, "split");
		public void Split(Action<SplitProcessorDescriptor<T>> configure) => Set(configure, "split");
		public void Trim(TrimProcessor variant) => Set(variant, "trim");
		public void Trim(Action<TrimProcessorDescriptor<T>> configure) => Set(configure, "trim");
		public void Uppercase(UppercaseProcessor variant) => Set(variant, "uppercase");
		public void Uppercase(Action<UppercaseProcessorDescriptor<T>> configure) => Set(configure, "uppercase");
		public void Urldecode(UrlDecodeProcessor variant) => Set(variant, "urldecode");
		public void Urldecode(Action<UrlDecodeProcessorDescriptor<T>> configure) => Set(configure, "urldecode");
		public void Bytes(BytesProcessor variant) => Set(variant, "bytes");
		public void Bytes(Action<BytesProcessorDescriptor<T>> configure) => Set(configure, "bytes");
		public void Dissect(DissectProcessor variant) => Set(variant, "dissect");
		public void Dissect(Action<DissectProcessorDescriptor<T>> configure) => Set(configure, "dissect");
		public void SetSecurityUser(SetSecurityUserProcessor variant) => Set(variant, "set_security_user");
		public void SetSecurityUser(Action<SetSecurityUserProcessorDescriptor<T>> configure) => Set(configure, "set_security_user");
		public void Pipeline(PipelineProcessor variant) => Set(variant, "pipeline");
		public void Pipeline(Action<PipelineProcessorDescriptor> configure) => Set(configure, "pipeline");
		public void Drop(DropProcessor variant) => Set(variant, "drop");
		public void Drop(Action<DropProcessorDescriptor> configure) => Set(configure, "drop");
		public void Circle(CircleProcessor variant) => Set(variant, "circle");
		public void Circle(Action<CircleProcessorDescriptor<T>> configure) => Set(configure, "circle");
		public void Inference(InferenceProcessor variant) => Set(variant, "inference");
		public void Inference(Action<InferenceProcessorDescriptor<T>> configure) => Set(configure, "inference");
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			if (!ContainsVariant)
			{
				writer.WriteNullValue();
				return;
			}

			writer.WriteStartObject();
			writer.WritePropertyName(ContainedVariantName);
			writer.WriteStartObject();
			if (Container is not null)
			{
				JsonSerializer.Serialize(writer, Container, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "attachment")
			{
				var descriptor = new AttachmentProcessorDescriptor<T>();
				((Action<AttachmentProcessorDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "append")
			{
				var descriptor = new AppendProcessorDescriptor<T>();
				((Action<AppendProcessorDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "csv")
			{
				var descriptor = new CsvProcessorDescriptor<T>();
				((Action<CsvProcessorDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "convert")
			{
				var descriptor = new ConvertProcessorDescriptor<T>();
				((Action<ConvertProcessorDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "date")
			{
				var descriptor = new DateProcessorDescriptor<T>();
				((Action<DateProcessorDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "date_index_name")
			{
				var descriptor = new DateIndexNameProcessorDescriptor<T>();
				((Action<DateIndexNameProcessorDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "dot_expander")
			{
				var descriptor = new DotExpanderProcessorDescriptor<T>();
				((Action<DotExpanderProcessorDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "enrich")
			{
				var descriptor = new EnrichProcessorDescriptor<T>();
				((Action<EnrichProcessorDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "fail")
			{
				var descriptor = new FailProcessorDescriptor();
				((Action<FailProcessorDescriptor>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "foreach")
			{
				var descriptor = new ForeachProcessorDescriptor<T>();
				((Action<ForeachProcessorDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "json")
			{
				var descriptor = new JsonProcessorDescriptor<T>();
				((Action<JsonProcessorDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "user_agent")
			{
				var descriptor = new UserAgentProcessorDescriptor<T>();
				((Action<UserAgentProcessorDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "kv")
			{
				var descriptor = new KeyValueProcessorDescriptor<T>();
				((Action<KeyValueProcessorDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "geoip")
			{
				var descriptor = new GeoIpProcessorDescriptor<T>();
				((Action<GeoIpProcessorDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "grok")
			{
				var descriptor = new GrokProcessorDescriptor<T>();
				((Action<GrokProcessorDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "gsub")
			{
				var descriptor = new GsubProcessorDescriptor<T>();
				((Action<GsubProcessorDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "join")
			{
				var descriptor = new JoinProcessorDescriptor<T>();
				((Action<JoinProcessorDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "lowercase")
			{
				var descriptor = new LowercaseProcessorDescriptor<T>();
				((Action<LowercaseProcessorDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "remove")
			{
				var descriptor = new RemoveProcessorDescriptor<T>();
				((Action<RemoveProcessorDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "rename")
			{
				var descriptor = new RenameProcessorDescriptor<T>();
				((Action<RenameProcessorDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "set")
			{
				var descriptor = new SetProcessorDescriptor<T>();
				((Action<SetProcessorDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "sort")
			{
				var descriptor = new SortProcessorDescriptor<T>();
				((Action<SortProcessorDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "split")
			{
				var descriptor = new SplitProcessorDescriptor<T>();
				((Action<SplitProcessorDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "trim")
			{
				var descriptor = new TrimProcessorDescriptor<T>();
				((Action<TrimProcessorDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "uppercase")
			{
				var descriptor = new UppercaseProcessorDescriptor<T>();
				((Action<UppercaseProcessorDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "urldecode")
			{
				var descriptor = new UrlDecodeProcessorDescriptor<T>();
				((Action<UrlDecodeProcessorDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "bytes")
			{
				var descriptor = new BytesProcessorDescriptor<T>();
				((Action<BytesProcessorDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "dissect")
			{
				var descriptor = new DissectProcessorDescriptor<T>();
				((Action<DissectProcessorDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "set_security_user")
			{
				var descriptor = new SetSecurityUserProcessorDescriptor<T>();
				((Action<SetSecurityUserProcessorDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "pipeline")
			{
				var descriptor = new PipelineProcessorDescriptor();
				((Action<PipelineProcessorDescriptor>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "drop")
			{
				var descriptor = new DropProcessorDescriptor();
				((Action<DropProcessorDescriptor>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "circle")
			{
				var descriptor = new CircleProcessorDescriptor<T>();
				((Action<CircleProcessorDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			if (ContainedVariantName == "inference")
			{
				var descriptor = new InferenceProcessorDescriptor<T>();
				((Action<InferenceProcessorDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
				Finalise();
				return;
			}

			writer.WriteEndObject();
			writer.WriteEndObject();
			void Finalise()
			{
				writer.WriteEndObject();
				writer.WriteEndObject();
			}
		}
	}

	public partial class RemoveProcessor : Ingest.ProcessorBase, IProcessorContainerVariant
	{
		[JsonIgnore]
		string Ingest.IProcessorContainerVariant.ProcessorContainerVariantName => "remove";
		[JsonInclude]
		[JsonPropertyName("field")]
		public Elastic.Clients.Elasticsearch.Fields Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("ignore_missing")]
		public bool? IgnoreMissing { get; set; }
	}

	public sealed partial class RemoveProcessorDescriptor<T> : DescriptorBase<RemoveProcessorDescriptor<T>>
	{
		public RemoveProcessorDescriptor()
		{
		}

		internal RemoveProcessorDescriptor(Action<RemoveProcessorDescriptor<T>> configure) => configure.Invoke(this);
		internal Elastic.Clients.Elasticsearch.Fields FieldValue { get; private set; }

		internal bool? IgnoreMissingValue { get; private set; }

		public RemoveProcessorDescriptor<T> Field(Elastic.Clients.Elasticsearch.Fields field) => Assign(field, (a, v) => a.FieldValue = v);
		public RemoveProcessorDescriptor<T> IgnoreMissing(bool? ignoreMissing = true) => Assign(ignoreMissing, (a, v) => a.IgnoreMissingValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, FieldValue, options);
			if (IgnoreMissingValue.HasValue)
			{
				writer.WritePropertyName("ignore_missing");
				writer.WriteBooleanValue(IgnoreMissingValue.Value);
			}

			writer.WriteEndObject();
		}
	}

	public partial class RenameProcessor : Ingest.ProcessorBase, IProcessorContainerVariant
	{
		[JsonIgnore]
		string Ingest.IProcessorContainerVariant.ProcessorContainerVariantName => "rename";
		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("ignore_missing")]
		public bool? IgnoreMissing { get; set; }

		[JsonInclude]
		[JsonPropertyName("target_field")]
		public string TargetField { get; set; }
	}

	public sealed partial class RenameProcessorDescriptor<T> : DescriptorBase<RenameProcessorDescriptor<T>>
	{
		public RenameProcessorDescriptor()
		{
		}

		internal RenameProcessorDescriptor(Action<RenameProcessorDescriptor<T>> configure) => configure.Invoke(this);
		internal string FieldValue { get; private set; }

		internal bool? IgnoreMissingValue { get; private set; }

		internal string TargetFieldValue { get; private set; }

		public RenameProcessorDescriptor<T> Field(string field) => Assign(field, (a, v) => a.FieldValue = v);
		public RenameProcessorDescriptor<T> IgnoreMissing(bool? ignoreMissing = true) => Assign(ignoreMissing, (a, v) => a.IgnoreMissingValue = v);
		public RenameProcessorDescriptor<T> TargetField(string targetField) => Assign(targetField, (a, v) => a.TargetFieldValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, FieldValue, options);
			if (IgnoreMissingValue.HasValue)
			{
				writer.WritePropertyName("ignore_missing");
				writer.WriteBooleanValue(IgnoreMissingValue.Value);
			}

			writer.WritePropertyName("target_field");
			JsonSerializer.Serialize(writer, TargetFieldValue, options);
			writer.WriteEndObject();
		}
	}

	public partial class SetProcessor : Ingest.ProcessorBase, IProcessorContainerVariant
	{
		[JsonIgnore]
		string Ingest.IProcessorContainerVariant.ProcessorContainerVariantName => "set";
		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("override")]
		public bool? Override { get; set; }

		[JsonInclude]
		[JsonPropertyName("value")]
		public object Value { get; set; }
	}

	public sealed partial class SetProcessorDescriptor<T> : DescriptorBase<SetProcessorDescriptor<T>>
	{
		public SetProcessorDescriptor()
		{
		}

		internal SetProcessorDescriptor(Action<SetProcessorDescriptor<T>> configure) => configure.Invoke(this);
		internal string FieldValue { get; private set; }

		internal bool? OverrideValue { get; private set; }

		internal object ValueValue { get; private set; }

		public SetProcessorDescriptor<T> Field(string field) => Assign(field, (a, v) => a.FieldValue = v);
		public SetProcessorDescriptor<T> Override(bool? overrideValue = true) => Assign(overrideValue, (a, v) => a.OverrideValue = v);
		public SetProcessorDescriptor<T> Value(object value) => Assign(value, (a, v) => a.ValueValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, FieldValue, options);
			if (OverrideValue.HasValue)
			{
				writer.WritePropertyName("override");
				writer.WriteBooleanValue(OverrideValue.Value);
			}

			writer.WriteEndObject();
		}
	}

	public partial class SetSecurityUserProcessor : Ingest.ProcessorBase, IProcessorContainerVariant
	{
		[JsonIgnore]
		string Ingest.IProcessorContainerVariant.ProcessorContainerVariantName => "set_security_user";
		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("properties")]
		public IEnumerable<string>? Properties { get; set; }
	}

	public sealed partial class SetSecurityUserProcessorDescriptor<T> : DescriptorBase<SetSecurityUserProcessorDescriptor<T>>
	{
		public SetSecurityUserProcessorDescriptor()
		{
		}

		internal SetSecurityUserProcessorDescriptor(Action<SetSecurityUserProcessorDescriptor<T>> configure) => configure.Invoke(this);
		internal string FieldValue { get; private set; }

		internal IEnumerable<string>? PropertiesValue { get; private set; }

		public SetSecurityUserProcessorDescriptor<T> Field(string field) => Assign(field, (a, v) => a.FieldValue = v);
		public SetSecurityUserProcessorDescriptor<T> Properties(IEnumerable<string>? properties) => Assign(properties, (a, v) => a.PropertiesValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, FieldValue, options);
			if (PropertiesValue is not null)
			{
				writer.WritePropertyName("properties");
				JsonSerializer.Serialize(writer, PropertiesValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class SortProcessor : Ingest.ProcessorBase, IProcessorContainerVariant
	{
		[JsonIgnore]
		string Ingest.IProcessorContainerVariant.ProcessorContainerVariantName => "sort";
		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("order")]
		public Elastic.Clients.Elasticsearch.SortOrder Order { get; set; }

		[JsonInclude]
		[JsonPropertyName("target_field")]
		public string TargetField { get; set; }
	}

	public sealed partial class SortProcessorDescriptor<T> : DescriptorBase<SortProcessorDescriptor<T>>
	{
		public SortProcessorDescriptor()
		{
		}

		internal SortProcessorDescriptor(Action<SortProcessorDescriptor<T>> configure) => configure.Invoke(this);
		internal string FieldValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.SortOrder OrderValue { get; private set; }

		internal string TargetFieldValue { get; private set; }

		public SortProcessorDescriptor<T> Field(string field) => Assign(field, (a, v) => a.FieldValue = v);
		public SortProcessorDescriptor<T> Order(Elastic.Clients.Elasticsearch.SortOrder order) => Assign(order, (a, v) => a.OrderValue = v);
		public SortProcessorDescriptor<T> TargetField(string targetField) => Assign(targetField, (a, v) => a.TargetFieldValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, FieldValue, options);
			writer.WritePropertyName("order");
			JsonSerializer.Serialize(writer, OrderValue, options);
			writer.WritePropertyName("target_field");
			JsonSerializer.Serialize(writer, TargetFieldValue, options);
			writer.WriteEndObject();
		}
	}

	public partial class SplitProcessor : Ingest.ProcessorBase, IProcessorContainerVariant
	{
		[JsonIgnore]
		string Ingest.IProcessorContainerVariant.ProcessorContainerVariantName => "split";
		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("ignore_missing")]
		public bool? IgnoreMissing { get; set; }

		[JsonInclude]
		[JsonPropertyName("preserve_trailing")]
		public bool? PreserveTrailing { get; set; }

		[JsonInclude]
		[JsonPropertyName("separator")]
		public string Separator { get; set; }

		[JsonInclude]
		[JsonPropertyName("target_field")]
		public string? TargetField { get; set; }
	}

	public sealed partial class SplitProcessorDescriptor<T> : DescriptorBase<SplitProcessorDescriptor<T>>
	{
		public SplitProcessorDescriptor()
		{
		}

		internal SplitProcessorDescriptor(Action<SplitProcessorDescriptor<T>> configure) => configure.Invoke(this);
		internal string FieldValue { get; private set; }

		internal bool? IgnoreMissingValue { get; private set; }

		internal bool? PreserveTrailingValue { get; private set; }

		internal string SeparatorValue { get; private set; }

		internal string? TargetFieldValue { get; private set; }

		public SplitProcessorDescriptor<T> Field(string field) => Assign(field, (a, v) => a.FieldValue = v);
		public SplitProcessorDescriptor<T> IgnoreMissing(bool? ignoreMissing = true) => Assign(ignoreMissing, (a, v) => a.IgnoreMissingValue = v);
		public SplitProcessorDescriptor<T> PreserveTrailing(bool? preserveTrailing = true) => Assign(preserveTrailing, (a, v) => a.PreserveTrailingValue = v);
		public SplitProcessorDescriptor<T> Separator(string separator) => Assign(separator, (a, v) => a.SeparatorValue = v);
		public SplitProcessorDescriptor<T> TargetField(string? targetField) => Assign(targetField, (a, v) => a.TargetFieldValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, FieldValue, options);
			if (IgnoreMissingValue.HasValue)
			{
				writer.WritePropertyName("ignore_missing");
				writer.WriteBooleanValue(IgnoreMissingValue.Value);
			}

			if (PreserveTrailingValue.HasValue)
			{
				writer.WritePropertyName("preserve_trailing");
				writer.WriteBooleanValue(PreserveTrailingValue.Value);
			}

			writer.WritePropertyName("separator");
			writer.WriteStringValue(SeparatorValue);
			if (TargetFieldValue is not null)
			{
				writer.WritePropertyName("target_field");
				JsonSerializer.Serialize(writer, TargetFieldValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class TrimProcessor : Ingest.ProcessorBase, IProcessorContainerVariant
	{
		[JsonIgnore]
		string Ingest.IProcessorContainerVariant.ProcessorContainerVariantName => "trim";
		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("ignore_missing")]
		public bool? IgnoreMissing { get; set; }

		[JsonInclude]
		[JsonPropertyName("target_field")]
		public string? TargetField { get; set; }
	}

	public sealed partial class TrimProcessorDescriptor<T> : DescriptorBase<TrimProcessorDescriptor<T>>
	{
		public TrimProcessorDescriptor()
		{
		}

		internal TrimProcessorDescriptor(Action<TrimProcessorDescriptor<T>> configure) => configure.Invoke(this);
		internal string FieldValue { get; private set; }

		internal bool? IgnoreMissingValue { get; private set; }

		internal string? TargetFieldValue { get; private set; }

		public TrimProcessorDescriptor<T> Field(string field) => Assign(field, (a, v) => a.FieldValue = v);
		public TrimProcessorDescriptor<T> IgnoreMissing(bool? ignoreMissing = true) => Assign(ignoreMissing, (a, v) => a.IgnoreMissingValue = v);
		public TrimProcessorDescriptor<T> TargetField(string? targetField) => Assign(targetField, (a, v) => a.TargetFieldValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, FieldValue, options);
			if (IgnoreMissingValue.HasValue)
			{
				writer.WritePropertyName("ignore_missing");
				writer.WriteBooleanValue(IgnoreMissingValue.Value);
			}

			if (TargetFieldValue is not null)
			{
				writer.WritePropertyName("target_field");
				JsonSerializer.Serialize(writer, TargetFieldValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class UppercaseProcessor : Ingest.ProcessorBase, IProcessorContainerVariant
	{
		[JsonIgnore]
		string Ingest.IProcessorContainerVariant.ProcessorContainerVariantName => "uppercase";
		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("ignore_missing")]
		public bool? IgnoreMissing { get; set; }

		[JsonInclude]
		[JsonPropertyName("target_field")]
		public string? TargetField { get; set; }
	}

	public sealed partial class UppercaseProcessorDescriptor<T> : DescriptorBase<UppercaseProcessorDescriptor<T>>
	{
		public UppercaseProcessorDescriptor()
		{
		}

		internal UppercaseProcessorDescriptor(Action<UppercaseProcessorDescriptor<T>> configure) => configure.Invoke(this);
		internal string FieldValue { get; private set; }

		internal bool? IgnoreMissingValue { get; private set; }

		internal string? TargetFieldValue { get; private set; }

		public UppercaseProcessorDescriptor<T> Field(string field) => Assign(field, (a, v) => a.FieldValue = v);
		public UppercaseProcessorDescriptor<T> IgnoreMissing(bool? ignoreMissing = true) => Assign(ignoreMissing, (a, v) => a.IgnoreMissingValue = v);
		public UppercaseProcessorDescriptor<T> TargetField(string? targetField) => Assign(targetField, (a, v) => a.TargetFieldValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, FieldValue, options);
			if (IgnoreMissingValue.HasValue)
			{
				writer.WritePropertyName("ignore_missing");
				writer.WriteBooleanValue(IgnoreMissingValue.Value);
			}

			if (TargetFieldValue is not null)
			{
				writer.WritePropertyName("target_field");
				JsonSerializer.Serialize(writer, TargetFieldValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class UrlDecodeProcessor : Ingest.ProcessorBase, IProcessorContainerVariant
	{
		[JsonIgnore]
		string Ingest.IProcessorContainerVariant.ProcessorContainerVariantName => "urldecode";
		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("ignore_missing")]
		public bool? IgnoreMissing { get; set; }

		[JsonInclude]
		[JsonPropertyName("target_field")]
		public string? TargetField { get; set; }
	}

	public sealed partial class UrlDecodeProcessorDescriptor<T> : DescriptorBase<UrlDecodeProcessorDescriptor<T>>
	{
		public UrlDecodeProcessorDescriptor()
		{
		}

		internal UrlDecodeProcessorDescriptor(Action<UrlDecodeProcessorDescriptor<T>> configure) => configure.Invoke(this);
		internal string FieldValue { get; private set; }

		internal bool? IgnoreMissingValue { get; private set; }

		internal string? TargetFieldValue { get; private set; }

		public UrlDecodeProcessorDescriptor<T> Field(string field) => Assign(field, (a, v) => a.FieldValue = v);
		public UrlDecodeProcessorDescriptor<T> IgnoreMissing(bool? ignoreMissing = true) => Assign(ignoreMissing, (a, v) => a.IgnoreMissingValue = v);
		public UrlDecodeProcessorDescriptor<T> TargetField(string? targetField) => Assign(targetField, (a, v) => a.TargetFieldValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, FieldValue, options);
			if (IgnoreMissingValue.HasValue)
			{
				writer.WritePropertyName("ignore_missing");
				writer.WriteBooleanValue(IgnoreMissingValue.Value);
			}

			if (TargetFieldValue is not null)
			{
				writer.WritePropertyName("target_field");
				JsonSerializer.Serialize(writer, TargetFieldValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class UserAgentProcessor : Ingest.ProcessorBase, IProcessorContainerVariant
	{
		[JsonIgnore]
		string Ingest.IProcessorContainerVariant.ProcessorContainerVariantName => "user_agent";
		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("ignore_missing")]
		public bool IgnoreMissing { get; set; }

		[JsonInclude]
		[JsonPropertyName("options")]
		public IEnumerable<Elastic.Clients.Elasticsearch.Ingest.UserAgentProperty> Options { get; set; }

		[JsonInclude]
		[JsonPropertyName("regex_file")]
		public string RegexFile { get; set; }

		[JsonInclude]
		[JsonPropertyName("target_field")]
		public string TargetField { get; set; }
	}

	public sealed partial class UserAgentProcessorDescriptor<T> : DescriptorBase<UserAgentProcessorDescriptor<T>>
	{
		public UserAgentProcessorDescriptor()
		{
		}

		internal UserAgentProcessorDescriptor(Action<UserAgentProcessorDescriptor<T>> configure) => configure.Invoke(this);
		internal string FieldValue { get; private set; }

		internal bool IgnoreMissingValue { get; private set; }

		internal IEnumerable<Elastic.Clients.Elasticsearch.Ingest.UserAgentProperty> OptionsValue { get; private set; }

		internal string RegexFileValue { get; private set; }

		internal string TargetFieldValue { get; private set; }

		public UserAgentProcessorDescriptor<T> Field(string field) => Assign(field, (a, v) => a.FieldValue = v);
		public UserAgentProcessorDescriptor<T> IgnoreMissing(bool ignoreMissing = true) => Assign(ignoreMissing, (a, v) => a.IgnoreMissingValue = v);
		public UserAgentProcessorDescriptor<T> Options(IEnumerable<Elastic.Clients.Elasticsearch.Ingest.UserAgentProperty> options) => Assign(options, (a, v) => a.OptionsValue = v);
		public UserAgentProcessorDescriptor<T> RegexFile(string regexFile) => Assign(regexFile, (a, v) => a.RegexFileValue = v);
		public UserAgentProcessorDescriptor<T> TargetField(string targetField) => Assign(targetField, (a, v) => a.TargetFieldValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, FieldValue, options);
			writer.WritePropertyName("ignore_missing");
			writer.WriteBooleanValue(IgnoreMissingValue);
			writer.WritePropertyName("options");
			JsonSerializer.Serialize(writer, OptionsValue, options);
			writer.WritePropertyName("regex_file");
			writer.WriteStringValue(RegexFileValue);
			writer.WritePropertyName("target_field");
			JsonSerializer.Serialize(writer, TargetFieldValue, options);
			writer.WriteEndObject();
		}
	}
}