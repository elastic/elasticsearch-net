// Licensed to Elasticsearch B.V under one or more agreements.
// Elasticsearch B.V licenses this file to you under the Apache 2.0 License.
// See the LICENSE file in the project root for more information.
//
// ███╗   ██╗ ██████╗ ████████╗██╗ ██████╗███████╗
// ████╗  ██║██╔═══██╗╚══██╔══╝██║██╔════╝██╔════╝
// ██╔██╗ ██║██║   ██║   ██║   ██║██║     █████╗
// ██║╚██╗██║██║   ██║   ██║   ██║██║     ██╔══╝
// ██║ ╚████║╚██████╔╝   ██║   ██║╚██████╗███████╗
// ╚═╝  ╚═══╝ ╚═════╝    ╚═╝   ╚═╝ ╚═════╝╚══════╝
// ------------------------------------------------
//
// This file is automatically generated.
// Please do not edit these files manually.
//
// ------------------------------------------------

#nullable restore

using Elastic.Clients.Elasticsearch.Fluent;
using Elastic.Clients.Elasticsearch.Serialization;
using System;
using System.Collections.Generic;
using System.Linq.Expressions;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace Elastic.Clients.Elasticsearch.Ingest;

[JsonConverter(typeof(ProcessorConverter))]
public sealed partial class Processor
{
	internal Processor(string variantName, object variant)
	{
		if (variantName is null)
			throw new ArgumentNullException(nameof(variantName));
		if (variant is null)
			throw new ArgumentNullException(nameof(variant));
		if (string.IsNullOrWhiteSpace(variantName))
			throw new ArgumentException("Variant name must not be empty or whitespace.");
		VariantName = variantName;
		Variant = variant;
	}

	internal object Variant { get; }
	internal string VariantName { get; }

	public static Processor Append(Elastic.Clients.Elasticsearch.Ingest.AppendProcessor appendProcessor) => new Processor("append", appendProcessor);
	public static Processor Attachment(Elastic.Clients.Elasticsearch.Ingest.AttachmentProcessor attachmentProcessor) => new Processor("attachment", attachmentProcessor);
	public static Processor Bytes(Elastic.Clients.Elasticsearch.Ingest.BytesProcessor bytesProcessor) => new Processor("bytes", bytesProcessor);
	public static Processor Circle(Elastic.Clients.Elasticsearch.Ingest.CircleProcessor circleProcessor) => new Processor("circle", circleProcessor);
	public static Processor Convert(Elastic.Clients.Elasticsearch.Ingest.ConvertProcessor convertProcessor) => new Processor("convert", convertProcessor);
	public static Processor Csv(Elastic.Clients.Elasticsearch.Ingest.CsvProcessor csvProcessor) => new Processor("csv", csvProcessor);
	public static Processor Date(Elastic.Clients.Elasticsearch.Ingest.DateProcessor dateProcessor) => new Processor("date", dateProcessor);
	public static Processor DateIndexName(Elastic.Clients.Elasticsearch.Ingest.DateIndexNameProcessor dateIndexNameProcessor) => new Processor("date_index_name", dateIndexNameProcessor);
	public static Processor Dissect(Elastic.Clients.Elasticsearch.Ingest.DissectProcessor dissectProcessor) => new Processor("dissect", dissectProcessor);
	public static Processor DotExpander(Elastic.Clients.Elasticsearch.Ingest.DotExpanderProcessor dotExpanderProcessor) => new Processor("dot_expander", dotExpanderProcessor);
	public static Processor Drop(Elastic.Clients.Elasticsearch.Ingest.DropProcessor dropProcessor) => new Processor("drop", dropProcessor);
	public static Processor Enrich(Elastic.Clients.Elasticsearch.Ingest.EnrichProcessor enrichProcessor) => new Processor("enrich", enrichProcessor);
	public static Processor Fail(Elastic.Clients.Elasticsearch.Ingest.FailProcessor failProcessor) => new Processor("fail", failProcessor);
	public static Processor Foreach(Elastic.Clients.Elasticsearch.Ingest.ForeachProcessor foreachProcessor) => new Processor("foreach", foreachProcessor);
	public static Processor Geoip(Elastic.Clients.Elasticsearch.Ingest.GeoIpProcessor geoIpProcessor) => new Processor("geoip", geoIpProcessor);
	public static Processor Grok(Elastic.Clients.Elasticsearch.Ingest.GrokProcessor grokProcessor) => new Processor("grok", grokProcessor);
	public static Processor Gsub(Elastic.Clients.Elasticsearch.Ingest.GsubProcessor gsubProcessor) => new Processor("gsub", gsubProcessor);
	public static Processor Inference(Elastic.Clients.Elasticsearch.Ingest.InferenceProcessor inferenceProcessor) => new Processor("inference", inferenceProcessor);
	public static Processor Join(Elastic.Clients.Elasticsearch.Ingest.JoinProcessor joinProcessor) => new Processor("join", joinProcessor);
	public static Processor Json(Elastic.Clients.Elasticsearch.Ingest.JsonProcessor jsonProcessor) => new Processor("json", jsonProcessor);
	public static Processor Kv(Elastic.Clients.Elasticsearch.Ingest.KeyValueProcessor keyValueProcessor) => new Processor("kv", keyValueProcessor);
	public static Processor Lowercase(Elastic.Clients.Elasticsearch.Ingest.LowercaseProcessor lowercaseProcessor) => new Processor("lowercase", lowercaseProcessor);
	public static Processor Pipeline(Elastic.Clients.Elasticsearch.Ingest.PipelineProcessor pipelineProcessor) => new Processor("pipeline", pipelineProcessor);
	public static Processor Remove(Elastic.Clients.Elasticsearch.Ingest.RemoveProcessor removeProcessor) => new Processor("remove", removeProcessor);
	public static Processor Rename(Elastic.Clients.Elasticsearch.Ingest.RenameProcessor renameProcessor) => new Processor("rename", renameProcessor);
	public static Processor Set(Elastic.Clients.Elasticsearch.Ingest.SetProcessor setProcessor) => new Processor("set", setProcessor);
	public static Processor SetSecurityUser(Elastic.Clients.Elasticsearch.Ingest.SetSecurityUserProcessor setSecurityUserProcessor) => new Processor("set_security_user", setSecurityUserProcessor);
	public static Processor Sort(Elastic.Clients.Elasticsearch.Ingest.SortProcessor sortProcessor) => new Processor("sort", sortProcessor);
	public static Processor Split(Elastic.Clients.Elasticsearch.Ingest.SplitProcessor splitProcessor) => new Processor("split", splitProcessor);
	public static Processor Trim(Elastic.Clients.Elasticsearch.Ingest.TrimProcessor trimProcessor) => new Processor("trim", trimProcessor);
	public static Processor Uppercase(Elastic.Clients.Elasticsearch.Ingest.UppercaseProcessor uppercaseProcessor) => new Processor("uppercase", uppercaseProcessor);
	public static Processor Urldecode(Elastic.Clients.Elasticsearch.Ingest.UrlDecodeProcessor urlDecodeProcessor) => new Processor("urldecode", urlDecodeProcessor);
	public static Processor UserAgent(Elastic.Clients.Elasticsearch.Ingest.UserAgentProcessor userAgentProcessor) => new Processor("user_agent", userAgentProcessor);
}

internal sealed partial class ProcessorConverter : JsonConverter<Processor>
{
	public override Processor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
	{
		if (reader.TokenType != JsonTokenType.StartObject)
		{
			throw new JsonException("Expected start token.");
		}

		reader.Read();
		if (reader.TokenType != JsonTokenType.PropertyName)
		{
			throw new JsonException("Expected a property name token representing the variant held within this container.");
		}

		var propertyName = reader.GetString();
		reader.Read();
		if (propertyName == "append")
		{
			var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.AppendProcessor?>(ref reader, options);
			reader.Read();
			return new Processor(propertyName, variant);
		}

		if (propertyName == "attachment")
		{
			var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.AttachmentProcessor?>(ref reader, options);
			reader.Read();
			return new Processor(propertyName, variant);
		}

		if (propertyName == "bytes")
		{
			var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.BytesProcessor?>(ref reader, options);
			reader.Read();
			return new Processor(propertyName, variant);
		}

		if (propertyName == "circle")
		{
			var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.CircleProcessor?>(ref reader, options);
			reader.Read();
			return new Processor(propertyName, variant);
		}

		if (propertyName == "convert")
		{
			var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.ConvertProcessor?>(ref reader, options);
			reader.Read();
			return new Processor(propertyName, variant);
		}

		if (propertyName == "csv")
		{
			var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.CsvProcessor?>(ref reader, options);
			reader.Read();
			return new Processor(propertyName, variant);
		}

		if (propertyName == "date")
		{
			var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.DateProcessor?>(ref reader, options);
			reader.Read();
			return new Processor(propertyName, variant);
		}

		if (propertyName == "date_index_name")
		{
			var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.DateIndexNameProcessor?>(ref reader, options);
			reader.Read();
			return new Processor(propertyName, variant);
		}

		if (propertyName == "dissect")
		{
			var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.DissectProcessor?>(ref reader, options);
			reader.Read();
			return new Processor(propertyName, variant);
		}

		if (propertyName == "dot_expander")
		{
			var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.DotExpanderProcessor?>(ref reader, options);
			reader.Read();
			return new Processor(propertyName, variant);
		}

		if (propertyName == "drop")
		{
			var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.DropProcessor?>(ref reader, options);
			reader.Read();
			return new Processor(propertyName, variant);
		}

		if (propertyName == "enrich")
		{
			var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.EnrichProcessor?>(ref reader, options);
			reader.Read();
			return new Processor(propertyName, variant);
		}

		if (propertyName == "fail")
		{
			var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.FailProcessor?>(ref reader, options);
			reader.Read();
			return new Processor(propertyName, variant);
		}

		if (propertyName == "foreach")
		{
			var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.ForeachProcessor?>(ref reader, options);
			reader.Read();
			return new Processor(propertyName, variant);
		}

		if (propertyName == "geoip")
		{
			var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.GeoIpProcessor?>(ref reader, options);
			reader.Read();
			return new Processor(propertyName, variant);
		}

		if (propertyName == "grok")
		{
			var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.GrokProcessor?>(ref reader, options);
			reader.Read();
			return new Processor(propertyName, variant);
		}

		if (propertyName == "gsub")
		{
			var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.GsubProcessor?>(ref reader, options);
			reader.Read();
			return new Processor(propertyName, variant);
		}

		if (propertyName == "inference")
		{
			var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.InferenceProcessor?>(ref reader, options);
			reader.Read();
			return new Processor(propertyName, variant);
		}

		if (propertyName == "join")
		{
			var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.JoinProcessor?>(ref reader, options);
			reader.Read();
			return new Processor(propertyName, variant);
		}

		if (propertyName == "json")
		{
			var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.JsonProcessor?>(ref reader, options);
			reader.Read();
			return new Processor(propertyName, variant);
		}

		if (propertyName == "kv")
		{
			var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.KeyValueProcessor?>(ref reader, options);
			reader.Read();
			return new Processor(propertyName, variant);
		}

		if (propertyName == "lowercase")
		{
			var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.LowercaseProcessor?>(ref reader, options);
			reader.Read();
			return new Processor(propertyName, variant);
		}

		if (propertyName == "pipeline")
		{
			var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.PipelineProcessor?>(ref reader, options);
			reader.Read();
			return new Processor(propertyName, variant);
		}

		if (propertyName == "remove")
		{
			var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.RemoveProcessor?>(ref reader, options);
			reader.Read();
			return new Processor(propertyName, variant);
		}

		if (propertyName == "rename")
		{
			var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.RenameProcessor?>(ref reader, options);
			reader.Read();
			return new Processor(propertyName, variant);
		}

		if (propertyName == "set")
		{
			var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.SetProcessor?>(ref reader, options);
			reader.Read();
			return new Processor(propertyName, variant);
		}

		if (propertyName == "set_security_user")
		{
			var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.SetSecurityUserProcessor?>(ref reader, options);
			reader.Read();
			return new Processor(propertyName, variant);
		}

		if (propertyName == "sort")
		{
			var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.SortProcessor?>(ref reader, options);
			reader.Read();
			return new Processor(propertyName, variant);
		}

		if (propertyName == "split")
		{
			var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.SplitProcessor?>(ref reader, options);
			reader.Read();
			return new Processor(propertyName, variant);
		}

		if (propertyName == "trim")
		{
			var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.TrimProcessor?>(ref reader, options);
			reader.Read();
			return new Processor(propertyName, variant);
		}

		if (propertyName == "uppercase")
		{
			var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.UppercaseProcessor?>(ref reader, options);
			reader.Read();
			return new Processor(propertyName, variant);
		}

		if (propertyName == "urldecode")
		{
			var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.UrlDecodeProcessor?>(ref reader, options);
			reader.Read();
			return new Processor(propertyName, variant);
		}

		if (propertyName == "user_agent")
		{
			var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Ingest.UserAgentProcessor?>(ref reader, options);
			reader.Read();
			return new Processor(propertyName, variant);
		}

		throw new JsonException();
	}

	public override void Write(Utf8JsonWriter writer, Processor value, JsonSerializerOptions options)
	{
		writer.WriteStartObject();
		writer.WritePropertyName(value.VariantName);
		switch (value.VariantName)
		{
			case "append":
				JsonSerializer.Serialize<Elastic.Clients.Elasticsearch.Ingest.AppendProcessor>(writer, (Elastic.Clients.Elasticsearch.Ingest.AppendProcessor)value.Variant, options);
				break;
			case "attachment":
				JsonSerializer.Serialize<Elastic.Clients.Elasticsearch.Ingest.AttachmentProcessor>(writer, (Elastic.Clients.Elasticsearch.Ingest.AttachmentProcessor)value.Variant, options);
				break;
			case "bytes":
				JsonSerializer.Serialize<Elastic.Clients.Elasticsearch.Ingest.BytesProcessor>(writer, (Elastic.Clients.Elasticsearch.Ingest.BytesProcessor)value.Variant, options);
				break;
			case "circle":
				JsonSerializer.Serialize<Elastic.Clients.Elasticsearch.Ingest.CircleProcessor>(writer, (Elastic.Clients.Elasticsearch.Ingest.CircleProcessor)value.Variant, options);
				break;
			case "convert":
				JsonSerializer.Serialize<Elastic.Clients.Elasticsearch.Ingest.ConvertProcessor>(writer, (Elastic.Clients.Elasticsearch.Ingest.ConvertProcessor)value.Variant, options);
				break;
			case "csv":
				JsonSerializer.Serialize<Elastic.Clients.Elasticsearch.Ingest.CsvProcessor>(writer, (Elastic.Clients.Elasticsearch.Ingest.CsvProcessor)value.Variant, options);
				break;
			case "date":
				JsonSerializer.Serialize<Elastic.Clients.Elasticsearch.Ingest.DateProcessor>(writer, (Elastic.Clients.Elasticsearch.Ingest.DateProcessor)value.Variant, options);
				break;
			case "date_index_name":
				JsonSerializer.Serialize<Elastic.Clients.Elasticsearch.Ingest.DateIndexNameProcessor>(writer, (Elastic.Clients.Elasticsearch.Ingest.DateIndexNameProcessor)value.Variant, options);
				break;
			case "dissect":
				JsonSerializer.Serialize<Elastic.Clients.Elasticsearch.Ingest.DissectProcessor>(writer, (Elastic.Clients.Elasticsearch.Ingest.DissectProcessor)value.Variant, options);
				break;
			case "dot_expander":
				JsonSerializer.Serialize<Elastic.Clients.Elasticsearch.Ingest.DotExpanderProcessor>(writer, (Elastic.Clients.Elasticsearch.Ingest.DotExpanderProcessor)value.Variant, options);
				break;
			case "drop":
				JsonSerializer.Serialize<Elastic.Clients.Elasticsearch.Ingest.DropProcessor>(writer, (Elastic.Clients.Elasticsearch.Ingest.DropProcessor)value.Variant, options);
				break;
			case "enrich":
				JsonSerializer.Serialize<Elastic.Clients.Elasticsearch.Ingest.EnrichProcessor>(writer, (Elastic.Clients.Elasticsearch.Ingest.EnrichProcessor)value.Variant, options);
				break;
			case "fail":
				JsonSerializer.Serialize<Elastic.Clients.Elasticsearch.Ingest.FailProcessor>(writer, (Elastic.Clients.Elasticsearch.Ingest.FailProcessor)value.Variant, options);
				break;
			case "foreach":
				JsonSerializer.Serialize<Elastic.Clients.Elasticsearch.Ingest.ForeachProcessor>(writer, (Elastic.Clients.Elasticsearch.Ingest.ForeachProcessor)value.Variant, options);
				break;
			case "geoip":
				JsonSerializer.Serialize<Elastic.Clients.Elasticsearch.Ingest.GeoIpProcessor>(writer, (Elastic.Clients.Elasticsearch.Ingest.GeoIpProcessor)value.Variant, options);
				break;
			case "grok":
				JsonSerializer.Serialize<Elastic.Clients.Elasticsearch.Ingest.GrokProcessor>(writer, (Elastic.Clients.Elasticsearch.Ingest.GrokProcessor)value.Variant, options);
				break;
			case "gsub":
				JsonSerializer.Serialize<Elastic.Clients.Elasticsearch.Ingest.GsubProcessor>(writer, (Elastic.Clients.Elasticsearch.Ingest.GsubProcessor)value.Variant, options);
				break;
			case "inference":
				JsonSerializer.Serialize<Elastic.Clients.Elasticsearch.Ingest.InferenceProcessor>(writer, (Elastic.Clients.Elasticsearch.Ingest.InferenceProcessor)value.Variant, options);
				break;
			case "join":
				JsonSerializer.Serialize<Elastic.Clients.Elasticsearch.Ingest.JoinProcessor>(writer, (Elastic.Clients.Elasticsearch.Ingest.JoinProcessor)value.Variant, options);
				break;
			case "json":
				JsonSerializer.Serialize<Elastic.Clients.Elasticsearch.Ingest.JsonProcessor>(writer, (Elastic.Clients.Elasticsearch.Ingest.JsonProcessor)value.Variant, options);
				break;
			case "kv":
				JsonSerializer.Serialize<Elastic.Clients.Elasticsearch.Ingest.KeyValueProcessor>(writer, (Elastic.Clients.Elasticsearch.Ingest.KeyValueProcessor)value.Variant, options);
				break;
			case "lowercase":
				JsonSerializer.Serialize<Elastic.Clients.Elasticsearch.Ingest.LowercaseProcessor>(writer, (Elastic.Clients.Elasticsearch.Ingest.LowercaseProcessor)value.Variant, options);
				break;
			case "pipeline":
				JsonSerializer.Serialize<Elastic.Clients.Elasticsearch.Ingest.PipelineProcessor>(writer, (Elastic.Clients.Elasticsearch.Ingest.PipelineProcessor)value.Variant, options);
				break;
			case "remove":
				JsonSerializer.Serialize<Elastic.Clients.Elasticsearch.Ingest.RemoveProcessor>(writer, (Elastic.Clients.Elasticsearch.Ingest.RemoveProcessor)value.Variant, options);
				break;
			case "rename":
				JsonSerializer.Serialize<Elastic.Clients.Elasticsearch.Ingest.RenameProcessor>(writer, (Elastic.Clients.Elasticsearch.Ingest.RenameProcessor)value.Variant, options);
				break;
			case "set":
				JsonSerializer.Serialize<Elastic.Clients.Elasticsearch.Ingest.SetProcessor>(writer, (Elastic.Clients.Elasticsearch.Ingest.SetProcessor)value.Variant, options);
				break;
			case "set_security_user":
				JsonSerializer.Serialize<Elastic.Clients.Elasticsearch.Ingest.SetSecurityUserProcessor>(writer, (Elastic.Clients.Elasticsearch.Ingest.SetSecurityUserProcessor)value.Variant, options);
				break;
			case "sort":
				JsonSerializer.Serialize<Elastic.Clients.Elasticsearch.Ingest.SortProcessor>(writer, (Elastic.Clients.Elasticsearch.Ingest.SortProcessor)value.Variant, options);
				break;
			case "split":
				JsonSerializer.Serialize<Elastic.Clients.Elasticsearch.Ingest.SplitProcessor>(writer, (Elastic.Clients.Elasticsearch.Ingest.SplitProcessor)value.Variant, options);
				break;
			case "trim":
				JsonSerializer.Serialize<Elastic.Clients.Elasticsearch.Ingest.TrimProcessor>(writer, (Elastic.Clients.Elasticsearch.Ingest.TrimProcessor)value.Variant, options);
				break;
			case "uppercase":
				JsonSerializer.Serialize<Elastic.Clients.Elasticsearch.Ingest.UppercaseProcessor>(writer, (Elastic.Clients.Elasticsearch.Ingest.UppercaseProcessor)value.Variant, options);
				break;
			case "urldecode":
				JsonSerializer.Serialize<Elastic.Clients.Elasticsearch.Ingest.UrlDecodeProcessor>(writer, (Elastic.Clients.Elasticsearch.Ingest.UrlDecodeProcessor)value.Variant, options);
				break;
			case "user_agent":
				JsonSerializer.Serialize<Elastic.Clients.Elasticsearch.Ingest.UserAgentProcessor>(writer, (Elastic.Clients.Elasticsearch.Ingest.UserAgentProcessor)value.Variant, options);
				break;
		}

		writer.WriteEndObject();
	}
}

public sealed partial class ProcessorDescriptor<TDocument> : SerializableDescriptor<ProcessorDescriptor<TDocument>>
{
	internal ProcessorDescriptor(Action<ProcessorDescriptor<TDocument>> configure) => configure.Invoke(this);

	public ProcessorDescriptor() : base()
	{
	}

	private bool ContainsVariant { get; set; }
	private string ContainedVariantName { get; set; }
	private object Variant { get; set; }
	private Descriptor Descriptor { get; set; }

	private ProcessorDescriptor<TDocument> Set<T>(Action<T> descriptorAction, string variantName) where T : Descriptor
	{
		ContainedVariantName = variantName;
		ContainsVariant = true;
		var descriptor = (T)Activator.CreateInstance(typeof(T), true);
		descriptorAction?.Invoke(descriptor);
		Descriptor = descriptor;
		return Self;
	}

	private ProcessorDescriptor<TDocument> Set(object variant, string variantName)
	{
		Variant = variant;
		ContainedVariantName = variantName;
		ContainsVariant = true;
		return Self;
	}

	public ProcessorDescriptor<TDocument> Append(AppendProcessor appendProcessor) => Set(appendProcessor, "append");
	public ProcessorDescriptor<TDocument> Append(Action<AppendProcessorDescriptor<TDocument>> configure) => Set(configure, "append");
	public ProcessorDescriptor<TDocument> Attachment(AttachmentProcessor attachmentProcessor) => Set(attachmentProcessor, "attachment");
	public ProcessorDescriptor<TDocument> Attachment(Action<AttachmentProcessorDescriptor<TDocument>> configure) => Set(configure, "attachment");
	public ProcessorDescriptor<TDocument> Bytes(BytesProcessor bytesProcessor) => Set(bytesProcessor, "bytes");
	public ProcessorDescriptor<TDocument> Bytes(Action<BytesProcessorDescriptor<TDocument>> configure) => Set(configure, "bytes");
	public ProcessorDescriptor<TDocument> Circle(CircleProcessor circleProcessor) => Set(circleProcessor, "circle");
	public ProcessorDescriptor<TDocument> Circle(Action<CircleProcessorDescriptor<TDocument>> configure) => Set(configure, "circle");
	public ProcessorDescriptor<TDocument> Convert(ConvertProcessor convertProcessor) => Set(convertProcessor, "convert");
	public ProcessorDescriptor<TDocument> Convert(Action<ConvertProcessorDescriptor<TDocument>> configure) => Set(configure, "convert");
	public ProcessorDescriptor<TDocument> Csv(CsvProcessor csvProcessor) => Set(csvProcessor, "csv");
	public ProcessorDescriptor<TDocument> Csv(Action<CsvProcessorDescriptor<TDocument>> configure) => Set(configure, "csv");
	public ProcessorDescriptor<TDocument> Date(DateProcessor dateProcessor) => Set(dateProcessor, "date");
	public ProcessorDescriptor<TDocument> Date(Action<DateProcessorDescriptor<TDocument>> configure) => Set(configure, "date");
	public ProcessorDescriptor<TDocument> DateIndexName(DateIndexNameProcessor dateIndexNameProcessor) => Set(dateIndexNameProcessor, "date_index_name");
	public ProcessorDescriptor<TDocument> DateIndexName(Action<DateIndexNameProcessorDescriptor<TDocument>> configure) => Set(configure, "date_index_name");
	public ProcessorDescriptor<TDocument> Dissect(DissectProcessor dissectProcessor) => Set(dissectProcessor, "dissect");
	public ProcessorDescriptor<TDocument> Dissect(Action<DissectProcessorDescriptor<TDocument>> configure) => Set(configure, "dissect");
	public ProcessorDescriptor<TDocument> DotExpander(DotExpanderProcessor dotExpanderProcessor) => Set(dotExpanderProcessor, "dot_expander");
	public ProcessorDescriptor<TDocument> DotExpander(Action<DotExpanderProcessorDescriptor<TDocument>> configure) => Set(configure, "dot_expander");
	public ProcessorDescriptor<TDocument> Drop(DropProcessor dropProcessor) => Set(dropProcessor, "drop");
	public ProcessorDescriptor<TDocument> Drop(Action<DropProcessorDescriptor<TDocument>> configure) => Set(configure, "drop");
	public ProcessorDescriptor<TDocument> Enrich(EnrichProcessor enrichProcessor) => Set(enrichProcessor, "enrich");
	public ProcessorDescriptor<TDocument> Enrich(Action<EnrichProcessorDescriptor<TDocument>> configure) => Set(configure, "enrich");
	public ProcessorDescriptor<TDocument> Fail(FailProcessor failProcessor) => Set(failProcessor, "fail");
	public ProcessorDescriptor<TDocument> Fail(Action<FailProcessorDescriptor<TDocument>> configure) => Set(configure, "fail");
	public ProcessorDescriptor<TDocument> Foreach(ForeachProcessor foreachProcessor) => Set(foreachProcessor, "foreach");
	public ProcessorDescriptor<TDocument> Foreach(Action<ForeachProcessorDescriptor<TDocument>> configure) => Set(configure, "foreach");
	public ProcessorDescriptor<TDocument> Geoip(GeoIpProcessor geoIpProcessor) => Set(geoIpProcessor, "geoip");
	public ProcessorDescriptor<TDocument> Geoip(Action<GeoIpProcessorDescriptor<TDocument>> configure) => Set(configure, "geoip");
	public ProcessorDescriptor<TDocument> Grok(GrokProcessor grokProcessor) => Set(grokProcessor, "grok");
	public ProcessorDescriptor<TDocument> Grok(Action<GrokProcessorDescriptor<TDocument>> configure) => Set(configure, "grok");
	public ProcessorDescriptor<TDocument> Gsub(GsubProcessor gsubProcessor) => Set(gsubProcessor, "gsub");
	public ProcessorDescriptor<TDocument> Gsub(Action<GsubProcessorDescriptor<TDocument>> configure) => Set(configure, "gsub");
	public ProcessorDescriptor<TDocument> Inference(InferenceProcessor inferenceProcessor) => Set(inferenceProcessor, "inference");
	public ProcessorDescriptor<TDocument> Inference(Action<InferenceProcessorDescriptor<TDocument>> configure) => Set(configure, "inference");
	public ProcessorDescriptor<TDocument> Join(JoinProcessor joinProcessor) => Set(joinProcessor, "join");
	public ProcessorDescriptor<TDocument> Join(Action<JoinProcessorDescriptor<TDocument>> configure) => Set(configure, "join");
	public ProcessorDescriptor<TDocument> Json(JsonProcessor jsonProcessor) => Set(jsonProcessor, "json");
	public ProcessorDescriptor<TDocument> Json(Action<JsonProcessorDescriptor<TDocument>> configure) => Set(configure, "json");
	public ProcessorDescriptor<TDocument> Kv(KeyValueProcessor keyValueProcessor) => Set(keyValueProcessor, "kv");
	public ProcessorDescriptor<TDocument> Kv(Action<KeyValueProcessorDescriptor<TDocument>> configure) => Set(configure, "kv");
	public ProcessorDescriptor<TDocument> Lowercase(LowercaseProcessor lowercaseProcessor) => Set(lowercaseProcessor, "lowercase");
	public ProcessorDescriptor<TDocument> Lowercase(Action<LowercaseProcessorDescriptor<TDocument>> configure) => Set(configure, "lowercase");
	public ProcessorDescriptor<TDocument> Pipeline(PipelineProcessor pipelineProcessor) => Set(pipelineProcessor, "pipeline");
	public ProcessorDescriptor<TDocument> Pipeline(Action<PipelineProcessorDescriptor<TDocument>> configure) => Set(configure, "pipeline");
	public ProcessorDescriptor<TDocument> Remove(RemoveProcessor removeProcessor) => Set(removeProcessor, "remove");
	public ProcessorDescriptor<TDocument> Remove(Action<RemoveProcessorDescriptor<TDocument>> configure) => Set(configure, "remove");
	public ProcessorDescriptor<TDocument> Rename(RenameProcessor renameProcessor) => Set(renameProcessor, "rename");
	public ProcessorDescriptor<TDocument> Rename(Action<RenameProcessorDescriptor<TDocument>> configure) => Set(configure, "rename");
	public ProcessorDescriptor<TDocument> Set(SetProcessor setProcessor) => Set(setProcessor, "set");
	public ProcessorDescriptor<TDocument> Set(Action<SetProcessorDescriptor<TDocument>> configure) => Set(configure, "set");
	public ProcessorDescriptor<TDocument> SetSecurityUser(SetSecurityUserProcessor setSecurityUserProcessor) => Set(setSecurityUserProcessor, "set_security_user");
	public ProcessorDescriptor<TDocument> SetSecurityUser(Action<SetSecurityUserProcessorDescriptor<TDocument>> configure) => Set(configure, "set_security_user");
	public ProcessorDescriptor<TDocument> Sort(SortProcessor sortProcessor) => Set(sortProcessor, "sort");
	public ProcessorDescriptor<TDocument> Sort(Action<SortProcessorDescriptor<TDocument>> configure) => Set(configure, "sort");
	public ProcessorDescriptor<TDocument> Split(SplitProcessor splitProcessor) => Set(splitProcessor, "split");
	public ProcessorDescriptor<TDocument> Split(Action<SplitProcessorDescriptor<TDocument>> configure) => Set(configure, "split");
	public ProcessorDescriptor<TDocument> Trim(TrimProcessor trimProcessor) => Set(trimProcessor, "trim");
	public ProcessorDescriptor<TDocument> Trim(Action<TrimProcessorDescriptor<TDocument>> configure) => Set(configure, "trim");
	public ProcessorDescriptor<TDocument> Uppercase(UppercaseProcessor uppercaseProcessor) => Set(uppercaseProcessor, "uppercase");
	public ProcessorDescriptor<TDocument> Uppercase(Action<UppercaseProcessorDescriptor<TDocument>> configure) => Set(configure, "uppercase");
	public ProcessorDescriptor<TDocument> Urldecode(UrlDecodeProcessor urlDecodeProcessor) => Set(urlDecodeProcessor, "urldecode");
	public ProcessorDescriptor<TDocument> Urldecode(Action<UrlDecodeProcessorDescriptor<TDocument>> configure) => Set(configure, "urldecode");
	public ProcessorDescriptor<TDocument> UserAgent(UserAgentProcessor userAgentProcessor) => Set(userAgentProcessor, "user_agent");
	public ProcessorDescriptor<TDocument> UserAgent(Action<UserAgentProcessorDescriptor<TDocument>> configure) => Set(configure, "user_agent");

	protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
	{
		if (!ContainsVariant)
		{
			writer.WriteNullValue();
			return;
		}

		writer.WriteStartObject();
		writer.WritePropertyName(ContainedVariantName);
		if (Variant is not null)
		{
			JsonSerializer.Serialize(writer, Variant, Variant.GetType(), options);
			writer.WriteEndObject();
			return;
		}

		JsonSerializer.Serialize(writer, Descriptor, Descriptor.GetType(), options);
		writer.WriteEndObject();
	}
}

public sealed partial class ProcessorDescriptor : SerializableDescriptor<ProcessorDescriptor>
{
	internal ProcessorDescriptor(Action<ProcessorDescriptor> configure) => configure.Invoke(this);

	public ProcessorDescriptor() : base()
	{
	}

	private bool ContainsVariant { get; set; }
	private string ContainedVariantName { get; set; }
	private object Variant { get; set; }
	private Descriptor Descriptor { get; set; }

	private ProcessorDescriptor Set<T>(Action<T> descriptorAction, string variantName) where T : Descriptor
	{
		ContainedVariantName = variantName;
		ContainsVariant = true;
		var descriptor = (T)Activator.CreateInstance(typeof(T), true);
		descriptorAction?.Invoke(descriptor);
		Descriptor = descriptor;
		return Self;
	}

	private ProcessorDescriptor Set(object variant, string variantName)
	{
		Variant = variant;
		ContainedVariantName = variantName;
		ContainsVariant = true;
		return Self;
	}

	public ProcessorDescriptor Append(AppendProcessor appendProcessor) => Set(appendProcessor, "append");
	public ProcessorDescriptor Append(Action<AppendProcessorDescriptor> configure) => Set(configure, "append");
	public ProcessorDescriptor Append<TDocument>(Action<AppendProcessorDescriptor<TDocument>> configure) => Set(configure, "append");
	public ProcessorDescriptor Attachment(AttachmentProcessor attachmentProcessor) => Set(attachmentProcessor, "attachment");
	public ProcessorDescriptor Attachment(Action<AttachmentProcessorDescriptor> configure) => Set(configure, "attachment");
	public ProcessorDescriptor Attachment<TDocument>(Action<AttachmentProcessorDescriptor<TDocument>> configure) => Set(configure, "attachment");
	public ProcessorDescriptor Bytes(BytesProcessor bytesProcessor) => Set(bytesProcessor, "bytes");
	public ProcessorDescriptor Bytes(Action<BytesProcessorDescriptor> configure) => Set(configure, "bytes");
	public ProcessorDescriptor Bytes<TDocument>(Action<BytesProcessorDescriptor<TDocument>> configure) => Set(configure, "bytes");
	public ProcessorDescriptor Circle(CircleProcessor circleProcessor) => Set(circleProcessor, "circle");
	public ProcessorDescriptor Circle(Action<CircleProcessorDescriptor> configure) => Set(configure, "circle");
	public ProcessorDescriptor Circle<TDocument>(Action<CircleProcessorDescriptor<TDocument>> configure) => Set(configure, "circle");
	public ProcessorDescriptor Convert(ConvertProcessor convertProcessor) => Set(convertProcessor, "convert");
	public ProcessorDescriptor Convert(Action<ConvertProcessorDescriptor> configure) => Set(configure, "convert");
	public ProcessorDescriptor Convert<TDocument>(Action<ConvertProcessorDescriptor<TDocument>> configure) => Set(configure, "convert");
	public ProcessorDescriptor Csv(CsvProcessor csvProcessor) => Set(csvProcessor, "csv");
	public ProcessorDescriptor Csv(Action<CsvProcessorDescriptor> configure) => Set(configure, "csv");
	public ProcessorDescriptor Csv<TDocument>(Action<CsvProcessorDescriptor<TDocument>> configure) => Set(configure, "csv");
	public ProcessorDescriptor Date(DateProcessor dateProcessor) => Set(dateProcessor, "date");
	public ProcessorDescriptor Date(Action<DateProcessorDescriptor> configure) => Set(configure, "date");
	public ProcessorDescriptor Date<TDocument>(Action<DateProcessorDescriptor<TDocument>> configure) => Set(configure, "date");
	public ProcessorDescriptor DateIndexName(DateIndexNameProcessor dateIndexNameProcessor) => Set(dateIndexNameProcessor, "date_index_name");
	public ProcessorDescriptor DateIndexName(Action<DateIndexNameProcessorDescriptor> configure) => Set(configure, "date_index_name");
	public ProcessorDescriptor DateIndexName<TDocument>(Action<DateIndexNameProcessorDescriptor<TDocument>> configure) => Set(configure, "date_index_name");
	public ProcessorDescriptor Dissect(DissectProcessor dissectProcessor) => Set(dissectProcessor, "dissect");
	public ProcessorDescriptor Dissect(Action<DissectProcessorDescriptor> configure) => Set(configure, "dissect");
	public ProcessorDescriptor Dissect<TDocument>(Action<DissectProcessorDescriptor<TDocument>> configure) => Set(configure, "dissect");
	public ProcessorDescriptor DotExpander(DotExpanderProcessor dotExpanderProcessor) => Set(dotExpanderProcessor, "dot_expander");
	public ProcessorDescriptor DotExpander(Action<DotExpanderProcessorDescriptor> configure) => Set(configure, "dot_expander");
	public ProcessorDescriptor DotExpander<TDocument>(Action<DotExpanderProcessorDescriptor<TDocument>> configure) => Set(configure, "dot_expander");
	public ProcessorDescriptor Drop(DropProcessor dropProcessor) => Set(dropProcessor, "drop");
	public ProcessorDescriptor Drop(Action<DropProcessorDescriptor> configure) => Set(configure, "drop");
	public ProcessorDescriptor Drop<TDocument>(Action<DropProcessorDescriptor<TDocument>> configure) => Set(configure, "drop");
	public ProcessorDescriptor Enrich(EnrichProcessor enrichProcessor) => Set(enrichProcessor, "enrich");
	public ProcessorDescriptor Enrich(Action<EnrichProcessorDescriptor> configure) => Set(configure, "enrich");
	public ProcessorDescriptor Enrich<TDocument>(Action<EnrichProcessorDescriptor<TDocument>> configure) => Set(configure, "enrich");
	public ProcessorDescriptor Fail(FailProcessor failProcessor) => Set(failProcessor, "fail");
	public ProcessorDescriptor Fail(Action<FailProcessorDescriptor> configure) => Set(configure, "fail");
	public ProcessorDescriptor Fail<TDocument>(Action<FailProcessorDescriptor<TDocument>> configure) => Set(configure, "fail");
	public ProcessorDescriptor Foreach(ForeachProcessor foreachProcessor) => Set(foreachProcessor, "foreach");
	public ProcessorDescriptor Foreach(Action<ForeachProcessorDescriptor> configure) => Set(configure, "foreach");
	public ProcessorDescriptor Foreach<TDocument>(Action<ForeachProcessorDescriptor<TDocument>> configure) => Set(configure, "foreach");
	public ProcessorDescriptor Geoip(GeoIpProcessor geoIpProcessor) => Set(geoIpProcessor, "geoip");
	public ProcessorDescriptor Geoip(Action<GeoIpProcessorDescriptor> configure) => Set(configure, "geoip");
	public ProcessorDescriptor Geoip<TDocument>(Action<GeoIpProcessorDescriptor<TDocument>> configure) => Set(configure, "geoip");
	public ProcessorDescriptor Grok(GrokProcessor grokProcessor) => Set(grokProcessor, "grok");
	public ProcessorDescriptor Grok(Action<GrokProcessorDescriptor> configure) => Set(configure, "grok");
	public ProcessorDescriptor Grok<TDocument>(Action<GrokProcessorDescriptor<TDocument>> configure) => Set(configure, "grok");
	public ProcessorDescriptor Gsub(GsubProcessor gsubProcessor) => Set(gsubProcessor, "gsub");
	public ProcessorDescriptor Gsub(Action<GsubProcessorDescriptor> configure) => Set(configure, "gsub");
	public ProcessorDescriptor Gsub<TDocument>(Action<GsubProcessorDescriptor<TDocument>> configure) => Set(configure, "gsub");
	public ProcessorDescriptor Inference(InferenceProcessor inferenceProcessor) => Set(inferenceProcessor, "inference");
	public ProcessorDescriptor Inference(Action<InferenceProcessorDescriptor> configure) => Set(configure, "inference");
	public ProcessorDescriptor Inference<TDocument>(Action<InferenceProcessorDescriptor<TDocument>> configure) => Set(configure, "inference");
	public ProcessorDescriptor Join(JoinProcessor joinProcessor) => Set(joinProcessor, "join");
	public ProcessorDescriptor Join(Action<JoinProcessorDescriptor> configure) => Set(configure, "join");
	public ProcessorDescriptor Join<TDocument>(Action<JoinProcessorDescriptor<TDocument>> configure) => Set(configure, "join");
	public ProcessorDescriptor Json(JsonProcessor jsonProcessor) => Set(jsonProcessor, "json");
	public ProcessorDescriptor Json(Action<JsonProcessorDescriptor> configure) => Set(configure, "json");
	public ProcessorDescriptor Json<TDocument>(Action<JsonProcessorDescriptor<TDocument>> configure) => Set(configure, "json");
	public ProcessorDescriptor Kv(KeyValueProcessor keyValueProcessor) => Set(keyValueProcessor, "kv");
	public ProcessorDescriptor Kv(Action<KeyValueProcessorDescriptor> configure) => Set(configure, "kv");
	public ProcessorDescriptor Kv<TDocument>(Action<KeyValueProcessorDescriptor<TDocument>> configure) => Set(configure, "kv");
	public ProcessorDescriptor Lowercase(LowercaseProcessor lowercaseProcessor) => Set(lowercaseProcessor, "lowercase");
	public ProcessorDescriptor Lowercase(Action<LowercaseProcessorDescriptor> configure) => Set(configure, "lowercase");
	public ProcessorDescriptor Lowercase<TDocument>(Action<LowercaseProcessorDescriptor<TDocument>> configure) => Set(configure, "lowercase");
	public ProcessorDescriptor Pipeline(PipelineProcessor pipelineProcessor) => Set(pipelineProcessor, "pipeline");
	public ProcessorDescriptor Pipeline(Action<PipelineProcessorDescriptor> configure) => Set(configure, "pipeline");
	public ProcessorDescriptor Pipeline<TDocument>(Action<PipelineProcessorDescriptor<TDocument>> configure) => Set(configure, "pipeline");
	public ProcessorDescriptor Remove(RemoveProcessor removeProcessor) => Set(removeProcessor, "remove");
	public ProcessorDescriptor Remove(Action<RemoveProcessorDescriptor> configure) => Set(configure, "remove");
	public ProcessorDescriptor Remove<TDocument>(Action<RemoveProcessorDescriptor<TDocument>> configure) => Set(configure, "remove");
	public ProcessorDescriptor Rename(RenameProcessor renameProcessor) => Set(renameProcessor, "rename");
	public ProcessorDescriptor Rename(Action<RenameProcessorDescriptor> configure) => Set(configure, "rename");
	public ProcessorDescriptor Rename<TDocument>(Action<RenameProcessorDescriptor<TDocument>> configure) => Set(configure, "rename");
	public ProcessorDescriptor Set(SetProcessor setProcessor) => Set(setProcessor, "set");
	public ProcessorDescriptor Set(Action<SetProcessorDescriptor> configure) => Set(configure, "set");
	public ProcessorDescriptor Set<TDocument>(Action<SetProcessorDescriptor<TDocument>> configure) => Set(configure, "set");
	public ProcessorDescriptor SetSecurityUser(SetSecurityUserProcessor setSecurityUserProcessor) => Set(setSecurityUserProcessor, "set_security_user");
	public ProcessorDescriptor SetSecurityUser(Action<SetSecurityUserProcessorDescriptor> configure) => Set(configure, "set_security_user");
	public ProcessorDescriptor SetSecurityUser<TDocument>(Action<SetSecurityUserProcessorDescriptor<TDocument>> configure) => Set(configure, "set_security_user");
	public ProcessorDescriptor Sort(SortProcessor sortProcessor) => Set(sortProcessor, "sort");
	public ProcessorDescriptor Sort(Action<SortProcessorDescriptor> configure) => Set(configure, "sort");
	public ProcessorDescriptor Sort<TDocument>(Action<SortProcessorDescriptor<TDocument>> configure) => Set(configure, "sort");
	public ProcessorDescriptor Split(SplitProcessor splitProcessor) => Set(splitProcessor, "split");
	public ProcessorDescriptor Split(Action<SplitProcessorDescriptor> configure) => Set(configure, "split");
	public ProcessorDescriptor Split<TDocument>(Action<SplitProcessorDescriptor<TDocument>> configure) => Set(configure, "split");
	public ProcessorDescriptor Trim(TrimProcessor trimProcessor) => Set(trimProcessor, "trim");
	public ProcessorDescriptor Trim(Action<TrimProcessorDescriptor> configure) => Set(configure, "trim");
	public ProcessorDescriptor Trim<TDocument>(Action<TrimProcessorDescriptor<TDocument>> configure) => Set(configure, "trim");
	public ProcessorDescriptor Uppercase(UppercaseProcessor uppercaseProcessor) => Set(uppercaseProcessor, "uppercase");
	public ProcessorDescriptor Uppercase(Action<UppercaseProcessorDescriptor> configure) => Set(configure, "uppercase");
	public ProcessorDescriptor Uppercase<TDocument>(Action<UppercaseProcessorDescriptor<TDocument>> configure) => Set(configure, "uppercase");
	public ProcessorDescriptor Urldecode(UrlDecodeProcessor urlDecodeProcessor) => Set(urlDecodeProcessor, "urldecode");
	public ProcessorDescriptor Urldecode(Action<UrlDecodeProcessorDescriptor> configure) => Set(configure, "urldecode");
	public ProcessorDescriptor Urldecode<TDocument>(Action<UrlDecodeProcessorDescriptor<TDocument>> configure) => Set(configure, "urldecode");
	public ProcessorDescriptor UserAgent(UserAgentProcessor userAgentProcessor) => Set(userAgentProcessor, "user_agent");
	public ProcessorDescriptor UserAgent(Action<UserAgentProcessorDescriptor> configure) => Set(configure, "user_agent");
	public ProcessorDescriptor UserAgent<TDocument>(Action<UserAgentProcessorDescriptor<TDocument>> configure) => Set(configure, "user_agent");

	protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
	{
		if (!ContainsVariant)
		{
			writer.WriteNullValue();
			return;
		}

		writer.WriteStartObject();
		writer.WritePropertyName(ContainedVariantName);
		if (Variant is not null)
		{
			JsonSerializer.Serialize(writer, Variant, Variant.GetType(), options);
			writer.WriteEndObject();
			return;
		}

		JsonSerializer.Serialize(writer, Descriptor, Descriptor.GetType(), options);
		writer.WriteEndObject();
	}
}