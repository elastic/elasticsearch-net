// Licensed to Elasticsearch B.V under one or more agreements.
// Elasticsearch B.V licenses this file to you under the Apache 2.0 License.
// See the LICENSE file in the project root for more information.
//
// ███╗   ██╗ ██████╗ ████████╗██╗ ██████╗███████╗
// ████╗  ██║██╔═══██╗╚══██╔══╝██║██╔════╝██╔════╝
// ██╔██╗ ██║██║   ██║   ██║   ██║██║     █████╗
// ██║╚██╗██║██║   ██║   ██║   ██║██║     ██╔══╝
// ██║ ╚████║╚██████╔╝   ██║   ██║╚██████╗███████╗
// ╚═╝  ╚═══╝ ╚═════╝    ╚═╝   ╚═╝ ╚═════╝╚══════╝
// ------------------------------------------------
//
// This file is automatically generated.
// Please do not edit these files manually.
//
// ------------------------------------------------

using System;
using System.Collections.Generic;
using System.Text.Json;
using System.Text.Json.Serialization;

#nullable restore
namespace Elastic.Clients.Elasticsearch.IndexManagement
{
	public partial class Alias
	{
		[JsonInclude]
		[JsonPropertyName("filter")]
		public Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? Filter { get; set; }

		[JsonInclude]
		[JsonPropertyName("index_routing")]
		public string? IndexRouting { get; set; }

		[JsonInclude]
		[JsonPropertyName("is_hidden")]
		public bool? IsHidden { get; set; }

		[JsonInclude]
		[JsonPropertyName("is_write_index")]
		public bool? IsWriteIndex { get; set; }

		[JsonInclude]
		[JsonPropertyName("routing")]
		public string? Routing { get; set; }

		[JsonInclude]
		[JsonPropertyName("search_routing")]
		public string? SearchRouting { get; set; }
	}

	public sealed partial class AliasDescriptor<T> : DescriptorBase<AliasDescriptor<T>>
	{
		public AliasDescriptor()
		{
		}

		internal AliasDescriptor(Action<AliasDescriptor<T>> configure) => configure.Invoke(this);
		internal Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? FilterValue { get; private set; }

		internal string? IndexRoutingValue { get; private set; }

		internal bool? IsHiddenValue { get; private set; }

		internal bool? IsWriteIndexValue { get; private set; }

		internal string? RoutingValue { get; private set; }

		internal string? SearchRoutingValue { get; private set; }

		internal QueryDsl.QueryContainerDescriptor<T> FilterDescriptor { get; private set; }

		internal Action<QueryDsl.QueryContainerDescriptor<T>> FilterDescriptorAction { get; private set; }

		public AliasDescriptor<T> Filter(Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? filter)
		{
			FilterDescriptor = null;
			FilterDescriptorAction = null;
			return Assign(filter, (a, v) => a.FilterValue = v);
		}

		public AliasDescriptor<T> Filter(Elastic.Clients.Elasticsearch.QueryDsl.QueryContainerDescriptor<T> descriptor)
		{
			FilterValue = null;
			FilterDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.FilterDescriptor = v);
		}

		public AliasDescriptor<T> Filter(Action<Elastic.Clients.Elasticsearch.QueryDsl.QueryContainerDescriptor<T>> configure)
		{
			FilterValue = null;
			FilterDescriptorAction = null;
			return Assign(configure, (a, v) => a.FilterDescriptorAction = v);
		}

		public AliasDescriptor<T> IndexRouting(string? indexRouting) => Assign(indexRouting, (a, v) => a.IndexRoutingValue = v);
		public AliasDescriptor<T> IsHidden(bool? isHidden = true) => Assign(isHidden, (a, v) => a.IsHiddenValue = v);
		public AliasDescriptor<T> IsWriteIndex(bool? isWriteIndex = true) => Assign(isWriteIndex, (a, v) => a.IsWriteIndexValue = v);
		public AliasDescriptor<T> Routing(string? routing) => Assign(routing, (a, v) => a.RoutingValue = v);
		public AliasDescriptor<T> SearchRouting(string? searchRouting) => Assign(searchRouting, (a, v) => a.SearchRoutingValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (FilterDescriptor is not null)
			{
				writer.WritePropertyName("filter");
				JsonSerializer.Serialize(writer, FilterDescriptor, options);
			}
			else if (FilterDescriptorAction is not null)
			{
				writer.WritePropertyName("filter");
				JsonSerializer.Serialize(writer, new QueryDsl.QueryContainerDescriptor<T>(FilterDescriptorAction), options);
			}
			else if (FilterValue is not null)
			{
				writer.WritePropertyName("filter");
				JsonSerializer.Serialize(writer, FilterValue, options);
			}

			if (IndexRoutingValue is not null)
			{
				writer.WritePropertyName("index_routing");
				JsonSerializer.Serialize(writer, IndexRoutingValue, options);
			}

			if (IsHiddenValue.HasValue)
			{
				writer.WritePropertyName("is_hidden");
				writer.WriteBooleanValue(IsHiddenValue.Value);
			}

			if (IsWriteIndexValue.HasValue)
			{
				writer.WritePropertyName("is_write_index");
				writer.WriteBooleanValue(IsWriteIndexValue.Value);
			}

			if (RoutingValue is not null)
			{
				writer.WritePropertyName("routing");
				JsonSerializer.Serialize(writer, RoutingValue, options);
			}

			if (SearchRoutingValue is not null)
			{
				writer.WritePropertyName("search_routing");
				JsonSerializer.Serialize(writer, SearchRoutingValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class AliasDefinition
	{
		[JsonInclude]
		[JsonPropertyName("filter")]
		public Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? Filter { get; set; }

		[JsonInclude]
		[JsonPropertyName("index_routing")]
		public string? IndexRouting { get; set; }

		[JsonInclude]
		[JsonPropertyName("is_write_index")]
		public bool? IsWriteIndex { get; set; }

		[JsonInclude]
		[JsonPropertyName("routing")]
		public string? Routing { get; set; }

		[JsonInclude]
		[JsonPropertyName("search_routing")]
		public string? SearchRouting { get; set; }
	}

	public sealed partial class AliasDefinitionDescriptor<T> : DescriptorBase<AliasDefinitionDescriptor<T>>
	{
		public AliasDefinitionDescriptor()
		{
		}

		internal AliasDefinitionDescriptor(Action<AliasDefinitionDescriptor<T>> configure) => configure.Invoke(this);
		internal Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? FilterValue { get; private set; }

		internal string? IndexRoutingValue { get; private set; }

		internal bool? IsWriteIndexValue { get; private set; }

		internal string? RoutingValue { get; private set; }

		internal string? SearchRoutingValue { get; private set; }

		internal QueryDsl.QueryContainerDescriptor<T> FilterDescriptor { get; private set; }

		internal Action<QueryDsl.QueryContainerDescriptor<T>> FilterDescriptorAction { get; private set; }

		public AliasDefinitionDescriptor<T> Filter(Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? filter)
		{
			FilterDescriptor = null;
			FilterDescriptorAction = null;
			return Assign(filter, (a, v) => a.FilterValue = v);
		}

		public AliasDefinitionDescriptor<T> Filter(Elastic.Clients.Elasticsearch.QueryDsl.QueryContainerDescriptor<T> descriptor)
		{
			FilterValue = null;
			FilterDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.FilterDescriptor = v);
		}

		public AliasDefinitionDescriptor<T> Filter(Action<Elastic.Clients.Elasticsearch.QueryDsl.QueryContainerDescriptor<T>> configure)
		{
			FilterValue = null;
			FilterDescriptorAction = null;
			return Assign(configure, (a, v) => a.FilterDescriptorAction = v);
		}

		public AliasDefinitionDescriptor<T> IndexRouting(string? indexRouting) => Assign(indexRouting, (a, v) => a.IndexRoutingValue = v);
		public AliasDefinitionDescriptor<T> IsWriteIndex(bool? isWriteIndex = true) => Assign(isWriteIndex, (a, v) => a.IsWriteIndexValue = v);
		public AliasDefinitionDescriptor<T> Routing(string? routing) => Assign(routing, (a, v) => a.RoutingValue = v);
		public AliasDefinitionDescriptor<T> SearchRouting(string? searchRouting) => Assign(searchRouting, (a, v) => a.SearchRoutingValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (FilterDescriptor is not null)
			{
				writer.WritePropertyName("filter");
				JsonSerializer.Serialize(writer, FilterDescriptor, options);
			}
			else if (FilterDescriptorAction is not null)
			{
				writer.WritePropertyName("filter");
				JsonSerializer.Serialize(writer, new QueryDsl.QueryContainerDescriptor<T>(FilterDescriptorAction), options);
			}
			else if (FilterValue is not null)
			{
				writer.WritePropertyName("filter");
				JsonSerializer.Serialize(writer, FilterValue, options);
			}

			if (!string.IsNullOrEmpty(IndexRoutingValue))
			{
				writer.WritePropertyName("index_routing");
				writer.WriteStringValue(IndexRoutingValue);
			}

			if (IsWriteIndexValue.HasValue)
			{
				writer.WritePropertyName("is_write_index");
				writer.WriteBooleanValue(IsWriteIndexValue.Value);
			}

			if (!string.IsNullOrEmpty(RoutingValue))
			{
				writer.WritePropertyName("routing");
				writer.WriteStringValue(RoutingValue);
			}

			if (!string.IsNullOrEmpty(SearchRoutingValue))
			{
				writer.WritePropertyName("search_routing");
				writer.WriteStringValue(SearchRoutingValue);
			}

			writer.WriteEndObject();
		}
	}

	public partial class DataStream
	{
		[JsonInclude]
		[JsonPropertyName("hidden")]
		public bool? Hidden { get; set; }
	}

	public sealed partial class DataStreamDescriptor : DescriptorBase<DataStreamDescriptor>
	{
		public DataStreamDescriptor()
		{
		}

		internal DataStreamDescriptor(Action<DataStreamDescriptor> configure) => configure.Invoke(this);
		internal bool? HiddenValue { get; private set; }

		public DataStreamDescriptor Hidden(bool? hidden = true) => Assign(hidden, (a, v) => a.HiddenValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (HiddenValue.HasValue)
			{
				writer.WritePropertyName("hidden");
				writer.WriteBooleanValue(HiddenValue.Value);
			}

			writer.WriteEndObject();
		}
	}

	public partial class FielddataFrequencyFilter
	{
		[JsonInclude]
		[JsonPropertyName("max")]
		public double Max { get; init; }

		[JsonInclude]
		[JsonPropertyName("min")]
		public double Min { get; init; }

		[JsonInclude]
		[JsonPropertyName("min_segment_size")]
		public int MinSegmentSize { get; init; }
	}

	public partial class IndexRouting
	{
		[JsonInclude]
		[JsonPropertyName("allocation")]
		public Elastic.Clients.Elasticsearch.IndexManagement.IndexRoutingAllocation? Allocation { get; set; }

		[JsonInclude]
		[JsonPropertyName("rebalance")]
		public Elastic.Clients.Elasticsearch.IndexManagement.IndexRoutingRebalance? Rebalance { get; set; }
	}

	public sealed partial class IndexRoutingDescriptor : DescriptorBase<IndexRoutingDescriptor>
	{
		public IndexRoutingDescriptor()
		{
		}

		internal IndexRoutingDescriptor(Action<IndexRoutingDescriptor> configure) => configure.Invoke(this);
		internal Elastic.Clients.Elasticsearch.IndexManagement.IndexRoutingAllocation? AllocationValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.IndexManagement.IndexRoutingRebalance? RebalanceValue { get; private set; }

		internal IndexRoutingAllocationDescriptor AllocationDescriptor { get; private set; }

		internal IndexRoutingRebalanceDescriptor RebalanceDescriptor { get; private set; }

		internal Action<IndexRoutingAllocationDescriptor> AllocationDescriptorAction { get; private set; }

		internal Action<IndexRoutingRebalanceDescriptor> RebalanceDescriptorAction { get; private set; }

		public IndexRoutingDescriptor Allocation(Elastic.Clients.Elasticsearch.IndexManagement.IndexRoutingAllocation? allocation)
		{
			AllocationDescriptor = null;
			AllocationDescriptorAction = null;
			return Assign(allocation, (a, v) => a.AllocationValue = v);
		}

		public IndexRoutingDescriptor Allocation(Elastic.Clients.Elasticsearch.IndexManagement.IndexRoutingAllocationDescriptor descriptor)
		{
			AllocationValue = null;
			AllocationDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.AllocationDescriptor = v);
		}

		public IndexRoutingDescriptor Allocation(Action<Elastic.Clients.Elasticsearch.IndexManagement.IndexRoutingAllocationDescriptor> configure)
		{
			AllocationValue = null;
			AllocationDescriptorAction = null;
			return Assign(configure, (a, v) => a.AllocationDescriptorAction = v);
		}

		public IndexRoutingDescriptor Rebalance(Elastic.Clients.Elasticsearch.IndexManagement.IndexRoutingRebalance? rebalance)
		{
			RebalanceDescriptor = null;
			RebalanceDescriptorAction = null;
			return Assign(rebalance, (a, v) => a.RebalanceValue = v);
		}

		public IndexRoutingDescriptor Rebalance(Elastic.Clients.Elasticsearch.IndexManagement.IndexRoutingRebalanceDescriptor descriptor)
		{
			RebalanceValue = null;
			RebalanceDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.RebalanceDescriptor = v);
		}

		public IndexRoutingDescriptor Rebalance(Action<Elastic.Clients.Elasticsearch.IndexManagement.IndexRoutingRebalanceDescriptor> configure)
		{
			RebalanceValue = null;
			RebalanceDescriptorAction = null;
			return Assign(configure, (a, v) => a.RebalanceDescriptorAction = v);
		}

		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (AllocationDescriptor is not null)
			{
				writer.WritePropertyName("allocation");
				JsonSerializer.Serialize(writer, AllocationDescriptor, options);
			}
			else if (AllocationDescriptorAction is not null)
			{
				writer.WritePropertyName("allocation");
				JsonSerializer.Serialize(writer, new IndexRoutingAllocationDescriptor(AllocationDescriptorAction), options);
			}
			else if (AllocationValue is not null)
			{
				writer.WritePropertyName("allocation");
				JsonSerializer.Serialize(writer, AllocationValue, options);
			}

			if (RebalanceDescriptor is not null)
			{
				writer.WritePropertyName("rebalance");
				JsonSerializer.Serialize(writer, RebalanceDescriptor, options);
			}
			else if (RebalanceDescriptorAction is not null)
			{
				writer.WritePropertyName("rebalance");
				JsonSerializer.Serialize(writer, new IndexRoutingRebalanceDescriptor(RebalanceDescriptorAction), options);
			}
			else if (RebalanceValue is not null)
			{
				writer.WritePropertyName("rebalance");
				JsonSerializer.Serialize(writer, RebalanceValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class IndexRoutingAllocation
	{
		[JsonInclude]
		[JsonPropertyName("enable")]
		public Elastic.Clients.Elasticsearch.IndexManagement.IndexRoutingAllocationOptions? Enable { get; set; }

		[JsonInclude]
		[JsonPropertyName("include")]
		public Elastic.Clients.Elasticsearch.IndexManagement.IndexRoutingAllocationInclude? Include { get; set; }

		[JsonInclude]
		[JsonPropertyName("initial_recovery")]
		public Elastic.Clients.Elasticsearch.IndexManagement.IndexRoutingAllocationInitialRecovery? InitialRecovery { get; set; }

		[JsonInclude]
		[JsonPropertyName("disk")]
		public Elastic.Clients.Elasticsearch.IndexManagement.IndexRoutingAllocationDisk? Disk { get; set; }
	}

	public sealed partial class IndexRoutingAllocationDescriptor : DescriptorBase<IndexRoutingAllocationDescriptor>
	{
		public IndexRoutingAllocationDescriptor()
		{
		}

		internal IndexRoutingAllocationDescriptor(Action<IndexRoutingAllocationDescriptor> configure) => configure.Invoke(this);
		internal Elastic.Clients.Elasticsearch.IndexManagement.IndexRoutingAllocationOptions? EnableValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.IndexManagement.IndexRoutingAllocationInclude? IncludeValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.IndexManagement.IndexRoutingAllocationInitialRecovery? InitialRecoveryValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.IndexManagement.IndexRoutingAllocationDisk? DiskValue { get; private set; }

		internal IndexRoutingAllocationIncludeDescriptor IncludeDescriptor { get; private set; }

		internal IndexRoutingAllocationInitialRecoveryDescriptor InitialRecoveryDescriptor { get; private set; }

		internal IndexRoutingAllocationDiskDescriptor DiskDescriptor { get; private set; }

		internal Action<IndexRoutingAllocationIncludeDescriptor> IncludeDescriptorAction { get; private set; }

		internal Action<IndexRoutingAllocationInitialRecoveryDescriptor> InitialRecoveryDescriptorAction { get; private set; }

		internal Action<IndexRoutingAllocationDiskDescriptor> DiskDescriptorAction { get; private set; }

		public IndexRoutingAllocationDescriptor Enable(Elastic.Clients.Elasticsearch.IndexManagement.IndexRoutingAllocationOptions? enable) => Assign(enable, (a, v) => a.EnableValue = v);
		public IndexRoutingAllocationDescriptor Include(Elastic.Clients.Elasticsearch.IndexManagement.IndexRoutingAllocationInclude? include)
		{
			IncludeDescriptor = null;
			IncludeDescriptorAction = null;
			return Assign(include, (a, v) => a.IncludeValue = v);
		}

		public IndexRoutingAllocationDescriptor Include(Elastic.Clients.Elasticsearch.IndexManagement.IndexRoutingAllocationIncludeDescriptor descriptor)
		{
			IncludeValue = null;
			IncludeDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.IncludeDescriptor = v);
		}

		public IndexRoutingAllocationDescriptor Include(Action<Elastic.Clients.Elasticsearch.IndexManagement.IndexRoutingAllocationIncludeDescriptor> configure)
		{
			IncludeValue = null;
			IncludeDescriptorAction = null;
			return Assign(configure, (a, v) => a.IncludeDescriptorAction = v);
		}

		public IndexRoutingAllocationDescriptor InitialRecovery(Elastic.Clients.Elasticsearch.IndexManagement.IndexRoutingAllocationInitialRecovery? initialRecovery)
		{
			InitialRecoveryDescriptor = null;
			InitialRecoveryDescriptorAction = null;
			return Assign(initialRecovery, (a, v) => a.InitialRecoveryValue = v);
		}

		public IndexRoutingAllocationDescriptor InitialRecovery(Elastic.Clients.Elasticsearch.IndexManagement.IndexRoutingAllocationInitialRecoveryDescriptor descriptor)
		{
			InitialRecoveryValue = null;
			InitialRecoveryDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.InitialRecoveryDescriptor = v);
		}

		public IndexRoutingAllocationDescriptor InitialRecovery(Action<Elastic.Clients.Elasticsearch.IndexManagement.IndexRoutingAllocationInitialRecoveryDescriptor> configure)
		{
			InitialRecoveryValue = null;
			InitialRecoveryDescriptorAction = null;
			return Assign(configure, (a, v) => a.InitialRecoveryDescriptorAction = v);
		}

		public IndexRoutingAllocationDescriptor Disk(Elastic.Clients.Elasticsearch.IndexManagement.IndexRoutingAllocationDisk? disk)
		{
			DiskDescriptor = null;
			DiskDescriptorAction = null;
			return Assign(disk, (a, v) => a.DiskValue = v);
		}

		public IndexRoutingAllocationDescriptor Disk(Elastic.Clients.Elasticsearch.IndexManagement.IndexRoutingAllocationDiskDescriptor descriptor)
		{
			DiskValue = null;
			DiskDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.DiskDescriptor = v);
		}

		public IndexRoutingAllocationDescriptor Disk(Action<Elastic.Clients.Elasticsearch.IndexManagement.IndexRoutingAllocationDiskDescriptor> configure)
		{
			DiskValue = null;
			DiskDescriptorAction = null;
			return Assign(configure, (a, v) => a.DiskDescriptorAction = v);
		}

		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (EnableValue is not null)
			{
				writer.WritePropertyName("enable");
				JsonSerializer.Serialize(writer, EnableValue, options);
			}

			if (IncludeDescriptor is not null)
			{
				writer.WritePropertyName("include");
				JsonSerializer.Serialize(writer, IncludeDescriptor, options);
			}
			else if (IncludeDescriptorAction is not null)
			{
				writer.WritePropertyName("include");
				JsonSerializer.Serialize(writer, new IndexRoutingAllocationIncludeDescriptor(IncludeDescriptorAction), options);
			}
			else if (IncludeValue is not null)
			{
				writer.WritePropertyName("include");
				JsonSerializer.Serialize(writer, IncludeValue, options);
			}

			if (InitialRecoveryDescriptor is not null)
			{
				writer.WritePropertyName("initial_recovery");
				JsonSerializer.Serialize(writer, InitialRecoveryDescriptor, options);
			}
			else if (InitialRecoveryDescriptorAction is not null)
			{
				writer.WritePropertyName("initial_recovery");
				JsonSerializer.Serialize(writer, new IndexRoutingAllocationInitialRecoveryDescriptor(InitialRecoveryDescriptorAction), options);
			}
			else if (InitialRecoveryValue is not null)
			{
				writer.WritePropertyName("initial_recovery");
				JsonSerializer.Serialize(writer, InitialRecoveryValue, options);
			}

			if (DiskDescriptor is not null)
			{
				writer.WritePropertyName("disk");
				JsonSerializer.Serialize(writer, DiskDescriptor, options);
			}
			else if (DiskDescriptorAction is not null)
			{
				writer.WritePropertyName("disk");
				JsonSerializer.Serialize(writer, new IndexRoutingAllocationDiskDescriptor(DiskDescriptorAction), options);
			}
			else if (DiskValue is not null)
			{
				writer.WritePropertyName("disk");
				JsonSerializer.Serialize(writer, DiskValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class IndexRoutingAllocationDisk
	{
		[JsonInclude]
		[JsonPropertyName("threshold_enabled")]
		public Union<bool, string> ThresholdEnabled { get; set; }
	}

	public sealed partial class IndexRoutingAllocationDiskDescriptor : DescriptorBase<IndexRoutingAllocationDiskDescriptor>
	{
		public IndexRoutingAllocationDiskDescriptor()
		{
		}

		internal IndexRoutingAllocationDiskDescriptor(Action<IndexRoutingAllocationDiskDescriptor> configure) => configure.Invoke(this);
		internal Union<bool, string> ThresholdEnabledValue { get; private set; }

		public IndexRoutingAllocationDiskDescriptor ThresholdEnabled(Union<bool, string> thresholdEnabled) => Assign(thresholdEnabled, (a, v) => a.ThresholdEnabledValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("threshold_enabled");
			JsonSerializer.Serialize(writer, ThresholdEnabledValue, options);
			writer.WriteEndObject();
		}
	}

	public partial class IndexRoutingAllocationInclude
	{
		[JsonInclude]
		[JsonPropertyName("_tier_preference")]
		public string? TierPreference { get; set; }

		[JsonInclude]
		[JsonPropertyName("_id")]
		public Elastic.Clients.Elasticsearch.Id? Id { get; set; }
	}

	public sealed partial class IndexRoutingAllocationIncludeDescriptor : DescriptorBase<IndexRoutingAllocationIncludeDescriptor>
	{
		public IndexRoutingAllocationIncludeDescriptor()
		{
		}

		internal IndexRoutingAllocationIncludeDescriptor(Action<IndexRoutingAllocationIncludeDescriptor> configure) => configure.Invoke(this);
		internal string? TierPreferenceValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Id? IdValue { get; private set; }

		public IndexRoutingAllocationIncludeDescriptor TierPreference(string? tierPreference) => Assign(tierPreference, (a, v) => a.TierPreferenceValue = v);
		public IndexRoutingAllocationIncludeDescriptor Id(Elastic.Clients.Elasticsearch.Id? id) => Assign(id, (a, v) => a.IdValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (!string.IsNullOrEmpty(TierPreferenceValue))
			{
				writer.WritePropertyName("_tier_preference");
				writer.WriteStringValue(TierPreferenceValue);
			}

			if (IdValue is not null)
			{
				writer.WritePropertyName("_id");
				JsonSerializer.Serialize(writer, IdValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class IndexRoutingAllocationInitialRecovery
	{
		[JsonInclude]
		[JsonPropertyName("_id")]
		public Elastic.Clients.Elasticsearch.Id? Id { get; set; }
	}

	public sealed partial class IndexRoutingAllocationInitialRecoveryDescriptor : DescriptorBase<IndexRoutingAllocationInitialRecoveryDescriptor>
	{
		public IndexRoutingAllocationInitialRecoveryDescriptor()
		{
		}

		internal IndexRoutingAllocationInitialRecoveryDescriptor(Action<IndexRoutingAllocationInitialRecoveryDescriptor> configure) => configure.Invoke(this);
		internal Elastic.Clients.Elasticsearch.Id? IdValue { get; private set; }

		public IndexRoutingAllocationInitialRecoveryDescriptor Id(Elastic.Clients.Elasticsearch.Id? id) => Assign(id, (a, v) => a.IdValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (IdValue is not null)
			{
				writer.WritePropertyName("_id");
				JsonSerializer.Serialize(writer, IdValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class IndexRoutingRebalance
	{
		[JsonInclude]
		[JsonPropertyName("enable")]
		public Elastic.Clients.Elasticsearch.IndexManagement.IndexRoutingRebalanceOptions Enable { get; set; }
	}

	public sealed partial class IndexRoutingRebalanceDescriptor : DescriptorBase<IndexRoutingRebalanceDescriptor>
	{
		public IndexRoutingRebalanceDescriptor()
		{
		}

		internal IndexRoutingRebalanceDescriptor(Action<IndexRoutingRebalanceDescriptor> configure) => configure.Invoke(this);
		internal Elastic.Clients.Elasticsearch.IndexManagement.IndexRoutingRebalanceOptions EnableValue { get; private set; }

		public IndexRoutingRebalanceDescriptor Enable(Elastic.Clients.Elasticsearch.IndexManagement.IndexRoutingRebalanceOptions enable) => Assign(enable, (a, v) => a.EnableValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("enable");
			JsonSerializer.Serialize(writer, EnableValue, options);
			writer.WriteEndObject();
		}
	}

	public partial class IndexSegmentSort
	{
		[JsonInclude]
		[JsonPropertyName("field")]
		public Elastic.Clients.Elasticsearch.Fields Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("order")]
		public Elastic.Clients.Elasticsearch.IndexManagement.SegmentSortOrder Order { get; set; }

		[JsonInclude]
		[JsonPropertyName("mode")]
		public Elastic.Clients.Elasticsearch.IndexManagement.SegmentSortMode? Mode { get; set; }

		[JsonInclude]
		[JsonPropertyName("missing")]
		public Elastic.Clients.Elasticsearch.IndexManagement.SegmentSortMissing? Missing { get; set; }
	}

	public sealed partial class IndexSegmentSortDescriptor<T> : DescriptorBase<IndexSegmentSortDescriptor<T>>
	{
		public IndexSegmentSortDescriptor()
		{
		}

		internal IndexSegmentSortDescriptor(Action<IndexSegmentSortDescriptor<T>> configure) => configure.Invoke(this);
		internal Elastic.Clients.Elasticsearch.Fields FieldValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.IndexManagement.SegmentSortOrder OrderValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.IndexManagement.SegmentSortMode? ModeValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.IndexManagement.SegmentSortMissing? MissingValue { get; private set; }

		public IndexSegmentSortDescriptor<T> Field(Elastic.Clients.Elasticsearch.Fields field) => Assign(field, (a, v) => a.FieldValue = v);
		public IndexSegmentSortDescriptor<T> Order(Elastic.Clients.Elasticsearch.IndexManagement.SegmentSortOrder order) => Assign(order, (a, v) => a.OrderValue = v);
		public IndexSegmentSortDescriptor<T> Mode(Elastic.Clients.Elasticsearch.IndexManagement.SegmentSortMode? mode) => Assign(mode, (a, v) => a.ModeValue = v);
		public IndexSegmentSortDescriptor<T> Missing(Elastic.Clients.Elasticsearch.IndexManagement.SegmentSortMissing? missing) => Assign(missing, (a, v) => a.MissingValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, FieldValue, options);
			writer.WritePropertyName("order");
			JsonSerializer.Serialize(writer, OrderValue, options);
			if (ModeValue is not null)
			{
				writer.WritePropertyName("mode");
				JsonSerializer.Serialize(writer, ModeValue, options);
			}

			if (MissingValue is not null)
			{
				writer.WritePropertyName("missing");
				JsonSerializer.Serialize(writer, MissingValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class IndexSettingBlocks
	{
		[JsonInclude]
		[JsonPropertyName("read_only")]
		public bool? ReadOnly { get; set; }

		[JsonInclude]
		[JsonPropertyName("read_only_allow_delete")]
		public bool? ReadOnlyAllowDelete { get; set; }

		[JsonInclude]
		[JsonPropertyName("read")]
		public bool? Read { get; set; }

		[JsonInclude]
		[JsonPropertyName("write")]
		public Union<bool?, string?>? Write { get; set; }

		[JsonInclude]
		[JsonPropertyName("metadata")]
		public bool? Metadata { get; set; }
	}

	public sealed partial class IndexSettingBlocksDescriptor : DescriptorBase<IndexSettingBlocksDescriptor>
	{
		public IndexSettingBlocksDescriptor()
		{
		}

		internal IndexSettingBlocksDescriptor(Action<IndexSettingBlocksDescriptor> configure) => configure.Invoke(this);
		internal bool? ReadOnlyValue { get; private set; }

		internal bool? ReadOnlyAllowDeleteValue { get; private set; }

		internal bool? ReadValue { get; private set; }

		internal Union<bool?, string?>? WriteValue { get; private set; }

		internal bool? MetadataValue { get; private set; }

		public IndexSettingBlocksDescriptor ReadOnly(bool? readOnly = true) => Assign(readOnly, (a, v) => a.ReadOnlyValue = v);
		public IndexSettingBlocksDescriptor ReadOnlyAllowDelete(bool? readOnlyAllowDelete = true) => Assign(readOnlyAllowDelete, (a, v) => a.ReadOnlyAllowDeleteValue = v);
		public IndexSettingBlocksDescriptor Read(bool? read = true) => Assign(read, (a, v) => a.ReadValue = v);
		public IndexSettingBlocksDescriptor Write(Union<bool?, string?>? write) => Assign(write, (a, v) => a.WriteValue = v);
		public IndexSettingBlocksDescriptor Metadata(bool? metadata = true) => Assign(metadata, (a, v) => a.MetadataValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (ReadOnlyValue.HasValue)
			{
				writer.WritePropertyName("read_only");
				writer.WriteBooleanValue(ReadOnlyValue.Value);
			}

			if (ReadOnlyAllowDeleteValue.HasValue)
			{
				writer.WritePropertyName("read_only_allow_delete");
				writer.WriteBooleanValue(ReadOnlyAllowDeleteValue.Value);
			}

			if (ReadValue.HasValue)
			{
				writer.WritePropertyName("read");
				writer.WriteBooleanValue(ReadValue.Value);
			}

			if (WriteValue is not null)
			{
				writer.WritePropertyName("write");
				JsonSerializer.Serialize(writer, WriteValue, options);
			}

			if (MetadataValue.HasValue)
			{
				writer.WritePropertyName("metadata");
				writer.WriteBooleanValue(MetadataValue.Value);
			}

			writer.WriteEndObject();
		}
	}

	public partial class IndexSettings
	{
		[JsonInclude]
		[JsonPropertyName("index")]
		public Elastic.Clients.Elasticsearch.IndexManagement.IndexSettings? Index { get; set; }

		[JsonInclude]
		[JsonPropertyName("mode")]
		public string? Mode { get; set; }

		[JsonInclude]
		[JsonPropertyName("routing_path")]
		public IEnumerable<string>? RoutingPath { get; set; }

		[JsonInclude]
		[JsonPropertyName("soft_deletes")]
		public Elastic.Clients.Elasticsearch.IndexManagement.SoftDeletes? SoftDeletes { get; set; }

		[JsonInclude]
		[JsonPropertyName("sort")]
		public Elastic.Clients.Elasticsearch.IndexManagement.IndexSegmentSort? Sort { get; set; }

		[JsonInclude]
		[JsonPropertyName("number_of_shards")]
		public Union<int?, string?>? NumberOfShards { get; set; }

		[JsonInclude]
		[JsonPropertyName("number_of_replicas")]
		public Union<int?, string?>? NumberOfReplicas { get; set; }

		[JsonInclude]
		[JsonPropertyName("number_of_routing_shards")]
		public int? NumberOfRoutingShards { get; set; }

		[JsonInclude]
		[JsonPropertyName("check_on_startup")]
		public Elastic.Clients.Elasticsearch.IndexManagement.IndexCheckOnStartup? CheckOnStartup { get; set; }

		[JsonInclude]
		[JsonPropertyName("codec")]
		public string? Codec { get; set; }

		[JsonInclude]
		[JsonPropertyName("routing_partition_size")]
		public int? RoutingPartitionSize { get; set; }

		[JsonInclude]
		[JsonPropertyName("soft_deletes.retention_lease.period")]
		public Elastic.Clients.Elasticsearch.Time? SoftDeletesRetentionLeasePeriod { get; set; }

		[JsonInclude]
		[JsonPropertyName("load_fixed_bitset_filters_eagerly")]
		public bool? LoadFixedBitsetFiltersEagerly { get; set; }

		[JsonInclude]
		[JsonPropertyName("hidden")]
		public Union<bool?, string?>? Hidden { get; set; }

		[JsonInclude]
		[JsonPropertyName("auto_expand_replicas")]
		public string? AutoExpandReplicas { get; set; }

		[JsonInclude]
		[JsonPropertyName("merge.scheduler.max_thread_count")]
		public int? MergeSchedulerMaxThreadCount { get; set; }

		[JsonInclude]
		[JsonPropertyName("search.idle.after")]
		public Elastic.Clients.Elasticsearch.Time? SearchIdleAfter { get; set; }

		[JsonInclude]
		[JsonPropertyName("refresh_interval")]
		public Elastic.Clients.Elasticsearch.Time? RefreshInterval { get; set; }

		[JsonInclude]
		[JsonPropertyName("max_result_window")]
		public int? MaxResultWindow { get; set; }

		[JsonInclude]
		[JsonPropertyName("max_inner_result_window")]
		public int? MaxInnerResultWindow { get; set; }

		[JsonInclude]
		[JsonPropertyName("max_rescore_window")]
		public int? MaxRescoreWindow { get; set; }

		[JsonInclude]
		[JsonPropertyName("max_docvalue_fields_search")]
		public int? MaxDocvalueFieldsSearch { get; set; }

		[JsonInclude]
		[JsonPropertyName("max_script_fields")]
		public int? MaxScriptFields { get; set; }

		[JsonInclude]
		[JsonPropertyName("max_ngram_diff")]
		public int? MaxNgramDiff { get; set; }

		[JsonInclude]
		[JsonPropertyName("max_shingle_diff")]
		public int? MaxShingleDiff { get; set; }

		[JsonInclude]
		[JsonPropertyName("blocks")]
		public Elastic.Clients.Elasticsearch.IndexManagement.IndexSettingBlocks? Blocks { get; set; }

		[JsonInclude]
		[JsonPropertyName("blocks.read_only")]
		public bool? BlocksReadOnly { get; set; }

		[JsonInclude]
		[JsonPropertyName("blocks.read_only_allow_delete")]
		public bool? BlocksReadOnlyAllowDelete { get; set; }

		[JsonInclude]
		[JsonPropertyName("blocks.read")]
		public bool? BlocksRead { get; set; }

		[JsonInclude]
		[JsonPropertyName("blocks.write")]
		public Union<bool?, string?>? BlocksWrite { get; set; }

		[JsonInclude]
		[JsonPropertyName("blocks.metadata")]
		public bool? BlocksMetadata { get; set; }

		[JsonInclude]
		[JsonPropertyName("max_refresh_listeners")]
		public int? MaxRefreshListeners { get; set; }

		[JsonInclude]
		[JsonPropertyName("analyze.max_token_count")]
		public int? AnalyzeMaxTokenCount { get; set; }

		[JsonInclude]
		[JsonPropertyName("highlight.max_analyzed_offset")]
		public int? HighlightMaxAnalyzedOffset { get; set; }

		[JsonInclude]
		[JsonPropertyName("max_terms_count")]
		public int? MaxTermsCount { get; set; }

		[JsonInclude]
		[JsonPropertyName("max_regex_length")]
		public int? MaxRegexLength { get; set; }

		[JsonInclude]
		[JsonPropertyName("routing")]
		public Elastic.Clients.Elasticsearch.IndexManagement.IndexRouting? Routing { get; set; }

		[JsonInclude]
		[JsonPropertyName("gc_deletes")]
		public Elastic.Clients.Elasticsearch.Time? GcDeletes { get; set; }

		[JsonInclude]
		[JsonPropertyName("default_pipeline")]
		public string? DefaultPipeline { get; set; }

		[JsonInclude]
		[JsonPropertyName("final_pipeline")]
		public string? FinalPipeline { get; set; }

		[JsonInclude]
		[JsonPropertyName("lifecycle")]
		public Elastic.Clients.Elasticsearch.IndexManagement.IndexSettingsLifecycle? Lifecycle { get; set; }

		[JsonInclude]
		[JsonPropertyName("lifecycle.name")]
		public string? LifecycleName { get; set; }

		[JsonInclude]
		[JsonPropertyName("provided_name")]
		public Elastic.Clients.Elasticsearch.Name? ProvidedName { get; set; }

		[JsonInclude]
		[JsonPropertyName("creation_date")]
		public string? CreationDate { get; set; }

		[JsonInclude]
		[JsonPropertyName("uuid")]
		public string? Uuid { get; set; }

		[JsonInclude]
		[JsonPropertyName("version")]
		public Elastic.Clients.Elasticsearch.IndexManagement.IndexVersioning? Version { get; set; }

		[JsonInclude]
		[JsonPropertyName("verified_before_close")]
		public Union<bool?, string?>? VerifiedBeforeClose { get; set; }

		[JsonInclude]
		[JsonPropertyName("format")]
		public Union<string?, int?>? Format { get; set; }

		[JsonInclude]
		[JsonPropertyName("max_slices_per_scroll")]
		public int? MaxSlicesPerScroll { get; set; }

		[JsonInclude]
		[JsonPropertyName("translog.durability")]
		public string? TranslogDurability { get; set; }

		[JsonInclude]
		[JsonPropertyName("translog.flush_threshold_size")]
		public string? TranslogFlushThresholdSize { get; set; }

		[JsonInclude]
		[JsonPropertyName("query_string.lenient")]
		public Union<bool?, string?>? QueryStringLenient { get; set; }

		[JsonInclude]
		[JsonPropertyName("priority")]
		public Union<int?, string?>? Priority { get; set; }

		[JsonInclude]
		[JsonPropertyName("top_metrics_max_size")]
		public int? TopMetricsMaxSize { get; set; }

		[JsonInclude]
		[JsonPropertyName("analysis")]
		public Elastic.Clients.Elasticsearch.IndexManagement.IndexSettingsAnalysis? Analysis { get; set; }

		[JsonInclude]
		[JsonPropertyName("settings")]
		public Elastic.Clients.Elasticsearch.IndexManagement.IndexSettings? Settings { get; set; }
	}

	public sealed partial class IndexSettingsDescriptor<T> : DescriptorBase<IndexSettingsDescriptor<T>>
	{
		public IndexSettingsDescriptor()
		{
		}

		internal IndexSettingsDescriptor(Action<IndexSettingsDescriptor<T>> configure) => configure.Invoke(this);
		internal Elastic.Clients.Elasticsearch.IndexManagement.IndexSettings? IndexValue { get; private set; }

		internal string? ModeValue { get; private set; }

		internal IEnumerable<string>? RoutingPathValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.IndexManagement.SoftDeletes? SoftDeletesValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.IndexManagement.IndexSegmentSort? SortValue { get; private set; }

		internal Union<int?, string?>? NumberOfShardsValue { get; private set; }

		internal Union<int?, string?>? NumberOfReplicasValue { get; private set; }

		internal int? NumberOfRoutingShardsValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.IndexManagement.IndexCheckOnStartup? CheckOnStartupValue { get; private set; }

		internal string? CodecValue { get; private set; }

		internal int? RoutingPartitionSizeValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Time? SoftDeletesRetentionLeasePeriodValue { get; private set; }

		internal bool? LoadFixedBitsetFiltersEagerlyValue { get; private set; }

		internal Union<bool?, string?>? HiddenValue { get; private set; }

		internal string? AutoExpandReplicasValue { get; private set; }

		internal int? MergeSchedulerMaxThreadCountValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Time? SearchIdleAfterValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Time? RefreshIntervalValue { get; private set; }

		internal int? MaxResultWindowValue { get; private set; }

		internal int? MaxInnerResultWindowValue { get; private set; }

		internal int? MaxRescoreWindowValue { get; private set; }

		internal int? MaxDocvalueFieldsSearchValue { get; private set; }

		internal int? MaxScriptFieldsValue { get; private set; }

		internal int? MaxNgramDiffValue { get; private set; }

		internal int? MaxShingleDiffValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.IndexManagement.IndexSettingBlocks? BlocksValue { get; private set; }

		internal bool? BlocksReadOnlyValue { get; private set; }

		internal bool? BlocksReadOnlyAllowDeleteValue { get; private set; }

		internal bool? BlocksReadValue { get; private set; }

		internal Union<bool?, string?>? BlocksWriteValue { get; private set; }

		internal bool? BlocksMetadataValue { get; private set; }

		internal int? MaxRefreshListenersValue { get; private set; }

		internal int? AnalyzeMaxTokenCountValue { get; private set; }

		internal int? HighlightMaxAnalyzedOffsetValue { get; private set; }

		internal int? MaxTermsCountValue { get; private set; }

		internal int? MaxRegexLengthValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.IndexManagement.IndexRouting? RoutingValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Time? GcDeletesValue { get; private set; }

		internal string? DefaultPipelineValue { get; private set; }

		internal string? FinalPipelineValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.IndexManagement.IndexSettingsLifecycle? LifecycleValue { get; private set; }

		internal string? LifecycleNameValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Name? ProvidedNameValue { get; private set; }

		internal string? CreationDateValue { get; private set; }

		internal string? UuidValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.IndexManagement.IndexVersioning? VersionValue { get; private set; }

		internal Union<bool?, string?>? VerifiedBeforeCloseValue { get; private set; }

		internal Union<string?, int?>? FormatValue { get; private set; }

		internal int? MaxSlicesPerScrollValue { get; private set; }

		internal string? TranslogDurabilityValue { get; private set; }

		internal string? TranslogFlushThresholdSizeValue { get; private set; }

		internal Union<bool?, string?>? QueryStringLenientValue { get; private set; }

		internal Union<int?, string?>? PriorityValue { get; private set; }

		internal int? TopMetricsMaxSizeValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.IndexManagement.IndexSettingsAnalysis? AnalysisValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.IndexManagement.IndexSettings? SettingsValue { get; private set; }

		internal IndexSettingsDescriptor<T> IndexDescriptor { get; private set; }

		internal SoftDeletesDescriptor SoftDeletesDescriptor { get; private set; }

		internal IndexSegmentSortDescriptor<T> SortDescriptor { get; private set; }

		internal IndexSettingBlocksDescriptor BlocksDescriptor { get; private set; }

		internal IndexRoutingDescriptor RoutingDescriptor { get; private set; }

		internal IndexSettingsLifecycleDescriptor LifecycleDescriptor { get; private set; }

		internal IndexVersioningDescriptor VersionDescriptor { get; private set; }

		internal IndexSettingsAnalysisDescriptor AnalysisDescriptor { get; private set; }

		internal IndexSettingsDescriptor<T> SettingsDescriptor { get; private set; }

		internal Action<IndexSettingsDescriptor<T>> IndexDescriptorAction { get; private set; }

		internal Action<SoftDeletesDescriptor> SoftDeletesDescriptorAction { get; private set; }

		internal Action<IndexSegmentSortDescriptor<T>> SortDescriptorAction { get; private set; }

		internal Action<IndexSettingBlocksDescriptor> BlocksDescriptorAction { get; private set; }

		internal Action<IndexRoutingDescriptor> RoutingDescriptorAction { get; private set; }

		internal Action<IndexSettingsLifecycleDescriptor> LifecycleDescriptorAction { get; private set; }

		internal Action<IndexVersioningDescriptor> VersionDescriptorAction { get; private set; }

		internal Action<IndexSettingsAnalysisDescriptor> AnalysisDescriptorAction { get; private set; }

		internal Action<IndexSettingsDescriptor<T>> SettingsDescriptorAction { get; private set; }

		public IndexSettingsDescriptor<T> Index(Elastic.Clients.Elasticsearch.IndexManagement.IndexSettings? index)
		{
			IndexDescriptor = null;
			IndexDescriptorAction = null;
			return Assign(index, (a, v) => a.IndexValue = v);
		}

		public IndexSettingsDescriptor<T> Index(Elastic.Clients.Elasticsearch.IndexManagement.IndexSettingsDescriptor<T> descriptor)
		{
			IndexValue = null;
			IndexDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.IndexDescriptor = v);
		}

		public IndexSettingsDescriptor<T> Index(Action<Elastic.Clients.Elasticsearch.IndexManagement.IndexSettingsDescriptor<T>> configure)
		{
			IndexValue = null;
			IndexDescriptorAction = null;
			return Assign(configure, (a, v) => a.IndexDescriptorAction = v);
		}

		public IndexSettingsDescriptor<T> Mode(string? mode) => Assign(mode, (a, v) => a.ModeValue = v);
		public IndexSettingsDescriptor<T> RoutingPath(IEnumerable<string>? routingPath) => Assign(routingPath, (a, v) => a.RoutingPathValue = v);
		public IndexSettingsDescriptor<T> SoftDeletes(Elastic.Clients.Elasticsearch.IndexManagement.SoftDeletes? softDeletes)
		{
			SoftDeletesDescriptor = null;
			SoftDeletesDescriptorAction = null;
			return Assign(softDeletes, (a, v) => a.SoftDeletesValue = v);
		}

		public IndexSettingsDescriptor<T> SoftDeletes(Elastic.Clients.Elasticsearch.IndexManagement.SoftDeletesDescriptor descriptor)
		{
			SoftDeletesValue = null;
			SoftDeletesDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.SoftDeletesDescriptor = v);
		}

		public IndexSettingsDescriptor<T> SoftDeletes(Action<Elastic.Clients.Elasticsearch.IndexManagement.SoftDeletesDescriptor> configure)
		{
			SoftDeletesValue = null;
			SoftDeletesDescriptorAction = null;
			return Assign(configure, (a, v) => a.SoftDeletesDescriptorAction = v);
		}

		public IndexSettingsDescriptor<T> Sort(Elastic.Clients.Elasticsearch.IndexManagement.IndexSegmentSort? sort)
		{
			SortDescriptor = null;
			SortDescriptorAction = null;
			return Assign(sort, (a, v) => a.SortValue = v);
		}

		public IndexSettingsDescriptor<T> Sort(Elastic.Clients.Elasticsearch.IndexManagement.IndexSegmentSortDescriptor<T> descriptor)
		{
			SortValue = null;
			SortDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.SortDescriptor = v);
		}

		public IndexSettingsDescriptor<T> Sort(Action<Elastic.Clients.Elasticsearch.IndexManagement.IndexSegmentSortDescriptor<T>> configure)
		{
			SortValue = null;
			SortDescriptorAction = null;
			return Assign(configure, (a, v) => a.SortDescriptorAction = v);
		}

		public IndexSettingsDescriptor<T> NumberOfShards(Union<int?, string?>? numberOfShards) => Assign(numberOfShards, (a, v) => a.NumberOfShardsValue = v);
		public IndexSettingsDescriptor<T> NumberOfReplicas(Union<int?, string?>? numberOfReplicas) => Assign(numberOfReplicas, (a, v) => a.NumberOfReplicasValue = v);
		public IndexSettingsDescriptor<T> NumberOfRoutingShards(int? numberOfRoutingShards) => Assign(numberOfRoutingShards, (a, v) => a.NumberOfRoutingShardsValue = v);
		public IndexSettingsDescriptor<T> CheckOnStartup(Elastic.Clients.Elasticsearch.IndexManagement.IndexCheckOnStartup? checkOnStartup) => Assign(checkOnStartup, (a, v) => a.CheckOnStartupValue = v);
		public IndexSettingsDescriptor<T> Codec(string? codec) => Assign(codec, (a, v) => a.CodecValue = v);
		public IndexSettingsDescriptor<T> RoutingPartitionSize(int? routingPartitionSize) => Assign(routingPartitionSize, (a, v) => a.RoutingPartitionSizeValue = v);
		public IndexSettingsDescriptor<T> SoftDeletesRetentionLeasePeriod(Elastic.Clients.Elasticsearch.Time? softDeletesRetentionLeasePeriod) => Assign(softDeletesRetentionLeasePeriod, (a, v) => a.SoftDeletesRetentionLeasePeriodValue = v);
		public IndexSettingsDescriptor<T> LoadFixedBitsetFiltersEagerly(bool? loadFixedBitsetFiltersEagerly = true) => Assign(loadFixedBitsetFiltersEagerly, (a, v) => a.LoadFixedBitsetFiltersEagerlyValue = v);
		public IndexSettingsDescriptor<T> Hidden(Union<bool?, string?>? hidden) => Assign(hidden, (a, v) => a.HiddenValue = v);
		public IndexSettingsDescriptor<T> AutoExpandReplicas(string? autoExpandReplicas) => Assign(autoExpandReplicas, (a, v) => a.AutoExpandReplicasValue = v);
		public IndexSettingsDescriptor<T> MergeSchedulerMaxThreadCount(int? mergeSchedulerMaxThreadCount) => Assign(mergeSchedulerMaxThreadCount, (a, v) => a.MergeSchedulerMaxThreadCountValue = v);
		public IndexSettingsDescriptor<T> SearchIdleAfter(Elastic.Clients.Elasticsearch.Time? searchIdleAfter) => Assign(searchIdleAfter, (a, v) => a.SearchIdleAfterValue = v);
		public IndexSettingsDescriptor<T> RefreshInterval(Elastic.Clients.Elasticsearch.Time? refreshInterval) => Assign(refreshInterval, (a, v) => a.RefreshIntervalValue = v);
		public IndexSettingsDescriptor<T> MaxResultWindow(int? maxResultWindow) => Assign(maxResultWindow, (a, v) => a.MaxResultWindowValue = v);
		public IndexSettingsDescriptor<T> MaxInnerResultWindow(int? maxInnerResultWindow) => Assign(maxInnerResultWindow, (a, v) => a.MaxInnerResultWindowValue = v);
		public IndexSettingsDescriptor<T> MaxRescoreWindow(int? maxRescoreWindow) => Assign(maxRescoreWindow, (a, v) => a.MaxRescoreWindowValue = v);
		public IndexSettingsDescriptor<T> MaxDocvalueFieldsSearch(int? maxDocvalueFieldsSearch) => Assign(maxDocvalueFieldsSearch, (a, v) => a.MaxDocvalueFieldsSearchValue = v);
		public IndexSettingsDescriptor<T> MaxScriptFields(int? maxScriptFields) => Assign(maxScriptFields, (a, v) => a.MaxScriptFieldsValue = v);
		public IndexSettingsDescriptor<T> MaxNgramDiff(int? maxNgramDiff) => Assign(maxNgramDiff, (a, v) => a.MaxNgramDiffValue = v);
		public IndexSettingsDescriptor<T> MaxShingleDiff(int? maxShingleDiff) => Assign(maxShingleDiff, (a, v) => a.MaxShingleDiffValue = v);
		public IndexSettingsDescriptor<T> Blocks(Elastic.Clients.Elasticsearch.IndexManagement.IndexSettingBlocks? blocks)
		{
			BlocksDescriptor = null;
			BlocksDescriptorAction = null;
			return Assign(blocks, (a, v) => a.BlocksValue = v);
		}

		public IndexSettingsDescriptor<T> Blocks(Elastic.Clients.Elasticsearch.IndexManagement.IndexSettingBlocksDescriptor descriptor)
		{
			BlocksValue = null;
			BlocksDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.BlocksDescriptor = v);
		}

		public IndexSettingsDescriptor<T> Blocks(Action<Elastic.Clients.Elasticsearch.IndexManagement.IndexSettingBlocksDescriptor> configure)
		{
			BlocksValue = null;
			BlocksDescriptorAction = null;
			return Assign(configure, (a, v) => a.BlocksDescriptorAction = v);
		}

		public IndexSettingsDescriptor<T> BlocksReadOnly(bool? blocksReadOnly = true) => Assign(blocksReadOnly, (a, v) => a.BlocksReadOnlyValue = v);
		public IndexSettingsDescriptor<T> BlocksReadOnlyAllowDelete(bool? blocksReadOnlyAllowDelete = true) => Assign(blocksReadOnlyAllowDelete, (a, v) => a.BlocksReadOnlyAllowDeleteValue = v);
		public IndexSettingsDescriptor<T> BlocksRead(bool? blocksRead = true) => Assign(blocksRead, (a, v) => a.BlocksReadValue = v);
		public IndexSettingsDescriptor<T> BlocksWrite(Union<bool?, string?>? blocksWrite) => Assign(blocksWrite, (a, v) => a.BlocksWriteValue = v);
		public IndexSettingsDescriptor<T> BlocksMetadata(bool? blocksMetadata = true) => Assign(blocksMetadata, (a, v) => a.BlocksMetadataValue = v);
		public IndexSettingsDescriptor<T> MaxRefreshListeners(int? maxRefreshListeners) => Assign(maxRefreshListeners, (a, v) => a.MaxRefreshListenersValue = v);
		public IndexSettingsDescriptor<T> AnalyzeMaxTokenCount(int? analyzeMaxTokenCount) => Assign(analyzeMaxTokenCount, (a, v) => a.AnalyzeMaxTokenCountValue = v);
		public IndexSettingsDescriptor<T> HighlightMaxAnalyzedOffset(int? highlightMaxAnalyzedOffset) => Assign(highlightMaxAnalyzedOffset, (a, v) => a.HighlightMaxAnalyzedOffsetValue = v);
		public IndexSettingsDescriptor<T> MaxTermsCount(int? maxTermsCount) => Assign(maxTermsCount, (a, v) => a.MaxTermsCountValue = v);
		public IndexSettingsDescriptor<T> MaxRegexLength(int? maxRegexLength) => Assign(maxRegexLength, (a, v) => a.MaxRegexLengthValue = v);
		public IndexSettingsDescriptor<T> Routing(Elastic.Clients.Elasticsearch.IndexManagement.IndexRouting? routing)
		{
			RoutingDescriptor = null;
			RoutingDescriptorAction = null;
			return Assign(routing, (a, v) => a.RoutingValue = v);
		}

		public IndexSettingsDescriptor<T> Routing(Elastic.Clients.Elasticsearch.IndexManagement.IndexRoutingDescriptor descriptor)
		{
			RoutingValue = null;
			RoutingDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.RoutingDescriptor = v);
		}

		public IndexSettingsDescriptor<T> Routing(Action<Elastic.Clients.Elasticsearch.IndexManagement.IndexRoutingDescriptor> configure)
		{
			RoutingValue = null;
			RoutingDescriptorAction = null;
			return Assign(configure, (a, v) => a.RoutingDescriptorAction = v);
		}

		public IndexSettingsDescriptor<T> GcDeletes(Elastic.Clients.Elasticsearch.Time? gcDeletes) => Assign(gcDeletes, (a, v) => a.GcDeletesValue = v);
		public IndexSettingsDescriptor<T> DefaultPipeline(string? defaultPipeline) => Assign(defaultPipeline, (a, v) => a.DefaultPipelineValue = v);
		public IndexSettingsDescriptor<T> FinalPipeline(string? finalPipeline) => Assign(finalPipeline, (a, v) => a.FinalPipelineValue = v);
		public IndexSettingsDescriptor<T> Lifecycle(Elastic.Clients.Elasticsearch.IndexManagement.IndexSettingsLifecycle? lifecycle)
		{
			LifecycleDescriptor = null;
			LifecycleDescriptorAction = null;
			return Assign(lifecycle, (a, v) => a.LifecycleValue = v);
		}

		public IndexSettingsDescriptor<T> Lifecycle(Elastic.Clients.Elasticsearch.IndexManagement.IndexSettingsLifecycleDescriptor descriptor)
		{
			LifecycleValue = null;
			LifecycleDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.LifecycleDescriptor = v);
		}

		public IndexSettingsDescriptor<T> Lifecycle(Action<Elastic.Clients.Elasticsearch.IndexManagement.IndexSettingsLifecycleDescriptor> configure)
		{
			LifecycleValue = null;
			LifecycleDescriptorAction = null;
			return Assign(configure, (a, v) => a.LifecycleDescriptorAction = v);
		}

		public IndexSettingsDescriptor<T> LifecycleName(string? lifecycleName) => Assign(lifecycleName, (a, v) => a.LifecycleNameValue = v);
		public IndexSettingsDescriptor<T> ProvidedName(Elastic.Clients.Elasticsearch.Name? providedName) => Assign(providedName, (a, v) => a.ProvidedNameValue = v);
		public IndexSettingsDescriptor<T> CreationDate(string? creationDate) => Assign(creationDate, (a, v) => a.CreationDateValue = v);
		public IndexSettingsDescriptor<T> Uuid(string? uuid) => Assign(uuid, (a, v) => a.UuidValue = v);
		public IndexSettingsDescriptor<T> Version(Elastic.Clients.Elasticsearch.IndexManagement.IndexVersioning? version)
		{
			VersionDescriptor = null;
			VersionDescriptorAction = null;
			return Assign(version, (a, v) => a.VersionValue = v);
		}

		public IndexSettingsDescriptor<T> Version(Elastic.Clients.Elasticsearch.IndexManagement.IndexVersioningDescriptor descriptor)
		{
			VersionValue = null;
			VersionDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.VersionDescriptor = v);
		}

		public IndexSettingsDescriptor<T> Version(Action<Elastic.Clients.Elasticsearch.IndexManagement.IndexVersioningDescriptor> configure)
		{
			VersionValue = null;
			VersionDescriptorAction = null;
			return Assign(configure, (a, v) => a.VersionDescriptorAction = v);
		}

		public IndexSettingsDescriptor<T> VerifiedBeforeClose(Union<bool?, string?>? verifiedBeforeClose) => Assign(verifiedBeforeClose, (a, v) => a.VerifiedBeforeCloseValue = v);
		public IndexSettingsDescriptor<T> Format(Union<string?, int?>? format) => Assign(format, (a, v) => a.FormatValue = v);
		public IndexSettingsDescriptor<T> MaxSlicesPerScroll(int? maxSlicesPerScroll) => Assign(maxSlicesPerScroll, (a, v) => a.MaxSlicesPerScrollValue = v);
		public IndexSettingsDescriptor<T> TranslogDurability(string? translogDurability) => Assign(translogDurability, (a, v) => a.TranslogDurabilityValue = v);
		public IndexSettingsDescriptor<T> TranslogFlushThresholdSize(string? translogFlushThresholdSize) => Assign(translogFlushThresholdSize, (a, v) => a.TranslogFlushThresholdSizeValue = v);
		public IndexSettingsDescriptor<T> QueryStringLenient(Union<bool?, string?>? queryStringLenient) => Assign(queryStringLenient, (a, v) => a.QueryStringLenientValue = v);
		public IndexSettingsDescriptor<T> Priority(Union<int?, string?>? priority) => Assign(priority, (a, v) => a.PriorityValue = v);
		public IndexSettingsDescriptor<T> TopMetricsMaxSize(int? topMetricsMaxSize) => Assign(topMetricsMaxSize, (a, v) => a.TopMetricsMaxSizeValue = v);
		public IndexSettingsDescriptor<T> Analysis(Elastic.Clients.Elasticsearch.IndexManagement.IndexSettingsAnalysis? analysis)
		{
			AnalysisDescriptor = null;
			AnalysisDescriptorAction = null;
			return Assign(analysis, (a, v) => a.AnalysisValue = v);
		}

		public IndexSettingsDescriptor<T> Analysis(Elastic.Clients.Elasticsearch.IndexManagement.IndexSettingsAnalysisDescriptor descriptor)
		{
			AnalysisValue = null;
			AnalysisDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.AnalysisDescriptor = v);
		}

		public IndexSettingsDescriptor<T> Analysis(Action<Elastic.Clients.Elasticsearch.IndexManagement.IndexSettingsAnalysisDescriptor> configure)
		{
			AnalysisValue = null;
			AnalysisDescriptorAction = null;
			return Assign(configure, (a, v) => a.AnalysisDescriptorAction = v);
		}

		public IndexSettingsDescriptor<T> Settings(Elastic.Clients.Elasticsearch.IndexManagement.IndexSettings? settings)
		{
			SettingsDescriptor = null;
			SettingsDescriptorAction = null;
			return Assign(settings, (a, v) => a.SettingsValue = v);
		}

		public IndexSettingsDescriptor<T> Settings(Elastic.Clients.Elasticsearch.IndexManagement.IndexSettingsDescriptor<T> descriptor)
		{
			SettingsValue = null;
			SettingsDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.SettingsDescriptor = v);
		}

		public IndexSettingsDescriptor<T> Settings(Action<Elastic.Clients.Elasticsearch.IndexManagement.IndexSettingsDescriptor<T>> configure)
		{
			SettingsValue = null;
			SettingsDescriptorAction = null;
			return Assign(configure, (a, v) => a.SettingsDescriptorAction = v);
		}

		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (IndexDescriptor is not null)
			{
				writer.WritePropertyName("index");
				JsonSerializer.Serialize(writer, IndexDescriptor, options);
			}
			else if (IndexDescriptorAction is not null)
			{
				writer.WritePropertyName("index");
				JsonSerializer.Serialize(writer, new IndexSettingsDescriptor<T>(IndexDescriptorAction), options);
			}
			else if (IndexValue is not null)
			{
				writer.WritePropertyName("index");
				JsonSerializer.Serialize(writer, IndexValue, options);
			}

			if (!string.IsNullOrEmpty(ModeValue))
			{
				writer.WritePropertyName("mode");
				writer.WriteStringValue(ModeValue);
			}

			if (RoutingPathValue is not null)
			{
				writer.WritePropertyName("routing_path");
				JsonSerializer.Serialize(writer, RoutingPathValue, options);
			}

			if (SoftDeletesDescriptor is not null)
			{
				writer.WritePropertyName("soft_deletes");
				JsonSerializer.Serialize(writer, SoftDeletesDescriptor, options);
			}
			else if (SoftDeletesDescriptorAction is not null)
			{
				writer.WritePropertyName("soft_deletes");
				JsonSerializer.Serialize(writer, new SoftDeletesDescriptor(SoftDeletesDescriptorAction), options);
			}
			else if (SoftDeletesValue is not null)
			{
				writer.WritePropertyName("soft_deletes");
				JsonSerializer.Serialize(writer, SoftDeletesValue, options);
			}

			if (SortDescriptor is not null)
			{
				writer.WritePropertyName("sort");
				JsonSerializer.Serialize(writer, SortDescriptor, options);
			}
			else if (SortDescriptorAction is not null)
			{
				writer.WritePropertyName("sort");
				JsonSerializer.Serialize(writer, new IndexSegmentSortDescriptor<T>(SortDescriptorAction), options);
			}
			else if (SortValue is not null)
			{
				writer.WritePropertyName("sort");
				JsonSerializer.Serialize(writer, SortValue, options);
			}

			if (NumberOfShardsValue is not null)
			{
				writer.WritePropertyName("number_of_shards");
				JsonSerializer.Serialize(writer, NumberOfShardsValue, options);
			}

			if (NumberOfReplicasValue is not null)
			{
				writer.WritePropertyName("number_of_replicas");
				JsonSerializer.Serialize(writer, NumberOfReplicasValue, options);
			}

			if (NumberOfRoutingShardsValue.HasValue)
			{
				writer.WritePropertyName("number_of_routing_shards");
				writer.WriteNumberValue(NumberOfRoutingShardsValue.Value);
			}

			if (CheckOnStartupValue is not null)
			{
				writer.WritePropertyName("check_on_startup");
				JsonSerializer.Serialize(writer, CheckOnStartupValue, options);
			}

			if (!string.IsNullOrEmpty(CodecValue))
			{
				writer.WritePropertyName("codec");
				writer.WriteStringValue(CodecValue);
			}

			if (RoutingPartitionSizeValue.HasValue)
			{
				writer.WritePropertyName("routing_partition_size");
				writer.WriteNumberValue(RoutingPartitionSizeValue.Value);
			}

			if (SoftDeletesRetentionLeasePeriodValue is not null)
			{
				writer.WritePropertyName("soft_deletes.retention_lease.period");
				JsonSerializer.Serialize(writer, SoftDeletesRetentionLeasePeriodValue, options);
			}

			if (LoadFixedBitsetFiltersEagerlyValue.HasValue)
			{
				writer.WritePropertyName("load_fixed_bitset_filters_eagerly");
				writer.WriteBooleanValue(LoadFixedBitsetFiltersEagerlyValue.Value);
			}

			if (HiddenValue is not null)
			{
				writer.WritePropertyName("hidden");
				JsonSerializer.Serialize(writer, HiddenValue, options);
			}

			if (!string.IsNullOrEmpty(AutoExpandReplicasValue))
			{
				writer.WritePropertyName("auto_expand_replicas");
				writer.WriteStringValue(AutoExpandReplicasValue);
			}

			if (MergeSchedulerMaxThreadCountValue.HasValue)
			{
				writer.WritePropertyName("merge.scheduler.max_thread_count");
				writer.WriteNumberValue(MergeSchedulerMaxThreadCountValue.Value);
			}

			if (SearchIdleAfterValue is not null)
			{
				writer.WritePropertyName("search.idle.after");
				JsonSerializer.Serialize(writer, SearchIdleAfterValue, options);
			}

			if (RefreshIntervalValue is not null)
			{
				writer.WritePropertyName("refresh_interval");
				JsonSerializer.Serialize(writer, RefreshIntervalValue, options);
			}

			if (MaxResultWindowValue.HasValue)
			{
				writer.WritePropertyName("max_result_window");
				writer.WriteNumberValue(MaxResultWindowValue.Value);
			}

			if (MaxInnerResultWindowValue.HasValue)
			{
				writer.WritePropertyName("max_inner_result_window");
				writer.WriteNumberValue(MaxInnerResultWindowValue.Value);
			}

			if (MaxRescoreWindowValue.HasValue)
			{
				writer.WritePropertyName("max_rescore_window");
				writer.WriteNumberValue(MaxRescoreWindowValue.Value);
			}

			if (MaxDocvalueFieldsSearchValue.HasValue)
			{
				writer.WritePropertyName("max_docvalue_fields_search");
				writer.WriteNumberValue(MaxDocvalueFieldsSearchValue.Value);
			}

			if (MaxScriptFieldsValue.HasValue)
			{
				writer.WritePropertyName("max_script_fields");
				writer.WriteNumberValue(MaxScriptFieldsValue.Value);
			}

			if (MaxNgramDiffValue.HasValue)
			{
				writer.WritePropertyName("max_ngram_diff");
				writer.WriteNumberValue(MaxNgramDiffValue.Value);
			}

			if (MaxShingleDiffValue.HasValue)
			{
				writer.WritePropertyName("max_shingle_diff");
				writer.WriteNumberValue(MaxShingleDiffValue.Value);
			}

			if (BlocksDescriptor is not null)
			{
				writer.WritePropertyName("blocks");
				JsonSerializer.Serialize(writer, BlocksDescriptor, options);
			}
			else if (BlocksDescriptorAction is not null)
			{
				writer.WritePropertyName("blocks");
				JsonSerializer.Serialize(writer, new IndexSettingBlocksDescriptor(BlocksDescriptorAction), options);
			}
			else if (BlocksValue is not null)
			{
				writer.WritePropertyName("blocks");
				JsonSerializer.Serialize(writer, BlocksValue, options);
			}

			if (BlocksReadOnlyValue.HasValue)
			{
				writer.WritePropertyName("blocks.read_only");
				writer.WriteBooleanValue(BlocksReadOnlyValue.Value);
			}

			if (BlocksReadOnlyAllowDeleteValue.HasValue)
			{
				writer.WritePropertyName("blocks.read_only_allow_delete");
				writer.WriteBooleanValue(BlocksReadOnlyAllowDeleteValue.Value);
			}

			if (BlocksReadValue.HasValue)
			{
				writer.WritePropertyName("blocks.read");
				writer.WriteBooleanValue(BlocksReadValue.Value);
			}

			if (BlocksWriteValue is not null)
			{
				writer.WritePropertyName("blocks.write");
				JsonSerializer.Serialize(writer, BlocksWriteValue, options);
			}

			if (BlocksMetadataValue.HasValue)
			{
				writer.WritePropertyName("blocks.metadata");
				writer.WriteBooleanValue(BlocksMetadataValue.Value);
			}

			if (MaxRefreshListenersValue.HasValue)
			{
				writer.WritePropertyName("max_refresh_listeners");
				writer.WriteNumberValue(MaxRefreshListenersValue.Value);
			}

			if (AnalyzeMaxTokenCountValue.HasValue)
			{
				writer.WritePropertyName("analyze.max_token_count");
				writer.WriteNumberValue(AnalyzeMaxTokenCountValue.Value);
			}

			if (HighlightMaxAnalyzedOffsetValue.HasValue)
			{
				writer.WritePropertyName("highlight.max_analyzed_offset");
				writer.WriteNumberValue(HighlightMaxAnalyzedOffsetValue.Value);
			}

			if (MaxTermsCountValue.HasValue)
			{
				writer.WritePropertyName("max_terms_count");
				writer.WriteNumberValue(MaxTermsCountValue.Value);
			}

			if (MaxRegexLengthValue.HasValue)
			{
				writer.WritePropertyName("max_regex_length");
				writer.WriteNumberValue(MaxRegexLengthValue.Value);
			}

			if (RoutingDescriptor is not null)
			{
				writer.WritePropertyName("routing");
				JsonSerializer.Serialize(writer, RoutingDescriptor, options);
			}
			else if (RoutingDescriptorAction is not null)
			{
				writer.WritePropertyName("routing");
				JsonSerializer.Serialize(writer, new IndexRoutingDescriptor(RoutingDescriptorAction), options);
			}
			else if (RoutingValue is not null)
			{
				writer.WritePropertyName("routing");
				JsonSerializer.Serialize(writer, RoutingValue, options);
			}

			if (GcDeletesValue is not null)
			{
				writer.WritePropertyName("gc_deletes");
				JsonSerializer.Serialize(writer, GcDeletesValue, options);
			}

			if (DefaultPipelineValue is not null)
			{
				writer.WritePropertyName("default_pipeline");
				JsonSerializer.Serialize(writer, DefaultPipelineValue, options);
			}

			if (FinalPipelineValue is not null)
			{
				writer.WritePropertyName("final_pipeline");
				JsonSerializer.Serialize(writer, FinalPipelineValue, options);
			}

			if (LifecycleDescriptor is not null)
			{
				writer.WritePropertyName("lifecycle");
				JsonSerializer.Serialize(writer, LifecycleDescriptor, options);
			}
			else if (LifecycleDescriptorAction is not null)
			{
				writer.WritePropertyName("lifecycle");
				JsonSerializer.Serialize(writer, new IndexSettingsLifecycleDescriptor(LifecycleDescriptorAction), options);
			}
			else if (LifecycleValue is not null)
			{
				writer.WritePropertyName("lifecycle");
				JsonSerializer.Serialize(writer, LifecycleValue, options);
			}

			if (!string.IsNullOrEmpty(LifecycleNameValue))
			{
				writer.WritePropertyName("lifecycle.name");
				writer.WriteStringValue(LifecycleNameValue);
			}

			if (ProvidedNameValue is not null)
			{
				writer.WritePropertyName("provided_name");
				JsonSerializer.Serialize(writer, ProvidedNameValue, options);
			}

			if (CreationDateValue is not null)
			{
				writer.WritePropertyName("creation_date");
				JsonSerializer.Serialize(writer, CreationDateValue, options);
			}

			if (UuidValue is not null)
			{
				writer.WritePropertyName("uuid");
				JsonSerializer.Serialize(writer, UuidValue, options);
			}

			if (VersionDescriptor is not null)
			{
				writer.WritePropertyName("version");
				JsonSerializer.Serialize(writer, VersionDescriptor, options);
			}
			else if (VersionDescriptorAction is not null)
			{
				writer.WritePropertyName("version");
				JsonSerializer.Serialize(writer, new IndexVersioningDescriptor(VersionDescriptorAction), options);
			}
			else if (VersionValue is not null)
			{
				writer.WritePropertyName("version");
				JsonSerializer.Serialize(writer, VersionValue, options);
			}

			if (VerifiedBeforeCloseValue is not null)
			{
				writer.WritePropertyName("verified_before_close");
				JsonSerializer.Serialize(writer, VerifiedBeforeCloseValue, options);
			}

			if (FormatValue is not null)
			{
				writer.WritePropertyName("format");
				JsonSerializer.Serialize(writer, FormatValue, options);
			}

			if (MaxSlicesPerScrollValue.HasValue)
			{
				writer.WritePropertyName("max_slices_per_scroll");
				writer.WriteNumberValue(MaxSlicesPerScrollValue.Value);
			}

			if (!string.IsNullOrEmpty(TranslogDurabilityValue))
			{
				writer.WritePropertyName("translog.durability");
				writer.WriteStringValue(TranslogDurabilityValue);
			}

			if (!string.IsNullOrEmpty(TranslogFlushThresholdSizeValue))
			{
				writer.WritePropertyName("translog.flush_threshold_size");
				writer.WriteStringValue(TranslogFlushThresholdSizeValue);
			}

			if (QueryStringLenientValue is not null)
			{
				writer.WritePropertyName("query_string.lenient");
				JsonSerializer.Serialize(writer, QueryStringLenientValue, options);
			}

			if (PriorityValue is not null)
			{
				writer.WritePropertyName("priority");
				JsonSerializer.Serialize(writer, PriorityValue, options);
			}

			if (TopMetricsMaxSizeValue.HasValue)
			{
				writer.WritePropertyName("top_metrics_max_size");
				writer.WriteNumberValue(TopMetricsMaxSizeValue.Value);
			}

			if (AnalysisDescriptor is not null)
			{
				writer.WritePropertyName("analysis");
				JsonSerializer.Serialize(writer, AnalysisDescriptor, options);
			}
			else if (AnalysisDescriptorAction is not null)
			{
				writer.WritePropertyName("analysis");
				JsonSerializer.Serialize(writer, new IndexSettingsAnalysisDescriptor(AnalysisDescriptorAction), options);
			}
			else if (AnalysisValue is not null)
			{
				writer.WritePropertyName("analysis");
				JsonSerializer.Serialize(writer, AnalysisValue, options);
			}

			if (SettingsDescriptor is not null)
			{
				writer.WritePropertyName("settings");
				JsonSerializer.Serialize(writer, SettingsDescriptor, options);
			}
			else if (SettingsDescriptorAction is not null)
			{
				writer.WritePropertyName("settings");
				JsonSerializer.Serialize(writer, new IndexSettingsDescriptor<T>(SettingsDescriptorAction), options);
			}
			else if (SettingsValue is not null)
			{
				writer.WritePropertyName("settings");
				JsonSerializer.Serialize(writer, SettingsValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class IndexSettingsAnalysis
	{
		[JsonInclude]
		[JsonPropertyName("analyzer")]
		public Elastic.Clients.Elasticsearch.Analysis.Analyzers? Analyzer { get; set; }

		[JsonInclude]
		[JsonPropertyName("char_filter")]
		public Dictionary<string, Elastic.Clients.Elasticsearch.Analysis.CharFilter>? CharFilter { get; set; }

		[JsonInclude]
		[JsonPropertyName("filter")]
		public Dictionary<string, Elastic.Clients.Elasticsearch.Analysis.TokenFilter>? Filter { get; set; }

		[JsonInclude]
		[JsonPropertyName("normalizer")]
		public Elastic.Clients.Elasticsearch.Analysis.Normalizers? Normalizer { get; set; }

		[JsonInclude]
		[JsonPropertyName("tokenizer")]
		public Dictionary<string, Elastic.Clients.Elasticsearch.Analysis.Tokenizer>? Tokenizer { get; set; }
	}

	public sealed partial class IndexSettingsAnalysisDescriptor : DescriptorBase<IndexSettingsAnalysisDescriptor>
	{
		public IndexSettingsAnalysisDescriptor()
		{
		}

		internal IndexSettingsAnalysisDescriptor(Action<IndexSettingsAnalysisDescriptor> configure) => configure.Invoke(this);
		internal Elastic.Clients.Elasticsearch.Analysis.Analyzers? AnalyzerValue { get; private set; }

		internal Dictionary<string, Elastic.Clients.Elasticsearch.Analysis.CharFilter>? CharFilterValue { get; private set; }

		internal Dictionary<string, Elastic.Clients.Elasticsearch.Analysis.TokenFilter>? FilterValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Analysis.Normalizers? NormalizerValue { get; private set; }

		internal Dictionary<string, Elastic.Clients.Elasticsearch.Analysis.Tokenizer>? TokenizerValue { get; private set; }

		public IndexSettingsAnalysisDescriptor Analyzer(Elastic.Clients.Elasticsearch.Analysis.Analyzers? analyzer) => Assign(analyzer, (a, v) => a.AnalyzerValue = v);
		public IndexSettingsAnalysisDescriptor CharFilter(Func<FluentDictionary<string?, Elastic.Clients.Elasticsearch.Analysis.CharFilter?>, FluentDictionary<string?, Elastic.Clients.Elasticsearch.Analysis.CharFilter?>> selector) => Assign(selector, (a, v) => a.CharFilterValue = v?.Invoke(new FluentDictionary<string?, Elastic.Clients.Elasticsearch.Analysis.CharFilter?>()));
		public IndexSettingsAnalysisDescriptor Filter(Func<FluentDictionary<string?, Elastic.Clients.Elasticsearch.Analysis.TokenFilter?>, FluentDictionary<string?, Elastic.Clients.Elasticsearch.Analysis.TokenFilter?>> selector) => Assign(selector, (a, v) => a.FilterValue = v?.Invoke(new FluentDictionary<string?, Elastic.Clients.Elasticsearch.Analysis.TokenFilter?>()));
		public IndexSettingsAnalysisDescriptor Normalizer(Elastic.Clients.Elasticsearch.Analysis.Normalizers? normalizer) => Assign(normalizer, (a, v) => a.NormalizerValue = v);
		public IndexSettingsAnalysisDescriptor Tokenizer(Func<FluentDictionary<string?, Elastic.Clients.Elasticsearch.Analysis.Tokenizer?>, FluentDictionary<string?, Elastic.Clients.Elasticsearch.Analysis.Tokenizer?>> selector) => Assign(selector, (a, v) => a.TokenizerValue = v?.Invoke(new FluentDictionary<string?, Elastic.Clients.Elasticsearch.Analysis.Tokenizer?>()));
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (AnalyzerValue is not null)
			{
				writer.WritePropertyName("analyzer");
				JsonSerializer.Serialize(writer, AnalyzerValue, options);
			}

			if (CharFilterValue is not null)
			{
				writer.WritePropertyName("char_filter");
				JsonSerializer.Serialize(writer, CharFilterValue, options);
			}

			if (FilterValue is not null)
			{
				writer.WritePropertyName("filter");
				JsonSerializer.Serialize(writer, FilterValue, options);
			}

			if (NormalizerValue is not null)
			{
				writer.WritePropertyName("normalizer");
				JsonSerializer.Serialize(writer, NormalizerValue, options);
			}

			if (TokenizerValue is not null)
			{
				writer.WritePropertyName("tokenizer");
				JsonSerializer.Serialize(writer, TokenizerValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class IndexSettingsLifecycle
	{
		[JsonInclude]
		[JsonPropertyName("name")]
		public Elastic.Clients.Elasticsearch.Name Name { get; set; }
	}

	public sealed partial class IndexSettingsLifecycleDescriptor : DescriptorBase<IndexSettingsLifecycleDescriptor>
	{
		public IndexSettingsLifecycleDescriptor()
		{
		}

		internal IndexSettingsLifecycleDescriptor(Action<IndexSettingsLifecycleDescriptor> configure) => configure.Invoke(this);
		internal Elastic.Clients.Elasticsearch.Name NameValue { get; private set; }

		public IndexSettingsLifecycleDescriptor Name(Elastic.Clients.Elasticsearch.Name name) => Assign(name, (a, v) => a.NameValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("name");
			JsonSerializer.Serialize(writer, NameValue, options);
			writer.WriteEndObject();
		}
	}

	public partial class IndexState
	{
		[JsonInclude]
		[JsonPropertyName("aliases")]
		public Dictionary<Elastic.Clients.Elasticsearch.IndexName, Elastic.Clients.Elasticsearch.IndexManagement.Alias>? Aliases { get; set; }

		[JsonInclude]
		[JsonPropertyName("mappings")]
		public Elastic.Clients.Elasticsearch.Mapping.TypeMapping? Mappings { get; set; }

		[JsonInclude]
		[JsonPropertyName("settings")]
		public Elastic.Clients.Elasticsearch.IndexManagement.IndexSettings? Settings { get; set; }

		[JsonInclude]
		[JsonPropertyName("data_stream")]
		public Elastic.Clients.Elasticsearch.DataStreamName? DataStream { get; set; }
	}

	public sealed partial class IndexStateDescriptor<T> : DescriptorBase<IndexStateDescriptor<T>>
	{
		public IndexStateDescriptor()
		{
		}

		internal IndexStateDescriptor(Action<IndexStateDescriptor<T>> configure) => configure.Invoke(this);
		internal Dictionary<Elastic.Clients.Elasticsearch.IndexName, Elastic.Clients.Elasticsearch.IndexManagement.Alias>? AliasesValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Mapping.TypeMapping? MappingsValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.IndexManagement.IndexSettings? SettingsValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.DataStreamName? DataStreamValue { get; private set; }

		internal Mapping.TypeMappingDescriptor MappingsDescriptor { get; private set; }

		internal IndexSettingsDescriptor<T> SettingsDescriptor { get; private set; }

		internal Action<Mapping.TypeMappingDescriptor> MappingsDescriptorAction { get; private set; }

		internal Action<IndexSettingsDescriptor<T>> SettingsDescriptorAction { get; private set; }

		public IndexStateDescriptor<T> Aliases(Func<FluentDictionary<Elastic.Clients.Elasticsearch.IndexName?, Elastic.Clients.Elasticsearch.IndexManagement.Alias?>, FluentDictionary<Elastic.Clients.Elasticsearch.IndexName?, Elastic.Clients.Elasticsearch.IndexManagement.Alias?>> selector) => Assign(selector, (a, v) => a.AliasesValue = v?.Invoke(new FluentDictionary<Elastic.Clients.Elasticsearch.IndexName?, Elastic.Clients.Elasticsearch.IndexManagement.Alias?>()));
		public IndexStateDescriptor<T> Mappings(Elastic.Clients.Elasticsearch.Mapping.TypeMapping? mappings)
		{
			MappingsDescriptor = null;
			MappingsDescriptorAction = null;
			return Assign(mappings, (a, v) => a.MappingsValue = v);
		}

		public IndexStateDescriptor<T> Mappings(Elastic.Clients.Elasticsearch.Mapping.TypeMappingDescriptor descriptor)
		{
			MappingsValue = null;
			MappingsDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.MappingsDescriptor = v);
		}

		public IndexStateDescriptor<T> Mappings(Action<Elastic.Clients.Elasticsearch.Mapping.TypeMappingDescriptor> configure)
		{
			MappingsValue = null;
			MappingsDescriptorAction = null;
			return Assign(configure, (a, v) => a.MappingsDescriptorAction = v);
		}

		public IndexStateDescriptor<T> Settings(Elastic.Clients.Elasticsearch.IndexManagement.IndexSettings? settings)
		{
			SettingsDescriptor = null;
			SettingsDescriptorAction = null;
			return Assign(settings, (a, v) => a.SettingsValue = v);
		}

		public IndexStateDescriptor<T> Settings(Elastic.Clients.Elasticsearch.IndexManagement.IndexSettingsDescriptor<T> descriptor)
		{
			SettingsValue = null;
			SettingsDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.SettingsDescriptor = v);
		}

		public IndexStateDescriptor<T> Settings(Action<Elastic.Clients.Elasticsearch.IndexManagement.IndexSettingsDescriptor<T>> configure)
		{
			SettingsValue = null;
			SettingsDescriptorAction = null;
			return Assign(configure, (a, v) => a.SettingsDescriptorAction = v);
		}

		public IndexStateDescriptor<T> DataStream(Elastic.Clients.Elasticsearch.DataStreamName? dataStream) => Assign(dataStream, (a, v) => a.DataStreamValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (AliasesValue is not null)
			{
				writer.WritePropertyName("aliases");
				JsonSerializer.Serialize(writer, AliasesValue, options);
			}

			if (MappingsDescriptor is not null)
			{
				writer.WritePropertyName("mappings");
				JsonSerializer.Serialize(writer, MappingsDescriptor, options);
			}
			else if (MappingsDescriptorAction is not null)
			{
				writer.WritePropertyName("mappings");
				JsonSerializer.Serialize(writer, new Mapping.TypeMappingDescriptor(MappingsDescriptorAction), options);
			}
			else if (MappingsValue is not null)
			{
				writer.WritePropertyName("mappings");
				JsonSerializer.Serialize(writer, MappingsValue, options);
			}

			if (SettingsDescriptor is not null)
			{
				writer.WritePropertyName("settings");
				JsonSerializer.Serialize(writer, SettingsDescriptor, options);
			}
			else if (SettingsDescriptorAction is not null)
			{
				writer.WritePropertyName("settings");
				JsonSerializer.Serialize(writer, new IndexSettingsDescriptor<T>(SettingsDescriptorAction), options);
			}
			else if (SettingsValue is not null)
			{
				writer.WritePropertyName("settings");
				JsonSerializer.Serialize(writer, SettingsValue, options);
			}

			if (DataStreamValue is not null)
			{
				writer.WritePropertyName("data_stream");
				JsonSerializer.Serialize(writer, DataStreamValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class IndexVersioning
	{
		[JsonInclude]
		[JsonPropertyName("created")]
		public string Created { get; set; }
	}

	public sealed partial class IndexVersioningDescriptor : DescriptorBase<IndexVersioningDescriptor>
	{
		public IndexVersioningDescriptor()
		{
		}

		internal IndexVersioningDescriptor(Action<IndexVersioningDescriptor> configure) => configure.Invoke(this);
		internal string CreatedValue { get; private set; }

		public IndexVersioningDescriptor Created(string created) => Assign(created, (a, v) => a.CreatedValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("created");
			JsonSerializer.Serialize(writer, CreatedValue, options);
			writer.WriteEndObject();
		}
	}

	public partial class NumericFielddata
	{
		[JsonInclude]
		[JsonPropertyName("format")]
		public Elastic.Clients.Elasticsearch.IndexManagement.NumericFielddataFormat Format { get; init; }
	}

	public partial class OverlappingIndexTemplate
	{
		[JsonInclude]
		[JsonPropertyName("name")]
		public Elastic.Clients.Elasticsearch.Name Name { get; set; }

		[JsonInclude]
		[JsonPropertyName("index_patterns")]
		public IEnumerable<Elastic.Clients.Elasticsearch.IndexName>? IndexPatterns { get; set; }
	}

	public sealed partial class OverlappingIndexTemplateDescriptor : DescriptorBase<OverlappingIndexTemplateDescriptor>
	{
		public OverlappingIndexTemplateDescriptor()
		{
		}

		internal OverlappingIndexTemplateDescriptor(Action<OverlappingIndexTemplateDescriptor> configure) => configure.Invoke(this);
		internal Elastic.Clients.Elasticsearch.Name NameValue { get; private set; }

		internal IEnumerable<Elastic.Clients.Elasticsearch.IndexName>? IndexPatternsValue { get; private set; }

		public OverlappingIndexTemplateDescriptor Name(Elastic.Clients.Elasticsearch.Name name) => Assign(name, (a, v) => a.NameValue = v);
		public OverlappingIndexTemplateDescriptor IndexPatterns(IEnumerable<Elastic.Clients.Elasticsearch.IndexName>? indexPatterns) => Assign(indexPatterns, (a, v) => a.IndexPatternsValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("name");
			JsonSerializer.Serialize(writer, NameValue, options);
			if (IndexPatternsValue is not null)
			{
				writer.WritePropertyName("index_patterns");
				JsonSerializer.Serialize(writer, IndexPatternsValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class SoftDeletes
	{
		[JsonInclude]
		[JsonPropertyName("enabled")]
		public bool Enabled { get; set; }
	}

	public sealed partial class SoftDeletesDescriptor : DescriptorBase<SoftDeletesDescriptor>
	{
		public SoftDeletesDescriptor()
		{
		}

		internal SoftDeletesDescriptor(Action<SoftDeletesDescriptor> configure) => configure.Invoke(this);
		internal bool EnabledValue { get; private set; }

		public SoftDeletesDescriptor Enabled(bool enabled = true) => Assign(enabled, (a, v) => a.EnabledValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("enabled");
			writer.WriteBooleanValue(EnabledValue);
			writer.WriteEndObject();
		}
	}

	public partial class StringFielddata
	{
		[JsonInclude]
		[JsonPropertyName("format")]
		public Elastic.Clients.Elasticsearch.IndexManagement.StringFielddataFormat Format { get; init; }
	}

	public partial class TemplateMapping
	{
		[JsonInclude]
		[JsonPropertyName("aliases")]
		public Dictionary<Elastic.Clients.Elasticsearch.IndexName, Elastic.Clients.Elasticsearch.IndexManagement.Alias> Aliases { get; set; }

		[JsonInclude]
		[JsonPropertyName("index_patterns")]
		public IEnumerable<Elastic.Clients.Elasticsearch.Name> IndexPatterns { get; set; }

		[JsonInclude]
		[JsonPropertyName("mappings")]
		public Elastic.Clients.Elasticsearch.Mapping.TypeMapping Mappings { get; set; }

		[JsonInclude]
		[JsonPropertyName("order")]
		public int Order { get; set; }

		[JsonInclude]
		[JsonPropertyName("settings")]
		public Dictionary<string, object> Settings { get; set; }

		[JsonInclude]
		[JsonPropertyName("version")]
		public long? Version { get; set; }
	}

	public sealed partial class TemplateMappingDescriptor : DescriptorBase<TemplateMappingDescriptor>
	{
		public TemplateMappingDescriptor()
		{
		}

		internal TemplateMappingDescriptor(Action<TemplateMappingDescriptor> configure) => configure.Invoke(this);
		internal Dictionary<Elastic.Clients.Elasticsearch.IndexName, Elastic.Clients.Elasticsearch.IndexManagement.Alias> AliasesValue { get; private set; }

		internal IEnumerable<Elastic.Clients.Elasticsearch.Name> IndexPatternsValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Mapping.TypeMapping MappingsValue { get; private set; }

		internal int OrderValue { get; private set; }

		internal Dictionary<string, object> SettingsValue { get; private set; }

		internal long? VersionValue { get; private set; }

		internal Mapping.TypeMappingDescriptor MappingsDescriptor { get; private set; }

		internal Action<Mapping.TypeMappingDescriptor> MappingsDescriptorAction { get; private set; }

		public TemplateMappingDescriptor Aliases(Func<FluentDictionary<Elastic.Clients.Elasticsearch.IndexName, Elastic.Clients.Elasticsearch.IndexManagement.Alias>, FluentDictionary<Elastic.Clients.Elasticsearch.IndexName, Elastic.Clients.Elasticsearch.IndexManagement.Alias>> selector) => Assign(selector, (a, v) => a.AliasesValue = v?.Invoke(new FluentDictionary<Elastic.Clients.Elasticsearch.IndexName, Elastic.Clients.Elasticsearch.IndexManagement.Alias>()));
		public TemplateMappingDescriptor IndexPatterns(IEnumerable<Elastic.Clients.Elasticsearch.Name> indexPatterns) => Assign(indexPatterns, (a, v) => a.IndexPatternsValue = v);
		public TemplateMappingDescriptor Mappings(Elastic.Clients.Elasticsearch.Mapping.TypeMapping mappings)
		{
			MappingsDescriptor = null;
			MappingsDescriptorAction = null;
			return Assign(mappings, (a, v) => a.MappingsValue = v);
		}

		public TemplateMappingDescriptor Mappings(Elastic.Clients.Elasticsearch.Mapping.TypeMappingDescriptor descriptor)
		{
			MappingsValue = null;
			MappingsDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.MappingsDescriptor = v);
		}

		public TemplateMappingDescriptor Mappings(Action<Elastic.Clients.Elasticsearch.Mapping.TypeMappingDescriptor> configure)
		{
			MappingsValue = null;
			MappingsDescriptorAction = null;
			return Assign(configure, (a, v) => a.MappingsDescriptorAction = v);
		}

		public TemplateMappingDescriptor Order(int order) => Assign(order, (a, v) => a.OrderValue = v);
		public TemplateMappingDescriptor Settings(Func<FluentDictionary<string, object>, FluentDictionary<string, object>> selector) => Assign(selector, (a, v) => a.SettingsValue = v?.Invoke(new FluentDictionary<string, object>()));
		public TemplateMappingDescriptor Version(long? version) => Assign(version, (a, v) => a.VersionValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("aliases");
			JsonSerializer.Serialize(writer, AliasesValue, options);
			writer.WritePropertyName("index_patterns");
			JsonSerializer.Serialize(writer, IndexPatternsValue, options);
			if (MappingsDescriptor is not null)
			{
				writer.WritePropertyName("mappings");
				JsonSerializer.Serialize(writer, MappingsDescriptor, options);
			}
			else if (MappingsDescriptorAction is not null)
			{
				writer.WritePropertyName("mappings");
				JsonSerializer.Serialize(writer, new Mapping.TypeMappingDescriptor(MappingsDescriptorAction), options);
			}
			else
			{
				writer.WritePropertyName("mappings");
				JsonSerializer.Serialize(writer, MappingsValue, options);
			}

			writer.WritePropertyName("order");
			writer.WriteNumberValue(OrderValue);
			writer.WritePropertyName("settings");
			JsonSerializer.Serialize(writer, SettingsValue, options);
			if (VersionValue is not null)
			{
				writer.WritePropertyName("version");
				JsonSerializer.Serialize(writer, VersionValue, options);
			}

			writer.WriteEndObject();
		}
	}
}