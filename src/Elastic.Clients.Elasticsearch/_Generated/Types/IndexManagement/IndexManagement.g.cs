// Licensed to Elasticsearch B.V under one or more agreements.
// Elasticsearch B.V licenses this file to you under the Apache 2.0 License.
// See the LICENSE file in the project root for more information.
//
// ███╗   ██╗ ██████╗ ████████╗██╗ ██████╗███████╗
// ████╗  ██║██╔═══██╗╚══██╔══╝██║██╔════╝██╔════╝
// ██╔██╗ ██║██║   ██║   ██║   ██║██║     █████╗
// ██║╚██╗██║██║   ██║   ██║   ██║██║     ██╔══╝
// ██║ ╚████║╚██████╔╝   ██║   ██║╚██████╗███████╗
// ╚═╝  ╚═══╝ ╚═════╝    ╚═╝   ╚═╝ ╚═════╝╚══════╝
// ------------------------------------------------
//
// This file is automatically generated.
// Please do not edit these files manually.
//
// ------------------------------------------------

using System;
using System.Collections.Generic;
using System.Text.Json;
using System.Text.Json.Serialization;

#nullable restore
namespace Elastic.Clients.Elasticsearch.IndexManagement
{
	public partial class Alias
	{
		[JsonInclude]
		[JsonPropertyName("filter")]
		public Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? Filter { get; set; }

		[JsonInclude]
		[JsonPropertyName("index_routing")]
		public string? IndexRouting { get; set; }

		[JsonInclude]
		[JsonPropertyName("is_hidden")]
		public bool? IsHidden { get; set; }

		[JsonInclude]
		[JsonPropertyName("is_write_index")]
		public bool? IsWriteIndex { get; set; }

		[JsonInclude]
		[JsonPropertyName("routing")]
		public string? Routing { get; set; }

		[JsonInclude]
		[JsonPropertyName("search_routing")]
		public string? SearchRouting { get; set; }
	}

	[JsonConverter(typeof(AliasDescriptorConverter))]
	public partial class AliasDescriptor : DescriptorBase<AliasDescriptor>
	{
		internal Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? _filter;
		internal string? _indexRouting;
		internal bool? _isHidden;
		internal bool? _isWriteIndex;
		internal string? _routing;
		internal string? _searchRouting;
	}

	internal sealed class AliasDescriptorConverter : JsonConverter<AliasDescriptor>
	{
		public override AliasDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, AliasDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value._filter is not null)
			{
				writer.WritePropertyName("filter");
				JsonSerializer.Serialize(writer, value._filter, options);
			}

			if (value._indexRouting is not null)
			{
				writer.WritePropertyName("index_routing");
				JsonSerializer.Serialize(writer, value._indexRouting, options);
			}

			if (value._isHidden.HasValue)
			{
				writer.WritePropertyName("is_hidden");
				writer.WriteBooleanValue(value._isHidden.Value);
			}

			if (value._isWriteIndex.HasValue)
			{
				writer.WritePropertyName("is_write_index");
				writer.WriteBooleanValue(value._isWriteIndex.Value);
			}

			if (value._routing is not null)
			{
				writer.WritePropertyName("routing");
				JsonSerializer.Serialize(writer, value._routing, options);
			}

			if (value._searchRouting is not null)
			{
				writer.WritePropertyName("search_routing");
				JsonSerializer.Serialize(writer, value._searchRouting, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class AliasDefinition
	{
		[JsonInclude]
		[JsonPropertyName("filter")]
		public Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? Filter { get; set; }

		[JsonInclude]
		[JsonPropertyName("index_routing")]
		public string? IndexRouting { get; set; }

		[JsonInclude]
		[JsonPropertyName("is_write_index")]
		public bool? IsWriteIndex { get; set; }

		[JsonInclude]
		[JsonPropertyName("routing")]
		public string? Routing { get; set; }

		[JsonInclude]
		[JsonPropertyName("search_routing")]
		public string? SearchRouting { get; set; }
	}

	[JsonConverter(typeof(AliasDefinitionDescriptorConverter))]
	public partial class AliasDefinitionDescriptor : DescriptorBase<AliasDefinitionDescriptor>
	{
		internal Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? _filter;
		internal string? _indexRouting;
		internal bool? _isWriteIndex;
		internal string? _routing;
		internal string? _searchRouting;
	}

	internal sealed class AliasDefinitionDescriptorConverter : JsonConverter<AliasDefinitionDescriptor>
	{
		public override AliasDefinitionDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, AliasDefinitionDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value._filter is not null)
			{
				writer.WritePropertyName("filter");
				JsonSerializer.Serialize(writer, value._filter, options);
			}

			if (!string.IsNullOrEmpty(value._indexRouting))
			{
				writer.WritePropertyName("index_routing");
				writer.WriteStringValue(value._indexRouting);
			}

			if (value._isWriteIndex.HasValue)
			{
				writer.WritePropertyName("is_write_index");
				writer.WriteBooleanValue(value._isWriteIndex.Value);
			}

			if (!string.IsNullOrEmpty(value._routing))
			{
				writer.WritePropertyName("routing");
				writer.WriteStringValue(value._routing);
			}

			if (!string.IsNullOrEmpty(value._searchRouting))
			{
				writer.WritePropertyName("search_routing");
				writer.WriteStringValue(value._searchRouting);
			}

			writer.WriteEndObject();
		}
	}

	public partial class DataStream
	{
		[JsonInclude]
		[JsonPropertyName("hidden")]
		public bool? Hidden { get; set; }
	}

	public partial class FielddataFrequencyFilter
	{
		[JsonInclude]
		[JsonPropertyName("max")]
		public double Max { get; init; }

		[JsonInclude]
		[JsonPropertyName("min")]
		public double Min { get; init; }

		[JsonInclude]
		[JsonPropertyName("min_segment_size")]
		public int MinSegmentSize { get; init; }
	}

	public partial class IndexRouting
	{
		[JsonInclude]
		[JsonPropertyName("allocation")]
		public Elastic.Clients.Elasticsearch.IndexManagement.IndexRoutingAllocation? Allocation { get; set; }

		[JsonInclude]
		[JsonPropertyName("rebalance")]
		public Elastic.Clients.Elasticsearch.IndexManagement.IndexRoutingRebalance? Rebalance { get; set; }
	}

	public partial class IndexRoutingAllocation
	{
		[JsonInclude]
		[JsonPropertyName("enable")]
		public Elastic.Clients.Elasticsearch.IndexManagement.IndexRoutingAllocationOptions? Enable { get; set; }

		[JsonInclude]
		[JsonPropertyName("include")]
		public Elastic.Clients.Elasticsearch.IndexManagement.IndexRoutingAllocationInclude? Include { get; set; }

		[JsonInclude]
		[JsonPropertyName("initial_recovery")]
		public Elastic.Clients.Elasticsearch.IndexManagement.IndexRoutingAllocationInitialRecovery? InitialRecovery { get; set; }

		[JsonInclude]
		[JsonPropertyName("disk")]
		public Elastic.Clients.Elasticsearch.IndexManagement.IndexRoutingAllocationDisk? Disk { get; set; }
	}

	[JsonConverter(typeof(IndexRoutingAllocationDescriptorConverter))]
	public partial class IndexRoutingAllocationDescriptor : DescriptorBase<IndexRoutingAllocationDescriptor>
	{
		internal Elastic.Clients.Elasticsearch.IndexManagement.IndexRoutingAllocationOptions? _enable;
		internal Elastic.Clients.Elasticsearch.IndexManagement.IndexRoutingAllocationInclude? _include;
		internal Elastic.Clients.Elasticsearch.IndexManagement.IndexRoutingAllocationInitialRecovery? _initialRecovery;
		internal Elastic.Clients.Elasticsearch.IndexManagement.IndexRoutingAllocationDisk? _disk;
	}

	internal sealed class IndexRoutingAllocationDescriptorConverter : JsonConverter<IndexRoutingAllocationDescriptor>
	{
		public override IndexRoutingAllocationDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, IndexRoutingAllocationDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value._enable is not null)
			{
				writer.WritePropertyName("enable");
				JsonSerializer.Serialize(writer, value._enable, options);
			}

			if (value._include is not null)
			{
				writer.WritePropertyName("include");
				JsonSerializer.Serialize(writer, value._include, options);
			}

			if (value._initialRecovery is not null)
			{
				writer.WritePropertyName("initial_recovery");
				JsonSerializer.Serialize(writer, value._initialRecovery, options);
			}

			if (value._disk is not null)
			{
				writer.WritePropertyName("disk");
				JsonSerializer.Serialize(writer, value._disk, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class IndexRoutingAllocationDisk
	{
		[JsonInclude]
		[JsonPropertyName("threshold_enabled")]
		public Union<bool, string> ThresholdEnabled { get; set; }
	}

	public partial class IndexRoutingAllocationInclude
	{
		[JsonInclude]
		[JsonPropertyName("_tier_preference")]
		public string? TierPreference { get; set; }

		[JsonInclude]
		[JsonPropertyName("_id")]
		public Elastic.Clients.Elasticsearch.Id? Id { get; set; }
	}

	public partial class IndexRoutingAllocationInitialRecovery
	{
		[JsonInclude]
		[JsonPropertyName("_id")]
		public Elastic.Clients.Elasticsearch.Id? Id { get; set; }
	}

	public partial class IndexRoutingRebalance
	{
		[JsonInclude]
		[JsonPropertyName("enable")]
		public Elastic.Clients.Elasticsearch.IndexManagement.IndexRoutingRebalanceOptions Enable { get; set; }
	}

	public partial class IndexSegmentSort
	{
		[JsonInclude]
		[JsonPropertyName("field")]
		public Elastic.Clients.Elasticsearch.Fields Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("order")]
		public IEnumerable<Elastic.Clients.Elasticsearch.IndexManagement.SegmentSortOrder> Order { get; set; }

		[JsonInclude]
		[JsonPropertyName("mode")]
		public Elastic.Clients.Elasticsearch.IndexManagement.SegmentSortMode? Mode { get; set; }

		[JsonInclude]
		[JsonPropertyName("missing")]
		public Elastic.Clients.Elasticsearch.IndexManagement.SegmentSortMissing? Missing { get; set; }
	}

	[JsonConverter(typeof(IndexSegmentSortDescriptorConverter))]
	public partial class IndexSegmentSortDescriptor : DescriptorBase<IndexSegmentSortDescriptor>
	{
		internal Elastic.Clients.Elasticsearch.Fields _field;
		internal IEnumerable<Elastic.Clients.Elasticsearch.IndexManagement.SegmentSortOrder> _order;
		internal Elastic.Clients.Elasticsearch.IndexManagement.SegmentSortMode? _mode;
		internal Elastic.Clients.Elasticsearch.IndexManagement.SegmentSortMissing? _missing;
	}

	internal sealed class IndexSegmentSortDescriptorConverter : JsonConverter<IndexSegmentSortDescriptor>
	{
		public override IndexSegmentSortDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, IndexSegmentSortDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, value._field, options);
			writer.WritePropertyName("order");
			JsonSerializer.Serialize(writer, value._order, options);
			if (value._mode is not null)
			{
				writer.WritePropertyName("mode");
				JsonSerializer.Serialize(writer, value._mode, options);
			}

			if (value._missing is not null)
			{
				writer.WritePropertyName("missing");
				JsonSerializer.Serialize(writer, value._missing, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class IndexSettingBlocks
	{
		[JsonInclude]
		[JsonPropertyName("read_only")]
		public bool? ReadOnly { get; set; }

		[JsonInclude]
		[JsonPropertyName("read_only_allow_delete")]
		public bool? ReadOnlyAllowDelete { get; set; }

		[JsonInclude]
		[JsonPropertyName("read")]
		public bool? Read { get; set; }

		[JsonInclude]
		[JsonPropertyName("write")]
		public Union<bool?, string?>? Write { get; set; }

		[JsonInclude]
		[JsonPropertyName("metadata")]
		public bool? Metadata { get; set; }
	}

	[JsonConverter(typeof(IndexSettingBlocksDescriptorConverter))]
	public partial class IndexSettingBlocksDescriptor : DescriptorBase<IndexSettingBlocksDescriptor>
	{
		internal bool? _readOnly;
		internal bool? _readOnlyAllowDelete;
		internal bool? _read;
		internal Union<bool?, string?>? _write;
		internal bool? _metadata;
	}

	internal sealed class IndexSettingBlocksDescriptorConverter : JsonConverter<IndexSettingBlocksDescriptor>
	{
		public override IndexSettingBlocksDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, IndexSettingBlocksDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value._readOnly.HasValue)
			{
				writer.WritePropertyName("read_only");
				writer.WriteBooleanValue(value._readOnly.Value);
			}

			if (value._readOnlyAllowDelete.HasValue)
			{
				writer.WritePropertyName("read_only_allow_delete");
				writer.WriteBooleanValue(value._readOnlyAllowDelete.Value);
			}

			if (value._read.HasValue)
			{
				writer.WritePropertyName("read");
				writer.WriteBooleanValue(value._read.Value);
			}

			if (value._write is not null)
			{
				writer.WritePropertyName("write");
				JsonSerializer.Serialize(writer, value._write, options);
			}

			if (value._metadata.HasValue)
			{
				writer.WritePropertyName("metadata");
				writer.WriteBooleanValue(value._metadata.Value);
			}

			writer.WriteEndObject();
		}
	}

	public partial class IndexSettings
	{
		[JsonInclude]
		[JsonPropertyName("index")]
		public Elastic.Clients.Elasticsearch.IndexManagement.IndexSettings? Index { get; set; }

		[JsonInclude]
		[JsonPropertyName("mode")]
		public string? Mode { get; set; }

		[JsonInclude]
		[JsonPropertyName("routing_path")]
		public IEnumerable<string>? RoutingPath { get; set; }

		[JsonInclude]
		[JsonPropertyName("soft_deletes")]
		public Elastic.Clients.Elasticsearch.IndexManagement.SoftDeletes? SoftDeletes { get; set; }

		[JsonInclude]
		[JsonPropertyName("sort")]
		public Elastic.Clients.Elasticsearch.IndexManagement.IndexSegmentSort? Sort { get; set; }

		[JsonInclude]
		[JsonPropertyName("number_of_shards")]
		public Union<int?, string?>? NumberOfShards { get; set; }

		[JsonInclude]
		[JsonPropertyName("number_of_replicas")]
		public Union<int?, string?>? NumberOfReplicas { get; set; }

		[JsonInclude]
		[JsonPropertyName("number_of_routing_shards")]
		public int? NumberOfRoutingShards { get; set; }

		[JsonInclude]
		[JsonPropertyName("check_on_startup")]
		public Elastic.Clients.Elasticsearch.IndexManagement.IndexCheckOnStartup? CheckOnStartup { get; set; }

		[JsonInclude]
		[JsonPropertyName("codec")]
		public string? Codec { get; set; }

		[JsonInclude]
		[JsonPropertyName("routing_partition_size")]
		public int? RoutingPartitionSize { get; set; }

		[JsonInclude]
		[JsonPropertyName("soft_deletes.retention_lease.period")]
		public Elastic.Clients.Elasticsearch.Time? SoftDeletesRetentionLeasePeriod { get; set; }

		[JsonInclude]
		[JsonPropertyName("load_fixed_bitset_filters_eagerly")]
		public bool? LoadFixedBitsetFiltersEagerly { get; set; }

		[JsonInclude]
		[JsonPropertyName("hidden")]
		public Union<bool?, string?>? Hidden { get; set; }

		[JsonInclude]
		[JsonPropertyName("auto_expand_replicas")]
		public string? AutoExpandReplicas { get; set; }

		[JsonInclude]
		[JsonPropertyName("merge.scheduler.max_thread_count")]
		public int? MergeSchedulerMaxThreadCount { get; set; }

		[JsonInclude]
		[JsonPropertyName("search.idle.after")]
		public Elastic.Clients.Elasticsearch.Time? SearchIdleAfter { get; set; }

		[JsonInclude]
		[JsonPropertyName("refresh_interval")]
		public Elastic.Clients.Elasticsearch.Time? RefreshInterval { get; set; }

		[JsonInclude]
		[JsonPropertyName("max_result_window")]
		public int? MaxResultWindow { get; set; }

		[JsonInclude]
		[JsonPropertyName("max_inner_result_window")]
		public int? MaxInnerResultWindow { get; set; }

		[JsonInclude]
		[JsonPropertyName("max_rescore_window")]
		public int? MaxRescoreWindow { get; set; }

		[JsonInclude]
		[JsonPropertyName("max_docvalue_fields_search")]
		public int? MaxDocvalueFieldsSearch { get; set; }

		[JsonInclude]
		[JsonPropertyName("max_script_fields")]
		public int? MaxScriptFields { get; set; }

		[JsonInclude]
		[JsonPropertyName("max_ngram_diff")]
		public int? MaxNgramDiff { get; set; }

		[JsonInclude]
		[JsonPropertyName("max_shingle_diff")]
		public int? MaxShingleDiff { get; set; }

		[JsonInclude]
		[JsonPropertyName("blocks")]
		public Elastic.Clients.Elasticsearch.IndexManagement.IndexSettingBlocks? Blocks { get; set; }

		[JsonInclude]
		[JsonPropertyName("blocks.read_only")]
		public bool? BlocksReadOnly { get; set; }

		[JsonInclude]
		[JsonPropertyName("blocks.read_only_allow_delete")]
		public bool? BlocksReadOnlyAllowDelete { get; set; }

		[JsonInclude]
		[JsonPropertyName("blocks.read")]
		public bool? BlocksRead { get; set; }

		[JsonInclude]
		[JsonPropertyName("blocks.write")]
		public Union<bool?, string?>? BlocksWrite { get; set; }

		[JsonInclude]
		[JsonPropertyName("blocks.metadata")]
		public bool? BlocksMetadata { get; set; }

		[JsonInclude]
		[JsonPropertyName("max_refresh_listeners")]
		public int? MaxRefreshListeners { get; set; }

		[JsonInclude]
		[JsonPropertyName("analyze.max_token_count")]
		public int? AnalyzeMaxTokenCount { get; set; }

		[JsonInclude]
		[JsonPropertyName("highlight.max_analyzed_offset")]
		public int? HighlightMaxAnalyzedOffset { get; set; }

		[JsonInclude]
		[JsonPropertyName("max_terms_count")]
		public int? MaxTermsCount { get; set; }

		[JsonInclude]
		[JsonPropertyName("max_regex_length")]
		public int? MaxRegexLength { get; set; }

		[JsonInclude]
		[JsonPropertyName("routing")]
		public Elastic.Clients.Elasticsearch.IndexManagement.IndexRouting? Routing { get; set; }

		[JsonInclude]
		[JsonPropertyName("gc_deletes")]
		public Elastic.Clients.Elasticsearch.Time? GcDeletes { get; set; }

		[JsonInclude]
		[JsonPropertyName("default_pipeline")]
		public string? DefaultPipeline { get; set; }

		[JsonInclude]
		[JsonPropertyName("final_pipeline")]
		public string? FinalPipeline { get; set; }

		[JsonInclude]
		[JsonPropertyName("lifecycle")]
		public Elastic.Clients.Elasticsearch.IndexManagement.IndexSettingsLifecycle? Lifecycle { get; set; }

		[JsonInclude]
		[JsonPropertyName("lifecycle.name")]
		public string? LifecycleName { get; set; }

		[JsonInclude]
		[JsonPropertyName("provided_name")]
		public Elastic.Clients.Elasticsearch.Name? ProvidedName { get; set; }

		[JsonInclude]
		[JsonPropertyName("creation_date")]
		public string? CreationDate { get; set; }

		[JsonInclude]
		[JsonPropertyName("uuid")]
		public string? Uuid { get; set; }

		[JsonInclude]
		[JsonPropertyName("version")]
		public Elastic.Clients.Elasticsearch.IndexManagement.IndexVersioning? Version { get; set; }

		[JsonInclude]
		[JsonPropertyName("verified_before_close")]
		public Union<bool?, string?>? VerifiedBeforeClose { get; set; }

		[JsonInclude]
		[JsonPropertyName("format")]
		public Union<string?, int?>? Format { get; set; }

		[JsonInclude]
		[JsonPropertyName("max_slices_per_scroll")]
		public int? MaxSlicesPerScroll { get; set; }

		[JsonInclude]
		[JsonPropertyName("translog.durability")]
		public string? TranslogDurability { get; set; }

		[JsonInclude]
		[JsonPropertyName("translog.flush_threshold_size")]
		public string? TranslogFlushThresholdSize { get; set; }

		[JsonInclude]
		[JsonPropertyName("query_string.lenient")]
		public Union<bool?, string?>? QueryStringLenient { get; set; }

		[JsonInclude]
		[JsonPropertyName("priority")]
		public Union<int?, string?>? Priority { get; set; }

		[JsonInclude]
		[JsonPropertyName("top_metrics_max_size")]
		public int? TopMetricsMaxSize { get; set; }

		[JsonInclude]
		[JsonPropertyName("analysis")]
		public Elastic.Clients.Elasticsearch.IndexManagement.IndexSettingsAnalysis? Analysis { get; set; }

		[JsonInclude]
		[JsonPropertyName("settings")]
		public Elastic.Clients.Elasticsearch.IndexManagement.IndexSettings? Settings { get; set; }
	}

	[JsonConverter(typeof(IndexSettingsDescriptorConverter))]
	public partial class IndexSettingsDescriptor : DescriptorBase<IndexSettingsDescriptor>
	{
		internal Elastic.Clients.Elasticsearch.IndexManagement.IndexSettings? _index;
		internal string? _mode;
		internal IEnumerable<string>? _routingPath;
		internal Elastic.Clients.Elasticsearch.IndexManagement.SoftDeletes? _softDeletes;
		internal Elastic.Clients.Elasticsearch.IndexManagement.IndexSegmentSort? _sort;
		internal Union<int?, string?>? _numberOfShards;
		internal Union<int?, string?>? _numberOfReplicas;
		internal int? _numberOfRoutingShards;
		internal Elastic.Clients.Elasticsearch.IndexManagement.IndexCheckOnStartup? _checkOnStartup;
		internal string? _codec;
		internal int? _routingPartitionSize;
		internal Elastic.Clients.Elasticsearch.Time? _softDeletesRetentionLeasePeriod;
		internal bool? _loadFixedBitsetFiltersEagerly;
		internal Union<bool?, string?>? _hidden;
		internal string? _autoExpandReplicas;
		internal int? _mergeSchedulerMaxThreadCount;
		internal Elastic.Clients.Elasticsearch.Time? _searchIdleAfter;
		internal Elastic.Clients.Elasticsearch.Time? _refreshInterval;
		internal int? _maxResultWindow;
		internal int? _maxInnerResultWindow;
		internal int? _maxRescoreWindow;
		internal int? _maxDocvalueFieldsSearch;
		internal int? _maxScriptFields;
		internal int? _maxNgramDiff;
		internal int? _maxShingleDiff;
		internal Elastic.Clients.Elasticsearch.IndexManagement.IndexSettingBlocks? _blocks;
		internal bool? _blocksReadOnly;
		internal bool? _blocksReadOnlyAllowDelete;
		internal bool? _blocksRead;
		internal Union<bool?, string?>? _blocksWrite;
		internal bool? _blocksMetadata;
		internal int? _maxRefreshListeners;
		internal int? _analyzeMaxTokenCount;
		internal int? _highlightMaxAnalyzedOffset;
		internal int? _maxTermsCount;
		internal int? _maxRegexLength;
		internal Elastic.Clients.Elasticsearch.IndexManagement.IndexRouting? _routing;
		internal Elastic.Clients.Elasticsearch.Time? _gcDeletes;
		internal string? _defaultPipeline;
		internal string? _finalPipeline;
		internal Elastic.Clients.Elasticsearch.IndexManagement.IndexSettingsLifecycle? _lifecycle;
		internal string? _lifecycleName;
		internal Elastic.Clients.Elasticsearch.Name? _providedName;
		internal string? _creationDate;
		internal string? _uuid;
		internal Elastic.Clients.Elasticsearch.IndexManagement.IndexVersioning? _version;
		internal Union<bool?, string?>? _verifiedBeforeClose;
		internal Union<string?, int?>? _format;
		internal int? _maxSlicesPerScroll;
		internal string? _translogDurability;
		internal string? _translogFlushThresholdSize;
		internal Union<bool?, string?>? _queryStringLenient;
		internal Union<int?, string?>? _priority;
		internal int? _topMetricsMaxSize;
		internal Elastic.Clients.Elasticsearch.IndexManagement.IndexSettingsAnalysis? _analysis;
		internal Elastic.Clients.Elasticsearch.IndexManagement.IndexSettings? _settings;
	}

	internal sealed class IndexSettingsDescriptorConverter : JsonConverter<IndexSettingsDescriptor>
	{
		public override IndexSettingsDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, IndexSettingsDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value._index is not null)
			{
				writer.WritePropertyName("index");
				JsonSerializer.Serialize(writer, value._index, options);
			}

			if (!string.IsNullOrEmpty(value._mode))
			{
				writer.WritePropertyName("mode");
				writer.WriteStringValue(value._mode);
			}

			if (value._routingPath is not null)
			{
				writer.WritePropertyName("routing_path");
				JsonSerializer.Serialize(writer, value._routingPath, options);
			}

			if (value._softDeletes is not null)
			{
				writer.WritePropertyName("soft_deletes");
				JsonSerializer.Serialize(writer, value._softDeletes, options);
			}

			if (value._sort is not null)
			{
				writer.WritePropertyName("sort");
				JsonSerializer.Serialize(writer, value._sort, options);
			}

			if (value._numberOfShards is not null)
			{
				writer.WritePropertyName("number_of_shards");
				JsonSerializer.Serialize(writer, value._numberOfShards, options);
			}

			if (value._numberOfReplicas is not null)
			{
				writer.WritePropertyName("number_of_replicas");
				JsonSerializer.Serialize(writer, value._numberOfReplicas, options);
			}

			if (value._numberOfRoutingShards.HasValue)
			{
				writer.WritePropertyName("number_of_routing_shards");
				writer.WriteNumberValue(value._numberOfRoutingShards.Value);
			}

			if (value._checkOnStartup is not null)
			{
				writer.WritePropertyName("check_on_startup");
				JsonSerializer.Serialize(writer, value._checkOnStartup, options);
			}

			if (!string.IsNullOrEmpty(value._codec))
			{
				writer.WritePropertyName("codec");
				writer.WriteStringValue(value._codec);
			}

			if (value._routingPartitionSize.HasValue)
			{
				writer.WritePropertyName("routing_partition_size");
				writer.WriteNumberValue(value._routingPartitionSize.Value);
			}

			if (value._softDeletesRetentionLeasePeriod is not null)
			{
				writer.WritePropertyName("soft_deletes.retention_lease.period");
				JsonSerializer.Serialize(writer, value._softDeletesRetentionLeasePeriod, options);
			}

			if (value._loadFixedBitsetFiltersEagerly.HasValue)
			{
				writer.WritePropertyName("load_fixed_bitset_filters_eagerly");
				writer.WriteBooleanValue(value._loadFixedBitsetFiltersEagerly.Value);
			}

			if (value._hidden is not null)
			{
				writer.WritePropertyName("hidden");
				JsonSerializer.Serialize(writer, value._hidden, options);
			}

			if (!string.IsNullOrEmpty(value._autoExpandReplicas))
			{
				writer.WritePropertyName("auto_expand_replicas");
				writer.WriteStringValue(value._autoExpandReplicas);
			}

			if (value._mergeSchedulerMaxThreadCount.HasValue)
			{
				writer.WritePropertyName("merge.scheduler.max_thread_count");
				writer.WriteNumberValue(value._mergeSchedulerMaxThreadCount.Value);
			}

			if (value._searchIdleAfter is not null)
			{
				writer.WritePropertyName("search.idle.after");
				JsonSerializer.Serialize(writer, value._searchIdleAfter, options);
			}

			if (value._refreshInterval is not null)
			{
				writer.WritePropertyName("refresh_interval");
				JsonSerializer.Serialize(writer, value._refreshInterval, options);
			}

			if (value._maxResultWindow.HasValue)
			{
				writer.WritePropertyName("max_result_window");
				writer.WriteNumberValue(value._maxResultWindow.Value);
			}

			if (value._maxInnerResultWindow.HasValue)
			{
				writer.WritePropertyName("max_inner_result_window");
				writer.WriteNumberValue(value._maxInnerResultWindow.Value);
			}

			if (value._maxRescoreWindow.HasValue)
			{
				writer.WritePropertyName("max_rescore_window");
				writer.WriteNumberValue(value._maxRescoreWindow.Value);
			}

			if (value._maxDocvalueFieldsSearch.HasValue)
			{
				writer.WritePropertyName("max_docvalue_fields_search");
				writer.WriteNumberValue(value._maxDocvalueFieldsSearch.Value);
			}

			if (value._maxScriptFields.HasValue)
			{
				writer.WritePropertyName("max_script_fields");
				writer.WriteNumberValue(value._maxScriptFields.Value);
			}

			if (value._maxNgramDiff.HasValue)
			{
				writer.WritePropertyName("max_ngram_diff");
				writer.WriteNumberValue(value._maxNgramDiff.Value);
			}

			if (value._maxShingleDiff.HasValue)
			{
				writer.WritePropertyName("max_shingle_diff");
				writer.WriteNumberValue(value._maxShingleDiff.Value);
			}

			if (value._blocks is not null)
			{
				writer.WritePropertyName("blocks");
				JsonSerializer.Serialize(writer, value._blocks, options);
			}

			if (value._blocksReadOnly.HasValue)
			{
				writer.WritePropertyName("blocks.read_only");
				writer.WriteBooleanValue(value._blocksReadOnly.Value);
			}

			if (value._blocksReadOnlyAllowDelete.HasValue)
			{
				writer.WritePropertyName("blocks.read_only_allow_delete");
				writer.WriteBooleanValue(value._blocksReadOnlyAllowDelete.Value);
			}

			if (value._blocksRead.HasValue)
			{
				writer.WritePropertyName("blocks.read");
				writer.WriteBooleanValue(value._blocksRead.Value);
			}

			if (value._blocksWrite is not null)
			{
				writer.WritePropertyName("blocks.write");
				JsonSerializer.Serialize(writer, value._blocksWrite, options);
			}

			if (value._blocksMetadata.HasValue)
			{
				writer.WritePropertyName("blocks.metadata");
				writer.WriteBooleanValue(value._blocksMetadata.Value);
			}

			if (value._maxRefreshListeners.HasValue)
			{
				writer.WritePropertyName("max_refresh_listeners");
				writer.WriteNumberValue(value._maxRefreshListeners.Value);
			}

			if (value._analyzeMaxTokenCount.HasValue)
			{
				writer.WritePropertyName("analyze.max_token_count");
				writer.WriteNumberValue(value._analyzeMaxTokenCount.Value);
			}

			if (value._highlightMaxAnalyzedOffset.HasValue)
			{
				writer.WritePropertyName("highlight.max_analyzed_offset");
				writer.WriteNumberValue(value._highlightMaxAnalyzedOffset.Value);
			}

			if (value._maxTermsCount.HasValue)
			{
				writer.WritePropertyName("max_terms_count");
				writer.WriteNumberValue(value._maxTermsCount.Value);
			}

			if (value._maxRegexLength.HasValue)
			{
				writer.WritePropertyName("max_regex_length");
				writer.WriteNumberValue(value._maxRegexLength.Value);
			}

			if (value._routing is not null)
			{
				writer.WritePropertyName("routing");
				JsonSerializer.Serialize(writer, value._routing, options);
			}

			if (value._gcDeletes is not null)
			{
				writer.WritePropertyName("gc_deletes");
				JsonSerializer.Serialize(writer, value._gcDeletes, options);
			}

			if (value._defaultPipeline is not null)
			{
				writer.WritePropertyName("default_pipeline");
				JsonSerializer.Serialize(writer, value._defaultPipeline, options);
			}

			if (value._finalPipeline is not null)
			{
				writer.WritePropertyName("final_pipeline");
				JsonSerializer.Serialize(writer, value._finalPipeline, options);
			}

			if (value._lifecycle is not null)
			{
				writer.WritePropertyName("lifecycle");
				JsonSerializer.Serialize(writer, value._lifecycle, options);
			}

			if (!string.IsNullOrEmpty(value._lifecycleName))
			{
				writer.WritePropertyName("lifecycle.name");
				writer.WriteStringValue(value._lifecycleName);
			}

			if (value._providedName is not null)
			{
				writer.WritePropertyName("provided_name");
				JsonSerializer.Serialize(writer, value._providedName, options);
			}

			if (value._creationDate is not null)
			{
				writer.WritePropertyName("creation_date");
				JsonSerializer.Serialize(writer, value._creationDate, options);
			}

			if (value._uuid is not null)
			{
				writer.WritePropertyName("uuid");
				JsonSerializer.Serialize(writer, value._uuid, options);
			}

			if (value._version is not null)
			{
				writer.WritePropertyName("version");
				JsonSerializer.Serialize(writer, value._version, options);
			}

			if (value._verifiedBeforeClose is not null)
			{
				writer.WritePropertyName("verified_before_close");
				JsonSerializer.Serialize(writer, value._verifiedBeforeClose, options);
			}

			if (value._format is not null)
			{
				writer.WritePropertyName("format");
				JsonSerializer.Serialize(writer, value._format, options);
			}

			if (value._maxSlicesPerScroll.HasValue)
			{
				writer.WritePropertyName("max_slices_per_scroll");
				writer.WriteNumberValue(value._maxSlicesPerScroll.Value);
			}

			if (!string.IsNullOrEmpty(value._translogDurability))
			{
				writer.WritePropertyName("translog.durability");
				writer.WriteStringValue(value._translogDurability);
			}

			if (!string.IsNullOrEmpty(value._translogFlushThresholdSize))
			{
				writer.WritePropertyName("translog.flush_threshold_size");
				writer.WriteStringValue(value._translogFlushThresholdSize);
			}

			if (value._queryStringLenient is not null)
			{
				writer.WritePropertyName("query_string.lenient");
				JsonSerializer.Serialize(writer, value._queryStringLenient, options);
			}

			if (value._priority is not null)
			{
				writer.WritePropertyName("priority");
				JsonSerializer.Serialize(writer, value._priority, options);
			}

			if (value._topMetricsMaxSize.HasValue)
			{
				writer.WritePropertyName("top_metrics_max_size");
				writer.WriteNumberValue(value._topMetricsMaxSize.Value);
			}

			if (value._analysis is not null)
			{
				writer.WritePropertyName("analysis");
				JsonSerializer.Serialize(writer, value._analysis, options);
			}

			if (value._settings is not null)
			{
				writer.WritePropertyName("settings");
				JsonSerializer.Serialize(writer, value._settings, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class IndexSettingsAnalysis
	{
		[JsonInclude]
		[JsonPropertyName("analyzer")]
		public Elastic.Clients.Elasticsearch.Analysis.Analyzers? Analyzer { get; set; }

		[JsonInclude]
		[JsonPropertyName("char_filter")]
		public Elastic.Clients.Elasticsearch.Analysis.CharFilters? CharFilter { get; set; }

		[JsonInclude]
		[JsonPropertyName("filter")]
		public Elastic.Clients.Elasticsearch.Analysis.TokenFilters? Filter { get; set; }

		[JsonInclude]
		[JsonPropertyName("normalizer")]
		public Elastic.Clients.Elasticsearch.Analysis.Normalizers? Normalizer { get; set; }

		[JsonInclude]
		[JsonPropertyName("tokenizer")]
		public Elastic.Clients.Elasticsearch.Analysis.Tokenizers? Tokenizer { get; set; }
	}

	[JsonConverter(typeof(IndexSettingsAnalysisDescriptorConverter))]
	public partial class IndexSettingsAnalysisDescriptor : DescriptorBase<IndexSettingsAnalysisDescriptor>
	{
		internal Elastic.Clients.Elasticsearch.Analysis.Analyzers? _analyzer;
		internal Elastic.Clients.Elasticsearch.Analysis.CharFilters? _charFilter;
		internal Elastic.Clients.Elasticsearch.Analysis.TokenFilters? _filter;
		internal Elastic.Clients.Elasticsearch.Analysis.Normalizers? _normalizer;
		internal Elastic.Clients.Elasticsearch.Analysis.Tokenizers? _tokenizer;
	}

	internal sealed class IndexSettingsAnalysisDescriptorConverter : JsonConverter<IndexSettingsAnalysisDescriptor>
	{
		public override IndexSettingsAnalysisDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, IndexSettingsAnalysisDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value._analyzer is not null)
			{
				writer.WritePropertyName("analyzer");
				JsonSerializer.Serialize(writer, value._analyzer, options);
			}

			if (value._charFilter is not null)
			{
				writer.WritePropertyName("char_filter");
				JsonSerializer.Serialize(writer, value._charFilter, options);
			}

			if (value._filter is not null)
			{
				writer.WritePropertyName("filter");
				JsonSerializer.Serialize(writer, value._filter, options);
			}

			if (value._normalizer is not null)
			{
				writer.WritePropertyName("normalizer");
				JsonSerializer.Serialize(writer, value._normalizer, options);
			}

			if (value._tokenizer is not null)
			{
				writer.WritePropertyName("tokenizer");
				JsonSerializer.Serialize(writer, value._tokenizer, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class IndexSettingsLifecycle
	{
		[JsonInclude]
		[JsonPropertyName("name")]
		public Elastic.Clients.Elasticsearch.Name Name { get; set; }
	}

	public partial class IndexState
	{
		[JsonInclude]
		[JsonPropertyName("aliases")]
		public Dictionary<Elastic.Clients.Elasticsearch.IndexName, Elastic.Clients.Elasticsearch.IndexManagement.Alias>? Aliases { get; set; }

		[JsonInclude]
		[JsonPropertyName("mappings")]
		public Elastic.Clients.Elasticsearch.Mapping.TypeMapping? Mappings { get; set; }

		[JsonInclude]
		[JsonPropertyName("settings")]
		public Union<Elastic.Clients.Elasticsearch.IndexManagement.IndexSettings?, Elastic.Clients.Elasticsearch.IndexManagement.IndexStatePrefixedSettings?>? Settings { get; set; }

		[JsonInclude]
		[JsonPropertyName("data_stream")]
		public Elastic.Clients.Elasticsearch.DataStreamName? DataStream { get; set; }
	}

	[JsonConverter(typeof(IndexStateDescriptorConverter))]
	public partial class IndexStateDescriptor : DescriptorBase<IndexStateDescriptor>
	{
		internal Dictionary<Elastic.Clients.Elasticsearch.IndexName, Elastic.Clients.Elasticsearch.IndexManagement.Alias>? _aliases;
		internal Elastic.Clients.Elasticsearch.Mapping.TypeMapping? _mappings;
		internal Union<Elastic.Clients.Elasticsearch.IndexManagement.IndexSettings?, Elastic.Clients.Elasticsearch.IndexManagement.IndexStatePrefixedSettings?>? _settings;
		internal Elastic.Clients.Elasticsearch.DataStreamName? _dataStream;
	}

	internal sealed class IndexStateDescriptorConverter : JsonConverter<IndexStateDescriptor>
	{
		public override IndexStateDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, IndexStateDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value._aliases is not null)
			{
				writer.WritePropertyName("aliases");
				JsonSerializer.Serialize(writer, value._aliases, options);
			}

			if (value._mappings is not null)
			{
				writer.WritePropertyName("mappings");
				JsonSerializer.Serialize(writer, value._mappings, options);
			}

			if (value._settings is not null)
			{
				writer.WritePropertyName("settings");
				JsonSerializer.Serialize(writer, value._settings, options);
			}

			if (value._dataStream is not null)
			{
				writer.WritePropertyName("data_stream");
				JsonSerializer.Serialize(writer, value._dataStream, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class IndexStatePrefixedSettings
	{
		[JsonInclude]
		[JsonPropertyName("index")]
		public Elastic.Clients.Elasticsearch.IndexManagement.IndexSettings Index { get; set; }
	}

	public partial class IndexVersioning
	{
		[JsonInclude]
		[JsonPropertyName("created")]
		public string Created { get; set; }
	}

	public partial class NumericFielddata
	{
		[JsonInclude]
		[JsonPropertyName("format")]
		public Elastic.Clients.Elasticsearch.IndexManagement.NumericFielddataFormat Format { get; init; }
	}

	public partial class OverlappingIndexTemplate
	{
		[JsonInclude]
		[JsonPropertyName("name")]
		public Elastic.Clients.Elasticsearch.Name Name { get; set; }

		[JsonInclude]
		[JsonPropertyName("index_patterns")]
		public IEnumerable<Elastic.Clients.Elasticsearch.IndexName>? IndexPatterns { get; set; }
	}

	public partial class SoftDeletes
	{
		[JsonInclude]
		[JsonPropertyName("enabled")]
		public bool Enabled { get; set; }
	}

	public partial class StringFielddata
	{
		[JsonInclude]
		[JsonPropertyName("format")]
		public Elastic.Clients.Elasticsearch.IndexManagement.StringFielddataFormat Format { get; init; }
	}

	public partial class TemplateMapping
	{
		[JsonInclude]
		[JsonPropertyName("aliases")]
		public Dictionary<Elastic.Clients.Elasticsearch.IndexName, Elastic.Clients.Elasticsearch.IndexManagement.Alias> Aliases { get; set; }

		[JsonInclude]
		[JsonPropertyName("index_patterns")]
		public IEnumerable<Elastic.Clients.Elasticsearch.Name> IndexPatterns { get; set; }

		[JsonInclude]
		[JsonPropertyName("mappings")]
		public Elastic.Clients.Elasticsearch.Mapping.TypeMapping Mappings { get; set; }

		[JsonInclude]
		[JsonPropertyName("order")]
		public int Order { get; set; }

		[JsonInclude]
		[JsonPropertyName("settings")]
		public Dictionary<string, object> Settings { get; set; }

		[JsonInclude]
		[JsonPropertyName("version")]
		public object? Version { get; set; }
	}

	[JsonConverter(typeof(TemplateMappingDescriptorConverter))]
	public partial class TemplateMappingDescriptor : DescriptorBase<TemplateMappingDescriptor>
	{
		internal Dictionary<Elastic.Clients.Elasticsearch.IndexName, Elastic.Clients.Elasticsearch.IndexManagement.Alias> _aliases;
		internal IEnumerable<Elastic.Clients.Elasticsearch.Name> _indexPatterns;
		internal Elastic.Clients.Elasticsearch.Mapping.TypeMapping _mappings;
		internal int _order;
		internal Dictionary<string, object> _settings;
		internal object? _version;
	}

	internal sealed class TemplateMappingDescriptorConverter : JsonConverter<TemplateMappingDescriptor>
	{
		public override TemplateMappingDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, TemplateMappingDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("aliases");
			JsonSerializer.Serialize(writer, value._aliases, options);
			writer.WritePropertyName("index_patterns");
			JsonSerializer.Serialize(writer, value._indexPatterns, options);
			writer.WritePropertyName("mappings");
			JsonSerializer.Serialize(writer, value._mappings, options);
			writer.WritePropertyName("order");
			writer.WriteNumberValue(value._order);
			writer.WritePropertyName("settings");
			JsonSerializer.Serialize(writer, value._settings, options);
			if (value._version is not null)
			{
				writer.WritePropertyName("version");
				JsonSerializer.Serialize(writer, value._version, options);
			}

			writer.WriteEndObject();
		}
	}
}