// Licensed to Elasticsearch B.V under one or more agreements.
// Elasticsearch B.V licenses this file to you under the Apache 2.0 License.
// See the LICENSE file in the project root for more information.
//
// ███╗   ██╗ ██████╗ ████████╗██╗ ██████╗███████╗
// ████╗  ██║██╔═══██╗╚══██╔══╝██║██╔════╝██╔════╝
// ██╔██╗ ██║██║   ██║   ██║   ██║██║     █████╗
// ██║╚██╗██║██║   ██║   ██║   ██║██║     ██╔══╝
// ██║ ╚████║╚██████╔╝   ██║   ██║╚██████╗███████╗
// ╚═╝  ╚═══╝ ╚═════╝    ╚═╝   ╚═╝ ╚═════╝╚══════╝
// ------------------------------------------------
//
// This file is automatically generated.
// Please do not edit these files manually.
//
// ------------------------------------------------

#nullable restore

using Elastic.Clients.Elasticsearch.Fluent;
using Elastic.Clients.Elasticsearch.Serialization;
using System;
using System.Collections.Generic;
using System.Linq.Expressions;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace Elastic.Clients.Elasticsearch.MachineLearning;

public sealed partial class Detector
{
	/// <summary>
	/// <para>
	/// The field used to split the data. In particular, this property is used for analyzing the splits with respect to their own history. It is used for finding unusual values in the context of the split.
	/// </para>
	/// </summary>
	[JsonInclude, JsonPropertyName("by_field_name")]
	public Elastic.Clients.Elasticsearch.Field? ByFieldName { get; set; }

	/// <summary>
	/// <para>
	/// Custom rules enable you to customize the way detectors operate. For example, a rule may dictate conditions under which results should be skipped. Kibana refers to custom rules as job rules.
	/// </para>
	/// </summary>
	[JsonInclude, JsonPropertyName("custom_rules")]
	public ICollection<Elastic.Clients.Elasticsearch.MachineLearning.DetectionRule>? CustomRules { get; set; }

	/// <summary>
	/// <para>
	/// A description of the detector.
	/// </para>
	/// </summary>
	[JsonInclude, JsonPropertyName("detector_description")]
	public string? DetectorDescription { get; set; }

	/// <summary>
	/// <para>
	/// A unique identifier for the detector. This identifier is based on the order of the detectors in the <c>analysis_config</c>, starting at zero. If you specify a value for this property, it is ignored.
	/// </para>
	/// </summary>
	[JsonInclude, JsonPropertyName("detector_index")]
	public int? DetectorIndex { get; set; }

	/// <summary>
	/// <para>
	/// If set, frequent entities are excluded from influencing the anomaly results. Entities can be considered frequent over time or frequent in a population. If you are working with both over and by fields, you can set <c>exclude_frequent</c> to <c>all</c> for both fields, or to <c>by</c> or <c>over</c> for those specific fields.
	/// </para>
	/// </summary>
	[JsonInclude, JsonPropertyName("exclude_frequent")]
	public Elastic.Clients.Elasticsearch.MachineLearning.ExcludeFrequent? ExcludeFrequent { get; set; }

	/// <summary>
	/// <para>
	/// The field that the detector uses in the function. If you use an event rate function such as count or rare, do not specify this field. The <c>field_name</c> cannot contain double quotes or backslashes.
	/// </para>
	/// </summary>
	[JsonInclude, JsonPropertyName("field_name")]
	public Elastic.Clients.Elasticsearch.Field? FieldName { get; set; }

	/// <summary>
	/// <para>
	/// The analysis function that is used. For example, <c>count</c>, <c>rare</c>, <c>mean</c>, <c>min</c>, <c>max</c>, or <c>sum</c>.
	/// </para>
	/// </summary>
	[JsonInclude, JsonPropertyName("function")]
	public string? Function { get; set; }

	/// <summary>
	/// <para>
	/// The field used to split the data. In particular, this property is used for analyzing the splits with respect to the history of all splits. It is used for finding unusual values in the population of all splits.
	/// </para>
	/// </summary>
	[JsonInclude, JsonPropertyName("over_field_name")]
	public Elastic.Clients.Elasticsearch.Field? OverFieldName { get; set; }

	/// <summary>
	/// <para>
	/// The field used to segment the analysis. When you use this property, you have completely independent baselines for each value of this field.
	/// </para>
	/// </summary>
	[JsonInclude, JsonPropertyName("partition_field_name")]
	public Elastic.Clients.Elasticsearch.Field? PartitionFieldName { get; set; }

	/// <summary>
	/// <para>
	/// Defines whether a new series is used as the null series when there is no value for the by or partition fields.
	/// </para>
	/// </summary>
	[JsonInclude, JsonPropertyName("use_null")]
	public bool? UseNull { get; set; }
}

public sealed partial class DetectorDescriptor<TDocument> : SerializableDescriptor<DetectorDescriptor<TDocument>>
{
	internal DetectorDescriptor(Action<DetectorDescriptor<TDocument>> configure) => configure.Invoke(this);

	public DetectorDescriptor() : base()
	{
	}

	private Elastic.Clients.Elasticsearch.Field? ByFieldNameValue { get; set; }
	private ICollection<Elastic.Clients.Elasticsearch.MachineLearning.DetectionRule>? CustomRulesValue { get; set; }
	private Elastic.Clients.Elasticsearch.MachineLearning.DetectionRuleDescriptor<TDocument> CustomRulesDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.MachineLearning.DetectionRuleDescriptor<TDocument>> CustomRulesDescriptorAction { get; set; }
	private Action<Elastic.Clients.Elasticsearch.MachineLearning.DetectionRuleDescriptor<TDocument>>[] CustomRulesDescriptorActions { get; set; }
	private string? DetectorDescriptionValue { get; set; }
	private int? DetectorIndexValue { get; set; }
	private Elastic.Clients.Elasticsearch.MachineLearning.ExcludeFrequent? ExcludeFrequentValue { get; set; }
	private Elastic.Clients.Elasticsearch.Field? FieldNameValue { get; set; }
	private string? FunctionValue { get; set; }
	private Elastic.Clients.Elasticsearch.Field? OverFieldNameValue { get; set; }
	private Elastic.Clients.Elasticsearch.Field? PartitionFieldNameValue { get; set; }
	private bool? UseNullValue { get; set; }

	/// <summary>
	/// <para>
	/// The field used to split the data. In particular, this property is used for analyzing the splits with respect to their own history. It is used for finding unusual values in the context of the split.
	/// </para>
	/// </summary>
	public DetectorDescriptor<TDocument> ByFieldName(Elastic.Clients.Elasticsearch.Field? byFieldName)
	{
		ByFieldNameValue = byFieldName;
		return Self;
	}

	/// <summary>
	/// <para>
	/// The field used to split the data. In particular, this property is used for analyzing the splits with respect to their own history. It is used for finding unusual values in the context of the split.
	/// </para>
	/// </summary>
	public DetectorDescriptor<TDocument> ByFieldName<TValue>(Expression<Func<TDocument, TValue>> byFieldName)
	{
		ByFieldNameValue = byFieldName;
		return Self;
	}

	/// <summary>
	/// <para>
	/// The field used to split the data. In particular, this property is used for analyzing the splits with respect to their own history. It is used for finding unusual values in the context of the split.
	/// </para>
	/// </summary>
	public DetectorDescriptor<TDocument> ByFieldName(Expression<Func<TDocument, object>> byFieldName)
	{
		ByFieldNameValue = byFieldName;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Custom rules enable you to customize the way detectors operate. For example, a rule may dictate conditions under which results should be skipped. Kibana refers to custom rules as job rules.
	/// </para>
	/// </summary>
	public DetectorDescriptor<TDocument> CustomRules(ICollection<Elastic.Clients.Elasticsearch.MachineLearning.DetectionRule>? customRules)
	{
		CustomRulesDescriptor = null;
		CustomRulesDescriptorAction = null;
		CustomRulesDescriptorActions = null;
		CustomRulesValue = customRules;
		return Self;
	}

	public DetectorDescriptor<TDocument> CustomRules(Elastic.Clients.Elasticsearch.MachineLearning.DetectionRuleDescriptor<TDocument> descriptor)
	{
		CustomRulesValue = null;
		CustomRulesDescriptorAction = null;
		CustomRulesDescriptorActions = null;
		CustomRulesDescriptor = descriptor;
		return Self;
	}

	public DetectorDescriptor<TDocument> CustomRules(Action<Elastic.Clients.Elasticsearch.MachineLearning.DetectionRuleDescriptor<TDocument>> configure)
	{
		CustomRulesValue = null;
		CustomRulesDescriptor = null;
		CustomRulesDescriptorActions = null;
		CustomRulesDescriptorAction = configure;
		return Self;
	}

	public DetectorDescriptor<TDocument> CustomRules(params Action<Elastic.Clients.Elasticsearch.MachineLearning.DetectionRuleDescriptor<TDocument>>[] configure)
	{
		CustomRulesValue = null;
		CustomRulesDescriptor = null;
		CustomRulesDescriptorAction = null;
		CustomRulesDescriptorActions = configure;
		return Self;
	}

	/// <summary>
	/// <para>
	/// A description of the detector.
	/// </para>
	/// </summary>
	public DetectorDescriptor<TDocument> DetectorDescription(string? detectorDescription)
	{
		DetectorDescriptionValue = detectorDescription;
		return Self;
	}

	/// <summary>
	/// <para>
	/// A unique identifier for the detector. This identifier is based on the order of the detectors in the <c>analysis_config</c>, starting at zero. If you specify a value for this property, it is ignored.
	/// </para>
	/// </summary>
	public DetectorDescriptor<TDocument> DetectorIndex(int? detectorIndex)
	{
		DetectorIndexValue = detectorIndex;
		return Self;
	}

	/// <summary>
	/// <para>
	/// If set, frequent entities are excluded from influencing the anomaly results. Entities can be considered frequent over time or frequent in a population. If you are working with both over and by fields, you can set <c>exclude_frequent</c> to <c>all</c> for both fields, or to <c>by</c> or <c>over</c> for those specific fields.
	/// </para>
	/// </summary>
	public DetectorDescriptor<TDocument> ExcludeFrequent(Elastic.Clients.Elasticsearch.MachineLearning.ExcludeFrequent? excludeFrequent)
	{
		ExcludeFrequentValue = excludeFrequent;
		return Self;
	}

	/// <summary>
	/// <para>
	/// The field that the detector uses in the function. If you use an event rate function such as count or rare, do not specify this field. The <c>field_name</c> cannot contain double quotes or backslashes.
	/// </para>
	/// </summary>
	public DetectorDescriptor<TDocument> FieldName(Elastic.Clients.Elasticsearch.Field? fieldName)
	{
		FieldNameValue = fieldName;
		return Self;
	}

	/// <summary>
	/// <para>
	/// The field that the detector uses in the function. If you use an event rate function such as count or rare, do not specify this field. The <c>field_name</c> cannot contain double quotes or backslashes.
	/// </para>
	/// </summary>
	public DetectorDescriptor<TDocument> FieldName<TValue>(Expression<Func<TDocument, TValue>> fieldName)
	{
		FieldNameValue = fieldName;
		return Self;
	}

	/// <summary>
	/// <para>
	/// The field that the detector uses in the function. If you use an event rate function such as count or rare, do not specify this field. The <c>field_name</c> cannot contain double quotes or backslashes.
	/// </para>
	/// </summary>
	public DetectorDescriptor<TDocument> FieldName(Expression<Func<TDocument, object>> fieldName)
	{
		FieldNameValue = fieldName;
		return Self;
	}

	/// <summary>
	/// <para>
	/// The analysis function that is used. For example, <c>count</c>, <c>rare</c>, <c>mean</c>, <c>min</c>, <c>max</c>, or <c>sum</c>.
	/// </para>
	/// </summary>
	public DetectorDescriptor<TDocument> Function(string? function)
	{
		FunctionValue = function;
		return Self;
	}

	/// <summary>
	/// <para>
	/// The field used to split the data. In particular, this property is used for analyzing the splits with respect to the history of all splits. It is used for finding unusual values in the population of all splits.
	/// </para>
	/// </summary>
	public DetectorDescriptor<TDocument> OverFieldName(Elastic.Clients.Elasticsearch.Field? overFieldName)
	{
		OverFieldNameValue = overFieldName;
		return Self;
	}

	/// <summary>
	/// <para>
	/// The field used to split the data. In particular, this property is used for analyzing the splits with respect to the history of all splits. It is used for finding unusual values in the population of all splits.
	/// </para>
	/// </summary>
	public DetectorDescriptor<TDocument> OverFieldName<TValue>(Expression<Func<TDocument, TValue>> overFieldName)
	{
		OverFieldNameValue = overFieldName;
		return Self;
	}

	/// <summary>
	/// <para>
	/// The field used to split the data. In particular, this property is used for analyzing the splits with respect to the history of all splits. It is used for finding unusual values in the population of all splits.
	/// </para>
	/// </summary>
	public DetectorDescriptor<TDocument> OverFieldName(Expression<Func<TDocument, object>> overFieldName)
	{
		OverFieldNameValue = overFieldName;
		return Self;
	}

	/// <summary>
	/// <para>
	/// The field used to segment the analysis. When you use this property, you have completely independent baselines for each value of this field.
	/// </para>
	/// </summary>
	public DetectorDescriptor<TDocument> PartitionFieldName(Elastic.Clients.Elasticsearch.Field? partitionFieldName)
	{
		PartitionFieldNameValue = partitionFieldName;
		return Self;
	}

	/// <summary>
	/// <para>
	/// The field used to segment the analysis. When you use this property, you have completely independent baselines for each value of this field.
	/// </para>
	/// </summary>
	public DetectorDescriptor<TDocument> PartitionFieldName<TValue>(Expression<Func<TDocument, TValue>> partitionFieldName)
	{
		PartitionFieldNameValue = partitionFieldName;
		return Self;
	}

	/// <summary>
	/// <para>
	/// The field used to segment the analysis. When you use this property, you have completely independent baselines for each value of this field.
	/// </para>
	/// </summary>
	public DetectorDescriptor<TDocument> PartitionFieldName(Expression<Func<TDocument, object>> partitionFieldName)
	{
		PartitionFieldNameValue = partitionFieldName;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Defines whether a new series is used as the null series when there is no value for the by or partition fields.
	/// </para>
	/// </summary>
	public DetectorDescriptor<TDocument> UseNull(bool? useNull = true)
	{
		UseNullValue = useNull;
		return Self;
	}

	protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
	{
		writer.WriteStartObject();
		if (ByFieldNameValue is not null)
		{
			writer.WritePropertyName("by_field_name");
			JsonSerializer.Serialize(writer, ByFieldNameValue, options);
		}

		if (CustomRulesDescriptor is not null)
		{
			writer.WritePropertyName("custom_rules");
			writer.WriteStartArray();
			JsonSerializer.Serialize(writer, CustomRulesDescriptor, options);
			writer.WriteEndArray();
		}
		else if (CustomRulesDescriptorAction is not null)
		{
			writer.WritePropertyName("custom_rules");
			writer.WriteStartArray();
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.MachineLearning.DetectionRuleDescriptor<TDocument>(CustomRulesDescriptorAction), options);
			writer.WriteEndArray();
		}
		else if (CustomRulesDescriptorActions is not null)
		{
			writer.WritePropertyName("custom_rules");
			writer.WriteStartArray();
			foreach (var action in CustomRulesDescriptorActions)
			{
				JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.MachineLearning.DetectionRuleDescriptor<TDocument>(action), options);
			}

			writer.WriteEndArray();
		}
		else if (CustomRulesValue is not null)
		{
			writer.WritePropertyName("custom_rules");
			JsonSerializer.Serialize(writer, CustomRulesValue, options);
		}

		if (!string.IsNullOrEmpty(DetectorDescriptionValue))
		{
			writer.WritePropertyName("detector_description");
			writer.WriteStringValue(DetectorDescriptionValue);
		}

		if (DetectorIndexValue.HasValue)
		{
			writer.WritePropertyName("detector_index");
			writer.WriteNumberValue(DetectorIndexValue.Value);
		}

		if (ExcludeFrequentValue is not null)
		{
			writer.WritePropertyName("exclude_frequent");
			JsonSerializer.Serialize(writer, ExcludeFrequentValue, options);
		}

		if (FieldNameValue is not null)
		{
			writer.WritePropertyName("field_name");
			JsonSerializer.Serialize(writer, FieldNameValue, options);
		}

		if (!string.IsNullOrEmpty(FunctionValue))
		{
			writer.WritePropertyName("function");
			writer.WriteStringValue(FunctionValue);
		}

		if (OverFieldNameValue is not null)
		{
			writer.WritePropertyName("over_field_name");
			JsonSerializer.Serialize(writer, OverFieldNameValue, options);
		}

		if (PartitionFieldNameValue is not null)
		{
			writer.WritePropertyName("partition_field_name");
			JsonSerializer.Serialize(writer, PartitionFieldNameValue, options);
		}

		if (UseNullValue.HasValue)
		{
			writer.WritePropertyName("use_null");
			writer.WriteBooleanValue(UseNullValue.Value);
		}

		writer.WriteEndObject();
	}
}

public sealed partial class DetectorDescriptor : SerializableDescriptor<DetectorDescriptor>
{
	internal DetectorDescriptor(Action<DetectorDescriptor> configure) => configure.Invoke(this);

	public DetectorDescriptor() : base()
	{
	}

	private Elastic.Clients.Elasticsearch.Field? ByFieldNameValue { get; set; }
	private ICollection<Elastic.Clients.Elasticsearch.MachineLearning.DetectionRule>? CustomRulesValue { get; set; }
	private Elastic.Clients.Elasticsearch.MachineLearning.DetectionRuleDescriptor CustomRulesDescriptor { get; set; }
	private Action<Elastic.Clients.Elasticsearch.MachineLearning.DetectionRuleDescriptor> CustomRulesDescriptorAction { get; set; }
	private Action<Elastic.Clients.Elasticsearch.MachineLearning.DetectionRuleDescriptor>[] CustomRulesDescriptorActions { get; set; }
	private string? DetectorDescriptionValue { get; set; }
	private int? DetectorIndexValue { get; set; }
	private Elastic.Clients.Elasticsearch.MachineLearning.ExcludeFrequent? ExcludeFrequentValue { get; set; }
	private Elastic.Clients.Elasticsearch.Field? FieldNameValue { get; set; }
	private string? FunctionValue { get; set; }
	private Elastic.Clients.Elasticsearch.Field? OverFieldNameValue { get; set; }
	private Elastic.Clients.Elasticsearch.Field? PartitionFieldNameValue { get; set; }
	private bool? UseNullValue { get; set; }

	/// <summary>
	/// <para>
	/// The field used to split the data. In particular, this property is used for analyzing the splits with respect to their own history. It is used for finding unusual values in the context of the split.
	/// </para>
	/// </summary>
	public DetectorDescriptor ByFieldName(Elastic.Clients.Elasticsearch.Field? byFieldName)
	{
		ByFieldNameValue = byFieldName;
		return Self;
	}

	/// <summary>
	/// <para>
	/// The field used to split the data. In particular, this property is used for analyzing the splits with respect to their own history. It is used for finding unusual values in the context of the split.
	/// </para>
	/// </summary>
	public DetectorDescriptor ByFieldName<TDocument, TValue>(Expression<Func<TDocument, TValue>> byFieldName)
	{
		ByFieldNameValue = byFieldName;
		return Self;
	}

	/// <summary>
	/// <para>
	/// The field used to split the data. In particular, this property is used for analyzing the splits with respect to their own history. It is used for finding unusual values in the context of the split.
	/// </para>
	/// </summary>
	public DetectorDescriptor ByFieldName<TDocument>(Expression<Func<TDocument, object>> byFieldName)
	{
		ByFieldNameValue = byFieldName;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Custom rules enable you to customize the way detectors operate. For example, a rule may dictate conditions under which results should be skipped. Kibana refers to custom rules as job rules.
	/// </para>
	/// </summary>
	public DetectorDescriptor CustomRules(ICollection<Elastic.Clients.Elasticsearch.MachineLearning.DetectionRule>? customRules)
	{
		CustomRulesDescriptor = null;
		CustomRulesDescriptorAction = null;
		CustomRulesDescriptorActions = null;
		CustomRulesValue = customRules;
		return Self;
	}

	public DetectorDescriptor CustomRules(Elastic.Clients.Elasticsearch.MachineLearning.DetectionRuleDescriptor descriptor)
	{
		CustomRulesValue = null;
		CustomRulesDescriptorAction = null;
		CustomRulesDescriptorActions = null;
		CustomRulesDescriptor = descriptor;
		return Self;
	}

	public DetectorDescriptor CustomRules(Action<Elastic.Clients.Elasticsearch.MachineLearning.DetectionRuleDescriptor> configure)
	{
		CustomRulesValue = null;
		CustomRulesDescriptor = null;
		CustomRulesDescriptorActions = null;
		CustomRulesDescriptorAction = configure;
		return Self;
	}

	public DetectorDescriptor CustomRules(params Action<Elastic.Clients.Elasticsearch.MachineLearning.DetectionRuleDescriptor>[] configure)
	{
		CustomRulesValue = null;
		CustomRulesDescriptor = null;
		CustomRulesDescriptorAction = null;
		CustomRulesDescriptorActions = configure;
		return Self;
	}

	/// <summary>
	/// <para>
	/// A description of the detector.
	/// </para>
	/// </summary>
	public DetectorDescriptor DetectorDescription(string? detectorDescription)
	{
		DetectorDescriptionValue = detectorDescription;
		return Self;
	}

	/// <summary>
	/// <para>
	/// A unique identifier for the detector. This identifier is based on the order of the detectors in the <c>analysis_config</c>, starting at zero. If you specify a value for this property, it is ignored.
	/// </para>
	/// </summary>
	public DetectorDescriptor DetectorIndex(int? detectorIndex)
	{
		DetectorIndexValue = detectorIndex;
		return Self;
	}

	/// <summary>
	/// <para>
	/// If set, frequent entities are excluded from influencing the anomaly results. Entities can be considered frequent over time or frequent in a population. If you are working with both over and by fields, you can set <c>exclude_frequent</c> to <c>all</c> for both fields, or to <c>by</c> or <c>over</c> for those specific fields.
	/// </para>
	/// </summary>
	public DetectorDescriptor ExcludeFrequent(Elastic.Clients.Elasticsearch.MachineLearning.ExcludeFrequent? excludeFrequent)
	{
		ExcludeFrequentValue = excludeFrequent;
		return Self;
	}

	/// <summary>
	/// <para>
	/// The field that the detector uses in the function. If you use an event rate function such as count or rare, do not specify this field. The <c>field_name</c> cannot contain double quotes or backslashes.
	/// </para>
	/// </summary>
	public DetectorDescriptor FieldName(Elastic.Clients.Elasticsearch.Field? fieldName)
	{
		FieldNameValue = fieldName;
		return Self;
	}

	/// <summary>
	/// <para>
	/// The field that the detector uses in the function. If you use an event rate function such as count or rare, do not specify this field. The <c>field_name</c> cannot contain double quotes or backslashes.
	/// </para>
	/// </summary>
	public DetectorDescriptor FieldName<TDocument, TValue>(Expression<Func<TDocument, TValue>> fieldName)
	{
		FieldNameValue = fieldName;
		return Self;
	}

	/// <summary>
	/// <para>
	/// The field that the detector uses in the function. If you use an event rate function such as count or rare, do not specify this field. The <c>field_name</c> cannot contain double quotes or backslashes.
	/// </para>
	/// </summary>
	public DetectorDescriptor FieldName<TDocument>(Expression<Func<TDocument, object>> fieldName)
	{
		FieldNameValue = fieldName;
		return Self;
	}

	/// <summary>
	/// <para>
	/// The analysis function that is used. For example, <c>count</c>, <c>rare</c>, <c>mean</c>, <c>min</c>, <c>max</c>, or <c>sum</c>.
	/// </para>
	/// </summary>
	public DetectorDescriptor Function(string? function)
	{
		FunctionValue = function;
		return Self;
	}

	/// <summary>
	/// <para>
	/// The field used to split the data. In particular, this property is used for analyzing the splits with respect to the history of all splits. It is used for finding unusual values in the population of all splits.
	/// </para>
	/// </summary>
	public DetectorDescriptor OverFieldName(Elastic.Clients.Elasticsearch.Field? overFieldName)
	{
		OverFieldNameValue = overFieldName;
		return Self;
	}

	/// <summary>
	/// <para>
	/// The field used to split the data. In particular, this property is used for analyzing the splits with respect to the history of all splits. It is used for finding unusual values in the population of all splits.
	/// </para>
	/// </summary>
	public DetectorDescriptor OverFieldName<TDocument, TValue>(Expression<Func<TDocument, TValue>> overFieldName)
	{
		OverFieldNameValue = overFieldName;
		return Self;
	}

	/// <summary>
	/// <para>
	/// The field used to split the data. In particular, this property is used for analyzing the splits with respect to the history of all splits. It is used for finding unusual values in the population of all splits.
	/// </para>
	/// </summary>
	public DetectorDescriptor OverFieldName<TDocument>(Expression<Func<TDocument, object>> overFieldName)
	{
		OverFieldNameValue = overFieldName;
		return Self;
	}

	/// <summary>
	/// <para>
	/// The field used to segment the analysis. When you use this property, you have completely independent baselines for each value of this field.
	/// </para>
	/// </summary>
	public DetectorDescriptor PartitionFieldName(Elastic.Clients.Elasticsearch.Field? partitionFieldName)
	{
		PartitionFieldNameValue = partitionFieldName;
		return Self;
	}

	/// <summary>
	/// <para>
	/// The field used to segment the analysis. When you use this property, you have completely independent baselines for each value of this field.
	/// </para>
	/// </summary>
	public DetectorDescriptor PartitionFieldName<TDocument, TValue>(Expression<Func<TDocument, TValue>> partitionFieldName)
	{
		PartitionFieldNameValue = partitionFieldName;
		return Self;
	}

	/// <summary>
	/// <para>
	/// The field used to segment the analysis. When you use this property, you have completely independent baselines for each value of this field.
	/// </para>
	/// </summary>
	public DetectorDescriptor PartitionFieldName<TDocument>(Expression<Func<TDocument, object>> partitionFieldName)
	{
		PartitionFieldNameValue = partitionFieldName;
		return Self;
	}

	/// <summary>
	/// <para>
	/// Defines whether a new series is used as the null series when there is no value for the by or partition fields.
	/// </para>
	/// </summary>
	public DetectorDescriptor UseNull(bool? useNull = true)
	{
		UseNullValue = useNull;
		return Self;
	}

	protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
	{
		writer.WriteStartObject();
		if (ByFieldNameValue is not null)
		{
			writer.WritePropertyName("by_field_name");
			JsonSerializer.Serialize(writer, ByFieldNameValue, options);
		}

		if (CustomRulesDescriptor is not null)
		{
			writer.WritePropertyName("custom_rules");
			writer.WriteStartArray();
			JsonSerializer.Serialize(writer, CustomRulesDescriptor, options);
			writer.WriteEndArray();
		}
		else if (CustomRulesDescriptorAction is not null)
		{
			writer.WritePropertyName("custom_rules");
			writer.WriteStartArray();
			JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.MachineLearning.DetectionRuleDescriptor(CustomRulesDescriptorAction), options);
			writer.WriteEndArray();
		}
		else if (CustomRulesDescriptorActions is not null)
		{
			writer.WritePropertyName("custom_rules");
			writer.WriteStartArray();
			foreach (var action in CustomRulesDescriptorActions)
			{
				JsonSerializer.Serialize(writer, new Elastic.Clients.Elasticsearch.MachineLearning.DetectionRuleDescriptor(action), options);
			}

			writer.WriteEndArray();
		}
		else if (CustomRulesValue is not null)
		{
			writer.WritePropertyName("custom_rules");
			JsonSerializer.Serialize(writer, CustomRulesValue, options);
		}

		if (!string.IsNullOrEmpty(DetectorDescriptionValue))
		{
			writer.WritePropertyName("detector_description");
			writer.WriteStringValue(DetectorDescriptionValue);
		}

		if (DetectorIndexValue.HasValue)
		{
			writer.WritePropertyName("detector_index");
			writer.WriteNumberValue(DetectorIndexValue.Value);
		}

		if (ExcludeFrequentValue is not null)
		{
			writer.WritePropertyName("exclude_frequent");
			JsonSerializer.Serialize(writer, ExcludeFrequentValue, options);
		}

		if (FieldNameValue is not null)
		{
			writer.WritePropertyName("field_name");
			JsonSerializer.Serialize(writer, FieldNameValue, options);
		}

		if (!string.IsNullOrEmpty(FunctionValue))
		{
			writer.WritePropertyName("function");
			writer.WriteStringValue(FunctionValue);
		}

		if (OverFieldNameValue is not null)
		{
			writer.WritePropertyName("over_field_name");
			JsonSerializer.Serialize(writer, OverFieldNameValue, options);
		}

		if (PartitionFieldNameValue is not null)
		{
			writer.WritePropertyName("partition_field_name");
			JsonSerializer.Serialize(writer, PartitionFieldNameValue, options);
		}

		if (UseNullValue.HasValue)
		{
			writer.WritePropertyName("use_null");
			writer.WriteBooleanValue(UseNullValue.Value);
		}

		writer.WriteEndObject();
	}
}