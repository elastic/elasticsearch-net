// Licensed to Elasticsearch B.V under one or more agreements.
// Elasticsearch B.V licenses this file to you under the Apache 2.0 License.
// See the LICENSE file in the project root for more information.
//
// ███╗   ██╗ ██████╗ ████████╗██╗ ██████╗███████╗
// ████╗  ██║██╔═══██╗╚══██╔══╝██║██╔════╝██╔════╝
// ██╔██╗ ██║██║   ██║   ██║   ██║██║     █████╗
// ██║╚██╗██║██║   ██║   ██║   ██║██║     ██╔══╝
// ██║ ╚████║╚██████╔╝   ██║   ██║╚██████╗███████╗
// ╚═╝  ╚═══╝ ╚═════╝    ╚═╝   ╚═╝ ╚═════╝╚══════╝
// ------------------------------------------------
//
// This file is automatically generated.
// Please do not edit these files manually.
//
// ------------------------------------------------

using System;
using System.Collections.Generic;
using System.Text.Json;
using System.Text.Json.Serialization;

#nullable restore
namespace Elastic.Clients.Elasticsearch.Aggregations
{
	public partial class AdjacencyMatrixAggregation : Aggregations.BucketAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "adjacency_matrix";
		[JsonInclude]
		[JsonPropertyName("filters")]
		public Dictionary<string, Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer>? Filters { get; set; }
	}

	public abstract partial class AggregateBase
	{
		[JsonInclude]
		[JsonPropertyName("meta")]
		public Dictionary<string, object>? Meta { get; init; }
	}

	public partial class Aggregation
	{
		[JsonInclude]
		[JsonPropertyName("meta")]
		public Dictionary<string, object>? Meta { get; set; }

		[JsonInclude]
		[JsonPropertyName("name")]
		public string? Name { get; set; }
	}

	public interface IAggregationContainerVariant
	{
		string AggregationContainerVariantName { get; }
	}

	[JsonConverter(typeof(AggregationContainerConverter))]
	public partial class AggregationContainer : IContainer
	{
		public AggregationContainer(IAggregationContainerVariant variant) => Variant = variant ?? throw new ArgumentNullException(nameof(variant));
		internal IAggregationContainerVariant Variant { get; }

		[JsonInclude]
		[JsonPropertyName("aggs")]
		public Dictionary<string, Elastic.Clients.Elasticsearch.Aggregations.AggregationContainer>? Aggs { get; set; }

		[JsonInclude]
		[JsonPropertyName("meta")]
		public Dictionary<string, object>? Meta { get; set; }
	}

	public class AggregationContainerConverter : JsonConverter<AggregationContainer>
	{
		public override AggregationContainer Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			reader.Read();
			if (reader.TokenType != JsonTokenType.PropertyName)
			{
				throw new JsonException();
			}

			var propertyName = reader.GetString();
			if (propertyName == "adjacency_matrix")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.AdjacencyMatrixAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "auto_date_histogram")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.AutoDateHistogramAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "avg")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.AverageAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "avg_bucket")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.AverageBucketAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "boxplot")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.BoxplotAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "bucket_script")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.BucketScriptAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "bucket_selector")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.BucketSelectorAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "bucket_sort")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.BucketSortAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "cardinality")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.CardinalityAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "children")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.ChildrenAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "composite")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.CompositeAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "cumulative_cardinality")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.CumulativeCardinalityAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "cumulative_sum")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.CumulativeSumAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "date_histogram")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.DateHistogramAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "date_range")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.DateRangeAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "derivative")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.DerivativeAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "diversified_sampler")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.DiversifiedSamplerAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "extended_stats")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.ExtendedStatsAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "extended_stats_bucket")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.ExtendedStatsBucketAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "filter")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "filters")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.FiltersAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "geo_bounds")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.GeoBoundsAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "geo_centroid")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.GeoCentroidAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "geo_distance")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.GeoDistanceAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "geohash_grid")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.GeoHashGridAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "geo_line")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.GeoLineAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "geotile_grid")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.GeoTileGridAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "global")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.GlobalAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "histogram")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.HistogramAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "ip_range")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.IpRangeAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "inference")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.InferenceAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "matrix_stats")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.MatrixStatsAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "max")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.MaxAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "max_bucket")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.MaxBucketAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "median_absolute_deviation")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.MedianAbsoluteDeviationAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "min")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.MinAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "min_bucket")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.MinBucketAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "missing")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.MissingAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "moving_avg")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.MovingAverageAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "moving_percentiles")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.MovingPercentilesAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "moving_fn")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.MovingFunctionAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "multi_terms")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.MultiTermsAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "nested")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.NestedAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "normalize")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.NormalizeAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "parent")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.ParentAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "percentile_ranks")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.PercentileRanksAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "percentiles")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.PercentilesAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "percentiles_bucket")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.PercentilesBucketAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "range")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.RangeAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "rare_terms")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.RareTermsAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "rate")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.RateAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "reverse_nested")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.ReverseNestedAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "sampler")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.SamplerAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "scripted_metric")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.ScriptedMetricAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "serial_diff")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.SerialDifferencingAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "significant_terms")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.SignificantTermsAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "significant_text")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.SignificantTextAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "stats")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.StatsAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "stats_bucket")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.StatsBucketAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "string_stats")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.StringStatsAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "sum")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.SumAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "sum_bucket")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.SumBucketAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "terms")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.TermsAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "top_hits")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.TopHitsAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "t_test")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.TTestAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "top_metrics")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.TopMetricsAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "value_count")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.ValueCountAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "weighted_avg")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.WeightedAverageAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "variable_width_histogram")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.VariableWidthHistogramAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			throw new JsonException();
		}

		public override void Write(Utf8JsonWriter writer, AggregationContainer value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName(value.Variant.AggregationContainerVariantName);
			switch (value.Variant)
			{
				case Elastic.Clients.Elasticsearch.Aggregations.AdjacencyMatrixAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.AutoDateHistogramAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.AverageAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.AverageBucketAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.BoxplotAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.BucketScriptAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.BucketSelectorAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.BucketSortAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.CardinalityAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.ChildrenAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.CompositeAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.CumulativeCardinalityAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.CumulativeSumAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.DateHistogramAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.DateRangeAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.DerivativeAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.DiversifiedSamplerAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.ExtendedStatsAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.ExtendedStatsBucketAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.FiltersAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.GeoBoundsAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.GeoCentroidAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.GeoDistanceAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.GeoHashGridAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.GeoLineAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.GeoTileGridAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.GlobalAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.HistogramAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.IpRangeAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.InferenceAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.MatrixStatsAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.MaxAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.MaxBucketAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.MedianAbsoluteDeviationAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.MinAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.MinBucketAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.MissingAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.MovingAverageAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.MovingPercentilesAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.MovingFunctionAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.MultiTermsAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.NestedAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.NormalizeAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.ParentAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.PercentileRanksAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.PercentilesAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.PercentilesBucketAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.RangeAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.RareTermsAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.RateAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.ReverseNestedAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.SamplerAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.ScriptedMetricAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.SerialDifferencingAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.SignificantTermsAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.SignificantTextAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.StatsAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.StatsBucketAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.StringStatsAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.SumAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.SumBucketAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.TermsAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.TopHitsAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.TTestAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.TopMetricsAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.ValueCountAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.WeightedAverageAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.VariableWidthHistogramAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
			}

			writer.WriteEndObject();
		}
	}

	public partial class AggregationRange
	{
		[JsonInclude]
		[JsonPropertyName("from")]
		public Union<double?, string?>? From { get; set; }

		[JsonInclude]
		[JsonPropertyName("key")]
		public string? Key { get; set; }

		[JsonInclude]
		[JsonPropertyName("to")]
		public Union<double?, string?>? To { get; set; }
	}

	[JsonConverter(typeof(AggregationRangeDescriptorConverter))]
	public partial class AggregationRangeDescriptor : DescriptorBase<AggregationRangeDescriptor>
	{
		internal Union<double?, string?>? _from;
		internal string? _key;
		internal Union<double?, string?>? _to;
		public AggregationRangeDescriptor From(Union<double?, string?>? from) => Assign(from, (a, v) => a._from = v);
		public AggregationRangeDescriptor Key(string? key) => Assign(key, (a, v) => a._key = v);
		public AggregationRangeDescriptor To(Union<double?, string?>? to) => Assign(to, (a, v) => a._to = v);
	}

	internal sealed class AggregationRangeDescriptorConverter : JsonConverter<AggregationRangeDescriptor>
	{
		public override AggregationRangeDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, AggregationRangeDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value._from is not null)
			{
				writer.WritePropertyName("from");
				JsonSerializer.Serialize(writer, value._from, options);
			}

			if (!string.IsNullOrEmpty(value._key))
			{
				writer.WritePropertyName("key");
				writer.WriteStringValue(value._key);
			}

			if (value._to is not null)
			{
				writer.WritePropertyName("to");
				JsonSerializer.Serialize(writer, value._to, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class AutoDateHistogramAggregate<TBucket> : Aggregations.MultiBucketAggregate<TBucket>
	{
		[JsonInclude]
		[JsonPropertyName("interval")]
		public string Interval { get; init; }
	}

	public partial class AutoDateHistogramAggregation : Aggregations.BucketAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "auto_date_histogram";
		[JsonInclude]
		[JsonPropertyName("buckets")]
		public int? Buckets { get; set; }

		[JsonInclude]
		[JsonPropertyName("field")]
		public string? Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("format")]
		public string? Format { get; set; }

		[JsonInclude]
		[JsonPropertyName("minimum_interval")]
		public Elastic.Clients.Elasticsearch.Aggregations.MinimumInterval? MinimumInterval { get; set; }

		[JsonInclude]
		[JsonPropertyName("missing")]
		public string? Missing { get; set; }

		[JsonInclude]
		[JsonPropertyName("offset")]
		public string? Offset { get; set; }

		[JsonInclude]
		[JsonPropertyName("params")]
		public Dictionary<string, object>? Params { get; set; }

		[JsonInclude]
		[JsonPropertyName("script")]
		public Elastic.Clients.Elasticsearch.Script? Script { get; set; }

		[JsonInclude]
		[JsonPropertyName("time_zone")]
		public string? TimeZone { get; set; }
	}

	public partial class AverageAggregation : Aggregations.FormatMetricAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "avg";
	}

	public partial class AverageBucketAggregation : Aggregations.PipelineAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "avg_bucket";
	}

	public partial class BoxPlotAggregate : Aggregations.AggregateBase
	{
		[JsonInclude]
		[JsonPropertyName("min")]
		public double Min { get; init; }

		[JsonInclude]
		[JsonPropertyName("max")]
		public double Max { get; init; }

		[JsonInclude]
		[JsonPropertyName("q1")]
		public double Q1 { get; init; }

		[JsonInclude]
		[JsonPropertyName("q2")]
		public double Q2 { get; init; }

		[JsonInclude]
		[JsonPropertyName("q3")]
		public double Q3 { get; init; }
	}

	public partial class BoxplotAggregation : Aggregations.MetricAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "boxplot";
		[JsonInclude]
		[JsonPropertyName("compression")]
		public double? Compression { get; set; }
	}

	public partial class BucketAggregate : Aggregations.AggregateBase
	{
		[JsonInclude]
		[JsonPropertyName("after_key")]
		public Dictionary<string, object> AfterKey { get; init; }

		[JsonInclude]
		[JsonPropertyName("bg_count")]
		public object BgCount { get; init; }

		[JsonInclude]
		[JsonPropertyName("doc_count")]
		public object DocCount { get; init; }

		[JsonInclude]
		[JsonPropertyName("doc_count_error_upper_bound")]
		public object DocCountErrorUpperBound { get; init; }

		[JsonInclude]
		[JsonPropertyName("sum_other_doc_count")]
		public object SumOtherDocCount { get; init; }

		[JsonInclude]
		[JsonPropertyName("interval")]
		public string Interval { get; init; }

		[JsonInclude]
		[JsonPropertyName("items")]
		public Elastic.Clients.Elasticsearch.Aggregations.Bucket Items { get; init; }
	}

	public abstract partial class BucketAggregationBase : Aggregations.Aggregation
	{
		[JsonInclude]
		[JsonPropertyName("aggregations")]
		public Dictionary<string, Elastic.Clients.Elasticsearch.Aggregations.AggregationContainer>? Aggregations { get; set; }
	}

	public partial class BucketScriptAggregation : Aggregations.PipelineAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "bucket_script";
		[JsonInclude]
		[JsonPropertyName("script")]
		public Elastic.Clients.Elasticsearch.Script? Script { get; set; }
	}

	public partial class BucketSelectorAggregation : Aggregations.PipelineAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "bucket_selector";
		[JsonInclude]
		[JsonPropertyName("script")]
		public Elastic.Clients.Elasticsearch.Script? Script { get; set; }
	}

	public partial class BucketSortAggregation : Aggregations.Aggregation, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "bucket_sort";
		[JsonInclude]
		[JsonPropertyName("from")]
		public int? From { get; set; }

		[JsonInclude]
		[JsonPropertyName("gap_policy")]
		public Elastic.Clients.Elasticsearch.Aggregations.GapPolicy? GapPolicy { get; set; }

		[JsonInclude]
		[JsonPropertyName("size")]
		public int? Size { get; set; }

		[JsonInclude]
		[JsonPropertyName("sort")]
		public Elastic.Clients.Elasticsearch.Sort? Sort { get; set; }
	}

	public partial class CardinalityAggregation : Aggregations.MetricAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "cardinality";
		[JsonInclude]
		[JsonPropertyName("precision_threshold")]
		public int? PrecisionThreshold { get; set; }

		[JsonInclude]
		[JsonPropertyName("rehash")]
		public bool? Rehash { get; set; }
	}

	public partial class ChildrenAggregation : Aggregations.BucketAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "children";
		[JsonInclude]
		[JsonPropertyName("type")]
		public string? Type { get; set; }
	}

	public partial class ChiSquareHeuristic
	{
		[JsonInclude]
		[JsonPropertyName("background_is_superset")]
		public bool BackgroundIsSuperset { get; set; }

		[JsonInclude]
		[JsonPropertyName("include_negatives")]
		public bool IncludeNegatives { get; set; }
	}

	public partial class ClassificationInferenceOptions
	{
		[JsonInclude]
		[JsonPropertyName("num_top_classes")]
		public int? NumTopClasses { get; set; }

		[JsonInclude]
		[JsonPropertyName("num_top_feature_importance_values")]
		public int? NumTopFeatureImportanceValues { get; set; }

		[JsonInclude]
		[JsonPropertyName("prediction_field_type")]
		public string? PredictionFieldType { get; set; }

		[JsonInclude]
		[JsonPropertyName("results_field")]
		public string? ResultsField { get; set; }

		[JsonInclude]
		[JsonPropertyName("top_classes_results_field")]
		public string? TopClassesResultsField { get; set; }
	}

	[JsonConverter(typeof(ClassificationInferenceOptionsDescriptorConverter))]
	public partial class ClassificationInferenceOptionsDescriptor : DescriptorBase<ClassificationInferenceOptionsDescriptor>
	{
		internal int? _numTopClasses;
		internal int? _numTopFeatureImportanceValues;
		internal string? _predictionFieldType;
		internal string? _resultsField;
		internal string? _topClassesResultsField;
		public ClassificationInferenceOptionsDescriptor NumTopClasses(int? numTopClasses) => Assign(numTopClasses, (a, v) => a._numTopClasses = v);
		public ClassificationInferenceOptionsDescriptor NumTopFeatureImportanceValues(int? numTopFeatureImportanceValues) => Assign(numTopFeatureImportanceValues, (a, v) => a._numTopFeatureImportanceValues = v);
		public ClassificationInferenceOptionsDescriptor PredictionFieldType(string? predictionFieldType) => Assign(predictionFieldType, (a, v) => a._predictionFieldType = v);
		public ClassificationInferenceOptionsDescriptor ResultsField(string? resultsField) => Assign(resultsField, (a, v) => a._resultsField = v);
		public ClassificationInferenceOptionsDescriptor TopClassesResultsField(string? topClassesResultsField) => Assign(topClassesResultsField, (a, v) => a._topClassesResultsField = v);
	}

	internal sealed class ClassificationInferenceOptionsDescriptorConverter : JsonConverter<ClassificationInferenceOptionsDescriptor>
	{
		public override ClassificationInferenceOptionsDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, ClassificationInferenceOptionsDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value._numTopClasses.HasValue)
			{
				writer.WritePropertyName("num_top_classes");
				writer.WriteNumberValue(value._numTopClasses.Value);
			}

			if (value._numTopFeatureImportanceValues.HasValue)
			{
				writer.WritePropertyName("num_top_feature_importance_values");
				writer.WriteNumberValue(value._numTopFeatureImportanceValues.Value);
			}

			if (!string.IsNullOrEmpty(value._predictionFieldType))
			{
				writer.WritePropertyName("prediction_field_type");
				writer.WriteStringValue(value._predictionFieldType);
			}

			if (!string.IsNullOrEmpty(value._resultsField))
			{
				writer.WritePropertyName("results_field");
				writer.WriteStringValue(value._resultsField);
			}

			if (!string.IsNullOrEmpty(value._topClassesResultsField))
			{
				writer.WritePropertyName("top_classes_results_field");
				writer.WriteStringValue(value._topClassesResultsField);
			}

			writer.WriteEndObject();
		}
	}

	public partial class CompositeAggregation : Aggregations.BucketAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "composite";
		[JsonInclude]
		[JsonPropertyName("after")]
		public Dictionary<string, object>? After { get; set; }

		[JsonInclude]
		[JsonPropertyName("size")]
		public int? Size { get; set; }

		[JsonInclude]
		[JsonPropertyName("sources")]
		public IEnumerable<Dictionary<string, Elastic.Clients.Elasticsearch.Aggregations.CompositeAggregationSource>>? Sources { get; set; }
	}

	public partial class CompositeAggregationSource
	{
		[JsonInclude]
		[JsonPropertyName("terms")]
		public Elastic.Clients.Elasticsearch.Aggregations.TermsAggregation? Terms { get; set; }

		[JsonInclude]
		[JsonPropertyName("histogram")]
		public Elastic.Clients.Elasticsearch.Aggregations.HistogramAggregation? Histogram { get; set; }

		[JsonInclude]
		[JsonPropertyName("date_histogram")]
		public Elastic.Clients.Elasticsearch.Aggregations.DateHistogramAggregation? DateHistogram { get; set; }

		[JsonInclude]
		[JsonPropertyName("geotile_grid")]
		public Elastic.Clients.Elasticsearch.Aggregations.GeoTileGridAggregation? GeotileGrid { get; set; }
	}

	[JsonConverter(typeof(CompositeAggregationSourceDescriptorConverter))]
	public partial class CompositeAggregationSourceDescriptor : DescriptorBase<CompositeAggregationSourceDescriptor>
	{
		internal Elastic.Clients.Elasticsearch.Aggregations.TermsAggregation? _terms;
		internal Elastic.Clients.Elasticsearch.Aggregations.HistogramAggregation? _histogram;
		internal Elastic.Clients.Elasticsearch.Aggregations.DateHistogramAggregation? _dateHistogram;
		internal Elastic.Clients.Elasticsearch.Aggregations.GeoTileGridAggregation? _geotileGrid;
		public CompositeAggregationSourceDescriptor Terms(Elastic.Clients.Elasticsearch.Aggregations.TermsAggregation? terms) => Assign(terms, (a, v) => a._terms = v);
		public CompositeAggregationSourceDescriptor Histogram(Elastic.Clients.Elasticsearch.Aggregations.HistogramAggregation? histogram) => Assign(histogram, (a, v) => a._histogram = v);
		public CompositeAggregationSourceDescriptor DateHistogram(Elastic.Clients.Elasticsearch.Aggregations.DateHistogramAggregation? dateHistogram) => Assign(dateHistogram, (a, v) => a._dateHistogram = v);
		public CompositeAggregationSourceDescriptor GeotileGrid(Elastic.Clients.Elasticsearch.Aggregations.GeoTileGridAggregation? geotileGrid) => Assign(geotileGrid, (a, v) => a._geotileGrid = v);
	}

	internal sealed class CompositeAggregationSourceDescriptorConverter : JsonConverter<CompositeAggregationSourceDescriptor>
	{
		public override CompositeAggregationSourceDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, CompositeAggregationSourceDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value._terms is not null)
			{
				writer.WritePropertyName("terms");
				JsonSerializer.Serialize(writer, value._terms, options);
			}

			if (value._histogram is not null)
			{
				writer.WritePropertyName("histogram");
				JsonSerializer.Serialize(writer, value._histogram, options);
			}

			if (value._dateHistogram is not null)
			{
				writer.WritePropertyName("date_histogram");
				JsonSerializer.Serialize(writer, value._dateHistogram, options);
			}

			if (value._geotileGrid is not null)
			{
				writer.WritePropertyName("geotile_grid");
				JsonSerializer.Serialize(writer, value._geotileGrid, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class CompositeBucket
	{
	}

	public partial class CompositeBucketAggregate<TBucket> : Aggregations.MultiBucketAggregate<TBucket>
	{
		[JsonInclude]
		[JsonPropertyName("after_key")]
		public Dictionary<string, object> AfterKey { get; init; }
	}

	public partial class CumulativeCardinalityAggregation : Aggregations.PipelineAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "cumulative_cardinality";
	}

	public partial class CumulativeSumAggregation : Aggregations.PipelineAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "cumulative_sum";
	}

	public partial class DateHistogramAggregation : Aggregations.BucketAggregationBase, IAggregationContainerVariant, TransformManagement.IPivotGroupByContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "date_histogram";
		[JsonIgnore]
		string TransformManagement.IPivotGroupByContainerVariant.PivotGroupByContainerVariantName => "date_histogram";
		[JsonInclude]
		[JsonPropertyName("calendar_interval")]
		public Union<Elastic.Clients.Elasticsearch.Aggregations.DateInterval?, Elastic.Clients.Elasticsearch.Time?>? CalendarInterval { get; set; }

		[JsonInclude]
		[JsonPropertyName("field")]
		public string? Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("fixed_interval")]
		public Union<Elastic.Clients.Elasticsearch.Aggregations.DateInterval?, Elastic.Clients.Elasticsearch.Time?>? FixedInterval { get; set; }

		[JsonInclude]
		[JsonPropertyName("format")]
		public string? Format { get; set; }

		[JsonInclude]
		[JsonPropertyName("interval")]
		public Union<Elastic.Clients.Elasticsearch.Aggregations.DateInterval?, Elastic.Clients.Elasticsearch.Time?>? Interval { get; set; }

		[JsonInclude]
		[JsonPropertyName("min_doc_count")]
		public int? MinDocCount { get; set; }

		[JsonInclude]
		[JsonPropertyName("missing")]
		public string? Missing { get; set; }

		[JsonInclude]
		[JsonPropertyName("offset")]
		public Elastic.Clients.Elasticsearch.Time? Offset { get; set; }

		[JsonInclude]
		[JsonPropertyName("order")]
		public Elastic.Clients.Elasticsearch.Aggregations.HistogramOrder? Order { get; set; }

		[JsonInclude]
		[JsonPropertyName("params")]
		public Dictionary<string, object>? Params { get; set; }

		[JsonInclude]
		[JsonPropertyName("script")]
		public Elastic.Clients.Elasticsearch.Script? Script { get; set; }

		[JsonInclude]
		[JsonPropertyName("time_zone")]
		public string? TimeZone { get; set; }

		[JsonInclude]
		[JsonPropertyName("keyed")]
		public bool? Keyed { get; set; }
	}

	public partial class DateHistogramBucket
	{
	}

	public partial class DateRangeAggregation : Aggregations.BucketAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "date_range";
		[JsonInclude]
		[JsonPropertyName("field")]
		public string? Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("format")]
		public string? Format { get; set; }

		[JsonInclude]
		[JsonPropertyName("missing")]
		public Elastic.Clients.Elasticsearch.Aggregations.Missing? Missing { get; set; }

		[JsonInclude]
		[JsonPropertyName("ranges")]
		public IEnumerable<Elastic.Clients.Elasticsearch.Aggregations.DateRangeExpression>? Ranges { get; set; }

		[JsonInclude]
		[JsonPropertyName("time_zone")]
		public string? TimeZone { get; set; }

		[JsonInclude]
		[JsonPropertyName("keyed")]
		public bool? Keyed { get; set; }
	}

	public partial class DateRangeExpression
	{
		[JsonInclude]
		[JsonPropertyName("from")]
		public Union<string?, float?>? From { get; set; }

		[JsonInclude]
		[JsonPropertyName("from_as_string")]
		public string? FromAsString { get; set; }

		[JsonInclude]
		[JsonPropertyName("to_as_string")]
		public string? ToAsString { get; set; }

		[JsonInclude]
		[JsonPropertyName("key")]
		public string? Key { get; set; }

		[JsonInclude]
		[JsonPropertyName("to")]
		public Union<string?, float?>? To { get; set; }

		[JsonInclude]
		[JsonPropertyName("doc_count")]
		public object? DocCount { get; set; }
	}

	[JsonConverter(typeof(DateRangeExpressionDescriptorConverter))]
	public partial class DateRangeExpressionDescriptor : DescriptorBase<DateRangeExpressionDescriptor>
	{
		internal Union<string?, float?>? _from;
		internal string? _fromAsString;
		internal string? _toAsString;
		internal string? _key;
		internal Union<string?, float?>? _to;
		internal object? _docCount;
		public DateRangeExpressionDescriptor From(Union<string?, float?>? from) => Assign(from, (a, v) => a._from = v);
		public DateRangeExpressionDescriptor FromAsString(string? fromAsString) => Assign(fromAsString, (a, v) => a._fromAsString = v);
		public DateRangeExpressionDescriptor ToAsString(string? toAsString) => Assign(toAsString, (a, v) => a._toAsString = v);
		public DateRangeExpressionDescriptor Key(string? key) => Assign(key, (a, v) => a._key = v);
		public DateRangeExpressionDescriptor To(Union<string?, float?>? to) => Assign(to, (a, v) => a._to = v);
		public DateRangeExpressionDescriptor DocCount(object? docCount) => Assign(docCount, (a, v) => a._docCount = v);
	}

	internal sealed class DateRangeExpressionDescriptorConverter : JsonConverter<DateRangeExpressionDescriptor>
	{
		public override DateRangeExpressionDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, DateRangeExpressionDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value._from is not null)
			{
				writer.WritePropertyName("from");
				JsonSerializer.Serialize(writer, value._from, options);
			}

			if (!string.IsNullOrEmpty(value._fromAsString))
			{
				writer.WritePropertyName("from_as_string");
				writer.WriteStringValue(value._fromAsString);
			}

			if (!string.IsNullOrEmpty(value._toAsString))
			{
				writer.WritePropertyName("to_as_string");
				writer.WriteStringValue(value._toAsString);
			}

			if (!string.IsNullOrEmpty(value._key))
			{
				writer.WritePropertyName("key");
				writer.WriteStringValue(value._key);
			}

			if (value._to is not null)
			{
				writer.WritePropertyName("to");
				JsonSerializer.Serialize(writer, value._to, options);
			}

			if (value._docCount is not null)
			{
				writer.WritePropertyName("doc_count");
				JsonSerializer.Serialize(writer, value._docCount, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class DerivativeAggregation : Aggregations.PipelineAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "derivative";
	}

	public partial class DiversifiedSamplerAggregation : Aggregations.BucketAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "diversified_sampler";
		[JsonInclude]
		[JsonPropertyName("execution_hint")]
		public Elastic.Clients.Elasticsearch.Aggregations.SamplerAggregationExecutionHint? ExecutionHint { get; set; }

		[JsonInclude]
		[JsonPropertyName("max_docs_per_value")]
		public int? MaxDocsPerValue { get; set; }

		[JsonInclude]
		[JsonPropertyName("script")]
		public Elastic.Clients.Elasticsearch.Script? Script { get; set; }

		[JsonInclude]
		[JsonPropertyName("shard_size")]
		public int? ShardSize { get; set; }

		[JsonInclude]
		[JsonPropertyName("field")]
		public string? Field { get; set; }
	}

	public partial class EwmaModelSettings
	{
		[JsonInclude]
		[JsonPropertyName("alpha")]
		public float? Alpha { get; init; }
	}

	public partial class ExtendedBounds<T>
	{
		[JsonInclude]
		[JsonPropertyName("max")]
		public T Max { get; set; }

		[JsonInclude]
		[JsonPropertyName("min")]
		public T Min { get; set; }
	}

	public partial class ExtendedStatsAggregate : Aggregations.StatsAggregate
	{
		[JsonInclude]
		[JsonPropertyName("std_deviation_bounds")]
		public Elastic.Clients.Elasticsearch.Aggregations.StandardDeviationBounds StdDeviationBounds { get; init; }

		[JsonInclude]
		[JsonPropertyName("sum_of_squares")]
		public double? SumOfSquares { get; init; }

		[JsonInclude]
		[JsonPropertyName("variance")]
		public double? Variance { get; init; }

		[JsonInclude]
		[JsonPropertyName("variance_population")]
		public double? VariancePopulation { get; init; }

		[JsonInclude]
		[JsonPropertyName("variance_sampling")]
		public double? VarianceSampling { get; init; }

		[JsonInclude]
		[JsonPropertyName("std_deviation")]
		public double? StdDeviation { get; init; }

		[JsonInclude]
		[JsonPropertyName("std_deviation_population")]
		public double? StdDeviationPopulation { get; init; }

		[JsonInclude]
		[JsonPropertyName("std_deviation_sampling")]
		public double? StdDeviationSampling { get; init; }
	}

	public partial class ExtendedStatsAggregation : Aggregations.FormatMetricAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "extended_stats";
		[JsonInclude]
		[JsonPropertyName("sigma")]
		public double? Sigma { get; set; }
	}

	public partial class ExtendedStatsBucketAggregation : Aggregations.PipelineAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "extended_stats_bucket";
		[JsonInclude]
		[JsonPropertyName("sigma")]
		public double? Sigma { get; set; }
	}

	public partial class FiltersAggregate : Aggregations.AggregateBase
	{
		[JsonInclude]
		[JsonPropertyName("buckets")]
		public Union<IReadOnlyCollection<Elastic.Clients.Elasticsearch.Aggregations.FiltersBucketItem>, Dictionary<string, Elastic.Clients.Elasticsearch.Aggregations.FiltersBucketItem>> Buckets { get; init; }
	}

	public partial class FiltersAggregation : Aggregations.BucketAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "filters";
		[JsonInclude]
		[JsonPropertyName("filters")]
		public Union<Dictionary<string, Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer>?, IEnumerable<Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer>?>? Filters { get; set; }

		[JsonInclude]
		[JsonPropertyName("other_bucket")]
		public bool? OtherBucket { get; set; }

		[JsonInclude]
		[JsonPropertyName("other_bucket_key")]
		public string? OtherBucketKey { get; set; }

		[JsonInclude]
		[JsonPropertyName("keyed")]
		public bool? Keyed { get; set; }
	}

	public partial class FiltersBucketItem
	{
		[JsonInclude]
		[JsonPropertyName("doc_count")]
		public object DocCount { get; init; }
	}

	public abstract partial class FormatMetricAggregationBase : Aggregations.MetricAggregationBase
	{
		[JsonInclude]
		[JsonPropertyName("format")]
		public string? Format { get; set; }
	}

	public partial class FormattableMetricAggregation : Aggregations.MetricAggregationBase
	{
		[JsonInclude]
		[JsonPropertyName("format")]
		public string? Format { get; set; }
	}

	public partial class GeoBounds
	{
		[JsonInclude]
		[JsonPropertyName("bottom_right")]
		public Elastic.Clients.Elasticsearch.LatLon BottomRight { get; set; }

		[JsonInclude]
		[JsonPropertyName("top_left")]
		public Elastic.Clients.Elasticsearch.LatLon TopLeft { get; set; }
	}

	public partial class GeoBoundsAggregate : Aggregations.AggregateBase
	{
		[JsonInclude]
		[JsonPropertyName("bounds")]
		public Elastic.Clients.Elasticsearch.Aggregations.GeoBounds Bounds { get; init; }
	}

	public partial class GeoBoundsAggregation : Aggregations.MetricAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "geo_bounds";
		[JsonInclude]
		[JsonPropertyName("wrap_longitude")]
		public bool? WrapLongitude { get; set; }
	}

	public partial class GeoCentroidAggregate : Aggregations.AggregateBase
	{
		[JsonInclude]
		[JsonPropertyName("count")]
		public object Count { get; init; }

		[JsonInclude]
		[JsonPropertyName("location")]
		public Elastic.Clients.Elasticsearch.QueryDsl.GeoLocation Location { get; init; }
	}

	public partial class GeoCentroidAggregation : Aggregations.MetricAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "geo_centroid";
		[JsonInclude]
		[JsonPropertyName("count")]
		public object? Count { get; set; }

		[JsonInclude]
		[JsonPropertyName("location")]
		public Elastic.Clients.Elasticsearch.QueryDsl.GeoLocation? Location { get; set; }
	}

	public partial class GeoDistanceAggregation : Aggregations.BucketAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "geo_distance";
		[JsonInclude]
		[JsonPropertyName("distance_type")]
		public Elastic.Clients.Elasticsearch.GeoDistanceType? DistanceType { get; set; }

		[JsonInclude]
		[JsonPropertyName("field")]
		public string? Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("origin")]
		public Union<Elastic.Clients.Elasticsearch.QueryDsl.GeoLocation?, string?>? Origin { get; set; }

		[JsonInclude]
		[JsonPropertyName("ranges")]
		public IEnumerable<Elastic.Clients.Elasticsearch.Aggregations.AggregationRange>? Ranges { get; set; }

		[JsonInclude]
		[JsonPropertyName("unit")]
		public Elastic.Clients.Elasticsearch.DistanceUnit? Unit { get; set; }
	}

	public partial class GeoHashGridAggregation : Aggregations.BucketAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "geohash_grid";
		[JsonInclude]
		[JsonPropertyName("bounds")]
		public Elastic.Clients.Elasticsearch.QueryDsl.BoundingBox? Bounds { get; set; }

		[JsonInclude]
		[JsonPropertyName("field")]
		public string? Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("precision")]
		public double? Precision { get; set; }

		[JsonInclude]
		[JsonPropertyName("shard_size")]
		public int? ShardSize { get; set; }

		[JsonInclude]
		[JsonPropertyName("size")]
		public int? Size { get; set; }
	}

	public partial class GeoLineAggregate : Aggregations.AggregateBase
	{
		[JsonInclude]
		[JsonPropertyName("type")]
		public string Type { get; init; }

		[JsonInclude]
		[JsonPropertyName("geometry")]
		public Elastic.Clients.Elasticsearch.Aggregations.LineStringGeoShape Geometry { get; init; }

		[JsonInclude]
		[JsonPropertyName("properties")]
		public Elastic.Clients.Elasticsearch.Aggregations.GeoLineProperties Properties { get; init; }
	}

	public partial class GeoLineAggregation : IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "geo_line";
		[JsonInclude]
		[JsonPropertyName("point")]
		public Elastic.Clients.Elasticsearch.Aggregations.GeoLinePoint Point { get; set; }

		[JsonInclude]
		[JsonPropertyName("sort")]
		public Elastic.Clients.Elasticsearch.Aggregations.GeoLineSort Sort { get; set; }

		[JsonInclude]
		[JsonPropertyName("include_sort")]
		public bool? IncludeSort { get; set; }

		[JsonInclude]
		[JsonPropertyName("sort_order")]
		public Elastic.Clients.Elasticsearch.SortOrder? SortOrder { get; set; }

		[JsonInclude]
		[JsonPropertyName("size")]
		public int? Size { get; set; }
	}

	public partial class GeoLinePoint
	{
		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }
	}

	public partial class GeoLineProperties
	{
		[JsonInclude]
		[JsonPropertyName("complete")]
		public bool Complete { get; init; }

		[JsonInclude]
		[JsonPropertyName("sort_values")]
		public IReadOnlyCollection<double> SortValues { get; init; }
	}

	public partial class GeoLineSort
	{
		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }
	}

	public partial class GeoTileGridAggregation : Aggregations.BucketAggregationBase, IAggregationContainerVariant, TransformManagement.IPivotGroupByContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "geotile_grid";
		[JsonIgnore]
		string TransformManagement.IPivotGroupByContainerVariant.PivotGroupByContainerVariantName => "geotile_grid";
		[JsonInclude]
		[JsonPropertyName("field")]
		public string? Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("precision")]
		public double? Precision { get; set; }

		[JsonInclude]
		[JsonPropertyName("shard_size")]
		public int? ShardSize { get; set; }

		[JsonInclude]
		[JsonPropertyName("size")]
		public int? Size { get; set; }

		[JsonInclude]
		[JsonPropertyName("bounds")]
		public Elastic.Clients.Elasticsearch.Aggregations.GeoBounds? Bounds { get; set; }
	}

	public partial class GlobalAggregation : Aggregations.BucketAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "global";
	}

	public partial class GoogleNormalizedDistanceHeuristic
	{
		[JsonInclude]
		[JsonPropertyName("background_is_superset")]
		public bool? BackgroundIsSuperset { get; set; }
	}

	public partial class HdrMethod
	{
		[JsonInclude]
		[JsonPropertyName("number_of_significant_value_digits")]
		public int? NumberOfSignificantValueDigits { get; set; }
	}

	public partial class HdrPercentileItem
	{
		[JsonInclude]
		[JsonPropertyName("key")]
		public double Key { get; init; }

		[JsonInclude]
		[JsonPropertyName("value")]
		public double Value { get; init; }
	}

	public partial class HdrPercentilesAggregate : Aggregations.AggregateBase
	{
		[JsonInclude]
		[JsonPropertyName("values")]
		public IReadOnlyCollection<Elastic.Clients.Elasticsearch.Aggregations.HdrPercentileItem> Values { get; init; }
	}

	public partial class HistogramAggregation : Aggregations.BucketAggregationBase, IAggregationContainerVariant, TransformManagement.IPivotGroupByContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "histogram";
		[JsonIgnore]
		string TransformManagement.IPivotGroupByContainerVariant.PivotGroupByContainerVariantName => "histogram";
		[JsonInclude]
		[JsonPropertyName("field")]
		public string? Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("interval")]
		public double? Interval { get; set; }

		[JsonInclude]
		[JsonPropertyName("min_doc_count")]
		public int? MinDocCount { get; set; }

		[JsonInclude]
		[JsonPropertyName("missing")]
		public double? Missing { get; set; }

		[JsonInclude]
		[JsonPropertyName("offset")]
		public double? Offset { get; set; }

		[JsonInclude]
		[JsonPropertyName("order")]
		public Elastic.Clients.Elasticsearch.Aggregations.HistogramOrder? Order { get; set; }

		[JsonInclude]
		[JsonPropertyName("script")]
		public Elastic.Clients.Elasticsearch.Script? Script { get; set; }

		[JsonInclude]
		[JsonPropertyName("format")]
		public string? Format { get; set; }

		[JsonInclude]
		[JsonPropertyName("keyed")]
		public bool? Keyed { get; set; }
	}

	public partial class HistogramOrder
	{
		[JsonInclude]
		[JsonPropertyName("_count")]
		public Elastic.Clients.Elasticsearch.SortOrder? Count { get; set; }

		[JsonInclude]
		[JsonPropertyName("_key")]
		public Elastic.Clients.Elasticsearch.SortOrder? Key { get; set; }
	}

	public partial class HoltLinearModelSettings
	{
		[JsonInclude]
		[JsonPropertyName("alpha")]
		public float? Alpha { get; init; }

		[JsonInclude]
		[JsonPropertyName("beta")]
		public float? Beta { get; init; }
	}

	public partial class HoltWintersModelSettings
	{
		[JsonInclude]
		[JsonPropertyName("alpha")]
		public float? Alpha { get; init; }

		[JsonInclude]
		[JsonPropertyName("beta")]
		public float? Beta { get; init; }

		[JsonInclude]
		[JsonPropertyName("gamma")]
		public float? Gamma { get; init; }

		[JsonInclude]
		[JsonPropertyName("pad")]
		public bool? Pad { get; init; }

		[JsonInclude]
		[JsonPropertyName("period")]
		public int? Period { get; init; }

		[JsonInclude]
		[JsonPropertyName("type")]
		public Elastic.Clients.Elasticsearch.Aggregations.HoltWintersType? Type { get; init; }
	}

	public partial class InferenceAggregation : Aggregations.PipelineAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "inference";
		[JsonInclude]
		[JsonPropertyName("model_id")]
		public Elastic.Clients.Elasticsearch.Name ModelId { get; set; }

		[JsonInclude]
		[JsonPropertyName("inference_config")]
		public Elastic.Clients.Elasticsearch.Aggregations.InferenceConfigContainer? InferenceConfig { get; set; }
	}

	public partial class InferenceConfigContainer
	{
		[JsonInclude]
		[JsonPropertyName("regression")]
		public Elastic.Clients.Elasticsearch.Aggregations.RegressionInferenceOptions? Regression { get; set; }

		[JsonInclude]
		[JsonPropertyName("classification")]
		public Elastic.Clients.Elasticsearch.Aggregations.ClassificationInferenceOptions? Classification { get; set; }
	}

	public partial class IpRangeAggregation : Aggregations.BucketAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "ip_range";
		[JsonInclude]
		[JsonPropertyName("field")]
		public string? Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("ranges")]
		public IEnumerable<Elastic.Clients.Elasticsearch.Aggregations.IpRangeAggregationRange>? Ranges { get; set; }
	}

	public partial class IpRangeAggregationRange
	{
		[JsonInclude]
		[JsonPropertyName("from")]
		public string? From { get; set; }

		[JsonInclude]
		[JsonPropertyName("mask")]
		public string? Mask { get; set; }

		[JsonInclude]
		[JsonPropertyName("to")]
		public string? To { get; set; }
	}

	[JsonConverter(typeof(IpRangeAggregationRangeDescriptorConverter))]
	public partial class IpRangeAggregationRangeDescriptor : DescriptorBase<IpRangeAggregationRangeDescriptor>
	{
		internal string? _from;
		internal string? _mask;
		internal string? _to;
		public IpRangeAggregationRangeDescriptor From(string? from) => Assign(from, (a, v) => a._from = v);
		public IpRangeAggregationRangeDescriptor Mask(string? mask) => Assign(mask, (a, v) => a._mask = v);
		public IpRangeAggregationRangeDescriptor To(string? to) => Assign(to, (a, v) => a._to = v);
	}

	internal sealed class IpRangeAggregationRangeDescriptorConverter : JsonConverter<IpRangeAggregationRangeDescriptor>
	{
		public override IpRangeAggregationRangeDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, IpRangeAggregationRangeDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (!string.IsNullOrEmpty(value._from))
			{
				writer.WritePropertyName("from");
				writer.WriteStringValue(value._from);
			}

			if (!string.IsNullOrEmpty(value._mask))
			{
				writer.WritePropertyName("mask");
				writer.WriteStringValue(value._mask);
			}

			if (!string.IsNullOrEmpty(value._to))
			{
				writer.WritePropertyName("to");
				writer.WriteStringValue(value._to);
			}

			writer.WriteEndObject();
		}
	}

	public partial class IpRangeBucket
	{
	}

	public partial class KeyedBucket<TKey>
	{
		[JsonInclude]
		[JsonPropertyName("doc_count")]
		public object DocCount { get; init; }

		[JsonInclude]
		[JsonPropertyName("key")]
		public TKey Key { get; init; }

		[JsonInclude]
		[JsonPropertyName("key_as_string")]
		public string KeyAsString { get; init; }
	}

	public partial class KeyedValueAggregate : Aggregations.ValueAggregate
	{
		[JsonInclude]
		[JsonPropertyName("keys")]
		public IReadOnlyCollection<string> Keys { get; init; }
	}

	public partial class LineStringGeoShape
	{
		[JsonInclude]
		[JsonPropertyName("coordinates")]
		public IReadOnlyCollection<Elastic.Clients.Elasticsearch.QueryDsl.GeoCoordinate> Coordinates { get; init; }
	}

	public partial class MatrixAggregation : Aggregations.Aggregation
	{
		[JsonInclude]
		[JsonPropertyName("fields")]
		public Elastic.Clients.Elasticsearch.Fields? Fields { get; set; }

		[JsonInclude]
		[JsonPropertyName("missing")]
		public Dictionary<string, double>? Missing { get; set; }
	}

	public partial class MatrixStatsAggregate : Aggregations.AggregateBase
	{
		[JsonInclude]
		[JsonPropertyName("correlation")]
		public Dictionary<string, double> Correlation { get; init; }

		[JsonInclude]
		[JsonPropertyName("covariance")]
		public Dictionary<string, double> Covariance { get; init; }

		[JsonInclude]
		[JsonPropertyName("count")]
		public int Count { get; init; }

		[JsonInclude]
		[JsonPropertyName("kurtosis")]
		public double Kurtosis { get; init; }

		[JsonInclude]
		[JsonPropertyName("mean")]
		public double Mean { get; init; }

		[JsonInclude]
		[JsonPropertyName("skewness")]
		public double Skewness { get; init; }

		[JsonInclude]
		[JsonPropertyName("variance")]
		public double Variance { get; init; }

		[JsonInclude]
		[JsonPropertyName("name")]
		public string Name { get; init; }
	}

	public partial class MatrixStatsAggregation : Aggregations.MatrixAggregation, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "matrix_stats";
		[JsonInclude]
		[JsonPropertyName("mode")]
		public Elastic.Clients.Elasticsearch.Aggregations.MatrixStatsMode? Mode { get; set; }
	}

	public partial class MaxAggregation : Aggregations.FormatMetricAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "max";
	}

	public partial class MaxBucketAggregation : Aggregations.PipelineAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "max_bucket";
	}

	public partial class MedianAbsoluteDeviationAggregation : Aggregations.FormatMetricAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "median_absolute_deviation";
		[JsonInclude]
		[JsonPropertyName("compression")]
		public double? Compression { get; set; }
	}

	public abstract partial class MetricAggregationBase
	{
		[JsonInclude]
		[JsonPropertyName("field")]
		public string? Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("missing")]
		public Elastic.Clients.Elasticsearch.Aggregations.Missing? Missing { get; set; }

		[JsonInclude]
		[JsonPropertyName("script")]
		public Elastic.Clients.Elasticsearch.Script? Script { get; set; }
	}

	[JsonConverter(typeof(MetricAggregationBaseDescriptorConverter))]
	public partial class MetricAggregationBaseDescriptor : DescriptorBase<MetricAggregationBaseDescriptor>
	{
		internal string? _field;
		internal Elastic.Clients.Elasticsearch.Aggregations.Missing? _missing;
		internal Elastic.Clients.Elasticsearch.Script? _script;
		public MetricAggregationBaseDescriptor Field(string? field) => Assign(field, (a, v) => a._field = v);
		public MetricAggregationBaseDescriptor Missing(Elastic.Clients.Elasticsearch.Aggregations.Missing? missing) => Assign(missing, (a, v) => a._missing = v);
		public MetricAggregationBaseDescriptor Script(Elastic.Clients.Elasticsearch.Script? script) => Assign(script, (a, v) => a._script = v);
	}

	internal sealed class MetricAggregationBaseDescriptorConverter : JsonConverter<MetricAggregationBaseDescriptor>
	{
		public override MetricAggregationBaseDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, MetricAggregationBaseDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value._field is not null)
			{
				writer.WritePropertyName("field");
				JsonSerializer.Serialize(writer, value._field, options);
			}

			if (value._missing is not null)
			{
				writer.WritePropertyName("missing");
				JsonSerializer.Serialize(writer, value._missing, options);
			}

			if (value._script is not null)
			{
				writer.WritePropertyName("script");
				JsonSerializer.Serialize(writer, value._script, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class MinAggregation : Aggregations.FormatMetricAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "min";
	}

	public partial class MinBucketAggregation : Aggregations.PipelineAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "min_bucket";
	}

	public partial class MissingAggregation : Aggregations.BucketAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "missing";
		[JsonInclude]
		[JsonPropertyName("field")]
		public string? Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("missing")]
		public Elastic.Clients.Elasticsearch.Aggregations.Missing? Missing { get; set; }
	}

	public partial class MovingAverageAggregation : Aggregations.PipelineAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "moving_avg";
		[JsonInclude]
		[JsonPropertyName("minimize")]
		public bool? Minimize { get; set; }

		[JsonInclude]
		[JsonPropertyName("model")]
		public Elastic.Clients.Elasticsearch.Aggregations.MovingAverageModel? Model { get; set; }

		[JsonInclude]
		[JsonPropertyName("settings")]
		public Elastic.Clients.Elasticsearch.Aggregations.MovingAverageSettings Settings { get; set; }

		[JsonInclude]
		[JsonPropertyName("predict")]
		public int? Predict { get; set; }

		[JsonInclude]
		[JsonPropertyName("window")]
		public int? Window { get; set; }
	}

	public partial class MovingFunctionAggregation : Aggregations.PipelineAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "moving_fn";
		[JsonInclude]
		[JsonPropertyName("script")]
		public string? Script { get; set; }

		[JsonInclude]
		[JsonPropertyName("shift")]
		public int? Shift { get; set; }

		[JsonInclude]
		[JsonPropertyName("window")]
		public int? Window { get; set; }
	}

	public partial class MovingPercentilesAggregation : Aggregations.PipelineAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "moving_percentiles";
		[JsonInclude]
		[JsonPropertyName("window")]
		public int? Window { get; set; }

		[JsonInclude]
		[JsonPropertyName("shift")]
		public int? Shift { get; set; }

		[JsonInclude]
		[JsonPropertyName("keyed")]
		public bool? Keyed { get; set; }
	}

	public partial class MultiBucketAggregate<TBucket> : Aggregations.AggregateBase
	{
		[JsonInclude]
		[JsonPropertyName("buckets")]
		public IReadOnlyCollection<TBucket> Buckets { get; init; }
	}

	public partial class MultiTermLookup
	{
		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }
	}

	public partial class MultiTermsAggregation : Aggregations.BucketAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "multi_terms";
		[JsonInclude]
		[JsonPropertyName("terms")]
		public IEnumerable<Elastic.Clients.Elasticsearch.Aggregations.MultiTermLookup> Terms { get; set; }
	}

	public partial class MutualInformationHeuristic
	{
		[JsonInclude]
		[JsonPropertyName("background_is_superset")]
		public bool? BackgroundIsSuperset { get; set; }

		[JsonInclude]
		[JsonPropertyName("include_negatives")]
		public bool? IncludeNegatives { get; set; }
	}

	public partial class NestedAggregation : Aggregations.BucketAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "nested";
		[JsonInclude]
		[JsonPropertyName("path")]
		public string? Path { get; set; }
	}

	public partial class NormalizeAggregation : Aggregations.PipelineAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "normalize";
		[JsonInclude]
		[JsonPropertyName("method")]
		public Elastic.Clients.Elasticsearch.Aggregations.NormalizeMethod? Method { get; set; }
	}

	public partial class ParentAggregation : Aggregations.BucketAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "parent";
		[JsonInclude]
		[JsonPropertyName("type")]
		public string? Type { get; set; }
	}

	public partial class PercentageScoreHeuristic
	{
	}

	public partial class PercentileItem
	{
		[JsonInclude]
		[JsonPropertyName("percentile")]
		public double Percentile { get; init; }

		[JsonInclude]
		[JsonPropertyName("value")]
		public double Value { get; init; }
	}

	public partial class PercentileRanksAggregation : Aggregations.FormatMetricAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "percentile_ranks";
		[JsonInclude]
		[JsonPropertyName("keyed")]
		public bool? Keyed { get; set; }

		[JsonInclude]
		[JsonPropertyName("values")]
		public IEnumerable<double>? Values { get; set; }

		[JsonInclude]
		[JsonPropertyName("hdr")]
		public Elastic.Clients.Elasticsearch.Aggregations.HdrMethod? Hdr { get; set; }

		[JsonInclude]
		[JsonPropertyName("tdigest")]
		public Elastic.Clients.Elasticsearch.Aggregations.TDigest? Tdigest { get; set; }
	}

	public partial class PercentilesAggregate : Aggregations.AggregateBase
	{
		[JsonInclude]
		[JsonPropertyName("items")]
		public IReadOnlyCollection<Elastic.Clients.Elasticsearch.Aggregations.PercentileItem> Items { get; init; }
	}

	public partial class PercentilesAggregation : Aggregations.FormatMetricAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "percentiles";
		[JsonInclude]
		[JsonPropertyName("keyed")]
		public bool? Keyed { get; set; }

		[JsonInclude]
		[JsonPropertyName("percents")]
		public IEnumerable<double>? Percents { get; set; }

		[JsonInclude]
		[JsonPropertyName("hdr")]
		public Elastic.Clients.Elasticsearch.Aggregations.HdrMethod? Hdr { get; set; }

		[JsonInclude]
		[JsonPropertyName("tdigest")]
		public Elastic.Clients.Elasticsearch.Aggregations.TDigest? Tdigest { get; set; }
	}

	public partial class PercentilesBucketAggregation : Aggregations.PipelineAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "percentiles_bucket";
		[JsonInclude]
		[JsonPropertyName("percents")]
		public IEnumerable<double>? Percents { get; set; }
	}

	public abstract partial class PipelineAggregationBase : Aggregations.Aggregation
	{
		[JsonInclude]
		[JsonPropertyName("buckets_path")]
		public object? BucketsPath { get; set; }

		[JsonInclude]
		[JsonPropertyName("format")]
		public string? Format { get; set; }

		[JsonInclude]
		[JsonPropertyName("gap_policy")]
		public Elastic.Clients.Elasticsearch.Aggregations.GapPolicy? GapPolicy { get; set; }
	}

	[JsonConverter(typeof(PipelineAggregationBaseDescriptorConverter))]
	public partial class PipelineAggregationBaseDescriptor : DescriptorBase<PipelineAggregationBaseDescriptor>
	{
		internal object? _bucketsPath;
		internal string? _format;
		internal Elastic.Clients.Elasticsearch.Aggregations.GapPolicy? _gapPolicy;
		public PipelineAggregationBaseDescriptor BucketsPath(object? bucketsPath) => Assign(bucketsPath, (a, v) => a._bucketsPath = v);
		public PipelineAggregationBaseDescriptor Format(string? format) => Assign(format, (a, v) => a._format = v);
		public PipelineAggregationBaseDescriptor GapPolicy(Elastic.Clients.Elasticsearch.Aggregations.GapPolicy? gapPolicy) => Assign(gapPolicy, (a, v) => a._gapPolicy = v);
	}

	internal sealed class PipelineAggregationBaseDescriptorConverter : JsonConverter<PipelineAggregationBaseDescriptor>
	{
		public override PipelineAggregationBaseDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, PipelineAggregationBaseDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value._bucketsPath is not null)
			{
				writer.WritePropertyName("buckets_path");
				JsonSerializer.Serialize(writer, value._bucketsPath, options);
			}

			if (!string.IsNullOrEmpty(value._format))
			{
				writer.WritePropertyName("format");
				writer.WriteStringValue(value._format);
			}

			if (value._gapPolicy is not null)
			{
				writer.WritePropertyName("gap_policy");
				JsonSerializer.Serialize(writer, value._gapPolicy, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class RangeAggregation : Aggregations.BucketAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "range";
		[JsonInclude]
		[JsonPropertyName("field")]
		public string? Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("missing")]
		public int? Missing { get; set; }

		[JsonInclude]
		[JsonPropertyName("ranges")]
		public IEnumerable<Elastic.Clients.Elasticsearch.Aggregations.AggregationRange>? Ranges { get; set; }

		[JsonInclude]
		[JsonPropertyName("script")]
		public Elastic.Clients.Elasticsearch.Script? Script { get; set; }

		[JsonInclude]
		[JsonPropertyName("keyed")]
		public bool? Keyed { get; set; }
	}

	public partial class RangeBucket
	{
	}

	public partial class RareTermsAggregation : Aggregations.BucketAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "rare_terms";
		[JsonInclude]
		[JsonPropertyName("exclude")]
		public IEnumerable<string>? Exclude { get; set; }

		[JsonInclude]
		[JsonPropertyName("field")]
		public string? Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("include")]
		public object? Include { get; set; }

		[JsonInclude]
		[JsonPropertyName("max_doc_count")]
		public object? MaxDocCount { get; set; }

		[JsonInclude]
		[JsonPropertyName("missing")]
		public Elastic.Clients.Elasticsearch.Aggregations.Missing? Missing { get; set; }

		[JsonInclude]
		[JsonPropertyName("precision")]
		public double? Precision { get; set; }

		[JsonInclude]
		[JsonPropertyName("value_type")]
		public string? ValueType { get; set; }
	}

	public partial class RareTermsBucket<TKey>
	{
	}

	public partial class RateAggregation : Aggregations.FormatMetricAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "rate";
		[JsonInclude]
		[JsonPropertyName("unit")]
		public Elastic.Clients.Elasticsearch.Aggregations.DateInterval? Unit { get; set; }

		[JsonInclude]
		[JsonPropertyName("mode")]
		public Elastic.Clients.Elasticsearch.Aggregations.RateMode? Mode { get; set; }
	}

	public partial class RegressionInferenceOptions
	{
		[JsonInclude]
		[JsonPropertyName("results_field")]
		public string? ResultsField { get; set; }

		[JsonInclude]
		[JsonPropertyName("num_top_feature_importance_values")]
		public int? NumTopFeatureImportanceValues { get; set; }
	}

	public partial class ReverseNestedAggregation : Aggregations.BucketAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "reverse_nested";
		[JsonInclude]
		[JsonPropertyName("path")]
		public string? Path { get; set; }
	}

	public partial class SamplerAggregation : Aggregations.BucketAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "sampler";
		[JsonInclude]
		[JsonPropertyName("shard_size")]
		public int? ShardSize { get; set; }
	}

	public partial class ScriptedHeuristic
	{
		[JsonInclude]
		[JsonPropertyName("script")]
		public Elastic.Clients.Elasticsearch.Script Script { get; set; }
	}

	public partial class ScriptedMetricAggregate : Aggregations.AggregateBase
	{
		[JsonInclude]
		[JsonPropertyName("value")]
		public object Value { get; init; }
	}

	public partial class ScriptedMetricAggregation : Aggregations.MetricAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "scripted_metric";
		[JsonInclude]
		[JsonPropertyName("combine_script")]
		public Elastic.Clients.Elasticsearch.Script? CombineScript { get; set; }

		[JsonInclude]
		[JsonPropertyName("init_script")]
		public Elastic.Clients.Elasticsearch.Script? InitScript { get; set; }

		[JsonInclude]
		[JsonPropertyName("map_script")]
		public Elastic.Clients.Elasticsearch.Script? MapScript { get; set; }

		[JsonInclude]
		[JsonPropertyName("params")]
		public Dictionary<string, object>? Params { get; set; }

		[JsonInclude]
		[JsonPropertyName("reduce_script")]
		public Elastic.Clients.Elasticsearch.Script? ReduceScript { get; set; }
	}

	public partial class SerialDifferencingAggregation : Aggregations.PipelineAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "serial_diff";
		[JsonInclude]
		[JsonPropertyName("lag")]
		public int? Lag { get; set; }
	}

	public partial class SignificantTermsAggregate<TBucket, TKey> : Aggregations.MultiBucketAggregate<TBucket>
	{
		[JsonInclude]
		[JsonPropertyName("bg_count")]
		public object BgCount { get; init; }

		[JsonInclude]
		[JsonPropertyName("doc_count")]
		public object DocCount { get; init; }
	}

	public partial class SignificantTermsAggregation : Aggregations.BucketAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "significant_terms";
		[JsonInclude]
		[JsonPropertyName("background_filter")]
		public Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? BackgroundFilter { get; set; }

		[JsonInclude]
		[JsonPropertyName("chi_square")]
		public Elastic.Clients.Elasticsearch.Aggregations.ChiSquareHeuristic? ChiSquare { get; set; }

		[JsonInclude]
		[JsonPropertyName("exclude")]
		public IEnumerable<string>? Exclude { get; set; }

		[JsonInclude]
		[JsonPropertyName("execution_hint")]
		public Elastic.Clients.Elasticsearch.Aggregations.TermsAggregationExecutionHint? ExecutionHint { get; set; }

		[JsonInclude]
		[JsonPropertyName("field")]
		public string? Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("gnd")]
		public Elastic.Clients.Elasticsearch.Aggregations.GoogleNormalizedDistanceHeuristic? Gnd { get; set; }

		[JsonInclude]
		[JsonPropertyName("include")]
		public IEnumerable<string>? Include { get; set; }

		[JsonInclude]
		[JsonPropertyName("min_doc_count")]
		public object? MinDocCount { get; set; }

		[JsonInclude]
		[JsonPropertyName("mutual_information")]
		public Elastic.Clients.Elasticsearch.Aggregations.MutualInformationHeuristic? MutualInformation { get; set; }

		[JsonInclude]
		[JsonPropertyName("percentage")]
		public Elastic.Clients.Elasticsearch.Aggregations.PercentageScoreHeuristic? Percentage { get; set; }

		[JsonInclude]
		[JsonPropertyName("script_heuristic")]
		public Elastic.Clients.Elasticsearch.Aggregations.ScriptedHeuristic? ScriptHeuristic { get; set; }

		[JsonInclude]
		[JsonPropertyName("shard_min_doc_count")]
		public object? ShardMinDocCount { get; set; }

		[JsonInclude]
		[JsonPropertyName("shard_size")]
		public int? ShardSize { get; set; }

		[JsonInclude]
		[JsonPropertyName("size")]
		public int? Size { get; set; }
	}

	public partial class SignificantTermsBucket<TKey>
	{
	}

	public partial class SignificantTextAggregation : Aggregations.BucketAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "significant_text";
		[JsonInclude]
		[JsonPropertyName("background_filter")]
		public Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? BackgroundFilter { get; set; }

		[JsonInclude]
		[JsonPropertyName("chi_square")]
		public Elastic.Clients.Elasticsearch.Aggregations.ChiSquareHeuristic? ChiSquare { get; set; }

		[JsonInclude]
		[JsonPropertyName("exclude")]
		public IEnumerable<string>? Exclude { get; set; }

		[JsonInclude]
		[JsonPropertyName("execution_hint")]
		public Elastic.Clients.Elasticsearch.Aggregations.TermsAggregationExecutionHint? ExecutionHint { get; set; }

		[JsonInclude]
		[JsonPropertyName("field")]
		public string? Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("filter_duplicate_text")]
		public bool? FilterDuplicateText { get; set; }

		[JsonInclude]
		[JsonPropertyName("gnd")]
		public Elastic.Clients.Elasticsearch.Aggregations.GoogleNormalizedDistanceHeuristic? Gnd { get; set; }

		[JsonInclude]
		[JsonPropertyName("include")]
		public IEnumerable<string>? Include { get; set; }

		[JsonInclude]
		[JsonPropertyName("min_doc_count")]
		public object? MinDocCount { get; set; }

		[JsonInclude]
		[JsonPropertyName("mutual_information")]
		public Elastic.Clients.Elasticsearch.Aggregations.MutualInformationHeuristic? MutualInformation { get; set; }

		[JsonInclude]
		[JsonPropertyName("percentage")]
		public Elastic.Clients.Elasticsearch.Aggregations.PercentageScoreHeuristic? Percentage { get; set; }

		[JsonInclude]
		[JsonPropertyName("script_heuristic")]
		public Elastic.Clients.Elasticsearch.Aggregations.ScriptedHeuristic? ScriptHeuristic { get; set; }

		[JsonInclude]
		[JsonPropertyName("shard_min_doc_count")]
		public object? ShardMinDocCount { get; set; }

		[JsonInclude]
		[JsonPropertyName("shard_size")]
		public int? ShardSize { get; set; }

		[JsonInclude]
		[JsonPropertyName("size")]
		public int? Size { get; set; }

		[JsonInclude]
		[JsonPropertyName("source_fields")]
		public Elastic.Clients.Elasticsearch.Fields? SourceFields { get; set; }
	}

	public partial class SingleBucketAggregate : Aggregations.AggregateBase
	{
		[JsonInclude]
		[JsonPropertyName("doc_count")]
		public double DocCount { get; init; }
	}

	public partial class StandardDeviationBounds
	{
		[JsonInclude]
		[JsonPropertyName("lower")]
		public double? Lower { get; init; }

		[JsonInclude]
		[JsonPropertyName("upper")]
		public double? Upper { get; init; }

		[JsonInclude]
		[JsonPropertyName("lower_population")]
		public double? LowerPopulation { get; init; }

		[JsonInclude]
		[JsonPropertyName("upper_population")]
		public double? UpperPopulation { get; init; }

		[JsonInclude]
		[JsonPropertyName("lower_sampling")]
		public double? LowerSampling { get; init; }

		[JsonInclude]
		[JsonPropertyName("upper_sampling")]
		public double? UpperSampling { get; init; }
	}

	public partial class StatsAggregate : Aggregations.AggregateBase
	{
		[JsonInclude]
		[JsonPropertyName("count")]
		public double Count { get; init; }

		[JsonInclude]
		[JsonPropertyName("sum")]
		public double Sum { get; init; }

		[JsonInclude]
		[JsonPropertyName("avg")]
		public double? Avg { get; init; }

		[JsonInclude]
		[JsonPropertyName("max")]
		public double? Max { get; init; }

		[JsonInclude]
		[JsonPropertyName("min")]
		public double? Min { get; init; }
	}

	public partial class StatsAggregation : Aggregations.FormatMetricAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "stats";
	}

	public partial class StatsBucketAggregation : Aggregations.PipelineAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "stats_bucket";
	}

	public partial class StringStatsAggregate : Aggregations.AggregateBase
	{
		[JsonInclude]
		[JsonPropertyName("count")]
		public object Count { get; init; }

		[JsonInclude]
		[JsonPropertyName("min_length")]
		public int MinLength { get; init; }

		[JsonInclude]
		[JsonPropertyName("max_length")]
		public int MaxLength { get; init; }

		[JsonInclude]
		[JsonPropertyName("avg_length")]
		public double AvgLength { get; init; }

		[JsonInclude]
		[JsonPropertyName("entropy")]
		public double Entropy { get; init; }

		[JsonInclude]
		[JsonPropertyName("distribution")]
		public Dictionary<string, double>? Distribution { get; init; }
	}

	public partial class StringStatsAggregation : Aggregations.MetricAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "string_stats";
		[JsonInclude]
		[JsonPropertyName("show_distribution")]
		public bool? ShowDistribution { get; set; }
	}

	public partial class SumAggregation : Aggregations.FormatMetricAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "sum";
	}

	public partial class SumBucketAggregation : Aggregations.PipelineAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "sum_bucket";
	}

	public partial class TDigest
	{
		[JsonInclude]
		[JsonPropertyName("compression")]
		public int? Compression { get; set; }
	}

	public partial class TDigestPercentilesAggregate : Aggregations.AggregateBase
	{
		[JsonInclude]
		[JsonPropertyName("values")]
		public Dictionary<string, double> Values { get; init; }
	}

	public partial class TermsAggregate<TBucket, TKey> : Aggregations.MultiBucketAggregate<TBucket>
	{
		[JsonInclude]
		[JsonPropertyName("doc_count_error_upper_bound")]
		public object DocCountErrorUpperBound { get; init; }

		[JsonInclude]
		[JsonPropertyName("sum_other_doc_count")]
		public object SumOtherDocCount { get; init; }
	}

	public partial class TermsAggregation : Aggregations.BucketAggregationBase, IAggregationContainerVariant, TransformManagement.IPivotGroupByContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "terms";
		[JsonIgnore]
		string TransformManagement.IPivotGroupByContainerVariant.PivotGroupByContainerVariantName => "terms";
		[JsonInclude]
		[JsonPropertyName("collect_mode")]
		public Elastic.Clients.Elasticsearch.Aggregations.TermsAggregationCollectMode? CollectMode { get; set; }

		[JsonInclude]
		[JsonPropertyName("exclude")]
		public IEnumerable<string>? Exclude { get; set; }

		[JsonInclude]
		[JsonPropertyName("execution_hint")]
		public Elastic.Clients.Elasticsearch.Aggregations.TermsAggregationExecutionHint? ExecutionHint { get; set; }

		[JsonInclude]
		[JsonPropertyName("field")]
		public string? Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("include")]
		public object? Include { get; set; }

		[JsonInclude]
		[JsonPropertyName("min_doc_count")]
		public int? MinDocCount { get; set; }

		[JsonInclude]
		[JsonPropertyName("missing")]
		public Elastic.Clients.Elasticsearch.Aggregations.Missing? Missing { get; set; }

		[JsonInclude]
		[JsonPropertyName("missing_order")]
		public Elastic.Clients.Elasticsearch.Aggregations.MissingOrder? MissingOrder { get; set; }

		[JsonInclude]
		[JsonPropertyName("missing_bucket")]
		public bool? MissingBucket { get; set; }

		[JsonInclude]
		[JsonPropertyName("value_type")]
		public string? ValueType { get; set; }

		[JsonInclude]
		[JsonPropertyName("order")]
		public Elastic.Clients.Elasticsearch.Aggregations.TermsAggregationOrder? Order { get; set; }

		[JsonInclude]
		[JsonPropertyName("script")]
		public Elastic.Clients.Elasticsearch.Script? Script { get; set; }

		[JsonInclude]
		[JsonPropertyName("shard_size")]
		public int? ShardSize { get; set; }

		[JsonInclude]
		[JsonPropertyName("show_term_doc_count_error")]
		public bool? ShowTermDocCountError { get; set; }

		[JsonInclude]
		[JsonPropertyName("size")]
		public int? Size { get; set; }
	}

	public partial class TermsInclude
	{
		[JsonInclude]
		[JsonPropertyName("num_partitions")]
		public object NumPartitions { get; set; }

		[JsonInclude]
		[JsonPropertyName("partition")]
		public object Partition { get; set; }
	}

	public partial class TestPopulation
	{
		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("script")]
		public Elastic.Clients.Elasticsearch.Script? Script { get; set; }

		[JsonInclude]
		[JsonPropertyName("filter")]
		public Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? Filter { get; set; }
	}

	[JsonConverter(typeof(TestPopulationDescriptorConverter))]
	public partial class TestPopulationDescriptor : DescriptorBase<TestPopulationDescriptor>
	{
		internal string _field;
		internal Elastic.Clients.Elasticsearch.Script? _script;
		internal Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? _filter;
		public TestPopulationDescriptor Field(string field) => Assign(field, (a, v) => a._field = v);
		public TestPopulationDescriptor Script(Elastic.Clients.Elasticsearch.Script? script) => Assign(script, (a, v) => a._script = v);
		public TestPopulationDescriptor Filter(Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? filter) => Assign(filter, (a, v) => a._filter = v);
	}

	internal sealed class TestPopulationDescriptorConverter : JsonConverter<TestPopulationDescriptor>
	{
		public override TestPopulationDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, TestPopulationDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, value._field, options);
			if (value._script is not null)
			{
				writer.WritePropertyName("script");
				JsonSerializer.Serialize(writer, value._script, options);
			}

			if (value._filter is not null)
			{
				writer.WritePropertyName("filter");
				JsonSerializer.Serialize(writer, value._filter, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class TopHitsAggregate : Aggregations.AggregateBase
	{
	}

	public partial class TopHitsAggregation : Aggregations.MetricAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "top_hits";
		[JsonInclude]
		[JsonPropertyName("docvalue_fields")]
		public Elastic.Clients.Elasticsearch.Fields? DocvalueFields { get; set; }

		[JsonInclude]
		[JsonPropertyName("explain")]
		public bool? Explain { get; set; }

		[JsonInclude]
		[JsonPropertyName("from")]
		public int? From { get; set; }

		[JsonInclude]
		[JsonPropertyName("highlight")]
		public Elastic.Clients.Elasticsearch.Highlight? Highlight { get; set; }

		[JsonInclude]
		[JsonPropertyName("script_fields")]
		public Dictionary<string, Elastic.Clients.Elasticsearch.ScriptField>? ScriptFields { get; set; }

		[JsonInclude]
		[JsonPropertyName("size")]
		public int? Size { get; set; }

		[JsonInclude]
		[JsonPropertyName("sort")]
		public Elastic.Clients.Elasticsearch.Sort? Sort { get; set; }

		[JsonInclude]
		[JsonPropertyName("_source")]
		public object? Source { get; set; }

		[JsonInclude]
		[JsonPropertyName("stored_fields")]
		public Elastic.Clients.Elasticsearch.Fields? StoredFields { get; set; }

		[JsonInclude]
		[JsonPropertyName("track_scores")]
		public bool? TrackScores { get; set; }

		[JsonInclude]
		[JsonPropertyName("version")]
		public bool? Version { get; set; }

		[JsonInclude]
		[JsonPropertyName("seq_no_primary_term")]
		public bool? SeqNoPrimaryTerm { get; set; }
	}

	public partial class TopMetrics
	{
		[JsonInclude]
		[JsonPropertyName("sort")]
		public IReadOnlyCollection<object> Sort { get; init; }

		[JsonInclude]
		[JsonPropertyName("metrics")]
		public Dictionary<string, object> Metrics { get; init; }
	}

	public partial class TopMetricsAggregate : Aggregations.AggregateBase
	{
		[JsonInclude]
		[JsonPropertyName("top")]
		public IReadOnlyCollection<Elastic.Clients.Elasticsearch.Aggregations.TopMetrics> Top { get; init; }
	}

	public partial class TopMetricsAggregation : Aggregations.MetricAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "top_metrics";
		[JsonInclude]
		[JsonPropertyName("metrics")]
		public IEnumerable<Elastic.Clients.Elasticsearch.Aggregations.TopMetricsValue>? Metrics { get; set; }

		[JsonInclude]
		[JsonPropertyName("size")]
		public int? Size { get; set; }

		[JsonInclude]
		[JsonPropertyName("sort")]
		public Elastic.Clients.Elasticsearch.Sort? Sort { get; set; }
	}

	public partial class TopMetricsValue
	{
		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }
	}

	public partial class TTestAggregation : Aggregations.Aggregation, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "t_test";
		[JsonInclude]
		[JsonPropertyName("a")]
		public Elastic.Clients.Elasticsearch.Aggregations.TestPopulation? a { get; set; }

		[JsonInclude]
		[JsonPropertyName("b")]
		public Elastic.Clients.Elasticsearch.Aggregations.TestPopulation? b { get; set; }

		[JsonInclude]
		[JsonPropertyName("type")]
		public Elastic.Clients.Elasticsearch.Aggregations.TTestType? Type { get; set; }
	}

	public partial class ValueAggregate : Aggregations.AggregateBase
	{
		[JsonInclude]
		[JsonPropertyName("value")]
		public double Value { get; init; }

		[JsonInclude]
		[JsonPropertyName("value_as_string")]
		public string? ValueAsString { get; init; }
	}

	public partial class ValueCountAggregation : Aggregations.FormattableMetricAggregation, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "value_count";
	}

	public partial class VariableWidthHistogramAggregation : IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "variable_width_histogram";
		[JsonInclude]
		[JsonPropertyName("field")]
		public string? Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("buckets")]
		public int? Buckets { get; set; }

		[JsonInclude]
		[JsonPropertyName("shard_size")]
		public int? ShardSize { get; set; }

		[JsonInclude]
		[JsonPropertyName("initial_buffer")]
		public int? InitialBuffer { get; set; }
	}

	public partial class WeightedAverageAggregation : Aggregations.Aggregation, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "weighted_avg";
		[JsonInclude]
		[JsonPropertyName("format")]
		public string? Format { get; set; }

		[JsonInclude]
		[JsonPropertyName("value")]
		public Elastic.Clients.Elasticsearch.Aggregations.WeightedAverageValue? Value { get; set; }

		[JsonInclude]
		[JsonPropertyName("value_type")]
		public Elastic.Clients.Elasticsearch.Aggregations.ValueType? ValueType { get; set; }

		[JsonInclude]
		[JsonPropertyName("weight")]
		public Elastic.Clients.Elasticsearch.Aggregations.WeightedAverageValue? Weight { get; set; }
	}

	public partial class WeightedAverageValue
	{
		[JsonInclude]
		[JsonPropertyName("field")]
		public string? Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("missing")]
		public double? Missing { get; set; }

		[JsonInclude]
		[JsonPropertyName("script")]
		public Elastic.Clients.Elasticsearch.Script? Script { get; set; }
	}

	[JsonConverter(typeof(WeightedAverageValueDescriptorConverter))]
	public partial class WeightedAverageValueDescriptor : DescriptorBase<WeightedAverageValueDescriptor>
	{
		internal string? _field;
		internal double? _missing;
		internal Elastic.Clients.Elasticsearch.Script? _script;
		public WeightedAverageValueDescriptor Field(string? field) => Assign(field, (a, v) => a._field = v);
		public WeightedAverageValueDescriptor Missing(double? missing) => Assign(missing, (a, v) => a._missing = v);
		public WeightedAverageValueDescriptor Script(Elastic.Clients.Elasticsearch.Script? script) => Assign(script, (a, v) => a._script = v);
	}

	internal sealed class WeightedAverageValueDescriptorConverter : JsonConverter<WeightedAverageValueDescriptor>
	{
		public override WeightedAverageValueDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, WeightedAverageValueDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value._field is not null)
			{
				writer.WritePropertyName("field");
				JsonSerializer.Serialize(writer, value._field, options);
			}

			if (value._missing.HasValue)
			{
				writer.WritePropertyName("missing");
				writer.WriteNumberValue(value._missing.Value);
			}

			if (value._script is not null)
			{
				writer.WritePropertyName("script");
				JsonSerializer.Serialize(writer, value._script, options);
			}

			writer.WriteEndObject();
		}
	}
}