// Licensed to Elasticsearch B.V under one or more agreements.
// Elasticsearch B.V licenses this file to you under the Apache 2.0 License.
// See the LICENSE file in the project root for more information.
//
// ███╗   ██╗ ██████╗ ████████╗██╗ ██████╗███████╗
// ████╗  ██║██╔═══██╗╚══██╔══╝██║██╔════╝██╔════╝
// ██╔██╗ ██║██║   ██║   ██║   ██║██║     █████╗
// ██║╚██╗██║██║   ██║   ██║   ██║██║     ██╔══╝
// ██║ ╚████║╚██████╔╝   ██║   ██║╚██████╗███████╗
// ╚═╝  ╚═══╝ ╚═════╝    ╚═╝   ╚═╝ ╚═════╝╚══════╝
// ------------------------------------------------
//
// This file is automatically generated.
// Please do not edit these files manually.
//
// ------------------------------------------------

using System;
using System.Collections.Generic;
using System.Text.Json;
using System.Text.Json.Serialization;

#nullable restore
namespace Elastic.Clients.Elasticsearch.Aggregations
{
	public partial class AdjacencyMatrixAggregate : Aggregations.MultiBucketAggregateBase<Elastic.Clients.Elasticsearch.Aggregations.AdjacencyMatrixBucket>
	{
	}

	public partial class AdjacencyMatrixAggregation : Aggregations.BucketAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "adjacency_matrix";
		[JsonInclude]
		[JsonPropertyName("filters")]
		public Dictionary<string, Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer>? Filters { get; set; }
	}

	public sealed partial class AdjacencyMatrixAggregationDescriptor : DescriptorBase<AdjacencyMatrixAggregationDescriptor>
	{
		public AdjacencyMatrixAggregationDescriptor()
		{
		}

		internal AdjacencyMatrixAggregationDescriptor(Action<AdjacencyMatrixAggregationDescriptor> configure) => configure.Invoke(this);
		internal Dictionary<string, Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer>? FiltersValue { get; private set; }

		public AdjacencyMatrixAggregationDescriptor Filters(Func<FluentDictionary<string?, Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer?>, FluentDictionary<string?, Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer?>> selector) => Assign(selector, (a, v) => a.FiltersValue = v?.Invoke(new FluentDictionary<string?, Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer?>()));
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (FiltersValue is not null)
			{
				writer.WritePropertyName("filters");
				JsonSerializer.Serialize(writer, FiltersValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class AdjacencyMatrixBucket : Aggregations.MultiBucketBase
	{
	}

	public abstract partial class AggregateBase
	{
		[JsonInclude]
		[JsonPropertyName("meta")]
		public Dictionary<string, object>? Meta { get; init; }
	}

	public abstract partial class AggregationBase
	{
		[JsonInclude]
		[JsonPropertyName("meta")]
		public Dictionary<string, object>? Meta { get; set; }

		[JsonInclude]
		[JsonPropertyName("name")]
		public string? Name { get; set; }
	}

	public sealed partial class AggregationBaseDescriptor : DescriptorBase<AggregationBaseDescriptor>
	{
		public AggregationBaseDescriptor()
		{
		}

		internal AggregationBaseDescriptor(Action<AggregationBaseDescriptor> configure) => configure.Invoke(this);
		internal Dictionary<string, object>? MetaValue { get; private set; }

		internal string? NameValue { get; private set; }

		public AggregationBaseDescriptor Meta(Func<FluentDictionary<string?, object?>, FluentDictionary<string?, object?>> selector) => Assign(selector, (a, v) => a.MetaValue = v?.Invoke(new FluentDictionary<string?, object?>()));
		public AggregationBaseDescriptor Name(string? name) => Assign(name, (a, v) => a.NameValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (MetaValue is not null)
			{
				writer.WritePropertyName("meta");
				JsonSerializer.Serialize(writer, MetaValue, options);
			}

			if (!string.IsNullOrEmpty(NameValue))
			{
				writer.WritePropertyName("name");
				writer.WriteStringValue(NameValue);
			}

			writer.WriteEndObject();
		}
	}

	public interface IAggregationContainerVariant
	{
		string AggregationContainerVariantName { get; }
	}

	[JsonConverter(typeof(AggregationContainerConverter))]
	public partial class AggregationContainer : IContainer
	{
		public AggregationContainer(IAggregationContainerVariant variant) => Variant = variant ?? throw new ArgumentNullException(nameof(variant));
		internal IAggregationContainerVariant Variant { get; }

		[JsonInclude]
		[JsonPropertyName("meta")]
		public Dictionary<string, object>? Meta { get; set; }
	}

	internal sealed class AggregationContainerConverter : JsonConverter<AggregationContainer>
	{
		public override AggregationContainer Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			reader.Read();
			if (reader.TokenType != JsonTokenType.PropertyName)
			{
				throw new JsonException();
			}

			var propertyName = reader.GetString();
			if (propertyName == "adjacency_matrix")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.AdjacencyMatrixAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "auto_date_histogram")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.AutoDateHistogramAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "avg")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.AverageAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "avg_bucket")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.AverageBucketAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "boxplot")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.BoxplotAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "bucket_script")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.BucketScriptAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "bucket_selector")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.BucketSelectorAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "bucket_sort")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.BucketSortAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "cardinality")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.CardinalityAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "children")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.ChildrenAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "composite")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.CompositeAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "cumulative_cardinality")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.CumulativeCardinalityAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "cumulative_sum")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.CumulativeSumAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "date_histogram")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.DateHistogramAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "date_range")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.DateRangeAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "derivative")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.DerivativeAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "diversified_sampler")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.DiversifiedSamplerAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "extended_stats")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.ExtendedStatsAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "extended_stats_bucket")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.ExtendedStatsBucketAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "filter")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "filters")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.FiltersAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "geo_bounds")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.GeoBoundsAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "geo_centroid")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.GeoCentroidAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "geo_distance")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.GeoDistanceAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "geohash_grid")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.GeoHashGridAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "geo_line")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.GeoLineAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "geotile_grid")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.GeoTileGridAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "global")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.GlobalAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "histogram")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.HistogramAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "ip_range")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.IpRangeAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "inference")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.InferenceAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "matrix_stats")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.MatrixStatsAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "max")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.MaxAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "max_bucket")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.MaxBucketAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "median_absolute_deviation")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.MedianAbsoluteDeviationAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "min")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.MinAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "min_bucket")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.MinBucketAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "missing")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.MissingAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "moving_percentiles")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.MovingPercentilesAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "moving_fn")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.MovingFunctionAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "multi_terms")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.MultiTermsAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "nested")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.NestedAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "normalize")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.NormalizeAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "parent")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.ParentAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "percentile_ranks")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.PercentileRanksAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "percentiles")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.PercentilesAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "percentiles_bucket")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.PercentilesBucketAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "range")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.RangeAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "rare_terms")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.RareTermsAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "rate")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.RateAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "reverse_nested")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.ReverseNestedAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "sampler")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.SamplerAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "scripted_metric")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.ScriptedMetricAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "serial_diff")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.SerialDifferencingAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "significant_terms")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.SignificantTermsAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "significant_text")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.SignificantTextAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "stats")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.StatsAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "stats_bucket")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.StatsBucketAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "string_stats")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.StringStatsAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "sum")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.SumAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "sum_bucket")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.SumBucketAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "terms")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.TermsAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "top_hits")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.TopHitsAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "t_test")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.TTestAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "top_metrics")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.TopMetricsAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "value_count")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.ValueCountAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "weighted_avg")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.WeightedAverageAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "variable_width_histogram")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.VariableWidthHistogramAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			throw new JsonException();
		}

		public override void Write(Utf8JsonWriter writer, AggregationContainer value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName(value.Variant.AggregationContainerVariantName);
			switch (value.Variant)
			{
				case Elastic.Clients.Elasticsearch.Aggregations.AdjacencyMatrixAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.AutoDateHistogramAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.AverageAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.AverageBucketAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.BoxplotAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.BucketScriptAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.BucketSelectorAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.BucketSortAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.CardinalityAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.ChildrenAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.CompositeAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.CumulativeCardinalityAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.CumulativeSumAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.DateHistogramAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.DateRangeAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.DerivativeAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.DiversifiedSamplerAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.ExtendedStatsAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.ExtendedStatsBucketAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.FiltersAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.GeoBoundsAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.GeoCentroidAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.GeoDistanceAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.GeoHashGridAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.GeoLineAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.GeoTileGridAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.GlobalAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.HistogramAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.IpRangeAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.InferenceAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.MatrixStatsAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.MaxAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.MaxBucketAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.MedianAbsoluteDeviationAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.MinAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.MinBucketAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.MissingAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.MovingPercentilesAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.MovingFunctionAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.MultiTermsAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.NestedAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.NormalizeAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.ParentAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.PercentileRanksAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.PercentilesAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.PercentilesBucketAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.RangeAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.RareTermsAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.RateAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.ReverseNestedAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.SamplerAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.ScriptedMetricAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.SerialDifferencingAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.SignificantTermsAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.SignificantTextAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.StatsAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.StatsBucketAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.StringStatsAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.SumAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.SumBucketAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.TermsAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.TopHitsAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.TTestAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.TopMetricsAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.ValueCountAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.WeightedAverageAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.VariableWidthHistogramAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
			}

			writer.WriteEndObject();
		}
	}

	public sealed partial class AggregationContainerDescriptor<T> : DescriptorBase<AggregationContainerDescriptor<T>>
	{
		public AggregationContainerDescriptor()
		{
		}

		internal AggregationContainerDescriptor(Action<AggregationContainerDescriptor<T>> configure) => configure.Invoke(this);
		internal bool ContainsVariant { get; private set; }

		internal string ContainedVariantName { get; private set; }

		internal AggregationContainer Container { get; private set; }

		internal object ContainerVariantDescriptorAction { get; private set; }

		private void Set(object descriptorAction, string variantName)
		{
			if (ContainsVariant)
				throw new Exception("TODO");
			ContainerVariantDescriptorAction = descriptorAction;
			ContainedVariantName = variantName;
			ContainsVariant = true;
		}

		private void Set(IAggregationContainerVariant variant, string variantName)
		{
			if (ContainsVariant)
				throw new Exception("TODO");
			Container = new AggregationContainer(variant);
			ContainedVariantName = variantName;
			ContainsVariant = true;
		}

		public void AdjacencyMatrix(AdjacencyMatrixAggregation variant) => Set(variant, "adjacency_matrix");
		public void AdjacencyMatrix(Action<AdjacencyMatrixAggregationDescriptor> configure) => Set(configure, "adjacency_matrix");
		public void AutoDateHistogram(AutoDateHistogramAggregation variant) => Set(variant, "auto_date_histogram");
		public void AutoDateHistogram(Action<AutoDateHistogramAggregationDescriptor<T>> configure) => Set(configure, "auto_date_histogram");
		public void Avg(AverageAggregation variant) => Set(variant, "avg");
		public void Avg(Action<AverageAggregationDescriptor> configure) => Set(configure, "avg");
		public void AvgBucket(AverageBucketAggregation variant) => Set(variant, "avg_bucket");
		public void AvgBucket(Action<AverageBucketAggregationDescriptor> configure) => Set(configure, "avg_bucket");
		public void Boxplot(BoxplotAggregation variant) => Set(variant, "boxplot");
		public void Boxplot(Action<BoxplotAggregationDescriptor> configure) => Set(configure, "boxplot");
		public void BucketScript(BucketScriptAggregation variant) => Set(variant, "bucket_script");
		public void BucketScript(Action<BucketScriptAggregationDescriptor> configure) => Set(configure, "bucket_script");
		public void BucketSelector(BucketSelectorAggregation variant) => Set(variant, "bucket_selector");
		public void BucketSelector(Action<BucketSelectorAggregationDescriptor> configure) => Set(configure, "bucket_selector");
		public void BucketSort(BucketSortAggregation variant) => Set(variant, "bucket_sort");
		public void BucketSort(Action<BucketSortAggregationDescriptor> configure) => Set(configure, "bucket_sort");
		public void Cardinality(CardinalityAggregation variant) => Set(variant, "cardinality");
		public void Cardinality(Action<CardinalityAggregationDescriptor> configure) => Set(configure, "cardinality");
		public void Children(ChildrenAggregation variant) => Set(variant, "children");
		public void Children(Action<ChildrenAggregationDescriptor> configure) => Set(configure, "children");
		public void Composite(CompositeAggregation variant) => Set(variant, "composite");
		public void Composite(Action<CompositeAggregationDescriptor> configure) => Set(configure, "composite");
		public void CumulativeCardinality(CumulativeCardinalityAggregation variant) => Set(variant, "cumulative_cardinality");
		public void CumulativeCardinality(Action<CumulativeCardinalityAggregationDescriptor> configure) => Set(configure, "cumulative_cardinality");
		public void CumulativeSum(CumulativeSumAggregation variant) => Set(variant, "cumulative_sum");
		public void CumulativeSum(Action<CumulativeSumAggregationDescriptor> configure) => Set(configure, "cumulative_sum");
		public void DateHistogram(DateHistogramAggregation variant) => Set(variant, "date_histogram");
		public void DateHistogram(Action<DateHistogramAggregationDescriptor<T>> configure) => Set(configure, "date_histogram");
		public void DateRange(DateRangeAggregation variant) => Set(variant, "date_range");
		public void DateRange(Action<DateRangeAggregationDescriptor<T>> configure) => Set(configure, "date_range");
		public void Derivative(DerivativeAggregation variant) => Set(variant, "derivative");
		public void Derivative(Action<DerivativeAggregationDescriptor> configure) => Set(configure, "derivative");
		public void DiversifiedSampler(DiversifiedSamplerAggregation variant) => Set(variant, "diversified_sampler");
		public void DiversifiedSampler(Action<DiversifiedSamplerAggregationDescriptor<T>> configure) => Set(configure, "diversified_sampler");
		public void ExtendedStats(ExtendedStatsAggregation variant) => Set(variant, "extended_stats");
		public void ExtendedStats(Action<ExtendedStatsAggregationDescriptor> configure) => Set(configure, "extended_stats");
		public void ExtendedStatsBucket(ExtendedStatsBucketAggregation variant) => Set(variant, "extended_stats_bucket");
		public void ExtendedStatsBucket(Action<ExtendedStatsBucketAggregationDescriptor> configure) => Set(configure, "extended_stats_bucket");
		public void Filter(QueryDsl.QueryContainer variant) => Set(variant, "filter");
		public void Filter(Action<QueryDsl.QueryContainerDescriptor<T>> configure) => Set(configure, "filter");
		public void Filters(FiltersAggregation variant) => Set(variant, "filters");
		public void Filters(Action<FiltersAggregationDescriptor> configure) => Set(configure, "filters");
		public void GeoBounds(GeoBoundsAggregation variant) => Set(variant, "geo_bounds");
		public void GeoBounds(Action<GeoBoundsAggregationDescriptor> configure) => Set(configure, "geo_bounds");
		public void GeoCentroid(GeoCentroidAggregation variant) => Set(variant, "geo_centroid");
		public void GeoCentroid(Action<GeoCentroidAggregationDescriptor> configure) => Set(configure, "geo_centroid");
		public void GeoDistance(GeoDistanceAggregation variant) => Set(variant, "geo_distance");
		public void GeoDistance(Action<GeoDistanceAggregationDescriptor<T>> configure) => Set(configure, "geo_distance");
		public void GeohashGrid(GeoHashGridAggregation variant) => Set(variant, "geohash_grid");
		public void GeohashGrid(Action<GeoHashGridAggregationDescriptor<T>> configure) => Set(configure, "geohash_grid");
		public void GeoLine(GeoLineAggregation variant) => Set(variant, "geo_line");
		public void GeoLine(Action<GeoLineAggregationDescriptor<T>> configure) => Set(configure, "geo_line");
		public void GeotileGrid(GeoTileGridAggregation variant) => Set(variant, "geotile_grid");
		public void GeotileGrid(Action<GeoTileGridAggregationDescriptor<T>> configure) => Set(configure, "geotile_grid");
		public void Global(GlobalAggregation variant) => Set(variant, "global");
		public void Global(Action<GlobalAggregationDescriptor> configure) => Set(configure, "global");
		public void Histogram(HistogramAggregation variant) => Set(variant, "histogram");
		public void Histogram(Action<HistogramAggregationDescriptor<T>> configure) => Set(configure, "histogram");
		public void IpRange(IpRangeAggregation variant) => Set(variant, "ip_range");
		public void IpRange(Action<IpRangeAggregationDescriptor<T>> configure) => Set(configure, "ip_range");
		public void Inference(InferenceAggregation variant) => Set(variant, "inference");
		public void Inference(Action<InferenceAggregationDescriptor<T>> configure) => Set(configure, "inference");
		public void MatrixStats(MatrixStatsAggregation variant) => Set(variant, "matrix_stats");
		public void MatrixStats(Action<MatrixStatsAggregationDescriptor> configure) => Set(configure, "matrix_stats");
		public void Max(MaxAggregation variant) => Set(variant, "max");
		public void Max(Action<MaxAggregationDescriptor> configure) => Set(configure, "max");
		public void MaxBucket(MaxBucketAggregation variant) => Set(variant, "max_bucket");
		public void MaxBucket(Action<MaxBucketAggregationDescriptor> configure) => Set(configure, "max_bucket");
		public void MedianAbsoluteDeviation(MedianAbsoluteDeviationAggregation variant) => Set(variant, "median_absolute_deviation");
		public void MedianAbsoluteDeviation(Action<MedianAbsoluteDeviationAggregationDescriptor> configure) => Set(configure, "median_absolute_deviation");
		public void Min(MinAggregation variant) => Set(variant, "min");
		public void Min(Action<MinAggregationDescriptor> configure) => Set(configure, "min");
		public void MinBucket(MinBucketAggregation variant) => Set(variant, "min_bucket");
		public void MinBucket(Action<MinBucketAggregationDescriptor> configure) => Set(configure, "min_bucket");
		public void Missing(MissingAggregation variant) => Set(variant, "missing");
		public void Missing(Action<MissingAggregationDescriptor<T>> configure) => Set(configure, "missing");
		public void MovingPercentiles(MovingPercentilesAggregation variant) => Set(variant, "moving_percentiles");
		public void MovingPercentiles(Action<MovingPercentilesAggregationDescriptor> configure) => Set(configure, "moving_percentiles");
		public void MovingFn(MovingFunctionAggregation variant) => Set(variant, "moving_fn");
		public void MovingFn(Action<MovingFunctionAggregationDescriptor> configure) => Set(configure, "moving_fn");
		public void MultiTerms(MultiTermsAggregation variant) => Set(variant, "multi_terms");
		public void MultiTerms(Action<MultiTermsAggregationDescriptor> configure) => Set(configure, "multi_terms");
		public void Nested(NestedAggregation variant) => Set(variant, "nested");
		public void Nested(Action<NestedAggregationDescriptor<T>> configure) => Set(configure, "nested");
		public void Normalize(NormalizeAggregation variant) => Set(variant, "normalize");
		public void Normalize(Action<NormalizeAggregationDescriptor> configure) => Set(configure, "normalize");
		public void Parent(ParentAggregation variant) => Set(variant, "parent");
		public void Parent(Action<ParentAggregationDescriptor> configure) => Set(configure, "parent");
		public void PercentileRanks(PercentileRanksAggregation variant) => Set(variant, "percentile_ranks");
		public void PercentileRanks(Action<PercentileRanksAggregationDescriptor> configure) => Set(configure, "percentile_ranks");
		public void Percentiles(PercentilesAggregation variant) => Set(variant, "percentiles");
		public void Percentiles(Action<PercentilesAggregationDescriptor> configure) => Set(configure, "percentiles");
		public void PercentilesBucket(PercentilesBucketAggregation variant) => Set(variant, "percentiles_bucket");
		public void PercentilesBucket(Action<PercentilesBucketAggregationDescriptor> configure) => Set(configure, "percentiles_bucket");
		public void Range(RangeAggregation variant) => Set(variant, "range");
		public void Range(Action<RangeAggregationDescriptor<T>> configure) => Set(configure, "range");
		public void RareTerms(RareTermsAggregation variant) => Set(variant, "rare_terms");
		public void RareTerms(Action<RareTermsAggregationDescriptor<T>> configure) => Set(configure, "rare_terms");
		public void Rate(RateAggregation variant) => Set(variant, "rate");
		public void Rate(Action<RateAggregationDescriptor> configure) => Set(configure, "rate");
		public void ReverseNested(ReverseNestedAggregation variant) => Set(variant, "reverse_nested");
		public void ReverseNested(Action<ReverseNestedAggregationDescriptor<T>> configure) => Set(configure, "reverse_nested");
		public void Sampler(SamplerAggregation variant) => Set(variant, "sampler");
		public void Sampler(Action<SamplerAggregationDescriptor> configure) => Set(configure, "sampler");
		public void ScriptedMetric(ScriptedMetricAggregation variant) => Set(variant, "scripted_metric");
		public void ScriptedMetric(Action<ScriptedMetricAggregationDescriptor> configure) => Set(configure, "scripted_metric");
		public void SerialDiff(SerialDifferencingAggregation variant) => Set(variant, "serial_diff");
		public void SerialDiff(Action<SerialDifferencingAggregationDescriptor> configure) => Set(configure, "serial_diff");
		public void SignificantTerms(SignificantTermsAggregation variant) => Set(variant, "significant_terms");
		public void SignificantTerms(Action<SignificantTermsAggregationDescriptor<T>> configure) => Set(configure, "significant_terms");
		public void SignificantText(SignificantTextAggregation variant) => Set(variant, "significant_text");
		public void SignificantText(Action<SignificantTextAggregationDescriptor<T>> configure) => Set(configure, "significant_text");
		public void Stats(StatsAggregation variant) => Set(variant, "stats");
		public void Stats(Action<StatsAggregationDescriptor> configure) => Set(configure, "stats");
		public void StatsBucket(StatsBucketAggregation variant) => Set(variant, "stats_bucket");
		public void StatsBucket(Action<StatsBucketAggregationDescriptor> configure) => Set(configure, "stats_bucket");
		public void StringStats(StringStatsAggregation variant) => Set(variant, "string_stats");
		public void StringStats(Action<StringStatsAggregationDescriptor> configure) => Set(configure, "string_stats");
		public void Sum(SumAggregation variant) => Set(variant, "sum");
		public void Sum(Action<SumAggregationDescriptor> configure) => Set(configure, "sum");
		public void SumBucket(SumBucketAggregation variant) => Set(variant, "sum_bucket");
		public void SumBucket(Action<SumBucketAggregationDescriptor> configure) => Set(configure, "sum_bucket");
		public void Terms(TermsAggregation variant) => Set(variant, "terms");
		public void Terms(Action<TermsAggregationDescriptor<T>> configure) => Set(configure, "terms");
		public void TopHits(TopHitsAggregation variant) => Set(variant, "top_hits");
		public void TopHits(Action<TopHitsAggregationDescriptor<T>> configure) => Set(configure, "top_hits");
		public void TTest(TTestAggregation variant) => Set(variant, "t_test");
		public void TTest(Action<TTestAggregationDescriptor<T>> configure) => Set(configure, "t_test");
		public void TopMetrics(TopMetricsAggregation variant) => Set(variant, "top_metrics");
		public void TopMetrics(Action<TopMetricsAggregationDescriptor<T>> configure) => Set(configure, "top_metrics");
		public void ValueCount(ValueCountAggregation variant) => Set(variant, "value_count");
		public void ValueCount(Action<ValueCountAggregationDescriptor> configure) => Set(configure, "value_count");
		public void WeightedAvg(WeightedAverageAggregation variant) => Set(variant, "weighted_avg");
		public void WeightedAvg(Action<WeightedAverageAggregationDescriptor<T>> configure) => Set(configure, "weighted_avg");
		public void VariableWidthHistogram(VariableWidthHistogramAggregation variant) => Set(variant, "variable_width_histogram");
		public void VariableWidthHistogram(Action<VariableWidthHistogramAggregationDescriptor<T>> configure) => Set(configure, "variable_width_histogram");
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			if (!ContainsVariant)
			{
				writer.WriteNullValue();
				return;
			}

			writer.WriteStartObject();
			writer.WritePropertyName(ContainedVariantName);
			writer.WriteStartObject();
			if (Container is not null)
			{
				JsonSerializer.Serialize(writer, Container, options);
			}

			if (ContainedVariantName == "adjacency_matrix")
			{
				var descriptor = new AdjacencyMatrixAggregationDescriptor();
				((Action<AdjacencyMatrixAggregationDescriptor>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
			}

			if (ContainedVariantName == "auto_date_histogram")
			{
				var descriptor = new AutoDateHistogramAggregationDescriptor<T>();
				((Action<AutoDateHistogramAggregationDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
			}

			if (ContainedVariantName == "avg")
			{
				var descriptor = new AverageAggregationDescriptor();
				((Action<AverageAggregationDescriptor>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
			}

			if (ContainedVariantName == "avg_bucket")
			{
				var descriptor = new AverageBucketAggregationDescriptor();
				((Action<AverageBucketAggregationDescriptor>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
			}

			if (ContainedVariantName == "boxplot")
			{
				var descriptor = new BoxplotAggregationDescriptor();
				((Action<BoxplotAggregationDescriptor>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
			}

			if (ContainedVariantName == "bucket_script")
			{
				var descriptor = new BucketScriptAggregationDescriptor();
				((Action<BucketScriptAggregationDescriptor>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
			}

			if (ContainedVariantName == "bucket_selector")
			{
				var descriptor = new BucketSelectorAggregationDescriptor();
				((Action<BucketSelectorAggregationDescriptor>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
			}

			if (ContainedVariantName == "bucket_sort")
			{
				var descriptor = new BucketSortAggregationDescriptor();
				((Action<BucketSortAggregationDescriptor>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
			}

			if (ContainedVariantName == "cardinality")
			{
				var descriptor = new CardinalityAggregationDescriptor();
				((Action<CardinalityAggregationDescriptor>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
			}

			if (ContainedVariantName == "children")
			{
				var descriptor = new ChildrenAggregationDescriptor();
				((Action<ChildrenAggregationDescriptor>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
			}

			if (ContainedVariantName == "composite")
			{
				var descriptor = new CompositeAggregationDescriptor();
				((Action<CompositeAggregationDescriptor>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
			}

			if (ContainedVariantName == "cumulative_cardinality")
			{
				var descriptor = new CumulativeCardinalityAggregationDescriptor();
				((Action<CumulativeCardinalityAggregationDescriptor>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
			}

			if (ContainedVariantName == "cumulative_sum")
			{
				var descriptor = new CumulativeSumAggregationDescriptor();
				((Action<CumulativeSumAggregationDescriptor>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
			}

			if (ContainedVariantName == "date_histogram")
			{
				var descriptor = new DateHistogramAggregationDescriptor<T>();
				((Action<DateHistogramAggregationDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
			}

			if (ContainedVariantName == "date_range")
			{
				var descriptor = new DateRangeAggregationDescriptor<T>();
				((Action<DateRangeAggregationDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
			}

			if (ContainedVariantName == "derivative")
			{
				var descriptor = new DerivativeAggregationDescriptor();
				((Action<DerivativeAggregationDescriptor>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
			}

			if (ContainedVariantName == "diversified_sampler")
			{
				var descriptor = new DiversifiedSamplerAggregationDescriptor<T>();
				((Action<DiversifiedSamplerAggregationDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
			}

			if (ContainedVariantName == "extended_stats")
			{
				var descriptor = new ExtendedStatsAggregationDescriptor();
				((Action<ExtendedStatsAggregationDescriptor>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
			}

			if (ContainedVariantName == "extended_stats_bucket")
			{
				var descriptor = new ExtendedStatsBucketAggregationDescriptor();
				((Action<ExtendedStatsBucketAggregationDescriptor>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
			}

			if (ContainedVariantName == "filter")
			{
				var descriptor = new QueryDsl.QueryContainerDescriptor<T>();
				((Action<QueryDsl.QueryContainerDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
			}

			if (ContainedVariantName == "filters")
			{
				var descriptor = new FiltersAggregationDescriptor();
				((Action<FiltersAggregationDescriptor>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
			}

			if (ContainedVariantName == "geo_bounds")
			{
				var descriptor = new GeoBoundsAggregationDescriptor();
				((Action<GeoBoundsAggregationDescriptor>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
			}

			if (ContainedVariantName == "geo_centroid")
			{
				var descriptor = new GeoCentroidAggregationDescriptor();
				((Action<GeoCentroidAggregationDescriptor>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
			}

			if (ContainedVariantName == "geo_distance")
			{
				var descriptor = new GeoDistanceAggregationDescriptor<T>();
				((Action<GeoDistanceAggregationDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
			}

			if (ContainedVariantName == "geohash_grid")
			{
				var descriptor = new GeoHashGridAggregationDescriptor<T>();
				((Action<GeoHashGridAggregationDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
			}

			if (ContainedVariantName == "geo_line")
			{
				var descriptor = new GeoLineAggregationDescriptor<T>();
				((Action<GeoLineAggregationDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
			}

			if (ContainedVariantName == "geotile_grid")
			{
				var descriptor = new GeoTileGridAggregationDescriptor<T>();
				((Action<GeoTileGridAggregationDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
			}

			if (ContainedVariantName == "global")
			{
				var descriptor = new GlobalAggregationDescriptor();
				((Action<GlobalAggregationDescriptor>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
			}

			if (ContainedVariantName == "histogram")
			{
				var descriptor = new HistogramAggregationDescriptor<T>();
				((Action<HistogramAggregationDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
			}

			if (ContainedVariantName == "ip_range")
			{
				var descriptor = new IpRangeAggregationDescriptor<T>();
				((Action<IpRangeAggregationDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
			}

			if (ContainedVariantName == "inference")
			{
				var descriptor = new InferenceAggregationDescriptor<T>();
				((Action<InferenceAggregationDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
			}

			if (ContainedVariantName == "matrix_stats")
			{
				var descriptor = new MatrixStatsAggregationDescriptor();
				((Action<MatrixStatsAggregationDescriptor>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
			}

			if (ContainedVariantName == "max")
			{
				var descriptor = new MaxAggregationDescriptor();
				((Action<MaxAggregationDescriptor>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
			}

			if (ContainedVariantName == "max_bucket")
			{
				var descriptor = new MaxBucketAggregationDescriptor();
				((Action<MaxBucketAggregationDescriptor>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
			}

			if (ContainedVariantName == "median_absolute_deviation")
			{
				var descriptor = new MedianAbsoluteDeviationAggregationDescriptor();
				((Action<MedianAbsoluteDeviationAggregationDescriptor>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
			}

			if (ContainedVariantName == "min")
			{
				var descriptor = new MinAggregationDescriptor();
				((Action<MinAggregationDescriptor>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
			}

			if (ContainedVariantName == "min_bucket")
			{
				var descriptor = new MinBucketAggregationDescriptor();
				((Action<MinBucketAggregationDescriptor>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
			}

			if (ContainedVariantName == "missing")
			{
				var descriptor = new MissingAggregationDescriptor<T>();
				((Action<MissingAggregationDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
			}

			if (ContainedVariantName == "moving_percentiles")
			{
				var descriptor = new MovingPercentilesAggregationDescriptor();
				((Action<MovingPercentilesAggregationDescriptor>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
			}

			if (ContainedVariantName == "moving_fn")
			{
				var descriptor = new MovingFunctionAggregationDescriptor();
				((Action<MovingFunctionAggregationDescriptor>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
			}

			if (ContainedVariantName == "multi_terms")
			{
				var descriptor = new MultiTermsAggregationDescriptor();
				((Action<MultiTermsAggregationDescriptor>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
			}

			if (ContainedVariantName == "nested")
			{
				var descriptor = new NestedAggregationDescriptor<T>();
				((Action<NestedAggregationDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
			}

			if (ContainedVariantName == "normalize")
			{
				var descriptor = new NormalizeAggregationDescriptor();
				((Action<NormalizeAggregationDescriptor>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
			}

			if (ContainedVariantName == "parent")
			{
				var descriptor = new ParentAggregationDescriptor();
				((Action<ParentAggregationDescriptor>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
			}

			if (ContainedVariantName == "percentile_ranks")
			{
				var descriptor = new PercentileRanksAggregationDescriptor();
				((Action<PercentileRanksAggregationDescriptor>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
			}

			if (ContainedVariantName == "percentiles")
			{
				var descriptor = new PercentilesAggregationDescriptor();
				((Action<PercentilesAggregationDescriptor>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
			}

			if (ContainedVariantName == "percentiles_bucket")
			{
				var descriptor = new PercentilesBucketAggregationDescriptor();
				((Action<PercentilesBucketAggregationDescriptor>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
			}

			if (ContainedVariantName == "range")
			{
				var descriptor = new RangeAggregationDescriptor<T>();
				((Action<RangeAggregationDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
			}

			if (ContainedVariantName == "rare_terms")
			{
				var descriptor = new RareTermsAggregationDescriptor<T>();
				((Action<RareTermsAggregationDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
			}

			if (ContainedVariantName == "rate")
			{
				var descriptor = new RateAggregationDescriptor();
				((Action<RateAggregationDescriptor>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
			}

			if (ContainedVariantName == "reverse_nested")
			{
				var descriptor = new ReverseNestedAggregationDescriptor<T>();
				((Action<ReverseNestedAggregationDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
			}

			if (ContainedVariantName == "sampler")
			{
				var descriptor = new SamplerAggregationDescriptor();
				((Action<SamplerAggregationDescriptor>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
			}

			if (ContainedVariantName == "scripted_metric")
			{
				var descriptor = new ScriptedMetricAggregationDescriptor();
				((Action<ScriptedMetricAggregationDescriptor>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
			}

			if (ContainedVariantName == "serial_diff")
			{
				var descriptor = new SerialDifferencingAggregationDescriptor();
				((Action<SerialDifferencingAggregationDescriptor>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
			}

			if (ContainedVariantName == "significant_terms")
			{
				var descriptor = new SignificantTermsAggregationDescriptor<T>();
				((Action<SignificantTermsAggregationDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
			}

			if (ContainedVariantName == "significant_text")
			{
				var descriptor = new SignificantTextAggregationDescriptor<T>();
				((Action<SignificantTextAggregationDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
			}

			if (ContainedVariantName == "stats")
			{
				var descriptor = new StatsAggregationDescriptor();
				((Action<StatsAggregationDescriptor>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
			}

			if (ContainedVariantName == "stats_bucket")
			{
				var descriptor = new StatsBucketAggregationDescriptor();
				((Action<StatsBucketAggregationDescriptor>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
			}

			if (ContainedVariantName == "string_stats")
			{
				var descriptor = new StringStatsAggregationDescriptor();
				((Action<StringStatsAggregationDescriptor>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
			}

			if (ContainedVariantName == "sum")
			{
				var descriptor = new SumAggregationDescriptor();
				((Action<SumAggregationDescriptor>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
			}

			if (ContainedVariantName == "sum_bucket")
			{
				var descriptor = new SumBucketAggregationDescriptor();
				((Action<SumBucketAggregationDescriptor>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
			}

			if (ContainedVariantName == "terms")
			{
				var descriptor = new TermsAggregationDescriptor<T>();
				((Action<TermsAggregationDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
			}

			if (ContainedVariantName == "top_hits")
			{
				var descriptor = new TopHitsAggregationDescriptor<T>();
				((Action<TopHitsAggregationDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
			}

			if (ContainedVariantName == "t_test")
			{
				var descriptor = new TTestAggregationDescriptor<T>();
				((Action<TTestAggregationDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
			}

			if (ContainedVariantName == "top_metrics")
			{
				var descriptor = new TopMetricsAggregationDescriptor<T>();
				((Action<TopMetricsAggregationDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
			}

			if (ContainedVariantName == "value_count")
			{
				var descriptor = new ValueCountAggregationDescriptor();
				((Action<ValueCountAggregationDescriptor>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
			}

			if (ContainedVariantName == "weighted_avg")
			{
				var descriptor = new WeightedAverageAggregationDescriptor<T>();
				((Action<WeightedAverageAggregationDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
			}

			if (ContainedVariantName == "variable_width_histogram")
			{
				var descriptor = new VariableWidthHistogramAggregationDescriptor<T>();
				((Action<VariableWidthHistogramAggregationDescriptor<T>>)ContainerVariantDescriptorAction).Invoke(descriptor);
				JsonSerializer.Serialize(writer, descriptor, options);
			}

			writer.WriteEndObject();
			writer.WriteEndObject();
		}
	}

	public partial class AggregationRange
	{
		[JsonInclude]
		[JsonPropertyName("from")]
		public Union<double?, string?>? From { get; set; }

		[JsonInclude]
		[JsonPropertyName("key")]
		public string? Key { get; set; }

		[JsonInclude]
		[JsonPropertyName("to")]
		public Union<double?, string?>? To { get; set; }
	}

	public sealed partial class AggregationRangeDescriptor : DescriptorBase<AggregationRangeDescriptor>
	{
		public AggregationRangeDescriptor()
		{
		}

		internal AggregationRangeDescriptor(Action<AggregationRangeDescriptor> configure) => configure.Invoke(this);
		internal Union<double?, string?>? FromValue { get; private set; }

		internal string? KeyValue { get; private set; }

		internal Union<double?, string?>? ToValue { get; private set; }

		public AggregationRangeDescriptor From(Union<double?, string?>? from) => Assign(from, (a, v) => a.FromValue = v);
		public AggregationRangeDescriptor Key(string? key) => Assign(key, (a, v) => a.KeyValue = v);
		public AggregationRangeDescriptor To(Union<double?, string?>? to) => Assign(to, (a, v) => a.ToValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (FromValue is not null)
			{
				writer.WritePropertyName("from");
				JsonSerializer.Serialize(writer, FromValue, options);
			}

			if (!string.IsNullOrEmpty(KeyValue))
			{
				writer.WritePropertyName("key");
				writer.WriteStringValue(KeyValue);
			}

			if (ToValue is not null)
			{
				writer.WritePropertyName("to");
				JsonSerializer.Serialize(writer, ToValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class ArrayPercentilesItem
	{
		[JsonInclude]
		[JsonPropertyName("key")]
		public string Key { get; init; }

		[JsonInclude]
		[JsonPropertyName("value")]
		public object Value { get; init; }

		[JsonInclude]
		[JsonPropertyName("value_as_string")]
		public string? ValueAsString { get; init; }
	}

	public partial class AutoDateHistogramAggregate : Aggregations.MultiBucketAggregateBase<Elastic.Clients.Elasticsearch.Aggregations.DateHistogramBucket>
	{
		[JsonInclude]
		[JsonPropertyName("interval")]
		public string Interval { get; init; }
	}

	public partial class AutoDateHistogramAggregation : Aggregations.BucketAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "auto_date_histogram";
		[JsonInclude]
		[JsonPropertyName("buckets")]
		public int? Buckets { get; set; }

		[JsonInclude]
		[JsonPropertyName("field")]
		public string? Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("format")]
		public string? Format { get; set; }

		[JsonInclude]
		[JsonPropertyName("minimum_interval")]
		public Elastic.Clients.Elasticsearch.Aggregations.MinimumInterval? MinimumInterval { get; set; }

		[JsonInclude]
		[JsonPropertyName("missing")]
		public string? Missing { get; set; }

		[JsonInclude]
		[JsonPropertyName("offset")]
		public string? Offset { get; set; }

		[JsonInclude]
		[JsonPropertyName("params")]
		public Dictionary<string, object>? Params { get; set; }

		[JsonInclude]
		[JsonPropertyName("script")]
		public Elastic.Clients.Elasticsearch.Script? Script { get; set; }

		[JsonInclude]
		[JsonPropertyName("time_zone")]
		public string? TimeZone { get; set; }
	}

	public sealed partial class AutoDateHistogramAggregationDescriptor<T> : DescriptorBase<AutoDateHistogramAggregationDescriptor<T>>
	{
		public AutoDateHistogramAggregationDescriptor()
		{
		}

		internal AutoDateHistogramAggregationDescriptor(Action<AutoDateHistogramAggregationDescriptor<T>> configure) => configure.Invoke(this);
		internal int? BucketsValue { get; private set; }

		internal string? FieldValue { get; private set; }

		internal string? FormatValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Aggregations.MinimumInterval? MinimumIntervalValue { get; private set; }

		internal string? MissingValue { get; private set; }

		internal string? OffsetValue { get; private set; }

		internal Dictionary<string, object>? ParamsValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Script? ScriptValue { get; private set; }

		internal string? TimeZoneValue { get; private set; }

		public AutoDateHistogramAggregationDescriptor<T> Buckets(int? buckets) => Assign(buckets, (a, v) => a.BucketsValue = v);
		public AutoDateHistogramAggregationDescriptor<T> Field(string? field) => Assign(field, (a, v) => a.FieldValue = v);
		public AutoDateHistogramAggregationDescriptor<T> Format(string? format) => Assign(format, (a, v) => a.FormatValue = v);
		public AutoDateHistogramAggregationDescriptor<T> MinimumInterval(Elastic.Clients.Elasticsearch.Aggregations.MinimumInterval? minimumInterval) => Assign(minimumInterval, (a, v) => a.MinimumIntervalValue = v);
		public AutoDateHistogramAggregationDescriptor<T> Missing(string? missing) => Assign(missing, (a, v) => a.MissingValue = v);
		public AutoDateHistogramAggregationDescriptor<T> Offset(string? offset) => Assign(offset, (a, v) => a.OffsetValue = v);
		public AutoDateHistogramAggregationDescriptor<T> Params(Func<FluentDictionary<string?, object?>, FluentDictionary<string?, object?>> selector) => Assign(selector, (a, v) => a.ParamsValue = v?.Invoke(new FluentDictionary<string?, object?>()));
		public AutoDateHistogramAggregationDescriptor<T> Script(Elastic.Clients.Elasticsearch.Script? script) => Assign(script, (a, v) => a.ScriptValue = v);
		public AutoDateHistogramAggregationDescriptor<T> TimeZone(string? timeZone) => Assign(timeZone, (a, v) => a.TimeZoneValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (BucketsValue.HasValue)
			{
				writer.WritePropertyName("buckets");
				writer.WriteNumberValue(BucketsValue.Value);
			}

			if (FieldValue is not null)
			{
				writer.WritePropertyName("field");
				JsonSerializer.Serialize(writer, FieldValue, options);
			}

			if (!string.IsNullOrEmpty(FormatValue))
			{
				writer.WritePropertyName("format");
				writer.WriteStringValue(FormatValue);
			}

			if (MinimumIntervalValue is not null)
			{
				writer.WritePropertyName("minimum_interval");
				JsonSerializer.Serialize(writer, MinimumIntervalValue, options);
			}

			if (MissingValue is not null)
			{
				writer.WritePropertyName("missing");
				JsonSerializer.Serialize(writer, MissingValue, options);
			}

			if (!string.IsNullOrEmpty(OffsetValue))
			{
				writer.WritePropertyName("offset");
				writer.WriteStringValue(OffsetValue);
			}

			if (ParamsValue is not null)
			{
				writer.WritePropertyName("params");
				JsonSerializer.Serialize(writer, ParamsValue, options);
			}

			if (ScriptValue is not null)
			{
				writer.WritePropertyName("script");
				JsonSerializer.Serialize(writer, ScriptValue, options);
			}

			if (!string.IsNullOrEmpty(TimeZoneValue))
			{
				writer.WritePropertyName("time_zone");
				writer.WriteStringValue(TimeZoneValue);
			}

			writer.WriteEndObject();
		}
	}

	public partial class AverageAggregation : Aggregations.FormatMetricAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "avg";
	}

	public sealed partial class AverageAggregationDescriptor : DescriptorBase<AverageAggregationDescriptor>
	{
		public AverageAggregationDescriptor()
		{
		}

		internal AverageAggregationDescriptor(Action<AverageAggregationDescriptor> configure) => configure.Invoke(this);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WriteEndObject();
		}
	}

	public partial class AverageBucketAggregation : Aggregations.PipelineAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "avg_bucket";
	}

	public sealed partial class AverageBucketAggregationDescriptor : DescriptorBase<AverageBucketAggregationDescriptor>
	{
		public AverageBucketAggregationDescriptor()
		{
		}

		internal AverageBucketAggregationDescriptor(Action<AverageBucketAggregationDescriptor> configure) => configure.Invoke(this);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WriteEndObject();
		}
	}

	public partial class AvgAggregate : Aggregations.SingleMetricAggregateBase
	{
	}

	public partial class BoxPlotAggregate : Aggregations.AggregateBase
	{
		[JsonInclude]
		[JsonPropertyName("min")]
		public double Min { get; init; }

		[JsonInclude]
		[JsonPropertyName("max")]
		public double Max { get; init; }

		[JsonInclude]
		[JsonPropertyName("q1")]
		public double Q1 { get; init; }

		[JsonInclude]
		[JsonPropertyName("q2")]
		public double Q2 { get; init; }

		[JsonInclude]
		[JsonPropertyName("q3")]
		public double Q3 { get; init; }

		[JsonInclude]
		[JsonPropertyName("lower")]
		public double Lower { get; init; }

		[JsonInclude]
		[JsonPropertyName("upper")]
		public double Upper { get; init; }

		[JsonInclude]
		[JsonPropertyName("min_as_string")]
		public string? MinAsString { get; init; }

		[JsonInclude]
		[JsonPropertyName("max_as_string")]
		public string? MaxAsString { get; init; }

		[JsonInclude]
		[JsonPropertyName("q1_as_string")]
		public string? Q1AsString { get; init; }

		[JsonInclude]
		[JsonPropertyName("q2_as_string")]
		public string? Q2AsString { get; init; }

		[JsonInclude]
		[JsonPropertyName("q3_as_string")]
		public string? Q3AsString { get; init; }

		[JsonInclude]
		[JsonPropertyName("lower_as_string")]
		public string? LowerAsString { get; init; }

		[JsonInclude]
		[JsonPropertyName("upper_as_string")]
		public string? UpperAsString { get; init; }
	}

	public partial class BoxplotAggregation : Aggregations.MetricAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "boxplot";
		[JsonInclude]
		[JsonPropertyName("compression")]
		public double? Compression { get; set; }
	}

	public sealed partial class BoxplotAggregationDescriptor : DescriptorBase<BoxplotAggregationDescriptor>
	{
		public BoxplotAggregationDescriptor()
		{
		}

		internal BoxplotAggregationDescriptor(Action<BoxplotAggregationDescriptor> configure) => configure.Invoke(this);
		internal double? CompressionValue { get; private set; }

		public BoxplotAggregationDescriptor Compression(double? compression) => Assign(compression, (a, v) => a.CompressionValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (CompressionValue.HasValue)
			{
				writer.WritePropertyName("compression");
				writer.WriteNumberValue(CompressionValue.Value);
			}

			writer.WriteEndObject();
		}
	}

	public abstract partial class BucketAggregationBase : Aggregations.AggregationBase
	{
	}

	public sealed partial class BucketAggregationBaseDescriptor : DescriptorBase<BucketAggregationBaseDescriptor>
	{
		public BucketAggregationBaseDescriptor()
		{
		}

		internal BucketAggregationBaseDescriptor(Action<BucketAggregationBaseDescriptor> configure) => configure.Invoke(this);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WriteEndObject();
		}
	}

	public partial class BucketMetricValueAggregate : Aggregations.SingleMetricAggregateBase
	{
		[JsonInclude]
		[JsonPropertyName("keys")]
		public IReadOnlyCollection<string> Keys { get; init; }
	}

	public partial class BucketScriptAggregation : Aggregations.PipelineAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "bucket_script";
		[JsonInclude]
		[JsonPropertyName("script")]
		public Elastic.Clients.Elasticsearch.Script? Script { get; set; }
	}

	public sealed partial class BucketScriptAggregationDescriptor : DescriptorBase<BucketScriptAggregationDescriptor>
	{
		public BucketScriptAggregationDescriptor()
		{
		}

		internal BucketScriptAggregationDescriptor(Action<BucketScriptAggregationDescriptor> configure) => configure.Invoke(this);
		internal Elastic.Clients.Elasticsearch.Script? ScriptValue { get; private set; }

		public BucketScriptAggregationDescriptor Script(Elastic.Clients.Elasticsearch.Script? script) => Assign(script, (a, v) => a.ScriptValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (ScriptValue is not null)
			{
				writer.WritePropertyName("script");
				JsonSerializer.Serialize(writer, ScriptValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class BucketSelectorAggregation : Aggregations.PipelineAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "bucket_selector";
		[JsonInclude]
		[JsonPropertyName("script")]
		public Elastic.Clients.Elasticsearch.Script? Script { get; set; }
	}

	public sealed partial class BucketSelectorAggregationDescriptor : DescriptorBase<BucketSelectorAggregationDescriptor>
	{
		public BucketSelectorAggregationDescriptor()
		{
		}

		internal BucketSelectorAggregationDescriptor(Action<BucketSelectorAggregationDescriptor> configure) => configure.Invoke(this);
		internal Elastic.Clients.Elasticsearch.Script? ScriptValue { get; private set; }

		public BucketSelectorAggregationDescriptor Script(Elastic.Clients.Elasticsearch.Script? script) => Assign(script, (a, v) => a.ScriptValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (ScriptValue is not null)
			{
				writer.WritePropertyName("script");
				JsonSerializer.Serialize(writer, ScriptValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class BucketSortAggregation : Aggregations.AggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "bucket_sort";
		[JsonInclude]
		[JsonPropertyName("from")]
		public int? From { get; set; }

		[JsonInclude]
		[JsonPropertyName("gap_policy")]
		public Elastic.Clients.Elasticsearch.Aggregations.GapPolicy? GapPolicy { get; set; }

		[JsonInclude]
		[JsonPropertyName("size")]
		public int? Size { get; set; }

		[JsonInclude]
		[JsonPropertyName("sort")]
		public Elastic.Clients.Elasticsearch.Sort? Sort { get; set; }
	}

	public sealed partial class BucketSortAggregationDescriptor : DescriptorBase<BucketSortAggregationDescriptor>
	{
		public BucketSortAggregationDescriptor()
		{
		}

		internal BucketSortAggregationDescriptor(Action<BucketSortAggregationDescriptor> configure) => configure.Invoke(this);
		internal int? FromValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Aggregations.GapPolicy? GapPolicyValue { get; private set; }

		internal int? SizeValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Sort? SortValue { get; private set; }

		public BucketSortAggregationDescriptor From(int? from) => Assign(from, (a, v) => a.FromValue = v);
		public BucketSortAggregationDescriptor GapPolicy(Elastic.Clients.Elasticsearch.Aggregations.GapPolicy? gapPolicy) => Assign(gapPolicy, (a, v) => a.GapPolicyValue = v);
		public BucketSortAggregationDescriptor Size(int? size) => Assign(size, (a, v) => a.SizeValue = v);
		public BucketSortAggregationDescriptor Sort(Elastic.Clients.Elasticsearch.Sort? sort) => Assign(sort, (a, v) => a.SortValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (FromValue.HasValue)
			{
				writer.WritePropertyName("from");
				writer.WriteNumberValue(FromValue.Value);
			}

			if (GapPolicyValue is not null)
			{
				writer.WritePropertyName("gap_policy");
				JsonSerializer.Serialize(writer, GapPolicyValue, options);
			}

			if (SizeValue.HasValue)
			{
				writer.WritePropertyName("size");
				writer.WriteNumberValue(SizeValue.Value);
			}

			if (SortValue is not null)
			{
				writer.WritePropertyName("sort");
				JsonSerializer.Serialize(writer, SortValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class CardinalityAggregate : Aggregations.AggregateBase
	{
		[JsonInclude]
		[JsonPropertyName("value")]
		public long Value { get; init; }
	}

	public partial class CardinalityAggregation : Aggregations.MetricAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "cardinality";
		[JsonInclude]
		[JsonPropertyName("precision_threshold")]
		public int? PrecisionThreshold { get; set; }

		[JsonInclude]
		[JsonPropertyName("rehash")]
		public bool? Rehash { get; set; }
	}

	public sealed partial class CardinalityAggregationDescriptor : DescriptorBase<CardinalityAggregationDescriptor>
	{
		public CardinalityAggregationDescriptor()
		{
		}

		internal CardinalityAggregationDescriptor(Action<CardinalityAggregationDescriptor> configure) => configure.Invoke(this);
		internal int? PrecisionThresholdValue { get; private set; }

		internal bool? RehashValue { get; private set; }

		public CardinalityAggregationDescriptor PrecisionThreshold(int? precisionThreshold) => Assign(precisionThreshold, (a, v) => a.PrecisionThresholdValue = v);
		public CardinalityAggregationDescriptor Rehash(bool? rehash = true) => Assign(rehash, (a, v) => a.RehashValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (PrecisionThresholdValue.HasValue)
			{
				writer.WritePropertyName("precision_threshold");
				writer.WriteNumberValue(PrecisionThresholdValue.Value);
			}

			if (RehashValue.HasValue)
			{
				writer.WritePropertyName("rehash");
				writer.WriteBooleanValue(RehashValue.Value);
			}

			writer.WriteEndObject();
		}
	}

	public partial class ChildrenAggregate : Aggregations.MultiBucketAggregateBase<Elastic.Clients.Elasticsearch.Aggregations.ChildrenAggregateBucket>
	{
	}

	public partial class ChildrenAggregateBucket : Aggregations.MultiBucketBase
	{
	}

	public partial class ChildrenAggregation : Aggregations.BucketAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "children";
		[JsonInclude]
		[JsonPropertyName("type")]
		public string? Type { get; set; }
	}

	public sealed partial class ChildrenAggregationDescriptor : DescriptorBase<ChildrenAggregationDescriptor>
	{
		public ChildrenAggregationDescriptor()
		{
		}

		internal ChildrenAggregationDescriptor(Action<ChildrenAggregationDescriptor> configure) => configure.Invoke(this);
		internal string? TypeValue { get; private set; }

		public ChildrenAggregationDescriptor Type(string? type) => Assign(type, (a, v) => a.TypeValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (TypeValue is not null)
			{
				writer.WritePropertyName("type");
				JsonSerializer.Serialize(writer, TypeValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class ChiSquareHeuristic
	{
		[JsonInclude]
		[JsonPropertyName("background_is_superset")]
		public bool BackgroundIsSuperset { get; set; }

		[JsonInclude]
		[JsonPropertyName("include_negatives")]
		public bool IncludeNegatives { get; set; }
	}

	public sealed partial class ChiSquareHeuristicDescriptor : DescriptorBase<ChiSquareHeuristicDescriptor>
	{
		public ChiSquareHeuristicDescriptor()
		{
		}

		internal ChiSquareHeuristicDescriptor(Action<ChiSquareHeuristicDescriptor> configure) => configure.Invoke(this);
		internal bool BackgroundIsSupersetValue { get; private set; }

		internal bool IncludeNegativesValue { get; private set; }

		public ChiSquareHeuristicDescriptor BackgroundIsSuperset(bool backgroundIsSuperset = true) => Assign(backgroundIsSuperset, (a, v) => a.BackgroundIsSupersetValue = v);
		public ChiSquareHeuristicDescriptor IncludeNegatives(bool includeNegatives = true) => Assign(includeNegatives, (a, v) => a.IncludeNegativesValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("background_is_superset");
			writer.WriteBooleanValue(BackgroundIsSupersetValue);
			writer.WritePropertyName("include_negatives");
			writer.WriteBooleanValue(IncludeNegativesValue);
			writer.WriteEndObject();
		}
	}

	public partial class ClassificationInferenceOptions
	{
		[JsonInclude]
		[JsonPropertyName("num_top_classes")]
		public int? NumTopClasses { get; set; }

		[JsonInclude]
		[JsonPropertyName("num_top_feature_importance_values")]
		public int? NumTopFeatureImportanceValues { get; set; }

		[JsonInclude]
		[JsonPropertyName("prediction_field_type")]
		public string? PredictionFieldType { get; set; }

		[JsonInclude]
		[JsonPropertyName("results_field")]
		public string? ResultsField { get; set; }

		[JsonInclude]
		[JsonPropertyName("top_classes_results_field")]
		public string? TopClassesResultsField { get; set; }
	}

	public sealed partial class ClassificationInferenceOptionsDescriptor : DescriptorBase<ClassificationInferenceOptionsDescriptor>
	{
		public ClassificationInferenceOptionsDescriptor()
		{
		}

		internal ClassificationInferenceOptionsDescriptor(Action<ClassificationInferenceOptionsDescriptor> configure) => configure.Invoke(this);
		internal int? NumTopClassesValue { get; private set; }

		internal int? NumTopFeatureImportanceValuesValue { get; private set; }

		internal string? PredictionFieldTypeValue { get; private set; }

		internal string? ResultsFieldValue { get; private set; }

		internal string? TopClassesResultsFieldValue { get; private set; }

		public ClassificationInferenceOptionsDescriptor NumTopClasses(int? numTopClasses) => Assign(numTopClasses, (a, v) => a.NumTopClassesValue = v);
		public ClassificationInferenceOptionsDescriptor NumTopFeatureImportanceValues(int? numTopFeatureImportanceValues) => Assign(numTopFeatureImportanceValues, (a, v) => a.NumTopFeatureImportanceValuesValue = v);
		public ClassificationInferenceOptionsDescriptor PredictionFieldType(string? predictionFieldType) => Assign(predictionFieldType, (a, v) => a.PredictionFieldTypeValue = v);
		public ClassificationInferenceOptionsDescriptor ResultsField(string? resultsField) => Assign(resultsField, (a, v) => a.ResultsFieldValue = v);
		public ClassificationInferenceOptionsDescriptor TopClassesResultsField(string? topClassesResultsField) => Assign(topClassesResultsField, (a, v) => a.TopClassesResultsFieldValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (NumTopClassesValue.HasValue)
			{
				writer.WritePropertyName("num_top_classes");
				writer.WriteNumberValue(NumTopClassesValue.Value);
			}

			if (NumTopFeatureImportanceValuesValue.HasValue)
			{
				writer.WritePropertyName("num_top_feature_importance_values");
				writer.WriteNumberValue(NumTopFeatureImportanceValuesValue.Value);
			}

			if (!string.IsNullOrEmpty(PredictionFieldTypeValue))
			{
				writer.WritePropertyName("prediction_field_type");
				writer.WriteStringValue(PredictionFieldTypeValue);
			}

			if (!string.IsNullOrEmpty(ResultsFieldValue))
			{
				writer.WritePropertyName("results_field");
				writer.WriteStringValue(ResultsFieldValue);
			}

			if (!string.IsNullOrEmpty(TopClassesResultsFieldValue))
			{
				writer.WritePropertyName("top_classes_results_field");
				writer.WriteStringValue(TopClassesResultsFieldValue);
			}

			writer.WriteEndObject();
		}
	}

	public partial class CompositeAggregate : Aggregations.MultiBucketAggregateBase<Elastic.Clients.Elasticsearch.Aggregations.CompositeBucket>
	{
		[JsonInclude]
		[JsonPropertyName("after_key")]
		public Dictionary<string, object>? AfterKey { get; init; }
	}

	public partial class CompositeAggregation : Aggregations.BucketAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "composite";
		[JsonInclude]
		[JsonPropertyName("after")]
		public Dictionary<string, object>? After { get; set; }

		[JsonInclude]
		[JsonPropertyName("size")]
		public int? Size { get; set; }

		[JsonInclude]
		[JsonPropertyName("sources")]
		public IEnumerable<Dictionary<string, Elastic.Clients.Elasticsearch.Aggregations.CompositeAggregationSource>>? Sources { get; set; }
	}

	public sealed partial class CompositeAggregationDescriptor : DescriptorBase<CompositeAggregationDescriptor>
	{
		public CompositeAggregationDescriptor()
		{
		}

		internal CompositeAggregationDescriptor(Action<CompositeAggregationDescriptor> configure) => configure.Invoke(this);
		internal Dictionary<string, object>? AfterValue { get; private set; }

		internal int? SizeValue { get; private set; }

		internal IEnumerable<Dictionary<string, Elastic.Clients.Elasticsearch.Aggregations.CompositeAggregationSource>>? SourcesValue { get; private set; }

		public CompositeAggregationDescriptor After(Func<FluentDictionary<string?, object?>, FluentDictionary<string?, object?>> selector) => Assign(selector, (a, v) => a.AfterValue = v?.Invoke(new FluentDictionary<string?, object?>()));
		public CompositeAggregationDescriptor Size(int? size) => Assign(size, (a, v) => a.SizeValue = v);
		public CompositeAggregationDescriptor Sources(IEnumerable<Dictionary<string, Elastic.Clients.Elasticsearch.Aggregations.CompositeAggregationSource>>? sources) => Assign(sources, (a, v) => a.SourcesValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (AfterValue is not null)
			{
				writer.WritePropertyName("after");
				JsonSerializer.Serialize(writer, AfterValue, options);
			}

			if (SizeValue.HasValue)
			{
				writer.WritePropertyName("size");
				writer.WriteNumberValue(SizeValue.Value);
			}

			if (SourcesValue is not null)
			{
				writer.WritePropertyName("sources");
				JsonSerializer.Serialize(writer, SourcesValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class CompositeAggregationSource
	{
		[JsonInclude]
		[JsonPropertyName("terms")]
		public Elastic.Clients.Elasticsearch.Aggregations.TermsAggregation? Terms { get; set; }

		[JsonInclude]
		[JsonPropertyName("histogram")]
		public Elastic.Clients.Elasticsearch.Aggregations.HistogramAggregation? Histogram { get; set; }

		[JsonInclude]
		[JsonPropertyName("date_histogram")]
		public Elastic.Clients.Elasticsearch.Aggregations.DateHistogramAggregation? DateHistogram { get; set; }

		[JsonInclude]
		[JsonPropertyName("geotile_grid")]
		public Elastic.Clients.Elasticsearch.Aggregations.GeoTileGridAggregation? GeotileGrid { get; set; }
	}

	public sealed partial class CompositeAggregationSourceDescriptor<T> : DescriptorBase<CompositeAggregationSourceDescriptor<T>>
	{
		public CompositeAggregationSourceDescriptor()
		{
		}

		internal CompositeAggregationSourceDescriptor(Action<CompositeAggregationSourceDescriptor<T>> configure) => configure.Invoke(this);
		internal Elastic.Clients.Elasticsearch.Aggregations.TermsAggregation? TermsValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Aggregations.HistogramAggregation? HistogramValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Aggregations.DateHistogramAggregation? DateHistogramValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Aggregations.GeoTileGridAggregation? GeotileGridValue { get; private set; }

		internal TermsAggregationDescriptor<T> TermsDescriptor { get; private set; }

		internal HistogramAggregationDescriptor<T> HistogramDescriptor { get; private set; }

		internal DateHistogramAggregationDescriptor<T> DateHistogramDescriptor { get; private set; }

		internal GeoTileGridAggregationDescriptor<T> GeotileGridDescriptor { get; private set; }

		internal Action<TermsAggregationDescriptor<T>> TermsDescriptorAction { get; private set; }

		internal Action<HistogramAggregationDescriptor<T>> HistogramDescriptorAction { get; private set; }

		internal Action<DateHistogramAggregationDescriptor<T>> DateHistogramDescriptorAction { get; private set; }

		internal Action<GeoTileGridAggregationDescriptor<T>> GeotileGridDescriptorAction { get; private set; }

		public CompositeAggregationSourceDescriptor<T> Terms(Elastic.Clients.Elasticsearch.Aggregations.TermsAggregation? terms)
		{
			TermsDescriptor = null;
			TermsDescriptorAction = null;
			return Assign(terms, (a, v) => a.TermsValue = v);
		}

		public CompositeAggregationSourceDescriptor<T> Terms(Elastic.Clients.Elasticsearch.Aggregations.TermsAggregationDescriptor<T> descriptor)
		{
			TermsValue = null;
			TermsDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.TermsDescriptor = v);
		}

		public CompositeAggregationSourceDescriptor<T> Terms(Action<Elastic.Clients.Elasticsearch.Aggregations.TermsAggregationDescriptor<T>> configure)
		{
			TermsValue = null;
			TermsDescriptorAction = null;
			return Assign(configure, (a, v) => a.TermsDescriptorAction = v);
		}

		public CompositeAggregationSourceDescriptor<T> Histogram(Elastic.Clients.Elasticsearch.Aggregations.HistogramAggregation? histogram)
		{
			HistogramDescriptor = null;
			HistogramDescriptorAction = null;
			return Assign(histogram, (a, v) => a.HistogramValue = v);
		}

		public CompositeAggregationSourceDescriptor<T> Histogram(Elastic.Clients.Elasticsearch.Aggregations.HistogramAggregationDescriptor<T> descriptor)
		{
			HistogramValue = null;
			HistogramDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.HistogramDescriptor = v);
		}

		public CompositeAggregationSourceDescriptor<T> Histogram(Action<Elastic.Clients.Elasticsearch.Aggregations.HistogramAggregationDescriptor<T>> configure)
		{
			HistogramValue = null;
			HistogramDescriptorAction = null;
			return Assign(configure, (a, v) => a.HistogramDescriptorAction = v);
		}

		public CompositeAggregationSourceDescriptor<T> DateHistogram(Elastic.Clients.Elasticsearch.Aggregations.DateHistogramAggregation? dateHistogram)
		{
			DateHistogramDescriptor = null;
			DateHistogramDescriptorAction = null;
			return Assign(dateHistogram, (a, v) => a.DateHistogramValue = v);
		}

		public CompositeAggregationSourceDescriptor<T> DateHistogram(Elastic.Clients.Elasticsearch.Aggregations.DateHistogramAggregationDescriptor<T> descriptor)
		{
			DateHistogramValue = null;
			DateHistogramDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.DateHistogramDescriptor = v);
		}

		public CompositeAggregationSourceDescriptor<T> DateHistogram(Action<Elastic.Clients.Elasticsearch.Aggregations.DateHistogramAggregationDescriptor<T>> configure)
		{
			DateHistogramValue = null;
			DateHistogramDescriptorAction = null;
			return Assign(configure, (a, v) => a.DateHistogramDescriptorAction = v);
		}

		public CompositeAggregationSourceDescriptor<T> GeotileGrid(Elastic.Clients.Elasticsearch.Aggregations.GeoTileGridAggregation? geotileGrid)
		{
			GeotileGridDescriptor = null;
			GeotileGridDescriptorAction = null;
			return Assign(geotileGrid, (a, v) => a.GeotileGridValue = v);
		}

		public CompositeAggregationSourceDescriptor<T> GeotileGrid(Elastic.Clients.Elasticsearch.Aggregations.GeoTileGridAggregationDescriptor<T> descriptor)
		{
			GeotileGridValue = null;
			GeotileGridDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.GeotileGridDescriptor = v);
		}

		public CompositeAggregationSourceDescriptor<T> GeotileGrid(Action<Elastic.Clients.Elasticsearch.Aggregations.GeoTileGridAggregationDescriptor<T>> configure)
		{
			GeotileGridValue = null;
			GeotileGridDescriptorAction = null;
			return Assign(configure, (a, v) => a.GeotileGridDescriptorAction = v);
		}

		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (TermsDescriptor is not null)
			{
				writer.WritePropertyName("terms");
				JsonSerializer.Serialize(writer, TermsDescriptor, options);
			}
			else if (TermsDescriptorAction is not null)
			{
				writer.WritePropertyName("terms");
				JsonSerializer.Serialize(writer, new TermsAggregationDescriptor<T>(TermsDescriptorAction), options);
			}
			else if (TermsValue is not null)
			{
				writer.WritePropertyName("terms");
				JsonSerializer.Serialize(writer, TermsValue, options);
			}

			if (HistogramDescriptor is not null)
			{
				writer.WritePropertyName("histogram");
				JsonSerializer.Serialize(writer, HistogramDescriptor, options);
			}
			else if (HistogramDescriptorAction is not null)
			{
				writer.WritePropertyName("histogram");
				JsonSerializer.Serialize(writer, new HistogramAggregationDescriptor<T>(HistogramDescriptorAction), options);
			}
			else if (HistogramValue is not null)
			{
				writer.WritePropertyName("histogram");
				JsonSerializer.Serialize(writer, HistogramValue, options);
			}

			if (DateHistogramDescriptor is not null)
			{
				writer.WritePropertyName("date_histogram");
				JsonSerializer.Serialize(writer, DateHistogramDescriptor, options);
			}
			else if (DateHistogramDescriptorAction is not null)
			{
				writer.WritePropertyName("date_histogram");
				JsonSerializer.Serialize(writer, new DateHistogramAggregationDescriptor<T>(DateHistogramDescriptorAction), options);
			}
			else if (DateHistogramValue is not null)
			{
				writer.WritePropertyName("date_histogram");
				JsonSerializer.Serialize(writer, DateHistogramValue, options);
			}

			if (GeotileGridDescriptor is not null)
			{
				writer.WritePropertyName("geotile_grid");
				JsonSerializer.Serialize(writer, GeotileGridDescriptor, options);
			}
			else if (GeotileGridDescriptorAction is not null)
			{
				writer.WritePropertyName("geotile_grid");
				JsonSerializer.Serialize(writer, new GeoTileGridAggregationDescriptor<T>(GeotileGridDescriptorAction), options);
			}
			else if (GeotileGridValue is not null)
			{
				writer.WritePropertyName("geotile_grid");
				JsonSerializer.Serialize(writer, GeotileGridValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class CompositeBucket : Aggregations.MultiBucketBase
	{
		[JsonInclude]
		[JsonPropertyName("key")]
		public Dictionary<string, object> Key { get; init; }
	}

	public partial class CumulativeCardinalityAggregate : Aggregations.AggregateBase
	{
		[JsonInclude]
		[JsonPropertyName("value")]
		public long Value { get; init; }

		[JsonInclude]
		[JsonPropertyName("value_as_string")]
		public string? ValueAsString { get; init; }
	}

	public partial class CumulativeCardinalityAggregation : Aggregations.PipelineAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "cumulative_cardinality";
	}

	public sealed partial class CumulativeCardinalityAggregationDescriptor : DescriptorBase<CumulativeCardinalityAggregationDescriptor>
	{
		public CumulativeCardinalityAggregationDescriptor()
		{
		}

		internal CumulativeCardinalityAggregationDescriptor(Action<CumulativeCardinalityAggregationDescriptor> configure) => configure.Invoke(this);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WriteEndObject();
		}
	}

	public partial class CumulativeSumAggregation : Aggregations.PipelineAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "cumulative_sum";
	}

	public sealed partial class CumulativeSumAggregationDescriptor : DescriptorBase<CumulativeSumAggregationDescriptor>
	{
		public CumulativeSumAggregationDescriptor()
		{
		}

		internal CumulativeSumAggregationDescriptor(Action<CumulativeSumAggregationDescriptor> configure) => configure.Invoke(this);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WriteEndObject();
		}
	}

	public partial class DateHistogramAggregate : Aggregations.MultiBucketAggregateBase<Elastic.Clients.Elasticsearch.Aggregations.DateHistogramBucket>
	{
	}

	public partial class DateHistogramAggregation : Aggregations.BucketAggregationBase, IAggregationContainerVariant, TransformManagement.IPivotGroupByContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "date_histogram";
		[JsonIgnore]
		string TransformManagement.IPivotGroupByContainerVariant.PivotGroupByContainerVariantName => "date_histogram";
		[JsonInclude]
		[JsonPropertyName("calendar_interval")]
		public Elastic.Clients.Elasticsearch.Aggregations.CalendarInterval? CalendarInterval { get; set; }

		[JsonInclude]
		[JsonPropertyName("field")]
		public string? Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("fixed_interval")]
		public Elastic.Clients.Elasticsearch.Time? FixedInterval { get; set; }

		[JsonInclude]
		[JsonPropertyName("format")]
		public string? Format { get; set; }

		[JsonInclude]
		[JsonPropertyName("interval")]
		public Elastic.Clients.Elasticsearch.Time? Interval { get; set; }

		[JsonInclude]
		[JsonPropertyName("min_doc_count")]
		public int? MinDocCount { get; set; }

		[JsonInclude]
		[JsonPropertyName("missing")]
		public string? Missing { get; set; }

		[JsonInclude]
		[JsonPropertyName("offset")]
		public Elastic.Clients.Elasticsearch.Time? Offset { get; set; }

		[JsonInclude]
		[JsonPropertyName("order")]
		public Elastic.Clients.Elasticsearch.Aggregations.HistogramOrder? Order { get; set; }

		[JsonInclude]
		[JsonPropertyName("params")]
		public Dictionary<string, object>? Params { get; set; }

		[JsonInclude]
		[JsonPropertyName("script")]
		public Elastic.Clients.Elasticsearch.Script? Script { get; set; }

		[JsonInclude]
		[JsonPropertyName("time_zone")]
		public string? TimeZone { get; set; }

		[JsonInclude]
		[JsonPropertyName("keyed")]
		public bool? Keyed { get; set; }
	}

	public sealed partial class DateHistogramAggregationDescriptor<T> : DescriptorBase<DateHistogramAggregationDescriptor<T>>
	{
		public DateHistogramAggregationDescriptor()
		{
		}

		internal DateHistogramAggregationDescriptor(Action<DateHistogramAggregationDescriptor<T>> configure) => configure.Invoke(this);
		internal Elastic.Clients.Elasticsearch.Aggregations.CalendarInterval? CalendarIntervalValue { get; private set; }

		internal string? FieldValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Time? FixedIntervalValue { get; private set; }

		internal string? FormatValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Time? IntervalValue { get; private set; }

		internal int? MinDocCountValue { get; private set; }

		internal string? MissingValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Time? OffsetValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Aggregations.HistogramOrder? OrderValue { get; private set; }

		internal Dictionary<string, object>? ParamsValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Script? ScriptValue { get; private set; }

		internal string? TimeZoneValue { get; private set; }

		internal bool? KeyedValue { get; private set; }

		internal HistogramOrderDescriptor OrderDescriptor { get; private set; }

		internal Action<HistogramOrderDescriptor> OrderDescriptorAction { get; private set; }

		public DateHistogramAggregationDescriptor<T> CalendarInterval(Elastic.Clients.Elasticsearch.Aggregations.CalendarInterval? calendarInterval) => Assign(calendarInterval, (a, v) => a.CalendarIntervalValue = v);
		public DateHistogramAggregationDescriptor<T> Field(string? field) => Assign(field, (a, v) => a.FieldValue = v);
		public DateHistogramAggregationDescriptor<T> FixedInterval(Elastic.Clients.Elasticsearch.Time? fixedInterval) => Assign(fixedInterval, (a, v) => a.FixedIntervalValue = v);
		public DateHistogramAggregationDescriptor<T> Format(string? format) => Assign(format, (a, v) => a.FormatValue = v);
		public DateHistogramAggregationDescriptor<T> Interval(Elastic.Clients.Elasticsearch.Time? interval) => Assign(interval, (a, v) => a.IntervalValue = v);
		public DateHistogramAggregationDescriptor<T> MinDocCount(int? minDocCount) => Assign(minDocCount, (a, v) => a.MinDocCountValue = v);
		public DateHistogramAggregationDescriptor<T> Missing(string? missing) => Assign(missing, (a, v) => a.MissingValue = v);
		public DateHistogramAggregationDescriptor<T> Offset(Elastic.Clients.Elasticsearch.Time? offset) => Assign(offset, (a, v) => a.OffsetValue = v);
		public DateHistogramAggregationDescriptor<T> Order(Elastic.Clients.Elasticsearch.Aggregations.HistogramOrder? order)
		{
			OrderDescriptor = null;
			OrderDescriptorAction = null;
			return Assign(order, (a, v) => a.OrderValue = v);
		}

		public DateHistogramAggregationDescriptor<T> Order(Elastic.Clients.Elasticsearch.Aggregations.HistogramOrderDescriptor descriptor)
		{
			OrderValue = null;
			OrderDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.OrderDescriptor = v);
		}

		public DateHistogramAggregationDescriptor<T> Order(Action<Elastic.Clients.Elasticsearch.Aggregations.HistogramOrderDescriptor> configure)
		{
			OrderValue = null;
			OrderDescriptorAction = null;
			return Assign(configure, (a, v) => a.OrderDescriptorAction = v);
		}

		public DateHistogramAggregationDescriptor<T> Params(Func<FluentDictionary<string?, object?>, FluentDictionary<string?, object?>> selector) => Assign(selector, (a, v) => a.ParamsValue = v?.Invoke(new FluentDictionary<string?, object?>()));
		public DateHistogramAggregationDescriptor<T> Script(Elastic.Clients.Elasticsearch.Script? script) => Assign(script, (a, v) => a.ScriptValue = v);
		public DateHistogramAggregationDescriptor<T> TimeZone(string? timeZone) => Assign(timeZone, (a, v) => a.TimeZoneValue = v);
		public DateHistogramAggregationDescriptor<T> Keyed(bool? keyed = true) => Assign(keyed, (a, v) => a.KeyedValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (CalendarIntervalValue is not null)
			{
				writer.WritePropertyName("calendar_interval");
				JsonSerializer.Serialize(writer, CalendarIntervalValue, options);
			}

			if (FieldValue is not null)
			{
				writer.WritePropertyName("field");
				JsonSerializer.Serialize(writer, FieldValue, options);
			}

			if (FixedIntervalValue is not null)
			{
				writer.WritePropertyName("fixed_interval");
				JsonSerializer.Serialize(writer, FixedIntervalValue, options);
			}

			if (!string.IsNullOrEmpty(FormatValue))
			{
				writer.WritePropertyName("format");
				writer.WriteStringValue(FormatValue);
			}

			if (IntervalValue is not null)
			{
				writer.WritePropertyName("interval");
				JsonSerializer.Serialize(writer, IntervalValue, options);
			}

			if (MinDocCountValue.HasValue)
			{
				writer.WritePropertyName("min_doc_count");
				writer.WriteNumberValue(MinDocCountValue.Value);
			}

			if (MissingValue is not null)
			{
				writer.WritePropertyName("missing");
				JsonSerializer.Serialize(writer, MissingValue, options);
			}

			if (OffsetValue is not null)
			{
				writer.WritePropertyName("offset");
				JsonSerializer.Serialize(writer, OffsetValue, options);
			}

			if (OrderDescriptor is not null)
			{
				writer.WritePropertyName("order");
				JsonSerializer.Serialize(writer, OrderDescriptor, options);
			}
			else if (OrderDescriptorAction is not null)
			{
				writer.WritePropertyName("order");
				JsonSerializer.Serialize(writer, new HistogramOrderDescriptor(OrderDescriptorAction), options);
			}
			else if (OrderValue is not null)
			{
				writer.WritePropertyName("order");
				JsonSerializer.Serialize(writer, OrderValue, options);
			}

			if (ParamsValue is not null)
			{
				writer.WritePropertyName("params");
				JsonSerializer.Serialize(writer, ParamsValue, options);
			}

			if (ScriptValue is not null)
			{
				writer.WritePropertyName("script");
				JsonSerializer.Serialize(writer, ScriptValue, options);
			}

			if (!string.IsNullOrEmpty(TimeZoneValue))
			{
				writer.WritePropertyName("time_zone");
				writer.WriteStringValue(TimeZoneValue);
			}

			if (KeyedValue.HasValue)
			{
				writer.WritePropertyName("keyed");
				writer.WriteBooleanValue(KeyedValue.Value);
			}

			writer.WriteEndObject();
		}
	}

	public partial class DateHistogramBucket : Aggregations.MultiBucketBase
	{
		[JsonInclude]
		[JsonPropertyName("key_as_string")]
		public string? KeyAsString { get; init; }

		[JsonInclude]
		[JsonPropertyName("key")]
		public Elastic.Clients.Elasticsearch.EpochMillis Key { get; init; }
	}

	public partial class DateRangeAggregate : Aggregations.RangeAggregate
	{
	}

	public partial class DateRangeAggregation : Aggregations.BucketAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "date_range";
		[JsonInclude]
		[JsonPropertyName("field")]
		public string? Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("format")]
		public string? Format { get; set; }

		[JsonInclude]
		[JsonPropertyName("missing")]
		public Elastic.Clients.Elasticsearch.Aggregations.Missing? Missing { get; set; }

		[JsonInclude]
		[JsonPropertyName("ranges")]
		public IEnumerable<Elastic.Clients.Elasticsearch.Aggregations.DateRangeExpression>? Ranges { get; set; }

		[JsonInclude]
		[JsonPropertyName("time_zone")]
		public string? TimeZone { get; set; }

		[JsonInclude]
		[JsonPropertyName("keyed")]
		public bool? Keyed { get; set; }
	}

	public sealed partial class DateRangeAggregationDescriptor<T> : DescriptorBase<DateRangeAggregationDescriptor<T>>
	{
		public DateRangeAggregationDescriptor()
		{
		}

		internal DateRangeAggregationDescriptor(Action<DateRangeAggregationDescriptor<T>> configure) => configure.Invoke(this);
		internal string? FieldValue { get; private set; }

		internal string? FormatValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Aggregations.Missing? MissingValue { get; private set; }

		internal IEnumerable<Elastic.Clients.Elasticsearch.Aggregations.DateRangeExpression>? RangesValue { get; private set; }

		internal string? TimeZoneValue { get; private set; }

		internal bool? KeyedValue { get; private set; }

		public DateRangeAggregationDescriptor<T> Field(string? field) => Assign(field, (a, v) => a.FieldValue = v);
		public DateRangeAggregationDescriptor<T> Format(string? format) => Assign(format, (a, v) => a.FormatValue = v);
		public DateRangeAggregationDescriptor<T> Missing(Elastic.Clients.Elasticsearch.Aggregations.Missing? missing) => Assign(missing, (a, v) => a.MissingValue = v);
		public DateRangeAggregationDescriptor<T> Ranges(IEnumerable<Elastic.Clients.Elasticsearch.Aggregations.DateRangeExpression>? ranges) => Assign(ranges, (a, v) => a.RangesValue = v);
		public DateRangeAggregationDescriptor<T> TimeZone(string? timeZone) => Assign(timeZone, (a, v) => a.TimeZoneValue = v);
		public DateRangeAggregationDescriptor<T> Keyed(bool? keyed = true) => Assign(keyed, (a, v) => a.KeyedValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (FieldValue is not null)
			{
				writer.WritePropertyName("field");
				JsonSerializer.Serialize(writer, FieldValue, options);
			}

			if (!string.IsNullOrEmpty(FormatValue))
			{
				writer.WritePropertyName("format");
				writer.WriteStringValue(FormatValue);
			}

			if (MissingValue is not null)
			{
				writer.WritePropertyName("missing");
				JsonSerializer.Serialize(writer, MissingValue, options);
			}

			if (RangesValue is not null)
			{
				writer.WritePropertyName("ranges");
				JsonSerializer.Serialize(writer, RangesValue, options);
			}

			if (!string.IsNullOrEmpty(TimeZoneValue))
			{
				writer.WritePropertyName("time_zone");
				writer.WriteStringValue(TimeZoneValue);
			}

			if (KeyedValue.HasValue)
			{
				writer.WritePropertyName("keyed");
				writer.WriteBooleanValue(KeyedValue.Value);
			}

			writer.WriteEndObject();
		}
	}

	public partial class DateRangeExpression
	{
		[JsonInclude]
		[JsonPropertyName("from")]
		public Elastic.Clients.Elasticsearch.Aggregations.FieldDateMath? From { get; set; }

		[JsonInclude]
		[JsonPropertyName("key")]
		public string? Key { get; set; }

		[JsonInclude]
		[JsonPropertyName("to")]
		public Elastic.Clients.Elasticsearch.Aggregations.FieldDateMath? To { get; set; }
	}

	public sealed partial class DateRangeExpressionDescriptor : DescriptorBase<DateRangeExpressionDescriptor>
	{
		public DateRangeExpressionDescriptor()
		{
		}

		internal DateRangeExpressionDescriptor(Action<DateRangeExpressionDescriptor> configure) => configure.Invoke(this);
		internal Elastic.Clients.Elasticsearch.Aggregations.FieldDateMath? FromValue { get; private set; }

		internal string? KeyValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Aggregations.FieldDateMath? ToValue { get; private set; }

		public DateRangeExpressionDescriptor From(Elastic.Clients.Elasticsearch.Aggregations.FieldDateMath? from) => Assign(from, (a, v) => a.FromValue = v);
		public DateRangeExpressionDescriptor Key(string? key) => Assign(key, (a, v) => a.KeyValue = v);
		public DateRangeExpressionDescriptor To(Elastic.Clients.Elasticsearch.Aggregations.FieldDateMath? to) => Assign(to, (a, v) => a.ToValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (FromValue is not null)
			{
				writer.WritePropertyName("from");
				JsonSerializer.Serialize(writer, FromValue, options);
			}

			if (!string.IsNullOrEmpty(KeyValue))
			{
				writer.WritePropertyName("key");
				writer.WriteStringValue(KeyValue);
			}

			if (ToValue is not null)
			{
				writer.WritePropertyName("to");
				JsonSerializer.Serialize(writer, ToValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class DerivativeAggregate : Aggregations.SingleMetricAggregateBase
	{
		[JsonInclude]
		[JsonPropertyName("normalized_value")]
		public double? NormalizedValue { get; init; }

		[JsonInclude]
		[JsonPropertyName("normalized_value_as_string")]
		public string? NormalizedValueAsString { get; init; }
	}

	public partial class DerivativeAggregation : Aggregations.PipelineAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "derivative";
	}

	public sealed partial class DerivativeAggregationDescriptor : DescriptorBase<DerivativeAggregationDescriptor>
	{
		public DerivativeAggregationDescriptor()
		{
		}

		internal DerivativeAggregationDescriptor(Action<DerivativeAggregationDescriptor> configure) => configure.Invoke(this);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WriteEndObject();
		}
	}

	public partial class DiversifiedSamplerAggregation : Aggregations.BucketAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "diversified_sampler";
		[JsonInclude]
		[JsonPropertyName("execution_hint")]
		public Elastic.Clients.Elasticsearch.Aggregations.SamplerAggregationExecutionHint? ExecutionHint { get; set; }

		[JsonInclude]
		[JsonPropertyName("max_docs_per_value")]
		public int? MaxDocsPerValue { get; set; }

		[JsonInclude]
		[JsonPropertyName("script")]
		public Elastic.Clients.Elasticsearch.Script? Script { get; set; }

		[JsonInclude]
		[JsonPropertyName("shard_size")]
		public int? ShardSize { get; set; }

		[JsonInclude]
		[JsonPropertyName("field")]
		public string? Field { get; set; }
	}

	public sealed partial class DiversifiedSamplerAggregationDescriptor<T> : DescriptorBase<DiversifiedSamplerAggregationDescriptor<T>>
	{
		public DiversifiedSamplerAggregationDescriptor()
		{
		}

		internal DiversifiedSamplerAggregationDescriptor(Action<DiversifiedSamplerAggregationDescriptor<T>> configure) => configure.Invoke(this);
		internal Elastic.Clients.Elasticsearch.Aggregations.SamplerAggregationExecutionHint? ExecutionHintValue { get; private set; }

		internal int? MaxDocsPerValueValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Script? ScriptValue { get; private set; }

		internal int? ShardSizeValue { get; private set; }

		internal string? FieldValue { get; private set; }

		public DiversifiedSamplerAggregationDescriptor<T> ExecutionHint(Elastic.Clients.Elasticsearch.Aggregations.SamplerAggregationExecutionHint? executionHint) => Assign(executionHint, (a, v) => a.ExecutionHintValue = v);
		public DiversifiedSamplerAggregationDescriptor<T> MaxDocsPerValue(int? maxDocsPerValue) => Assign(maxDocsPerValue, (a, v) => a.MaxDocsPerValueValue = v);
		public DiversifiedSamplerAggregationDescriptor<T> Script(Elastic.Clients.Elasticsearch.Script? script) => Assign(script, (a, v) => a.ScriptValue = v);
		public DiversifiedSamplerAggregationDescriptor<T> ShardSize(int? shardSize) => Assign(shardSize, (a, v) => a.ShardSizeValue = v);
		public DiversifiedSamplerAggregationDescriptor<T> Field(string? field) => Assign(field, (a, v) => a.FieldValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (ExecutionHintValue is not null)
			{
				writer.WritePropertyName("execution_hint");
				JsonSerializer.Serialize(writer, ExecutionHintValue, options);
			}

			if (MaxDocsPerValueValue.HasValue)
			{
				writer.WritePropertyName("max_docs_per_value");
				writer.WriteNumberValue(MaxDocsPerValueValue.Value);
			}

			if (ScriptValue is not null)
			{
				writer.WritePropertyName("script");
				JsonSerializer.Serialize(writer, ScriptValue, options);
			}

			if (ShardSizeValue.HasValue)
			{
				writer.WritePropertyName("shard_size");
				writer.WriteNumberValue(ShardSizeValue.Value);
			}

			if (FieldValue is not null)
			{
				writer.WritePropertyName("field");
				JsonSerializer.Serialize(writer, FieldValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class DoubleTermsAggregate : Aggregations.TermsAggregateBase<Elastic.Clients.Elasticsearch.Aggregations.DoubleTermsBucket>
	{
	}

	public partial class DoubleTermsBucket : Aggregations.TermsBucketBase
	{
		[JsonInclude]
		[JsonPropertyName("key")]
		public double Key { get; init; }

		[JsonInclude]
		[JsonPropertyName("key_as_string")]
		public string? KeyAsString { get; init; }
	}

	public partial class ExtendedStatsAggregate : Aggregations.StatsAggregate
	{
		[JsonInclude]
		[JsonPropertyName("sum_of_squares")]
		public object SumOfSquares { get; init; }

		[JsonInclude]
		[JsonPropertyName("variance")]
		public object Variance { get; init; }

		[JsonInclude]
		[JsonPropertyName("variance_population")]
		public object VariancePopulation { get; init; }

		[JsonInclude]
		[JsonPropertyName("variance_sampling")]
		public object VarianceSampling { get; init; }

		[JsonInclude]
		[JsonPropertyName("std_deviation")]
		public object StdDeviation { get; init; }

		[JsonInclude]
		[JsonPropertyName("std_deviation_bounds")]
		public Elastic.Clients.Elasticsearch.Aggregations.StandardDeviationBounds? StdDeviationBounds { get; init; }

		[JsonInclude]
		[JsonPropertyName("sum_of_squares_as_string")]
		public string? SumOfSquaresAsString { get; init; }

		[JsonInclude]
		[JsonPropertyName("variance_as_string")]
		public string? VarianceAsString { get; init; }

		[JsonInclude]
		[JsonPropertyName("variance_population_as_string")]
		public string? VariancePopulationAsString { get; init; }

		[JsonInclude]
		[JsonPropertyName("variance_sampling_as_string")]
		public string? VarianceSamplingAsString { get; init; }

		[JsonInclude]
		[JsonPropertyName("std_deviation_as_string")]
		public string? StdDeviationAsString { get; init; }

		[JsonInclude]
		[JsonPropertyName("std_deviation_bounds_as_string")]
		public Elastic.Clients.Elasticsearch.Aggregations.StandardDeviationBoundsAsString? StdDeviationBoundsAsString { get; init; }
	}

	public partial class ExtendedStatsAggregation : Aggregations.FormatMetricAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "extended_stats";
		[JsonInclude]
		[JsonPropertyName("sigma")]
		public double? Sigma { get; set; }
	}

	public sealed partial class ExtendedStatsAggregationDescriptor : DescriptorBase<ExtendedStatsAggregationDescriptor>
	{
		public ExtendedStatsAggregationDescriptor()
		{
		}

		internal ExtendedStatsAggregationDescriptor(Action<ExtendedStatsAggregationDescriptor> configure) => configure.Invoke(this);
		internal double? SigmaValue { get; private set; }

		public ExtendedStatsAggregationDescriptor Sigma(double? sigma) => Assign(sigma, (a, v) => a.SigmaValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (SigmaValue.HasValue)
			{
				writer.WritePropertyName("sigma");
				writer.WriteNumberValue(SigmaValue.Value);
			}

			writer.WriteEndObject();
		}
	}

	public partial class ExtendedStatsBucketAggregate : Aggregations.ExtendedStatsAggregate
	{
	}

	public partial class ExtendedStatsBucketAggregation : Aggregations.PipelineAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "extended_stats_bucket";
		[JsonInclude]
		[JsonPropertyName("sigma")]
		public double? Sigma { get; set; }
	}

	public sealed partial class ExtendedStatsBucketAggregationDescriptor : DescriptorBase<ExtendedStatsBucketAggregationDescriptor>
	{
		public ExtendedStatsBucketAggregationDescriptor()
		{
		}

		internal ExtendedStatsBucketAggregationDescriptor(Action<ExtendedStatsBucketAggregationDescriptor> configure) => configure.Invoke(this);
		internal double? SigmaValue { get; private set; }

		public ExtendedStatsBucketAggregationDescriptor Sigma(double? sigma) => Assign(sigma, (a, v) => a.SigmaValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (SigmaValue.HasValue)
			{
				writer.WritePropertyName("sigma");
				writer.WriteNumberValue(SigmaValue.Value);
			}

			writer.WriteEndObject();
		}
	}

	public partial class FilterAggregate : Aggregations.SingleBucketAggregateBase
	{
	}

	public partial class FiltersAggregate : Aggregations.MultiBucketAggregateBase<Elastic.Clients.Elasticsearch.Aggregations.FiltersBucket>
	{
	}

	public partial class FiltersAggregation : Aggregations.BucketAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "filters";
		[JsonInclude]
		[JsonPropertyName("filters")]
		public Elastic.Clients.Elasticsearch.Aggregations.Buckets<Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer>? Filters { get; set; }

		[JsonInclude]
		[JsonPropertyName("other_bucket")]
		public bool? OtherBucket { get; set; }

		[JsonInclude]
		[JsonPropertyName("other_bucket_key")]
		public string? OtherBucketKey { get; set; }

		[JsonInclude]
		[JsonPropertyName("keyed")]
		public bool? Keyed { get; set; }
	}

	public sealed partial class FiltersAggregationDescriptor : DescriptorBase<FiltersAggregationDescriptor>
	{
		public FiltersAggregationDescriptor()
		{
		}

		internal FiltersAggregationDescriptor(Action<FiltersAggregationDescriptor> configure) => configure.Invoke(this);
		internal Elastic.Clients.Elasticsearch.Aggregations.Buckets<Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer>? FiltersValue { get; private set; }

		internal bool? OtherBucketValue { get; private set; }

		internal string? OtherBucketKeyValue { get; private set; }

		internal bool? KeyedValue { get; private set; }

		public FiltersAggregationDescriptor Filters(Elastic.Clients.Elasticsearch.Aggregations.Buckets<Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer>? filters) => Assign(filters, (a, v) => a.FiltersValue = v);
		public FiltersAggregationDescriptor OtherBucket(bool? otherBucket = true) => Assign(otherBucket, (a, v) => a.OtherBucketValue = v);
		public FiltersAggregationDescriptor OtherBucketKey(string? otherBucketKey) => Assign(otherBucketKey, (a, v) => a.OtherBucketKeyValue = v);
		public FiltersAggregationDescriptor Keyed(bool? keyed = true) => Assign(keyed, (a, v) => a.KeyedValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (FiltersValue is not null)
			{
				writer.WritePropertyName("filters");
				JsonSerializer.Serialize(writer, FiltersValue, options);
			}

			if (OtherBucketValue.HasValue)
			{
				writer.WritePropertyName("other_bucket");
				writer.WriteBooleanValue(OtherBucketValue.Value);
			}

			if (!string.IsNullOrEmpty(OtherBucketKeyValue))
			{
				writer.WritePropertyName("other_bucket_key");
				writer.WriteStringValue(OtherBucketKeyValue);
			}

			if (KeyedValue.HasValue)
			{
				writer.WritePropertyName("keyed");
				writer.WriteBooleanValue(KeyedValue.Value);
			}

			writer.WriteEndObject();
		}
	}

	public partial class FiltersBucket : Aggregations.MultiBucketBase
	{
	}

	public abstract partial class FormatMetricAggregationBase : Aggregations.MetricAggregationBase
	{
		[JsonInclude]
		[JsonPropertyName("format")]
		public string? Format { get; set; }
	}

	public sealed partial class FormatMetricAggregationBaseDescriptor : DescriptorBase<FormatMetricAggregationBaseDescriptor>
	{
		public FormatMetricAggregationBaseDescriptor()
		{
		}

		internal FormatMetricAggregationBaseDescriptor(Action<FormatMetricAggregationBaseDescriptor> configure) => configure.Invoke(this);
		internal string? FormatValue { get; private set; }

		public FormatMetricAggregationBaseDescriptor Format(string? format) => Assign(format, (a, v) => a.FormatValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (!string.IsNullOrEmpty(FormatValue))
			{
				writer.WritePropertyName("format");
				writer.WriteStringValue(FormatValue);
			}

			writer.WriteEndObject();
		}
	}

	public partial class FormattableMetricAggregation : Aggregations.MetricAggregationBase
	{
		[JsonInclude]
		[JsonPropertyName("format")]
		public string? Format { get; set; }
	}

	public sealed partial class FormattableMetricAggregationDescriptor : DescriptorBase<FormattableMetricAggregationDescriptor>
	{
		public FormattableMetricAggregationDescriptor()
		{
		}

		internal FormattableMetricAggregationDescriptor(Action<FormattableMetricAggregationDescriptor> configure) => configure.Invoke(this);
		internal string? FormatValue { get; private set; }

		public FormattableMetricAggregationDescriptor Format(string? format) => Assign(format, (a, v) => a.FormatValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (!string.IsNullOrEmpty(FormatValue))
			{
				writer.WritePropertyName("format");
				writer.WriteStringValue(FormatValue);
			}

			writer.WriteEndObject();
		}
	}

	public partial class GeoBoundsAggregate : Aggregations.AggregateBase
	{
		[JsonInclude]
		[JsonPropertyName("bounds")]
		public Elastic.Clients.Elasticsearch.GeoBounds Bounds { get; init; }
	}

	public partial class GeoBoundsAggregation : Aggregations.MetricAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "geo_bounds";
		[JsonInclude]
		[JsonPropertyName("wrap_longitude")]
		public bool? WrapLongitude { get; set; }
	}

	public sealed partial class GeoBoundsAggregationDescriptor : DescriptorBase<GeoBoundsAggregationDescriptor>
	{
		public GeoBoundsAggregationDescriptor()
		{
		}

		internal GeoBoundsAggregationDescriptor(Action<GeoBoundsAggregationDescriptor> configure) => configure.Invoke(this);
		internal bool? WrapLongitudeValue { get; private set; }

		public GeoBoundsAggregationDescriptor WrapLongitude(bool? wrapLongitude = true) => Assign(wrapLongitude, (a, v) => a.WrapLongitudeValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (WrapLongitudeValue.HasValue)
			{
				writer.WritePropertyName("wrap_longitude");
				writer.WriteBooleanValue(WrapLongitudeValue.Value);
			}

			writer.WriteEndObject();
		}
	}

	public partial class GeoCentroidAggregate : Aggregations.AggregateBase
	{
		[JsonInclude]
		[JsonPropertyName("count")]
		public long Count { get; init; }

		[JsonInclude]
		[JsonPropertyName("location")]
		public Elastic.Clients.Elasticsearch.GeoLocation? Location { get; init; }
	}

	public partial class GeoCentroidAggregation : Aggregations.MetricAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "geo_centroid";
		[JsonInclude]
		[JsonPropertyName("count")]
		public long? Count { get; set; }

		[JsonInclude]
		[JsonPropertyName("location")]
		public Elastic.Clients.Elasticsearch.GeoLocation? Location { get; set; }
	}

	public sealed partial class GeoCentroidAggregationDescriptor : DescriptorBase<GeoCentroidAggregationDescriptor>
	{
		public GeoCentroidAggregationDescriptor()
		{
		}

		internal GeoCentroidAggregationDescriptor(Action<GeoCentroidAggregationDescriptor> configure) => configure.Invoke(this);
		internal long? CountValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.GeoLocation? LocationValue { get; private set; }

		public GeoCentroidAggregationDescriptor Count(long? count) => Assign(count, (a, v) => a.CountValue = v);
		public GeoCentroidAggregationDescriptor Location(Elastic.Clients.Elasticsearch.GeoLocation? location) => Assign(location, (a, v) => a.LocationValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (CountValue.HasValue)
			{
				writer.WritePropertyName("count");
				writer.WriteNumberValue(CountValue.Value);
			}

			if (LocationValue is not null)
			{
				writer.WritePropertyName("location");
				JsonSerializer.Serialize(writer, LocationValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class GeoDistanceAggregate : Aggregations.RangeAggregate
	{
	}

	public partial class GeoDistanceAggregation : Aggregations.BucketAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "geo_distance";
		[JsonInclude]
		[JsonPropertyName("distance_type")]
		public Elastic.Clients.Elasticsearch.GeoDistanceType? DistanceType { get; set; }

		[JsonInclude]
		[JsonPropertyName("field")]
		public string? Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("origin")]
		public Elastic.Clients.Elasticsearch.GeoLocation? Origin { get; set; }

		[JsonInclude]
		[JsonPropertyName("ranges")]
		public IEnumerable<Elastic.Clients.Elasticsearch.Aggregations.AggregationRange>? Ranges { get; set; }

		[JsonInclude]
		[JsonPropertyName("unit")]
		public Elastic.Clients.Elasticsearch.DistanceUnit? Unit { get; set; }
	}

	public sealed partial class GeoDistanceAggregationDescriptor<T> : DescriptorBase<GeoDistanceAggregationDescriptor<T>>
	{
		public GeoDistanceAggregationDescriptor()
		{
		}

		internal GeoDistanceAggregationDescriptor(Action<GeoDistanceAggregationDescriptor<T>> configure) => configure.Invoke(this);
		internal Elastic.Clients.Elasticsearch.GeoDistanceType? DistanceTypeValue { get; private set; }

		internal string? FieldValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.GeoLocation? OriginValue { get; private set; }

		internal IEnumerable<Elastic.Clients.Elasticsearch.Aggregations.AggregationRange>? RangesValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.DistanceUnit? UnitValue { get; private set; }

		public GeoDistanceAggregationDescriptor<T> DistanceType(Elastic.Clients.Elasticsearch.GeoDistanceType? distanceType) => Assign(distanceType, (a, v) => a.DistanceTypeValue = v);
		public GeoDistanceAggregationDescriptor<T> Field(string? field) => Assign(field, (a, v) => a.FieldValue = v);
		public GeoDistanceAggregationDescriptor<T> Origin(Elastic.Clients.Elasticsearch.GeoLocation? origin) => Assign(origin, (a, v) => a.OriginValue = v);
		public GeoDistanceAggregationDescriptor<T> Ranges(IEnumerable<Elastic.Clients.Elasticsearch.Aggregations.AggregationRange>? ranges) => Assign(ranges, (a, v) => a.RangesValue = v);
		public GeoDistanceAggregationDescriptor<T> Unit(Elastic.Clients.Elasticsearch.DistanceUnit? unit) => Assign(unit, (a, v) => a.UnitValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (DistanceTypeValue is not null)
			{
				writer.WritePropertyName("distance_type");
				JsonSerializer.Serialize(writer, DistanceTypeValue, options);
			}

			if (FieldValue is not null)
			{
				writer.WritePropertyName("field");
				JsonSerializer.Serialize(writer, FieldValue, options);
			}

			if (OriginValue is not null)
			{
				writer.WritePropertyName("origin");
				JsonSerializer.Serialize(writer, OriginValue, options);
			}

			if (RangesValue is not null)
			{
				writer.WritePropertyName("ranges");
				JsonSerializer.Serialize(writer, RangesValue, options);
			}

			if (UnitValue is not null)
			{
				writer.WritePropertyName("unit");
				JsonSerializer.Serialize(writer, UnitValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class GeoHashGridAggregate : Aggregations.MultiBucketAggregateBase<Elastic.Clients.Elasticsearch.Aggregations.GeoHashGridBucket>
	{
	}

	public partial class GeoHashGridAggregation : Aggregations.BucketAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "geohash_grid";
		[JsonInclude]
		[JsonPropertyName("bounds")]
		public Elastic.Clients.Elasticsearch.GeoBounds? Bounds { get; set; }

		[JsonInclude]
		[JsonPropertyName("field")]
		public string? Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("precision")]
		public Elastic.Clients.Elasticsearch.GeoHashPrecision? Precision { get; set; }

		[JsonInclude]
		[JsonPropertyName("shard_size")]
		public int? ShardSize { get; set; }

		[JsonInclude]
		[JsonPropertyName("size")]
		public int? Size { get; set; }
	}

	public sealed partial class GeoHashGridAggregationDescriptor<T> : DescriptorBase<GeoHashGridAggregationDescriptor<T>>
	{
		public GeoHashGridAggregationDescriptor()
		{
		}

		internal GeoHashGridAggregationDescriptor(Action<GeoHashGridAggregationDescriptor<T>> configure) => configure.Invoke(this);
		internal Elastic.Clients.Elasticsearch.GeoBounds? BoundsValue { get; private set; }

		internal string? FieldValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.GeoHashPrecision? PrecisionValue { get; private set; }

		internal int? ShardSizeValue { get; private set; }

		internal int? SizeValue { get; private set; }

		public GeoHashGridAggregationDescriptor<T> Bounds(Elastic.Clients.Elasticsearch.GeoBounds? bounds) => Assign(bounds, (a, v) => a.BoundsValue = v);
		public GeoHashGridAggregationDescriptor<T> Field(string? field) => Assign(field, (a, v) => a.FieldValue = v);
		public GeoHashGridAggregationDescriptor<T> Precision(Elastic.Clients.Elasticsearch.GeoHashPrecision? precision) => Assign(precision, (a, v) => a.PrecisionValue = v);
		public GeoHashGridAggregationDescriptor<T> ShardSize(int? shardSize) => Assign(shardSize, (a, v) => a.ShardSizeValue = v);
		public GeoHashGridAggregationDescriptor<T> Size(int? size) => Assign(size, (a, v) => a.SizeValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (BoundsValue is not null)
			{
				writer.WritePropertyName("bounds");
				JsonSerializer.Serialize(writer, BoundsValue, options);
			}

			if (FieldValue is not null)
			{
				writer.WritePropertyName("field");
				JsonSerializer.Serialize(writer, FieldValue, options);
			}

			if (PrecisionValue is not null)
			{
				writer.WritePropertyName("precision");
				JsonSerializer.Serialize(writer, PrecisionValue, options);
			}

			if (ShardSizeValue.HasValue)
			{
				writer.WritePropertyName("shard_size");
				writer.WriteNumberValue(ShardSizeValue.Value);
			}

			if (SizeValue.HasValue)
			{
				writer.WritePropertyName("size");
				writer.WriteNumberValue(SizeValue.Value);
			}

			writer.WriteEndObject();
		}
	}

	public partial class GeoHashGridBucket : Aggregations.MultiBucketBase
	{
		[JsonInclude]
		[JsonPropertyName("key")]
		public string Key { get; init; }
	}

	public partial class GeoLineAggregate : Aggregations.AggregateBase
	{
		[JsonInclude]
		[JsonPropertyName("type")]
		public string Type { get; init; }

		[JsonInclude]
		[JsonPropertyName("geometry")]
		public Elastic.Clients.Elasticsearch.GeoLine Geometry { get; init; }
	}

	public partial class GeoLineAggregation : IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "geo_line";
		[JsonInclude]
		[JsonPropertyName("point")]
		public Elastic.Clients.Elasticsearch.Aggregations.GeoLinePoint Point { get; set; }

		[JsonInclude]
		[JsonPropertyName("sort")]
		public Elastic.Clients.Elasticsearch.Aggregations.GeoLineSort Sort { get; set; }

		[JsonInclude]
		[JsonPropertyName("include_sort")]
		public bool? IncludeSort { get; set; }

		[JsonInclude]
		[JsonPropertyName("sort_order")]
		public Elastic.Clients.Elasticsearch.SortOrder? SortOrder { get; set; }

		[JsonInclude]
		[JsonPropertyName("size")]
		public int? Size { get; set; }
	}

	public sealed partial class GeoLineAggregationDescriptor<T> : DescriptorBase<GeoLineAggregationDescriptor<T>>
	{
		public GeoLineAggregationDescriptor()
		{
		}

		internal GeoLineAggregationDescriptor(Action<GeoLineAggregationDescriptor<T>> configure) => configure.Invoke(this);
		internal Elastic.Clients.Elasticsearch.Aggregations.GeoLinePoint PointValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Aggregations.GeoLineSort SortValue { get; private set; }

		internal bool? IncludeSortValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.SortOrder? SortOrderValue { get; private set; }

		internal int? SizeValue { get; private set; }

		internal GeoLinePointDescriptor<T> PointDescriptor { get; private set; }

		internal GeoLineSortDescriptor<T> SortDescriptor { get; private set; }

		internal Action<GeoLinePointDescriptor<T>> PointDescriptorAction { get; private set; }

		internal Action<GeoLineSortDescriptor<T>> SortDescriptorAction { get; private set; }

		public GeoLineAggregationDescriptor<T> Point(Elastic.Clients.Elasticsearch.Aggregations.GeoLinePoint point)
		{
			PointDescriptor = null;
			PointDescriptorAction = null;
			return Assign(point, (a, v) => a.PointValue = v);
		}

		public GeoLineAggregationDescriptor<T> Point(Elastic.Clients.Elasticsearch.Aggregations.GeoLinePointDescriptor<T> descriptor)
		{
			PointValue = null;
			PointDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.PointDescriptor = v);
		}

		public GeoLineAggregationDescriptor<T> Point(Action<Elastic.Clients.Elasticsearch.Aggregations.GeoLinePointDescriptor<T>> configure)
		{
			PointValue = null;
			PointDescriptorAction = null;
			return Assign(configure, (a, v) => a.PointDescriptorAction = v);
		}

		public GeoLineAggregationDescriptor<T> Sort(Elastic.Clients.Elasticsearch.Aggregations.GeoLineSort sort)
		{
			SortDescriptor = null;
			SortDescriptorAction = null;
			return Assign(sort, (a, v) => a.SortValue = v);
		}

		public GeoLineAggregationDescriptor<T> Sort(Elastic.Clients.Elasticsearch.Aggregations.GeoLineSortDescriptor<T> descriptor)
		{
			SortValue = null;
			SortDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.SortDescriptor = v);
		}

		public GeoLineAggregationDescriptor<T> Sort(Action<Elastic.Clients.Elasticsearch.Aggregations.GeoLineSortDescriptor<T>> configure)
		{
			SortValue = null;
			SortDescriptorAction = null;
			return Assign(configure, (a, v) => a.SortDescriptorAction = v);
		}

		public GeoLineAggregationDescriptor<T> IncludeSort(bool? includeSort = true) => Assign(includeSort, (a, v) => a.IncludeSortValue = v);
		public GeoLineAggregationDescriptor<T> SortOrder(Elastic.Clients.Elasticsearch.SortOrder? sortOrder) => Assign(sortOrder, (a, v) => a.SortOrderValue = v);
		public GeoLineAggregationDescriptor<T> Size(int? size) => Assign(size, (a, v) => a.SizeValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (PointDescriptor is not null)
			{
				writer.WritePropertyName("point");
				JsonSerializer.Serialize(writer, PointDescriptor, options);
			}
			else if (PointDescriptorAction is not null)
			{
				writer.WritePropertyName("point");
				JsonSerializer.Serialize(writer, new GeoLinePointDescriptor<T>(PointDescriptorAction), options);
			}
			else
			{
				writer.WritePropertyName("point");
				JsonSerializer.Serialize(writer, PointValue, options);
			}

			if (SortDescriptor is not null)
			{
				writer.WritePropertyName("sort");
				JsonSerializer.Serialize(writer, SortDescriptor, options);
			}
			else if (SortDescriptorAction is not null)
			{
				writer.WritePropertyName("sort");
				JsonSerializer.Serialize(writer, new GeoLineSortDescriptor<T>(SortDescriptorAction), options);
			}
			else
			{
				writer.WritePropertyName("sort");
				JsonSerializer.Serialize(writer, SortValue, options);
			}

			if (IncludeSortValue.HasValue)
			{
				writer.WritePropertyName("include_sort");
				writer.WriteBooleanValue(IncludeSortValue.Value);
			}

			if (SortOrderValue is not null)
			{
				writer.WritePropertyName("sort_order");
				JsonSerializer.Serialize(writer, SortOrderValue, options);
			}

			if (SizeValue.HasValue)
			{
				writer.WritePropertyName("size");
				writer.WriteNumberValue(SizeValue.Value);
			}

			writer.WriteEndObject();
		}
	}

	public partial class GeoLinePoint
	{
		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }
	}

	public sealed partial class GeoLinePointDescriptor<T> : DescriptorBase<GeoLinePointDescriptor<T>>
	{
		public GeoLinePointDescriptor()
		{
		}

		internal GeoLinePointDescriptor(Action<GeoLinePointDescriptor<T>> configure) => configure.Invoke(this);
		internal string FieldValue { get; private set; }

		public GeoLinePointDescriptor<T> Field(string field) => Assign(field, (a, v) => a.FieldValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, FieldValue, options);
			writer.WriteEndObject();
		}
	}

	public partial class GeoLineSort
	{
		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }
	}

	public sealed partial class GeoLineSortDescriptor<T> : DescriptorBase<GeoLineSortDescriptor<T>>
	{
		public GeoLineSortDescriptor()
		{
		}

		internal GeoLineSortDescriptor(Action<GeoLineSortDescriptor<T>> configure) => configure.Invoke(this);
		internal string FieldValue { get; private set; }

		public GeoLineSortDescriptor<T> Field(string field) => Assign(field, (a, v) => a.FieldValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, FieldValue, options);
			writer.WriteEndObject();
		}
	}

	public partial class GeoTileGridAggregate : Aggregations.MultiBucketAggregateBase<Elastic.Clients.Elasticsearch.Aggregations.GeoTileGridBucket>
	{
	}

	public partial class GeoTileGridAggregation : Aggregations.BucketAggregationBase, IAggregationContainerVariant, TransformManagement.IPivotGroupByContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "geotile_grid";
		[JsonIgnore]
		string TransformManagement.IPivotGroupByContainerVariant.PivotGroupByContainerVariantName => "geotile_grid";
		[JsonInclude]
		[JsonPropertyName("field")]
		public string? Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("precision")]
		public double? Precision { get; set; }

		[JsonInclude]
		[JsonPropertyName("shard_size")]
		public int? ShardSize { get; set; }

		[JsonInclude]
		[JsonPropertyName("size")]
		public int? Size { get; set; }

		[JsonInclude]
		[JsonPropertyName("bounds")]
		public Elastic.Clients.Elasticsearch.GeoBounds? Bounds { get; set; }
	}

	public sealed partial class GeoTileGridAggregationDescriptor<T> : DescriptorBase<GeoTileGridAggregationDescriptor<T>>
	{
		public GeoTileGridAggregationDescriptor()
		{
		}

		internal GeoTileGridAggregationDescriptor(Action<GeoTileGridAggregationDescriptor<T>> configure) => configure.Invoke(this);
		internal string? FieldValue { get; private set; }

		internal double? PrecisionValue { get; private set; }

		internal int? ShardSizeValue { get; private set; }

		internal int? SizeValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.GeoBounds? BoundsValue { get; private set; }

		public GeoTileGridAggregationDescriptor<T> Field(string? field) => Assign(field, (a, v) => a.FieldValue = v);
		public GeoTileGridAggregationDescriptor<T> Precision(double? precision) => Assign(precision, (a, v) => a.PrecisionValue = v);
		public GeoTileGridAggregationDescriptor<T> ShardSize(int? shardSize) => Assign(shardSize, (a, v) => a.ShardSizeValue = v);
		public GeoTileGridAggregationDescriptor<T> Size(int? size) => Assign(size, (a, v) => a.SizeValue = v);
		public GeoTileGridAggregationDescriptor<T> Bounds(Elastic.Clients.Elasticsearch.GeoBounds? bounds) => Assign(bounds, (a, v) => a.BoundsValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (FieldValue is not null)
			{
				writer.WritePropertyName("field");
				JsonSerializer.Serialize(writer, FieldValue, options);
			}

			if (PrecisionValue is not null)
			{
				writer.WritePropertyName("precision");
				JsonSerializer.Serialize(writer, PrecisionValue, options);
			}

			if (ShardSizeValue.HasValue)
			{
				writer.WritePropertyName("shard_size");
				writer.WriteNumberValue(ShardSizeValue.Value);
			}

			if (SizeValue.HasValue)
			{
				writer.WritePropertyName("size");
				writer.WriteNumberValue(SizeValue.Value);
			}

			if (BoundsValue is not null)
			{
				writer.WritePropertyName("bounds");
				JsonSerializer.Serialize(writer, BoundsValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class GeoTileGridBucket : Aggregations.MultiBucketBase
	{
		[JsonInclude]
		[JsonPropertyName("key")]
		public string Key { get; init; }
	}

	public partial class GlobalAggregate : Aggregations.SingleBucketAggregateBase
	{
	}

	public partial class GlobalAggregation : Aggregations.BucketAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "global";
	}

	public sealed partial class GlobalAggregationDescriptor : DescriptorBase<GlobalAggregationDescriptor>
	{
		public GlobalAggregationDescriptor()
		{
		}

		internal GlobalAggregationDescriptor(Action<GlobalAggregationDescriptor> configure) => configure.Invoke(this);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WriteEndObject();
		}
	}

	public partial class GoogleNormalizedDistanceHeuristic
	{
		[JsonInclude]
		[JsonPropertyName("background_is_superset")]
		public bool? BackgroundIsSuperset { get; set; }
	}

	public sealed partial class GoogleNormalizedDistanceHeuristicDescriptor : DescriptorBase<GoogleNormalizedDistanceHeuristicDescriptor>
	{
		public GoogleNormalizedDistanceHeuristicDescriptor()
		{
		}

		internal GoogleNormalizedDistanceHeuristicDescriptor(Action<GoogleNormalizedDistanceHeuristicDescriptor> configure) => configure.Invoke(this);
		internal bool? BackgroundIsSupersetValue { get; private set; }

		public GoogleNormalizedDistanceHeuristicDescriptor BackgroundIsSuperset(bool? backgroundIsSuperset = true) => Assign(backgroundIsSuperset, (a, v) => a.BackgroundIsSupersetValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (BackgroundIsSupersetValue.HasValue)
			{
				writer.WritePropertyName("background_is_superset");
				writer.WriteBooleanValue(BackgroundIsSupersetValue.Value);
			}

			writer.WriteEndObject();
		}
	}

	public partial class HdrMethod
	{
		[JsonInclude]
		[JsonPropertyName("number_of_significant_value_digits")]
		public int? NumberOfSignificantValueDigits { get; set; }
	}

	public sealed partial class HdrMethodDescriptor : DescriptorBase<HdrMethodDescriptor>
	{
		public HdrMethodDescriptor()
		{
		}

		internal HdrMethodDescriptor(Action<HdrMethodDescriptor> configure) => configure.Invoke(this);
		internal int? NumberOfSignificantValueDigitsValue { get; private set; }

		public HdrMethodDescriptor NumberOfSignificantValueDigits(int? numberOfSignificantValueDigits) => Assign(numberOfSignificantValueDigits, (a, v) => a.NumberOfSignificantValueDigitsValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (NumberOfSignificantValueDigitsValue.HasValue)
			{
				writer.WritePropertyName("number_of_significant_value_digits");
				writer.WriteNumberValue(NumberOfSignificantValueDigitsValue.Value);
			}

			writer.WriteEndObject();
		}
	}

	public partial class HdrPercentileRanksAggregate : Aggregations.PercentilesAggregateBase
	{
	}

	public partial class HdrPercentilesAggregate : Aggregations.PercentilesAggregateBase
	{
	}

	public partial class HistogramAggregate : Aggregations.MultiBucketAggregateBase<Elastic.Clients.Elasticsearch.Aggregations.HistogramBucket>
	{
	}

	public partial class HistogramAggregation : Aggregations.BucketAggregationBase, IAggregationContainerVariant, TransformManagement.IPivotGroupByContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "histogram";
		[JsonIgnore]
		string TransformManagement.IPivotGroupByContainerVariant.PivotGroupByContainerVariantName => "histogram";
		[JsonInclude]
		[JsonPropertyName("field")]
		public string? Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("interval")]
		public double? Interval { get; set; }

		[JsonInclude]
		[JsonPropertyName("min_doc_count")]
		public int? MinDocCount { get; set; }

		[JsonInclude]
		[JsonPropertyName("missing")]
		public double? Missing { get; set; }

		[JsonInclude]
		[JsonPropertyName("offset")]
		public double? Offset { get; set; }

		[JsonInclude]
		[JsonPropertyName("order")]
		public Elastic.Clients.Elasticsearch.Aggregations.HistogramOrder? Order { get; set; }

		[JsonInclude]
		[JsonPropertyName("script")]
		public Elastic.Clients.Elasticsearch.Script? Script { get; set; }

		[JsonInclude]
		[JsonPropertyName("format")]
		public string? Format { get; set; }

		[JsonInclude]
		[JsonPropertyName("keyed")]
		public bool? Keyed { get; set; }
	}

	public sealed partial class HistogramAggregationDescriptor<T> : DescriptorBase<HistogramAggregationDescriptor<T>>
	{
		public HistogramAggregationDescriptor()
		{
		}

		internal HistogramAggregationDescriptor(Action<HistogramAggregationDescriptor<T>> configure) => configure.Invoke(this);
		internal string? FieldValue { get; private set; }

		internal double? IntervalValue { get; private set; }

		internal int? MinDocCountValue { get; private set; }

		internal double? MissingValue { get; private set; }

		internal double? OffsetValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Aggregations.HistogramOrder? OrderValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Script? ScriptValue { get; private set; }

		internal string? FormatValue { get; private set; }

		internal bool? KeyedValue { get; private set; }

		internal HistogramOrderDescriptor OrderDescriptor { get; private set; }

		internal Action<HistogramOrderDescriptor> OrderDescriptorAction { get; private set; }

		public HistogramAggregationDescriptor<T> Field(string? field) => Assign(field, (a, v) => a.FieldValue = v);
		public HistogramAggregationDescriptor<T> Interval(double? interval) => Assign(interval, (a, v) => a.IntervalValue = v);
		public HistogramAggregationDescriptor<T> MinDocCount(int? minDocCount) => Assign(minDocCount, (a, v) => a.MinDocCountValue = v);
		public HistogramAggregationDescriptor<T> Missing(double? missing) => Assign(missing, (a, v) => a.MissingValue = v);
		public HistogramAggregationDescriptor<T> Offset(double? offset) => Assign(offset, (a, v) => a.OffsetValue = v);
		public HistogramAggregationDescriptor<T> Order(Elastic.Clients.Elasticsearch.Aggregations.HistogramOrder? order)
		{
			OrderDescriptor = null;
			OrderDescriptorAction = null;
			return Assign(order, (a, v) => a.OrderValue = v);
		}

		public HistogramAggregationDescriptor<T> Order(Elastic.Clients.Elasticsearch.Aggregations.HistogramOrderDescriptor descriptor)
		{
			OrderValue = null;
			OrderDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.OrderDescriptor = v);
		}

		public HistogramAggregationDescriptor<T> Order(Action<Elastic.Clients.Elasticsearch.Aggregations.HistogramOrderDescriptor> configure)
		{
			OrderValue = null;
			OrderDescriptorAction = null;
			return Assign(configure, (a, v) => a.OrderDescriptorAction = v);
		}

		public HistogramAggregationDescriptor<T> Script(Elastic.Clients.Elasticsearch.Script? script) => Assign(script, (a, v) => a.ScriptValue = v);
		public HistogramAggregationDescriptor<T> Format(string? format) => Assign(format, (a, v) => a.FormatValue = v);
		public HistogramAggregationDescriptor<T> Keyed(bool? keyed = true) => Assign(keyed, (a, v) => a.KeyedValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (FieldValue is not null)
			{
				writer.WritePropertyName("field");
				JsonSerializer.Serialize(writer, FieldValue, options);
			}

			if (IntervalValue.HasValue)
			{
				writer.WritePropertyName("interval");
				writer.WriteNumberValue(IntervalValue.Value);
			}

			if (MinDocCountValue.HasValue)
			{
				writer.WritePropertyName("min_doc_count");
				writer.WriteNumberValue(MinDocCountValue.Value);
			}

			if (MissingValue.HasValue)
			{
				writer.WritePropertyName("missing");
				writer.WriteNumberValue(MissingValue.Value);
			}

			if (OffsetValue.HasValue)
			{
				writer.WritePropertyName("offset");
				writer.WriteNumberValue(OffsetValue.Value);
			}

			if (OrderDescriptor is not null)
			{
				writer.WritePropertyName("order");
				JsonSerializer.Serialize(writer, OrderDescriptor, options);
			}
			else if (OrderDescriptorAction is not null)
			{
				writer.WritePropertyName("order");
				JsonSerializer.Serialize(writer, new HistogramOrderDescriptor(OrderDescriptorAction), options);
			}
			else if (OrderValue is not null)
			{
				writer.WritePropertyName("order");
				JsonSerializer.Serialize(writer, OrderValue, options);
			}

			if (ScriptValue is not null)
			{
				writer.WritePropertyName("script");
				JsonSerializer.Serialize(writer, ScriptValue, options);
			}

			if (!string.IsNullOrEmpty(FormatValue))
			{
				writer.WritePropertyName("format");
				writer.WriteStringValue(FormatValue);
			}

			if (KeyedValue.HasValue)
			{
				writer.WritePropertyName("keyed");
				writer.WriteBooleanValue(KeyedValue.Value);
			}

			writer.WriteEndObject();
		}
	}

	public partial class HistogramBucket : Aggregations.MultiBucketBase
	{
		[JsonInclude]
		[JsonPropertyName("key_as_string")]
		public string? KeyAsString { get; init; }

		[JsonInclude]
		[JsonPropertyName("key")]
		public double Key { get; init; }
	}

	public partial class HistogramOrder
	{
		[JsonInclude]
		[JsonPropertyName("_count")]
		public Elastic.Clients.Elasticsearch.SortOrder? Count { get; set; }

		[JsonInclude]
		[JsonPropertyName("_key")]
		public Elastic.Clients.Elasticsearch.SortOrder? Key { get; set; }
	}

	public sealed partial class HistogramOrderDescriptor : DescriptorBase<HistogramOrderDescriptor>
	{
		public HistogramOrderDescriptor()
		{
		}

		internal HistogramOrderDescriptor(Action<HistogramOrderDescriptor> configure) => configure.Invoke(this);
		internal Elastic.Clients.Elasticsearch.SortOrder? CountValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.SortOrder? KeyValue { get; private set; }

		public HistogramOrderDescriptor Count(Elastic.Clients.Elasticsearch.SortOrder? count) => Assign(count, (a, v) => a.CountValue = v);
		public HistogramOrderDescriptor Key(Elastic.Clients.Elasticsearch.SortOrder? key) => Assign(key, (a, v) => a.KeyValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (CountValue is not null)
			{
				writer.WritePropertyName("_count");
				JsonSerializer.Serialize(writer, CountValue, options);
			}

			if (KeyValue is not null)
			{
				writer.WritePropertyName("_key");
				JsonSerializer.Serialize(writer, KeyValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class InferenceAggregate : Aggregations.AggregateBase
	{
		[JsonInclude]
		[JsonPropertyName("value")]
		public object? Value { get; init; }

		[JsonInclude]
		[JsonPropertyName("feature_importance")]
		public IReadOnlyCollection<Elastic.Clients.Elasticsearch.Aggregations.InferenceFeatureImportance>? FeatureImportance { get; init; }

		[JsonInclude]
		[JsonPropertyName("top_classes")]
		public IReadOnlyCollection<Elastic.Clients.Elasticsearch.Aggregations.InferenceTopClassEntry>? TopClasses { get; init; }

		[JsonInclude]
		[JsonPropertyName("warning")]
		public string? Warning { get; init; }
	}

	public partial class InferenceAggregation : Aggregations.PipelineAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "inference";
		[JsonInclude]
		[JsonPropertyName("model_id")]
		public Elastic.Clients.Elasticsearch.Name ModelId { get; set; }

		[JsonInclude]
		[JsonPropertyName("inference_config")]
		public Elastic.Clients.Elasticsearch.Aggregations.InferenceConfigContainer? InferenceConfig { get; set; }
	}

	public sealed partial class InferenceAggregationDescriptor<T> : DescriptorBase<InferenceAggregationDescriptor<T>>
	{
		public InferenceAggregationDescriptor()
		{
		}

		internal InferenceAggregationDescriptor(Action<InferenceAggregationDescriptor<T>> configure) => configure.Invoke(this);
		internal Elastic.Clients.Elasticsearch.Name ModelIdValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Aggregations.InferenceConfigContainer? InferenceConfigValue { get; private set; }

		internal InferenceConfigContainerDescriptor<T> InferenceConfigDescriptor { get; private set; }

		internal Action<InferenceConfigContainerDescriptor<T>> InferenceConfigDescriptorAction { get; private set; }

		public InferenceAggregationDescriptor<T> ModelId(Elastic.Clients.Elasticsearch.Name modelId) => Assign(modelId, (a, v) => a.ModelIdValue = v);
		public InferenceAggregationDescriptor<T> InferenceConfig(Elastic.Clients.Elasticsearch.Aggregations.InferenceConfigContainer? inferenceConfig)
		{
			InferenceConfigDescriptor = null;
			InferenceConfigDescriptorAction = null;
			return Assign(inferenceConfig, (a, v) => a.InferenceConfigValue = v);
		}

		public InferenceAggregationDescriptor<T> InferenceConfig(Elastic.Clients.Elasticsearch.Aggregations.InferenceConfigContainerDescriptor<T> descriptor)
		{
			InferenceConfigValue = null;
			InferenceConfigDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.InferenceConfigDescriptor = v);
		}

		public InferenceAggregationDescriptor<T> InferenceConfig(Action<Elastic.Clients.Elasticsearch.Aggregations.InferenceConfigContainerDescriptor<T>> configure)
		{
			InferenceConfigValue = null;
			InferenceConfigDescriptorAction = null;
			return Assign(configure, (a, v) => a.InferenceConfigDescriptorAction = v);
		}

		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("model_id");
			JsonSerializer.Serialize(writer, ModelIdValue, options);
			if (InferenceConfigDescriptor is not null)
			{
				writer.WritePropertyName("inference_config");
				JsonSerializer.Serialize(writer, InferenceConfigDescriptor, options);
			}
			else if (InferenceConfigDescriptorAction is not null)
			{
				writer.WritePropertyName("inference_config");
				JsonSerializer.Serialize(writer, new InferenceConfigContainerDescriptor<T>(InferenceConfigDescriptorAction), options);
			}
			else if (InferenceConfigValue is not null)
			{
				writer.WritePropertyName("inference_config");
				JsonSerializer.Serialize(writer, InferenceConfigValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class InferenceClassImportance
	{
		[JsonInclude]
		[JsonPropertyName("class_name")]
		public string ClassName { get; init; }

		[JsonInclude]
		[JsonPropertyName("importance")]
		public double Importance { get; init; }
	}

	public partial class InferenceConfigContainer
	{
		[JsonInclude]
		[JsonPropertyName("regression")]
		public Elastic.Clients.Elasticsearch.Aggregations.RegressionInferenceOptions? Regression { get; set; }

		[JsonInclude]
		[JsonPropertyName("classification")]
		public Elastic.Clients.Elasticsearch.Aggregations.ClassificationInferenceOptions? Classification { get; set; }
	}

	public sealed partial class InferenceConfigContainerDescriptor<T> : DescriptorBase<InferenceConfigContainerDescriptor<T>>
	{
		public InferenceConfigContainerDescriptor()
		{
		}

		internal InferenceConfigContainerDescriptor(Action<InferenceConfigContainerDescriptor<T>> configure) => configure.Invoke(this);
		internal Elastic.Clients.Elasticsearch.Aggregations.RegressionInferenceOptions? RegressionValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Aggregations.ClassificationInferenceOptions? ClassificationValue { get; private set; }

		internal RegressionInferenceOptionsDescriptor<T> RegressionDescriptor { get; private set; }

		internal ClassificationInferenceOptionsDescriptor ClassificationDescriptor { get; private set; }

		internal Action<RegressionInferenceOptionsDescriptor<T>> RegressionDescriptorAction { get; private set; }

		internal Action<ClassificationInferenceOptionsDescriptor> ClassificationDescriptorAction { get; private set; }

		public InferenceConfigContainerDescriptor<T> Regression(Elastic.Clients.Elasticsearch.Aggregations.RegressionInferenceOptions? regression)
		{
			RegressionDescriptor = null;
			RegressionDescriptorAction = null;
			return Assign(regression, (a, v) => a.RegressionValue = v);
		}

		public InferenceConfigContainerDescriptor<T> Regression(Elastic.Clients.Elasticsearch.Aggregations.RegressionInferenceOptionsDescriptor<T> descriptor)
		{
			RegressionValue = null;
			RegressionDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.RegressionDescriptor = v);
		}

		public InferenceConfigContainerDescriptor<T> Regression(Action<Elastic.Clients.Elasticsearch.Aggregations.RegressionInferenceOptionsDescriptor<T>> configure)
		{
			RegressionValue = null;
			RegressionDescriptorAction = null;
			return Assign(configure, (a, v) => a.RegressionDescriptorAction = v);
		}

		public InferenceConfigContainerDescriptor<T> Classification(Elastic.Clients.Elasticsearch.Aggregations.ClassificationInferenceOptions? classification)
		{
			ClassificationDescriptor = null;
			ClassificationDescriptorAction = null;
			return Assign(classification, (a, v) => a.ClassificationValue = v);
		}

		public InferenceConfigContainerDescriptor<T> Classification(Elastic.Clients.Elasticsearch.Aggregations.ClassificationInferenceOptionsDescriptor descriptor)
		{
			ClassificationValue = null;
			ClassificationDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.ClassificationDescriptor = v);
		}

		public InferenceConfigContainerDescriptor<T> Classification(Action<Elastic.Clients.Elasticsearch.Aggregations.ClassificationInferenceOptionsDescriptor> configure)
		{
			ClassificationValue = null;
			ClassificationDescriptorAction = null;
			return Assign(configure, (a, v) => a.ClassificationDescriptorAction = v);
		}

		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (RegressionDescriptor is not null)
			{
				writer.WritePropertyName("regression");
				JsonSerializer.Serialize(writer, RegressionDescriptor, options);
			}
			else if (RegressionDescriptorAction is not null)
			{
				writer.WritePropertyName("regression");
				JsonSerializer.Serialize(writer, new RegressionInferenceOptionsDescriptor<T>(RegressionDescriptorAction), options);
			}
			else if (RegressionValue is not null)
			{
				writer.WritePropertyName("regression");
				JsonSerializer.Serialize(writer, RegressionValue, options);
			}

			if (ClassificationDescriptor is not null)
			{
				writer.WritePropertyName("classification");
				JsonSerializer.Serialize(writer, ClassificationDescriptor, options);
			}
			else if (ClassificationDescriptorAction is not null)
			{
				writer.WritePropertyName("classification");
				JsonSerializer.Serialize(writer, new ClassificationInferenceOptionsDescriptor(ClassificationDescriptorAction), options);
			}
			else if (ClassificationValue is not null)
			{
				writer.WritePropertyName("classification");
				JsonSerializer.Serialize(writer, ClassificationValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class InferenceFeatureImportance
	{
		[JsonInclude]
		[JsonPropertyName("feature_name")]
		public string FeatureName { get; init; }

		[JsonInclude]
		[JsonPropertyName("importance")]
		public double? Importance { get; init; }

		[JsonInclude]
		[JsonPropertyName("classes")]
		public IReadOnlyCollection<Elastic.Clients.Elasticsearch.Aggregations.InferenceClassImportance>? Classes { get; init; }
	}

	public partial class InferenceTopClassEntry
	{
		[JsonInclude]
		[JsonPropertyName("class_name")]
		public object ClassName { get; init; }

		[JsonInclude]
		[JsonPropertyName("class_probability")]
		public double ClassProbability { get; init; }

		[JsonInclude]
		[JsonPropertyName("class_score")]
		public double ClassScore { get; init; }
	}

	public partial class IpRangeAggregate : Aggregations.MultiBucketAggregateBase<Elastic.Clients.Elasticsearch.Aggregations.IpRangeBucket>
	{
	}

	public partial class IpRangeAggregation : Aggregations.BucketAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "ip_range";
		[JsonInclude]
		[JsonPropertyName("field")]
		public string? Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("ranges")]
		public IEnumerable<Elastic.Clients.Elasticsearch.Aggregations.IpRangeAggregationRange>? Ranges { get; set; }
	}

	public sealed partial class IpRangeAggregationDescriptor<T> : DescriptorBase<IpRangeAggregationDescriptor<T>>
	{
		public IpRangeAggregationDescriptor()
		{
		}

		internal IpRangeAggregationDescriptor(Action<IpRangeAggregationDescriptor<T>> configure) => configure.Invoke(this);
		internal string? FieldValue { get; private set; }

		internal IEnumerable<Elastic.Clients.Elasticsearch.Aggregations.IpRangeAggregationRange>? RangesValue { get; private set; }

		public IpRangeAggregationDescriptor<T> Field(string? field) => Assign(field, (a, v) => a.FieldValue = v);
		public IpRangeAggregationDescriptor<T> Ranges(IEnumerable<Elastic.Clients.Elasticsearch.Aggregations.IpRangeAggregationRange>? ranges) => Assign(ranges, (a, v) => a.RangesValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (FieldValue is not null)
			{
				writer.WritePropertyName("field");
				JsonSerializer.Serialize(writer, FieldValue, options);
			}

			if (RangesValue is not null)
			{
				writer.WritePropertyName("ranges");
				JsonSerializer.Serialize(writer, RangesValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class IpRangeAggregationRange
	{
		[JsonInclude]
		[JsonPropertyName("from")]
		public string? From { get; set; }

		[JsonInclude]
		[JsonPropertyName("mask")]
		public string? Mask { get; set; }

		[JsonInclude]
		[JsonPropertyName("to")]
		public string? To { get; set; }
	}

	public sealed partial class IpRangeAggregationRangeDescriptor : DescriptorBase<IpRangeAggregationRangeDescriptor>
	{
		public IpRangeAggregationRangeDescriptor()
		{
		}

		internal IpRangeAggregationRangeDescriptor(Action<IpRangeAggregationRangeDescriptor> configure) => configure.Invoke(this);
		internal string? FromValue { get; private set; }

		internal string? MaskValue { get; private set; }

		internal string? ToValue { get; private set; }

		public IpRangeAggregationRangeDescriptor From(string? from) => Assign(from, (a, v) => a.FromValue = v);
		public IpRangeAggregationRangeDescriptor Mask(string? mask) => Assign(mask, (a, v) => a.MaskValue = v);
		public IpRangeAggregationRangeDescriptor To(string? to) => Assign(to, (a, v) => a.ToValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (!string.IsNullOrEmpty(FromValue))
			{
				writer.WritePropertyName("from");
				writer.WriteStringValue(FromValue);
			}

			if (!string.IsNullOrEmpty(MaskValue))
			{
				writer.WritePropertyName("mask");
				writer.WriteStringValue(MaskValue);
			}

			if (!string.IsNullOrEmpty(ToValue))
			{
				writer.WritePropertyName("to");
				writer.WriteStringValue(ToValue);
			}

			writer.WriteEndObject();
		}
	}

	public partial class IpRangeBucket : Aggregations.MultiBucketBase
	{
		[JsonInclude]
		[JsonPropertyName("from")]
		public string? From { get; init; }

		[JsonInclude]
		[JsonPropertyName("to")]
		public string? To { get; init; }
	}

	public partial class LongRareTermsAggregate : Aggregations.MultiBucketAggregateBase<Elastic.Clients.Elasticsearch.Aggregations.LongRareTermsBucket>
	{
	}

	public partial class LongRareTermsBucket : Aggregations.MultiBucketBase
	{
		[JsonInclude]
		[JsonPropertyName("key")]
		public long Key { get; init; }

		[JsonInclude]
		[JsonPropertyName("key_as_string")]
		public string? KeyAsString { get; init; }
	}

	public partial class LongTermsAggregate : Aggregations.TermsAggregateBase<Elastic.Clients.Elasticsearch.Aggregations.LongTermsBucket>
	{
	}

	public partial class LongTermsBucket : Aggregations.TermsBucketBase
	{
		[JsonInclude]
		[JsonPropertyName("key")]
		public string Key { get; init; }

		[JsonInclude]
		[JsonPropertyName("key_as_string")]
		public string? KeyAsString { get; init; }
	}

	public partial class MatrixAggregation : Aggregations.AggregationBase
	{
		[JsonInclude]
		[JsonPropertyName("fields")]
		public Elastic.Clients.Elasticsearch.Fields? Fields { get; set; }

		[JsonInclude]
		[JsonPropertyName("missing")]
		public Dictionary<string, double>? Missing { get; set; }
	}

	public sealed partial class MatrixAggregationDescriptor<T> : DescriptorBase<MatrixAggregationDescriptor<T>>
	{
		public MatrixAggregationDescriptor()
		{
		}

		internal MatrixAggregationDescriptor(Action<MatrixAggregationDescriptor<T>> configure) => configure.Invoke(this);
		internal Elastic.Clients.Elasticsearch.Fields? FieldsValue { get; private set; }

		internal Dictionary<string, double>? MissingValue { get; private set; }

		public MatrixAggregationDescriptor<T> Fields(Elastic.Clients.Elasticsearch.Fields? fields) => Assign(fields, (a, v) => a.FieldsValue = v);
		public MatrixAggregationDescriptor<T> Missing(Func<FluentDictionary<string, double>, FluentDictionary<string, double>> selector) => Assign(selector, (a, v) => a.MissingValue = v?.Invoke(new FluentDictionary<string, double>()));
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (FieldsValue is not null)
			{
				writer.WritePropertyName("fields");
				JsonSerializer.Serialize(writer, FieldsValue, options);
			}

			if (MissingValue is not null)
			{
				writer.WritePropertyName("missing");
				JsonSerializer.Serialize(writer, MissingValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class MatrixStatsAggregate : Aggregations.AggregateBase
	{
		[JsonInclude]
		[JsonPropertyName("doc_count")]
		public long DocCount { get; init; }

		[JsonInclude]
		[JsonPropertyName("fields")]
		public IReadOnlyCollection<Elastic.Clients.Elasticsearch.Aggregations.MatrixStatsFields> Fields { get; init; }
	}

	public partial class MatrixStatsAggregation : Aggregations.MatrixAggregation, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "matrix_stats";
		[JsonInclude]
		[JsonPropertyName("mode")]
		public Elastic.Clients.Elasticsearch.Aggregations.MatrixStatsMode? Mode { get; set; }
	}

	public sealed partial class MatrixStatsAggregationDescriptor : DescriptorBase<MatrixStatsAggregationDescriptor>
	{
		public MatrixStatsAggregationDescriptor()
		{
		}

		internal MatrixStatsAggregationDescriptor(Action<MatrixStatsAggregationDescriptor> configure) => configure.Invoke(this);
		internal Elastic.Clients.Elasticsearch.Aggregations.MatrixStatsMode? ModeValue { get; private set; }

		public MatrixStatsAggregationDescriptor Mode(Elastic.Clients.Elasticsearch.Aggregations.MatrixStatsMode? mode) => Assign(mode, (a, v) => a.ModeValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (ModeValue is not null)
			{
				writer.WritePropertyName("mode");
				JsonSerializer.Serialize(writer, ModeValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class MatrixStatsFields
	{
		[JsonInclude]
		[JsonPropertyName("name")]
		public string Name { get; init; }

		[JsonInclude]
		[JsonPropertyName("count")]
		public long Count { get; init; }

		[JsonInclude]
		[JsonPropertyName("mean")]
		public double Mean { get; init; }

		[JsonInclude]
		[JsonPropertyName("variance")]
		public double Variance { get; init; }

		[JsonInclude]
		[JsonPropertyName("skewness")]
		public double Skewness { get; init; }

		[JsonInclude]
		[JsonPropertyName("kurtosis")]
		public double Kurtosis { get; init; }

		[JsonInclude]
		[JsonPropertyName("covariance")]
		public Dictionary<string, double> Covariance { get; init; }

		[JsonInclude]
		[JsonPropertyName("correlation")]
		public Dictionary<string, double> Correlation { get; init; }
	}

	public partial class MaxAggregate : Aggregations.SingleMetricAggregateBase
	{
	}

	public partial class MaxAggregation : Aggregations.FormatMetricAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "max";
	}

	public sealed partial class MaxAggregationDescriptor : DescriptorBase<MaxAggregationDescriptor>
	{
		public MaxAggregationDescriptor()
		{
		}

		internal MaxAggregationDescriptor(Action<MaxAggregationDescriptor> configure) => configure.Invoke(this);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WriteEndObject();
		}
	}

	public partial class MaxBucketAggregation : Aggregations.PipelineAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "max_bucket";
	}

	public sealed partial class MaxBucketAggregationDescriptor : DescriptorBase<MaxBucketAggregationDescriptor>
	{
		public MaxBucketAggregationDescriptor()
		{
		}

		internal MaxBucketAggregationDescriptor(Action<MaxBucketAggregationDescriptor> configure) => configure.Invoke(this);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WriteEndObject();
		}
	}

	public partial class MedianAbsoluteDeviationAggregate : Aggregations.SingleMetricAggregateBase
	{
	}

	public partial class MedianAbsoluteDeviationAggregation : Aggregations.FormatMetricAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "median_absolute_deviation";
		[JsonInclude]
		[JsonPropertyName("compression")]
		public double? Compression { get; set; }
	}

	public sealed partial class MedianAbsoluteDeviationAggregationDescriptor : DescriptorBase<MedianAbsoluteDeviationAggregationDescriptor>
	{
		public MedianAbsoluteDeviationAggregationDescriptor()
		{
		}

		internal MedianAbsoluteDeviationAggregationDescriptor(Action<MedianAbsoluteDeviationAggregationDescriptor> configure) => configure.Invoke(this);
		internal double? CompressionValue { get; private set; }

		public MedianAbsoluteDeviationAggregationDescriptor Compression(double? compression) => Assign(compression, (a, v) => a.CompressionValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (CompressionValue.HasValue)
			{
				writer.WritePropertyName("compression");
				writer.WriteNumberValue(CompressionValue.Value);
			}

			writer.WriteEndObject();
		}
	}

	public abstract partial class MetricAggregationBase
	{
		[JsonInclude]
		[JsonPropertyName("field")]
		public string? Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("missing")]
		public Elastic.Clients.Elasticsearch.Aggregations.Missing? Missing { get; set; }

		[JsonInclude]
		[JsonPropertyName("script")]
		public Elastic.Clients.Elasticsearch.Script? Script { get; set; }
	}

	public sealed partial class MetricAggregationBaseDescriptor<T> : DescriptorBase<MetricAggregationBaseDescriptor<T>>
	{
		public MetricAggregationBaseDescriptor()
		{
		}

		internal MetricAggregationBaseDescriptor(Action<MetricAggregationBaseDescriptor<T>> configure) => configure.Invoke(this);
		internal string? FieldValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Aggregations.Missing? MissingValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Script? ScriptValue { get; private set; }

		public MetricAggregationBaseDescriptor<T> Field(string? field) => Assign(field, (a, v) => a.FieldValue = v);
		public MetricAggregationBaseDescriptor<T> Missing(Elastic.Clients.Elasticsearch.Aggregations.Missing? missing) => Assign(missing, (a, v) => a.MissingValue = v);
		public MetricAggregationBaseDescriptor<T> Script(Elastic.Clients.Elasticsearch.Script? script) => Assign(script, (a, v) => a.ScriptValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (FieldValue is not null)
			{
				writer.WritePropertyName("field");
				JsonSerializer.Serialize(writer, FieldValue, options);
			}

			if (MissingValue is not null)
			{
				writer.WritePropertyName("missing");
				JsonSerializer.Serialize(writer, MissingValue, options);
			}

			if (ScriptValue is not null)
			{
				writer.WritePropertyName("script");
				JsonSerializer.Serialize(writer, ScriptValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class MinAggregate : Aggregations.SingleMetricAggregateBase
	{
	}

	public partial class MinAggregation : Aggregations.FormatMetricAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "min";
	}

	public sealed partial class MinAggregationDescriptor : DescriptorBase<MinAggregationDescriptor>
	{
		public MinAggregationDescriptor()
		{
		}

		internal MinAggregationDescriptor(Action<MinAggregationDescriptor> configure) => configure.Invoke(this);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WriteEndObject();
		}
	}

	public partial class MinBucketAggregation : Aggregations.PipelineAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "min_bucket";
	}

	public sealed partial class MinBucketAggregationDescriptor : DescriptorBase<MinBucketAggregationDescriptor>
	{
		public MinBucketAggregationDescriptor()
		{
		}

		internal MinBucketAggregationDescriptor(Action<MinBucketAggregationDescriptor> configure) => configure.Invoke(this);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WriteEndObject();
		}
	}

	public partial class MissingAggregate : Aggregations.SingleBucketAggregateBase
	{
	}

	public partial class MissingAggregation : Aggregations.BucketAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "missing";
		[JsonInclude]
		[JsonPropertyName("field")]
		public string? Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("missing")]
		public Elastic.Clients.Elasticsearch.Aggregations.Missing? Missing { get; set; }
	}

	public sealed partial class MissingAggregationDescriptor<T> : DescriptorBase<MissingAggregationDescriptor<T>>
	{
		public MissingAggregationDescriptor()
		{
		}

		internal MissingAggregationDescriptor(Action<MissingAggregationDescriptor<T>> configure) => configure.Invoke(this);
		internal string? FieldValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Aggregations.Missing? MissingValue { get; private set; }

		public MissingAggregationDescriptor<T> Field(string? field) => Assign(field, (a, v) => a.FieldValue = v);
		public MissingAggregationDescriptor<T> Missing(Elastic.Clients.Elasticsearch.Aggregations.Missing? missing) => Assign(missing, (a, v) => a.MissingValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (FieldValue is not null)
			{
				writer.WritePropertyName("field");
				JsonSerializer.Serialize(writer, FieldValue, options);
			}

			if (MissingValue is not null)
			{
				writer.WritePropertyName("missing");
				JsonSerializer.Serialize(writer, MissingValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class MovingFunctionAggregation : Aggregations.PipelineAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "moving_fn";
		[JsonInclude]
		[JsonPropertyName("script")]
		public string? Script { get; set; }

		[JsonInclude]
		[JsonPropertyName("shift")]
		public int? Shift { get; set; }

		[JsonInclude]
		[JsonPropertyName("window")]
		public int? Window { get; set; }
	}

	public sealed partial class MovingFunctionAggregationDescriptor : DescriptorBase<MovingFunctionAggregationDescriptor>
	{
		public MovingFunctionAggregationDescriptor()
		{
		}

		internal MovingFunctionAggregationDescriptor(Action<MovingFunctionAggregationDescriptor> configure) => configure.Invoke(this);
		internal string? ScriptValue { get; private set; }

		internal int? ShiftValue { get; private set; }

		internal int? WindowValue { get; private set; }

		public MovingFunctionAggregationDescriptor Script(string? script) => Assign(script, (a, v) => a.ScriptValue = v);
		public MovingFunctionAggregationDescriptor Shift(int? shift) => Assign(shift, (a, v) => a.ShiftValue = v);
		public MovingFunctionAggregationDescriptor Window(int? window) => Assign(window, (a, v) => a.WindowValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (!string.IsNullOrEmpty(ScriptValue))
			{
				writer.WritePropertyName("script");
				writer.WriteStringValue(ScriptValue);
			}

			if (ShiftValue.HasValue)
			{
				writer.WritePropertyName("shift");
				writer.WriteNumberValue(ShiftValue.Value);
			}

			if (WindowValue.HasValue)
			{
				writer.WritePropertyName("window");
				writer.WriteNumberValue(WindowValue.Value);
			}

			writer.WriteEndObject();
		}
	}

	public partial class MovingPercentilesAggregation : Aggregations.PipelineAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "moving_percentiles";
		[JsonInclude]
		[JsonPropertyName("window")]
		public int? Window { get; set; }

		[JsonInclude]
		[JsonPropertyName("shift")]
		public int? Shift { get; set; }

		[JsonInclude]
		[JsonPropertyName("keyed")]
		public bool? Keyed { get; set; }
	}

	public sealed partial class MovingPercentilesAggregationDescriptor : DescriptorBase<MovingPercentilesAggregationDescriptor>
	{
		public MovingPercentilesAggregationDescriptor()
		{
		}

		internal MovingPercentilesAggregationDescriptor(Action<MovingPercentilesAggregationDescriptor> configure) => configure.Invoke(this);
		internal int? WindowValue { get; private set; }

		internal int? ShiftValue { get; private set; }

		internal bool? KeyedValue { get; private set; }

		public MovingPercentilesAggregationDescriptor Window(int? window) => Assign(window, (a, v) => a.WindowValue = v);
		public MovingPercentilesAggregationDescriptor Shift(int? shift) => Assign(shift, (a, v) => a.ShiftValue = v);
		public MovingPercentilesAggregationDescriptor Keyed(bool? keyed = true) => Assign(keyed, (a, v) => a.KeyedValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (WindowValue.HasValue)
			{
				writer.WritePropertyName("window");
				writer.WriteNumberValue(WindowValue.Value);
			}

			if (ShiftValue.HasValue)
			{
				writer.WritePropertyName("shift");
				writer.WriteNumberValue(ShiftValue.Value);
			}

			if (KeyedValue.HasValue)
			{
				writer.WritePropertyName("keyed");
				writer.WriteBooleanValue(KeyedValue.Value);
			}

			writer.WriteEndObject();
		}
	}

	public abstract partial class MultiBucketAggregateBase<TBucket> : Aggregations.AggregateBase
	{
		[JsonInclude]
		[JsonPropertyName("buckets")]
		public Elastic.Clients.Elasticsearch.Aggregations.Buckets<TBucket> Buckets { get; init; }
	}

	public abstract partial class MultiBucketBase
	{
		[JsonInclude]
		[JsonPropertyName("doc_count")]
		public long DocCount { get; init; }
	}

	public partial class MultiTermLookup
	{
		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }
	}

	public sealed partial class MultiTermLookupDescriptor<T> : DescriptorBase<MultiTermLookupDescriptor<T>>
	{
		public MultiTermLookupDescriptor()
		{
		}

		internal MultiTermLookupDescriptor(Action<MultiTermLookupDescriptor<T>> configure) => configure.Invoke(this);
		internal string FieldValue { get; private set; }

		public MultiTermLookupDescriptor<T> Field(string field) => Assign(field, (a, v) => a.FieldValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, FieldValue, options);
			writer.WriteEndObject();
		}
	}

	public partial class MultiTermsAggregate : Aggregations.TermsAggregateBase<Elastic.Clients.Elasticsearch.Aggregations.MultiTermsBucket>
	{
	}

	public partial class MultiTermsAggregation : Aggregations.BucketAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "multi_terms";
		[JsonInclude]
		[JsonPropertyName("terms")]
		public IEnumerable<Elastic.Clients.Elasticsearch.Aggregations.MultiTermLookup> Terms { get; set; }
	}

	public sealed partial class MultiTermsAggregationDescriptor : DescriptorBase<MultiTermsAggregationDescriptor>
	{
		public MultiTermsAggregationDescriptor()
		{
		}

		internal MultiTermsAggregationDescriptor(Action<MultiTermsAggregationDescriptor> configure) => configure.Invoke(this);
		internal IEnumerable<Elastic.Clients.Elasticsearch.Aggregations.MultiTermLookup> TermsValue { get; private set; }

		public MultiTermsAggregationDescriptor Terms(IEnumerable<Elastic.Clients.Elasticsearch.Aggregations.MultiTermLookup> terms) => Assign(terms, (a, v) => a.TermsValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("terms");
			JsonSerializer.Serialize(writer, TermsValue, options);
			writer.WriteEndObject();
		}
	}

	public partial class MultiTermsBucket : Aggregations.MultiBucketBase
	{
		[JsonInclude]
		[JsonPropertyName("key")]
		public IReadOnlyCollection<object> Key { get; init; }

		[JsonInclude]
		[JsonPropertyName("key_as_string")]
		public string? KeyAsString { get; init; }

		[JsonInclude]
		[JsonPropertyName("doc_count_error_upper_bound")]
		public long? DocCountErrorUpperBound { get; init; }
	}

	public partial class MutualInformationHeuristic
	{
		[JsonInclude]
		[JsonPropertyName("background_is_superset")]
		public bool? BackgroundIsSuperset { get; set; }

		[JsonInclude]
		[JsonPropertyName("include_negatives")]
		public bool? IncludeNegatives { get; set; }
	}

	public sealed partial class MutualInformationHeuristicDescriptor : DescriptorBase<MutualInformationHeuristicDescriptor>
	{
		public MutualInformationHeuristicDescriptor()
		{
		}

		internal MutualInformationHeuristicDescriptor(Action<MutualInformationHeuristicDescriptor> configure) => configure.Invoke(this);
		internal bool? BackgroundIsSupersetValue { get; private set; }

		internal bool? IncludeNegativesValue { get; private set; }

		public MutualInformationHeuristicDescriptor BackgroundIsSuperset(bool? backgroundIsSuperset = true) => Assign(backgroundIsSuperset, (a, v) => a.BackgroundIsSupersetValue = v);
		public MutualInformationHeuristicDescriptor IncludeNegatives(bool? includeNegatives = true) => Assign(includeNegatives, (a, v) => a.IncludeNegativesValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (BackgroundIsSupersetValue.HasValue)
			{
				writer.WritePropertyName("background_is_superset");
				writer.WriteBooleanValue(BackgroundIsSupersetValue.Value);
			}

			if (IncludeNegativesValue.HasValue)
			{
				writer.WritePropertyName("include_negatives");
				writer.WriteBooleanValue(IncludeNegativesValue.Value);
			}

			writer.WriteEndObject();
		}
	}

	public partial class NestedAggregate : Aggregations.SingleBucketAggregateBase
	{
	}

	public partial class NestedAggregation : Aggregations.BucketAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "nested";
		[JsonInclude]
		[JsonPropertyName("path")]
		public string? Path { get; set; }
	}

	public sealed partial class NestedAggregationDescriptor<T> : DescriptorBase<NestedAggregationDescriptor<T>>
	{
		public NestedAggregationDescriptor()
		{
		}

		internal NestedAggregationDescriptor(Action<NestedAggregationDescriptor<T>> configure) => configure.Invoke(this);
		internal string? PathValue { get; private set; }

		public NestedAggregationDescriptor<T> Path(string? path) => Assign(path, (a, v) => a.PathValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (PathValue is not null)
			{
				writer.WritePropertyName("path");
				JsonSerializer.Serialize(writer, PathValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class NormalizeAggregation : Aggregations.PipelineAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "normalize";
		[JsonInclude]
		[JsonPropertyName("method")]
		public Elastic.Clients.Elasticsearch.Aggregations.NormalizeMethod? Method { get; set; }
	}

	public sealed partial class NormalizeAggregationDescriptor : DescriptorBase<NormalizeAggregationDescriptor>
	{
		public NormalizeAggregationDescriptor()
		{
		}

		internal NormalizeAggregationDescriptor(Action<NormalizeAggregationDescriptor> configure) => configure.Invoke(this);
		internal Elastic.Clients.Elasticsearch.Aggregations.NormalizeMethod? MethodValue { get; private set; }

		public NormalizeAggregationDescriptor Method(Elastic.Clients.Elasticsearch.Aggregations.NormalizeMethod? method) => Assign(method, (a, v) => a.MethodValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (MethodValue is not null)
			{
				writer.WritePropertyName("method");
				JsonSerializer.Serialize(writer, MethodValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class ParentAggregation : Aggregations.BucketAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "parent";
		[JsonInclude]
		[JsonPropertyName("type")]
		public string? Type { get; set; }
	}

	public sealed partial class ParentAggregationDescriptor : DescriptorBase<ParentAggregationDescriptor>
	{
		public ParentAggregationDescriptor()
		{
		}

		internal ParentAggregationDescriptor(Action<ParentAggregationDescriptor> configure) => configure.Invoke(this);
		internal string? TypeValue { get; private set; }

		public ParentAggregationDescriptor Type(string? type) => Assign(type, (a, v) => a.TypeValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (TypeValue is not null)
			{
				writer.WritePropertyName("type");
				JsonSerializer.Serialize(writer, TypeValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class PercentageScoreHeuristic
	{
	}

	public sealed partial class PercentageScoreHeuristicDescriptor : DescriptorBase<PercentageScoreHeuristicDescriptor>
	{
		public PercentageScoreHeuristicDescriptor()
		{
		}

		internal PercentageScoreHeuristicDescriptor(Action<PercentageScoreHeuristicDescriptor> configure) => configure.Invoke(this);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WriteEndObject();
		}
	}

	public partial class PercentileRanksAggregation : Aggregations.FormatMetricAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "percentile_ranks";
		[JsonInclude]
		[JsonPropertyName("keyed")]
		public bool? Keyed { get; set; }

		[JsonInclude]
		[JsonPropertyName("values")]
		public IEnumerable<double>? Values { get; set; }

		[JsonInclude]
		[JsonPropertyName("hdr")]
		public Elastic.Clients.Elasticsearch.Aggregations.HdrMethod? Hdr { get; set; }

		[JsonInclude]
		[JsonPropertyName("tdigest")]
		public Elastic.Clients.Elasticsearch.Aggregations.TDigest? Tdigest { get; set; }
	}

	public sealed partial class PercentileRanksAggregationDescriptor : DescriptorBase<PercentileRanksAggregationDescriptor>
	{
		public PercentileRanksAggregationDescriptor()
		{
		}

		internal PercentileRanksAggregationDescriptor(Action<PercentileRanksAggregationDescriptor> configure) => configure.Invoke(this);
		internal bool? KeyedValue { get; private set; }

		internal IEnumerable<double>? ValuesValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Aggregations.HdrMethod? HdrValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Aggregations.TDigest? TdigestValue { get; private set; }

		internal HdrMethodDescriptor HdrDescriptor { get; private set; }

		internal TDigestDescriptor TdigestDescriptor { get; private set; }

		internal Action<HdrMethodDescriptor> HdrDescriptorAction { get; private set; }

		internal Action<TDigestDescriptor> TdigestDescriptorAction { get; private set; }

		public PercentileRanksAggregationDescriptor Keyed(bool? keyed = true) => Assign(keyed, (a, v) => a.KeyedValue = v);
		public PercentileRanksAggregationDescriptor Values(IEnumerable<double>? values) => Assign(values, (a, v) => a.ValuesValue = v);
		public PercentileRanksAggregationDescriptor Hdr(Elastic.Clients.Elasticsearch.Aggregations.HdrMethod? hdr)
		{
			HdrDescriptor = null;
			HdrDescriptorAction = null;
			return Assign(hdr, (a, v) => a.HdrValue = v);
		}

		public PercentileRanksAggregationDescriptor Hdr(Elastic.Clients.Elasticsearch.Aggregations.HdrMethodDescriptor descriptor)
		{
			HdrValue = null;
			HdrDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.HdrDescriptor = v);
		}

		public PercentileRanksAggregationDescriptor Hdr(Action<Elastic.Clients.Elasticsearch.Aggregations.HdrMethodDescriptor> configure)
		{
			HdrValue = null;
			HdrDescriptorAction = null;
			return Assign(configure, (a, v) => a.HdrDescriptorAction = v);
		}

		public PercentileRanksAggregationDescriptor Tdigest(Elastic.Clients.Elasticsearch.Aggregations.TDigest? tdigest)
		{
			TdigestDescriptor = null;
			TdigestDescriptorAction = null;
			return Assign(tdigest, (a, v) => a.TdigestValue = v);
		}

		public PercentileRanksAggregationDescriptor Tdigest(Elastic.Clients.Elasticsearch.Aggregations.TDigestDescriptor descriptor)
		{
			TdigestValue = null;
			TdigestDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.TdigestDescriptor = v);
		}

		public PercentileRanksAggregationDescriptor Tdigest(Action<Elastic.Clients.Elasticsearch.Aggregations.TDigestDescriptor> configure)
		{
			TdigestValue = null;
			TdigestDescriptorAction = null;
			return Assign(configure, (a, v) => a.TdigestDescriptorAction = v);
		}

		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (KeyedValue.HasValue)
			{
				writer.WritePropertyName("keyed");
				writer.WriteBooleanValue(KeyedValue.Value);
			}

			if (ValuesValue is not null)
			{
				writer.WritePropertyName("values");
				JsonSerializer.Serialize(writer, ValuesValue, options);
			}

			if (HdrDescriptor is not null)
			{
				writer.WritePropertyName("hdr");
				JsonSerializer.Serialize(writer, HdrDescriptor, options);
			}
			else if (HdrDescriptorAction is not null)
			{
				writer.WritePropertyName("hdr");
				JsonSerializer.Serialize(writer, new HdrMethodDescriptor(HdrDescriptorAction), options);
			}
			else if (HdrValue is not null)
			{
				writer.WritePropertyName("hdr");
				JsonSerializer.Serialize(writer, HdrValue, options);
			}

			if (TdigestDescriptor is not null)
			{
				writer.WritePropertyName("tdigest");
				JsonSerializer.Serialize(writer, TdigestDescriptor, options);
			}
			else if (TdigestDescriptorAction is not null)
			{
				writer.WritePropertyName("tdigest");
				JsonSerializer.Serialize(writer, new TDigestDescriptor(TdigestDescriptorAction), options);
			}
			else if (TdigestValue is not null)
			{
				writer.WritePropertyName("tdigest");
				JsonSerializer.Serialize(writer, TdigestValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public abstract partial class PercentilesAggregateBase : Aggregations.AggregateBase
	{
		[JsonInclude]
		[JsonPropertyName("values")]
		public Elastic.Clients.Elasticsearch.Aggregations.Percentiles Values { get; init; }
	}

	public partial class PercentilesAggregation : Aggregations.FormatMetricAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "percentiles";
		[JsonInclude]
		[JsonPropertyName("keyed")]
		public bool? Keyed { get; set; }

		[JsonInclude]
		[JsonPropertyName("percents")]
		public IEnumerable<double>? Percents { get; set; }

		[JsonInclude]
		[JsonPropertyName("hdr")]
		public Elastic.Clients.Elasticsearch.Aggregations.HdrMethod? Hdr { get; set; }

		[JsonInclude]
		[JsonPropertyName("tdigest")]
		public Elastic.Clients.Elasticsearch.Aggregations.TDigest? Tdigest { get; set; }
	}

	public sealed partial class PercentilesAggregationDescriptor : DescriptorBase<PercentilesAggregationDescriptor>
	{
		public PercentilesAggregationDescriptor()
		{
		}

		internal PercentilesAggregationDescriptor(Action<PercentilesAggregationDescriptor> configure) => configure.Invoke(this);
		internal bool? KeyedValue { get; private set; }

		internal IEnumerable<double>? PercentsValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Aggregations.HdrMethod? HdrValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Aggregations.TDigest? TdigestValue { get; private set; }

		internal HdrMethodDescriptor HdrDescriptor { get; private set; }

		internal TDigestDescriptor TdigestDescriptor { get; private set; }

		internal Action<HdrMethodDescriptor> HdrDescriptorAction { get; private set; }

		internal Action<TDigestDescriptor> TdigestDescriptorAction { get; private set; }

		public PercentilesAggregationDescriptor Keyed(bool? keyed = true) => Assign(keyed, (a, v) => a.KeyedValue = v);
		public PercentilesAggregationDescriptor Percents(IEnumerable<double>? percents) => Assign(percents, (a, v) => a.PercentsValue = v);
		public PercentilesAggregationDescriptor Hdr(Elastic.Clients.Elasticsearch.Aggregations.HdrMethod? hdr)
		{
			HdrDescriptor = null;
			HdrDescriptorAction = null;
			return Assign(hdr, (a, v) => a.HdrValue = v);
		}

		public PercentilesAggregationDescriptor Hdr(Elastic.Clients.Elasticsearch.Aggregations.HdrMethodDescriptor descriptor)
		{
			HdrValue = null;
			HdrDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.HdrDescriptor = v);
		}

		public PercentilesAggregationDescriptor Hdr(Action<Elastic.Clients.Elasticsearch.Aggregations.HdrMethodDescriptor> configure)
		{
			HdrValue = null;
			HdrDescriptorAction = null;
			return Assign(configure, (a, v) => a.HdrDescriptorAction = v);
		}

		public PercentilesAggregationDescriptor Tdigest(Elastic.Clients.Elasticsearch.Aggregations.TDigest? tdigest)
		{
			TdigestDescriptor = null;
			TdigestDescriptorAction = null;
			return Assign(tdigest, (a, v) => a.TdigestValue = v);
		}

		public PercentilesAggregationDescriptor Tdigest(Elastic.Clients.Elasticsearch.Aggregations.TDigestDescriptor descriptor)
		{
			TdigestValue = null;
			TdigestDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.TdigestDescriptor = v);
		}

		public PercentilesAggregationDescriptor Tdigest(Action<Elastic.Clients.Elasticsearch.Aggregations.TDigestDescriptor> configure)
		{
			TdigestValue = null;
			TdigestDescriptorAction = null;
			return Assign(configure, (a, v) => a.TdigestDescriptorAction = v);
		}

		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (KeyedValue.HasValue)
			{
				writer.WritePropertyName("keyed");
				writer.WriteBooleanValue(KeyedValue.Value);
			}

			if (PercentsValue is not null)
			{
				writer.WritePropertyName("percents");
				JsonSerializer.Serialize(writer, PercentsValue, options);
			}

			if (HdrDescriptor is not null)
			{
				writer.WritePropertyName("hdr");
				JsonSerializer.Serialize(writer, HdrDescriptor, options);
			}
			else if (HdrDescriptorAction is not null)
			{
				writer.WritePropertyName("hdr");
				JsonSerializer.Serialize(writer, new HdrMethodDescriptor(HdrDescriptorAction), options);
			}
			else if (HdrValue is not null)
			{
				writer.WritePropertyName("hdr");
				JsonSerializer.Serialize(writer, HdrValue, options);
			}

			if (TdigestDescriptor is not null)
			{
				writer.WritePropertyName("tdigest");
				JsonSerializer.Serialize(writer, TdigestDescriptor, options);
			}
			else if (TdigestDescriptorAction is not null)
			{
				writer.WritePropertyName("tdigest");
				JsonSerializer.Serialize(writer, new TDigestDescriptor(TdigestDescriptorAction), options);
			}
			else if (TdigestValue is not null)
			{
				writer.WritePropertyName("tdigest");
				JsonSerializer.Serialize(writer, TdigestValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class PercentilesBucketAggregate : Aggregations.PercentilesAggregateBase
	{
	}

	public partial class PercentilesBucketAggregation : Aggregations.PipelineAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "percentiles_bucket";
		[JsonInclude]
		[JsonPropertyName("percents")]
		public IEnumerable<double>? Percents { get; set; }
	}

	public sealed partial class PercentilesBucketAggregationDescriptor : DescriptorBase<PercentilesBucketAggregationDescriptor>
	{
		public PercentilesBucketAggregationDescriptor()
		{
		}

		internal PercentilesBucketAggregationDescriptor(Action<PercentilesBucketAggregationDescriptor> configure) => configure.Invoke(this);
		internal IEnumerable<double>? PercentsValue { get; private set; }

		public PercentilesBucketAggregationDescriptor Percents(IEnumerable<double>? percents) => Assign(percents, (a, v) => a.PercentsValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (PercentsValue is not null)
			{
				writer.WritePropertyName("percents");
				JsonSerializer.Serialize(writer, PercentsValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public abstract partial class PipelineAggregationBase : Aggregations.AggregationBase
	{
		[JsonInclude]
		[JsonPropertyName("buckets_path")]
		public Elastic.Clients.Elasticsearch.Aggregations.BucketsPath? BucketsPath { get; set; }

		[JsonInclude]
		[JsonPropertyName("format")]
		public string? Format { get; set; }

		[JsonInclude]
		[JsonPropertyName("gap_policy")]
		public Elastic.Clients.Elasticsearch.Aggregations.GapPolicy? GapPolicy { get; set; }
	}

	public sealed partial class PipelineAggregationBaseDescriptor : DescriptorBase<PipelineAggregationBaseDescriptor>
	{
		public PipelineAggregationBaseDescriptor()
		{
		}

		internal PipelineAggregationBaseDescriptor(Action<PipelineAggregationBaseDescriptor> configure) => configure.Invoke(this);
		internal Elastic.Clients.Elasticsearch.Aggregations.BucketsPath? BucketsPathValue { get; private set; }

		internal string? FormatValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Aggregations.GapPolicy? GapPolicyValue { get; private set; }

		public PipelineAggregationBaseDescriptor BucketsPath(Elastic.Clients.Elasticsearch.Aggregations.BucketsPath? bucketsPath) => Assign(bucketsPath, (a, v) => a.BucketsPathValue = v);
		public PipelineAggregationBaseDescriptor Format(string? format) => Assign(format, (a, v) => a.FormatValue = v);
		public PipelineAggregationBaseDescriptor GapPolicy(Elastic.Clients.Elasticsearch.Aggregations.GapPolicy? gapPolicy) => Assign(gapPolicy, (a, v) => a.GapPolicyValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (BucketsPathValue is not null)
			{
				writer.WritePropertyName("buckets_path");
				JsonSerializer.Serialize(writer, BucketsPathValue, options);
			}

			if (!string.IsNullOrEmpty(FormatValue))
			{
				writer.WritePropertyName("format");
				writer.WriteStringValue(FormatValue);
			}

			if (GapPolicyValue is not null)
			{
				writer.WritePropertyName("gap_policy");
				JsonSerializer.Serialize(writer, GapPolicyValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class RangeAggregate : Aggregations.MultiBucketAggregateBase<Elastic.Clients.Elasticsearch.Aggregations.RangeBucket>
	{
	}

	public partial class RangeAggregation : Aggregations.BucketAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "range";
		[JsonInclude]
		[JsonPropertyName("field")]
		public string? Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("missing")]
		public int? Missing { get; set; }

		[JsonInclude]
		[JsonPropertyName("ranges")]
		public IEnumerable<Elastic.Clients.Elasticsearch.Aggregations.AggregationRange>? Ranges { get; set; }

		[JsonInclude]
		[JsonPropertyName("script")]
		public Elastic.Clients.Elasticsearch.Script? Script { get; set; }

		[JsonInclude]
		[JsonPropertyName("keyed")]
		public bool? Keyed { get; set; }
	}

	public sealed partial class RangeAggregationDescriptor<T> : DescriptorBase<RangeAggregationDescriptor<T>>
	{
		public RangeAggregationDescriptor()
		{
		}

		internal RangeAggregationDescriptor(Action<RangeAggregationDescriptor<T>> configure) => configure.Invoke(this);
		internal string? FieldValue { get; private set; }

		internal int? MissingValue { get; private set; }

		internal IEnumerable<Elastic.Clients.Elasticsearch.Aggregations.AggregationRange>? RangesValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Script? ScriptValue { get; private set; }

		internal bool? KeyedValue { get; private set; }

		public RangeAggregationDescriptor<T> Field(string? field) => Assign(field, (a, v) => a.FieldValue = v);
		public RangeAggregationDescriptor<T> Missing(int? missing) => Assign(missing, (a, v) => a.MissingValue = v);
		public RangeAggregationDescriptor<T> Ranges(IEnumerable<Elastic.Clients.Elasticsearch.Aggregations.AggregationRange>? ranges) => Assign(ranges, (a, v) => a.RangesValue = v);
		public RangeAggregationDescriptor<T> Script(Elastic.Clients.Elasticsearch.Script? script) => Assign(script, (a, v) => a.ScriptValue = v);
		public RangeAggregationDescriptor<T> Keyed(bool? keyed = true) => Assign(keyed, (a, v) => a.KeyedValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (FieldValue is not null)
			{
				writer.WritePropertyName("field");
				JsonSerializer.Serialize(writer, FieldValue, options);
			}

			if (MissingValue.HasValue)
			{
				writer.WritePropertyName("missing");
				writer.WriteNumberValue(MissingValue.Value);
			}

			if (RangesValue is not null)
			{
				writer.WritePropertyName("ranges");
				JsonSerializer.Serialize(writer, RangesValue, options);
			}

			if (ScriptValue is not null)
			{
				writer.WritePropertyName("script");
				JsonSerializer.Serialize(writer, ScriptValue, options);
			}

			if (KeyedValue.HasValue)
			{
				writer.WritePropertyName("keyed");
				writer.WriteBooleanValue(KeyedValue.Value);
			}

			writer.WriteEndObject();
		}
	}

	public partial class RangeBucket : Aggregations.MultiBucketBase
	{
		[JsonInclude]
		[JsonPropertyName("from")]
		public double? From { get; init; }

		[JsonInclude]
		[JsonPropertyName("to")]
		public double? To { get; init; }

		[JsonInclude]
		[JsonPropertyName("from_as_string")]
		public string? FromAsString { get; init; }

		[JsonInclude]
		[JsonPropertyName("to_as_string")]
		public string? ToAsString { get; init; }
	}

	public partial class RareTermsAggregation : Aggregations.BucketAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "rare_terms";
		[JsonInclude]
		[JsonPropertyName("exclude")]
		public Elastic.Clients.Elasticsearch.Aggregations.TermsExclude? Exclude { get; set; }

		[JsonInclude]
		[JsonPropertyName("field")]
		public string? Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("include")]
		public Elastic.Clients.Elasticsearch.Aggregations.TermsInclude? Include { get; set; }

		[JsonInclude]
		[JsonPropertyName("max_doc_count")]
		public long? MaxDocCount { get; set; }

		[JsonInclude]
		[JsonPropertyName("missing")]
		public Elastic.Clients.Elasticsearch.Aggregations.Missing? Missing { get; set; }

		[JsonInclude]
		[JsonPropertyName("precision")]
		public double? Precision { get; set; }

		[JsonInclude]
		[JsonPropertyName("value_type")]
		public string? ValueType { get; set; }
	}

	public sealed partial class RareTermsAggregationDescriptor<T> : DescriptorBase<RareTermsAggregationDescriptor<T>>
	{
		public RareTermsAggregationDescriptor()
		{
		}

		internal RareTermsAggregationDescriptor(Action<RareTermsAggregationDescriptor<T>> configure) => configure.Invoke(this);
		internal Elastic.Clients.Elasticsearch.Aggregations.TermsExclude? ExcludeValue { get; private set; }

		internal string? FieldValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Aggregations.TermsInclude? IncludeValue { get; private set; }

		internal long? MaxDocCountValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Aggregations.Missing? MissingValue { get; private set; }

		internal double? PrecisionValue { get; private set; }

		internal string? ValueTypeValue { get; private set; }

		public RareTermsAggregationDescriptor<T> Exclude(Elastic.Clients.Elasticsearch.Aggregations.TermsExclude? exclude) => Assign(exclude, (a, v) => a.ExcludeValue = v);
		public RareTermsAggregationDescriptor<T> Field(string? field) => Assign(field, (a, v) => a.FieldValue = v);
		public RareTermsAggregationDescriptor<T> Include(Elastic.Clients.Elasticsearch.Aggregations.TermsInclude? include) => Assign(include, (a, v) => a.IncludeValue = v);
		public RareTermsAggregationDescriptor<T> MaxDocCount(long? maxDocCount) => Assign(maxDocCount, (a, v) => a.MaxDocCountValue = v);
		public RareTermsAggregationDescriptor<T> Missing(Elastic.Clients.Elasticsearch.Aggregations.Missing? missing) => Assign(missing, (a, v) => a.MissingValue = v);
		public RareTermsAggregationDescriptor<T> Precision(double? precision) => Assign(precision, (a, v) => a.PrecisionValue = v);
		public RareTermsAggregationDescriptor<T> ValueType(string? valueType) => Assign(valueType, (a, v) => a.ValueTypeValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (ExcludeValue is not null)
			{
				writer.WritePropertyName("exclude");
				JsonSerializer.Serialize(writer, ExcludeValue, options);
			}

			if (FieldValue is not null)
			{
				writer.WritePropertyName("field");
				JsonSerializer.Serialize(writer, FieldValue, options);
			}

			if (IncludeValue is not null)
			{
				writer.WritePropertyName("include");
				JsonSerializer.Serialize(writer, IncludeValue, options);
			}

			if (MaxDocCountValue.HasValue)
			{
				writer.WritePropertyName("max_doc_count");
				writer.WriteNumberValue(MaxDocCountValue.Value);
			}

			if (MissingValue is not null)
			{
				writer.WritePropertyName("missing");
				JsonSerializer.Serialize(writer, MissingValue, options);
			}

			if (PrecisionValue.HasValue)
			{
				writer.WritePropertyName("precision");
				writer.WriteNumberValue(PrecisionValue.Value);
			}

			if (!string.IsNullOrEmpty(ValueTypeValue))
			{
				writer.WritePropertyName("value_type");
				writer.WriteStringValue(ValueTypeValue);
			}

			writer.WriteEndObject();
		}
	}

	public partial class RateAggregate : Aggregations.AggregateBase
	{
		[JsonInclude]
		[JsonPropertyName("value")]
		public double Value { get; init; }

		[JsonInclude]
		[JsonPropertyName("value_as_string")]
		public string? ValueAsString { get; init; }
	}

	public partial class RateAggregation : Aggregations.FormatMetricAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "rate";
		[JsonInclude]
		[JsonPropertyName("unit")]
		public Elastic.Clients.Elasticsearch.Aggregations.CalendarInterval? Unit { get; set; }

		[JsonInclude]
		[JsonPropertyName("mode")]
		public Elastic.Clients.Elasticsearch.Aggregations.RateMode? Mode { get; set; }
	}

	public sealed partial class RateAggregationDescriptor : DescriptorBase<RateAggregationDescriptor>
	{
		public RateAggregationDescriptor()
		{
		}

		internal RateAggregationDescriptor(Action<RateAggregationDescriptor> configure) => configure.Invoke(this);
		internal Elastic.Clients.Elasticsearch.Aggregations.CalendarInterval? UnitValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Aggregations.RateMode? ModeValue { get; private set; }

		public RateAggregationDescriptor Unit(Elastic.Clients.Elasticsearch.Aggregations.CalendarInterval? unit) => Assign(unit, (a, v) => a.UnitValue = v);
		public RateAggregationDescriptor Mode(Elastic.Clients.Elasticsearch.Aggregations.RateMode? mode) => Assign(mode, (a, v) => a.ModeValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (UnitValue is not null)
			{
				writer.WritePropertyName("unit");
				JsonSerializer.Serialize(writer, UnitValue, options);
			}

			if (ModeValue is not null)
			{
				writer.WritePropertyName("mode");
				JsonSerializer.Serialize(writer, ModeValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class RegressionInferenceOptions
	{
		[JsonInclude]
		[JsonPropertyName("results_field")]
		public string? ResultsField { get; set; }

		[JsonInclude]
		[JsonPropertyName("num_top_feature_importance_values")]
		public int? NumTopFeatureImportanceValues { get; set; }
	}

	public sealed partial class RegressionInferenceOptionsDescriptor<T> : DescriptorBase<RegressionInferenceOptionsDescriptor<T>>
	{
		public RegressionInferenceOptionsDescriptor()
		{
		}

		internal RegressionInferenceOptionsDescriptor(Action<RegressionInferenceOptionsDescriptor<T>> configure) => configure.Invoke(this);
		internal string? ResultsFieldValue { get; private set; }

		internal int? NumTopFeatureImportanceValuesValue { get; private set; }

		public RegressionInferenceOptionsDescriptor<T> ResultsField(string? resultsField) => Assign(resultsField, (a, v) => a.ResultsFieldValue = v);
		public RegressionInferenceOptionsDescriptor<T> NumTopFeatureImportanceValues(int? numTopFeatureImportanceValues) => Assign(numTopFeatureImportanceValues, (a, v) => a.NumTopFeatureImportanceValuesValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (ResultsFieldValue is not null)
			{
				writer.WritePropertyName("results_field");
				JsonSerializer.Serialize(writer, ResultsFieldValue, options);
			}

			if (NumTopFeatureImportanceValuesValue.HasValue)
			{
				writer.WritePropertyName("num_top_feature_importance_values");
				writer.WriteNumberValue(NumTopFeatureImportanceValuesValue.Value);
			}

			writer.WriteEndObject();
		}
	}

	public partial class ReverseNestedAggregate : Aggregations.SingleBucketAggregateBase
	{
	}

	public partial class ReverseNestedAggregation : Aggregations.BucketAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "reverse_nested";
		[JsonInclude]
		[JsonPropertyName("path")]
		public string? Path { get; set; }
	}

	public sealed partial class ReverseNestedAggregationDescriptor<T> : DescriptorBase<ReverseNestedAggregationDescriptor<T>>
	{
		public ReverseNestedAggregationDescriptor()
		{
		}

		internal ReverseNestedAggregationDescriptor(Action<ReverseNestedAggregationDescriptor<T>> configure) => configure.Invoke(this);
		internal string? PathValue { get; private set; }

		public ReverseNestedAggregationDescriptor<T> Path(string? path) => Assign(path, (a, v) => a.PathValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (PathValue is not null)
			{
				writer.WritePropertyName("path");
				JsonSerializer.Serialize(writer, PathValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class SamplerAggregate : Aggregations.SingleBucketAggregateBase
	{
	}

	public partial class SamplerAggregation : Aggregations.BucketAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "sampler";
		[JsonInclude]
		[JsonPropertyName("shard_size")]
		public int? ShardSize { get; set; }
	}

	public sealed partial class SamplerAggregationDescriptor : DescriptorBase<SamplerAggregationDescriptor>
	{
		public SamplerAggregationDescriptor()
		{
		}

		internal SamplerAggregationDescriptor(Action<SamplerAggregationDescriptor> configure) => configure.Invoke(this);
		internal int? ShardSizeValue { get; private set; }

		public SamplerAggregationDescriptor ShardSize(int? shardSize) => Assign(shardSize, (a, v) => a.ShardSizeValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (ShardSizeValue.HasValue)
			{
				writer.WritePropertyName("shard_size");
				writer.WriteNumberValue(ShardSizeValue.Value);
			}

			writer.WriteEndObject();
		}
	}

	public partial class ScriptedHeuristic
	{
		[JsonInclude]
		[JsonPropertyName("script")]
		public Elastic.Clients.Elasticsearch.Script Script { get; set; }
	}

	public sealed partial class ScriptedHeuristicDescriptor : DescriptorBase<ScriptedHeuristicDescriptor>
	{
		public ScriptedHeuristicDescriptor()
		{
		}

		internal ScriptedHeuristicDescriptor(Action<ScriptedHeuristicDescriptor> configure) => configure.Invoke(this);
		internal Elastic.Clients.Elasticsearch.Script ScriptValue { get; private set; }

		public ScriptedHeuristicDescriptor Script(Elastic.Clients.Elasticsearch.Script script) => Assign(script, (a, v) => a.ScriptValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("script");
			JsonSerializer.Serialize(writer, ScriptValue, options);
			writer.WriteEndObject();
		}
	}

	public partial class ScriptedMetricAggregate : Aggregations.AggregateBase
	{
		[JsonInclude]
		[JsonPropertyName("value")]
		public object Value { get; init; }
	}

	public partial class ScriptedMetricAggregation : Aggregations.MetricAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "scripted_metric";
		[JsonInclude]
		[JsonPropertyName("combine_script")]
		public Elastic.Clients.Elasticsearch.Script? CombineScript { get; set; }

		[JsonInclude]
		[JsonPropertyName("init_script")]
		public Elastic.Clients.Elasticsearch.Script? InitScript { get; set; }

		[JsonInclude]
		[JsonPropertyName("map_script")]
		public Elastic.Clients.Elasticsearch.Script? MapScript { get; set; }

		[JsonInclude]
		[JsonPropertyName("params")]
		public Dictionary<string, object>? Params { get; set; }

		[JsonInclude]
		[JsonPropertyName("reduce_script")]
		public Elastic.Clients.Elasticsearch.Script? ReduceScript { get; set; }
	}

	public sealed partial class ScriptedMetricAggregationDescriptor : DescriptorBase<ScriptedMetricAggregationDescriptor>
	{
		public ScriptedMetricAggregationDescriptor()
		{
		}

		internal ScriptedMetricAggregationDescriptor(Action<ScriptedMetricAggregationDescriptor> configure) => configure.Invoke(this);
		internal Elastic.Clients.Elasticsearch.Script? CombineScriptValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Script? InitScriptValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Script? MapScriptValue { get; private set; }

		internal Dictionary<string, object>? ParamsValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Script? ReduceScriptValue { get; private set; }

		public ScriptedMetricAggregationDescriptor CombineScript(Elastic.Clients.Elasticsearch.Script? combineScript) => Assign(combineScript, (a, v) => a.CombineScriptValue = v);
		public ScriptedMetricAggregationDescriptor InitScript(Elastic.Clients.Elasticsearch.Script? initScript) => Assign(initScript, (a, v) => a.InitScriptValue = v);
		public ScriptedMetricAggregationDescriptor MapScript(Elastic.Clients.Elasticsearch.Script? mapScript) => Assign(mapScript, (a, v) => a.MapScriptValue = v);
		public ScriptedMetricAggregationDescriptor Params(Func<FluentDictionary<string?, object?>, FluentDictionary<string?, object?>> selector) => Assign(selector, (a, v) => a.ParamsValue = v?.Invoke(new FluentDictionary<string?, object?>()));
		public ScriptedMetricAggregationDescriptor ReduceScript(Elastic.Clients.Elasticsearch.Script? reduceScript) => Assign(reduceScript, (a, v) => a.ReduceScriptValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (CombineScriptValue is not null)
			{
				writer.WritePropertyName("combine_script");
				JsonSerializer.Serialize(writer, CombineScriptValue, options);
			}

			if (InitScriptValue is not null)
			{
				writer.WritePropertyName("init_script");
				JsonSerializer.Serialize(writer, InitScriptValue, options);
			}

			if (MapScriptValue is not null)
			{
				writer.WritePropertyName("map_script");
				JsonSerializer.Serialize(writer, MapScriptValue, options);
			}

			if (ParamsValue is not null)
			{
				writer.WritePropertyName("params");
				JsonSerializer.Serialize(writer, ParamsValue, options);
			}

			if (ReduceScriptValue is not null)
			{
				writer.WritePropertyName("reduce_script");
				JsonSerializer.Serialize(writer, ReduceScriptValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class SerialDifferencingAggregation : Aggregations.PipelineAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "serial_diff";
		[JsonInclude]
		[JsonPropertyName("lag")]
		public int? Lag { get; set; }
	}

	public sealed partial class SerialDifferencingAggregationDescriptor : DescriptorBase<SerialDifferencingAggregationDescriptor>
	{
		public SerialDifferencingAggregationDescriptor()
		{
		}

		internal SerialDifferencingAggregationDescriptor(Action<SerialDifferencingAggregationDescriptor> configure) => configure.Invoke(this);
		internal int? LagValue { get; private set; }

		public SerialDifferencingAggregationDescriptor Lag(int? lag) => Assign(lag, (a, v) => a.LagValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (LagValue.HasValue)
			{
				writer.WritePropertyName("lag");
				writer.WriteNumberValue(LagValue.Value);
			}

			writer.WriteEndObject();
		}
	}

	public partial class SignificantLongTermsAggregate : Aggregations.MultiBucketAggregateBase<Elastic.Clients.Elasticsearch.Aggregations.SignificantLongTermsBucket>
	{
	}

	public partial class SignificantLongTermsBucket : Aggregations.SignificantTermsBucketBase
	{
		[JsonInclude]
		[JsonPropertyName("key")]
		public long Key { get; init; }

		[JsonInclude]
		[JsonPropertyName("key_as_string")]
		public string? KeyAsString { get; init; }
	}

	public partial class SignificantStringTermsAggregate : Aggregations.MultiBucketAggregateBase<Elastic.Clients.Elasticsearch.Aggregations.SignificantStringTermsBucket>
	{
	}

	public partial class SignificantStringTermsBucket : Aggregations.SignificantTermsBucketBase
	{
		[JsonInclude]
		[JsonPropertyName("key")]
		public string Key { get; init; }
	}

	public partial class SignificantTermsAggregation : Aggregations.BucketAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "significant_terms";
		[JsonInclude]
		[JsonPropertyName("background_filter")]
		public Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? BackgroundFilter { get; set; }

		[JsonInclude]
		[JsonPropertyName("chi_square")]
		public Elastic.Clients.Elasticsearch.Aggregations.ChiSquareHeuristic? ChiSquare { get; set; }

		[JsonInclude]
		[JsonPropertyName("exclude")]
		public Elastic.Clients.Elasticsearch.Aggregations.TermsExclude? Exclude { get; set; }

		[JsonInclude]
		[JsonPropertyName("execution_hint")]
		public Elastic.Clients.Elasticsearch.Aggregations.TermsAggregationExecutionHint? ExecutionHint { get; set; }

		[JsonInclude]
		[JsonPropertyName("field")]
		public string? Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("gnd")]
		public Elastic.Clients.Elasticsearch.Aggregations.GoogleNormalizedDistanceHeuristic? Gnd { get; set; }

		[JsonInclude]
		[JsonPropertyName("include")]
		public string? Include { get; set; }

		[JsonInclude]
		[JsonPropertyName("min_doc_count")]
		public long? MinDocCount { get; set; }

		[JsonInclude]
		[JsonPropertyName("mutual_information")]
		public Elastic.Clients.Elasticsearch.Aggregations.MutualInformationHeuristic? MutualInformation { get; set; }

		[JsonInclude]
		[JsonPropertyName("percentage")]
		public Elastic.Clients.Elasticsearch.Aggregations.PercentageScoreHeuristic? Percentage { get; set; }

		[JsonInclude]
		[JsonPropertyName("script_heuristic")]
		public Elastic.Clients.Elasticsearch.Aggregations.ScriptedHeuristic? ScriptHeuristic { get; set; }

		[JsonInclude]
		[JsonPropertyName("shard_min_doc_count")]
		public long? ShardMinDocCount { get; set; }

		[JsonInclude]
		[JsonPropertyName("shard_size")]
		public int? ShardSize { get; set; }

		[JsonInclude]
		[JsonPropertyName("size")]
		public int? Size { get; set; }
	}

	public sealed partial class SignificantTermsAggregationDescriptor<T> : DescriptorBase<SignificantTermsAggregationDescriptor<T>>
	{
		public SignificantTermsAggregationDescriptor()
		{
		}

		internal SignificantTermsAggregationDescriptor(Action<SignificantTermsAggregationDescriptor<T>> configure) => configure.Invoke(this);
		internal Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? BackgroundFilterValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Aggregations.ChiSquareHeuristic? ChiSquareValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Aggregations.TermsExclude? ExcludeValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Aggregations.TermsAggregationExecutionHint? ExecutionHintValue { get; private set; }

		internal string? FieldValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Aggregations.GoogleNormalizedDistanceHeuristic? GndValue { get; private set; }

		internal string? IncludeValue { get; private set; }

		internal long? MinDocCountValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Aggregations.MutualInformationHeuristic? MutualInformationValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Aggregations.PercentageScoreHeuristic? PercentageValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Aggregations.ScriptedHeuristic? ScriptHeuristicValue { get; private set; }

		internal long? ShardMinDocCountValue { get; private set; }

		internal int? ShardSizeValue { get; private set; }

		internal int? SizeValue { get; private set; }

		internal QueryDsl.QueryContainerDescriptor<T> BackgroundFilterDescriptor { get; private set; }

		internal ChiSquareHeuristicDescriptor ChiSquareDescriptor { get; private set; }

		internal GoogleNormalizedDistanceHeuristicDescriptor GndDescriptor { get; private set; }

		internal MutualInformationHeuristicDescriptor MutualInformationDescriptor { get; private set; }

		internal PercentageScoreHeuristicDescriptor PercentageDescriptor { get; private set; }

		internal ScriptedHeuristicDescriptor ScriptHeuristicDescriptor { get; private set; }

		internal Action<QueryDsl.QueryContainerDescriptor<T>> BackgroundFilterDescriptorAction { get; private set; }

		internal Action<ChiSquareHeuristicDescriptor> ChiSquareDescriptorAction { get; private set; }

		internal Action<GoogleNormalizedDistanceHeuristicDescriptor> GndDescriptorAction { get; private set; }

		internal Action<MutualInformationHeuristicDescriptor> MutualInformationDescriptorAction { get; private set; }

		internal Action<PercentageScoreHeuristicDescriptor> PercentageDescriptorAction { get; private set; }

		internal Action<ScriptedHeuristicDescriptor> ScriptHeuristicDescriptorAction { get; private set; }

		public SignificantTermsAggregationDescriptor<T> BackgroundFilter(Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? backgroundFilter)
		{
			BackgroundFilterDescriptor = null;
			BackgroundFilterDescriptorAction = null;
			return Assign(backgroundFilter, (a, v) => a.BackgroundFilterValue = v);
		}

		public SignificantTermsAggregationDescriptor<T> BackgroundFilter(Elastic.Clients.Elasticsearch.QueryDsl.QueryContainerDescriptor<T> descriptor)
		{
			BackgroundFilterValue = null;
			BackgroundFilterDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.BackgroundFilterDescriptor = v);
		}

		public SignificantTermsAggregationDescriptor<T> BackgroundFilter(Action<Elastic.Clients.Elasticsearch.QueryDsl.QueryContainerDescriptor<T>> configure)
		{
			BackgroundFilterValue = null;
			BackgroundFilterDescriptorAction = null;
			return Assign(configure, (a, v) => a.BackgroundFilterDescriptorAction = v);
		}

		public SignificantTermsAggregationDescriptor<T> ChiSquare(Elastic.Clients.Elasticsearch.Aggregations.ChiSquareHeuristic? chiSquare)
		{
			ChiSquareDescriptor = null;
			ChiSquareDescriptorAction = null;
			return Assign(chiSquare, (a, v) => a.ChiSquareValue = v);
		}

		public SignificantTermsAggregationDescriptor<T> ChiSquare(Elastic.Clients.Elasticsearch.Aggregations.ChiSquareHeuristicDescriptor descriptor)
		{
			ChiSquareValue = null;
			ChiSquareDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.ChiSquareDescriptor = v);
		}

		public SignificantTermsAggregationDescriptor<T> ChiSquare(Action<Elastic.Clients.Elasticsearch.Aggregations.ChiSquareHeuristicDescriptor> configure)
		{
			ChiSquareValue = null;
			ChiSquareDescriptorAction = null;
			return Assign(configure, (a, v) => a.ChiSquareDescriptorAction = v);
		}

		public SignificantTermsAggregationDescriptor<T> Exclude(Elastic.Clients.Elasticsearch.Aggregations.TermsExclude? exclude) => Assign(exclude, (a, v) => a.ExcludeValue = v);
		public SignificantTermsAggregationDescriptor<T> ExecutionHint(Elastic.Clients.Elasticsearch.Aggregations.TermsAggregationExecutionHint? executionHint) => Assign(executionHint, (a, v) => a.ExecutionHintValue = v);
		public SignificantTermsAggregationDescriptor<T> Field(string? field) => Assign(field, (a, v) => a.FieldValue = v);
		public SignificantTermsAggregationDescriptor<T> Gnd(Elastic.Clients.Elasticsearch.Aggregations.GoogleNormalizedDistanceHeuristic? gnd)
		{
			GndDescriptor = null;
			GndDescriptorAction = null;
			return Assign(gnd, (a, v) => a.GndValue = v);
		}

		public SignificantTermsAggregationDescriptor<T> Gnd(Elastic.Clients.Elasticsearch.Aggregations.GoogleNormalizedDistanceHeuristicDescriptor descriptor)
		{
			GndValue = null;
			GndDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.GndDescriptor = v);
		}

		public SignificantTermsAggregationDescriptor<T> Gnd(Action<Elastic.Clients.Elasticsearch.Aggregations.GoogleNormalizedDistanceHeuristicDescriptor> configure)
		{
			GndValue = null;
			GndDescriptorAction = null;
			return Assign(configure, (a, v) => a.GndDescriptorAction = v);
		}

		public SignificantTermsAggregationDescriptor<T> Include(string? include) => Assign(include, (a, v) => a.IncludeValue = v);
		public SignificantTermsAggregationDescriptor<T> MinDocCount(long? minDocCount) => Assign(minDocCount, (a, v) => a.MinDocCountValue = v);
		public SignificantTermsAggregationDescriptor<T> MutualInformation(Elastic.Clients.Elasticsearch.Aggregations.MutualInformationHeuristic? mutualInformation)
		{
			MutualInformationDescriptor = null;
			MutualInformationDescriptorAction = null;
			return Assign(mutualInformation, (a, v) => a.MutualInformationValue = v);
		}

		public SignificantTermsAggregationDescriptor<T> MutualInformation(Elastic.Clients.Elasticsearch.Aggregations.MutualInformationHeuristicDescriptor descriptor)
		{
			MutualInformationValue = null;
			MutualInformationDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.MutualInformationDescriptor = v);
		}

		public SignificantTermsAggregationDescriptor<T> MutualInformation(Action<Elastic.Clients.Elasticsearch.Aggregations.MutualInformationHeuristicDescriptor> configure)
		{
			MutualInformationValue = null;
			MutualInformationDescriptorAction = null;
			return Assign(configure, (a, v) => a.MutualInformationDescriptorAction = v);
		}

		public SignificantTermsAggregationDescriptor<T> Percentage(Elastic.Clients.Elasticsearch.Aggregations.PercentageScoreHeuristic? percentage)
		{
			PercentageDescriptor = null;
			PercentageDescriptorAction = null;
			return Assign(percentage, (a, v) => a.PercentageValue = v);
		}

		public SignificantTermsAggregationDescriptor<T> Percentage(Elastic.Clients.Elasticsearch.Aggregations.PercentageScoreHeuristicDescriptor descriptor)
		{
			PercentageValue = null;
			PercentageDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.PercentageDescriptor = v);
		}

		public SignificantTermsAggregationDescriptor<T> Percentage(Action<Elastic.Clients.Elasticsearch.Aggregations.PercentageScoreHeuristicDescriptor> configure)
		{
			PercentageValue = null;
			PercentageDescriptorAction = null;
			return Assign(configure, (a, v) => a.PercentageDescriptorAction = v);
		}

		public SignificantTermsAggregationDescriptor<T> ScriptHeuristic(Elastic.Clients.Elasticsearch.Aggregations.ScriptedHeuristic? scriptHeuristic)
		{
			ScriptHeuristicDescriptor = null;
			ScriptHeuristicDescriptorAction = null;
			return Assign(scriptHeuristic, (a, v) => a.ScriptHeuristicValue = v);
		}

		public SignificantTermsAggregationDescriptor<T> ScriptHeuristic(Elastic.Clients.Elasticsearch.Aggregations.ScriptedHeuristicDescriptor descriptor)
		{
			ScriptHeuristicValue = null;
			ScriptHeuristicDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.ScriptHeuristicDescriptor = v);
		}

		public SignificantTermsAggregationDescriptor<T> ScriptHeuristic(Action<Elastic.Clients.Elasticsearch.Aggregations.ScriptedHeuristicDescriptor> configure)
		{
			ScriptHeuristicValue = null;
			ScriptHeuristicDescriptorAction = null;
			return Assign(configure, (a, v) => a.ScriptHeuristicDescriptorAction = v);
		}

		public SignificantTermsAggregationDescriptor<T> ShardMinDocCount(long? shardMinDocCount) => Assign(shardMinDocCount, (a, v) => a.ShardMinDocCountValue = v);
		public SignificantTermsAggregationDescriptor<T> ShardSize(int? shardSize) => Assign(shardSize, (a, v) => a.ShardSizeValue = v);
		public SignificantTermsAggregationDescriptor<T> Size(int? size) => Assign(size, (a, v) => a.SizeValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (BackgroundFilterDescriptor is not null)
			{
				writer.WritePropertyName("background_filter");
				JsonSerializer.Serialize(writer, BackgroundFilterDescriptor, options);
			}
			else if (BackgroundFilterDescriptorAction is not null)
			{
				writer.WritePropertyName("background_filter");
				JsonSerializer.Serialize(writer, new QueryDsl.QueryContainerDescriptor<T>(BackgroundFilterDescriptorAction), options);
			}
			else if (BackgroundFilterValue is not null)
			{
				writer.WritePropertyName("background_filter");
				JsonSerializer.Serialize(writer, BackgroundFilterValue, options);
			}

			if (ChiSquareDescriptor is not null)
			{
				writer.WritePropertyName("chi_square");
				JsonSerializer.Serialize(writer, ChiSquareDescriptor, options);
			}
			else if (ChiSquareDescriptorAction is not null)
			{
				writer.WritePropertyName("chi_square");
				JsonSerializer.Serialize(writer, new ChiSquareHeuristicDescriptor(ChiSquareDescriptorAction), options);
			}
			else if (ChiSquareValue is not null)
			{
				writer.WritePropertyName("chi_square");
				JsonSerializer.Serialize(writer, ChiSquareValue, options);
			}

			if (ExcludeValue is not null)
			{
				writer.WritePropertyName("exclude");
				JsonSerializer.Serialize(writer, ExcludeValue, options);
			}

			if (ExecutionHintValue is not null)
			{
				writer.WritePropertyName("execution_hint");
				JsonSerializer.Serialize(writer, ExecutionHintValue, options);
			}

			if (FieldValue is not null)
			{
				writer.WritePropertyName("field");
				JsonSerializer.Serialize(writer, FieldValue, options);
			}

			if (GndDescriptor is not null)
			{
				writer.WritePropertyName("gnd");
				JsonSerializer.Serialize(writer, GndDescriptor, options);
			}
			else if (GndDescriptorAction is not null)
			{
				writer.WritePropertyName("gnd");
				JsonSerializer.Serialize(writer, new GoogleNormalizedDistanceHeuristicDescriptor(GndDescriptorAction), options);
			}
			else if (GndValue is not null)
			{
				writer.WritePropertyName("gnd");
				JsonSerializer.Serialize(writer, GndValue, options);
			}

			if (!string.IsNullOrEmpty(IncludeValue))
			{
				writer.WritePropertyName("include");
				writer.WriteStringValue(IncludeValue);
			}

			if (MinDocCountValue.HasValue)
			{
				writer.WritePropertyName("min_doc_count");
				writer.WriteNumberValue(MinDocCountValue.Value);
			}

			if (MutualInformationDescriptor is not null)
			{
				writer.WritePropertyName("mutual_information");
				JsonSerializer.Serialize(writer, MutualInformationDescriptor, options);
			}
			else if (MutualInformationDescriptorAction is not null)
			{
				writer.WritePropertyName("mutual_information");
				JsonSerializer.Serialize(writer, new MutualInformationHeuristicDescriptor(MutualInformationDescriptorAction), options);
			}
			else if (MutualInformationValue is not null)
			{
				writer.WritePropertyName("mutual_information");
				JsonSerializer.Serialize(writer, MutualInformationValue, options);
			}

			if (PercentageDescriptor is not null)
			{
				writer.WritePropertyName("percentage");
				JsonSerializer.Serialize(writer, PercentageDescriptor, options);
			}
			else if (PercentageDescriptorAction is not null)
			{
				writer.WritePropertyName("percentage");
				JsonSerializer.Serialize(writer, new PercentageScoreHeuristicDescriptor(PercentageDescriptorAction), options);
			}
			else if (PercentageValue is not null)
			{
				writer.WritePropertyName("percentage");
				JsonSerializer.Serialize(writer, PercentageValue, options);
			}

			if (ScriptHeuristicDescriptor is not null)
			{
				writer.WritePropertyName("script_heuristic");
				JsonSerializer.Serialize(writer, ScriptHeuristicDescriptor, options);
			}
			else if (ScriptHeuristicDescriptorAction is not null)
			{
				writer.WritePropertyName("script_heuristic");
				JsonSerializer.Serialize(writer, new ScriptedHeuristicDescriptor(ScriptHeuristicDescriptorAction), options);
			}
			else if (ScriptHeuristicValue is not null)
			{
				writer.WritePropertyName("script_heuristic");
				JsonSerializer.Serialize(writer, ScriptHeuristicValue, options);
			}

			if (ShardMinDocCountValue.HasValue)
			{
				writer.WritePropertyName("shard_min_doc_count");
				writer.WriteNumberValue(ShardMinDocCountValue.Value);
			}

			if (ShardSizeValue.HasValue)
			{
				writer.WritePropertyName("shard_size");
				writer.WriteNumberValue(ShardSizeValue.Value);
			}

			if (SizeValue.HasValue)
			{
				writer.WritePropertyName("size");
				writer.WriteNumberValue(SizeValue.Value);
			}

			writer.WriteEndObject();
		}
	}

	public abstract partial class SignificantTermsBucketBase : Aggregations.MultiBucketBase
	{
		[JsonInclude]
		[JsonPropertyName("score")]
		public double Score { get; init; }

		[JsonInclude]
		[JsonPropertyName("bg_count")]
		public long BgCount { get; init; }
	}

	public partial class SignificantTextAggregation : Aggregations.BucketAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "significant_text";
		[JsonInclude]
		[JsonPropertyName("background_filter")]
		public Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? BackgroundFilter { get; set; }

		[JsonInclude]
		[JsonPropertyName("chi_square")]
		public Elastic.Clients.Elasticsearch.Aggregations.ChiSquareHeuristic? ChiSquare { get; set; }

		[JsonInclude]
		[JsonPropertyName("exclude")]
		public Elastic.Clients.Elasticsearch.Aggregations.TermsExclude? Exclude { get; set; }

		[JsonInclude]
		[JsonPropertyName("execution_hint")]
		public Elastic.Clients.Elasticsearch.Aggregations.TermsAggregationExecutionHint? ExecutionHint { get; set; }

		[JsonInclude]
		[JsonPropertyName("field")]
		public string? Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("filter_duplicate_text")]
		public bool? FilterDuplicateText { get; set; }

		[JsonInclude]
		[JsonPropertyName("gnd")]
		public Elastic.Clients.Elasticsearch.Aggregations.GoogleNormalizedDistanceHeuristic? Gnd { get; set; }

		[JsonInclude]
		[JsonPropertyName("include")]
		public string? Include { get; set; }

		[JsonInclude]
		[JsonPropertyName("min_doc_count")]
		public long? MinDocCount { get; set; }

		[JsonInclude]
		[JsonPropertyName("mutual_information")]
		public Elastic.Clients.Elasticsearch.Aggregations.MutualInformationHeuristic? MutualInformation { get; set; }

		[JsonInclude]
		[JsonPropertyName("percentage")]
		public Elastic.Clients.Elasticsearch.Aggregations.PercentageScoreHeuristic? Percentage { get; set; }

		[JsonInclude]
		[JsonPropertyName("script_heuristic")]
		public Elastic.Clients.Elasticsearch.Aggregations.ScriptedHeuristic? ScriptHeuristic { get; set; }

		[JsonInclude]
		[JsonPropertyName("shard_min_doc_count")]
		public long? ShardMinDocCount { get; set; }

		[JsonInclude]
		[JsonPropertyName("shard_size")]
		public int? ShardSize { get; set; }

		[JsonInclude]
		[JsonPropertyName("size")]
		public int? Size { get; set; }

		[JsonInclude]
		[JsonPropertyName("source_fields")]
		public Elastic.Clients.Elasticsearch.Fields? SourceFields { get; set; }
	}

	public sealed partial class SignificantTextAggregationDescriptor<T> : DescriptorBase<SignificantTextAggregationDescriptor<T>>
	{
		public SignificantTextAggregationDescriptor()
		{
		}

		internal SignificantTextAggregationDescriptor(Action<SignificantTextAggregationDescriptor<T>> configure) => configure.Invoke(this);
		internal Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? BackgroundFilterValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Aggregations.ChiSquareHeuristic? ChiSquareValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Aggregations.TermsExclude? ExcludeValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Aggregations.TermsAggregationExecutionHint? ExecutionHintValue { get; private set; }

		internal string? FieldValue { get; private set; }

		internal bool? FilterDuplicateTextValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Aggregations.GoogleNormalizedDistanceHeuristic? GndValue { get; private set; }

		internal string? IncludeValue { get; private set; }

		internal long? MinDocCountValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Aggregations.MutualInformationHeuristic? MutualInformationValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Aggregations.PercentageScoreHeuristic? PercentageValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Aggregations.ScriptedHeuristic? ScriptHeuristicValue { get; private set; }

		internal long? ShardMinDocCountValue { get; private set; }

		internal int? ShardSizeValue { get; private set; }

		internal int? SizeValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Fields? SourceFieldsValue { get; private set; }

		internal QueryDsl.QueryContainerDescriptor<T> BackgroundFilterDescriptor { get; private set; }

		internal ChiSquareHeuristicDescriptor ChiSquareDescriptor { get; private set; }

		internal GoogleNormalizedDistanceHeuristicDescriptor GndDescriptor { get; private set; }

		internal MutualInformationHeuristicDescriptor MutualInformationDescriptor { get; private set; }

		internal PercentageScoreHeuristicDescriptor PercentageDescriptor { get; private set; }

		internal ScriptedHeuristicDescriptor ScriptHeuristicDescriptor { get; private set; }

		internal Action<QueryDsl.QueryContainerDescriptor<T>> BackgroundFilterDescriptorAction { get; private set; }

		internal Action<ChiSquareHeuristicDescriptor> ChiSquareDescriptorAction { get; private set; }

		internal Action<GoogleNormalizedDistanceHeuristicDescriptor> GndDescriptorAction { get; private set; }

		internal Action<MutualInformationHeuristicDescriptor> MutualInformationDescriptorAction { get; private set; }

		internal Action<PercentageScoreHeuristicDescriptor> PercentageDescriptorAction { get; private set; }

		internal Action<ScriptedHeuristicDescriptor> ScriptHeuristicDescriptorAction { get; private set; }

		public SignificantTextAggregationDescriptor<T> BackgroundFilter(Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? backgroundFilter)
		{
			BackgroundFilterDescriptor = null;
			BackgroundFilterDescriptorAction = null;
			return Assign(backgroundFilter, (a, v) => a.BackgroundFilterValue = v);
		}

		public SignificantTextAggregationDescriptor<T> BackgroundFilter(Elastic.Clients.Elasticsearch.QueryDsl.QueryContainerDescriptor<T> descriptor)
		{
			BackgroundFilterValue = null;
			BackgroundFilterDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.BackgroundFilterDescriptor = v);
		}

		public SignificantTextAggregationDescriptor<T> BackgroundFilter(Action<Elastic.Clients.Elasticsearch.QueryDsl.QueryContainerDescriptor<T>> configure)
		{
			BackgroundFilterValue = null;
			BackgroundFilterDescriptorAction = null;
			return Assign(configure, (a, v) => a.BackgroundFilterDescriptorAction = v);
		}

		public SignificantTextAggregationDescriptor<T> ChiSquare(Elastic.Clients.Elasticsearch.Aggregations.ChiSquareHeuristic? chiSquare)
		{
			ChiSquareDescriptor = null;
			ChiSquareDescriptorAction = null;
			return Assign(chiSquare, (a, v) => a.ChiSquareValue = v);
		}

		public SignificantTextAggregationDescriptor<T> ChiSquare(Elastic.Clients.Elasticsearch.Aggregations.ChiSquareHeuristicDescriptor descriptor)
		{
			ChiSquareValue = null;
			ChiSquareDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.ChiSquareDescriptor = v);
		}

		public SignificantTextAggregationDescriptor<T> ChiSquare(Action<Elastic.Clients.Elasticsearch.Aggregations.ChiSquareHeuristicDescriptor> configure)
		{
			ChiSquareValue = null;
			ChiSquareDescriptorAction = null;
			return Assign(configure, (a, v) => a.ChiSquareDescriptorAction = v);
		}

		public SignificantTextAggregationDescriptor<T> Exclude(Elastic.Clients.Elasticsearch.Aggregations.TermsExclude? exclude) => Assign(exclude, (a, v) => a.ExcludeValue = v);
		public SignificantTextAggregationDescriptor<T> ExecutionHint(Elastic.Clients.Elasticsearch.Aggregations.TermsAggregationExecutionHint? executionHint) => Assign(executionHint, (a, v) => a.ExecutionHintValue = v);
		public SignificantTextAggregationDescriptor<T> Field(string? field) => Assign(field, (a, v) => a.FieldValue = v);
		public SignificantTextAggregationDescriptor<T> FilterDuplicateText(bool? filterDuplicateText = true) => Assign(filterDuplicateText, (a, v) => a.FilterDuplicateTextValue = v);
		public SignificantTextAggregationDescriptor<T> Gnd(Elastic.Clients.Elasticsearch.Aggregations.GoogleNormalizedDistanceHeuristic? gnd)
		{
			GndDescriptor = null;
			GndDescriptorAction = null;
			return Assign(gnd, (a, v) => a.GndValue = v);
		}

		public SignificantTextAggregationDescriptor<T> Gnd(Elastic.Clients.Elasticsearch.Aggregations.GoogleNormalizedDistanceHeuristicDescriptor descriptor)
		{
			GndValue = null;
			GndDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.GndDescriptor = v);
		}

		public SignificantTextAggregationDescriptor<T> Gnd(Action<Elastic.Clients.Elasticsearch.Aggregations.GoogleNormalizedDistanceHeuristicDescriptor> configure)
		{
			GndValue = null;
			GndDescriptorAction = null;
			return Assign(configure, (a, v) => a.GndDescriptorAction = v);
		}

		public SignificantTextAggregationDescriptor<T> Include(string? include) => Assign(include, (a, v) => a.IncludeValue = v);
		public SignificantTextAggregationDescriptor<T> MinDocCount(long? minDocCount) => Assign(minDocCount, (a, v) => a.MinDocCountValue = v);
		public SignificantTextAggregationDescriptor<T> MutualInformation(Elastic.Clients.Elasticsearch.Aggregations.MutualInformationHeuristic? mutualInformation)
		{
			MutualInformationDescriptor = null;
			MutualInformationDescriptorAction = null;
			return Assign(mutualInformation, (a, v) => a.MutualInformationValue = v);
		}

		public SignificantTextAggregationDescriptor<T> MutualInformation(Elastic.Clients.Elasticsearch.Aggregations.MutualInformationHeuristicDescriptor descriptor)
		{
			MutualInformationValue = null;
			MutualInformationDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.MutualInformationDescriptor = v);
		}

		public SignificantTextAggregationDescriptor<T> MutualInformation(Action<Elastic.Clients.Elasticsearch.Aggregations.MutualInformationHeuristicDescriptor> configure)
		{
			MutualInformationValue = null;
			MutualInformationDescriptorAction = null;
			return Assign(configure, (a, v) => a.MutualInformationDescriptorAction = v);
		}

		public SignificantTextAggregationDescriptor<T> Percentage(Elastic.Clients.Elasticsearch.Aggregations.PercentageScoreHeuristic? percentage)
		{
			PercentageDescriptor = null;
			PercentageDescriptorAction = null;
			return Assign(percentage, (a, v) => a.PercentageValue = v);
		}

		public SignificantTextAggregationDescriptor<T> Percentage(Elastic.Clients.Elasticsearch.Aggregations.PercentageScoreHeuristicDescriptor descriptor)
		{
			PercentageValue = null;
			PercentageDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.PercentageDescriptor = v);
		}

		public SignificantTextAggregationDescriptor<T> Percentage(Action<Elastic.Clients.Elasticsearch.Aggregations.PercentageScoreHeuristicDescriptor> configure)
		{
			PercentageValue = null;
			PercentageDescriptorAction = null;
			return Assign(configure, (a, v) => a.PercentageDescriptorAction = v);
		}

		public SignificantTextAggregationDescriptor<T> ScriptHeuristic(Elastic.Clients.Elasticsearch.Aggregations.ScriptedHeuristic? scriptHeuristic)
		{
			ScriptHeuristicDescriptor = null;
			ScriptHeuristicDescriptorAction = null;
			return Assign(scriptHeuristic, (a, v) => a.ScriptHeuristicValue = v);
		}

		public SignificantTextAggregationDescriptor<T> ScriptHeuristic(Elastic.Clients.Elasticsearch.Aggregations.ScriptedHeuristicDescriptor descriptor)
		{
			ScriptHeuristicValue = null;
			ScriptHeuristicDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.ScriptHeuristicDescriptor = v);
		}

		public SignificantTextAggregationDescriptor<T> ScriptHeuristic(Action<Elastic.Clients.Elasticsearch.Aggregations.ScriptedHeuristicDescriptor> configure)
		{
			ScriptHeuristicValue = null;
			ScriptHeuristicDescriptorAction = null;
			return Assign(configure, (a, v) => a.ScriptHeuristicDescriptorAction = v);
		}

		public SignificantTextAggregationDescriptor<T> ShardMinDocCount(long? shardMinDocCount) => Assign(shardMinDocCount, (a, v) => a.ShardMinDocCountValue = v);
		public SignificantTextAggregationDescriptor<T> ShardSize(int? shardSize) => Assign(shardSize, (a, v) => a.ShardSizeValue = v);
		public SignificantTextAggregationDescriptor<T> Size(int? size) => Assign(size, (a, v) => a.SizeValue = v);
		public SignificantTextAggregationDescriptor<T> SourceFields(Elastic.Clients.Elasticsearch.Fields? sourceFields) => Assign(sourceFields, (a, v) => a.SourceFieldsValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (BackgroundFilterDescriptor is not null)
			{
				writer.WritePropertyName("background_filter");
				JsonSerializer.Serialize(writer, BackgroundFilterDescriptor, options);
			}
			else if (BackgroundFilterDescriptorAction is not null)
			{
				writer.WritePropertyName("background_filter");
				JsonSerializer.Serialize(writer, new QueryDsl.QueryContainerDescriptor<T>(BackgroundFilterDescriptorAction), options);
			}
			else if (BackgroundFilterValue is not null)
			{
				writer.WritePropertyName("background_filter");
				JsonSerializer.Serialize(writer, BackgroundFilterValue, options);
			}

			if (ChiSquareDescriptor is not null)
			{
				writer.WritePropertyName("chi_square");
				JsonSerializer.Serialize(writer, ChiSquareDescriptor, options);
			}
			else if (ChiSquareDescriptorAction is not null)
			{
				writer.WritePropertyName("chi_square");
				JsonSerializer.Serialize(writer, new ChiSquareHeuristicDescriptor(ChiSquareDescriptorAction), options);
			}
			else if (ChiSquareValue is not null)
			{
				writer.WritePropertyName("chi_square");
				JsonSerializer.Serialize(writer, ChiSquareValue, options);
			}

			if (ExcludeValue is not null)
			{
				writer.WritePropertyName("exclude");
				JsonSerializer.Serialize(writer, ExcludeValue, options);
			}

			if (ExecutionHintValue is not null)
			{
				writer.WritePropertyName("execution_hint");
				JsonSerializer.Serialize(writer, ExecutionHintValue, options);
			}

			if (FieldValue is not null)
			{
				writer.WritePropertyName("field");
				JsonSerializer.Serialize(writer, FieldValue, options);
			}

			if (FilterDuplicateTextValue.HasValue)
			{
				writer.WritePropertyName("filter_duplicate_text");
				writer.WriteBooleanValue(FilterDuplicateTextValue.Value);
			}

			if (GndDescriptor is not null)
			{
				writer.WritePropertyName("gnd");
				JsonSerializer.Serialize(writer, GndDescriptor, options);
			}
			else if (GndDescriptorAction is not null)
			{
				writer.WritePropertyName("gnd");
				JsonSerializer.Serialize(writer, new GoogleNormalizedDistanceHeuristicDescriptor(GndDescriptorAction), options);
			}
			else if (GndValue is not null)
			{
				writer.WritePropertyName("gnd");
				JsonSerializer.Serialize(writer, GndValue, options);
			}

			if (!string.IsNullOrEmpty(IncludeValue))
			{
				writer.WritePropertyName("include");
				writer.WriteStringValue(IncludeValue);
			}

			if (MinDocCountValue.HasValue)
			{
				writer.WritePropertyName("min_doc_count");
				writer.WriteNumberValue(MinDocCountValue.Value);
			}

			if (MutualInformationDescriptor is not null)
			{
				writer.WritePropertyName("mutual_information");
				JsonSerializer.Serialize(writer, MutualInformationDescriptor, options);
			}
			else if (MutualInformationDescriptorAction is not null)
			{
				writer.WritePropertyName("mutual_information");
				JsonSerializer.Serialize(writer, new MutualInformationHeuristicDescriptor(MutualInformationDescriptorAction), options);
			}
			else if (MutualInformationValue is not null)
			{
				writer.WritePropertyName("mutual_information");
				JsonSerializer.Serialize(writer, MutualInformationValue, options);
			}

			if (PercentageDescriptor is not null)
			{
				writer.WritePropertyName("percentage");
				JsonSerializer.Serialize(writer, PercentageDescriptor, options);
			}
			else if (PercentageDescriptorAction is not null)
			{
				writer.WritePropertyName("percentage");
				JsonSerializer.Serialize(writer, new PercentageScoreHeuristicDescriptor(PercentageDescriptorAction), options);
			}
			else if (PercentageValue is not null)
			{
				writer.WritePropertyName("percentage");
				JsonSerializer.Serialize(writer, PercentageValue, options);
			}

			if (ScriptHeuristicDescriptor is not null)
			{
				writer.WritePropertyName("script_heuristic");
				JsonSerializer.Serialize(writer, ScriptHeuristicDescriptor, options);
			}
			else if (ScriptHeuristicDescriptorAction is not null)
			{
				writer.WritePropertyName("script_heuristic");
				JsonSerializer.Serialize(writer, new ScriptedHeuristicDescriptor(ScriptHeuristicDescriptorAction), options);
			}
			else if (ScriptHeuristicValue is not null)
			{
				writer.WritePropertyName("script_heuristic");
				JsonSerializer.Serialize(writer, ScriptHeuristicValue, options);
			}

			if (ShardMinDocCountValue.HasValue)
			{
				writer.WritePropertyName("shard_min_doc_count");
				writer.WriteNumberValue(ShardMinDocCountValue.Value);
			}

			if (ShardSizeValue.HasValue)
			{
				writer.WritePropertyName("shard_size");
				writer.WriteNumberValue(ShardSizeValue.Value);
			}

			if (SizeValue.HasValue)
			{
				writer.WritePropertyName("size");
				writer.WriteNumberValue(SizeValue.Value);
			}

			if (SourceFieldsValue is not null)
			{
				writer.WritePropertyName("source_fields");
				JsonSerializer.Serialize(writer, SourceFieldsValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class SimpleValueAggregate : Aggregations.SingleMetricAggregateBase
	{
	}

	public abstract partial class SingleBucketAggregateBase : Aggregations.AggregateBase
	{
		[JsonInclude]
		[JsonPropertyName("doc_count")]
		public long DocCount { get; init; }
	}

	public abstract partial class SingleMetricAggregateBase : Aggregations.AggregateBase
	{
		[JsonInclude]
		[JsonPropertyName("value")]
		public object Value { get; init; }

		[JsonInclude]
		[JsonPropertyName("value_as_string")]
		public string? ValueAsString { get; init; }
	}

	public partial class StandardDeviationBounds
	{
		[JsonInclude]
		[JsonPropertyName("upper")]
		public object Upper { get; init; }

		[JsonInclude]
		[JsonPropertyName("lower")]
		public object Lower { get; init; }

		[JsonInclude]
		[JsonPropertyName("upper_population")]
		public object UpperPopulation { get; init; }

		[JsonInclude]
		[JsonPropertyName("lower_population")]
		public object LowerPopulation { get; init; }

		[JsonInclude]
		[JsonPropertyName("upper_sampling")]
		public object UpperSampling { get; init; }

		[JsonInclude]
		[JsonPropertyName("lower_sampling")]
		public object LowerSampling { get; init; }
	}

	public partial class StandardDeviationBoundsAsString
	{
		[JsonInclude]
		[JsonPropertyName("upper")]
		public string Upper { get; init; }

		[JsonInclude]
		[JsonPropertyName("lower")]
		public string Lower { get; init; }

		[JsonInclude]
		[JsonPropertyName("upper_population")]
		public string UpperPopulation { get; init; }

		[JsonInclude]
		[JsonPropertyName("lower_population")]
		public string LowerPopulation { get; init; }

		[JsonInclude]
		[JsonPropertyName("upper_sampling")]
		public string UpperSampling { get; init; }

		[JsonInclude]
		[JsonPropertyName("lower_sampling")]
		public string LowerSampling { get; init; }
	}

	public partial class StatsAggregate : Aggregations.AggregateBase
	{
		[JsonInclude]
		[JsonPropertyName("count")]
		public long Count { get; init; }

		[JsonInclude]
		[JsonPropertyName("min")]
		public object Min { get; init; }

		[JsonInclude]
		[JsonPropertyName("max")]
		public object Max { get; init; }

		[JsonInclude]
		[JsonPropertyName("avg")]
		public object Avg { get; init; }

		[JsonInclude]
		[JsonPropertyName("sum")]
		public double Sum { get; init; }

		[JsonInclude]
		[JsonPropertyName("min_as_string")]
		public string? MinAsString { get; init; }

		[JsonInclude]
		[JsonPropertyName("max_as_string")]
		public string? MaxAsString { get; init; }

		[JsonInclude]
		[JsonPropertyName("avg_as_string")]
		public string? AvgAsString { get; init; }

		[JsonInclude]
		[JsonPropertyName("sum_as_string")]
		public string? SumAsString { get; init; }
	}

	public partial class StatsAggregation : Aggregations.FormatMetricAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "stats";
	}

	public sealed partial class StatsAggregationDescriptor : DescriptorBase<StatsAggregationDescriptor>
	{
		public StatsAggregationDescriptor()
		{
		}

		internal StatsAggregationDescriptor(Action<StatsAggregationDescriptor> configure) => configure.Invoke(this);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WriteEndObject();
		}
	}

	public partial class StatsBucketAggregate : Aggregations.StatsAggregate
	{
	}

	public partial class StatsBucketAggregation : Aggregations.PipelineAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "stats_bucket";
	}

	public sealed partial class StatsBucketAggregationDescriptor : DescriptorBase<StatsBucketAggregationDescriptor>
	{
		public StatsBucketAggregationDescriptor()
		{
		}

		internal StatsBucketAggregationDescriptor(Action<StatsBucketAggregationDescriptor> configure) => configure.Invoke(this);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WriteEndObject();
		}
	}

	public partial class StringRareTermsAggregate : Aggregations.MultiBucketAggregateBase<Elastic.Clients.Elasticsearch.Aggregations.StringRareTermsBucket>
	{
	}

	public partial class StringRareTermsBucket : Aggregations.MultiBucketBase
	{
		[JsonInclude]
		[JsonPropertyName("key")]
		public string Key { get; init; }
	}

	public partial class StringStatsAggregate : Aggregations.AggregateBase
	{
		[JsonInclude]
		[JsonPropertyName("count")]
		public long Count { get; init; }

		[JsonInclude]
		[JsonPropertyName("min_length")]
		public object MinLength { get; init; }

		[JsonInclude]
		[JsonPropertyName("max_length")]
		public object MaxLength { get; init; }

		[JsonInclude]
		[JsonPropertyName("avg_length")]
		public object AvgLength { get; init; }

		[JsonInclude]
		[JsonPropertyName("entropy")]
		public object Entropy { get; init; }

		[JsonInclude]
		[JsonPropertyName("distribution")]
		public object? Distribution { get; init; }

		[JsonInclude]
		[JsonPropertyName("min_length_as_string")]
		public string? MinLengthAsString { get; init; }

		[JsonInclude]
		[JsonPropertyName("max_length_as_string")]
		public string? MaxLengthAsString { get; init; }

		[JsonInclude]
		[JsonPropertyName("avg_length_as_string")]
		public string? AvgLengthAsString { get; init; }
	}

	public partial class StringStatsAggregation : Aggregations.MetricAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "string_stats";
		[JsonInclude]
		[JsonPropertyName("show_distribution")]
		public bool? ShowDistribution { get; set; }
	}

	public sealed partial class StringStatsAggregationDescriptor : DescriptorBase<StringStatsAggregationDescriptor>
	{
		public StringStatsAggregationDescriptor()
		{
		}

		internal StringStatsAggregationDescriptor(Action<StringStatsAggregationDescriptor> configure) => configure.Invoke(this);
		internal bool? ShowDistributionValue { get; private set; }

		public StringStatsAggregationDescriptor ShowDistribution(bool? showDistribution = true) => Assign(showDistribution, (a, v) => a.ShowDistributionValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (ShowDistributionValue.HasValue)
			{
				writer.WritePropertyName("show_distribution");
				writer.WriteBooleanValue(ShowDistributionValue.Value);
			}

			writer.WriteEndObject();
		}
	}

	public partial class StringTermsAggregate : Aggregations.TermsAggregateBase<Elastic.Clients.Elasticsearch.Aggregations.StringTermsBucket>
	{
	}

	public partial class StringTermsBucket : Aggregations.TermsBucketBase
	{
		[JsonInclude]
		[JsonPropertyName("key")]
		public string Key { get; init; }
	}

	public partial class SumAggregate : Aggregations.SingleMetricAggregateBase
	{
	}

	public partial class SumAggregation : Aggregations.FormatMetricAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "sum";
	}

	public sealed partial class SumAggregationDescriptor : DescriptorBase<SumAggregationDescriptor>
	{
		public SumAggregationDescriptor()
		{
		}

		internal SumAggregationDescriptor(Action<SumAggregationDescriptor> configure) => configure.Invoke(this);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WriteEndObject();
		}
	}

	public partial class SumBucketAggregation : Aggregations.PipelineAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "sum_bucket";
	}

	public sealed partial class SumBucketAggregationDescriptor : DescriptorBase<SumBucketAggregationDescriptor>
	{
		public SumBucketAggregationDescriptor()
		{
		}

		internal SumBucketAggregationDescriptor(Action<SumBucketAggregationDescriptor> configure) => configure.Invoke(this);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WriteEndObject();
		}
	}

	public partial class TDigest
	{
		[JsonInclude]
		[JsonPropertyName("compression")]
		public int? Compression { get; set; }
	}

	public sealed partial class TDigestDescriptor : DescriptorBase<TDigestDescriptor>
	{
		public TDigestDescriptor()
		{
		}

		internal TDigestDescriptor(Action<TDigestDescriptor> configure) => configure.Invoke(this);
		internal int? CompressionValue { get; private set; }

		public TDigestDescriptor Compression(int? compression) => Assign(compression, (a, v) => a.CompressionValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (CompressionValue.HasValue)
			{
				writer.WritePropertyName("compression");
				writer.WriteNumberValue(CompressionValue.Value);
			}

			writer.WriteEndObject();
		}
	}

	public partial class TDigestPercentileRanksAggregate : Aggregations.PercentilesAggregateBase
	{
	}

	public partial class TDigestPercentilesAggregate : Aggregations.PercentilesAggregateBase
	{
	}

	public abstract partial class TermsAggregateBase<TBucket> : Aggregations.MultiBucketAggregateBase<TBucket>
	{
		[JsonInclude]
		[JsonPropertyName("doc_count_error_upper_bound")]
		public long? DocCountErrorUpperBound { get; init; }

		[JsonInclude]
		[JsonPropertyName("sum_other_doc_count")]
		public long SumOtherDocCount { get; init; }
	}

	public partial class TermsAggregation : Aggregations.BucketAggregationBase, IAggregationContainerVariant, TransformManagement.IPivotGroupByContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "terms";
		[JsonIgnore]
		string TransformManagement.IPivotGroupByContainerVariant.PivotGroupByContainerVariantName => "terms";
		[JsonInclude]
		[JsonPropertyName("collect_mode")]
		public Elastic.Clients.Elasticsearch.Aggregations.TermsAggregationCollectMode? CollectMode { get; set; }

		[JsonInclude]
		[JsonPropertyName("exclude")]
		public Elastic.Clients.Elasticsearch.Aggregations.TermsExclude? Exclude { get; set; }

		[JsonInclude]
		[JsonPropertyName("execution_hint")]
		public Elastic.Clients.Elasticsearch.Aggregations.TermsAggregationExecutionHint? ExecutionHint { get; set; }

		[JsonInclude]
		[JsonPropertyName("field")]
		public string? Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("include")]
		public Elastic.Clients.Elasticsearch.Aggregations.TermsInclude? Include { get; set; }

		[JsonInclude]
		[JsonPropertyName("min_doc_count")]
		public int? MinDocCount { get; set; }

		[JsonInclude]
		[JsonPropertyName("missing")]
		public Elastic.Clients.Elasticsearch.Aggregations.Missing? Missing { get; set; }

		[JsonInclude]
		[JsonPropertyName("missing_order")]
		public Elastic.Clients.Elasticsearch.Aggregations.MissingOrder? MissingOrder { get; set; }

		[JsonInclude]
		[JsonPropertyName("missing_bucket")]
		public bool? MissingBucket { get; set; }

		[JsonInclude]
		[JsonPropertyName("value_type")]
		public string? ValueType { get; set; }

		[JsonInclude]
		[JsonPropertyName("order")]
		public Elastic.Clients.Elasticsearch.Aggregations.TermsAggregationOrder? Order { get; set; }

		[JsonInclude]
		[JsonPropertyName("script")]
		public Elastic.Clients.Elasticsearch.Script? Script { get; set; }

		[JsonInclude]
		[JsonPropertyName("shard_size")]
		public int? ShardSize { get; set; }

		[JsonInclude]
		[JsonPropertyName("show_term_doc_count_error")]
		public bool? ShowTermDocCountError { get; set; }

		[JsonInclude]
		[JsonPropertyName("size")]
		public int? Size { get; set; }
	}

	public sealed partial class TermsAggregationDescriptor<T> : DescriptorBase<TermsAggregationDescriptor<T>>
	{
		public TermsAggregationDescriptor()
		{
		}

		internal TermsAggregationDescriptor(Action<TermsAggregationDescriptor<T>> configure) => configure.Invoke(this);
		internal Elastic.Clients.Elasticsearch.Aggregations.TermsAggregationCollectMode? CollectModeValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Aggregations.TermsExclude? ExcludeValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Aggregations.TermsAggregationExecutionHint? ExecutionHintValue { get; private set; }

		internal string? FieldValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Aggregations.TermsInclude? IncludeValue { get; private set; }

		internal int? MinDocCountValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Aggregations.Missing? MissingValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Aggregations.MissingOrder? MissingOrderValue { get; private set; }

		internal bool? MissingBucketValue { get; private set; }

		internal string? ValueTypeValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Aggregations.TermsAggregationOrder? OrderValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Script? ScriptValue { get; private set; }

		internal int? ShardSizeValue { get; private set; }

		internal bool? ShowTermDocCountErrorValue { get; private set; }

		internal int? SizeValue { get; private set; }

		public TermsAggregationDescriptor<T> CollectMode(Elastic.Clients.Elasticsearch.Aggregations.TermsAggregationCollectMode? collectMode) => Assign(collectMode, (a, v) => a.CollectModeValue = v);
		public TermsAggregationDescriptor<T> Exclude(Elastic.Clients.Elasticsearch.Aggregations.TermsExclude? exclude) => Assign(exclude, (a, v) => a.ExcludeValue = v);
		public TermsAggregationDescriptor<T> ExecutionHint(Elastic.Clients.Elasticsearch.Aggregations.TermsAggregationExecutionHint? executionHint) => Assign(executionHint, (a, v) => a.ExecutionHintValue = v);
		public TermsAggregationDescriptor<T> Field(string? field) => Assign(field, (a, v) => a.FieldValue = v);
		public TermsAggregationDescriptor<T> Include(Elastic.Clients.Elasticsearch.Aggregations.TermsInclude? include) => Assign(include, (a, v) => a.IncludeValue = v);
		public TermsAggregationDescriptor<T> MinDocCount(int? minDocCount) => Assign(minDocCount, (a, v) => a.MinDocCountValue = v);
		public TermsAggregationDescriptor<T> Missing(Elastic.Clients.Elasticsearch.Aggregations.Missing? missing) => Assign(missing, (a, v) => a.MissingValue = v);
		public TermsAggregationDescriptor<T> MissingOrder(Elastic.Clients.Elasticsearch.Aggregations.MissingOrder? missingOrder) => Assign(missingOrder, (a, v) => a.MissingOrderValue = v);
		public TermsAggregationDescriptor<T> MissingBucket(bool? missingBucket = true) => Assign(missingBucket, (a, v) => a.MissingBucketValue = v);
		public TermsAggregationDescriptor<T> ValueType(string? valueType) => Assign(valueType, (a, v) => a.ValueTypeValue = v);
		public TermsAggregationDescriptor<T> Order(Elastic.Clients.Elasticsearch.Aggregations.TermsAggregationOrder? order) => Assign(order, (a, v) => a.OrderValue = v);
		public TermsAggregationDescriptor<T> Script(Elastic.Clients.Elasticsearch.Script? script) => Assign(script, (a, v) => a.ScriptValue = v);
		public TermsAggregationDescriptor<T> ShardSize(int? shardSize) => Assign(shardSize, (a, v) => a.ShardSizeValue = v);
		public TermsAggregationDescriptor<T> ShowTermDocCountError(bool? showTermDocCountError = true) => Assign(showTermDocCountError, (a, v) => a.ShowTermDocCountErrorValue = v);
		public TermsAggregationDescriptor<T> Size(int? size) => Assign(size, (a, v) => a.SizeValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (CollectModeValue is not null)
			{
				writer.WritePropertyName("collect_mode");
				JsonSerializer.Serialize(writer, CollectModeValue, options);
			}

			if (ExcludeValue is not null)
			{
				writer.WritePropertyName("exclude");
				JsonSerializer.Serialize(writer, ExcludeValue, options);
			}

			if (ExecutionHintValue is not null)
			{
				writer.WritePropertyName("execution_hint");
				JsonSerializer.Serialize(writer, ExecutionHintValue, options);
			}

			if (FieldValue is not null)
			{
				writer.WritePropertyName("field");
				JsonSerializer.Serialize(writer, FieldValue, options);
			}

			if (IncludeValue is not null)
			{
				writer.WritePropertyName("include");
				JsonSerializer.Serialize(writer, IncludeValue, options);
			}

			if (MinDocCountValue.HasValue)
			{
				writer.WritePropertyName("min_doc_count");
				writer.WriteNumberValue(MinDocCountValue.Value);
			}

			if (MissingValue is not null)
			{
				writer.WritePropertyName("missing");
				JsonSerializer.Serialize(writer, MissingValue, options);
			}

			if (MissingOrderValue is not null)
			{
				writer.WritePropertyName("missing_order");
				JsonSerializer.Serialize(writer, MissingOrderValue, options);
			}

			if (MissingBucketValue.HasValue)
			{
				writer.WritePropertyName("missing_bucket");
				writer.WriteBooleanValue(MissingBucketValue.Value);
			}

			if (!string.IsNullOrEmpty(ValueTypeValue))
			{
				writer.WritePropertyName("value_type");
				writer.WriteStringValue(ValueTypeValue);
			}

			if (OrderValue is not null)
			{
				writer.WritePropertyName("order");
				JsonSerializer.Serialize(writer, OrderValue, options);
			}

			if (ScriptValue is not null)
			{
				writer.WritePropertyName("script");
				JsonSerializer.Serialize(writer, ScriptValue, options);
			}

			if (ShardSizeValue.HasValue)
			{
				writer.WritePropertyName("shard_size");
				writer.WriteNumberValue(ShardSizeValue.Value);
			}

			if (ShowTermDocCountErrorValue.HasValue)
			{
				writer.WritePropertyName("show_term_doc_count_error");
				writer.WriteBooleanValue(ShowTermDocCountErrorValue.Value);
			}

			if (SizeValue.HasValue)
			{
				writer.WritePropertyName("size");
				writer.WriteNumberValue(SizeValue.Value);
			}

			writer.WriteEndObject();
		}
	}

	public abstract partial class TermsBucketBase : Aggregations.MultiBucketBase
	{
		[JsonInclude]
		[JsonPropertyName("doc_count_error")]
		public long? DocCountError { get; init; }
	}

	public partial class TermsPartition
	{
		[JsonInclude]
		[JsonPropertyName("num_partitions")]
		public long NumPartitions { get; init; }

		[JsonInclude]
		[JsonPropertyName("partition")]
		public long Partition { get; init; }
	}

	public partial class TestPopulation
	{
		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("script")]
		public Elastic.Clients.Elasticsearch.Script? Script { get; set; }

		[JsonInclude]
		[JsonPropertyName("filter")]
		public Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? Filter { get; set; }
	}

	public sealed partial class TestPopulationDescriptor<T> : DescriptorBase<TestPopulationDescriptor<T>>
	{
		public TestPopulationDescriptor()
		{
		}

		internal TestPopulationDescriptor(Action<TestPopulationDescriptor<T>> configure) => configure.Invoke(this);
		internal string FieldValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Script? ScriptValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? FilterValue { get; private set; }

		internal QueryDsl.QueryContainerDescriptor<T> FilterDescriptor { get; private set; }

		internal Action<QueryDsl.QueryContainerDescriptor<T>> FilterDescriptorAction { get; private set; }

		public TestPopulationDescriptor<T> Field(string field) => Assign(field, (a, v) => a.FieldValue = v);
		public TestPopulationDescriptor<T> Script(Elastic.Clients.Elasticsearch.Script? script) => Assign(script, (a, v) => a.ScriptValue = v);
		public TestPopulationDescriptor<T> Filter(Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? filter)
		{
			FilterDescriptor = null;
			FilterDescriptorAction = null;
			return Assign(filter, (a, v) => a.FilterValue = v);
		}

		public TestPopulationDescriptor<T> Filter(Elastic.Clients.Elasticsearch.QueryDsl.QueryContainerDescriptor<T> descriptor)
		{
			FilterValue = null;
			FilterDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.FilterDescriptor = v);
		}

		public TestPopulationDescriptor<T> Filter(Action<Elastic.Clients.Elasticsearch.QueryDsl.QueryContainerDescriptor<T>> configure)
		{
			FilterValue = null;
			FilterDescriptorAction = null;
			return Assign(configure, (a, v) => a.FilterDescriptorAction = v);
		}

		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, FieldValue, options);
			if (ScriptValue is not null)
			{
				writer.WritePropertyName("script");
				JsonSerializer.Serialize(writer, ScriptValue, options);
			}

			if (FilterDescriptor is not null)
			{
				writer.WritePropertyName("filter");
				JsonSerializer.Serialize(writer, FilterDescriptor, options);
			}
			else if (FilterDescriptorAction is not null)
			{
				writer.WritePropertyName("filter");
				JsonSerializer.Serialize(writer, new QueryDsl.QueryContainerDescriptor<T>(FilterDescriptorAction), options);
			}
			else if (FilterValue is not null)
			{
				writer.WritePropertyName("filter");
				JsonSerializer.Serialize(writer, FilterValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class TopHitsAggregate : Aggregations.AggregateBase
	{
		[JsonInclude]
		[JsonPropertyName("hits")]
		public Elastic.Clients.Elasticsearch.HitsMetadata<object> Hits { get; init; }
	}

	public partial class TopHitsAggregation : Aggregations.MetricAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "top_hits";
		[JsonInclude]
		[JsonPropertyName("docvalue_fields")]
		public Elastic.Clients.Elasticsearch.Fields? DocvalueFields { get; set; }

		[JsonInclude]
		[JsonPropertyName("explain")]
		public bool? Explain { get; set; }

		[JsonInclude]
		[JsonPropertyName("from")]
		public int? From { get; set; }

		[JsonInclude]
		[JsonPropertyName("highlight")]
		public Elastic.Clients.Elasticsearch.Highlight? Highlight { get; set; }

		[JsonInclude]
		[JsonPropertyName("script_fields")]
		public Dictionary<string, Elastic.Clients.Elasticsearch.ScriptField>? ScriptFields { get; set; }

		[JsonInclude]
		[JsonPropertyName("size")]
		public int? Size { get; set; }

		[JsonInclude]
		[JsonPropertyName("sort")]
		public Elastic.Clients.Elasticsearch.Sort? Sort { get; set; }

		[JsonInclude]
		[JsonPropertyName("_source")]
		public Elastic.Clients.Elasticsearch.SourceConfig? Source { get; set; }

		[JsonInclude]
		[JsonPropertyName("stored_fields")]
		public Elastic.Clients.Elasticsearch.Fields? StoredFields { get; set; }

		[JsonInclude]
		[JsonPropertyName("track_scores")]
		public bool? TrackScores { get; set; }

		[JsonInclude]
		[JsonPropertyName("version")]
		public bool? Version { get; set; }

		[JsonInclude]
		[JsonPropertyName("seq_no_primary_term")]
		public bool? SeqNoPrimaryTerm { get; set; }
	}

	public sealed partial class TopHitsAggregationDescriptor<T> : DescriptorBase<TopHitsAggregationDescriptor<T>>
	{
		public TopHitsAggregationDescriptor()
		{
		}

		internal TopHitsAggregationDescriptor(Action<TopHitsAggregationDescriptor<T>> configure) => configure.Invoke(this);
		internal Elastic.Clients.Elasticsearch.Fields? DocvalueFieldsValue { get; private set; }

		internal bool? ExplainValue { get; private set; }

		internal int? FromValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Highlight? HighlightValue { get; private set; }

		internal Dictionary<string, Elastic.Clients.Elasticsearch.ScriptField>? ScriptFieldsValue { get; private set; }

		internal int? SizeValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Sort? SortValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.SourceConfig? SourceValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Fields? StoredFieldsValue { get; private set; }

		internal bool? TrackScoresValue { get; private set; }

		internal bool? VersionValue { get; private set; }

		internal bool? SeqNoPrimaryTermValue { get; private set; }

		internal HighlightDescriptor<T> HighlightDescriptor { get; private set; }

		internal Action<HighlightDescriptor<T>> HighlightDescriptorAction { get; private set; }

		public TopHitsAggregationDescriptor<T> DocvalueFields(Elastic.Clients.Elasticsearch.Fields? docvalueFields) => Assign(docvalueFields, (a, v) => a.DocvalueFieldsValue = v);
		public TopHitsAggregationDescriptor<T> Explain(bool? explain = true) => Assign(explain, (a, v) => a.ExplainValue = v);
		public TopHitsAggregationDescriptor<T> From(int? from) => Assign(from, (a, v) => a.FromValue = v);
		public TopHitsAggregationDescriptor<T> Highlight(Elastic.Clients.Elasticsearch.Highlight? highlight)
		{
			HighlightDescriptor = null;
			HighlightDescriptorAction = null;
			return Assign(highlight, (a, v) => a.HighlightValue = v);
		}

		public TopHitsAggregationDescriptor<T> Highlight(Elastic.Clients.Elasticsearch.HighlightDescriptor<T> descriptor)
		{
			HighlightValue = null;
			HighlightDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.HighlightDescriptor = v);
		}

		public TopHitsAggregationDescriptor<T> Highlight(Action<Elastic.Clients.Elasticsearch.HighlightDescriptor<T>> configure)
		{
			HighlightValue = null;
			HighlightDescriptorAction = null;
			return Assign(configure, (a, v) => a.HighlightDescriptorAction = v);
		}

		public TopHitsAggregationDescriptor<T> ScriptFields(Func<FluentDictionary<string?, Elastic.Clients.Elasticsearch.ScriptField?>, FluentDictionary<string?, Elastic.Clients.Elasticsearch.ScriptField?>> selector) => Assign(selector, (a, v) => a.ScriptFieldsValue = v?.Invoke(new FluentDictionary<string?, Elastic.Clients.Elasticsearch.ScriptField?>()));
		public TopHitsAggregationDescriptor<T> Size(int? size) => Assign(size, (a, v) => a.SizeValue = v);
		public TopHitsAggregationDescriptor<T> Sort(Elastic.Clients.Elasticsearch.Sort? sort) => Assign(sort, (a, v) => a.SortValue = v);
		public TopHitsAggregationDescriptor<T> Source(Elastic.Clients.Elasticsearch.SourceConfig? source) => Assign(source, (a, v) => a.SourceValue = v);
		public TopHitsAggregationDescriptor<T> StoredFields(Elastic.Clients.Elasticsearch.Fields? storedFields) => Assign(storedFields, (a, v) => a.StoredFieldsValue = v);
		public TopHitsAggregationDescriptor<T> TrackScores(bool? trackScores = true) => Assign(trackScores, (a, v) => a.TrackScoresValue = v);
		public TopHitsAggregationDescriptor<T> Version(bool? version = true) => Assign(version, (a, v) => a.VersionValue = v);
		public TopHitsAggregationDescriptor<T> SeqNoPrimaryTerm(bool? seqNoPrimaryTerm = true) => Assign(seqNoPrimaryTerm, (a, v) => a.SeqNoPrimaryTermValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (DocvalueFieldsValue is not null)
			{
				writer.WritePropertyName("docvalue_fields");
				JsonSerializer.Serialize(writer, DocvalueFieldsValue, options);
			}

			if (ExplainValue.HasValue)
			{
				writer.WritePropertyName("explain");
				writer.WriteBooleanValue(ExplainValue.Value);
			}

			if (FromValue.HasValue)
			{
				writer.WritePropertyName("from");
				writer.WriteNumberValue(FromValue.Value);
			}

			if (HighlightDescriptor is not null)
			{
				writer.WritePropertyName("highlight");
				JsonSerializer.Serialize(writer, HighlightDescriptor, options);
			}
			else if (HighlightDescriptorAction is not null)
			{
				writer.WritePropertyName("highlight");
				JsonSerializer.Serialize(writer, new HighlightDescriptor<T>(HighlightDescriptorAction), options);
			}
			else if (HighlightValue is not null)
			{
				writer.WritePropertyName("highlight");
				JsonSerializer.Serialize(writer, HighlightValue, options);
			}

			if (ScriptFieldsValue is not null)
			{
				writer.WritePropertyName("script_fields");
				JsonSerializer.Serialize(writer, ScriptFieldsValue, options);
			}

			if (SizeValue.HasValue)
			{
				writer.WritePropertyName("size");
				writer.WriteNumberValue(SizeValue.Value);
			}

			if (SortValue is not null)
			{
				writer.WritePropertyName("sort");
				JsonSerializer.Serialize(writer, SortValue, options);
			}

			if (SourceValue is not null)
			{
				writer.WritePropertyName("_source");
				JsonSerializer.Serialize(writer, SourceValue, options);
			}

			if (StoredFieldsValue is not null)
			{
				writer.WritePropertyName("stored_fields");
				JsonSerializer.Serialize(writer, StoredFieldsValue, options);
			}

			if (TrackScoresValue.HasValue)
			{
				writer.WritePropertyName("track_scores");
				writer.WriteBooleanValue(TrackScoresValue.Value);
			}

			if (VersionValue.HasValue)
			{
				writer.WritePropertyName("version");
				writer.WriteBooleanValue(VersionValue.Value);
			}

			if (SeqNoPrimaryTermValue.HasValue)
			{
				writer.WritePropertyName("seq_no_primary_term");
				writer.WriteBooleanValue(SeqNoPrimaryTermValue.Value);
			}

			writer.WriteEndObject();
		}
	}

	public partial class TopMetrics
	{
		[JsonInclude]
		[JsonPropertyName("sort")]
		public IReadOnlyCollection<object> Sort { get; init; }

		[JsonInclude]
		[JsonPropertyName("metrics")]
		public Dictionary<string, object> Metrics { get; init; }
	}

	public partial class TopMetricsAggregate : Aggregations.MultiBucketAggregateBase<Elastic.Clients.Elasticsearch.Aggregations.TopMetricsBucket>
	{
	}

	public partial class TopMetricsAggregation : Aggregations.MetricAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "top_metrics";
		[JsonInclude]
		[JsonPropertyName("metrics")]
		public Elastic.Clients.Elasticsearch.Aggregations.TopMetricsValue? Metrics { get; set; }

		[JsonInclude]
		[JsonPropertyName("size")]
		public int? Size { get; set; }

		[JsonInclude]
		[JsonPropertyName("sort")]
		public Elastic.Clients.Elasticsearch.Sort? Sort { get; set; }
	}

	public sealed partial class TopMetricsAggregationDescriptor<T> : DescriptorBase<TopMetricsAggregationDescriptor<T>>
	{
		public TopMetricsAggregationDescriptor()
		{
		}

		internal TopMetricsAggregationDescriptor(Action<TopMetricsAggregationDescriptor<T>> configure) => configure.Invoke(this);
		internal Elastic.Clients.Elasticsearch.Aggregations.TopMetricsValue? MetricsValue { get; private set; }

		internal int? SizeValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Sort? SortValue { get; private set; }

		internal TopMetricsValueDescriptor<T> MetricsDescriptor { get; private set; }

		internal Action<TopMetricsValueDescriptor<T>> MetricsDescriptorAction { get; private set; }

		public TopMetricsAggregationDescriptor<T> Metrics(Elastic.Clients.Elasticsearch.Aggregations.TopMetricsValue? metrics)
		{
			MetricsDescriptor = null;
			MetricsDescriptorAction = null;
			return Assign(metrics, (a, v) => a.MetricsValue = v);
		}

		public TopMetricsAggregationDescriptor<T> Metrics(Elastic.Clients.Elasticsearch.Aggregations.TopMetricsValueDescriptor<T> descriptor)
		{
			MetricsValue = null;
			MetricsDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.MetricsDescriptor = v);
		}

		public TopMetricsAggregationDescriptor<T> Metrics(Action<Elastic.Clients.Elasticsearch.Aggregations.TopMetricsValueDescriptor<T>> configure)
		{
			MetricsValue = null;
			MetricsDescriptorAction = null;
			return Assign(configure, (a, v) => a.MetricsDescriptorAction = v);
		}

		public TopMetricsAggregationDescriptor<T> Size(int? size) => Assign(size, (a, v) => a.SizeValue = v);
		public TopMetricsAggregationDescriptor<T> Sort(Elastic.Clients.Elasticsearch.Sort? sort) => Assign(sort, (a, v) => a.SortValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (MetricsDescriptor is not null)
			{
				writer.WritePropertyName("metrics");
				JsonSerializer.Serialize(writer, MetricsDescriptor, options);
			}
			else if (MetricsDescriptorAction is not null)
			{
				writer.WritePropertyName("metrics");
				JsonSerializer.Serialize(writer, new TopMetricsValueDescriptor<T>(MetricsDescriptorAction), options);
			}
			else if (MetricsValue is not null)
			{
				writer.WritePropertyName("metrics");
				JsonSerializer.Serialize(writer, MetricsValue, options);
			}

			if (SizeValue.HasValue)
			{
				writer.WritePropertyName("size");
				writer.WriteNumberValue(SizeValue.Value);
			}

			if (SortValue is not null)
			{
				writer.WritePropertyName("sort");
				JsonSerializer.Serialize(writer, SortValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class TopMetricsBucket : Aggregations.MultiBucketBase
	{
		[JsonInclude]
		[JsonPropertyName("top")]
		public IReadOnlyCollection<Elastic.Clients.Elasticsearch.Aggregations.TopMetrics> Top { get; init; }
	}

	public partial class TopMetricsValue
	{
		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }
	}

	public sealed partial class TopMetricsValueDescriptor<T> : DescriptorBase<TopMetricsValueDescriptor<T>>
	{
		public TopMetricsValueDescriptor()
		{
		}

		internal TopMetricsValueDescriptor(Action<TopMetricsValueDescriptor<T>> configure) => configure.Invoke(this);
		internal string FieldValue { get; private set; }

		public TopMetricsValueDescriptor<T> Field(string field) => Assign(field, (a, v) => a.FieldValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, FieldValue, options);
			writer.WriteEndObject();
		}
	}

	public partial class TTestAggregate : Aggregations.AggregateBase
	{
		[JsonInclude]
		[JsonPropertyName("value")]
		public object Value { get; init; }

		[JsonInclude]
		[JsonPropertyName("value_as_string")]
		public string? ValueAsString { get; init; }
	}

	public partial class TTestAggregation : Aggregations.AggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "t_test";
		[JsonInclude]
		[JsonPropertyName("a")]
		public Elastic.Clients.Elasticsearch.Aggregations.TestPopulation? a { get; set; }

		[JsonInclude]
		[JsonPropertyName("b")]
		public Elastic.Clients.Elasticsearch.Aggregations.TestPopulation? b { get; set; }

		[JsonInclude]
		[JsonPropertyName("type")]
		public Elastic.Clients.Elasticsearch.Aggregations.TTestType? Type { get; set; }
	}

	public sealed partial class TTestAggregationDescriptor<T> : DescriptorBase<TTestAggregationDescriptor<T>>
	{
		public TTestAggregationDescriptor()
		{
		}

		internal TTestAggregationDescriptor(Action<TTestAggregationDescriptor<T>> configure) => configure.Invoke(this);
		internal Elastic.Clients.Elasticsearch.Aggregations.TestPopulation? aValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Aggregations.TestPopulation? bValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Aggregations.TTestType? TypeValue { get; private set; }

		internal TestPopulationDescriptor<T> aDescriptor { get; private set; }

		internal TestPopulationDescriptor<T> bDescriptor { get; private set; }

		internal Action<TestPopulationDescriptor<T>> aDescriptorAction { get; private set; }

		internal Action<TestPopulationDescriptor<T>> bDescriptorAction { get; private set; }

		public TTestAggregationDescriptor<T> a(Elastic.Clients.Elasticsearch.Aggregations.TestPopulation? a)
		{
			aDescriptor = null;
			aDescriptorAction = null;
			return Assign(a, (a, v) => a.aValue = v);
		}

		public TTestAggregationDescriptor<T> a(Elastic.Clients.Elasticsearch.Aggregations.TestPopulationDescriptor<T> descriptor)
		{
			aValue = null;
			aDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.aDescriptor = v);
		}

		public TTestAggregationDescriptor<T> a(Action<Elastic.Clients.Elasticsearch.Aggregations.TestPopulationDescriptor<T>> configure)
		{
			aValue = null;
			aDescriptorAction = null;
			return Assign(configure, (a, v) => a.aDescriptorAction = v);
		}

		public TTestAggregationDescriptor<T> b(Elastic.Clients.Elasticsearch.Aggregations.TestPopulation? b)
		{
			bDescriptor = null;
			bDescriptorAction = null;
			return Assign(b, (a, v) => a.bValue = v);
		}

		public TTestAggregationDescriptor<T> b(Elastic.Clients.Elasticsearch.Aggregations.TestPopulationDescriptor<T> descriptor)
		{
			bValue = null;
			bDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.bDescriptor = v);
		}

		public TTestAggregationDescriptor<T> b(Action<Elastic.Clients.Elasticsearch.Aggregations.TestPopulationDescriptor<T>> configure)
		{
			bValue = null;
			bDescriptorAction = null;
			return Assign(configure, (a, v) => a.bDescriptorAction = v);
		}

		public TTestAggregationDescriptor<T> Type(Elastic.Clients.Elasticsearch.Aggregations.TTestType? type) => Assign(type, (a, v) => a.TypeValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (aDescriptor is not null)
			{
				writer.WritePropertyName("a");
				JsonSerializer.Serialize(writer, aDescriptor, options);
			}
			else if (aDescriptorAction is not null)
			{
				writer.WritePropertyName("a");
				JsonSerializer.Serialize(writer, new TestPopulationDescriptor<T>(aDescriptorAction), options);
			}
			else if (aValue is not null)
			{
				writer.WritePropertyName("a");
				JsonSerializer.Serialize(writer, aValue, options);
			}

			if (bDescriptor is not null)
			{
				writer.WritePropertyName("b");
				JsonSerializer.Serialize(writer, bDescriptor, options);
			}
			else if (bDescriptorAction is not null)
			{
				writer.WritePropertyName("b");
				JsonSerializer.Serialize(writer, new TestPopulationDescriptor<T>(bDescriptorAction), options);
			}
			else if (bValue is not null)
			{
				writer.WritePropertyName("b");
				JsonSerializer.Serialize(writer, bValue, options);
			}

			if (TypeValue is not null)
			{
				writer.WritePropertyName("type");
				JsonSerializer.Serialize(writer, TypeValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class ValueCountAggregate : Aggregations.SingleMetricAggregateBase
	{
	}

	public partial class ValueCountAggregation : Aggregations.FormattableMetricAggregation, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "value_count";
	}

	public sealed partial class ValueCountAggregationDescriptor : DescriptorBase<ValueCountAggregationDescriptor>
	{
		public ValueCountAggregationDescriptor()
		{
		}

		internal ValueCountAggregationDescriptor(Action<ValueCountAggregationDescriptor> configure) => configure.Invoke(this);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			writer.WriteEndObject();
		}
	}

	public partial class VariableWidthHistogramAggregate : Aggregations.MultiBucketAggregateBase<Elastic.Clients.Elasticsearch.Aggregations.VariableWidthHistogramBucket>
	{
	}

	public partial class VariableWidthHistogramAggregation : IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "variable_width_histogram";
		[JsonInclude]
		[JsonPropertyName("field")]
		public string? Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("buckets")]
		public int? Buckets { get; set; }

		[JsonInclude]
		[JsonPropertyName("shard_size")]
		public int? ShardSize { get; set; }

		[JsonInclude]
		[JsonPropertyName("initial_buffer")]
		public int? InitialBuffer { get; set; }
	}

	public sealed partial class VariableWidthHistogramAggregationDescriptor<T> : DescriptorBase<VariableWidthHistogramAggregationDescriptor<T>>
	{
		public VariableWidthHistogramAggregationDescriptor()
		{
		}

		internal VariableWidthHistogramAggregationDescriptor(Action<VariableWidthHistogramAggregationDescriptor<T>> configure) => configure.Invoke(this);
		internal string? FieldValue { get; private set; }

		internal int? BucketsValue { get; private set; }

		internal int? ShardSizeValue { get; private set; }

		internal int? InitialBufferValue { get; private set; }

		public VariableWidthHistogramAggregationDescriptor<T> Field(string? field) => Assign(field, (a, v) => a.FieldValue = v);
		public VariableWidthHistogramAggregationDescriptor<T> Buckets(int? buckets) => Assign(buckets, (a, v) => a.BucketsValue = v);
		public VariableWidthHistogramAggregationDescriptor<T> ShardSize(int? shardSize) => Assign(shardSize, (a, v) => a.ShardSizeValue = v);
		public VariableWidthHistogramAggregationDescriptor<T> InitialBuffer(int? initialBuffer) => Assign(initialBuffer, (a, v) => a.InitialBufferValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (FieldValue is not null)
			{
				writer.WritePropertyName("field");
				JsonSerializer.Serialize(writer, FieldValue, options);
			}

			if (BucketsValue.HasValue)
			{
				writer.WritePropertyName("buckets");
				writer.WriteNumberValue(BucketsValue.Value);
			}

			if (ShardSizeValue.HasValue)
			{
				writer.WritePropertyName("shard_size");
				writer.WriteNumberValue(ShardSizeValue.Value);
			}

			if (InitialBufferValue.HasValue)
			{
				writer.WritePropertyName("initial_buffer");
				writer.WriteNumberValue(InitialBufferValue.Value);
			}

			writer.WriteEndObject();
		}
	}

	public partial class VariableWidthHistogramBucket : Aggregations.MultiBucketBase
	{
		[JsonInclude]
		[JsonPropertyName("min")]
		public double Min { get; init; }

		[JsonInclude]
		[JsonPropertyName("key")]
		public double Key { get; init; }

		[JsonInclude]
		[JsonPropertyName("max")]
		public double Max { get; init; }

		[JsonInclude]
		[JsonPropertyName("min_as_string")]
		public string? MinAsString { get; init; }

		[JsonInclude]
		[JsonPropertyName("key_as_string")]
		public string? KeyAsString { get; init; }

		[JsonInclude]
		[JsonPropertyName("max_as_string")]
		public string? MaxAsString { get; init; }
	}

	public partial class WeightedAverageAggregation : Aggregations.AggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "weighted_avg";
		[JsonInclude]
		[JsonPropertyName("format")]
		public string? Format { get; set; }

		[JsonInclude]
		[JsonPropertyName("value")]
		public Elastic.Clients.Elasticsearch.Aggregations.WeightedAverageValue? Value { get; set; }

		[JsonInclude]
		[JsonPropertyName("value_type")]
		public Elastic.Clients.Elasticsearch.Aggregations.ValueType? ValueType { get; set; }

		[JsonInclude]
		[JsonPropertyName("weight")]
		public Elastic.Clients.Elasticsearch.Aggregations.WeightedAverageValue? Weight { get; set; }
	}

	public sealed partial class WeightedAverageAggregationDescriptor<T> : DescriptorBase<WeightedAverageAggregationDescriptor<T>>
	{
		public WeightedAverageAggregationDescriptor()
		{
		}

		internal WeightedAverageAggregationDescriptor(Action<WeightedAverageAggregationDescriptor<T>> configure) => configure.Invoke(this);
		internal string? FormatValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Aggregations.WeightedAverageValue? ValueValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Aggregations.ValueType? ValueTypeValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Aggregations.WeightedAverageValue? WeightValue { get; private set; }

		internal WeightedAverageValueDescriptor<T> ValueDescriptor { get; private set; }

		internal WeightedAverageValueDescriptor<T> WeightDescriptor { get; private set; }

		internal Action<WeightedAverageValueDescriptor<T>> ValueDescriptorAction { get; private set; }

		internal Action<WeightedAverageValueDescriptor<T>> WeightDescriptorAction { get; private set; }

		public WeightedAverageAggregationDescriptor<T> Format(string? format) => Assign(format, (a, v) => a.FormatValue = v);
		public WeightedAverageAggregationDescriptor<T> Value(Elastic.Clients.Elasticsearch.Aggregations.WeightedAverageValue? value)
		{
			ValueDescriptor = null;
			ValueDescriptorAction = null;
			return Assign(value, (a, v) => a.ValueValue = v);
		}

		public WeightedAverageAggregationDescriptor<T> Value(Elastic.Clients.Elasticsearch.Aggregations.WeightedAverageValueDescriptor<T> descriptor)
		{
			ValueValue = null;
			ValueDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.ValueDescriptor = v);
		}

		public WeightedAverageAggregationDescriptor<T> Value(Action<Elastic.Clients.Elasticsearch.Aggregations.WeightedAverageValueDescriptor<T>> configure)
		{
			ValueValue = null;
			ValueDescriptorAction = null;
			return Assign(configure, (a, v) => a.ValueDescriptorAction = v);
		}

		public WeightedAverageAggregationDescriptor<T> ValueType(Elastic.Clients.Elasticsearch.Aggregations.ValueType? valueType) => Assign(valueType, (a, v) => a.ValueTypeValue = v);
		public WeightedAverageAggregationDescriptor<T> Weight(Elastic.Clients.Elasticsearch.Aggregations.WeightedAverageValue? weight)
		{
			WeightDescriptor = null;
			WeightDescriptorAction = null;
			return Assign(weight, (a, v) => a.WeightValue = v);
		}

		public WeightedAverageAggregationDescriptor<T> Weight(Elastic.Clients.Elasticsearch.Aggregations.WeightedAverageValueDescriptor<T> descriptor)
		{
			WeightValue = null;
			WeightDescriptorAction = null;
			return Assign(descriptor, (a, v) => a.WeightDescriptor = v);
		}

		public WeightedAverageAggregationDescriptor<T> Weight(Action<Elastic.Clients.Elasticsearch.Aggregations.WeightedAverageValueDescriptor<T>> configure)
		{
			WeightValue = null;
			WeightDescriptorAction = null;
			return Assign(configure, (a, v) => a.WeightDescriptorAction = v);
		}

		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (!string.IsNullOrEmpty(FormatValue))
			{
				writer.WritePropertyName("format");
				writer.WriteStringValue(FormatValue);
			}

			if (ValueDescriptor is not null)
			{
				writer.WritePropertyName("value");
				JsonSerializer.Serialize(writer, ValueDescriptor, options);
			}
			else if (ValueDescriptorAction is not null)
			{
				writer.WritePropertyName("value");
				JsonSerializer.Serialize(writer, new WeightedAverageValueDescriptor<T>(ValueDescriptorAction), options);
			}
			else if (ValueValue is not null)
			{
				writer.WritePropertyName("value");
				JsonSerializer.Serialize(writer, ValueValue, options);
			}

			if (ValueTypeValue is not null)
			{
				writer.WritePropertyName("value_type");
				JsonSerializer.Serialize(writer, ValueTypeValue, options);
			}

			if (WeightDescriptor is not null)
			{
				writer.WritePropertyName("weight");
				JsonSerializer.Serialize(writer, WeightDescriptor, options);
			}
			else if (WeightDescriptorAction is not null)
			{
				writer.WritePropertyName("weight");
				JsonSerializer.Serialize(writer, new WeightedAverageValueDescriptor<T>(WeightDescriptorAction), options);
			}
			else if (WeightValue is not null)
			{
				writer.WritePropertyName("weight");
				JsonSerializer.Serialize(writer, WeightValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class WeightedAverageValue
	{
		[JsonInclude]
		[JsonPropertyName("field")]
		public string? Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("missing")]
		public double? Missing { get; set; }

		[JsonInclude]
		[JsonPropertyName("script")]
		public Elastic.Clients.Elasticsearch.Script? Script { get; set; }
	}

	public sealed partial class WeightedAverageValueDescriptor<T> : DescriptorBase<WeightedAverageValueDescriptor<T>>
	{
		public WeightedAverageValueDescriptor()
		{
		}

		internal WeightedAverageValueDescriptor(Action<WeightedAverageValueDescriptor<T>> configure) => configure.Invoke(this);
		internal string? FieldValue { get; private set; }

		internal double? MissingValue { get; private set; }

		internal Elastic.Clients.Elasticsearch.Script? ScriptValue { get; private set; }

		public WeightedAverageValueDescriptor<T> Field(string? field) => Assign(field, (a, v) => a.FieldValue = v);
		public WeightedAverageValueDescriptor<T> Missing(double? missing) => Assign(missing, (a, v) => a.MissingValue = v);
		public WeightedAverageValueDescriptor<T> Script(Elastic.Clients.Elasticsearch.Script? script) => Assign(script, (a, v) => a.ScriptValue = v);
		protected override void Serialize(Utf8JsonWriter writer, JsonSerializerOptions options, IElasticsearchClientSettings settings)
		{
			writer.WriteStartObject();
			if (FieldValue is not null)
			{
				writer.WritePropertyName("field");
				JsonSerializer.Serialize(writer, FieldValue, options);
			}

			if (MissingValue.HasValue)
			{
				writer.WritePropertyName("missing");
				writer.WriteNumberValue(MissingValue.Value);
			}

			if (ScriptValue is not null)
			{
				writer.WritePropertyName("script");
				JsonSerializer.Serialize(writer, ScriptValue, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class WeightedAvgAggregate : Aggregations.SingleMetricAggregateBase
	{
	}
}
