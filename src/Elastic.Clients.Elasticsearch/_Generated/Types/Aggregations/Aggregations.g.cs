// Licensed to Elasticsearch B.V under one or more agreements.
// Elasticsearch B.V licenses this file to you under the Apache 2.0 License.
// See the LICENSE file in the project root for more information.
//
// ███╗   ██╗ ██████╗ ████████╗██╗ ██████╗███████╗
// ████╗  ██║██╔═══██╗╚══██╔══╝██║██╔════╝██╔════╝
// ██╔██╗ ██║██║   ██║   ██║   ██║██║     █████╗
// ██║╚██╗██║██║   ██║   ██║   ██║██║     ██╔══╝
// ██║ ╚████║╚██████╔╝   ██║   ██║╚██████╗███████╗
// ╚═╝  ╚═══╝ ╚═════╝    ╚═╝   ╚═╝ ╚═════╝╚══════╝
// ------------------------------------------------
//
// This file is automatically generated.
// Please do not edit these files manually.
//
// ------------------------------------------------

using System;
using System.Collections.Generic;
using System.Text.Json;
using System.Text.Json.Serialization;

#nullable restore
namespace Elastic.Clients.Elasticsearch.Aggregations
{
	public partial class AdjacencyMatrixAggregate : Aggregations.MultiBucketAggregateBase<Elastic.Clients.Elasticsearch.Aggregations.AdjacencyMatrixBucket>
	{
	}

	public partial class AdjacencyMatrixAggregation : Aggregations.BucketAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "adjacency_matrix";
		[JsonInclude]
		[JsonPropertyName("filters")]
		public Dictionary<string, Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer>? Filters { get; set; }
	}

	[JsonConverter(typeof(AdjacencyMatrixAggregationDescriptorConverter))]
	public sealed partial class AdjacencyMatrixAggregationDescriptor : DescriptorBase<AdjacencyMatrixAggregationDescriptor>
	{
		internal Dictionary<string, Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer>? _filters;
	}

	internal sealed class AdjacencyMatrixAggregationDescriptorConverter : JsonConverter<AdjacencyMatrixAggregationDescriptor>
	{
		public override AdjacencyMatrixAggregationDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, AdjacencyMatrixAggregationDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value._filters is not null)
			{
				writer.WritePropertyName("filters");
				JsonSerializer.Serialize(writer, value._filters, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class AdjacencyMatrixBucket : Aggregations.MultiBucketBase
	{
	}

	public abstract partial class AggregateBase
	{
		[JsonInclude]
		[JsonPropertyName("meta")]
		public Dictionary<string, object>? Meta { get; init; }
	}

	public partial class Aggregation
	{
		[JsonInclude]
		[JsonPropertyName("meta")]
		public Dictionary<string, object>? Meta { get; set; }

		[JsonInclude]
		[JsonPropertyName("name")]
		public string? Name { get; set; }
	}

	[JsonConverter(typeof(AggregationDescriptorConverter))]
	public sealed partial class AggregationDescriptor : DescriptorBase<AggregationDescriptor>
	{
		internal Dictionary<string, object>? _meta;
		internal string? _name;
	}

	internal sealed class AggregationDescriptorConverter : JsonConverter<AggregationDescriptor>
	{
		public override AggregationDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, AggregationDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value._meta is not null)
			{
				writer.WritePropertyName("meta");
				JsonSerializer.Serialize(writer, value._meta, options);
			}

			if (!string.IsNullOrEmpty(value._name))
			{
				writer.WritePropertyName("name");
				writer.WriteStringValue(value._name);
			}

			writer.WriteEndObject();
		}
	}

	public interface IAggregationContainerVariant
	{
		string AggregationContainerVariantName { get; }
	}

	[JsonConverter(typeof(AggregationContainerConverter))]
	public partial class AggregationContainer : IContainer
	{
		public AggregationContainer(IAggregationContainerVariant variant) => Variant = variant ?? throw new ArgumentNullException(nameof(variant));
		internal IAggregationContainerVariant Variant { get; }

		[JsonInclude]
		[JsonPropertyName("meta")]
		public Dictionary<string, object>? Meta { get; set; }
	}

	internal sealed class AggregationContainerConverter : JsonConverter<AggregationContainer>
	{
		public override AggregationContainer Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
		{
			reader.Read();
			if (reader.TokenType != JsonTokenType.PropertyName)
			{
				throw new JsonException();
			}

			var propertyName = reader.GetString();
			if (propertyName == "adjacency_matrix")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.AdjacencyMatrixAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "auto_date_histogram")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.AutoDateHistogramAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "avg")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.AverageAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "avg_bucket")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.AverageBucketAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "boxplot")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.BoxplotAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "bucket_script")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.BucketScriptAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "bucket_selector")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.BucketSelectorAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "bucket_sort")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.BucketSortAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "cardinality")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.CardinalityAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "children")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.ChildrenAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "composite")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.CompositeAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "cumulative_cardinality")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.CumulativeCardinalityAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "cumulative_sum")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.CumulativeSumAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "date_histogram")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.DateHistogramAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "date_range")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.DateRangeAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "derivative")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.DerivativeAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "diversified_sampler")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.DiversifiedSamplerAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "extended_stats")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.ExtendedStatsAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "extended_stats_bucket")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.ExtendedStatsBucketAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "filter")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "filters")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.FiltersAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "geo_bounds")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.GeoBoundsAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "geo_centroid")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.GeoCentroidAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "geo_distance")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.GeoDistanceAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "geohash_grid")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.GeoHashGridAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "geo_line")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.GeoLineAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "geotile_grid")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.GeoTileGridAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "global")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.GlobalAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "histogram")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.HistogramAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "ip_range")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.IpRangeAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "inference")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.InferenceAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "matrix_stats")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.MatrixStatsAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "max")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.MaxAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "max_bucket")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.MaxBucketAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "median_absolute_deviation")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.MedianAbsoluteDeviationAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "min")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.MinAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "min_bucket")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.MinBucketAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "missing")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.MissingAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "moving_avg")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.MovingAverageAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "moving_percentiles")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.MovingPercentilesAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "moving_fn")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.MovingFunctionAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "multi_terms")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.MultiTermsAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "nested")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.NestedAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "normalize")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.NormalizeAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "parent")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.ParentAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "percentile_ranks")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.PercentileRanksAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "percentiles")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.PercentilesAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "percentiles_bucket")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.PercentilesBucketAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "range")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.RangeAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "rare_terms")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.RareTermsAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "rate")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.RateAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "reverse_nested")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.ReverseNestedAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "sampler")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.SamplerAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "scripted_metric")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.ScriptedMetricAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "serial_diff")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.SerialDifferencingAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "significant_terms")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.SignificantTermsAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "significant_text")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.SignificantTextAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "stats")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.StatsAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "stats_bucket")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.StatsBucketAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "string_stats")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.StringStatsAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "sum")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.SumAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "sum_bucket")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.SumBucketAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "terms")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.TermsAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "top_hits")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.TopHitsAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "t_test")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.TTestAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "top_metrics")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.TopMetricsAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "value_count")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.ValueCountAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "weighted_avg")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.WeightedAverageAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			if (propertyName == "variable_width_histogram")
			{
				var variant = JsonSerializer.Deserialize<Elastic.Clients.Elasticsearch.Aggregations.VariableWidthHistogramAggregation?>(ref reader, options);
				reader.Read();
				return new AggregationContainer(variant);
			}

			throw new JsonException();
		}

		public override void Write(Utf8JsonWriter writer, AggregationContainer value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName(value.Variant.AggregationContainerVariantName);
			switch (value.Variant)
			{
				case Elastic.Clients.Elasticsearch.Aggregations.AdjacencyMatrixAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.AutoDateHistogramAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.AverageAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.AverageBucketAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.BoxplotAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.BucketScriptAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.BucketSelectorAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.BucketSortAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.CardinalityAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.ChildrenAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.CompositeAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.CumulativeCardinalityAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.CumulativeSumAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.DateHistogramAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.DateRangeAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.DerivativeAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.DiversifiedSamplerAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.ExtendedStatsAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.ExtendedStatsBucketAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.FiltersAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.GeoBoundsAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.GeoCentroidAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.GeoDistanceAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.GeoHashGridAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.GeoLineAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.GeoTileGridAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.GlobalAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.HistogramAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.IpRangeAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.InferenceAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.MatrixStatsAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.MaxAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.MaxBucketAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.MedianAbsoluteDeviationAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.MinAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.MinBucketAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.MissingAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.MovingAverageAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.MovingPercentilesAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.MovingFunctionAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.MultiTermsAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.NestedAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.NormalizeAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.ParentAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.PercentileRanksAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.PercentilesAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.PercentilesBucketAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.RangeAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.RareTermsAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.RateAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.ReverseNestedAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.SamplerAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.ScriptedMetricAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.SerialDifferencingAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.SignificantTermsAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.SignificantTextAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.StatsAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.StatsBucketAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.StringStatsAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.SumAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.SumBucketAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.TermsAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.TopHitsAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.TTestAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.TopMetricsAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.ValueCountAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.WeightedAverageAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
				case Elastic.Clients.Elasticsearch.Aggregations.VariableWidthHistogramAggregation variant:
					JsonSerializer.Serialize(writer, variant, options);
					break;
			}

			writer.WriteEndObject();
		}
	}

	public sealed partial class AggregationContainerDescriptor : DescriptorBase<AggregationContainerDescriptor>
	{
	}

	internal sealed class AggregationContainerDescriptorConverter : JsonConverter<AggregationContainerDescriptor>
	{
		public override AggregationContainerDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, AggregationContainerDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WriteEndObject();
		}
	}

	public partial class AggregationRange
	{
		[JsonInclude]
		[JsonPropertyName("from")]
		public Union<double?, string?>? From { get; set; }

		[JsonInclude]
		[JsonPropertyName("key")]
		public string? Key { get; set; }

		[JsonInclude]
		[JsonPropertyName("to")]
		public Union<double?, string?>? To { get; set; }
	}

	[JsonConverter(typeof(AggregationRangeDescriptorConverter))]
	public sealed partial class AggregationRangeDescriptor : DescriptorBase<AggregationRangeDescriptor>
	{
		internal Union<double?, string?>? _from;
		internal string? _key;
		internal Union<double?, string?>? _to;
	}

	internal sealed class AggregationRangeDescriptorConverter : JsonConverter<AggregationRangeDescriptor>
	{
		public override AggregationRangeDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, AggregationRangeDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value._from is not null)
			{
				writer.WritePropertyName("from");
				JsonSerializer.Serialize(writer, value._from, options);
			}

			if (!string.IsNullOrEmpty(value._key))
			{
				writer.WritePropertyName("key");
				writer.WriteStringValue(value._key);
			}

			if (value._to is not null)
			{
				writer.WritePropertyName("to");
				JsonSerializer.Serialize(writer, value._to, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class ArrayPercentilesItem
	{
		[JsonInclude]
		[JsonPropertyName("key")]
		public string Key { get; init; }

		[JsonInclude]
		[JsonPropertyName("value")]
		public object Value { get; init; }

		[JsonInclude]
		[JsonPropertyName("value_as_string")]
		public string? ValueAsString { get; init; }
	}

	public partial class AutoDateHistogramAggregate : Aggregations.MultiBucketAggregateBase<Elastic.Clients.Elasticsearch.Aggregations.DateHistogramBucket>
	{
		[JsonInclude]
		[JsonPropertyName("interval")]
		public string Interval { get; init; }
	}

	public partial class AutoDateHistogramAggregation : Aggregations.BucketAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "auto_date_histogram";
		[JsonInclude]
		[JsonPropertyName("buckets")]
		public int? Buckets { get; set; }

		[JsonInclude]
		[JsonPropertyName("field")]
		public string? Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("format")]
		public string? Format { get; set; }

		[JsonInclude]
		[JsonPropertyName("minimum_interval")]
		public Elastic.Clients.Elasticsearch.Aggregations.MinimumInterval? MinimumInterval { get; set; }

		[JsonInclude]
		[JsonPropertyName("missing")]
		public string? Missing { get; set; }

		[JsonInclude]
		[JsonPropertyName("offset")]
		public string? Offset { get; set; }

		[JsonInclude]
		[JsonPropertyName("params")]
		public Dictionary<string, object>? Params { get; set; }

		[JsonInclude]
		[JsonPropertyName("script")]
		public Elastic.Clients.Elasticsearch.Script? Script { get; set; }

		[JsonInclude]
		[JsonPropertyName("time_zone")]
		public string? TimeZone { get; set; }
	}

	[JsonConverter(typeof(AutoDateHistogramAggregationDescriptorConverter))]
	public sealed partial class AutoDateHistogramAggregationDescriptor : DescriptorBase<AutoDateHistogramAggregationDescriptor>
	{
		internal int? _buckets;
		internal string? _field;
		internal string? _format;
		internal Elastic.Clients.Elasticsearch.Aggregations.MinimumInterval? _minimumInterval;
		internal string? _missing;
		internal string? _offset;
		internal Dictionary<string, object>? _params;
		internal Elastic.Clients.Elasticsearch.Script? _script;
		internal string? _timeZone;
	}

	internal sealed class AutoDateHistogramAggregationDescriptorConverter : JsonConverter<AutoDateHistogramAggregationDescriptor>
	{
		public override AutoDateHistogramAggregationDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, AutoDateHistogramAggregationDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value._buckets.HasValue)
			{
				writer.WritePropertyName("buckets");
				writer.WriteNumberValue(value._buckets.Value);
			}

			if (value._field is not null)
			{
				writer.WritePropertyName("field");
				JsonSerializer.Serialize(writer, value._field, options);
			}

			if (!string.IsNullOrEmpty(value._format))
			{
				writer.WritePropertyName("format");
				writer.WriteStringValue(value._format);
			}

			if (value._minimumInterval is not null)
			{
				writer.WritePropertyName("minimum_interval");
				JsonSerializer.Serialize(writer, value._minimumInterval, options);
			}

			if (value._missing is not null)
			{
				writer.WritePropertyName("missing");
				JsonSerializer.Serialize(writer, value._missing, options);
			}

			if (!string.IsNullOrEmpty(value._offset))
			{
				writer.WritePropertyName("offset");
				writer.WriteStringValue(value._offset);
			}

			if (value._params is not null)
			{
				writer.WritePropertyName("params");
				JsonSerializer.Serialize(writer, value._params, options);
			}

			if (value._script is not null)
			{
				writer.WritePropertyName("script");
				JsonSerializer.Serialize(writer, value._script, options);
			}

			if (!string.IsNullOrEmpty(value._timeZone))
			{
				writer.WritePropertyName("time_zone");
				writer.WriteStringValue(value._timeZone);
			}

			writer.WriteEndObject();
		}
	}

	public partial class AverageAggregation : Aggregations.FormatMetricAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "avg";
	}

	[JsonConverter(typeof(AverageAggregationDescriptorConverter))]
	public sealed partial class AverageAggregationDescriptor : DescriptorBase<AverageAggregationDescriptor>
	{
	}

	internal sealed class AverageAggregationDescriptorConverter : JsonConverter<AverageAggregationDescriptor>
	{
		public override AverageAggregationDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, AverageAggregationDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WriteEndObject();
		}
	}

	public partial class AverageBucketAggregation : Aggregations.PipelineAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "avg_bucket";
	}

	[JsonConverter(typeof(AverageBucketAggregationDescriptorConverter))]
	public sealed partial class AverageBucketAggregationDescriptor : DescriptorBase<AverageBucketAggregationDescriptor>
	{
	}

	internal sealed class AverageBucketAggregationDescriptorConverter : JsonConverter<AverageBucketAggregationDescriptor>
	{
		public override AverageBucketAggregationDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, AverageBucketAggregationDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WriteEndObject();
		}
	}

	public partial class AvgAggregate : Aggregations.SingleMetricAggregateBase
	{
	}

	public partial class BoxPlotAggregate : Aggregations.AggregateBase
	{
		[JsonInclude]
		[JsonPropertyName("min")]
		public double Min { get; init; }

		[JsonInclude]
		[JsonPropertyName("max")]
		public double Max { get; init; }

		[JsonInclude]
		[JsonPropertyName("q1")]
		public double Q1 { get; init; }

		[JsonInclude]
		[JsonPropertyName("q2")]
		public double Q2 { get; init; }

		[JsonInclude]
		[JsonPropertyName("q3")]
		public double Q3 { get; init; }

		[JsonInclude]
		[JsonPropertyName("lower")]
		public double Lower { get; init; }

		[JsonInclude]
		[JsonPropertyName("upper")]
		public double Upper { get; init; }

		[JsonInclude]
		[JsonPropertyName("min_as_string")]
		public string? MinAsString { get; init; }

		[JsonInclude]
		[JsonPropertyName("max_as_string")]
		public string? MaxAsString { get; init; }

		[JsonInclude]
		[JsonPropertyName("q1_as_string")]
		public string? Q1AsString { get; init; }

		[JsonInclude]
		[JsonPropertyName("q2_as_string")]
		public string? Q2AsString { get; init; }

		[JsonInclude]
		[JsonPropertyName("q3_as_string")]
		public string? Q3AsString { get; init; }

		[JsonInclude]
		[JsonPropertyName("lower_as_string")]
		public string? LowerAsString { get; init; }

		[JsonInclude]
		[JsonPropertyName("upper_as_string")]
		public string? UpperAsString { get; init; }
	}

	public partial class BoxplotAggregation : Aggregations.MetricAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "boxplot";
		[JsonInclude]
		[JsonPropertyName("compression")]
		public double? Compression { get; set; }
	}

	[JsonConverter(typeof(BoxplotAggregationDescriptorConverter))]
	public sealed partial class BoxplotAggregationDescriptor : DescriptorBase<BoxplotAggregationDescriptor>
	{
		internal double? _compression;
	}

	internal sealed class BoxplotAggregationDescriptorConverter : JsonConverter<BoxplotAggregationDescriptor>
	{
		public override BoxplotAggregationDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, BoxplotAggregationDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value._compression.HasValue)
			{
				writer.WritePropertyName("compression");
				writer.WriteNumberValue(value._compression.Value);
			}

			writer.WriteEndObject();
		}
	}

	public abstract partial class BucketAggregationBase : Aggregations.Aggregation
	{
	}

	[JsonConverter(typeof(BucketAggregationBaseDescriptorConverter))]
	public sealed partial class BucketAggregationBaseDescriptor : DescriptorBase<BucketAggregationBaseDescriptor>
	{
	}

	internal sealed class BucketAggregationBaseDescriptorConverter : JsonConverter<BucketAggregationBaseDescriptor>
	{
		public override BucketAggregationBaseDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, BucketAggregationBaseDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WriteEndObject();
		}
	}

	public partial class BucketMetricValueAggregate : Aggregations.SingleMetricAggregateBase
	{
		[JsonInclude]
		[JsonPropertyName("keys")]
		public IReadOnlyCollection<string> Keys { get; init; }
	}

	public partial class BucketScriptAggregation : Aggregations.PipelineAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "bucket_script";
		[JsonInclude]
		[JsonPropertyName("script")]
		public Elastic.Clients.Elasticsearch.Script? Script { get; set; }
	}

	[JsonConverter(typeof(BucketScriptAggregationDescriptorConverter))]
	public sealed partial class BucketScriptAggregationDescriptor : DescriptorBase<BucketScriptAggregationDescriptor>
	{
		internal Elastic.Clients.Elasticsearch.Script? _script;
	}

	internal sealed class BucketScriptAggregationDescriptorConverter : JsonConverter<BucketScriptAggregationDescriptor>
	{
		public override BucketScriptAggregationDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, BucketScriptAggregationDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value._script is not null)
			{
				writer.WritePropertyName("script");
				JsonSerializer.Serialize(writer, value._script, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class BucketSelectorAggregation : Aggregations.PipelineAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "bucket_selector";
		[JsonInclude]
		[JsonPropertyName("script")]
		public Elastic.Clients.Elasticsearch.Script? Script { get; set; }
	}

	[JsonConverter(typeof(BucketSelectorAggregationDescriptorConverter))]
	public sealed partial class BucketSelectorAggregationDescriptor : DescriptorBase<BucketSelectorAggregationDescriptor>
	{
		internal Elastic.Clients.Elasticsearch.Script? _script;
	}

	internal sealed class BucketSelectorAggregationDescriptorConverter : JsonConverter<BucketSelectorAggregationDescriptor>
	{
		public override BucketSelectorAggregationDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, BucketSelectorAggregationDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value._script is not null)
			{
				writer.WritePropertyName("script");
				JsonSerializer.Serialize(writer, value._script, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class BucketSortAggregation : Aggregations.Aggregation, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "bucket_sort";
		[JsonInclude]
		[JsonPropertyName("from")]
		public int? From { get; set; }

		[JsonInclude]
		[JsonPropertyName("gap_policy")]
		public Elastic.Clients.Elasticsearch.Aggregations.GapPolicy? GapPolicy { get; set; }

		[JsonInclude]
		[JsonPropertyName("size")]
		public int? Size { get; set; }

		[JsonInclude]
		[JsonPropertyName("sort")]
		public Elastic.Clients.Elasticsearch.Sort? Sort { get; set; }
	}

	[JsonConverter(typeof(BucketSortAggregationDescriptorConverter))]
	public sealed partial class BucketSortAggregationDescriptor : DescriptorBase<BucketSortAggregationDescriptor>
	{
		internal int? _from;
		internal Elastic.Clients.Elasticsearch.Aggregations.GapPolicy? _gapPolicy;
		internal int? _size;
		internal Elastic.Clients.Elasticsearch.Sort? _sort;
	}

	internal sealed class BucketSortAggregationDescriptorConverter : JsonConverter<BucketSortAggregationDescriptor>
	{
		public override BucketSortAggregationDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, BucketSortAggregationDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value._from.HasValue)
			{
				writer.WritePropertyName("from");
				writer.WriteNumberValue(value._from.Value);
			}

			if (value._gapPolicy is not null)
			{
				writer.WritePropertyName("gap_policy");
				JsonSerializer.Serialize(writer, value._gapPolicy, options);
			}

			if (value._size.HasValue)
			{
				writer.WritePropertyName("size");
				writer.WriteNumberValue(value._size.Value);
			}

			if (value._sort is not null)
			{
				writer.WritePropertyName("sort");
				JsonSerializer.Serialize(writer, value._sort, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class CardinalityAggregate : Aggregations.AggregateBase
	{
		[JsonInclude]
		[JsonPropertyName("value")]
		public long Value { get; init; }
	}

	public partial class CardinalityAggregation : Aggregations.MetricAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "cardinality";
		[JsonInclude]
		[JsonPropertyName("precision_threshold")]
		public int? PrecisionThreshold { get; set; }

		[JsonInclude]
		[JsonPropertyName("rehash")]
		public bool? Rehash { get; set; }
	}

	[JsonConverter(typeof(CardinalityAggregationDescriptorConverter))]
	public sealed partial class CardinalityAggregationDescriptor : DescriptorBase<CardinalityAggregationDescriptor>
	{
		internal int? _precisionThreshold;
		internal bool? _rehash;
	}

	internal sealed class CardinalityAggregationDescriptorConverter : JsonConverter<CardinalityAggregationDescriptor>
	{
		public override CardinalityAggregationDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, CardinalityAggregationDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value._precisionThreshold.HasValue)
			{
				writer.WritePropertyName("precision_threshold");
				writer.WriteNumberValue(value._precisionThreshold.Value);
			}

			if (value._rehash.HasValue)
			{
				writer.WritePropertyName("rehash");
				writer.WriteBooleanValue(value._rehash.Value);
			}

			writer.WriteEndObject();
		}
	}

	public partial class ChildrenAggregate : Aggregations.MultiBucketAggregateBase<Elastic.Clients.Elasticsearch.Aggregations.ChildrenAggregateBucket>
	{
	}

	public partial class ChildrenAggregateBucket : Aggregations.MultiBucketBase
	{
	}

	public partial class ChildrenAggregation : Aggregations.BucketAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "children";
		[JsonInclude]
		[JsonPropertyName("type")]
		public string? Type { get; set; }
	}

	[JsonConverter(typeof(ChildrenAggregationDescriptorConverter))]
	public sealed partial class ChildrenAggregationDescriptor : DescriptorBase<ChildrenAggregationDescriptor>
	{
		internal string? _type;
	}

	internal sealed class ChildrenAggregationDescriptorConverter : JsonConverter<ChildrenAggregationDescriptor>
	{
		public override ChildrenAggregationDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, ChildrenAggregationDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value._type is not null)
			{
				writer.WritePropertyName("type");
				JsonSerializer.Serialize(writer, value._type, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class ChiSquareHeuristic
	{
		[JsonInclude]
		[JsonPropertyName("background_is_superset")]
		public bool BackgroundIsSuperset { get; set; }

		[JsonInclude]
		[JsonPropertyName("include_negatives")]
		public bool IncludeNegatives { get; set; }
	}

	[JsonConverter(typeof(ChiSquareHeuristicDescriptorConverter))]
	public sealed partial class ChiSquareHeuristicDescriptor : DescriptorBase<ChiSquareHeuristicDescriptor>
	{
		internal bool _backgroundIsSuperset;
		internal bool _includeNegatives;
	}

	internal sealed class ChiSquareHeuristicDescriptorConverter : JsonConverter<ChiSquareHeuristicDescriptor>
	{
		public override ChiSquareHeuristicDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, ChiSquareHeuristicDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("background_is_superset");
			writer.WriteBooleanValue(value._backgroundIsSuperset);
			writer.WritePropertyName("include_negatives");
			writer.WriteBooleanValue(value._includeNegatives);
			writer.WriteEndObject();
		}
	}

	public partial class ClassificationInferenceOptions
	{
		[JsonInclude]
		[JsonPropertyName("num_top_classes")]
		public int? NumTopClasses { get; set; }

		[JsonInclude]
		[JsonPropertyName("num_top_feature_importance_values")]
		public int? NumTopFeatureImportanceValues { get; set; }

		[JsonInclude]
		[JsonPropertyName("prediction_field_type")]
		public string? PredictionFieldType { get; set; }

		[JsonInclude]
		[JsonPropertyName("results_field")]
		public string? ResultsField { get; set; }

		[JsonInclude]
		[JsonPropertyName("top_classes_results_field")]
		public string? TopClassesResultsField { get; set; }
	}

	[JsonConverter(typeof(ClassificationInferenceOptionsDescriptorConverter))]
	public sealed partial class ClassificationInferenceOptionsDescriptor : DescriptorBase<ClassificationInferenceOptionsDescriptor>
	{
		internal int? _numTopClasses;
		internal int? _numTopFeatureImportanceValues;
		internal string? _predictionFieldType;
		internal string? _resultsField;
		internal string? _topClassesResultsField;
	}

	internal sealed class ClassificationInferenceOptionsDescriptorConverter : JsonConverter<ClassificationInferenceOptionsDescriptor>
	{
		public override ClassificationInferenceOptionsDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, ClassificationInferenceOptionsDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value._numTopClasses.HasValue)
			{
				writer.WritePropertyName("num_top_classes");
				writer.WriteNumberValue(value._numTopClasses.Value);
			}

			if (value._numTopFeatureImportanceValues.HasValue)
			{
				writer.WritePropertyName("num_top_feature_importance_values");
				writer.WriteNumberValue(value._numTopFeatureImportanceValues.Value);
			}

			if (!string.IsNullOrEmpty(value._predictionFieldType))
			{
				writer.WritePropertyName("prediction_field_type");
				writer.WriteStringValue(value._predictionFieldType);
			}

			if (!string.IsNullOrEmpty(value._resultsField))
			{
				writer.WritePropertyName("results_field");
				writer.WriteStringValue(value._resultsField);
			}

			if (!string.IsNullOrEmpty(value._topClassesResultsField))
			{
				writer.WritePropertyName("top_classes_results_field");
				writer.WriteStringValue(value._topClassesResultsField);
			}

			writer.WriteEndObject();
		}
	}

	public partial class CompositeAggregate : Aggregations.MultiBucketAggregateBase<Elastic.Clients.Elasticsearch.Aggregations.CompositeBucket>
	{
		[JsonInclude]
		[JsonPropertyName("after_key")]
		public Dictionary<string, object>? AfterKey { get; init; }
	}

	public partial class CompositeAggregation : Aggregations.BucketAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "composite";
		[JsonInclude]
		[JsonPropertyName("after")]
		public Dictionary<string, object>? After { get; set; }

		[JsonInclude]
		[JsonPropertyName("size")]
		public int? Size { get; set; }

		[JsonInclude]
		[JsonPropertyName("sources")]
		public IEnumerable<Dictionary<string, Elastic.Clients.Elasticsearch.Aggregations.CompositeAggregationSource>>? Sources { get; set; }
	}

	[JsonConverter(typeof(CompositeAggregationDescriptorConverter))]
	public sealed partial class CompositeAggregationDescriptor : DescriptorBase<CompositeAggregationDescriptor>
	{
		internal Dictionary<string, object>? _after;
		internal int? _size;
		internal IEnumerable<Dictionary<string, Elastic.Clients.Elasticsearch.Aggregations.CompositeAggregationSource>>? _sources;
	}

	internal sealed class CompositeAggregationDescriptorConverter : JsonConverter<CompositeAggregationDescriptor>
	{
		public override CompositeAggregationDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, CompositeAggregationDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value._after is not null)
			{
				writer.WritePropertyName("after");
				JsonSerializer.Serialize(writer, value._after, options);
			}

			if (value._size.HasValue)
			{
				writer.WritePropertyName("size");
				writer.WriteNumberValue(value._size.Value);
			}

			if (value._sources is not null)
			{
				writer.WritePropertyName("sources");
				JsonSerializer.Serialize(writer, value._sources, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class CompositeAggregationSource
	{
		[JsonInclude]
		[JsonPropertyName("terms")]
		public Elastic.Clients.Elasticsearch.Aggregations.TermsAggregation? Terms { get; set; }

		[JsonInclude]
		[JsonPropertyName("histogram")]
		public Elastic.Clients.Elasticsearch.Aggregations.HistogramAggregation? Histogram { get; set; }

		[JsonInclude]
		[JsonPropertyName("date_histogram")]
		public Elastic.Clients.Elasticsearch.Aggregations.DateHistogramAggregation? DateHistogram { get; set; }

		[JsonInclude]
		[JsonPropertyName("geotile_grid")]
		public Elastic.Clients.Elasticsearch.Aggregations.GeoTileGridAggregation? GeotileGrid { get; set; }
	}

	[JsonConverter(typeof(CompositeAggregationSourceDescriptorConverter))]
	public sealed partial class CompositeAggregationSourceDescriptor : DescriptorBase<CompositeAggregationSourceDescriptor>
	{
		internal Elastic.Clients.Elasticsearch.Aggregations.TermsAggregation? _terms;
		internal Elastic.Clients.Elasticsearch.Aggregations.HistogramAggregation? _histogram;
		internal Elastic.Clients.Elasticsearch.Aggregations.DateHistogramAggregation? _dateHistogram;
		internal Elastic.Clients.Elasticsearch.Aggregations.GeoTileGridAggregation? _geotileGrid;
	}

	internal sealed class CompositeAggregationSourceDescriptorConverter : JsonConverter<CompositeAggregationSourceDescriptor>
	{
		public override CompositeAggregationSourceDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, CompositeAggregationSourceDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value._terms is not null)
			{
				writer.WritePropertyName("terms");
				JsonSerializer.Serialize(writer, value._terms, options);
			}

			if (value._histogram is not null)
			{
				writer.WritePropertyName("histogram");
				JsonSerializer.Serialize(writer, value._histogram, options);
			}

			if (value._dateHistogram is not null)
			{
				writer.WritePropertyName("date_histogram");
				JsonSerializer.Serialize(writer, value._dateHistogram, options);
			}

			if (value._geotileGrid is not null)
			{
				writer.WritePropertyName("geotile_grid");
				JsonSerializer.Serialize(writer, value._geotileGrid, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class CompositeBucket : Aggregations.MultiBucketBase
	{
		[JsonInclude]
		[JsonPropertyName("key")]
		public Dictionary<string, object> Key { get; init; }
	}

	public partial class CumulativeCardinalityAggregate : Aggregations.AggregateBase
	{
		[JsonInclude]
		[JsonPropertyName("value")]
		public long Value { get; init; }

		[JsonInclude]
		[JsonPropertyName("value_as_string")]
		public string? ValueAsString { get; init; }
	}

	public partial class CumulativeCardinalityAggregation : Aggregations.PipelineAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "cumulative_cardinality";
	}

	[JsonConverter(typeof(CumulativeCardinalityAggregationDescriptorConverter))]
	public sealed partial class CumulativeCardinalityAggregationDescriptor : DescriptorBase<CumulativeCardinalityAggregationDescriptor>
	{
	}

	internal sealed class CumulativeCardinalityAggregationDescriptorConverter : JsonConverter<CumulativeCardinalityAggregationDescriptor>
	{
		public override CumulativeCardinalityAggregationDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, CumulativeCardinalityAggregationDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WriteEndObject();
		}
	}

	public partial class CumulativeSumAggregation : Aggregations.PipelineAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "cumulative_sum";
	}

	[JsonConverter(typeof(CumulativeSumAggregationDescriptorConverter))]
	public sealed partial class CumulativeSumAggregationDescriptor : DescriptorBase<CumulativeSumAggregationDescriptor>
	{
	}

	internal sealed class CumulativeSumAggregationDescriptorConverter : JsonConverter<CumulativeSumAggregationDescriptor>
	{
		public override CumulativeSumAggregationDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, CumulativeSumAggregationDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WriteEndObject();
		}
	}

	public partial class DateHistogramAggregate : Aggregations.MultiBucketAggregateBase<Elastic.Clients.Elasticsearch.Aggregations.DateHistogramBucket>
	{
	}

	public partial class DateHistogramAggregation : Aggregations.BucketAggregationBase, IAggregationContainerVariant, TransformManagement.IPivotGroupByContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "date_histogram";
		[JsonIgnore]
		string TransformManagement.IPivotGroupByContainerVariant.PivotGroupByContainerVariantName => "date_histogram";
		[JsonInclude]
		[JsonPropertyName("calendar_interval")]
		public Union<Elastic.Clients.Elasticsearch.Aggregations.DateInterval?, Time?>? CalendarInterval { get; set; }

		[JsonInclude]
		[JsonPropertyName("field")]
		public string? Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("fixed_interval")]
		public Union<Elastic.Clients.Elasticsearch.Aggregations.DateInterval?, Time?>? FixedInterval { get; set; }

		[JsonInclude]
		[JsonPropertyName("format")]
		public string? Format { get; set; }

		[JsonInclude]
		[JsonPropertyName("interval")]
		public Union<Elastic.Clients.Elasticsearch.Aggregations.DateInterval?, Time?>? Interval { get; set; }

		[JsonInclude]
		[JsonPropertyName("min_doc_count")]
		public int? MinDocCount { get; set; }

		[JsonInclude]
		[JsonPropertyName("missing")]
		public string? Missing { get; set; }

		[JsonInclude]
		[JsonPropertyName("offset")]
		public Time? Offset { get; set; }

		[JsonInclude]
		[JsonPropertyName("order")]
		public Elastic.Clients.Elasticsearch.Aggregations.HistogramOrder? Order { get; set; }

		[JsonInclude]
		[JsonPropertyName("params")]
		public Dictionary<string, object>? Params { get; set; }

		[JsonInclude]
		[JsonPropertyName("script")]
		public Elastic.Clients.Elasticsearch.Script? Script { get; set; }

		[JsonInclude]
		[JsonPropertyName("time_zone")]
		public string? TimeZone { get; set; }

		[JsonInclude]
		[JsonPropertyName("keyed")]
		public bool? Keyed { get; set; }
	}

	[JsonConverter(typeof(DateHistogramAggregationDescriptorConverter))]
	public sealed partial class DateHistogramAggregationDescriptor : DescriptorBase<DateHistogramAggregationDescriptor>
	{
		internal Union<Elastic.Clients.Elasticsearch.Aggregations.DateInterval?, Time?>? _calendarInterval;
		internal string? _field;
		internal Union<Elastic.Clients.Elasticsearch.Aggregations.DateInterval?, Time?>? _fixedInterval;
		internal string? _format;
		internal Union<Elastic.Clients.Elasticsearch.Aggregations.DateInterval?, Time?>? _interval;
		internal int? _minDocCount;
		internal string? _missing;
		internal Time? _offset;
		internal Elastic.Clients.Elasticsearch.Aggregations.HistogramOrder? _order;
		internal Dictionary<string, object>? _params;
		internal Elastic.Clients.Elasticsearch.Script? _script;
		internal string? _timeZone;
		internal bool? _keyed;
	}

	internal sealed class DateHistogramAggregationDescriptorConverter : JsonConverter<DateHistogramAggregationDescriptor>
	{
		public override DateHistogramAggregationDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, DateHistogramAggregationDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value._calendarInterval is not null)
			{
				writer.WritePropertyName("calendar_interval");
				JsonSerializer.Serialize(writer, value._calendarInterval, options);
			}

			if (value._field is not null)
			{
				writer.WritePropertyName("field");
				JsonSerializer.Serialize(writer, value._field, options);
			}

			if (value._fixedInterval is not null)
			{
				writer.WritePropertyName("fixed_interval");
				JsonSerializer.Serialize(writer, value._fixedInterval, options);
			}

			if (!string.IsNullOrEmpty(value._format))
			{
				writer.WritePropertyName("format");
				writer.WriteStringValue(value._format);
			}

			if (value._interval is not null)
			{
				writer.WritePropertyName("interval");
				JsonSerializer.Serialize(writer, value._interval, options);
			}

			if (value._minDocCount.HasValue)
			{
				writer.WritePropertyName("min_doc_count");
				writer.WriteNumberValue(value._minDocCount.Value);
			}

			if (value._missing is not null)
			{
				writer.WritePropertyName("missing");
				JsonSerializer.Serialize(writer, value._missing, options);
			}

			if (value._offset is not null)
			{
				writer.WritePropertyName("offset");
				JsonSerializer.Serialize(writer, value._offset, options);
			}

			if (value._order is not null)
			{
				writer.WritePropertyName("order");
				JsonSerializer.Serialize(writer, value._order, options);
			}

			if (value._params is not null)
			{
				writer.WritePropertyName("params");
				JsonSerializer.Serialize(writer, value._params, options);
			}

			if (value._script is not null)
			{
				writer.WritePropertyName("script");
				JsonSerializer.Serialize(writer, value._script, options);
			}

			if (!string.IsNullOrEmpty(value._timeZone))
			{
				writer.WritePropertyName("time_zone");
				writer.WriteStringValue(value._timeZone);
			}

			if (value._keyed.HasValue)
			{
				writer.WritePropertyName("keyed");
				writer.WriteBooleanValue(value._keyed.Value);
			}

			writer.WriteEndObject();
		}
	}

	public partial class DateHistogramBucket : Aggregations.MultiBucketBase
	{
		[JsonInclude]
		[JsonPropertyName("key_as_string")]
		public string? KeyAsString { get; init; }

		[JsonInclude]
		[JsonPropertyName("key")]
		public Elastic.Clients.Elasticsearch.EpochMillis Key { get; init; }
	}

	public partial class DateRangeAggregate : Aggregations.RangeAggregate
	{
	}

	public partial class DateRangeAggregation : Aggregations.BucketAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "date_range";
		[JsonInclude]
		[JsonPropertyName("field")]
		public string? Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("format")]
		public string? Format { get; set; }

		[JsonInclude]
		[JsonPropertyName("missing")]
		public Elastic.Clients.Elasticsearch.Aggregations.Missing? Missing { get; set; }

		[JsonInclude]
		[JsonPropertyName("ranges")]
		public IEnumerable<Elastic.Clients.Elasticsearch.Aggregations.DateRangeExpression>? Ranges { get; set; }

		[JsonInclude]
		[JsonPropertyName("time_zone")]
		public string? TimeZone { get; set; }

		[JsonInclude]
		[JsonPropertyName("keyed")]
		public bool? Keyed { get; set; }
	}

	[JsonConverter(typeof(DateRangeAggregationDescriptorConverter))]
	public sealed partial class DateRangeAggregationDescriptor : DescriptorBase<DateRangeAggregationDescriptor>
	{
		internal string? _field;
		internal string? _format;
		internal Elastic.Clients.Elasticsearch.Aggregations.Missing? _missing;
		internal IEnumerable<Elastic.Clients.Elasticsearch.Aggregations.DateRangeExpression>? _ranges;
		internal string? _timeZone;
		internal bool? _keyed;
	}

	internal sealed class DateRangeAggregationDescriptorConverter : JsonConverter<DateRangeAggregationDescriptor>
	{
		public override DateRangeAggregationDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, DateRangeAggregationDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value._field is not null)
			{
				writer.WritePropertyName("field");
				JsonSerializer.Serialize(writer, value._field, options);
			}

			if (!string.IsNullOrEmpty(value._format))
			{
				writer.WritePropertyName("format");
				writer.WriteStringValue(value._format);
			}

			if (value._missing is not null)
			{
				writer.WritePropertyName("missing");
				JsonSerializer.Serialize(writer, value._missing, options);
			}

			if (value._ranges is not null)
			{
				writer.WritePropertyName("ranges");
				JsonSerializer.Serialize(writer, value._ranges, options);
			}

			if (!string.IsNullOrEmpty(value._timeZone))
			{
				writer.WritePropertyName("time_zone");
				writer.WriteStringValue(value._timeZone);
			}

			if (value._keyed.HasValue)
			{
				writer.WritePropertyName("keyed");
				writer.WriteBooleanValue(value._keyed.Value);
			}

			writer.WriteEndObject();
		}
	}

	public partial class DateRangeExpression
	{
		[JsonInclude]
		[JsonPropertyName("from")]
		public Union<string?, float?>? From { get; set; }

		[JsonInclude]
		[JsonPropertyName("from_as_string")]
		public string? FromAsString { get; set; }

		[JsonInclude]
		[JsonPropertyName("to_as_string")]
		public string? ToAsString { get; set; }

		[JsonInclude]
		[JsonPropertyName("key")]
		public string? Key { get; set; }

		[JsonInclude]
		[JsonPropertyName("to")]
		public Union<string?, float?>? To { get; set; }

		[JsonInclude]
		[JsonPropertyName("doc_count")]
		public long? DocCount { get; set; }
	}

	[JsonConverter(typeof(DateRangeExpressionDescriptorConverter))]
	public sealed partial class DateRangeExpressionDescriptor : DescriptorBase<DateRangeExpressionDescriptor>
	{
		internal Union<string?, float?>? _from;
		internal string? _fromAsString;
		internal string? _toAsString;
		internal string? _key;
		internal Union<string?, float?>? _to;
		internal long? _docCount;
	}

	internal sealed class DateRangeExpressionDescriptorConverter : JsonConverter<DateRangeExpressionDescriptor>
	{
		public override DateRangeExpressionDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, DateRangeExpressionDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value._from is not null)
			{
				writer.WritePropertyName("from");
				JsonSerializer.Serialize(writer, value._from, options);
			}

			if (!string.IsNullOrEmpty(value._fromAsString))
			{
				writer.WritePropertyName("from_as_string");
				writer.WriteStringValue(value._fromAsString);
			}

			if (!string.IsNullOrEmpty(value._toAsString))
			{
				writer.WritePropertyName("to_as_string");
				writer.WriteStringValue(value._toAsString);
			}

			if (!string.IsNullOrEmpty(value._key))
			{
				writer.WritePropertyName("key");
				writer.WriteStringValue(value._key);
			}

			if (value._to is not null)
			{
				writer.WritePropertyName("to");
				JsonSerializer.Serialize(writer, value._to, options);
			}

			if (value._docCount.HasValue)
			{
				writer.WritePropertyName("doc_count");
				writer.WriteNumberValue(value._docCount.Value);
			}

			writer.WriteEndObject();
		}
	}

	public partial class DerivativeAggregate : Aggregations.SingleMetricAggregateBase
	{
		[JsonInclude]
		[JsonPropertyName("normalized_value")]
		public double? NormalizedValue { get; init; }

		[JsonInclude]
		[JsonPropertyName("normalized_value_as_string")]
		public string? NormalizedValueAsString { get; init; }
	}

	public partial class DerivativeAggregation : Aggregations.PipelineAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "derivative";
	}

	[JsonConverter(typeof(DerivativeAggregationDescriptorConverter))]
	public sealed partial class DerivativeAggregationDescriptor : DescriptorBase<DerivativeAggregationDescriptor>
	{
	}

	internal sealed class DerivativeAggregationDescriptorConverter : JsonConverter<DerivativeAggregationDescriptor>
	{
		public override DerivativeAggregationDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, DerivativeAggregationDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WriteEndObject();
		}
	}

	public partial class DiversifiedSamplerAggregation : Aggregations.BucketAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "diversified_sampler";
		[JsonInclude]
		[JsonPropertyName("execution_hint")]
		public Elastic.Clients.Elasticsearch.Aggregations.SamplerAggregationExecutionHint? ExecutionHint { get; set; }

		[JsonInclude]
		[JsonPropertyName("max_docs_per_value")]
		public int? MaxDocsPerValue { get; set; }

		[JsonInclude]
		[JsonPropertyName("script")]
		public Elastic.Clients.Elasticsearch.Script? Script { get; set; }

		[JsonInclude]
		[JsonPropertyName("shard_size")]
		public int? ShardSize { get; set; }

		[JsonInclude]
		[JsonPropertyName("field")]
		public string? Field { get; set; }
	}

	[JsonConverter(typeof(DiversifiedSamplerAggregationDescriptorConverter))]
	public sealed partial class DiversifiedSamplerAggregationDescriptor : DescriptorBase<DiversifiedSamplerAggregationDescriptor>
	{
		internal Elastic.Clients.Elasticsearch.Aggregations.SamplerAggregationExecutionHint? _executionHint;
		internal int? _maxDocsPerValue;
		internal Elastic.Clients.Elasticsearch.Script? _script;
		internal int? _shardSize;
		internal string? _field;
	}

	internal sealed class DiversifiedSamplerAggregationDescriptorConverter : JsonConverter<DiversifiedSamplerAggregationDescriptor>
	{
		public override DiversifiedSamplerAggregationDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, DiversifiedSamplerAggregationDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value._executionHint is not null)
			{
				writer.WritePropertyName("execution_hint");
				JsonSerializer.Serialize(writer, value._executionHint, options);
			}

			if (value._maxDocsPerValue.HasValue)
			{
				writer.WritePropertyName("max_docs_per_value");
				writer.WriteNumberValue(value._maxDocsPerValue.Value);
			}

			if (value._script is not null)
			{
				writer.WritePropertyName("script");
				JsonSerializer.Serialize(writer, value._script, options);
			}

			if (value._shardSize.HasValue)
			{
				writer.WritePropertyName("shard_size");
				writer.WriteNumberValue(value._shardSize.Value);
			}

			if (value._field is not null)
			{
				writer.WritePropertyName("field");
				JsonSerializer.Serialize(writer, value._field, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class DoubleTermsAggregate : Aggregations.TermsAggregateBase<Elastic.Clients.Elasticsearch.Aggregations.DoubleTermsBucket>
	{
	}

	public partial class DoubleTermsBucket : Aggregations.TermsBucketBase
	{
		[JsonInclude]
		[JsonPropertyName("key")]
		public double Key { get; init; }

		[JsonInclude]
		[JsonPropertyName("key_as_string")]
		public string? KeyAsString { get; init; }
	}

	public partial class EwmaModelSettings
	{
		[JsonInclude]
		[JsonPropertyName("alpha")]
		public float? Alpha { get; init; }
	}

	public partial class ExtendedBounds<T>
	{
		[JsonInclude]
		[JsonPropertyName("max")]
		public T Max { get; set; }

		[JsonInclude]
		[JsonPropertyName("min")]
		public T Min { get; set; }
	}

	public sealed partial class ExtendedBoundsDescriptor<T> : DescriptorBase<ExtendedBoundsDescriptor<T>>
	{
		internal T _max;
		internal T _min;
	}

	public partial class ExtendedStatsAggregate : Aggregations.StatsAggregate
	{
		[JsonInclude]
		[JsonPropertyName("sum_of_squares")]
		public object SumOfSquares { get; init; }

		[JsonInclude]
		[JsonPropertyName("variance")]
		public object Variance { get; init; }

		[JsonInclude]
		[JsonPropertyName("variance_population")]
		public object VariancePopulation { get; init; }

		[JsonInclude]
		[JsonPropertyName("variance_sampling")]
		public object VarianceSampling { get; init; }

		[JsonInclude]
		[JsonPropertyName("std_deviation")]
		public object StdDeviation { get; init; }

		[JsonInclude]
		[JsonPropertyName("std_deviation_bounds")]
		public Elastic.Clients.Elasticsearch.Aggregations.StandardDeviationBounds? StdDeviationBounds { get; init; }

		[JsonInclude]
		[JsonPropertyName("sum_of_squares_as_string")]
		public string? SumOfSquaresAsString { get; init; }

		[JsonInclude]
		[JsonPropertyName("variance_as_string")]
		public string? VarianceAsString { get; init; }

		[JsonInclude]
		[JsonPropertyName("variance_population_as_string")]
		public string? VariancePopulationAsString { get; init; }

		[JsonInclude]
		[JsonPropertyName("variance_sampling_as_string")]
		public string? VarianceSamplingAsString { get; init; }

		[JsonInclude]
		[JsonPropertyName("std_deviation_as_string")]
		public string? StdDeviationAsString { get; init; }

		[JsonInclude]
		[JsonPropertyName("std_deviation_bounds_as_string")]
		public Elastic.Clients.Elasticsearch.Aggregations.StandardDeviationBoundsAsString? StdDeviationBoundsAsString { get; init; }
	}

	public partial class ExtendedStatsAggregation : Aggregations.FormatMetricAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "extended_stats";
		[JsonInclude]
		[JsonPropertyName("sigma")]
		public double? Sigma { get; set; }
	}

	[JsonConverter(typeof(ExtendedStatsAggregationDescriptorConverter))]
	public sealed partial class ExtendedStatsAggregationDescriptor : DescriptorBase<ExtendedStatsAggregationDescriptor>
	{
		internal double? _sigma;
	}

	internal sealed class ExtendedStatsAggregationDescriptorConverter : JsonConverter<ExtendedStatsAggregationDescriptor>
	{
		public override ExtendedStatsAggregationDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, ExtendedStatsAggregationDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value._sigma.HasValue)
			{
				writer.WritePropertyName("sigma");
				writer.WriteNumberValue(value._sigma.Value);
			}

			writer.WriteEndObject();
		}
	}

	public partial class ExtendedStatsBucketAggregate : Aggregations.ExtendedStatsAggregate
	{
	}

	public partial class ExtendedStatsBucketAggregation : Aggregations.PipelineAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "extended_stats_bucket";
		[JsonInclude]
		[JsonPropertyName("sigma")]
		public double? Sigma { get; set; }
	}

	[JsonConverter(typeof(ExtendedStatsBucketAggregationDescriptorConverter))]
	public sealed partial class ExtendedStatsBucketAggregationDescriptor : DescriptorBase<ExtendedStatsBucketAggregationDescriptor>
	{
		internal double? _sigma;
	}

	internal sealed class ExtendedStatsBucketAggregationDescriptorConverter : JsonConverter<ExtendedStatsBucketAggregationDescriptor>
	{
		public override ExtendedStatsBucketAggregationDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, ExtendedStatsBucketAggregationDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value._sigma.HasValue)
			{
				writer.WritePropertyName("sigma");
				writer.WriteNumberValue(value._sigma.Value);
			}

			writer.WriteEndObject();
		}
	}

	public partial class FilterAggregate : Aggregations.SingleBucketAggregateBase
	{
	}

	public partial class FiltersAggregate : Aggregations.MultiBucketAggregateBase<Elastic.Clients.Elasticsearch.Aggregations.FiltersBucket>
	{
	}

	public partial class FiltersAggregation : Aggregations.BucketAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "filters";
		[JsonInclude]
		[JsonPropertyName("filters")]
		public Union<Dictionary<string, Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer>?, IEnumerable<Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer>?>? Filters { get; set; }

		[JsonInclude]
		[JsonPropertyName("other_bucket")]
		public bool? OtherBucket { get; set; }

		[JsonInclude]
		[JsonPropertyName("other_bucket_key")]
		public string? OtherBucketKey { get; set; }

		[JsonInclude]
		[JsonPropertyName("keyed")]
		public bool? Keyed { get; set; }
	}

	[JsonConverter(typeof(FiltersAggregationDescriptorConverter))]
	public sealed partial class FiltersAggregationDescriptor : DescriptorBase<FiltersAggregationDescriptor>
	{
		internal Union<Dictionary<string, Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer>?, IEnumerable<Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer>?>? _filters;
		internal bool? _otherBucket;
		internal string? _otherBucketKey;
		internal bool? _keyed;
	}

	internal sealed class FiltersAggregationDescriptorConverter : JsonConverter<FiltersAggregationDescriptor>
	{
		public override FiltersAggregationDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, FiltersAggregationDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value._filters is not null)
			{
				writer.WritePropertyName("filters");
				JsonSerializer.Serialize(writer, value._filters, options);
			}

			if (value._otherBucket.HasValue)
			{
				writer.WritePropertyName("other_bucket");
				writer.WriteBooleanValue(value._otherBucket.Value);
			}

			if (!string.IsNullOrEmpty(value._otherBucketKey))
			{
				writer.WritePropertyName("other_bucket_key");
				writer.WriteStringValue(value._otherBucketKey);
			}

			if (value._keyed.HasValue)
			{
				writer.WritePropertyName("keyed");
				writer.WriteBooleanValue(value._keyed.Value);
			}

			writer.WriteEndObject();
		}
	}

	public partial class FiltersBucket : Aggregations.MultiBucketBase
	{
	}

	public abstract partial class FormatMetricAggregationBase : Aggregations.MetricAggregationBase
	{
		[JsonInclude]
		[JsonPropertyName("format")]
		public string? Format { get; set; }
	}

	[JsonConverter(typeof(FormatMetricAggregationBaseDescriptorConverter))]
	public sealed partial class FormatMetricAggregationBaseDescriptor : DescriptorBase<FormatMetricAggregationBaseDescriptor>
	{
		internal string? _format;
	}

	internal sealed class FormatMetricAggregationBaseDescriptorConverter : JsonConverter<FormatMetricAggregationBaseDescriptor>
	{
		public override FormatMetricAggregationBaseDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, FormatMetricAggregationBaseDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (!string.IsNullOrEmpty(value._format))
			{
				writer.WritePropertyName("format");
				writer.WriteStringValue(value._format);
			}

			writer.WriteEndObject();
		}
	}

	public partial class FormattableMetricAggregation : Aggregations.MetricAggregationBase
	{
		[JsonInclude]
		[JsonPropertyName("format")]
		public string? Format { get; set; }
	}

	[JsonConverter(typeof(FormattableMetricAggregationDescriptorConverter))]
	public sealed partial class FormattableMetricAggregationDescriptor : DescriptorBase<FormattableMetricAggregationDescriptor>
	{
		internal string? _format;
	}

	internal sealed class FormattableMetricAggregationDescriptorConverter : JsonConverter<FormattableMetricAggregationDescriptor>
	{
		public override FormattableMetricAggregationDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, FormattableMetricAggregationDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (!string.IsNullOrEmpty(value._format))
			{
				writer.WritePropertyName("format");
				writer.WriteStringValue(value._format);
			}

			writer.WriteEndObject();
		}
	}

	public partial class GeoBounds
	{
		[JsonInclude]
		[JsonPropertyName("bottom_right")]
		public Elastic.Clients.Elasticsearch.LatLon BottomRight { get; set; }

		[JsonInclude]
		[JsonPropertyName("top_left")]
		public Elastic.Clients.Elasticsearch.LatLon TopLeft { get; set; }
	}

	[JsonConverter(typeof(GeoBoundsDescriptorConverter))]
	public sealed partial class GeoBoundsDescriptor : DescriptorBase<GeoBoundsDescriptor>
	{
		internal Elastic.Clients.Elasticsearch.LatLon _bottomRight;
		internal Elastic.Clients.Elasticsearch.LatLon _topLeft;
	}

	internal sealed class GeoBoundsDescriptorConverter : JsonConverter<GeoBoundsDescriptor>
	{
		public override GeoBoundsDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, GeoBoundsDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("bottom_right");
			JsonSerializer.Serialize(writer, value._bottomRight, options);
			writer.WritePropertyName("top_left");
			JsonSerializer.Serialize(writer, value._topLeft, options);
			writer.WriteEndObject();
		}
	}

	public partial class GeoBoundsAggregate : Aggregations.AggregateBase
	{
		[JsonInclude]
		[JsonPropertyName("bounds")]
		public Elastic.Clients.Elasticsearch.Aggregations.GeoBounds Bounds { get; init; }
	}

	public partial class GeoBoundsAggregation : Aggregations.MetricAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "geo_bounds";
		[JsonInclude]
		[JsonPropertyName("wrap_longitude")]
		public bool? WrapLongitude { get; set; }
	}

	[JsonConverter(typeof(GeoBoundsAggregationDescriptorConverter))]
	public sealed partial class GeoBoundsAggregationDescriptor : DescriptorBase<GeoBoundsAggregationDescriptor>
	{
		internal bool? _wrapLongitude;
	}

	internal sealed class GeoBoundsAggregationDescriptorConverter : JsonConverter<GeoBoundsAggregationDescriptor>
	{
		public override GeoBoundsAggregationDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, GeoBoundsAggregationDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value._wrapLongitude.HasValue)
			{
				writer.WritePropertyName("wrap_longitude");
				writer.WriteBooleanValue(value._wrapLongitude.Value);
			}

			writer.WriteEndObject();
		}
	}

	public partial class GeoCentroidAggregate : Aggregations.AggregateBase
	{
		[JsonInclude]
		[JsonPropertyName("count")]
		public long Count { get; init; }

		[JsonInclude]
		[JsonPropertyName("location")]
		public Elastic.Clients.Elasticsearch.QueryDsl.GeoLocation? Location { get; init; }
	}

	public partial class GeoCentroidAggregation : Aggregations.MetricAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "geo_centroid";
		[JsonInclude]
		[JsonPropertyName("count")]
		public long? Count { get; set; }

		[JsonInclude]
		[JsonPropertyName("location")]
		public Elastic.Clients.Elasticsearch.QueryDsl.GeoLocation? Location { get; set; }
	}

	[JsonConverter(typeof(GeoCentroidAggregationDescriptorConverter))]
	public sealed partial class GeoCentroidAggregationDescriptor : DescriptorBase<GeoCentroidAggregationDescriptor>
	{
		internal long? _count;
		internal Elastic.Clients.Elasticsearch.QueryDsl.GeoLocation? _location;
	}

	internal sealed class GeoCentroidAggregationDescriptorConverter : JsonConverter<GeoCentroidAggregationDescriptor>
	{
		public override GeoCentroidAggregationDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, GeoCentroidAggregationDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value._count.HasValue)
			{
				writer.WritePropertyName("count");
				writer.WriteNumberValue(value._count.Value);
			}

			if (value._location is not null)
			{
				writer.WritePropertyName("location");
				JsonSerializer.Serialize(writer, value._location, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class GeoDistanceAggregate : Aggregations.RangeAggregate
	{
	}

	public partial class GeoDistanceAggregation : Aggregations.BucketAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "geo_distance";
		[JsonInclude]
		[JsonPropertyName("distance_type")]
		public Elastic.Clients.Elasticsearch.GeoDistanceType? DistanceType { get; set; }

		[JsonInclude]
		[JsonPropertyName("field")]
		public string? Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("origin")]
		public Union<Elastic.Clients.Elasticsearch.QueryDsl.GeoLocation?, string?>? Origin { get; set; }

		[JsonInclude]
		[JsonPropertyName("ranges")]
		public IEnumerable<Elastic.Clients.Elasticsearch.Aggregations.AggregationRange>? Ranges { get; set; }

		[JsonInclude]
		[JsonPropertyName("unit")]
		public Elastic.Clients.Elasticsearch.DistanceUnit? Unit { get; set; }
	}

	[JsonConverter(typeof(GeoDistanceAggregationDescriptorConverter))]
	public sealed partial class GeoDistanceAggregationDescriptor : DescriptorBase<GeoDistanceAggregationDescriptor>
	{
		internal Elastic.Clients.Elasticsearch.GeoDistanceType? _distanceType;
		internal string? _field;
		internal Union<Elastic.Clients.Elasticsearch.QueryDsl.GeoLocation?, string?>? _origin;
		internal IEnumerable<Elastic.Clients.Elasticsearch.Aggregations.AggregationRange>? _ranges;
		internal Elastic.Clients.Elasticsearch.DistanceUnit? _unit;
	}

	internal sealed class GeoDistanceAggregationDescriptorConverter : JsonConverter<GeoDistanceAggregationDescriptor>
	{
		public override GeoDistanceAggregationDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, GeoDistanceAggregationDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value._distanceType is not null)
			{
				writer.WritePropertyName("distance_type");
				JsonSerializer.Serialize(writer, value._distanceType, options);
			}

			if (value._field is not null)
			{
				writer.WritePropertyName("field");
				JsonSerializer.Serialize(writer, value._field, options);
			}

			if (value._origin is not null)
			{
				writer.WritePropertyName("origin");
				JsonSerializer.Serialize(writer, value._origin, options);
			}

			if (value._ranges is not null)
			{
				writer.WritePropertyName("ranges");
				JsonSerializer.Serialize(writer, value._ranges, options);
			}

			if (value._unit is not null)
			{
				writer.WritePropertyName("unit");
				JsonSerializer.Serialize(writer, value._unit, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class GeoHashGridAggregate : Aggregations.MultiBucketAggregateBase<Elastic.Clients.Elasticsearch.Aggregations.GeoHashGridBucket>
	{
	}

	public partial class GeoHashGridAggregation : Aggregations.BucketAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "geohash_grid";
		[JsonInclude]
		[JsonPropertyName("bounds")]
		public Elastic.Clients.Elasticsearch.QueryDsl.BoundingBox? Bounds { get; set; }

		[JsonInclude]
		[JsonPropertyName("field")]
		public string? Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("precision")]
		public double? Precision { get; set; }

		[JsonInclude]
		[JsonPropertyName("shard_size")]
		public int? ShardSize { get; set; }

		[JsonInclude]
		[JsonPropertyName("size")]
		public int? Size { get; set; }
	}

	[JsonConverter(typeof(GeoHashGridAggregationDescriptorConverter))]
	public sealed partial class GeoHashGridAggregationDescriptor : DescriptorBase<GeoHashGridAggregationDescriptor>
	{
		internal Elastic.Clients.Elasticsearch.QueryDsl.BoundingBox? _bounds;
		internal string? _field;
		internal double? _precision;
		internal int? _shardSize;
		internal int? _size;
	}

	internal sealed class GeoHashGridAggregationDescriptorConverter : JsonConverter<GeoHashGridAggregationDescriptor>
	{
		public override GeoHashGridAggregationDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, GeoHashGridAggregationDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value._bounds is not null)
			{
				writer.WritePropertyName("bounds");
				JsonSerializer.Serialize(writer, value._bounds, options);
			}

			if (value._field is not null)
			{
				writer.WritePropertyName("field");
				JsonSerializer.Serialize(writer, value._field, options);
			}

			if (value._precision is not null)
			{
				writer.WritePropertyName("precision");
				JsonSerializer.Serialize(writer, value._precision, options);
			}

			if (value._shardSize.HasValue)
			{
				writer.WritePropertyName("shard_size");
				writer.WriteNumberValue(value._shardSize.Value);
			}

			if (value._size.HasValue)
			{
				writer.WritePropertyName("size");
				writer.WriteNumberValue(value._size.Value);
			}

			writer.WriteEndObject();
		}
	}

	public partial class GeoHashGridBucket : Aggregations.MultiBucketBase
	{
		[JsonInclude]
		[JsonPropertyName("key")]
		public string Key { get; init; }
	}

	public partial class GeoLineAggregate : Aggregations.AggregateBase
	{
		[JsonInclude]
		[JsonPropertyName("type")]
		public string Type => "Feature";
		[JsonInclude]
		[JsonPropertyName("geometry")]
		public Elastic.Clients.Elasticsearch.GeoLine Geometry { get; init; }
	}

	public partial class GeoLineAggregation : IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "geo_line";
		[JsonInclude]
		[JsonPropertyName("point")]
		public Elastic.Clients.Elasticsearch.Aggregations.GeoLinePoint Point { get; set; }

		[JsonInclude]
		[JsonPropertyName("sort")]
		public Elastic.Clients.Elasticsearch.Aggregations.GeoLineSort Sort { get; set; }

		[JsonInclude]
		[JsonPropertyName("include_sort")]
		public bool? IncludeSort { get; set; }

		[JsonInclude]
		[JsonPropertyName("sort_order")]
		public Elastic.Clients.Elasticsearch.SortOrder? SortOrder { get; set; }

		[JsonInclude]
		[JsonPropertyName("size")]
		public int? Size { get; set; }
	}

	[JsonConverter(typeof(GeoLineAggregationDescriptorConverter))]
	public sealed partial class GeoLineAggregationDescriptor : DescriptorBase<GeoLineAggregationDescriptor>
	{
		internal Elastic.Clients.Elasticsearch.Aggregations.GeoLinePoint _point;
		internal Elastic.Clients.Elasticsearch.Aggregations.GeoLineSort _sort;
		internal bool? _includeSort;
		internal Elastic.Clients.Elasticsearch.SortOrder? _sortOrder;
		internal int? _size;
	}

	internal sealed class GeoLineAggregationDescriptorConverter : JsonConverter<GeoLineAggregationDescriptor>
	{
		public override GeoLineAggregationDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, GeoLineAggregationDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("point");
			JsonSerializer.Serialize(writer, value._point, options);
			writer.WritePropertyName("sort");
			JsonSerializer.Serialize(writer, value._sort, options);
			if (value._includeSort.HasValue)
			{
				writer.WritePropertyName("include_sort");
				writer.WriteBooleanValue(value._includeSort.Value);
			}

			if (value._sortOrder is not null)
			{
				writer.WritePropertyName("sort_order");
				JsonSerializer.Serialize(writer, value._sortOrder, options);
			}

			if (value._size.HasValue)
			{
				writer.WritePropertyName("size");
				writer.WriteNumberValue(value._size.Value);
			}

			writer.WriteEndObject();
		}
	}

	public partial class GeoLinePoint
	{
		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }
	}

	[JsonConverter(typeof(GeoLinePointDescriptorConverter))]
	public sealed partial class GeoLinePointDescriptor : DescriptorBase<GeoLinePointDescriptor>
	{
		internal string _field;
	}

	internal sealed class GeoLinePointDescriptorConverter : JsonConverter<GeoLinePointDescriptor>
	{
		public override GeoLinePointDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, GeoLinePointDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, value._field, options);
			writer.WriteEndObject();
		}
	}

	public partial class GeoLineSort
	{
		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }
	}

	[JsonConverter(typeof(GeoLineSortDescriptorConverter))]
	public sealed partial class GeoLineSortDescriptor : DescriptorBase<GeoLineSortDescriptor>
	{
		internal string _field;
	}

	internal sealed class GeoLineSortDescriptorConverter : JsonConverter<GeoLineSortDescriptor>
	{
		public override GeoLineSortDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, GeoLineSortDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, value._field, options);
			writer.WriteEndObject();
		}
	}

	public partial class GeoTileGridAggregate : Aggregations.MultiBucketAggregateBase<Elastic.Clients.Elasticsearch.Aggregations.GeoTileGridBucket>
	{
	}

	public partial class GeoTileGridAggregation : Aggregations.BucketAggregationBase, IAggregationContainerVariant, TransformManagement.IPivotGroupByContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "geotile_grid";
		[JsonIgnore]
		string TransformManagement.IPivotGroupByContainerVariant.PivotGroupByContainerVariantName => "geotile_grid";
		[JsonInclude]
		[JsonPropertyName("field")]
		public string? Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("precision")]
		public double? Precision { get; set; }

		[JsonInclude]
		[JsonPropertyName("shard_size")]
		public int? ShardSize { get; set; }

		[JsonInclude]
		[JsonPropertyName("size")]
		public int? Size { get; set; }

		[JsonInclude]
		[JsonPropertyName("bounds")]
		public Elastic.Clients.Elasticsearch.Aggregations.GeoBounds? Bounds { get; set; }
	}

	[JsonConverter(typeof(GeoTileGridAggregationDescriptorConverter))]
	public sealed partial class GeoTileGridAggregationDescriptor : DescriptorBase<GeoTileGridAggregationDescriptor>
	{
		internal string? _field;
		internal double? _precision;
		internal int? _shardSize;
		internal int? _size;
		internal Elastic.Clients.Elasticsearch.Aggregations.GeoBounds? _bounds;
	}

	internal sealed class GeoTileGridAggregationDescriptorConverter : JsonConverter<GeoTileGridAggregationDescriptor>
	{
		public override GeoTileGridAggregationDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, GeoTileGridAggregationDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value._field is not null)
			{
				writer.WritePropertyName("field");
				JsonSerializer.Serialize(writer, value._field, options);
			}

			if (value._precision is not null)
			{
				writer.WritePropertyName("precision");
				JsonSerializer.Serialize(writer, value._precision, options);
			}

			if (value._shardSize.HasValue)
			{
				writer.WritePropertyName("shard_size");
				writer.WriteNumberValue(value._shardSize.Value);
			}

			if (value._size.HasValue)
			{
				writer.WritePropertyName("size");
				writer.WriteNumberValue(value._size.Value);
			}

			if (value._bounds is not null)
			{
				writer.WritePropertyName("bounds");
				JsonSerializer.Serialize(writer, value._bounds, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class GeoTileGridBucket : Aggregations.MultiBucketBase
	{
		[JsonInclude]
		[JsonPropertyName("key")]
		public string Key { get; init; }
	}

	public partial class GlobalAggregate : Aggregations.SingleBucketAggregateBase
	{
	}

	public partial class GlobalAggregation : Aggregations.BucketAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "global";
	}

	[JsonConverter(typeof(GlobalAggregationDescriptorConverter))]
	public sealed partial class GlobalAggregationDescriptor : DescriptorBase<GlobalAggregationDescriptor>
	{
	}

	internal sealed class GlobalAggregationDescriptorConverter : JsonConverter<GlobalAggregationDescriptor>
	{
		public override GlobalAggregationDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, GlobalAggregationDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WriteEndObject();
		}
	}

	public partial class GoogleNormalizedDistanceHeuristic
	{
		[JsonInclude]
		[JsonPropertyName("background_is_superset")]
		public bool? BackgroundIsSuperset { get; set; }
	}

	[JsonConverter(typeof(GoogleNormalizedDistanceHeuristicDescriptorConverter))]
	public sealed partial class GoogleNormalizedDistanceHeuristicDescriptor : DescriptorBase<GoogleNormalizedDistanceHeuristicDescriptor>
	{
		internal bool? _backgroundIsSuperset;
	}

	internal sealed class GoogleNormalizedDistanceHeuristicDescriptorConverter : JsonConverter<GoogleNormalizedDistanceHeuristicDescriptor>
	{
		public override GoogleNormalizedDistanceHeuristicDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, GoogleNormalizedDistanceHeuristicDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value._backgroundIsSuperset.HasValue)
			{
				writer.WritePropertyName("background_is_superset");
				writer.WriteBooleanValue(value._backgroundIsSuperset.Value);
			}

			writer.WriteEndObject();
		}
	}

	public partial class HdrMethod
	{
		[JsonInclude]
		[JsonPropertyName("number_of_significant_value_digits")]
		public int? NumberOfSignificantValueDigits { get; set; }
	}

	[JsonConverter(typeof(HdrMethodDescriptorConverter))]
	public sealed partial class HdrMethodDescriptor : DescriptorBase<HdrMethodDescriptor>
	{
		internal int? _numberOfSignificantValueDigits;
	}

	internal sealed class HdrMethodDescriptorConverter : JsonConverter<HdrMethodDescriptor>
	{
		public override HdrMethodDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, HdrMethodDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value._numberOfSignificantValueDigits.HasValue)
			{
				writer.WritePropertyName("number_of_significant_value_digits");
				writer.WriteNumberValue(value._numberOfSignificantValueDigits.Value);
			}

			writer.WriteEndObject();
		}
	}

	public partial class HdrPercentileRanksAggregate : Aggregations.PercentilesAggregateBase
	{
	}

	public partial class HdrPercentilesAggregate : Aggregations.PercentilesAggregateBase
	{
	}

	public partial class HistogramAggregate : Aggregations.MultiBucketAggregateBase<Elastic.Clients.Elasticsearch.Aggregations.HistogramBucket>
	{
	}

	public partial class HistogramAggregation : Aggregations.BucketAggregationBase, IAggregationContainerVariant, TransformManagement.IPivotGroupByContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "histogram";
		[JsonIgnore]
		string TransformManagement.IPivotGroupByContainerVariant.PivotGroupByContainerVariantName => "histogram";
		[JsonInclude]
		[JsonPropertyName("field")]
		public string? Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("interval")]
		public double? Interval { get; set; }

		[JsonInclude]
		[JsonPropertyName("min_doc_count")]
		public int? MinDocCount { get; set; }

		[JsonInclude]
		[JsonPropertyName("missing")]
		public double? Missing { get; set; }

		[JsonInclude]
		[JsonPropertyName("offset")]
		public double? Offset { get; set; }

		[JsonInclude]
		[JsonPropertyName("order")]
		public Elastic.Clients.Elasticsearch.Aggregations.HistogramOrder? Order { get; set; }

		[JsonInclude]
		[JsonPropertyName("script")]
		public Elastic.Clients.Elasticsearch.Script? Script { get; set; }

		[JsonInclude]
		[JsonPropertyName("format")]
		public string? Format { get; set; }

		[JsonInclude]
		[JsonPropertyName("keyed")]
		public bool? Keyed { get; set; }
	}

	[JsonConverter(typeof(HistogramAggregationDescriptorConverter))]
	public sealed partial class HistogramAggregationDescriptor : DescriptorBase<HistogramAggregationDescriptor>
	{
		internal string? _field;
		internal double? _interval;
		internal int? _minDocCount;
		internal double? _missing;
		internal double? _offset;
		internal Elastic.Clients.Elasticsearch.Aggregations.HistogramOrder? _order;
		internal Elastic.Clients.Elasticsearch.Script? _script;
		internal string? _format;
		internal bool? _keyed;
	}

	internal sealed class HistogramAggregationDescriptorConverter : JsonConverter<HistogramAggregationDescriptor>
	{
		public override HistogramAggregationDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, HistogramAggregationDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();

			if (value._field is not null)
			{
				writer.WritePropertyName("field");
				JsonSerializer.Serialize(writer, value._field, options);
			}

			if (value._interval.HasValue)
			{
				writer.WritePropertyName("interval");
				writer.WriteNumberValue(value._interval.Value);
			}

			if (value._minDocCount.HasValue)
			{
				writer.WritePropertyName("min_doc_count");
				writer.WriteNumberValue(value._minDocCount.Value);
			}

			if (value._missing.HasValue)
			{
				writer.WritePropertyName("missing");
				writer.WriteNumberValue(value._missing.Value);
			}

			if (value._offset.HasValue)
			{
				writer.WritePropertyName("offset");
				writer.WriteNumberValue(value._offset.Value);
			}

			if (value._order is not null)
			{
				writer.WritePropertyName("order");
				JsonSerializer.Serialize(writer, value._order, options);
			}

			if (value._script is not null)
			{
				writer.WritePropertyName("script");
				JsonSerializer.Serialize(writer, value._script, options);
			}

			if (!string.IsNullOrEmpty(value._format))
			{
				writer.WritePropertyName("format");
				writer.WriteStringValue(value._format);
			}

			if (value._keyed.HasValue)
			{
				writer.WritePropertyName("keyed");
				writer.WriteBooleanValue(value._keyed.Value);
			}

			writer.WriteEndObject();
		}
	}

	public partial class HistogramBucket : Aggregations.MultiBucketBase
	{
		[JsonInclude]
		[JsonPropertyName("key_as_string")]
		public string? KeyAsString { get; init; }

		[JsonInclude]
		[JsonPropertyName("key")]
		public double Key { get; init; }
	}

	public partial class HistogramOrder
	{
		[JsonInclude]
		[JsonPropertyName("_count")]
		public Elastic.Clients.Elasticsearch.SortOrder? Count { get; set; }

		[JsonInclude]
		[JsonPropertyName("_key")]
		public Elastic.Clients.Elasticsearch.SortOrder? Key { get; set; }
	}

	[JsonConverter(typeof(HistogramOrderDescriptorConverter))]
	public sealed partial class HistogramOrderDescriptor : DescriptorBase<HistogramOrderDescriptor>
	{
		internal Elastic.Clients.Elasticsearch.SortOrder? _count;
		internal Elastic.Clients.Elasticsearch.SortOrder? _key;
	}

	internal sealed class HistogramOrderDescriptorConverter : JsonConverter<HistogramOrderDescriptor>
	{
		public override HistogramOrderDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, HistogramOrderDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value._count is not null)
			{
				writer.WritePropertyName("_count");
				JsonSerializer.Serialize(writer, value._count, options);
			}

			if (value._key is not null)
			{
				writer.WritePropertyName("_key");
				JsonSerializer.Serialize(writer, value._key, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class HoltLinearModelSettings
	{
		[JsonInclude]
		[JsonPropertyName("alpha")]
		public float? Alpha { get; init; }

		[JsonInclude]
		[JsonPropertyName("beta")]
		public float? Beta { get; init; }
	}

	public partial class HoltWintersModelSettings
	{
		[JsonInclude]
		[JsonPropertyName("alpha")]
		public float? Alpha { get; init; }

		[JsonInclude]
		[JsonPropertyName("beta")]
		public float? Beta { get; init; }

		[JsonInclude]
		[JsonPropertyName("gamma")]
		public float? Gamma { get; init; }

		[JsonInclude]
		[JsonPropertyName("pad")]
		public bool? Pad { get; init; }

		[JsonInclude]
		[JsonPropertyName("period")]
		public int? Period { get; init; }

		[JsonInclude]
		[JsonPropertyName("type")]
		public Elastic.Clients.Elasticsearch.Aggregations.HoltWintersType? Type { get; init; }
	}

	public partial class InferenceAggregate : Aggregations.AggregateBase
	{
		[JsonInclude]
		[JsonPropertyName("value")]
		public Elastic.Clients.Elasticsearch.ScalarValue? Value { get; init; }

		[JsonInclude]
		[JsonPropertyName("feature_importance")]
		public IReadOnlyCollection<Elastic.Clients.Elasticsearch.Aggregations.InferenceFeatureImportance>? FeatureImportance { get; init; }

		[JsonInclude]
		[JsonPropertyName("top_classes")]
		public IReadOnlyCollection<Elastic.Clients.Elasticsearch.Aggregations.InferenceTopClassEntry>? TopClasses { get; init; }

		[JsonInclude]
		[JsonPropertyName("warning")]
		public string? Warning { get; init; }
	}

	public partial class InferenceAggregation : Aggregations.PipelineAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "inference";
		[JsonInclude]
		[JsonPropertyName("model_id")]
		public Elastic.Clients.Elasticsearch.Name ModelId { get; set; }

		[JsonInclude]
		[JsonPropertyName("inference_config")]
		public Elastic.Clients.Elasticsearch.Aggregations.InferenceConfigContainer? InferenceConfig { get; set; }
	}

	[JsonConverter(typeof(InferenceAggregationDescriptorConverter))]
	public sealed partial class InferenceAggregationDescriptor : DescriptorBase<InferenceAggregationDescriptor>
	{
		internal Elastic.Clients.Elasticsearch.Name _modelId;
		internal Elastic.Clients.Elasticsearch.Aggregations.InferenceConfigContainer? _inferenceConfig;
	}

	internal sealed class InferenceAggregationDescriptorConverter : JsonConverter<InferenceAggregationDescriptor>
	{
		public override InferenceAggregationDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, InferenceAggregationDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("model_id");
			JsonSerializer.Serialize(writer, value._modelId, options);
			if (value._inferenceConfig is not null)
			{
				writer.WritePropertyName("inference_config");
				JsonSerializer.Serialize(writer, value._inferenceConfig, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class InferenceClassImportance
	{
		[JsonInclude]
		[JsonPropertyName("class_name")]
		public string ClassName { get; init; }

		[JsonInclude]
		[JsonPropertyName("importance")]
		public double Importance { get; init; }
	}

	public partial class InferenceConfigContainer
	{
		[JsonInclude]
		[JsonPropertyName("regression")]
		public Elastic.Clients.Elasticsearch.Aggregations.RegressionInferenceOptions? Regression { get; set; }

		[JsonInclude]
		[JsonPropertyName("classification")]
		public Elastic.Clients.Elasticsearch.Aggregations.ClassificationInferenceOptions? Classification { get; set; }
	}

	[JsonConverter(typeof(InferenceConfigContainerDescriptorConverter))]
	public sealed partial class InferenceConfigContainerDescriptor : DescriptorBase<InferenceConfigContainerDescriptor>
	{
		internal Elastic.Clients.Elasticsearch.Aggregations.RegressionInferenceOptions? _regression;
		internal Elastic.Clients.Elasticsearch.Aggregations.ClassificationInferenceOptions? _classification;
	}

	internal sealed class InferenceConfigContainerDescriptorConverter : JsonConverter<InferenceConfigContainerDescriptor>
	{
		public override InferenceConfigContainerDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, InferenceConfigContainerDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value._regression is not null)
			{
				writer.WritePropertyName("regression");
				JsonSerializer.Serialize(writer, value._regression, options);
			}

			if (value._classification is not null)
			{
				writer.WritePropertyName("classification");
				JsonSerializer.Serialize(writer, value._classification, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class InferenceFeatureImportance
	{
		[JsonInclude]
		[JsonPropertyName("feature_name")]
		public string FeatureName { get; init; }

		[JsonInclude]
		[JsonPropertyName("importance")]
		public double? Importance { get; init; }

		[JsonInclude]
		[JsonPropertyName("classes")]
		public IReadOnlyCollection<Elastic.Clients.Elasticsearch.Aggregations.InferenceClassImportance>? Classes { get; init; }
	}

	public partial class InferenceTopClassEntry
	{
		[JsonInclude]
		[JsonPropertyName("class_name")]
		public Elastic.Clients.Elasticsearch.ScalarValue ClassName { get; init; }

		[JsonInclude]
		[JsonPropertyName("class_probability")]
		public double ClassProbability { get; init; }

		[JsonInclude]
		[JsonPropertyName("class_score")]
		public double ClassScore { get; init; }
	}

	public partial class IpRangeAggregate : Aggregations.MultiBucketAggregateBase<Elastic.Clients.Elasticsearch.Aggregations.IpRangeBucket>
	{
	}

	public partial class IpRangeAggregation : Aggregations.BucketAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "ip_range";
		[JsonInclude]
		[JsonPropertyName("field")]
		public string? Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("ranges")]
		public IEnumerable<Elastic.Clients.Elasticsearch.Aggregations.IpRangeAggregationRange>? Ranges { get; set; }
	}

	[JsonConverter(typeof(IpRangeAggregationDescriptorConverter))]
	public sealed partial class IpRangeAggregationDescriptor : DescriptorBase<IpRangeAggregationDescriptor>
	{
		internal string? _field;
		internal IEnumerable<Elastic.Clients.Elasticsearch.Aggregations.IpRangeAggregationRange>? _ranges;
	}

	internal sealed class IpRangeAggregationDescriptorConverter : JsonConverter<IpRangeAggregationDescriptor>
	{
		public override IpRangeAggregationDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, IpRangeAggregationDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value._field is not null)
			{
				writer.WritePropertyName("field");
				JsonSerializer.Serialize(writer, value._field, options);
			}

			if (value._ranges is not null)
			{
				writer.WritePropertyName("ranges");
				JsonSerializer.Serialize(writer, value._ranges, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class IpRangeAggregationRange
	{
		[JsonInclude]
		[JsonPropertyName("from")]
		public string? From { get; set; }

		[JsonInclude]
		[JsonPropertyName("mask")]
		public string? Mask { get; set; }

		[JsonInclude]
		[JsonPropertyName("to")]
		public string? To { get; set; }
	}

	[JsonConverter(typeof(IpRangeAggregationRangeDescriptorConverter))]
	public sealed partial class IpRangeAggregationRangeDescriptor : DescriptorBase<IpRangeAggregationRangeDescriptor>
	{
		internal string? _from;
		internal string? _mask;
		internal string? _to;
	}

	internal sealed class IpRangeAggregationRangeDescriptorConverter : JsonConverter<IpRangeAggregationRangeDescriptor>
	{
		public override IpRangeAggregationRangeDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, IpRangeAggregationRangeDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (!string.IsNullOrEmpty(value._from))
			{
				writer.WritePropertyName("from");
				writer.WriteStringValue(value._from);
			}

			if (!string.IsNullOrEmpty(value._mask))
			{
				writer.WritePropertyName("mask");
				writer.WriteStringValue(value._mask);
			}

			if (!string.IsNullOrEmpty(value._to))
			{
				writer.WritePropertyName("to");
				writer.WriteStringValue(value._to);
			}

			writer.WriteEndObject();
		}
	}

	public partial class IpRangeBucket : Aggregations.MultiBucketBase
	{
		[JsonInclude]
		[JsonPropertyName("from")]
		public string? From { get; init; }

		[JsonInclude]
		[JsonPropertyName("to")]
		public string? To { get; init; }
	}

	public partial class LongRareTermsAggregate : Aggregations.MultiBucketAggregateBase<Elastic.Clients.Elasticsearch.Aggregations.LongRareTermsBucket>
	{
	}

	public partial class LongRareTermsBucket : Aggregations.MultiBucketBase
	{
		[JsonInclude]
		[JsonPropertyName("key")]
		public long Key { get; init; }

		[JsonInclude]
		[JsonPropertyName("key_as_string")]
		public string? KeyAsString { get; init; }
	}

	public partial class LongTermsAggregate : Aggregations.TermsAggregateBase<Elastic.Clients.Elasticsearch.Aggregations.LongTermsBucket>
	{
	}

	public partial class LongTermsBucket : Aggregations.TermsBucketBase
	{
		[JsonInclude]
		[JsonPropertyName("key")]
		public string Key { get; init; }

		[JsonInclude]
		[JsonPropertyName("key_as_string")]
		public string? KeyAsString { get; init; }
	}

	public partial class MatrixAggregation : Aggregations.Aggregation
	{
		[JsonInclude]
		[JsonPropertyName("fields")]
		public Elastic.Clients.Elasticsearch.Fields? Fields { get; set; }

		[JsonInclude]
		[JsonPropertyName("missing")]
		public Dictionary<string, double>? Missing { get; set; }
	}

	[JsonConverter(typeof(MatrixAggregationDescriptorConverter))]
	public sealed partial class MatrixAggregationDescriptor : DescriptorBase<MatrixAggregationDescriptor>
	{
		internal Elastic.Clients.Elasticsearch.Fields? _fields;
		internal Dictionary<string, double>? _missing;
	}

	internal sealed class MatrixAggregationDescriptorConverter : JsonConverter<MatrixAggregationDescriptor>
	{
		public override MatrixAggregationDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, MatrixAggregationDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value._fields is not null)
			{
				writer.WritePropertyName("fields");
				JsonSerializer.Serialize(writer, value._fields, options);
			}

			if (value._missing is not null)
			{
				writer.WritePropertyName("missing");
				JsonSerializer.Serialize(writer, value._missing, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class MatrixStatsAggregate : Aggregations.AggregateBase
	{
		[JsonInclude]
		[JsonPropertyName("doc_count")]
		public long DocCount { get; init; }

		[JsonInclude]
		[JsonPropertyName("fields")]
		public IReadOnlyCollection<Elastic.Clients.Elasticsearch.Aggregations.MatrixStatsFields> Fields { get; init; }
	}

	public partial class MatrixStatsAggregation : Aggregations.MatrixAggregation, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "matrix_stats";
		[JsonInclude]
		[JsonPropertyName("mode")]
		public Elastic.Clients.Elasticsearch.Aggregations.MatrixStatsMode? Mode { get; set; }
	}

	[JsonConverter(typeof(MatrixStatsAggregationDescriptorConverter))]
	public sealed partial class MatrixStatsAggregationDescriptor : DescriptorBase<MatrixStatsAggregationDescriptor>
	{
		internal Elastic.Clients.Elasticsearch.Aggregations.MatrixStatsMode? _mode;
	}

	internal sealed class MatrixStatsAggregationDescriptorConverter : JsonConverter<MatrixStatsAggregationDescriptor>
	{
		public override MatrixStatsAggregationDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, MatrixStatsAggregationDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value._mode is not null)
			{
				writer.WritePropertyName("mode");
				JsonSerializer.Serialize(writer, value._mode, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class MatrixStatsFields
	{
		[JsonInclude]
		[JsonPropertyName("name")]
		public string Name { get; init; }

		[JsonInclude]
		[JsonPropertyName("count")]
		public long Count { get; init; }

		[JsonInclude]
		[JsonPropertyName("mean")]
		public double Mean { get; init; }

		[JsonInclude]
		[JsonPropertyName("variance")]
		public double Variance { get; init; }

		[JsonInclude]
		[JsonPropertyName("skewness")]
		public double Skewness { get; init; }

		[JsonInclude]
		[JsonPropertyName("kurtosis")]
		public double Kurtosis { get; init; }

		[JsonInclude]
		[JsonPropertyName("covariance")]
		public Dictionary<string, double> Covariance { get; init; }

		[JsonInclude]
		[JsonPropertyName("correlation")]
		public Dictionary<string, double> Correlation { get; init; }
	}

	public partial class MaxAggregate : Aggregations.SingleMetricAggregateBase
	{
	}

	public partial class MaxAggregation : Aggregations.FormatMetricAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "max";
	}

	[JsonConverter(typeof(MaxAggregationDescriptorConverter))]
	public sealed partial class MaxAggregationDescriptor : DescriptorBase<MaxAggregationDescriptor>
	{
	}

	internal sealed class MaxAggregationDescriptorConverter : JsonConverter<MaxAggregationDescriptor>
	{
		public override MaxAggregationDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, MaxAggregationDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WriteEndObject();
		}
	}

	public partial class MaxBucketAggregation : Aggregations.PipelineAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "max_bucket";
	}

	[JsonConverter(typeof(MaxBucketAggregationDescriptorConverter))]
	public sealed partial class MaxBucketAggregationDescriptor : DescriptorBase<MaxBucketAggregationDescriptor>
	{
	}

	internal sealed class MaxBucketAggregationDescriptorConverter : JsonConverter<MaxBucketAggregationDescriptor>
	{
		public override MaxBucketAggregationDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, MaxBucketAggregationDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WriteEndObject();
		}
	}

	public partial class MedianAbsoluteDeviationAggregate : Aggregations.SingleMetricAggregateBase
	{
	}

	public partial class MedianAbsoluteDeviationAggregation : Aggregations.FormatMetricAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "median_absolute_deviation";
		[JsonInclude]
		[JsonPropertyName("compression")]
		public double? Compression { get; set; }
	}

	[JsonConverter(typeof(MedianAbsoluteDeviationAggregationDescriptorConverter))]
	public sealed partial class MedianAbsoluteDeviationAggregationDescriptor : DescriptorBase<MedianAbsoluteDeviationAggregationDescriptor>
	{
		internal double? _compression;
	}

	internal sealed class MedianAbsoluteDeviationAggregationDescriptorConverter : JsonConverter<MedianAbsoluteDeviationAggregationDescriptor>
	{
		public override MedianAbsoluteDeviationAggregationDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, MedianAbsoluteDeviationAggregationDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value._compression.HasValue)
			{
				writer.WritePropertyName("compression");
				writer.WriteNumberValue(value._compression.Value);
			}

			writer.WriteEndObject();
		}
	}

	public abstract partial class MetricAggregationBase
	{
		[JsonInclude]
		[JsonPropertyName("field")]
		public string? Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("missing")]
		public Elastic.Clients.Elasticsearch.Aggregations.Missing? Missing { get; set; }

		[JsonInclude]
		[JsonPropertyName("script")]
		public Elastic.Clients.Elasticsearch.Script? Script { get; set; }
	}

	[JsonConverter(typeof(MetricAggregationBaseDescriptorConverter))]
	public sealed partial class MetricAggregationBaseDescriptor : DescriptorBase<MetricAggregationBaseDescriptor>
	{
		internal string? _field;
		internal Elastic.Clients.Elasticsearch.Aggregations.Missing? _missing;
		internal Elastic.Clients.Elasticsearch.Script? _script;
	}

	internal sealed class MetricAggregationBaseDescriptorConverter : JsonConverter<MetricAggregationBaseDescriptor>
	{
		public override MetricAggregationBaseDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, MetricAggregationBaseDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value._field is not null)
			{
				writer.WritePropertyName("field");
				JsonSerializer.Serialize(writer, value._field, options);
			}

			if (value._missing is not null)
			{
				writer.WritePropertyName("missing");
				JsonSerializer.Serialize(writer, value._missing, options);
			}

			if (value._script is not null)
			{
				writer.WritePropertyName("script");
				JsonSerializer.Serialize(writer, value._script, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class MinAggregate : Aggregations.SingleMetricAggregateBase
	{
	}

	public partial class MinAggregation : Aggregations.FormatMetricAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "min";
	}

	[JsonConverter(typeof(MinAggregationDescriptorConverter))]
	public sealed partial class MinAggregationDescriptor : DescriptorBase<MinAggregationDescriptor>
	{
	}

	internal sealed class MinAggregationDescriptorConverter : JsonConverter<MinAggregationDescriptor>
	{
		public override MinAggregationDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, MinAggregationDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WriteEndObject();
		}
	}

	public partial class MinBucketAggregation : Aggregations.PipelineAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "min_bucket";
	}

	[JsonConverter(typeof(MinBucketAggregationDescriptorConverter))]
	public sealed partial class MinBucketAggregationDescriptor : DescriptorBase<MinBucketAggregationDescriptor>
	{
	}

	internal sealed class MinBucketAggregationDescriptorConverter : JsonConverter<MinBucketAggregationDescriptor>
	{
		public override MinBucketAggregationDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, MinBucketAggregationDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WriteEndObject();
		}
	}

	public partial class MissingAggregate : Aggregations.SingleBucketAggregateBase
	{
	}

	public partial class MissingAggregation : Aggregations.BucketAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "missing";
		[JsonInclude]
		[JsonPropertyName("field")]
		public string? Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("missing")]
		public Elastic.Clients.Elasticsearch.Aggregations.Missing? Missing { get; set; }
	}

	[JsonConverter(typeof(MissingAggregationDescriptorConverter))]
	public sealed partial class MissingAggregationDescriptor : DescriptorBase<MissingAggregationDescriptor>
	{
		internal string? _field;
		internal Elastic.Clients.Elasticsearch.Aggregations.Missing? _missing;
	}

	internal sealed class MissingAggregationDescriptorConverter : JsonConverter<MissingAggregationDescriptor>
	{
		public override MissingAggregationDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, MissingAggregationDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value._field is not null)
			{
				writer.WritePropertyName("field");
				JsonSerializer.Serialize(writer, value._field, options);
			}

			if (value._missing is not null)
			{
				writer.WritePropertyName("missing");
				JsonSerializer.Serialize(writer, value._missing, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class MovingAverageAggregation : Aggregations.PipelineAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "moving_avg";
		[JsonInclude]
		[JsonPropertyName("minimize")]
		public bool? Minimize { get; set; }

		[JsonInclude]
		[JsonPropertyName("model")]
		public Elastic.Clients.Elasticsearch.Aggregations.MovingAverageModel? Model { get; set; }

		[JsonInclude]
		[JsonPropertyName("settings")]
		public Elastic.Clients.Elasticsearch.Aggregations.MovingAverageSettings Settings { get; set; }

		[JsonInclude]
		[JsonPropertyName("predict")]
		public int? Predict { get; set; }

		[JsonInclude]
		[JsonPropertyName("window")]
		public int? Window { get; set; }
	}

	[JsonConverter(typeof(MovingAverageAggregationDescriptorConverter))]
	public sealed partial class MovingAverageAggregationDescriptor : DescriptorBase<MovingAverageAggregationDescriptor>
	{
		internal bool? _minimize;
		internal Elastic.Clients.Elasticsearch.Aggregations.MovingAverageModel? _model;
		internal Elastic.Clients.Elasticsearch.Aggregations.MovingAverageSettings _settings;
		internal int? _predict;
		internal int? _window;
	}

	internal sealed class MovingAverageAggregationDescriptorConverter : JsonConverter<MovingAverageAggregationDescriptor>
	{
		public override MovingAverageAggregationDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, MovingAverageAggregationDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value._minimize.HasValue)
			{
				writer.WritePropertyName("minimize");
				writer.WriteBooleanValue(value._minimize.Value);
			}

			if (value._model is not null)
			{
				writer.WritePropertyName("model");
				JsonSerializer.Serialize(writer, value._model, options);
			}

			writer.WritePropertyName("settings");
			JsonSerializer.Serialize(writer, value._settings, options);
			if (value._predict.HasValue)
			{
				writer.WritePropertyName("predict");
				writer.WriteNumberValue(value._predict.Value);
			}

			if (value._window.HasValue)
			{
				writer.WritePropertyName("window");
				writer.WriteNumberValue(value._window.Value);
			}

			writer.WriteEndObject();
		}
	}

	public partial class MovingFunctionAggregation : Aggregations.PipelineAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "moving_fn";
		[JsonInclude]
		[JsonPropertyName("script")]
		public string? Script { get; set; }

		[JsonInclude]
		[JsonPropertyName("shift")]
		public int? Shift { get; set; }

		[JsonInclude]
		[JsonPropertyName("window")]
		public int? Window { get; set; }
	}

	[JsonConverter(typeof(MovingFunctionAggregationDescriptorConverter))]
	public sealed partial class MovingFunctionAggregationDescriptor : DescriptorBase<MovingFunctionAggregationDescriptor>
	{
		internal string? _script;
		internal int? _shift;
		internal int? _window;
	}

	internal sealed class MovingFunctionAggregationDescriptorConverter : JsonConverter<MovingFunctionAggregationDescriptor>
	{
		public override MovingFunctionAggregationDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, MovingFunctionAggregationDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (!string.IsNullOrEmpty(value._script))
			{
				writer.WritePropertyName("script");
				writer.WriteStringValue(value._script);
			}

			if (value._shift.HasValue)
			{
				writer.WritePropertyName("shift");
				writer.WriteNumberValue(value._shift.Value);
			}

			if (value._window.HasValue)
			{
				writer.WritePropertyName("window");
				writer.WriteNumberValue(value._window.Value);
			}

			writer.WriteEndObject();
		}
	}

	public partial class MovingPercentilesAggregation : Aggregations.PipelineAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "moving_percentiles";
		[JsonInclude]
		[JsonPropertyName("window")]
		public int? Window { get; set; }

		[JsonInclude]
		[JsonPropertyName("shift")]
		public int? Shift { get; set; }

		[JsonInclude]
		[JsonPropertyName("keyed")]
		public bool? Keyed { get; set; }
	}

	[JsonConverter(typeof(MovingPercentilesAggregationDescriptorConverter))]
	public sealed partial class MovingPercentilesAggregationDescriptor : DescriptorBase<MovingPercentilesAggregationDescriptor>
	{
		internal int? _window;
		internal int? _shift;
		internal bool? _keyed;
	}

	internal sealed class MovingPercentilesAggregationDescriptorConverter : JsonConverter<MovingPercentilesAggregationDescriptor>
	{
		public override MovingPercentilesAggregationDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, MovingPercentilesAggregationDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value._window.HasValue)
			{
				writer.WritePropertyName("window");
				writer.WriteNumberValue(value._window.Value);
			}

			if (value._shift.HasValue)
			{
				writer.WritePropertyName("shift");
				writer.WriteNumberValue(value._shift.Value);
			}

			if (value._keyed.HasValue)
			{
				writer.WritePropertyName("keyed");
				writer.WriteBooleanValue(value._keyed.Value);
			}

			writer.WriteEndObject();
		}
	}

	public abstract partial class MultiBucketAggregateBase<TBucket> : Aggregations.AggregateBase
	{
		[JsonInclude]
		[JsonPropertyName("buckets")]
		public Elastic.Clients.Elasticsearch.Aggregations.Buckets<TBucket> Buckets { get; init; }
	}

	public abstract partial class MultiBucketBase
	{
		[JsonInclude]
		[JsonPropertyName("doc_count")]
		public long DocCount { get; init; }
	}

	public partial class MultiTermLookup
	{
		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }
	}

	[JsonConverter(typeof(MultiTermLookupDescriptorConverter))]
	public sealed partial class MultiTermLookupDescriptor : DescriptorBase<MultiTermLookupDescriptor>
	{
		internal string _field;
	}

	internal sealed class MultiTermLookupDescriptorConverter : JsonConverter<MultiTermLookupDescriptor>
	{
		public override MultiTermLookupDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, MultiTermLookupDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, value._field, options);
			writer.WriteEndObject();
		}
	}

	public partial class MultiTermsAggregate : Aggregations.TermsAggregateBase<Elastic.Clients.Elasticsearch.Aggregations.MultiTermsBucket>
	{
	}

	public partial class MultiTermsAggregation : Aggregations.BucketAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "multi_terms";
		[JsonInclude]
		[JsonPropertyName("terms")]
		public IEnumerable<Elastic.Clients.Elasticsearch.Aggregations.MultiTermLookup> Terms { get; set; }
	}

	[JsonConverter(typeof(MultiTermsAggregationDescriptorConverter))]
	public sealed partial class MultiTermsAggregationDescriptor : DescriptorBase<MultiTermsAggregationDescriptor>
	{
		internal IEnumerable<Elastic.Clients.Elasticsearch.Aggregations.MultiTermLookup> _terms;
	}

	internal sealed class MultiTermsAggregationDescriptorConverter : JsonConverter<MultiTermsAggregationDescriptor>
	{
		public override MultiTermsAggregationDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, MultiTermsAggregationDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("terms");
			JsonSerializer.Serialize(writer, value._terms, options);
			writer.WriteEndObject();
		}
	}

	public partial class MultiTermsBucket : Aggregations.MultiBucketBase
	{
		[JsonInclude]
		[JsonPropertyName("key")]
		public IReadOnlyCollection<object> Key { get; init; }

		[JsonInclude]
		[JsonPropertyName("key_as_string")]
		public string? KeyAsString { get; init; }

		[JsonInclude]
		[JsonPropertyName("doc_count_error_upper_bound")]
		public long? DocCountErrorUpperBound { get; init; }
	}

	public partial class MutualInformationHeuristic
	{
		[JsonInclude]
		[JsonPropertyName("background_is_superset")]
		public bool? BackgroundIsSuperset { get; set; }

		[JsonInclude]
		[JsonPropertyName("include_negatives")]
		public bool? IncludeNegatives { get; set; }
	}

	[JsonConverter(typeof(MutualInformationHeuristicDescriptorConverter))]
	public sealed partial class MutualInformationHeuristicDescriptor : DescriptorBase<MutualInformationHeuristicDescriptor>
	{
		internal bool? _backgroundIsSuperset;
		internal bool? _includeNegatives;
	}

	internal sealed class MutualInformationHeuristicDescriptorConverter : JsonConverter<MutualInformationHeuristicDescriptor>
	{
		public override MutualInformationHeuristicDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, MutualInformationHeuristicDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value._backgroundIsSuperset.HasValue)
			{
				writer.WritePropertyName("background_is_superset");
				writer.WriteBooleanValue(value._backgroundIsSuperset.Value);
			}

			if (value._includeNegatives.HasValue)
			{
				writer.WritePropertyName("include_negatives");
				writer.WriteBooleanValue(value._includeNegatives.Value);
			}

			writer.WriteEndObject();
		}
	}

	public partial class NestedAggregate : Aggregations.SingleBucketAggregateBase
	{
	}

	public partial class NestedAggregation : Aggregations.BucketAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "nested";
		[JsonInclude]
		[JsonPropertyName("path")]
		public string? Path { get; set; }
	}

	[JsonConverter(typeof(NestedAggregationDescriptorConverter))]
	public sealed partial class NestedAggregationDescriptor : DescriptorBase<NestedAggregationDescriptor>
	{
		internal string? _path;
	}

	internal sealed class NestedAggregationDescriptorConverter : JsonConverter<NestedAggregationDescriptor>
	{
		public override NestedAggregationDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, NestedAggregationDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value._path is not null)
			{
				writer.WritePropertyName("path");
				JsonSerializer.Serialize(writer, value._path, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class NormalizeAggregation : Aggregations.PipelineAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "normalize";
		[JsonInclude]
		[JsonPropertyName("method")]
		public Elastic.Clients.Elasticsearch.Aggregations.NormalizeMethod? Method { get; set; }
	}

	[JsonConverter(typeof(NormalizeAggregationDescriptorConverter))]
	public sealed partial class NormalizeAggregationDescriptor : DescriptorBase<NormalizeAggregationDescriptor>
	{
		internal Elastic.Clients.Elasticsearch.Aggregations.NormalizeMethod? _method;
	}

	internal sealed class NormalizeAggregationDescriptorConverter : JsonConverter<NormalizeAggregationDescriptor>
	{
		public override NormalizeAggregationDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, NormalizeAggregationDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value._method is not null)
			{
				writer.WritePropertyName("method");
				JsonSerializer.Serialize(writer, value._method, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class ParentAggregation : Aggregations.BucketAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "parent";
		[JsonInclude]
		[JsonPropertyName("type")]
		public string? Type { get; set; }
	}

	[JsonConverter(typeof(ParentAggregationDescriptorConverter))]
	public sealed partial class ParentAggregationDescriptor : DescriptorBase<ParentAggregationDescriptor>
	{
		internal string? _type;
	}

	internal sealed class ParentAggregationDescriptorConverter : JsonConverter<ParentAggregationDescriptor>
	{
		public override ParentAggregationDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, ParentAggregationDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value._type is not null)
			{
				writer.WritePropertyName("type");
				JsonSerializer.Serialize(writer, value._type, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class PercentageScoreHeuristic
	{
	}

	[JsonConverter(typeof(PercentageScoreHeuristicDescriptorConverter))]
	public sealed partial class PercentageScoreHeuristicDescriptor : DescriptorBase<PercentageScoreHeuristicDescriptor>
	{
	}

	internal sealed class PercentageScoreHeuristicDescriptorConverter : JsonConverter<PercentageScoreHeuristicDescriptor>
	{
		public override PercentageScoreHeuristicDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, PercentageScoreHeuristicDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WriteEndObject();
		}
	}

	public partial class PercentileRanksAggregation : Aggregations.FormatMetricAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "percentile_ranks";
		[JsonInclude]
		[JsonPropertyName("keyed")]
		public bool? Keyed { get; set; }

		[JsonInclude]
		[JsonPropertyName("values")]
		public IEnumerable<double>? Values { get; set; }

		[JsonInclude]
		[JsonPropertyName("hdr")]
		public Elastic.Clients.Elasticsearch.Aggregations.HdrMethod? Hdr { get; set; }

		[JsonInclude]
		[JsonPropertyName("tdigest")]
		public Elastic.Clients.Elasticsearch.Aggregations.TDigest? Tdigest { get; set; }
	}

	[JsonConverter(typeof(PercentileRanksAggregationDescriptorConverter))]
	public sealed partial class PercentileRanksAggregationDescriptor : DescriptorBase<PercentileRanksAggregationDescriptor>
	{
		internal bool? _keyed;
		internal IEnumerable<double>? _values;
		internal Elastic.Clients.Elasticsearch.Aggregations.HdrMethod? _hdr;
		internal Elastic.Clients.Elasticsearch.Aggregations.TDigest? _tdigest;
	}

	internal sealed class PercentileRanksAggregationDescriptorConverter : JsonConverter<PercentileRanksAggregationDescriptor>
	{
		public override PercentileRanksAggregationDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, PercentileRanksAggregationDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value._keyed.HasValue)
			{
				writer.WritePropertyName("keyed");
				writer.WriteBooleanValue(value._keyed.Value);
			}

			if (value._values is not null)
			{
				writer.WritePropertyName("values");
				JsonSerializer.Serialize(writer, value._values, options);
			}

			if (value._hdr is not null)
			{
				writer.WritePropertyName("hdr");
				JsonSerializer.Serialize(writer, value._hdr, options);
			}

			if (value._tdigest is not null)
			{
				writer.WritePropertyName("tdigest");
				JsonSerializer.Serialize(writer, value._tdigest, options);
			}

			writer.WriteEndObject();
		}
	}

	public abstract partial class PercentilesAggregateBase : Aggregations.AggregateBase
	{
		[JsonInclude]
		[JsonPropertyName("values")]
		public Union<Dictionary<string, object>, IReadOnlyCollection<Elastic.Clients.Elasticsearch.Aggregations.ArrayPercentilesItem>> Values { get; init; }
	}

	public partial class PercentilesAggregation : Aggregations.FormatMetricAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "percentiles";
		[JsonInclude]
		[JsonPropertyName("keyed")]
		public bool? Keyed { get; set; }

		[JsonInclude]
		[JsonPropertyName("percents")]
		public IEnumerable<double>? Percents { get; set; }

		[JsonInclude]
		[JsonPropertyName("hdr")]
		public Elastic.Clients.Elasticsearch.Aggregations.HdrMethod? Hdr { get; set; }

		[JsonInclude]
		[JsonPropertyName("tdigest")]
		public Elastic.Clients.Elasticsearch.Aggregations.TDigest? Tdigest { get; set; }
	}

	[JsonConverter(typeof(PercentilesAggregationDescriptorConverter))]
	public sealed partial class PercentilesAggregationDescriptor : DescriptorBase<PercentilesAggregationDescriptor>
	{
		internal bool? _keyed;
		internal IEnumerable<double>? _percents;
		internal Elastic.Clients.Elasticsearch.Aggregations.HdrMethod? _hdr;
		internal Elastic.Clients.Elasticsearch.Aggregations.TDigest? _tdigest;
	}

	internal sealed class PercentilesAggregationDescriptorConverter : JsonConverter<PercentilesAggregationDescriptor>
	{
		public override PercentilesAggregationDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, PercentilesAggregationDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value._keyed.HasValue)
			{
				writer.WritePropertyName("keyed");
				writer.WriteBooleanValue(value._keyed.Value);
			}

			if (value._percents is not null)
			{
				writer.WritePropertyName("percents");
				JsonSerializer.Serialize(writer, value._percents, options);
			}

			if (value._hdr is not null)
			{
				writer.WritePropertyName("hdr");
				JsonSerializer.Serialize(writer, value._hdr, options);
			}

			if (value._tdigest is not null)
			{
				writer.WritePropertyName("tdigest");
				JsonSerializer.Serialize(writer, value._tdigest, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class PercentilesBucketAggregate : Aggregations.PercentilesAggregateBase
	{
	}

	public partial class PercentilesBucketAggregation : Aggregations.PipelineAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "percentiles_bucket";
		[JsonInclude]
		[JsonPropertyName("percents")]
		public IEnumerable<double>? Percents { get; set; }
	}

	[JsonConverter(typeof(PercentilesBucketAggregationDescriptorConverter))]
	public sealed partial class PercentilesBucketAggregationDescriptor : DescriptorBase<PercentilesBucketAggregationDescriptor>
	{
		internal IEnumerable<double>? _percents;
	}

	internal sealed class PercentilesBucketAggregationDescriptorConverter : JsonConverter<PercentilesBucketAggregationDescriptor>
	{
		public override PercentilesBucketAggregationDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, PercentilesBucketAggregationDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value._percents is not null)
			{
				writer.WritePropertyName("percents");
				JsonSerializer.Serialize(writer, value._percents, options);
			}

			writer.WriteEndObject();
		}
	}

	public abstract partial class PipelineAggregationBase : Aggregations.Aggregation
	{
		[JsonInclude]
		[JsonPropertyName("buckets_path")]
		public object? BucketsPath { get; set; }

		[JsonInclude]
		[JsonPropertyName("format")]
		public string? Format { get; set; }

		[JsonInclude]
		[JsonPropertyName("gap_policy")]
		public Elastic.Clients.Elasticsearch.Aggregations.GapPolicy? GapPolicy { get; set; }
	}

	[JsonConverter(typeof(PipelineAggregationBaseDescriptorConverter))]
	public sealed partial class PipelineAggregationBaseDescriptor : DescriptorBase<PipelineAggregationBaseDescriptor>
	{
		internal object? _bucketsPath;
		internal string? _format;
		internal Elastic.Clients.Elasticsearch.Aggregations.GapPolicy? _gapPolicy;
	}

	internal sealed class PipelineAggregationBaseDescriptorConverter : JsonConverter<PipelineAggregationBaseDescriptor>
	{
		public override PipelineAggregationBaseDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, PipelineAggregationBaseDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value._bucketsPath is not null)
			{
				writer.WritePropertyName("buckets_path");
				JsonSerializer.Serialize(writer, value._bucketsPath, options);
			}

			if (!string.IsNullOrEmpty(value._format))
			{
				writer.WritePropertyName("format");
				writer.WriteStringValue(value._format);
			}

			if (value._gapPolicy is not null)
			{
				writer.WritePropertyName("gap_policy");
				JsonSerializer.Serialize(writer, value._gapPolicy, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class RangeAggregate : Aggregations.MultiBucketAggregateBase<Elastic.Clients.Elasticsearch.Aggregations.RangeBucket>
	{
	}

	public partial class RangeAggregation : Aggregations.BucketAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "range";
		[JsonInclude]
		[JsonPropertyName("field")]
		public string? Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("missing")]
		public int? Missing { get; set; }

		[JsonInclude]
		[JsonPropertyName("ranges")]
		public IEnumerable<Elastic.Clients.Elasticsearch.Aggregations.AggregationRange>? Ranges { get; set; }

		[JsonInclude]
		[JsonPropertyName("script")]
		public Elastic.Clients.Elasticsearch.Script? Script { get; set; }

		[JsonInclude]
		[JsonPropertyName("keyed")]
		public bool? Keyed { get; set; }
	}

	[JsonConverter(typeof(RangeAggregationDescriptorConverter))]
	public sealed partial class RangeAggregationDescriptor : DescriptorBase<RangeAggregationDescriptor>
	{
		internal string? _field;
		internal int? _missing;
		internal IEnumerable<Elastic.Clients.Elasticsearch.Aggregations.AggregationRange>? _ranges;
		internal Elastic.Clients.Elasticsearch.Script? _script;
		internal bool? _keyed;
	}

	internal sealed class RangeAggregationDescriptorConverter : JsonConverter<RangeAggregationDescriptor>
	{
		public override RangeAggregationDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, RangeAggregationDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value._field is not null)
			{
				writer.WritePropertyName("field");
				JsonSerializer.Serialize(writer, value._field, options);
			}

			if (value._missing.HasValue)
			{
				writer.WritePropertyName("missing");
				writer.WriteNumberValue(value._missing.Value);
			}

			if (value._ranges is not null)
			{
				writer.WritePropertyName("ranges");
				JsonSerializer.Serialize(writer, value._ranges, options);
			}

			if (value._script is not null)
			{
				writer.WritePropertyName("script");
				JsonSerializer.Serialize(writer, value._script, options);
			}

			if (value._keyed.HasValue)
			{
				writer.WritePropertyName("keyed");
				writer.WriteBooleanValue(value._keyed.Value);
			}

			writer.WriteEndObject();
		}
	}

	public partial class RangeBucket : Aggregations.MultiBucketBase
	{
		[JsonInclude]
		[JsonPropertyName("from")]
		public double? From { get; init; }

		[JsonInclude]
		[JsonPropertyName("to")]
		public double? To { get; init; }

		[JsonInclude]
		[JsonPropertyName("from_as_string")]
		public string? FromAsString { get; init; }

		[JsonInclude]
		[JsonPropertyName("to_as_string")]
		public string? ToAsString { get; init; }
	}

	public partial class RareTermsAggregation : Aggregations.BucketAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "rare_terms";
		[JsonInclude]
		[JsonPropertyName("exclude")]
		public IEnumerable<string>? Exclude { get; set; }

		[JsonInclude]
		[JsonPropertyName("field")]
		public string? Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("include")]
		public object? Include { get; set; }

		[JsonInclude]
		[JsonPropertyName("max_doc_count")]
		public long? MaxDocCount { get; set; }

		[JsonInclude]
		[JsonPropertyName("missing")]
		public Elastic.Clients.Elasticsearch.Aggregations.Missing? Missing { get; set; }

		[JsonInclude]
		[JsonPropertyName("precision")]
		public double? Precision { get; set; }

		[JsonInclude]
		[JsonPropertyName("value_type")]
		public string? ValueType { get; set; }
	}

	[JsonConverter(typeof(RareTermsAggregationDescriptorConverter))]
	public sealed partial class RareTermsAggregationDescriptor : DescriptorBase<RareTermsAggregationDescriptor>
	{
		internal IEnumerable<string>? _exclude;
		internal string? _field;
		internal object? _include;
		internal long? _maxDocCount;
		internal Elastic.Clients.Elasticsearch.Aggregations.Missing? _missing;
		internal double? _precision;
		internal string? _valueType;
	}

	internal sealed class RareTermsAggregationDescriptorConverter : JsonConverter<RareTermsAggregationDescriptor>
	{
		public override RareTermsAggregationDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, RareTermsAggregationDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value._exclude is not null)
			{
				writer.WritePropertyName("exclude");
				JsonSerializer.Serialize(writer, value._exclude, options);
			}

			if (value._field is not null)
			{
				writer.WritePropertyName("field");
				JsonSerializer.Serialize(writer, value._field, options);
			}

			if (value._include is not null)
			{
				writer.WritePropertyName("include");
				JsonSerializer.Serialize(writer, value._include, options);
			}

			if (value._maxDocCount.HasValue)
			{
				writer.WritePropertyName("max_doc_count");
				writer.WriteNumberValue(value._maxDocCount.Value);
			}

			if (value._missing is not null)
			{
				writer.WritePropertyName("missing");
				JsonSerializer.Serialize(writer, value._missing, options);
			}

			if (value._precision.HasValue)
			{
				writer.WritePropertyName("precision");
				writer.WriteNumberValue(value._precision.Value);
			}

			if (!string.IsNullOrEmpty(value._valueType))
			{
				writer.WritePropertyName("value_type");
				writer.WriteStringValue(value._valueType);
			}

			writer.WriteEndObject();
		}
	}

	public partial class RateAggregate : Aggregations.AggregateBase
	{
		[JsonInclude]
		[JsonPropertyName("value")]
		public double Value { get; init; }

		[JsonInclude]
		[JsonPropertyName("value_as_string")]
		public string? ValueAsString { get; init; }
	}

	public partial class RateAggregation : Aggregations.FormatMetricAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "rate";
		[JsonInclude]
		[JsonPropertyName("unit")]
		public Elastic.Clients.Elasticsearch.Aggregations.DateInterval? Unit { get; set; }

		[JsonInclude]
		[JsonPropertyName("mode")]
		public Elastic.Clients.Elasticsearch.Aggregations.RateMode? Mode { get; set; }
	}

	[JsonConverter(typeof(RateAggregationDescriptorConverter))]
	public sealed partial class RateAggregationDescriptor : DescriptorBase<RateAggregationDescriptor>
	{
		internal Elastic.Clients.Elasticsearch.Aggregations.DateInterval? _unit;
		internal Elastic.Clients.Elasticsearch.Aggregations.RateMode? _mode;
	}

	internal sealed class RateAggregationDescriptorConverter : JsonConverter<RateAggregationDescriptor>
	{
		public override RateAggregationDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, RateAggregationDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value._unit is not null)
			{
				writer.WritePropertyName("unit");
				JsonSerializer.Serialize(writer, value._unit, options);
			}

			if (value._mode is not null)
			{
				writer.WritePropertyName("mode");
				JsonSerializer.Serialize(writer, value._mode, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class RegressionInferenceOptions
	{
		[JsonInclude]
		[JsonPropertyName("results_field")]
		public string? ResultsField { get; set; }

		[JsonInclude]
		[JsonPropertyName("num_top_feature_importance_values")]
		public int? NumTopFeatureImportanceValues { get; set; }
	}

	[JsonConverter(typeof(RegressionInferenceOptionsDescriptorConverter))]
	public sealed partial class RegressionInferenceOptionsDescriptor : DescriptorBase<RegressionInferenceOptionsDescriptor>
	{
		internal string? _resultsField;
		internal int? _numTopFeatureImportanceValues;
	}

	internal sealed class RegressionInferenceOptionsDescriptorConverter : JsonConverter<RegressionInferenceOptionsDescriptor>
	{
		public override RegressionInferenceOptionsDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, RegressionInferenceOptionsDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value._resultsField is not null)
			{
				writer.WritePropertyName("results_field");
				JsonSerializer.Serialize(writer, value._resultsField, options);
			}

			if (value._numTopFeatureImportanceValues.HasValue)
			{
				writer.WritePropertyName("num_top_feature_importance_values");
				writer.WriteNumberValue(value._numTopFeatureImportanceValues.Value);
			}

			writer.WriteEndObject();
		}
	}

	public partial class ReverseNestedAggregate : Aggregations.SingleBucketAggregateBase
	{
	}

	public partial class ReverseNestedAggregation : Aggregations.BucketAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "reverse_nested";
		[JsonInclude]
		[JsonPropertyName("path")]
		public string? Path { get; set; }
	}

	[JsonConverter(typeof(ReverseNestedAggregationDescriptorConverter))]
	public sealed partial class ReverseNestedAggregationDescriptor : DescriptorBase<ReverseNestedAggregationDescriptor>
	{
		internal string? _path;
	}

	internal sealed class ReverseNestedAggregationDescriptorConverter : JsonConverter<ReverseNestedAggregationDescriptor>
	{
		public override ReverseNestedAggregationDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, ReverseNestedAggregationDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value._path is not null)
			{
				writer.WritePropertyName("path");
				JsonSerializer.Serialize(writer, value._path, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class SamplerAggregate : Aggregations.SingleBucketAggregateBase
	{
	}

	public partial class SamplerAggregation : Aggregations.BucketAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "sampler";
		[JsonInclude]
		[JsonPropertyName("shard_size")]
		public int? ShardSize { get; set; }
	}

	[JsonConverter(typeof(SamplerAggregationDescriptorConverter))]
	public sealed partial class SamplerAggregationDescriptor : DescriptorBase<SamplerAggregationDescriptor>
	{
		internal int? _shardSize;
	}

	internal sealed class SamplerAggregationDescriptorConverter : JsonConverter<SamplerAggregationDescriptor>
	{
		public override SamplerAggregationDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, SamplerAggregationDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value._shardSize.HasValue)
			{
				writer.WritePropertyName("shard_size");
				writer.WriteNumberValue(value._shardSize.Value);
			}

			writer.WriteEndObject();
		}
	}

	public partial class ScriptedHeuristic
	{
		[JsonInclude]
		[JsonPropertyName("script")]
		public Elastic.Clients.Elasticsearch.Script Script { get; set; }
	}

	[JsonConverter(typeof(ScriptedHeuristicDescriptorConverter))]
	public sealed partial class ScriptedHeuristicDescriptor : DescriptorBase<ScriptedHeuristicDescriptor>
	{
		internal Elastic.Clients.Elasticsearch.Script _script;
	}

	internal sealed class ScriptedHeuristicDescriptorConverter : JsonConverter<ScriptedHeuristicDescriptor>
	{
		public override ScriptedHeuristicDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, ScriptedHeuristicDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("script");
			JsonSerializer.Serialize(writer, value._script, options);
			writer.WriteEndObject();
		}
	}

	public partial class ScriptedMetricAggregate : Aggregations.AggregateBase
	{
		[JsonInclude]
		[JsonPropertyName("value")]
		public object Value { get; init; }
	}

	public partial class ScriptedMetricAggregation : Aggregations.MetricAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "scripted_metric";
		[JsonInclude]
		[JsonPropertyName("combine_script")]
		public Elastic.Clients.Elasticsearch.Script? CombineScript { get; set; }

		[JsonInclude]
		[JsonPropertyName("init_script")]
		public Elastic.Clients.Elasticsearch.Script? InitScript { get; set; }

		[JsonInclude]
		[JsonPropertyName("map_script")]
		public Elastic.Clients.Elasticsearch.Script? MapScript { get; set; }

		[JsonInclude]
		[JsonPropertyName("params")]
		public Dictionary<string, object>? Params { get; set; }

		[JsonInclude]
		[JsonPropertyName("reduce_script")]
		public Elastic.Clients.Elasticsearch.Script? ReduceScript { get; set; }
	}

	[JsonConverter(typeof(ScriptedMetricAggregationDescriptorConverter))]
	public sealed partial class ScriptedMetricAggregationDescriptor : DescriptorBase<ScriptedMetricAggregationDescriptor>
	{
		internal Elastic.Clients.Elasticsearch.Script? _combineScript;
		internal Elastic.Clients.Elasticsearch.Script? _initScript;
		internal Elastic.Clients.Elasticsearch.Script? _mapScript;
		internal Dictionary<string, object>? _params;
		internal Elastic.Clients.Elasticsearch.Script? _reduceScript;
	}

	internal sealed class ScriptedMetricAggregationDescriptorConverter : JsonConverter<ScriptedMetricAggregationDescriptor>
	{
		public override ScriptedMetricAggregationDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, ScriptedMetricAggregationDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value._combineScript is not null)
			{
				writer.WritePropertyName("combine_script");
				JsonSerializer.Serialize(writer, value._combineScript, options);
			}

			if (value._initScript is not null)
			{
				writer.WritePropertyName("init_script");
				JsonSerializer.Serialize(writer, value._initScript, options);
			}

			if (value._mapScript is not null)
			{
				writer.WritePropertyName("map_script");
				JsonSerializer.Serialize(writer, value._mapScript, options);
			}

			if (value._params is not null)
			{
				writer.WritePropertyName("params");
				JsonSerializer.Serialize(writer, value._params, options);
			}

			if (value._reduceScript is not null)
			{
				writer.WritePropertyName("reduce_script");
				JsonSerializer.Serialize(writer, value._reduceScript, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class SerialDifferencingAggregation : Aggregations.PipelineAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "serial_diff";
		[JsonInclude]
		[JsonPropertyName("lag")]
		public int? Lag { get; set; }
	}

	[JsonConverter(typeof(SerialDifferencingAggregationDescriptorConverter))]
	public sealed partial class SerialDifferencingAggregationDescriptor : DescriptorBase<SerialDifferencingAggregationDescriptor>
	{
		internal int? _lag;
	}

	internal sealed class SerialDifferencingAggregationDescriptorConverter : JsonConverter<SerialDifferencingAggregationDescriptor>
	{
		public override SerialDifferencingAggregationDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, SerialDifferencingAggregationDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value._lag.HasValue)
			{
				writer.WritePropertyName("lag");
				writer.WriteNumberValue(value._lag.Value);
			}

			writer.WriteEndObject();
		}
	}

	public partial class SignificantLongTermsAggregate : Aggregations.MultiBucketAggregateBase<Elastic.Clients.Elasticsearch.Aggregations.SignificantLongTermsBucket>
	{
	}

	public partial class SignificantLongTermsBucket : Aggregations.SignificantTermsBucketBase
	{
		[JsonInclude]
		[JsonPropertyName("key")]
		public long Key { get; init; }

		[JsonInclude]
		[JsonPropertyName("key_as_string")]
		public string? KeyAsString { get; init; }
	}

	public partial class SignificantStringTermsAggregate : Aggregations.MultiBucketAggregateBase<Elastic.Clients.Elasticsearch.Aggregations.SignificantStringTermsBucket>
	{
	}

	public partial class SignificantStringTermsBucket : Aggregations.SignificantTermsBucketBase
	{
		[JsonInclude]
		[JsonPropertyName("key")]
		public string Key { get; init; }
	}

	public partial class SignificantTermsAggregation : Aggregations.BucketAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "significant_terms";
		[JsonInclude]
		[JsonPropertyName("background_filter")]
		public Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? BackgroundFilter { get; set; }

		[JsonInclude]
		[JsonPropertyName("chi_square")]
		public Elastic.Clients.Elasticsearch.Aggregations.ChiSquareHeuristic? ChiSquare { get; set; }

		[JsonInclude]
		[JsonPropertyName("exclude")]
		public IEnumerable<string>? Exclude { get; set; }

		[JsonInclude]
		[JsonPropertyName("execution_hint")]
		public Elastic.Clients.Elasticsearch.Aggregations.TermsAggregationExecutionHint? ExecutionHint { get; set; }

		[JsonInclude]
		[JsonPropertyName("field")]
		public string? Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("gnd")]
		public Elastic.Clients.Elasticsearch.Aggregations.GoogleNormalizedDistanceHeuristic? Gnd { get; set; }

		[JsonInclude]
		[JsonPropertyName("include")]
		public IEnumerable<string>? Include { get; set; }

		[JsonInclude]
		[JsonPropertyName("min_doc_count")]
		public long? MinDocCount { get; set; }

		[JsonInclude]
		[JsonPropertyName("mutual_information")]
		public Elastic.Clients.Elasticsearch.Aggregations.MutualInformationHeuristic? MutualInformation { get; set; }

		[JsonInclude]
		[JsonPropertyName("percentage")]
		public Elastic.Clients.Elasticsearch.Aggregations.PercentageScoreHeuristic? Percentage { get; set; }

		[JsonInclude]
		[JsonPropertyName("script_heuristic")]
		public Elastic.Clients.Elasticsearch.Aggregations.ScriptedHeuristic? ScriptHeuristic { get; set; }

		[JsonInclude]
		[JsonPropertyName("shard_min_doc_count")]
		public long? ShardMinDocCount { get; set; }

		[JsonInclude]
		[JsonPropertyName("shard_size")]
		public int? ShardSize { get; set; }

		[JsonInclude]
		[JsonPropertyName("size")]
		public int? Size { get; set; }
	}

	[JsonConverter(typeof(SignificantTermsAggregationDescriptorConverter))]
	public sealed partial class SignificantTermsAggregationDescriptor : DescriptorBase<SignificantTermsAggregationDescriptor>
	{
		internal Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? _backgroundFilter;
		internal Elastic.Clients.Elasticsearch.Aggregations.ChiSquareHeuristic? _chiSquare;
		internal IEnumerable<string>? _exclude;
		internal Elastic.Clients.Elasticsearch.Aggregations.TermsAggregationExecutionHint? _executionHint;
		internal string? _field;
		internal Elastic.Clients.Elasticsearch.Aggregations.GoogleNormalizedDistanceHeuristic? _gnd;
		internal IEnumerable<string>? _include;
		internal long? _minDocCount;
		internal Elastic.Clients.Elasticsearch.Aggregations.MutualInformationHeuristic? _mutualInformation;
		internal Elastic.Clients.Elasticsearch.Aggregations.PercentageScoreHeuristic? _percentage;
		internal Elastic.Clients.Elasticsearch.Aggregations.ScriptedHeuristic? _scriptHeuristic;
		internal long? _shardMinDocCount;
		internal int? _shardSize;
		internal int? _size;
	}

	internal sealed class SignificantTermsAggregationDescriptorConverter : JsonConverter<SignificantTermsAggregationDescriptor>
	{
		public override SignificantTermsAggregationDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, SignificantTermsAggregationDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value._backgroundFilter is not null)
			{
				writer.WritePropertyName("background_filter");
				JsonSerializer.Serialize(writer, value._backgroundFilter, options);
			}

			if (value._chiSquare is not null)
			{
				writer.WritePropertyName("chi_square");
				JsonSerializer.Serialize(writer, value._chiSquare, options);
			}

			if (value._exclude is not null)
			{
				writer.WritePropertyName("exclude");
				JsonSerializer.Serialize(writer, value._exclude, options);
			}

			if (value._executionHint is not null)
			{
				writer.WritePropertyName("execution_hint");
				JsonSerializer.Serialize(writer, value._executionHint, options);
			}

			if (value._field is not null)
			{
				writer.WritePropertyName("field");
				JsonSerializer.Serialize(writer, value._field, options);
			}

			if (value._gnd is not null)
			{
				writer.WritePropertyName("gnd");
				JsonSerializer.Serialize(writer, value._gnd, options);
			}

			if (value._include is not null)
			{
				writer.WritePropertyName("include");
				JsonSerializer.Serialize(writer, value._include, options);
			}

			if (value._minDocCount.HasValue)
			{
				writer.WritePropertyName("min_doc_count");
				writer.WriteNumberValue(value._minDocCount.Value);
			}

			if (value._mutualInformation is not null)
			{
				writer.WritePropertyName("mutual_information");
				JsonSerializer.Serialize(writer, value._mutualInformation, options);
			}

			if (value._percentage is not null)
			{
				writer.WritePropertyName("percentage");
				JsonSerializer.Serialize(writer, value._percentage, options);
			}

			if (value._scriptHeuristic is not null)
			{
				writer.WritePropertyName("script_heuristic");
				JsonSerializer.Serialize(writer, value._scriptHeuristic, options);
			}

			if (value._shardMinDocCount.HasValue)
			{
				writer.WritePropertyName("shard_min_doc_count");
				writer.WriteNumberValue(value._shardMinDocCount.Value);
			}

			if (value._shardSize.HasValue)
			{
				writer.WritePropertyName("shard_size");
				writer.WriteNumberValue(value._shardSize.Value);
			}

			if (value._size.HasValue)
			{
				writer.WritePropertyName("size");
				writer.WriteNumberValue(value._size.Value);
			}

			writer.WriteEndObject();
		}
	}

	public abstract partial class SignificantTermsBucketBase : Aggregations.MultiBucketBase
	{
		[JsonInclude]
		[JsonPropertyName("score")]
		public double Score { get; init; }

		[JsonInclude]
		[JsonPropertyName("bg_count")]
		public long BgCount { get; init; }
	}

	public partial class SignificantTextAggregation : Aggregations.BucketAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "significant_text";
		[JsonInclude]
		[JsonPropertyName("background_filter")]
		public Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? BackgroundFilter { get; set; }

		[JsonInclude]
		[JsonPropertyName("chi_square")]
		public Elastic.Clients.Elasticsearch.Aggregations.ChiSquareHeuristic? ChiSquare { get; set; }

		[JsonInclude]
		[JsonPropertyName("exclude")]
		public IEnumerable<string>? Exclude { get; set; }

		[JsonInclude]
		[JsonPropertyName("execution_hint")]
		public Elastic.Clients.Elasticsearch.Aggregations.TermsAggregationExecutionHint? ExecutionHint { get; set; }

		[JsonInclude]
		[JsonPropertyName("field")]
		public string? Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("filter_duplicate_text")]
		public bool? FilterDuplicateText { get; set; }

		[JsonInclude]
		[JsonPropertyName("gnd")]
		public Elastic.Clients.Elasticsearch.Aggregations.GoogleNormalizedDistanceHeuristic? Gnd { get; set; }

		[JsonInclude]
		[JsonPropertyName("include")]
		public IEnumerable<string>? Include { get; set; }

		[JsonInclude]
		[JsonPropertyName("min_doc_count")]
		public long? MinDocCount { get; set; }

		[JsonInclude]
		[JsonPropertyName("mutual_information")]
		public Elastic.Clients.Elasticsearch.Aggregations.MutualInformationHeuristic? MutualInformation { get; set; }

		[JsonInclude]
		[JsonPropertyName("percentage")]
		public Elastic.Clients.Elasticsearch.Aggregations.PercentageScoreHeuristic? Percentage { get; set; }

		[JsonInclude]
		[JsonPropertyName("script_heuristic")]
		public Elastic.Clients.Elasticsearch.Aggregations.ScriptedHeuristic? ScriptHeuristic { get; set; }

		[JsonInclude]
		[JsonPropertyName("shard_min_doc_count")]
		public long? ShardMinDocCount { get; set; }

		[JsonInclude]
		[JsonPropertyName("shard_size")]
		public int? ShardSize { get; set; }

		[JsonInclude]
		[JsonPropertyName("size")]
		public int? Size { get; set; }

		[JsonInclude]
		[JsonPropertyName("source_fields")]
		public Elastic.Clients.Elasticsearch.Fields? SourceFields { get; set; }
	}

	[JsonConverter(typeof(SignificantTextAggregationDescriptorConverter))]
	public sealed partial class SignificantTextAggregationDescriptor : DescriptorBase<SignificantTextAggregationDescriptor>
	{
		internal Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? _backgroundFilter;
		internal Elastic.Clients.Elasticsearch.Aggregations.ChiSquareHeuristic? _chiSquare;
		internal IEnumerable<string>? _exclude;
		internal Elastic.Clients.Elasticsearch.Aggregations.TermsAggregationExecutionHint? _executionHint;
		internal string? _field;
		internal bool? _filterDuplicateText;
		internal Elastic.Clients.Elasticsearch.Aggregations.GoogleNormalizedDistanceHeuristic? _gnd;
		internal IEnumerable<string>? _include;
		internal long? _minDocCount;
		internal Elastic.Clients.Elasticsearch.Aggregations.MutualInformationHeuristic? _mutualInformation;
		internal Elastic.Clients.Elasticsearch.Aggregations.PercentageScoreHeuristic? _percentage;
		internal Elastic.Clients.Elasticsearch.Aggregations.ScriptedHeuristic? _scriptHeuristic;
		internal long? _shardMinDocCount;
		internal int? _shardSize;
		internal int? _size;
		internal Elastic.Clients.Elasticsearch.Fields? _sourceFields;
	}

	internal sealed class SignificantTextAggregationDescriptorConverter : JsonConverter<SignificantTextAggregationDescriptor>
	{
		public override SignificantTextAggregationDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, SignificantTextAggregationDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value._backgroundFilter is not null)
			{
				writer.WritePropertyName("background_filter");
				JsonSerializer.Serialize(writer, value._backgroundFilter, options);
			}

			if (value._chiSquare is not null)
			{
				writer.WritePropertyName("chi_square");
				JsonSerializer.Serialize(writer, value._chiSquare, options);
			}

			if (value._exclude is not null)
			{
				writer.WritePropertyName("exclude");
				JsonSerializer.Serialize(writer, value._exclude, options);
			}

			if (value._executionHint is not null)
			{
				writer.WritePropertyName("execution_hint");
				JsonSerializer.Serialize(writer, value._executionHint, options);
			}

			if (value._field is not null)
			{
				writer.WritePropertyName("field");
				JsonSerializer.Serialize(writer, value._field, options);
			}

			if (value._filterDuplicateText.HasValue)
			{
				writer.WritePropertyName("filter_duplicate_text");
				writer.WriteBooleanValue(value._filterDuplicateText.Value);
			}

			if (value._gnd is not null)
			{
				writer.WritePropertyName("gnd");
				JsonSerializer.Serialize(writer, value._gnd, options);
			}

			if (value._include is not null)
			{
				writer.WritePropertyName("include");
				JsonSerializer.Serialize(writer, value._include, options);
			}

			if (value._minDocCount.HasValue)
			{
				writer.WritePropertyName("min_doc_count");
				writer.WriteNumberValue(value._minDocCount.Value);
			}

			if (value._mutualInformation is not null)
			{
				writer.WritePropertyName("mutual_information");
				JsonSerializer.Serialize(writer, value._mutualInformation, options);
			}

			if (value._percentage is not null)
			{
				writer.WritePropertyName("percentage");
				JsonSerializer.Serialize(writer, value._percentage, options);
			}

			if (value._scriptHeuristic is not null)
			{
				writer.WritePropertyName("script_heuristic");
				JsonSerializer.Serialize(writer, value._scriptHeuristic, options);
			}

			if (value._shardMinDocCount.HasValue)
			{
				writer.WritePropertyName("shard_min_doc_count");
				writer.WriteNumberValue(value._shardMinDocCount.Value);
			}

			if (value._shardSize.HasValue)
			{
				writer.WritePropertyName("shard_size");
				writer.WriteNumberValue(value._shardSize.Value);
			}

			if (value._size.HasValue)
			{
				writer.WritePropertyName("size");
				writer.WriteNumberValue(value._size.Value);
			}

			if (value._sourceFields is not null)
			{
				writer.WritePropertyName("source_fields");
				JsonSerializer.Serialize(writer, value._sourceFields, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class SimpleValueAggregate : Aggregations.SingleMetricAggregateBase
	{
	}

	public abstract partial class SingleBucketAggregateBase : Aggregations.AggregateBase
	{
		[JsonInclude]
		[JsonPropertyName("doc_count")]
		public long DocCount { get; init; }
	}

	public abstract partial class SingleMetricAggregateBase : Aggregations.AggregateBase
	{
		[JsonInclude]
		[JsonPropertyName("value")]
		public object Value { get; init; }

		[JsonInclude]
		[JsonPropertyName("value_as_string")]
		public string? ValueAsString { get; init; }
	}

	public partial class StandardDeviationBounds
	{
		[JsonInclude]
		[JsonPropertyName("upper")]
		public object Upper { get; init; }

		[JsonInclude]
		[JsonPropertyName("lower")]
		public object Lower { get; init; }

		[JsonInclude]
		[JsonPropertyName("upper_population")]
		public object UpperPopulation { get; init; }

		[JsonInclude]
		[JsonPropertyName("lower_population")]
		public object LowerPopulation { get; init; }

		[JsonInclude]
		[JsonPropertyName("upper_sampling")]
		public object UpperSampling { get; init; }

		[JsonInclude]
		[JsonPropertyName("lower_sampling")]
		public object LowerSampling { get; init; }
	}

	public partial class StandardDeviationBoundsAsString
	{
		[JsonInclude]
		[JsonPropertyName("upper")]
		public string Upper { get; init; }

		[JsonInclude]
		[JsonPropertyName("lower")]
		public string Lower { get; init; }

		[JsonInclude]
		[JsonPropertyName("upper_population")]
		public string UpperPopulation { get; init; }

		[JsonInclude]
		[JsonPropertyName("lower_population")]
		public string LowerPopulation { get; init; }

		[JsonInclude]
		[JsonPropertyName("upper_sampling")]
		public string UpperSampling { get; init; }

		[JsonInclude]
		[JsonPropertyName("lower_sampling")]
		public string LowerSampling { get; init; }
	}

	public partial class StatsAggregate : Aggregations.AggregateBase
	{
		[JsonInclude]
		[JsonPropertyName("count")]
		public long Count { get; init; }

		[JsonInclude]
		[JsonPropertyName("min")]
		public object Min { get; init; }

		[JsonInclude]
		[JsonPropertyName("max")]
		public object Max { get; init; }

		[JsonInclude]
		[JsonPropertyName("avg")]
		public object Avg { get; init; }

		[JsonInclude]
		[JsonPropertyName("sum")]
		public double Sum { get; init; }

		[JsonInclude]
		[JsonPropertyName("min_as_string")]
		public string? MinAsString { get; init; }

		[JsonInclude]
		[JsonPropertyName("max_as_string")]
		public string? MaxAsString { get; init; }

		[JsonInclude]
		[JsonPropertyName("avg_as_string")]
		public string? AvgAsString { get; init; }

		[JsonInclude]
		[JsonPropertyName("sum_as_string")]
		public string? SumAsString { get; init; }
	}

	public partial class StatsAggregation : Aggregations.FormatMetricAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "stats";
	}

	[JsonConverter(typeof(StatsAggregationDescriptorConverter))]
	public sealed partial class StatsAggregationDescriptor : DescriptorBase<StatsAggregationDescriptor>
	{
	}

	internal sealed class StatsAggregationDescriptorConverter : JsonConverter<StatsAggregationDescriptor>
	{
		public override StatsAggregationDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, StatsAggregationDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WriteEndObject();
		}
	}

	public partial class StatsBucketAggregate : Aggregations.StatsAggregate
	{
	}

	public partial class StatsBucketAggregation : Aggregations.PipelineAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "stats_bucket";
	}

	[JsonConverter(typeof(StatsBucketAggregationDescriptorConverter))]
	public sealed partial class StatsBucketAggregationDescriptor : DescriptorBase<StatsBucketAggregationDescriptor>
	{
	}

	internal sealed class StatsBucketAggregationDescriptorConverter : JsonConverter<StatsBucketAggregationDescriptor>
	{
		public override StatsBucketAggregationDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, StatsBucketAggregationDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WriteEndObject();
		}
	}

	public partial class StringRareTermsAggregate : Aggregations.MultiBucketAggregateBase<Elastic.Clients.Elasticsearch.Aggregations.StringRareTermsBucket>
	{
	}

	public partial class StringRareTermsBucket : Aggregations.MultiBucketBase
	{
		[JsonInclude]
		[JsonPropertyName("key")]
		public string Key { get; init; }
	}

	public partial class StringStatsAggregate : Aggregations.AggregateBase
	{
		[JsonInclude]
		[JsonPropertyName("count")]
		public long Count { get; init; }

		[JsonInclude]
		[JsonPropertyName("min_length")]
		public object MinLength { get; init; }

		[JsonInclude]
		[JsonPropertyName("max_length")]
		public object MaxLength { get; init; }

		[JsonInclude]
		[JsonPropertyName("avg_length")]
		public object AvgLength { get; init; }

		[JsonInclude]
		[JsonPropertyName("entropy")]
		public object Entropy { get; init; }

		[JsonInclude]
		[JsonPropertyName("distribution")]
		public object? Distribution { get; init; }

		[JsonInclude]
		[JsonPropertyName("min_length_as_string")]
		public string? MinLengthAsString { get; init; }

		[JsonInclude]
		[JsonPropertyName("max_length_as_string")]
		public string? MaxLengthAsString { get; init; }

		[JsonInclude]
		[JsonPropertyName("avg_length_as_string")]
		public string? AvgLengthAsString { get; init; }
	}

	public partial class StringStatsAggregation : Aggregations.MetricAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "string_stats";
		[JsonInclude]
		[JsonPropertyName("show_distribution")]
		public bool? ShowDistribution { get; set; }
	}

	[JsonConverter(typeof(StringStatsAggregationDescriptorConverter))]
	public sealed partial class StringStatsAggregationDescriptor : DescriptorBase<StringStatsAggregationDescriptor>
	{
		internal bool? _showDistribution;
	}

	internal sealed class StringStatsAggregationDescriptorConverter : JsonConverter<StringStatsAggregationDescriptor>
	{
		public override StringStatsAggregationDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, StringStatsAggregationDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value._showDistribution.HasValue)
			{
				writer.WritePropertyName("show_distribution");
				writer.WriteBooleanValue(value._showDistribution.Value);
			}

			writer.WriteEndObject();
		}
	}

	public partial class StringTermsAggregate : Aggregations.TermsAggregateBase<Elastic.Clients.Elasticsearch.Aggregations.StringTermsBucket>
	{
	}

	public partial class StringTermsBucket : Aggregations.TermsBucketBase
	{
		[JsonInclude]
		[JsonPropertyName("key")]
		public string Key { get; init; }
	}

	public partial class SumAggregate : Aggregations.SingleMetricAggregateBase
	{
	}

	public partial class SumAggregation : Aggregations.FormatMetricAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "sum";
	}

	[JsonConverter(typeof(SumAggregationDescriptorConverter))]
	public sealed partial class SumAggregationDescriptor : DescriptorBase<SumAggregationDescriptor>
	{
	}

	internal sealed class SumAggregationDescriptorConverter : JsonConverter<SumAggregationDescriptor>
	{
		public override SumAggregationDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, SumAggregationDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WriteEndObject();
		}
	}

	public partial class SumBucketAggregation : Aggregations.PipelineAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "sum_bucket";
	}

	[JsonConverter(typeof(SumBucketAggregationDescriptorConverter))]
	public sealed partial class SumBucketAggregationDescriptor : DescriptorBase<SumBucketAggregationDescriptor>
	{
	}

	internal sealed class SumBucketAggregationDescriptorConverter : JsonConverter<SumBucketAggregationDescriptor>
	{
		public override SumBucketAggregationDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, SumBucketAggregationDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WriteEndObject();
		}
	}

	public partial class TDigest
	{
		[JsonInclude]
		[JsonPropertyName("compression")]
		public int? Compression { get; set; }
	}

	[JsonConverter(typeof(TDigestDescriptorConverter))]
	public sealed partial class TDigestDescriptor : DescriptorBase<TDigestDescriptor>
	{
		internal int? _compression;
	}

	internal sealed class TDigestDescriptorConverter : JsonConverter<TDigestDescriptor>
	{
		public override TDigestDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, TDigestDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value._compression.HasValue)
			{
				writer.WritePropertyName("compression");
				writer.WriteNumberValue(value._compression.Value);
			}

			writer.WriteEndObject();
		}
	}

	public partial class TDigestPercentileRanksAggregate : Aggregations.PercentilesAggregateBase
	{
	}

	public partial class TDigestPercentilesAggregate : Aggregations.PercentilesAggregateBase
	{
	}

	public abstract partial class TermsAggregateBase<TBucket> : Aggregations.MultiBucketAggregateBase<TBucket>
	{
		[JsonInclude]
		[JsonPropertyName("doc_count_error_upper_bound")]
		public long? DocCountErrorUpperBound { get; init; }

		[JsonInclude]
		[JsonPropertyName("sum_other_doc_count")]
		public long SumOtherDocCount { get; init; }
	}

	public partial class TermsAggregation : Aggregations.BucketAggregationBase, IAggregationContainerVariant, TransformManagement.IPivotGroupByContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "terms";
		[JsonIgnore]
		string TransformManagement.IPivotGroupByContainerVariant.PivotGroupByContainerVariantName => "terms";
		[JsonInclude]
		[JsonPropertyName("collect_mode")]
		public Elastic.Clients.Elasticsearch.Aggregations.TermsAggregationCollectMode? CollectMode { get; set; }

		[JsonInclude]
		[JsonPropertyName("exclude")]
		public IEnumerable<string>? Exclude { get; set; }

		[JsonInclude]
		[JsonPropertyName("execution_hint")]
		public Elastic.Clients.Elasticsearch.Aggregations.TermsAggregationExecutionHint? ExecutionHint { get; set; }

		[JsonInclude]
		[JsonPropertyName("field")]
		public string? Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("include")]
		public object? Include { get; set; }

		[JsonInclude]
		[JsonPropertyName("min_doc_count")]
		public int? MinDocCount { get; set; }

		[JsonInclude]
		[JsonPropertyName("missing")]
		public Elastic.Clients.Elasticsearch.Aggregations.Missing? Missing { get; set; }

		[JsonInclude]
		[JsonPropertyName("missing_order")]
		public Elastic.Clients.Elasticsearch.Aggregations.MissingOrder? MissingOrder { get; set; }

		[JsonInclude]
		[JsonPropertyName("missing_bucket")]
		public bool? MissingBucket { get; set; }

		[JsonInclude]
		[JsonPropertyName("value_type")]
		public string? ValueType { get; set; }

		[JsonInclude]
		[JsonPropertyName("order")]
		public Elastic.Clients.Elasticsearch.Aggregations.TermsAggregationOrder? Order { get; set; }

		[JsonInclude]
		[JsonPropertyName("script")]
		public Elastic.Clients.Elasticsearch.Script? Script { get; set; }

		[JsonInclude]
		[JsonPropertyName("shard_size")]
		public int? ShardSize { get; set; }

		[JsonInclude]
		[JsonPropertyName("show_term_doc_count_error")]
		public bool? ShowTermDocCountError { get; set; }

		[JsonInclude]
		[JsonPropertyName("size")]
		public int? Size { get; set; }
	}

	[JsonConverter(typeof(TermsAggregationDescriptorConverter))]
	public sealed partial class TermsAggregationDescriptor : DescriptorBase<TermsAggregationDescriptor>
	{
		internal Elastic.Clients.Elasticsearch.Aggregations.TermsAggregationCollectMode? _collectMode;
		internal IEnumerable<string>? _exclude;
		internal Elastic.Clients.Elasticsearch.Aggregations.TermsAggregationExecutionHint? _executionHint;
		internal string? _field;
		internal object? _include;
		internal int? _minDocCount;
		internal Elastic.Clients.Elasticsearch.Aggregations.Missing? _missing;
		internal Elastic.Clients.Elasticsearch.Aggregations.MissingOrder? _missingOrder;
		internal bool? _missingBucket;
		internal string? _valueType;
		internal Elastic.Clients.Elasticsearch.Aggregations.TermsAggregationOrder? _order;
		internal Elastic.Clients.Elasticsearch.Script? _script;
		internal int? _shardSize;
		internal bool? _showTermDocCountError;
		internal int? _size;
	}

	internal sealed class TermsAggregationDescriptorConverter : JsonConverter<TermsAggregationDescriptor>
	{
		public override TermsAggregationDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, TermsAggregationDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value._collectMode is not null)
			{
				writer.WritePropertyName("collect_mode");
				JsonSerializer.Serialize(writer, value._collectMode, options);
			}

			if (value._exclude is not null)
			{
				writer.WritePropertyName("exclude");
				JsonSerializer.Serialize(writer, value._exclude, options);
			}

			if (value._executionHint is not null)
			{
				writer.WritePropertyName("execution_hint");
				JsonSerializer.Serialize(writer, value._executionHint, options);
			}

			if (value._field is not null)
			{
				writer.WritePropertyName("field");
				JsonSerializer.Serialize(writer, value._field, options);
			}

			if (value._include is not null)
			{
				writer.WritePropertyName("include");
				JsonSerializer.Serialize(writer, value._include, options);
			}

			if (value._minDocCount.HasValue)
			{
				writer.WritePropertyName("min_doc_count");
				writer.WriteNumberValue(value._minDocCount.Value);
			}

			if (value._missing is not null)
			{
				writer.WritePropertyName("missing");
				JsonSerializer.Serialize(writer, value._missing, options);
			}

			if (value._missingOrder is not null)
			{
				writer.WritePropertyName("missing_order");
				JsonSerializer.Serialize(writer, value._missingOrder, options);
			}

			if (value._missingBucket.HasValue)
			{
				writer.WritePropertyName("missing_bucket");
				writer.WriteBooleanValue(value._missingBucket.Value);
			}

			if (!string.IsNullOrEmpty(value._valueType))
			{
				writer.WritePropertyName("value_type");
				writer.WriteStringValue(value._valueType);
			}

			if (value._order is not null)
			{
				writer.WritePropertyName("order");
				JsonSerializer.Serialize(writer, value._order, options);
			}

			if (value._script is not null)
			{
				writer.WritePropertyName("script");
				JsonSerializer.Serialize(writer, value._script, options);
			}

			if (value._shardSize.HasValue)
			{
				writer.WritePropertyName("shard_size");
				writer.WriteNumberValue(value._shardSize.Value);
			}

			if (value._showTermDocCountError.HasValue)
			{
				writer.WritePropertyName("show_term_doc_count_error");
				writer.WriteBooleanValue(value._showTermDocCountError.Value);
			}

			if (value._size.HasValue)
			{
				writer.WritePropertyName("size");
				writer.WriteNumberValue(value._size.Value);
			}

			writer.WriteEndObject();
		}
	}

	public abstract partial class TermsBucketBase : Aggregations.MultiBucketBase
	{
		[JsonInclude]
		[JsonPropertyName("doc_count_error")]
		public long? DocCountError { get; init; }
	}

	public partial class TermsInclude
	{
		[JsonInclude]
		[JsonPropertyName("num_partitions")]
		public long NumPartitions { get; set; }

		[JsonInclude]
		[JsonPropertyName("partition")]
		public long Partition { get; set; }
	}

	[JsonConverter(typeof(TermsIncludeDescriptorConverter))]
	public sealed partial class TermsIncludeDescriptor : DescriptorBase<TermsIncludeDescriptor>
	{
		internal long _numPartitions;
		internal long _partition;
	}

	internal sealed class TermsIncludeDescriptorConverter : JsonConverter<TermsIncludeDescriptor>
	{
		public override TermsIncludeDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, TermsIncludeDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("num_partitions");
			writer.WriteNumberValue(value._numPartitions);
			writer.WritePropertyName("partition");
			writer.WriteNumberValue(value._partition);
			writer.WriteEndObject();
		}
	}

	public partial class TestPopulation
	{
		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("script")]
		public Elastic.Clients.Elasticsearch.Script? Script { get; set; }

		[JsonInclude]
		[JsonPropertyName("filter")]
		public Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? Filter { get; set; }
	}

	[JsonConverter(typeof(TestPopulationDescriptorConverter))]
	public sealed partial class TestPopulationDescriptor : DescriptorBase<TestPopulationDescriptor>
	{
		internal string _field;
		internal Elastic.Clients.Elasticsearch.Script? _script;
		internal Elastic.Clients.Elasticsearch.QueryDsl.QueryContainer? _filter;
	}

	internal sealed class TestPopulationDescriptorConverter : JsonConverter<TestPopulationDescriptor>
	{
		public override TestPopulationDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, TestPopulationDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, value._field, options);
			if (value._script is not null)
			{
				writer.WritePropertyName("script");
				JsonSerializer.Serialize(writer, value._script, options);
			}

			if (value._filter is not null)
			{
				writer.WritePropertyName("filter");
				JsonSerializer.Serialize(writer, value._filter, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class TopHitsAggregate : Aggregations.AggregateBase
	{
	}

	public partial class TopHitsAggregation : Aggregations.MetricAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "top_hits";
		[JsonInclude]
		[JsonPropertyName("docvalue_fields")]
		public Elastic.Clients.Elasticsearch.Fields? DocvalueFields { get; set; }

		[JsonInclude]
		[JsonPropertyName("explain")]
		public bool? Explain { get; set; }

		[JsonInclude]
		[JsonPropertyName("from")]
		public int? From { get; set; }

		[JsonInclude]
		[JsonPropertyName("highlight")]
		public Elastic.Clients.Elasticsearch.Highlight? Highlight { get; set; }

		[JsonInclude]
		[JsonPropertyName("script_fields")]
		public Dictionary<string, Elastic.Clients.Elasticsearch.ScriptField>? ScriptFields { get; set; }

		[JsonInclude]
		[JsonPropertyName("size")]
		public int? Size { get; set; }

		[JsonInclude]
		[JsonPropertyName("sort")]
		public Elastic.Clients.Elasticsearch.Sort? Sort { get; set; }

		[JsonInclude]
		[JsonPropertyName("_source")]
		public object? Source { get; set; }

		[JsonInclude]
		[JsonPropertyName("stored_fields")]
		public Elastic.Clients.Elasticsearch.Fields? StoredFields { get; set; }

		[JsonInclude]
		[JsonPropertyName("track_scores")]
		public bool? TrackScores { get; set; }

		[JsonInclude]
		[JsonPropertyName("version")]
		public bool? Version { get; set; }

		[JsonInclude]
		[JsonPropertyName("seq_no_primary_term")]
		public bool? SeqNoPrimaryTerm { get; set; }
	}

	[JsonConverter(typeof(TopHitsAggregationDescriptorConverter))]
	public sealed partial class TopHitsAggregationDescriptor : DescriptorBase<TopHitsAggregationDescriptor>
	{
		internal Elastic.Clients.Elasticsearch.Fields? _docvalueFields;
		internal bool? _explain;
		internal int? _from;
		internal Elastic.Clients.Elasticsearch.Highlight? _highlight;
		internal Dictionary<string, Elastic.Clients.Elasticsearch.ScriptField>? _scriptFields;
		internal int? _size;
		internal Elastic.Clients.Elasticsearch.Sort? _sort;
		internal object? _source;
		internal Elastic.Clients.Elasticsearch.Fields? _storedFields;
		internal bool? _trackScores;
		internal bool? _version;
		internal bool? _seqNoPrimaryTerm;
	}

	internal sealed class TopHitsAggregationDescriptorConverter : JsonConverter<TopHitsAggregationDescriptor>
	{
		public override TopHitsAggregationDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, TopHitsAggregationDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value._docvalueFields is not null)
			{
				writer.WritePropertyName("docvalue_fields");
				JsonSerializer.Serialize(writer, value._docvalueFields, options);
			}

			if (value._explain.HasValue)
			{
				writer.WritePropertyName("explain");
				writer.WriteBooleanValue(value._explain.Value);
			}

			if (value._from.HasValue)
			{
				writer.WritePropertyName("from");
				writer.WriteNumberValue(value._from.Value);
			}

			if (value._highlight is not null)
			{
				writer.WritePropertyName("highlight");
				JsonSerializer.Serialize(writer, value._highlight, options);
			}

			if (value._scriptFields is not null)
			{
				writer.WritePropertyName("script_fields");
				JsonSerializer.Serialize(writer, value._scriptFields, options);
			}

			if (value._size.HasValue)
			{
				writer.WritePropertyName("size");
				writer.WriteNumberValue(value._size.Value);
			}

			if (value._sort is not null)
			{
				writer.WritePropertyName("sort");
				JsonSerializer.Serialize(writer, value._sort, options);
			}

			if (value._source is not null)
			{
				writer.WritePropertyName("_source");
				JsonSerializer.Serialize(writer, value._source, options);
			}

			if (value._storedFields is not null)
			{
				writer.WritePropertyName("stored_fields");
				JsonSerializer.Serialize(writer, value._storedFields, options);
			}

			if (value._trackScores.HasValue)
			{
				writer.WritePropertyName("track_scores");
				writer.WriteBooleanValue(value._trackScores.Value);
			}

			if (value._version.HasValue)
			{
				writer.WritePropertyName("version");
				writer.WriteBooleanValue(value._version.Value);
			}

			if (value._seqNoPrimaryTerm.HasValue)
			{
				writer.WritePropertyName("seq_no_primary_term");
				writer.WriteBooleanValue(value._seqNoPrimaryTerm.Value);
			}

			writer.WriteEndObject();
		}
	}

	public partial class TopMetrics
	{
		[JsonInclude]
		[JsonPropertyName("sort")]
		public IReadOnlyCollection<object> Sort { get; init; }

		[JsonInclude]
		[JsonPropertyName("metrics")]
		public Dictionary<string, object> Metrics { get; init; }
	}

	public partial class TopMetricsAggregate : Aggregations.MultiBucketAggregateBase<Elastic.Clients.Elasticsearch.Aggregations.TopMetricsBucket>
	{
	}

	public partial class TopMetricsAggregation : Aggregations.MetricAggregationBase, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "top_metrics";
		[JsonInclude]
		[JsonPropertyName("metrics")]
		public IEnumerable<Elastic.Clients.Elasticsearch.Aggregations.TopMetricsValue>? Metrics { get; set; }

		[JsonInclude]
		[JsonPropertyName("size")]
		public int? Size { get; set; }

		[JsonInclude]
		[JsonPropertyName("sort")]
		public Elastic.Clients.Elasticsearch.Sort? Sort { get; set; }
	}

	[JsonConverter(typeof(TopMetricsAggregationDescriptorConverter))]
	public sealed partial class TopMetricsAggregationDescriptor : DescriptorBase<TopMetricsAggregationDescriptor>
	{
		internal IEnumerable<Elastic.Clients.Elasticsearch.Aggregations.TopMetricsValue>? _metrics;
		internal int? _size;
		internal Elastic.Clients.Elasticsearch.Sort? _sort;
	}

	internal sealed class TopMetricsAggregationDescriptorConverter : JsonConverter<TopMetricsAggregationDescriptor>
	{
		public override TopMetricsAggregationDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, TopMetricsAggregationDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value._metrics is not null)
			{
				writer.WritePropertyName("metrics");
				JsonSerializer.Serialize(writer, value._metrics, options);
			}

			if (value._size.HasValue)
			{
				writer.WritePropertyName("size");
				writer.WriteNumberValue(value._size.Value);
			}

			if (value._sort is not null)
			{
				writer.WritePropertyName("sort");
				JsonSerializer.Serialize(writer, value._sort, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class TopMetricsBucket : Aggregations.MultiBucketBase
	{
		[JsonInclude]
		[JsonPropertyName("top")]
		public IReadOnlyCollection<Elastic.Clients.Elasticsearch.Aggregations.TopMetrics> Top { get; init; }
	}

	public partial class TopMetricsValue
	{
		[JsonInclude]
		[JsonPropertyName("field")]
		public string Field { get; set; }
	}

	[JsonConverter(typeof(TopMetricsValueDescriptorConverter))]
	public sealed partial class TopMetricsValueDescriptor : DescriptorBase<TopMetricsValueDescriptor>
	{
		internal string _field;
	}

	internal sealed class TopMetricsValueDescriptorConverter : JsonConverter<TopMetricsValueDescriptor>
	{
		public override TopMetricsValueDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, TopMetricsValueDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("field");
			JsonSerializer.Serialize(writer, value._field, options);
			writer.WriteEndObject();
		}
	}

	public partial class TTestAggregate : Aggregations.AggregateBase
	{
		[JsonInclude]
		[JsonPropertyName("value")]
		public object Value { get; init; }

		[JsonInclude]
		[JsonPropertyName("value_as_string")]
		public string? ValueAsString { get; init; }
	}

	public partial class TTestAggregation : Aggregations.Aggregation, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "t_test";
		[JsonInclude]
		[JsonPropertyName("a")]
		public Elastic.Clients.Elasticsearch.Aggregations.TestPopulation? a { get; set; }

		[JsonInclude]
		[JsonPropertyName("b")]
		public Elastic.Clients.Elasticsearch.Aggregations.TestPopulation? b { get; set; }

		[JsonInclude]
		[JsonPropertyName("type")]
		public Elastic.Clients.Elasticsearch.Aggregations.TTestType? Type { get; set; }
	}

	[JsonConverter(typeof(TTestAggregationDescriptorConverter))]
	public sealed partial class TTestAggregationDescriptor : DescriptorBase<TTestAggregationDescriptor>
	{
		internal Elastic.Clients.Elasticsearch.Aggregations.TestPopulation? _a;
		internal Elastic.Clients.Elasticsearch.Aggregations.TestPopulation? _b;
		internal Elastic.Clients.Elasticsearch.Aggregations.TTestType? _type;
	}

	internal sealed class TTestAggregationDescriptorConverter : JsonConverter<TTestAggregationDescriptor>
	{
		public override TTestAggregationDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, TTestAggregationDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value._a is not null)
			{
				writer.WritePropertyName("a");
				JsonSerializer.Serialize(writer, value._a, options);
			}

			if (value._b is not null)
			{
				writer.WritePropertyName("b");
				JsonSerializer.Serialize(writer, value._b, options);
			}

			if (value._type is not null)
			{
				writer.WritePropertyName("type");
				JsonSerializer.Serialize(writer, value._type, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class ValueCountAggregate : Aggregations.SingleMetricAggregateBase
	{
	}

	public partial class ValueCountAggregation : Aggregations.FormattableMetricAggregation, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "value_count";
	}

	[JsonConverter(typeof(ValueCountAggregationDescriptorConverter))]
	public sealed partial class ValueCountAggregationDescriptor : DescriptorBase<ValueCountAggregationDescriptor>
	{
	}

	internal sealed class ValueCountAggregationDescriptorConverter : JsonConverter<ValueCountAggregationDescriptor>
	{
		public override ValueCountAggregationDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, ValueCountAggregationDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			writer.WriteEndObject();
		}
	}

	public partial class VariableWidthHistogramAggregate : Aggregations.MultiBucketAggregateBase<Elastic.Clients.Elasticsearch.Aggregations.VariableWidthHistogramBucket>
	{
	}

	public partial class VariableWidthHistogramAggregation : IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "variable_width_histogram";
		[JsonInclude]
		[JsonPropertyName("field")]
		public string? Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("buckets")]
		public int? Buckets { get; set; }

		[JsonInclude]
		[JsonPropertyName("shard_size")]
		public int? ShardSize { get; set; }

		[JsonInclude]
		[JsonPropertyName("initial_buffer")]
		public int? InitialBuffer { get; set; }
	}

	[JsonConverter(typeof(VariableWidthHistogramAggregationDescriptorConverter))]
	public sealed partial class VariableWidthHistogramAggregationDescriptor : DescriptorBase<VariableWidthHistogramAggregationDescriptor>
	{
		internal string? _field;
		internal int? _buckets;
		internal int? _shardSize;
		internal int? _initialBuffer;
	}

	internal sealed class VariableWidthHistogramAggregationDescriptorConverter : JsonConverter<VariableWidthHistogramAggregationDescriptor>
	{
		public override VariableWidthHistogramAggregationDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, VariableWidthHistogramAggregationDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value._field is not null)
			{
				writer.WritePropertyName("field");
				JsonSerializer.Serialize(writer, value._field, options);
			}

			if (value._buckets.HasValue)
			{
				writer.WritePropertyName("buckets");
				writer.WriteNumberValue(value._buckets.Value);
			}

			if (value._shardSize.HasValue)
			{
				writer.WritePropertyName("shard_size");
				writer.WriteNumberValue(value._shardSize.Value);
			}

			if (value._initialBuffer.HasValue)
			{
				writer.WritePropertyName("initial_buffer");
				writer.WriteNumberValue(value._initialBuffer.Value);
			}

			writer.WriteEndObject();
		}
	}

	public partial class VariableWidthHistogramBucket : Aggregations.MultiBucketBase
	{
		[JsonInclude]
		[JsonPropertyName("min")]
		public double Min { get; init; }

		[JsonInclude]
		[JsonPropertyName("key")]
		public double Key { get; init; }

		[JsonInclude]
		[JsonPropertyName("max")]
		public double Max { get; init; }

		[JsonInclude]
		[JsonPropertyName("min_as_string")]
		public string? MinAsString { get; init; }

		[JsonInclude]
		[JsonPropertyName("key_as_string")]
		public string? KeyAsString { get; init; }

		[JsonInclude]
		[JsonPropertyName("max_as_string")]
		public string? MaxAsString { get; init; }
	}

	public partial class WeightedAverageAggregation : Aggregations.Aggregation, IAggregationContainerVariant
	{
		[JsonIgnore]
		string Aggregations.IAggregationContainerVariant.AggregationContainerVariantName => "weighted_avg";
		[JsonInclude]
		[JsonPropertyName("format")]
		public string? Format { get; set; }

		[JsonInclude]
		[JsonPropertyName("value")]
		public Elastic.Clients.Elasticsearch.Aggregations.WeightedAverageValue? Value { get; set; }

		[JsonInclude]
		[JsonPropertyName("value_type")]
		public Elastic.Clients.Elasticsearch.Aggregations.ValueType? ValueType { get; set; }

		[JsonInclude]
		[JsonPropertyName("weight")]
		public Elastic.Clients.Elasticsearch.Aggregations.WeightedAverageValue? Weight { get; set; }
	}

	[JsonConverter(typeof(WeightedAverageAggregationDescriptorConverter))]
	public sealed partial class WeightedAverageAggregationDescriptor : DescriptorBase<WeightedAverageAggregationDescriptor>
	{
		internal string? _format;
		internal Elastic.Clients.Elasticsearch.Aggregations.WeightedAverageValue? _value;
		internal Elastic.Clients.Elasticsearch.Aggregations.ValueType? _valueType;
		internal Elastic.Clients.Elasticsearch.Aggregations.WeightedAverageValue? _weight;
	}

	internal sealed class WeightedAverageAggregationDescriptorConverter : JsonConverter<WeightedAverageAggregationDescriptor>
	{
		public override WeightedAverageAggregationDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, WeightedAverageAggregationDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (!string.IsNullOrEmpty(value._format))
			{
				writer.WritePropertyName("format");
				writer.WriteStringValue(value._format);
			}

			if (value._value is not null)
			{
				writer.WritePropertyName("value");
				JsonSerializer.Serialize(writer, value._value, options);
			}

			if (value._valueType is not null)
			{
				writer.WritePropertyName("value_type");
				JsonSerializer.Serialize(writer, value._valueType, options);
			}

			if (value._weight is not null)
			{
				writer.WritePropertyName("weight");
				JsonSerializer.Serialize(writer, value._weight, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class WeightedAverageValue
	{
		[JsonInclude]
		[JsonPropertyName("field")]
		public string? Field { get; set; }

		[JsonInclude]
		[JsonPropertyName("missing")]
		public double? Missing { get; set; }

		[JsonInclude]
		[JsonPropertyName("script")]
		public Elastic.Clients.Elasticsearch.Script? Script { get; set; }
	}

	[JsonConverter(typeof(WeightedAverageValueDescriptorConverter))]
	public sealed partial class WeightedAverageValueDescriptor : DescriptorBase<WeightedAverageValueDescriptor>
	{
		internal string? _field;
		internal double? _missing;
		internal Elastic.Clients.Elasticsearch.Script? _script;
	}

	internal sealed class WeightedAverageValueDescriptorConverter : JsonConverter<WeightedAverageValueDescriptor>
	{
		public override WeightedAverageValueDescriptor Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();
		public override void Write(Utf8JsonWriter writer, WeightedAverageValueDescriptor value, JsonSerializerOptions options)
		{
			writer.WriteStartObject();
			if (value._field is not null)
			{
				writer.WritePropertyName("field");
				JsonSerializer.Serialize(writer, value._field, options);
			}

			if (value._missing.HasValue)
			{
				writer.WritePropertyName("missing");
				writer.WriteNumberValue(value._missing.Value);
			}

			if (value._script is not null)
			{
				writer.WritePropertyName("script");
				JsonSerializer.Serialize(writer, value._script, options);
			}

			writer.WriteEndObject();
		}
	}

	public partial class WeightedAvgAggregate : Aggregations.SingleMetricAggregateBase
	{
	}
}
