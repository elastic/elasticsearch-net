// Licensed to Elasticsearch B.V under one or more agreements.
// Elasticsearch B.V licenses this file to you under the Apache 2.0 License.
// See the LICENSE file in the project root for more information.
//
// ███╗   ██╗ ██████╗ ████████╗██╗ ██████╗███████╗
// ████╗  ██║██╔═══██╗╚══██╔══╝██║██╔════╝██╔════╝
// ██╔██╗ ██║██║   ██║   ██║   ██║██║     █████╗
// ██║╚██╗██║██║   ██║   ██║   ██║██║     ██╔══╝
// ██║ ╚████║╚██████╔╝   ██║   ██║╚██████╗███████╗
// ╚═╝  ╚═══╝ ╚═════╝    ╚═╝   ╚═╝ ╚═════╝╚══════╝
// ------------------------------------------------
//
// This file is automatically generated.
// Please do not edit these files manually.
// Run the following in the root of the repository:
//
// ------------------------------------------------

using System;
using System.Text.Json.Serialization;
using Elastic.Transport;
using System.Collections.Generic;

#nullable restore
namespace Nest
{
	[ConvertAs(typeof(IndicesAddBlockRequest))]
	public partial interface IIndicesAddBlockRequest : IRequest<IndicesAddBlockRequestParameters>
	{
	}

	public partial class IndicesAddBlockRequest : PlainRequestBase<IndicesAddBlockRequestParameters>, IIndicesAddBlockRequest
	{
		protected IIndicesAddBlockRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesAddBlock;
		protected override HttpMethod HttpMethod => HttpMethod.PUT;
		protected override bool SupportsBody => false;
		protected override bool CanBeEmpty => false;
		protected override bool IsEmpty => false;

		///<summary>/{index}/_block/{block}</summary>
        public IndicesAddBlockRequest(IndexName index, IndicesBlockOptions block) : base(r => r.Required("index", index).Required("block", block))
		{
		}

		[JsonIgnore]
		public bool? AllowNoIndices { get => Q<bool?>("allow_no_indices"); set => Q("allow_no_indices", value); }

		[JsonIgnore]
		public ExpandWildcards? ExpandWildcards { get => Q<ExpandWildcards?>("expand_wildcards"); set => Q("expand_wildcards", value); }

		[JsonIgnore]
		public bool? IgnoreUnavailable { get => Q<bool?>("ignore_unavailable"); set => Q("ignore_unavailable", value); }

		[JsonIgnore]
		public Time? MasterTimeout { get => Q<Time?>("master_timeout"); set => Q("master_timeout", value); }

		[JsonIgnore]
		public Time? Timeout { get => Q<Time?>("timeout"); set => Q("timeout", value); }
	}

	[ConvertAs(typeof(IndicesAnalyzeRequest))]
	public partial interface IIndicesAnalyzeRequest : IRequest<IndicesAnalyzeRequestParameters>
	{
	}

	public partial class IndicesAnalyzeRequest : PlainRequestBase<IndicesAnalyzeRequestParameters>, IIndicesAnalyzeRequest
	{
		protected IIndicesAnalyzeRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesAnalyze;
		protected override HttpMethod HttpMethod => HttpMethod.POST;
		protected override bool SupportsBody => true;
		protected override bool CanBeEmpty => true;
		protected override bool IsEmpty => Analyzer is null && Attributes is null && Explain is null && Field is null && Filter is null && Normalizer is null && Text is null;

		///<summary>/_analyze</summary>
        public IndicesAnalyzeRequest() : base()
		{
		}

		///<summary>/{index}/_analyze</summary>
        public IndicesAnalyzeRequest(IndexName index) : base(r => r.Optional("index", index))
		{
		}

		[JsonPropertyName("analyzer")]
		public string? Analyzer
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("attributes")]
		public IReadOnlyCollection<string>? Attributes
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("explain")]
		public bool? Explain
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("field")]
		public Field? Field
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("filter")]
		public IReadOnlyCollection<Union<string, TokenFilter>>? Filter
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("normalizer")]
		public string? Normalizer
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("text")]
		public TextToAnalyze? Text
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}
	}

	[ConvertAs(typeof(IndicesClearCacheRequest))]
	public partial interface IIndicesClearCacheRequest : IRequest<IndicesClearCacheRequestParameters>
	{
	}

	public partial class IndicesClearCacheRequest : PlainRequestBase<IndicesClearCacheRequestParameters>, IIndicesClearCacheRequest
	{
		protected IIndicesClearCacheRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesClearCache;
		protected override HttpMethod HttpMethod => HttpMethod.POST;
		protected override bool SupportsBody => false;
		protected override bool CanBeEmpty => true;
		protected override bool IsEmpty => true;

		///<summary>/_cache/clear</summary>
        public IndicesClearCacheRequest() : base()
		{
		}

		///<summary>/{index}/_cache/clear</summary>
        public IndicesClearCacheRequest(Indices index) : base(r => r.Optional("index", index))
		{
		}

		[JsonIgnore]
		public bool? AllowNoIndices { get => Q<bool?>("allow_no_indices"); set => Q("allow_no_indices", value); }

		[JsonIgnore]
		public ExpandWildcards? ExpandWildcards { get => Q<ExpandWildcards?>("expand_wildcards"); set => Q("expand_wildcards", value); }

		[JsonIgnore]
		public bool? Fielddata { get => Q<bool?>("fielddata"); set => Q("fielddata", value); }

		[JsonIgnore]
		public Fields? Fields { get => Q<Fields?>("fields"); set => Q("fields", value); }

		[JsonIgnore]
		public bool? IgnoreUnavailable { get => Q<bool?>("ignore_unavailable"); set => Q("ignore_unavailable", value); }

		[JsonIgnore]
		public bool? Query { get => Q<bool?>("query"); set => Q("query", value); }

		[JsonIgnore]
		public bool? Request { get => Q<bool?>("request"); set => Q("request", value); }
	}

	[ConvertAs(typeof(IndicesCloneRequest))]
	public partial interface IIndicesCloneRequest : IRequest<IndicesCloneRequestParameters>
	{
	}

	public partial class IndicesCloneRequest : PlainRequestBase<IndicesCloneRequestParameters>, IIndicesCloneRequest
	{
		protected IIndicesCloneRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesClone;
		protected override HttpMethod HttpMethod => HttpMethod.PUT;
		protected override bool SupportsBody => true;
		protected override bool CanBeEmpty => false;
		protected override bool IsEmpty => false;

		///<summary>/{index}/_clone/{target}</summary>
        public IndicesCloneRequest(IndexName index, Name target) : base(r => r.Required("index", index).Required("target", target))
		{
		}

		[JsonIgnore]
		public Time? MasterTimeout { get => Q<Time?>("master_timeout"); set => Q("master_timeout", value); }

		[JsonIgnore]
		public Time? Timeout { get => Q<Time?>("timeout"); set => Q("timeout", value); }

		[JsonIgnore]
		public WaitForActiveShards? WaitForActiveShards { get => Q<WaitForActiveShards?>("wait_for_active_shards"); set => Q("wait_for_active_shards", value); }

		[JsonPropertyName("aliases")]
		public Dictionary<IndexName, Alias>? Aliases
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("settings")]
		public Dictionary<string, object>? Settings
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}
	}

	[ConvertAs(typeof(IndicesCloseRequest))]
	public partial interface IIndicesCloseRequest : IRequest<IndicesCloseRequestParameters>
	{
	}

	public partial class IndicesCloseRequest : PlainRequestBase<IndicesCloseRequestParameters>, IIndicesCloseRequest
	{
		protected IIndicesCloseRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesClose;
		protected override HttpMethod HttpMethod => HttpMethod.POST;
		protected override bool SupportsBody => false;
		protected override bool CanBeEmpty => false;
		protected override bool IsEmpty => false;

		///<summary>/{index}/_close</summary>
        public IndicesCloseRequest(Indices index) : base(r => r.Required("index", index))
		{
		}

		[JsonIgnore]
		public bool? AllowNoIndices { get => Q<bool?>("allow_no_indices"); set => Q("allow_no_indices", value); }

		[JsonIgnore]
		public ExpandWildcards? ExpandWildcards { get => Q<ExpandWildcards?>("expand_wildcards"); set => Q("expand_wildcards", value); }

		[JsonIgnore]
		public bool? IgnoreUnavailable { get => Q<bool?>("ignore_unavailable"); set => Q("ignore_unavailable", value); }

		[JsonIgnore]
		public Time? MasterTimeout { get => Q<Time?>("master_timeout"); set => Q("master_timeout", value); }

		[JsonIgnore]
		public Time? Timeout { get => Q<Time?>("timeout"); set => Q("timeout", value); }

		[JsonIgnore]
		public WaitForActiveShards? WaitForActiveShards { get => Q<WaitForActiveShards?>("wait_for_active_shards"); set => Q("wait_for_active_shards", value); }
	}

	[ConvertAs(typeof(IndicesCreateRequest))]
	public partial interface IIndicesCreateRequest : IRequest<IndicesCreateRequestParameters>
	{
	}

	public partial class IndicesCreateRequest : PlainRequestBase<IndicesCreateRequestParameters>, IIndicesCreateRequest
	{
		protected IIndicesCreateRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesCreate;
		protected override HttpMethod HttpMethod => HttpMethod.PUT;
		protected override bool SupportsBody => true;
		protected override bool CanBeEmpty => false;
		protected override bool IsEmpty => false;

		///<summary>/{index}</summary>
        public IndicesCreateRequest(IndexName index) : base(r => r.Required("index", index))
		{
		}

		[JsonIgnore]
		public bool? IncludeTypeName { get => Q<bool?>("include_type_name"); set => Q("include_type_name", value); }

		[JsonIgnore]
		public Time? MasterTimeout { get => Q<Time?>("master_timeout"); set => Q("master_timeout", value); }

		[JsonIgnore]
		public Time? Timeout { get => Q<Time?>("timeout"); set => Q("timeout", value); }

		[JsonIgnore]
		public WaitForActiveShards? WaitForActiveShards { get => Q<WaitForActiveShards?>("wait_for_active_shards"); set => Q("wait_for_active_shards", value); }

		[JsonPropertyName("aliases")]
		public Dictionary<IndexName, Alias>? Aliases
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("mappings")]
		public Union<Dictionary<string, TypeMapping>, TypeMapping>? Mappings
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("settings")]
		public Dictionary<string, object>? Settings
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}
	}

	[ConvertAs(typeof(IndicesCreateDataStreamRequest))]
	public partial interface IIndicesCreateDataStreamRequest : IRequest<IndicesCreateDataStreamRequestParameters>
	{
	}

	public partial class IndicesCreateDataStreamRequest : PlainRequestBase<IndicesCreateDataStreamRequestParameters>, IIndicesCreateDataStreamRequest
	{
		protected IIndicesCreateDataStreamRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesCreateDataStream;
		protected override HttpMethod HttpMethod => HttpMethod.PUT;
		protected override bool SupportsBody => false;
		protected override bool CanBeEmpty => false;
		protected override bool IsEmpty => false;

		///<summary>/_data_stream/{name}</summary>
        public IndicesCreateDataStreamRequest(DataStreamName name) : base(r => r.Required("name", name))
		{
		}
	}

	[ConvertAs(typeof(IndicesDataStreamsStatsRequest))]
	public partial interface IIndicesDataStreamsStatsRequest : IRequest<IndicesDataStreamsStatsRequestParameters>
	{
	}

	public partial class IndicesDataStreamsStatsRequest : PlainRequestBase<IndicesDataStreamsStatsRequestParameters>, IIndicesDataStreamsStatsRequest
	{
		protected IIndicesDataStreamsStatsRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesDataStreamsStats;
		protected override HttpMethod HttpMethod => HttpMethod.GET;
		protected override bool SupportsBody => false;
		protected override bool CanBeEmpty => true;
		protected override bool IsEmpty => true;

		///<summary>/_data_stream/_stats</summary>
        public IndicesDataStreamsStatsRequest() : base()
		{
		}

		///<summary>/_data_stream/{name}/_stats</summary>
        public IndicesDataStreamsStatsRequest(IndexName name) : base(r => r.Optional("name", name))
		{
		}

		[JsonIgnore]
		public ExpandWildcards? ExpandWildcards { get => Q<ExpandWildcards?>("expand_wildcards"); set => Q("expand_wildcards", value); }
	}

	[ConvertAs(typeof(DeleteIndicesRequest))]
	public partial interface IDeleteIndicesRequest : IRequest<DeleteIndicesRequestParameters>
	{
	}

	public partial class DeleteIndicesRequest : PlainRequestBase<DeleteIndicesRequestParameters>, IDeleteIndicesRequest
	{
		protected IDeleteIndicesRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesDelete;
		protected override HttpMethod HttpMethod => HttpMethod.DELETE;
		protected override bool SupportsBody => false;
		protected override bool CanBeEmpty => false;
		protected override bool IsEmpty => false;

		///<summary>/{index}</summary>
        public DeleteIndicesRequest(Indices index) : base(r => r.Required("index", index))
		{
		}

		[JsonIgnore]
		public bool? AllowNoIndices { get => Q<bool?>("allow_no_indices"); set => Q("allow_no_indices", value); }

		[JsonIgnore]
		public ExpandWildcards? ExpandWildcards { get => Q<ExpandWildcards?>("expand_wildcards"); set => Q("expand_wildcards", value); }

		[JsonIgnore]
		public bool? IgnoreUnavailable { get => Q<bool?>("ignore_unavailable"); set => Q("ignore_unavailable", value); }

		[JsonIgnore]
		public Time? MasterTimeout { get => Q<Time?>("master_timeout"); set => Q("master_timeout", value); }

		[JsonIgnore]
		public Time? Timeout { get => Q<Time?>("timeout"); set => Q("timeout", value); }
	}

	[ConvertAs(typeof(IndicesDeleteAliasRequest))]
	public partial interface IIndicesDeleteAliasRequest : IRequest<IndicesDeleteAliasRequestParameters>
	{
	}

	public partial class IndicesDeleteAliasRequest : PlainRequestBase<IndicesDeleteAliasRequestParameters>, IIndicesDeleteAliasRequest
	{
		protected IIndicesDeleteAliasRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesDeleteAlias;
		protected override HttpMethod HttpMethod => HttpMethod.DELETE;
		protected override bool SupportsBody => false;
		protected override bool CanBeEmpty => false;
		protected override bool IsEmpty => false;

		///<summary>/{index}/_alias/{name}</summary>
        public IndicesDeleteAliasRequest(Indices index, Names name) : base(r => r.Required("index", index).Required("name", name))
		{
		}

		[JsonIgnore]
		public Time? MasterTimeout { get => Q<Time?>("master_timeout"); set => Q("master_timeout", value); }

		[JsonIgnore]
		public Time? Timeout { get => Q<Time?>("timeout"); set => Q("timeout", value); }
	}

	[ConvertAs(typeof(IndicesDeleteDataStreamRequest))]
	public partial interface IIndicesDeleteDataStreamRequest : IRequest<IndicesDeleteDataStreamRequestParameters>
	{
	}

	public partial class IndicesDeleteDataStreamRequest : PlainRequestBase<IndicesDeleteDataStreamRequestParameters>, IIndicesDeleteDataStreamRequest
	{
		protected IIndicesDeleteDataStreamRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesDeleteDataStream;
		protected override HttpMethod HttpMethod => HttpMethod.DELETE;
		protected override bool SupportsBody => false;
		protected override bool CanBeEmpty => false;
		protected override bool IsEmpty => false;

		///<summary>/_data_stream/{name}</summary>
        public IndicesDeleteDataStreamRequest(DataStreamName name) : base(r => r.Required("name", name))
		{
		}
	}

	[ConvertAs(typeof(IndicesDeleteIndexTemplateRequest))]
	public partial interface IIndicesDeleteIndexTemplateRequest : IRequest<IndicesDeleteIndexTemplateRequestParameters>
	{
	}

	public partial class IndicesDeleteIndexTemplateRequest : PlainRequestBase<IndicesDeleteIndexTemplateRequestParameters>, IIndicesDeleteIndexTemplateRequest
	{
		protected IIndicesDeleteIndexTemplateRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesDeleteIndexTemplate;
		protected override HttpMethod HttpMethod => HttpMethod.DELETE;
		protected override bool SupportsBody => false;
		protected override bool CanBeEmpty => false;
		protected override bool IsEmpty => false;

		///<summary>/_index_template/{name}</summary>
        public IndicesDeleteIndexTemplateRequest(Name name) : base(r => r.Required("name", name))
		{
		}
	}

	[ConvertAs(typeof(IndicesDeleteTemplateRequest))]
	public partial interface IIndicesDeleteTemplateRequest : IRequest<IndicesDeleteTemplateRequestParameters>
	{
	}

	public partial class IndicesDeleteTemplateRequest : PlainRequestBase<IndicesDeleteTemplateRequestParameters>, IIndicesDeleteTemplateRequest
	{
		protected IIndicesDeleteTemplateRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesDeleteTemplate;
		protected override HttpMethod HttpMethod => HttpMethod.DELETE;
		protected override bool SupportsBody => false;
		protected override bool CanBeEmpty => false;
		protected override bool IsEmpty => false;

		///<summary>/_template/{name}</summary>
        public IndicesDeleteTemplateRequest(Name name) : base(r => r.Required("name", name))
		{
		}

		[JsonIgnore]
		public Time? MasterTimeout { get => Q<Time?>("master_timeout"); set => Q("master_timeout", value); }

		[JsonIgnore]
		public Time? Timeout { get => Q<Time?>("timeout"); set => Q("timeout", value); }
	}

	[ConvertAs(typeof(IndicesExistsRequest))]
	public partial interface IIndicesExistsRequest : IRequest<IndicesExistsRequestParameters>
	{
	}

	public partial class IndicesExistsRequest : PlainRequestBase<IndicesExistsRequestParameters>, IIndicesExistsRequest
	{
		protected IIndicesExistsRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesExists;
		protected override HttpMethod HttpMethod => HttpMethod.HEAD;
		protected override bool SupportsBody => false;
		protected override bool CanBeEmpty => false;
		protected override bool IsEmpty => false;

		///<summary>/{index}</summary>
        public IndicesExistsRequest(Indices index) : base(r => r.Required("index", index))
		{
		}

		[JsonIgnore]
		public bool? AllowNoIndices { get => Q<bool?>("allow_no_indices"); set => Q("allow_no_indices", value); }

		[JsonIgnore]
		public ExpandWildcards? ExpandWildcards { get => Q<ExpandWildcards?>("expand_wildcards"); set => Q("expand_wildcards", value); }

		[JsonIgnore]
		public bool? FlatSettings { get => Q<bool?>("flat_settings"); set => Q("flat_settings", value); }

		[JsonIgnore]
		public bool? IgnoreUnavailable { get => Q<bool?>("ignore_unavailable"); set => Q("ignore_unavailable", value); }

		[JsonIgnore]
		public bool? IncludeDefaults { get => Q<bool?>("include_defaults"); set => Q("include_defaults", value); }

		[JsonIgnore]
		public bool? Local { get => Q<bool?>("local"); set => Q("local", value); }
	}

	[ConvertAs(typeof(IndicesExistsAliasRequest))]
	public partial interface IIndicesExistsAliasRequest : IRequest<IndicesExistsAliasRequestParameters>
	{
	}

	public partial class IndicesExistsAliasRequest : PlainRequestBase<IndicesExistsAliasRequestParameters>, IIndicesExistsAliasRequest
	{
		protected IIndicesExistsAliasRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesExistsAlias;
		protected override HttpMethod HttpMethod => HttpMethod.HEAD;
		protected override bool SupportsBody => false;
		protected override bool CanBeEmpty => false;
		protected override bool IsEmpty => false;

		///<summary>/_alias/{name}</summary>
        public IndicesExistsAliasRequest(Names name) : base(r => r.Required("name", name))
		{
		}

		///<summary>/{index}/_alias/{name}</summary>
        public IndicesExistsAliasRequest(Indices index, Names name) : base(r => r.Optional("index", index).Required("name", name))
		{
		}

		[JsonIgnore]
		public bool? AllowNoIndices { get => Q<bool?>("allow_no_indices"); set => Q("allow_no_indices", value); }

		[JsonIgnore]
		public ExpandWildcards? ExpandWildcards { get => Q<ExpandWildcards?>("expand_wildcards"); set => Q("expand_wildcards", value); }

		[JsonIgnore]
		public bool? IgnoreUnavailable { get => Q<bool?>("ignore_unavailable"); set => Q("ignore_unavailable", value); }

		[JsonIgnore]
		public bool? Local { get => Q<bool?>("local"); set => Q("local", value); }
	}

	[ConvertAs(typeof(IndicesExistsIndexTemplateRequest))]
	public partial interface IIndicesExistsIndexTemplateRequest : IRequest<IndicesExistsIndexTemplateRequestParameters>
	{
	}

	public partial class IndicesExistsIndexTemplateRequest : PlainRequestBase<IndicesExistsIndexTemplateRequestParameters>, IIndicesExistsIndexTemplateRequest
	{
		protected IIndicesExistsIndexTemplateRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesExistsIndexTemplate;
		protected override HttpMethod HttpMethod => HttpMethod.HEAD;
		protected override bool SupportsBody => false;
		protected override bool CanBeEmpty => false;
		protected override bool IsEmpty => false;

		///<summary>/_index_template/{name}</summary>
        public IndicesExistsIndexTemplateRequest(Name name) : base(r => r.Required("name", name))
		{
		}

		[JsonIgnore]
		public Time? MasterTimeout { get => Q<Time?>("master_timeout"); set => Q("master_timeout", value); }
	}

	[ConvertAs(typeof(IndicesExistsTemplateRequest))]
	public partial interface IIndicesExistsTemplateRequest : IRequest<IndicesExistsTemplateRequestParameters>
	{
	}

	public partial class IndicesExistsTemplateRequest : PlainRequestBase<IndicesExistsTemplateRequestParameters>, IIndicesExistsTemplateRequest
	{
		protected IIndicesExistsTemplateRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesExistsTemplate;
		protected override HttpMethod HttpMethod => HttpMethod.HEAD;
		protected override bool SupportsBody => false;
		protected override bool CanBeEmpty => false;
		protected override bool IsEmpty => false;

		///<summary>/_template/{name}</summary>
        public IndicesExistsTemplateRequest(Names name) : base(r => r.Required("name", name))
		{
		}

		[JsonIgnore]
		public bool? FlatSettings { get => Q<bool?>("flat_settings"); set => Q("flat_settings", value); }

		[JsonIgnore]
		public bool? Local { get => Q<bool?>("local"); set => Q("local", value); }

		[JsonIgnore]
		public Time? MasterTimeout { get => Q<Time?>("master_timeout"); set => Q("master_timeout", value); }
	}

	[ConvertAs(typeof(IndicesExistsTypeRequest))]
	public partial interface IIndicesExistsTypeRequest : IRequest<IndicesExistsTypeRequestParameters>
	{
	}

	public partial class IndicesExistsTypeRequest : PlainRequestBase<IndicesExistsTypeRequestParameters>, IIndicesExistsTypeRequest
	{
		protected IIndicesExistsTypeRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesExistsType;
		protected override HttpMethod HttpMethod => HttpMethod.HEAD;
		protected override bool SupportsBody => false;
		protected override bool CanBeEmpty => false;
		protected override bool IsEmpty => false;

		///<summary>/{index}/_mapping/{type}</summary>
        public IndicesExistsTypeRequest(Indices index, Types type) : base(r => r.Required("index", index).Required("type", type))
		{
		}

		[JsonIgnore]
		public bool? AllowNoIndices { get => Q<bool?>("allow_no_indices"); set => Q("allow_no_indices", value); }

		[JsonIgnore]
		public ExpandWildcards? ExpandWildcards { get => Q<ExpandWildcards?>("expand_wildcards"); set => Q("expand_wildcards", value); }

		[JsonIgnore]
		public bool? IgnoreUnavailable { get => Q<bool?>("ignore_unavailable"); set => Q("ignore_unavailable", value); }

		[JsonIgnore]
		public bool? Local { get => Q<bool?>("local"); set => Q("local", value); }
	}

	[ConvertAs(typeof(IndicesFlushRequest))]
	public partial interface IIndicesFlushRequest : IRequest<IndicesFlushRequestParameters>
	{
	}

	public partial class IndicesFlushRequest : PlainRequestBase<IndicesFlushRequestParameters>, IIndicesFlushRequest
	{
		protected IIndicesFlushRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesFlush;
		protected override HttpMethod HttpMethod => HttpMethod.POST;
		protected override bool SupportsBody => false;
		protected override bool CanBeEmpty => true;
		protected override bool IsEmpty => true;

		///<summary>/_flush</summary>
        public IndicesFlushRequest() : base()
		{
		}

		///<summary>/{index}/_flush</summary>
        public IndicesFlushRequest(Indices index) : base(r => r.Optional("index", index))
		{
		}

		[JsonIgnore]
		public bool? AllowNoIndices { get => Q<bool?>("allow_no_indices"); set => Q("allow_no_indices", value); }

		[JsonIgnore]
		public ExpandWildcards? ExpandWildcards { get => Q<ExpandWildcards?>("expand_wildcards"); set => Q("expand_wildcards", value); }

		[JsonIgnore]
		public bool? Force { get => Q<bool?>("force"); set => Q("force", value); }

		[JsonIgnore]
		public bool? IgnoreUnavailable { get => Q<bool?>("ignore_unavailable"); set => Q("ignore_unavailable", value); }

		[JsonIgnore]
		public bool? WaitIfOngoing { get => Q<bool?>("wait_if_ongoing"); set => Q("wait_if_ongoing", value); }
	}

	[ConvertAs(typeof(IndicesForcemergeRequest))]
	public partial interface IIndicesForcemergeRequest : IRequest<IndicesForcemergeRequestParameters>
	{
	}

	public partial class IndicesForcemergeRequest : PlainRequestBase<IndicesForcemergeRequestParameters>, IIndicesForcemergeRequest
	{
		protected IIndicesForcemergeRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesForcemerge;
		protected override HttpMethod HttpMethod => HttpMethod.POST;
		protected override bool SupportsBody => false;
		protected override bool CanBeEmpty => true;
		protected override bool IsEmpty => true;

		///<summary>/_forcemerge</summary>
        public IndicesForcemergeRequest() : base()
		{
		}

		///<summary>/{index}/_forcemerge</summary>
        public IndicesForcemergeRequest(Indices index) : base(r => r.Optional("index", index))
		{
		}

		[JsonIgnore]
		public bool? AllowNoIndices { get => Q<bool?>("allow_no_indices"); set => Q("allow_no_indices", value); }

		[JsonIgnore]
		public ExpandWildcards? ExpandWildcards { get => Q<ExpandWildcards?>("expand_wildcards"); set => Q("expand_wildcards", value); }

		[JsonIgnore]
		public bool? Flush { get => Q<bool?>("flush"); set => Q("flush", value); }

		[JsonIgnore]
		public bool? IgnoreUnavailable { get => Q<bool?>("ignore_unavailable"); set => Q("ignore_unavailable", value); }

		[JsonIgnore]
		public long? MaxNumSegments { get => Q<long?>("max_num_segments"); set => Q("max_num_segments", value); }

		[JsonIgnore]
		public bool? OnlyExpungeDeletes { get => Q<bool?>("only_expunge_deletes"); set => Q("only_expunge_deletes", value); }
	}

	[ConvertAs(typeof(GetIndicesRequest))]
	public partial interface IGetIndicesRequest : IRequest<GetIndicesRequestParameters>
	{
	}

	public partial class GetIndicesRequest : PlainRequestBase<GetIndicesRequestParameters>, IGetIndicesRequest
	{
		protected IGetIndicesRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesGet;
		protected override HttpMethod HttpMethod => HttpMethod.GET;
		protected override bool SupportsBody => false;
		protected override bool CanBeEmpty => false;
		protected override bool IsEmpty => false;

		///<summary>/{index}</summary>
        public GetIndicesRequest(Indices index) : base(r => r.Required("index", index))
		{
		}

		[JsonIgnore]
		public bool? AllowNoIndices { get => Q<bool?>("allow_no_indices"); set => Q("allow_no_indices", value); }

		[JsonIgnore]
		public ExpandWildcards? ExpandWildcards { get => Q<ExpandWildcards?>("expand_wildcards"); set => Q("expand_wildcards", value); }

		[JsonIgnore]
		public bool? FlatSettings { get => Q<bool?>("flat_settings"); set => Q("flat_settings", value); }

		[JsonIgnore]
		public bool? IgnoreUnavailable { get => Q<bool?>("ignore_unavailable"); set => Q("ignore_unavailable", value); }

		[JsonIgnore]
		public bool? IncludeDefaults { get => Q<bool?>("include_defaults"); set => Q("include_defaults", value); }

		[JsonIgnore]
		public bool? IncludeTypeName { get => Q<bool?>("include_type_name"); set => Q("include_type_name", value); }

		[JsonIgnore]
		public bool? Local { get => Q<bool?>("local"); set => Q("local", value); }

		[JsonIgnore]
		public Time? MasterTimeout { get => Q<Time?>("master_timeout"); set => Q("master_timeout", value); }
	}

	[ConvertAs(typeof(IndicesGetAliasRequest))]
	public partial interface IIndicesGetAliasRequest : IRequest<IndicesGetAliasRequestParameters>
	{
	}

	public partial class IndicesGetAliasRequest : PlainRequestBase<IndicesGetAliasRequestParameters>, IIndicesGetAliasRequest
	{
		protected IIndicesGetAliasRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesGetAlias;
		protected override HttpMethod HttpMethod => HttpMethod.GET;
		protected override bool SupportsBody => false;
		protected override bool CanBeEmpty => true;
		protected override bool IsEmpty => true;

		///<summary>/_alias</summary>
        public IndicesGetAliasRequest() : base()
		{
		}

		///<summary>/_alias/{name}</summary>
        public IndicesGetAliasRequest(Names name) : base(r => r.Optional("name", name))
		{
		}

		///<summary>/{index}/_alias/{name}</summary>
        public IndicesGetAliasRequest(Indices index, Names name) : base(r => r.Optional("index", index).Optional("name", name))
		{
		}

		///<summary>/{index}/_alias</summary>
        public IndicesGetAliasRequest(Indices index) : base(r => r.Optional("index", index))
		{
		}

		[JsonIgnore]
		public bool? AllowNoIndices { get => Q<bool?>("allow_no_indices"); set => Q("allow_no_indices", value); }

		[JsonIgnore]
		public ExpandWildcards? ExpandWildcards { get => Q<ExpandWildcards?>("expand_wildcards"); set => Q("expand_wildcards", value); }

		[JsonIgnore]
		public bool? IgnoreUnavailable { get => Q<bool?>("ignore_unavailable"); set => Q("ignore_unavailable", value); }

		[JsonIgnore]
		public bool? Local { get => Q<bool?>("local"); set => Q("local", value); }
	}

	[ConvertAs(typeof(IndicesGetDataStreamRequest))]
	public partial interface IIndicesGetDataStreamRequest : IRequest<IndicesGetDataStreamRequestParameters>
	{
	}

	public partial class IndicesGetDataStreamRequest : PlainRequestBase<IndicesGetDataStreamRequestParameters>, IIndicesGetDataStreamRequest
	{
		protected IIndicesGetDataStreamRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesGetDataStream;
		protected override HttpMethod HttpMethod => HttpMethod.GET;
		protected override bool SupportsBody => false;
		protected override bool CanBeEmpty => true;
		protected override bool IsEmpty => true;

		///<summary>/_data_stream</summary>
        public IndicesGetDataStreamRequest() : base()
		{
		}

		///<summary>/_data_stream/{name}</summary>
        public IndicesGetDataStreamRequest(IndexName name) : base(r => r.Optional("name", name))
		{
		}

		[JsonIgnore]
		public ExpandWildcards? ExpandWildcards { get => Q<ExpandWildcards?>("expand_wildcards"); set => Q("expand_wildcards", value); }
	}

	[ConvertAs(typeof(IndicesGetFieldMappingRequest))]
	public partial interface IIndicesGetFieldMappingRequest : IRequest<IndicesGetFieldMappingRequestParameters>
	{
	}

	public partial class IndicesGetFieldMappingRequest : PlainRequestBase<IndicesGetFieldMappingRequestParameters>, IIndicesGetFieldMappingRequest
	{
		protected IIndicesGetFieldMappingRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesGetFieldMapping;
		protected override HttpMethod HttpMethod => HttpMethod.GET;
		protected override bool SupportsBody => false;
		protected override bool CanBeEmpty => false;
		protected override bool IsEmpty => false;

		///<summary>/_mapping/field/{fields}</summary>
        public IndicesGetFieldMappingRequest(Fields fields) : base(r => r.Required("fields", fields))
		{
		}

		///<summary>/{index}/_mapping/field/{fields}</summary>
        public IndicesGetFieldMappingRequest(Indices index, Fields fields) : base(r => r.Optional("index", index).Required("fields", fields))
		{
		}

		[JsonIgnore]
		public bool? AllowNoIndices { get => Q<bool?>("allow_no_indices"); set => Q("allow_no_indices", value); }

		[JsonIgnore]
		public ExpandWildcards? ExpandWildcards { get => Q<ExpandWildcards?>("expand_wildcards"); set => Q("expand_wildcards", value); }

		[JsonIgnore]
		public bool? IgnoreUnavailable { get => Q<bool?>("ignore_unavailable"); set => Q("ignore_unavailable", value); }

		[JsonIgnore]
		public bool? IncludeDefaults { get => Q<bool?>("include_defaults"); set => Q("include_defaults", value); }

		[JsonIgnore]
		public bool? IncludeTypeName { get => Q<bool?>("include_type_name"); set => Q("include_type_name", value); }

		[JsonIgnore]
		public bool? Local { get => Q<bool?>("local"); set => Q("local", value); }
	}

	[ConvertAs(typeof(IndicesGetIndexTemplateRequest))]
	public partial interface IIndicesGetIndexTemplateRequest : IRequest<IndicesGetIndexTemplateRequestParameters>
	{
	}

	public partial class IndicesGetIndexTemplateRequest : PlainRequestBase<IndicesGetIndexTemplateRequestParameters>, IIndicesGetIndexTemplateRequest
	{
		protected IIndicesGetIndexTemplateRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesGetIndexTemplate;
		protected override HttpMethod HttpMethod => HttpMethod.GET;
		protected override bool SupportsBody => true;
		protected override bool CanBeEmpty => true;
		protected override bool IsEmpty => FlatSettings is null && IncludeTypeName is null && MasterTimeout is null;

		///<summary>/_index_template</summary>
        public IndicesGetIndexTemplateRequest() : base()
		{
		}

		///<summary>/_index_template/{name}</summary>
        public IndicesGetIndexTemplateRequest(Name name) : base(r => r.Optional("name", name))
		{
		}

		[JsonIgnore]
		public bool? Local { get => Q<bool?>("local"); set => Q("local", value); }

		[JsonPropertyName("flat_settings")]
		public bool? FlatSettings
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("include_type_name")]
		public bool? IncludeTypeName
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("master_timeout")]
		public Time? MasterTimeout
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}
	}

	[ConvertAs(typeof(IndicesGetMappingRequest))]
	public partial interface IIndicesGetMappingRequest : IRequest<IndicesGetMappingRequestParameters>
	{
	}

	public partial class IndicesGetMappingRequest : PlainRequestBase<IndicesGetMappingRequestParameters>, IIndicesGetMappingRequest
	{
		protected IIndicesGetMappingRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesGetMapping;
		protected override HttpMethod HttpMethod => HttpMethod.GET;
		protected override bool SupportsBody => false;
		protected override bool CanBeEmpty => true;
		protected override bool IsEmpty => true;

		///<summary>/_mapping</summary>
        public IndicesGetMappingRequest() : base()
		{
		}

		///<summary>/{index}/_mapping</summary>
        public IndicesGetMappingRequest(Indices index) : base(r => r.Optional("index", index))
		{
		}

		[JsonIgnore]
		public bool? AllowNoIndices { get => Q<bool?>("allow_no_indices"); set => Q("allow_no_indices", value); }

		[JsonIgnore]
		public ExpandWildcards? ExpandWildcards { get => Q<ExpandWildcards?>("expand_wildcards"); set => Q("expand_wildcards", value); }

		[JsonIgnore]
		public bool? IgnoreUnavailable { get => Q<bool?>("ignore_unavailable"); set => Q("ignore_unavailable", value); }

		[JsonIgnore]
		public bool? IncludeTypeName { get => Q<bool?>("include_type_name"); set => Q("include_type_name", value); }

		[JsonIgnore]
		public bool? Local { get => Q<bool?>("local"); set => Q("local", value); }

		[JsonIgnore]
		public Time? MasterTimeout { get => Q<Time?>("master_timeout"); set => Q("master_timeout", value); }
	}

	[ConvertAs(typeof(IndicesGetSettingsRequest))]
	public partial interface IIndicesGetSettingsRequest : IRequest<IndicesGetSettingsRequestParameters>
	{
	}

	public partial class IndicesGetSettingsRequest : PlainRequestBase<IndicesGetSettingsRequestParameters>, IIndicesGetSettingsRequest
	{
		protected IIndicesGetSettingsRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesGetSettings;
		protected override HttpMethod HttpMethod => HttpMethod.GET;
		protected override bool SupportsBody => false;
		protected override bool CanBeEmpty => true;
		protected override bool IsEmpty => true;

		///<summary>/_settings</summary>
        public IndicesGetSettingsRequest() : base()
		{
		}

		///<summary>/{index}/_settings</summary>
        public IndicesGetSettingsRequest(Indices index) : base(r => r.Optional("index", index))
		{
		}

		///<summary>/{index}/_settings/{name}</summary>
        public IndicesGetSettingsRequest(Indices index, Names name) : base(r => r.Optional("index", index).Optional("name", name))
		{
		}

		///<summary>/_settings/{name}</summary>
        public IndicesGetSettingsRequest(Names name) : base(r => r.Optional("name", name))
		{
		}

		[JsonIgnore]
		public bool? AllowNoIndices { get => Q<bool?>("allow_no_indices"); set => Q("allow_no_indices", value); }

		[JsonIgnore]
		public ExpandWildcards? ExpandWildcards { get => Q<ExpandWildcards?>("expand_wildcards"); set => Q("expand_wildcards", value); }

		[JsonIgnore]
		public bool? FlatSettings { get => Q<bool?>("flat_settings"); set => Q("flat_settings", value); }

		[JsonIgnore]
		public bool? IgnoreUnavailable { get => Q<bool?>("ignore_unavailable"); set => Q("ignore_unavailable", value); }

		[JsonIgnore]
		public bool? IncludeDefaults { get => Q<bool?>("include_defaults"); set => Q("include_defaults", value); }

		[JsonIgnore]
		public bool? Local { get => Q<bool?>("local"); set => Q("local", value); }

		[JsonIgnore]
		public Time? MasterTimeout { get => Q<Time?>("master_timeout"); set => Q("master_timeout", value); }
	}

	[ConvertAs(typeof(IndicesGetTemplateRequest))]
	public partial interface IIndicesGetTemplateRequest : IRequest<IndicesGetTemplateRequestParameters>
	{
	}

	public partial class IndicesGetTemplateRequest : PlainRequestBase<IndicesGetTemplateRequestParameters>, IIndicesGetTemplateRequest
	{
		protected IIndicesGetTemplateRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesGetTemplate;
		protected override HttpMethod HttpMethod => HttpMethod.GET;
		protected override bool SupportsBody => false;
		protected override bool CanBeEmpty => true;
		protected override bool IsEmpty => true;

		///<summary>/_template</summary>
        public IndicesGetTemplateRequest() : base()
		{
		}

		///<summary>/_template/{name}</summary>
        public IndicesGetTemplateRequest(Names name) : base(r => r.Optional("name", name))
		{
		}

		[JsonIgnore]
		public bool? FlatSettings { get => Q<bool?>("flat_settings"); set => Q("flat_settings", value); }

		[JsonIgnore]
		public bool? IncludeTypeName { get => Q<bool?>("include_type_name"); set => Q("include_type_name", value); }

		[JsonIgnore]
		public bool? Local { get => Q<bool?>("local"); set => Q("local", value); }

		[JsonIgnore]
		public Time? MasterTimeout { get => Q<Time?>("master_timeout"); set => Q("master_timeout", value); }
	}

	[ConvertAs(typeof(IndicesMigrateToDataStreamRequest))]
	public partial interface IIndicesMigrateToDataStreamRequest : IRequest<IndicesMigrateToDataStreamRequestParameters>
	{
	}

	public partial class IndicesMigrateToDataStreamRequest : PlainRequestBase<IndicesMigrateToDataStreamRequestParameters>, IIndicesMigrateToDataStreamRequest
	{
		protected IIndicesMigrateToDataStreamRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesMigrateToDataStream;
		protected override HttpMethod HttpMethod => HttpMethod.POST;
		protected override bool SupportsBody => false;
		protected override bool CanBeEmpty => false;
		protected override bool IsEmpty => false;

		///<summary>/_data_stream/_migrate/{name}</summary>
        public IndicesMigrateToDataStreamRequest(IndexName name) : base(r => r.Required("name", name))
		{
		}
	}

	[ConvertAs(typeof(IndicesOpenRequest))]
	public partial interface IIndicesOpenRequest : IRequest<IndicesOpenRequestParameters>
	{
	}

	public partial class IndicesOpenRequest : PlainRequestBase<IndicesOpenRequestParameters>, IIndicesOpenRequest
	{
		protected IIndicesOpenRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesOpen;
		protected override HttpMethod HttpMethod => HttpMethod.POST;
		protected override bool SupportsBody => false;
		protected override bool CanBeEmpty => false;
		protected override bool IsEmpty => false;

		///<summary>/{index}/_open</summary>
        public IndicesOpenRequest(Indices index) : base(r => r.Required("index", index))
		{
		}

		[JsonIgnore]
		public bool? AllowNoIndices { get => Q<bool?>("allow_no_indices"); set => Q("allow_no_indices", value); }

		[JsonIgnore]
		public ExpandWildcards? ExpandWildcards { get => Q<ExpandWildcards?>("expand_wildcards"); set => Q("expand_wildcards", value); }

		[JsonIgnore]
		public bool? IgnoreUnavailable { get => Q<bool?>("ignore_unavailable"); set => Q("ignore_unavailable", value); }

		[JsonIgnore]
		public Time? MasterTimeout { get => Q<Time?>("master_timeout"); set => Q("master_timeout", value); }

		[JsonIgnore]
		public Time? Timeout { get => Q<Time?>("timeout"); set => Q("timeout", value); }

		[JsonIgnore]
		public WaitForActiveShards? WaitForActiveShards { get => Q<WaitForActiveShards?>("wait_for_active_shards"); set => Q("wait_for_active_shards", value); }
	}

	[ConvertAs(typeof(IndicesPromoteDataStreamRequest))]
	public partial interface IIndicesPromoteDataStreamRequest : IRequest<IndicesPromoteDataStreamRequestParameters>
	{
	}

	public partial class IndicesPromoteDataStreamRequest : PlainRequestBase<IndicesPromoteDataStreamRequestParameters>, IIndicesPromoteDataStreamRequest
	{
		protected IIndicesPromoteDataStreamRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesPromoteDataStream;
		protected override HttpMethod HttpMethod => HttpMethod.POST;
		protected override bool SupportsBody => false;
		protected override bool CanBeEmpty => false;
		protected override bool IsEmpty => false;

		///<summary>/_data_stream/_promote/{name}</summary>
        public IndicesPromoteDataStreamRequest(IndexName name) : base(r => r.Required("name", name))
		{
		}
	}

	[ConvertAs(typeof(IndicesPutAliasRequest))]
	public partial interface IIndicesPutAliasRequest : IRequest<IndicesPutAliasRequestParameters>
	{
	}

	public partial class IndicesPutAliasRequest : PlainRequestBase<IndicesPutAliasRequestParameters>, IIndicesPutAliasRequest
	{
		protected IIndicesPutAliasRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesPutAlias;
		protected override HttpMethod HttpMethod => HttpMethod.PUT;
		protected override bool SupportsBody => true;
		protected override bool CanBeEmpty => false;
		protected override bool IsEmpty => false;

		///<summary>/{index}/_alias/{name}</summary>
        public IndicesPutAliasRequest(Indices index, Name name) : base(r => r.Required("index", index).Required("name", name))
		{
		}

		[JsonIgnore]
		public Time? MasterTimeout { get => Q<Time?>("master_timeout"); set => Q("master_timeout", value); }

		[JsonIgnore]
		public Time? Timeout { get => Q<Time?>("timeout"); set => Q("timeout", value); }

		[JsonPropertyName("filter")]
		public QueryContainer? Filter
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("index_routing")]
		public Routing? IndexRouting
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("is_write_index")]
		public bool? IsWriteIndex
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("routing")]
		public Routing? Routing
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("search_routing")]
		public Routing? SearchRouting
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}
	}

	[ConvertAs(typeof(IndicesPutIndexTemplateRequest))]
	public partial interface IIndicesPutIndexTemplateRequest : IRequest<IndicesPutIndexTemplateRequestParameters>
	{
	}

	public partial class IndicesPutIndexTemplateRequest : PlainRequestBase<IndicesPutIndexTemplateRequestParameters>, IIndicesPutIndexTemplateRequest
	{
		protected IIndicesPutIndexTemplateRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesPutIndexTemplate;
		protected override HttpMethod HttpMethod => HttpMethod.PUT;
		protected override bool SupportsBody => true;
		protected override bool CanBeEmpty => false;
		protected override bool IsEmpty => false;

		///<summary>/_index_template/{name}</summary>
        public IndicesPutIndexTemplateRequest(Name name) : base(r => r.Required("name", name))
		{
		}

		[JsonPropertyName("composed_of")]
		public IReadOnlyCollection<Name>? ComposedOf
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("template")]
		public IndexTemplateMapping? Template
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("data_stream")]
		public EmptyObject? DataStream
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("priority")]
		public int? Priority
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("version")]
		public VersionNumber? Version
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("_meta")]
		public Metadata? Meta
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}
	}

	[ConvertAs(typeof(IndicesPutMappingRequest))]
	public partial interface IIndicesPutMappingRequest : IRequest<IndicesPutMappingRequestParameters>
	{
	}

	public partial class IndicesPutMappingRequest : PlainRequestBase<IndicesPutMappingRequestParameters>, IIndicesPutMappingRequest
	{
		protected IIndicesPutMappingRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesPutMapping;
		protected override HttpMethod HttpMethod => HttpMethod.PUT;
		protected override bool SupportsBody => true;
		protected override bool CanBeEmpty => true;
		protected override bool IsEmpty => AllField is null && DateDetection is null && Dynamic is null && DynamicDateFormats is null && DynamicTemplates is null && FieldNamesField is null && IndexField is null && Meta is null && NumericDetection is null && Properties is null && RoutingField is null && SizeField is null && SourceField is null && Runtime is null;

		///<summary>/{index}/_mapping</summary>
        public IndicesPutMappingRequest(Indices index) : base(r => r.Optional("index", index))
		{
		}

		[JsonIgnore]
		public bool? AllowNoIndices { get => Q<bool?>("allow_no_indices"); set => Q("allow_no_indices", value); }

		[JsonIgnore]
		public ExpandWildcards? ExpandWildcards { get => Q<ExpandWildcards?>("expand_wildcards"); set => Q("expand_wildcards", value); }

		[JsonIgnore]
		public bool? IgnoreUnavailable { get => Q<bool?>("ignore_unavailable"); set => Q("ignore_unavailable", value); }

		[JsonIgnore]
		public bool? IncludeTypeName { get => Q<bool?>("include_type_name"); set => Q("include_type_name", value); }

		[JsonIgnore]
		public Time? MasterTimeout { get => Q<Time?>("master_timeout"); set => Q("master_timeout", value); }

		[JsonIgnore]
		public Time? Timeout { get => Q<Time?>("timeout"); set => Q("timeout", value); }

		[JsonIgnore]
		public bool? WriteIndexOnly { get => Q<bool?>("write_index_only"); set => Q("write_index_only", value); }

		[JsonPropertyName("all_field")]
		public AllField? AllField
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("date_detection")]
		public bool? DateDetection
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("dynamic")]
		public Union<bool, DynamicMapping>? Dynamic
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("dynamic_date_formats")]
		public IReadOnlyCollection<string>? DynamicDateFormats
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("dynamic_templates")]
		public Union<Dictionary<string, DynamicTemplate>, IReadOnlyCollection<Dictionary<string, DynamicTemplate>>>? DynamicTemplates
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("field_names_field")]
		public FieldNamesField? FieldNamesField
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("index_field")]
		public IndexField? IndexField
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("meta")]
		public Dictionary<string, object>? Meta
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("numeric_detection")]
		public bool? NumericDetection
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("properties")]
		public Dictionary<PropertyName, PropertyBase>? Properties
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("routing_field")]
		public RoutingField? RoutingField
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("size_field")]
		public SizeField? SizeField
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("source_field")]
		public SourceField? SourceField
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("runtime")]
		public RuntimeFields? Runtime
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}
	}

	[ConvertAs(typeof(IndicesPutSettingsRequest))]
	public partial interface IIndicesPutSettingsRequest : IRequest<IndicesPutSettingsRequestParameters>
	{
	}

	public partial class IndicesPutSettingsRequest : PlainRequestBase<IndicesPutSettingsRequestParameters>, IIndicesPutSettingsRequest
	{
		protected IIndicesPutSettingsRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesPutSettings;
		protected override HttpMethod HttpMethod => HttpMethod.PUT;
		protected override bool SupportsBody => false;
		protected override bool CanBeEmpty => true;
		protected override bool IsEmpty => true;

		///<summary>/_settings</summary>
        public IndicesPutSettingsRequest() : base()
		{
		}

		///<summary>/{index}/_settings</summary>
        public IndicesPutSettingsRequest(Indices index) : base(r => r.Optional("index", index))
		{
		}

		[JsonIgnore]
		public bool? AllowNoIndices { get => Q<bool?>("allow_no_indices"); set => Q("allow_no_indices", value); }

		[JsonIgnore]
		public ExpandWildcards? ExpandWildcards { get => Q<ExpandWildcards?>("expand_wildcards"); set => Q("expand_wildcards", value); }

		[JsonIgnore]
		public bool? FlatSettings { get => Q<bool?>("flat_settings"); set => Q("flat_settings", value); }

		[JsonIgnore]
		public bool? IgnoreUnavailable { get => Q<bool?>("ignore_unavailable"); set => Q("ignore_unavailable", value); }

		[JsonIgnore]
		public Time? MasterTimeout { get => Q<Time?>("master_timeout"); set => Q("master_timeout", value); }

		[JsonIgnore]
		public bool? PreserveExisting { get => Q<bool?>("preserve_existing"); set => Q("preserve_existing", value); }

		[JsonIgnore]
		public Time? Timeout { get => Q<Time?>("timeout"); set => Q("timeout", value); }
	}

	[ConvertAs(typeof(IndicesPutTemplateRequest))]
	public partial interface IIndicesPutTemplateRequest : IRequest<IndicesPutTemplateRequestParameters>
	{
	}

	public partial class IndicesPutTemplateRequest : PlainRequestBase<IndicesPutTemplateRequestParameters>, IIndicesPutTemplateRequest
	{
		protected IIndicesPutTemplateRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesPutTemplate;
		protected override HttpMethod HttpMethod => HttpMethod.PUT;
		protected override bool SupportsBody => true;
		protected override bool CanBeEmpty => false;
		protected override bool IsEmpty => false;

		///<summary>/_template/{name}</summary>
        public IndicesPutTemplateRequest(Name name) : base(r => r.Required("name", name))
		{
		}

		[JsonIgnore]
		public bool? Create { get => Q<bool?>("create"); set => Q("create", value); }

		[JsonIgnore]
		public bool? FlatSettings { get => Q<bool?>("flat_settings"); set => Q("flat_settings", value); }

		[JsonIgnore]
		public bool? IncludeTypeName { get => Q<bool?>("include_type_name"); set => Q("include_type_name", value); }

		[JsonIgnore]
		public Time? MasterTimeout { get => Q<Time?>("master_timeout"); set => Q("master_timeout", value); }

		[JsonIgnore]
		public Time? Timeout { get => Q<Time?>("timeout"); set => Q("timeout", value); }

		[JsonPropertyName("aliases")]
		public Dictionary<IndexName, Alias>? Aliases
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("mappings")]
		public TypeMapping? Mappings
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("order")]
		public int? Order
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("settings")]
		public Dictionary<string, object>? Settings
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("version")]
		public VersionNumber? Version
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}
	}

	[ConvertAs(typeof(IndicesRecoveryRequest))]
	public partial interface IIndicesRecoveryRequest : IRequest<IndicesRecoveryRequestParameters>
	{
	}

	public partial class IndicesRecoveryRequest : PlainRequestBase<IndicesRecoveryRequestParameters>, IIndicesRecoveryRequest
	{
		protected IIndicesRecoveryRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesRecovery;
		protected override HttpMethod HttpMethod => HttpMethod.GET;
		protected override bool SupportsBody => false;
		protected override bool CanBeEmpty => true;
		protected override bool IsEmpty => true;

		///<summary>/_recovery</summary>
        public IndicesRecoveryRequest() : base()
		{
		}

		///<summary>/{index}/_recovery</summary>
        public IndicesRecoveryRequest(Indices index) : base(r => r.Optional("index", index))
		{
		}

		[JsonIgnore]
		public bool? ActiveOnly { get => Q<bool?>("active_only"); set => Q("active_only", value); }

		[JsonIgnore]
		public bool? Detailed { get => Q<bool?>("detailed"); set => Q("detailed", value); }
	}

	[ConvertAs(typeof(IndicesRefreshRequest))]
	public partial interface IIndicesRefreshRequest : IRequest<IndicesRefreshRequestParameters>
	{
	}

	public partial class IndicesRefreshRequest : PlainRequestBase<IndicesRefreshRequestParameters>, IIndicesRefreshRequest
	{
		protected IIndicesRefreshRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesRefresh;
		protected override HttpMethod HttpMethod => HttpMethod.POST;
		protected override bool SupportsBody => false;
		protected override bool CanBeEmpty => true;
		protected override bool IsEmpty => true;

		///<summary>/_refresh</summary>
        public IndicesRefreshRequest() : base()
		{
		}

		///<summary>/{index}/_refresh</summary>
        public IndicesRefreshRequest(Indices index) : base(r => r.Optional("index", index))
		{
		}

		[JsonIgnore]
		public bool? AllowNoIndices { get => Q<bool?>("allow_no_indices"); set => Q("allow_no_indices", value); }

		[JsonIgnore]
		public ExpandWildcards? ExpandWildcards { get => Q<ExpandWildcards?>("expand_wildcards"); set => Q("expand_wildcards", value); }

		[JsonIgnore]
		public bool? IgnoreUnavailable { get => Q<bool?>("ignore_unavailable"); set => Q("ignore_unavailable", value); }
	}

	[ConvertAs(typeof(IndicesReloadSearchAnalyzersRequest))]
	public partial interface IIndicesReloadSearchAnalyzersRequest : IRequest<IndicesReloadSearchAnalyzersRequestParameters>
	{
	}

	public partial class IndicesReloadSearchAnalyzersRequest : PlainRequestBase<IndicesReloadSearchAnalyzersRequestParameters>, IIndicesReloadSearchAnalyzersRequest
	{
		protected IIndicesReloadSearchAnalyzersRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesReloadSearchAnalyzers;
		protected override HttpMethod HttpMethod => HttpMethod.POST;
		protected override bool SupportsBody => false;
		protected override bool CanBeEmpty => false;
		protected override bool IsEmpty => false;

		///<summary>/{index}/_reload_search_analyzers</summary>
        public IndicesReloadSearchAnalyzersRequest(Indices index) : base(r => r.Required("index", index))
		{
		}

		[JsonIgnore]
		public bool? AllowNoIndices { get => Q<bool?>("allow_no_indices"); set => Q("allow_no_indices", value); }

		[JsonIgnore]
		public ExpandWildcards? ExpandWildcards { get => Q<ExpandWildcards?>("expand_wildcards"); set => Q("expand_wildcards", value); }

		[JsonIgnore]
		public bool? IgnoreUnavailable { get => Q<bool?>("ignore_unavailable"); set => Q("ignore_unavailable", value); }
	}

	[ConvertAs(typeof(IndicesResolveIndexRequest))]
	public partial interface IIndicesResolveIndexRequest : IRequest<IndicesResolveIndexRequestParameters>
	{
	}

	public partial class IndicesResolveIndexRequest : PlainRequestBase<IndicesResolveIndexRequestParameters>, IIndicesResolveIndexRequest
	{
		protected IIndicesResolveIndexRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesResolveIndex;
		protected override HttpMethod HttpMethod => HttpMethod.GET;
		protected override bool SupportsBody => false;
		protected override bool CanBeEmpty => false;
		protected override bool IsEmpty => false;

		///<summary>/_resolve/index/{name}</summary>
        public IndicesResolveIndexRequest(Names name) : base(r => r.Required("name", name))
		{
		}

		[JsonIgnore]
		public ExpandWildcards? ExpandWildcards { get => Q<ExpandWildcards?>("expand_wildcards"); set => Q("expand_wildcards", value); }
	}

	[ConvertAs(typeof(IndicesRolloverRequest))]
	public partial interface IIndicesRolloverRequest : IRequest<IndicesRolloverRequestParameters>
	{
	}

	public partial class IndicesRolloverRequest : PlainRequestBase<IndicesRolloverRequestParameters>, IIndicesRolloverRequest
	{
		protected IIndicesRolloverRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesRollover;
		protected override HttpMethod HttpMethod => HttpMethod.POST;
		protected override bool SupportsBody => true;
		protected override bool CanBeEmpty => false;
		protected override bool IsEmpty => false;

		///<summary>/{alias}/_rollover</summary>
        public IndicesRolloverRequest(IndexAlias alias) : base(r => r.Required("alias", alias))
		{
		}

		///<summary>/{alias}/_rollover/{new_index}</summary>
        public IndicesRolloverRequest(IndexAlias alias, IndexName new_index) : base(r => r.Required("alias", alias).Optional("new_index", new_index))
		{
		}

		[JsonIgnore]
		public bool? DryRun { get => Q<bool?>("dry_run"); set => Q("dry_run", value); }

		[JsonIgnore]
		public bool? IncludeTypeName { get => Q<bool?>("include_type_name"); set => Q("include_type_name", value); }

		[JsonIgnore]
		public Time? MasterTimeout { get => Q<Time?>("master_timeout"); set => Q("master_timeout", value); }

		[JsonIgnore]
		public Time? Timeout { get => Q<Time?>("timeout"); set => Q("timeout", value); }

		[JsonIgnore]
		public WaitForActiveShards? WaitForActiveShards { get => Q<WaitForActiveShards?>("wait_for_active_shards"); set => Q("wait_for_active_shards", value); }

		[JsonPropertyName("aliases")]
		public Dictionary<IndexName, Alias>? Aliases
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("conditions")]
		public RolloverConditions? Conditions
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("mappings")]
		public Union<Dictionary<string, TypeMapping>, TypeMapping>? Mappings
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("settings")]
		public Dictionary<string, object>? Settings
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}
	}

	[ConvertAs(typeof(IndicesSegmentsRequest))]
	public partial interface IIndicesSegmentsRequest : IRequest<IndicesSegmentsRequestParameters>
	{
	}

	public partial class IndicesSegmentsRequest : PlainRequestBase<IndicesSegmentsRequestParameters>, IIndicesSegmentsRequest
	{
		protected IIndicesSegmentsRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesSegments;
		protected override HttpMethod HttpMethod => HttpMethod.GET;
		protected override bool SupportsBody => false;
		protected override bool CanBeEmpty => true;
		protected override bool IsEmpty => true;

		///<summary>/_segments</summary>
        public IndicesSegmentsRequest() : base()
		{
		}

		///<summary>/{index}/_segments</summary>
        public IndicesSegmentsRequest(Indices index) : base(r => r.Optional("index", index))
		{
		}

		[JsonIgnore]
		public bool? AllowNoIndices { get => Q<bool?>("allow_no_indices"); set => Q("allow_no_indices", value); }

		[JsonIgnore]
		public ExpandWildcards? ExpandWildcards { get => Q<ExpandWildcards?>("expand_wildcards"); set => Q("expand_wildcards", value); }

		[JsonIgnore]
		public bool? IgnoreUnavailable { get => Q<bool?>("ignore_unavailable"); set => Q("ignore_unavailable", value); }

		[JsonIgnore]
		public bool? Verbose { get => Q<bool?>("verbose"); set => Q("verbose", value); }
	}

	[ConvertAs(typeof(IndicesShardStoresRequest))]
	public partial interface IIndicesShardStoresRequest : IRequest<IndicesShardStoresRequestParameters>
	{
	}

	public partial class IndicesShardStoresRequest : PlainRequestBase<IndicesShardStoresRequestParameters>, IIndicesShardStoresRequest
	{
		protected IIndicesShardStoresRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesShardStores;
		protected override HttpMethod HttpMethod => HttpMethod.GET;
		protected override bool SupportsBody => false;
		protected override bool CanBeEmpty => true;
		protected override bool IsEmpty => true;

		///<summary>/_shard_stores</summary>
        public IndicesShardStoresRequest() : base()
		{
		}

		///<summary>/{index}/_shard_stores</summary>
        public IndicesShardStoresRequest(Indices index) : base(r => r.Optional("index", index))
		{
		}

		[JsonIgnore]
		public bool? AllowNoIndices { get => Q<bool?>("allow_no_indices"); set => Q("allow_no_indices", value); }

		[JsonIgnore]
		public ExpandWildcards? ExpandWildcards { get => Q<ExpandWildcards?>("expand_wildcards"); set => Q("expand_wildcards", value); }

		[JsonIgnore]
		public bool? IgnoreUnavailable { get => Q<bool?>("ignore_unavailable"); set => Q("ignore_unavailable", value); }
	}

	[ConvertAs(typeof(IndicesShrinkRequest))]
	public partial interface IIndicesShrinkRequest : IRequest<IndicesShrinkRequestParameters>
	{
	}

	public partial class IndicesShrinkRequest : PlainRequestBase<IndicesShrinkRequestParameters>, IIndicesShrinkRequest
	{
		protected IIndicesShrinkRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesShrink;
		protected override HttpMethod HttpMethod => HttpMethod.PUT;
		protected override bool SupportsBody => true;
		protected override bool CanBeEmpty => false;
		protected override bool IsEmpty => false;

		///<summary>/{index}/_shrink/{target}</summary>
        public IndicesShrinkRequest(IndexName index, IndexName target) : base(r => r.Required("index", index).Required("target", target))
		{
		}

		[JsonIgnore]
		public Time? MasterTimeout { get => Q<Time?>("master_timeout"); set => Q("master_timeout", value); }

		[JsonIgnore]
		public Time? Timeout { get => Q<Time?>("timeout"); set => Q("timeout", value); }

		[JsonIgnore]
		public WaitForActiveShards? WaitForActiveShards { get => Q<WaitForActiveShards?>("wait_for_active_shards"); set => Q("wait_for_active_shards", value); }

		[JsonPropertyName("aliases")]
		public Dictionary<IndexName, Alias>? Aliases
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("settings")]
		public Dictionary<string, object>? Settings
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}
	}

	[ConvertAs(typeof(IndicesSimulateIndexTemplateRequest))]
	public partial interface IIndicesSimulateIndexTemplateRequest : IRequest<IndicesSimulateIndexTemplateRequestParameters>
	{
	}

	public partial class IndicesSimulateIndexTemplateRequest : PlainRequestBase<IndicesSimulateIndexTemplateRequestParameters>, IIndicesSimulateIndexTemplateRequest
	{
		protected IIndicesSimulateIndexTemplateRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesSimulateIndexTemplate;
		protected override HttpMethod HttpMethod => HttpMethod.POST;
		protected override bool SupportsBody => true;
		protected override bool CanBeEmpty => true;
		protected override bool IsEmpty => ComposedOf is null && Overlapping is null && Template is null;

		///<summary>/_index_template/_simulate_index/{name}</summary>
        public IndicesSimulateIndexTemplateRequest(Name name) : base(r => r.Optional("name", name))
		{
		}

		[JsonPropertyName("composed_of")]
		public IReadOnlyCollection<Name>? ComposedOf
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("overlapping")]
		public IReadOnlyCollection<OverlappingIndexTemplate>? Overlapping
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("template")]
		public TemplateMapping? Template
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}
	}

	[ConvertAs(typeof(IndicesSimulateTemplateRequest))]
	public partial interface IIndicesSimulateTemplateRequest : IRequest<IndicesSimulateTemplateRequestParameters>
	{
	}

	public partial class IndicesSimulateTemplateRequest : PlainRequestBase<IndicesSimulateTemplateRequestParameters>, IIndicesSimulateTemplateRequest
	{
		protected IIndicesSimulateTemplateRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesSimulateTemplate;
		protected override HttpMethod HttpMethod => HttpMethod.POST;
		protected override bool SupportsBody => false;
		protected override bool CanBeEmpty => true;
		protected override bool IsEmpty => true;

		///<summary>/_index_template/_simulate</summary>
        public IndicesSimulateTemplateRequest() : base()
		{
		}

		///<summary>/_index_template/_simulate/{name}</summary>
        public IndicesSimulateTemplateRequest(Name name) : base(r => r.Optional("name", name))
		{
		}

		[JsonIgnore]
		public bool? Create { get => Q<bool?>("create"); set => Q("create", value); }

		[JsonIgnore]
		public Time? MasterTimeout { get => Q<Time?>("master_timeout"); set => Q("master_timeout", value); }
	}

	[ConvertAs(typeof(IndicesSplitRequest))]
	public partial interface IIndicesSplitRequest : IRequest<IndicesSplitRequestParameters>
	{
	}

	public partial class IndicesSplitRequest : PlainRequestBase<IndicesSplitRequestParameters>, IIndicesSplitRequest
	{
		protected IIndicesSplitRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesSplit;
		protected override HttpMethod HttpMethod => HttpMethod.PUT;
		protected override bool SupportsBody => true;
		protected override bool CanBeEmpty => false;
		protected override bool IsEmpty => false;

		///<summary>/{index}/_split/{target}</summary>
        public IndicesSplitRequest(IndexName index, IndexName target) : base(r => r.Required("index", index).Required("target", target))
		{
		}

		[JsonIgnore]
		public Time? MasterTimeout { get => Q<Time?>("master_timeout"); set => Q("master_timeout", value); }

		[JsonIgnore]
		public Time? Timeout { get => Q<Time?>("timeout"); set => Q("timeout", value); }

		[JsonIgnore]
		public WaitForActiveShards? WaitForActiveShards { get => Q<WaitForActiveShards?>("wait_for_active_shards"); set => Q("wait_for_active_shards", value); }

		[JsonPropertyName("aliases")]
		public Dictionary<IndexName, Alias>? Aliases
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("settings")]
		public Dictionary<string, object>? Settings
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}
	}

	[ConvertAs(typeof(IndicesStatsRequest))]
	public partial interface IIndicesStatsRequest : IRequest<IndicesStatsRequestParameters>
	{
	}

	public partial class IndicesStatsRequest : PlainRequestBase<IndicesStatsRequestParameters>, IIndicesStatsRequest
	{
		protected IIndicesStatsRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesStats;
		protected override HttpMethod HttpMethod => HttpMethod.GET;
		protected override bool SupportsBody => false;
		protected override bool CanBeEmpty => true;
		protected override bool IsEmpty => true;

		///<summary>/_stats</summary>
        public IndicesStatsRequest() : base()
		{
		}

		///<summary>/_stats/{metric}</summary>
        public IndicesStatsRequest(Metrics metric) : base(r => r.Optional("metric", metric))
		{
		}

		///<summary>/{index}/_stats</summary>
        public IndicesStatsRequest(Indices index) : base(r => r.Optional("index", index))
		{
		}

		///<summary>/{index}/_stats/{metric}</summary>
        public IndicesStatsRequest(Indices index, Metrics metric) : base(r => r.Optional("index", index).Optional("metric", metric))
		{
		}

		[JsonIgnore]
		public Fields? CompletionFields { get => Q<Fields?>("completion_fields"); set => Q("completion_fields", value); }

		[JsonIgnore]
		public ExpandWildcards? ExpandWildcards { get => Q<ExpandWildcards?>("expand_wildcards"); set => Q("expand_wildcards", value); }

		[JsonIgnore]
		public Fields? FielddataFields { get => Q<Fields?>("fielddata_fields"); set => Q("fielddata_fields", value); }

		[JsonIgnore]
		public Fields? Fields { get => Q<Fields?>("fields"); set => Q("fields", value); }

		[JsonIgnore]
		public bool? ForbidClosedIndices { get => Q<bool?>("forbid_closed_indices"); set => Q("forbid_closed_indices", value); }

		[JsonIgnore]
		public Union<string, IEnumerable<string>>? Groups { get => Q<Union<string, IEnumerable<string>>?>("groups"); set => Q("groups", value); }

		[JsonIgnore]
		public bool? IncludeSegmentFileSizes { get => Q<bool?>("include_segment_file_sizes"); set => Q("include_segment_file_sizes", value); }

		[JsonIgnore]
		public bool? IncludeUnloadedSegments { get => Q<bool?>("include_unloaded_segments"); set => Q("include_unloaded_segments", value); }

		[JsonIgnore]
		public Level? Level { get => Q<Level?>("level"); set => Q("level", value); }

		[JsonIgnore]
		public Types? Types { get => Q<Types?>("types"); set => Q("types", value); }
	}

	[ConvertAs(typeof(IndicesUpdateAliasesRequest))]
	public partial interface IIndicesUpdateAliasesRequest : IRequest<IndicesUpdateAliasesRequestParameters>
	{
	}

	public partial class IndicesUpdateAliasesRequest : PlainRequestBase<IndicesUpdateAliasesRequestParameters>, IIndicesUpdateAliasesRequest
	{
		protected IIndicesUpdateAliasesRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesUpdateAliases;
		protected override HttpMethod HttpMethod => HttpMethod.POST;
		protected override bool SupportsBody => true;
		protected override bool CanBeEmpty => true;
		protected override bool IsEmpty => true;

		///<summary>/_aliases</summary>
        public IndicesUpdateAliasesRequest() : base()
		{
		}

		[JsonIgnore]
		public Time? MasterTimeout { get => Q<Time?>("master_timeout"); set => Q("master_timeout", value); }

		[JsonIgnore]
		public Time? Timeout { get => Q<Time?>("timeout"); set => Q("timeout", value); }
	}

	[ConvertAs(typeof(IndicesValidateQueryRequest))]
	public partial interface IIndicesValidateQueryRequest : IRequest<IndicesValidateQueryRequestParameters>
	{
	}

	public partial class IndicesValidateQueryRequest : PlainRequestBase<IndicesValidateQueryRequestParameters>, IIndicesValidateQueryRequest
	{
		protected IIndicesValidateQueryRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesValidateQuery;
		protected override HttpMethod HttpMethod => HttpMethod.POST;
		protected override bool SupportsBody => true;
		protected override bool CanBeEmpty => true;
		protected override bool IsEmpty => Query is null;

		///<summary>/_validate/query</summary>
        public IndicesValidateQueryRequest() : base()
		{
		}

		///<summary>/{index}/_validate/query</summary>
        public IndicesValidateQueryRequest(Indices index) : base(r => r.Optional("index", index))
		{
		}

		[JsonIgnore]
		public bool? AllowNoIndices { get => Q<bool?>("allow_no_indices"); set => Q("allow_no_indices", value); }

		[JsonIgnore]
		public bool? AllShards { get => Q<bool?>("all_shards"); set => Q("all_shards", value); }

		[JsonIgnore]
		public string? Analyzer { get => Q<string?>("analyzer"); set => Q("analyzer", value); }

		[JsonIgnore]
		public bool? AnalyzeWildcard { get => Q<bool?>("analyze_wildcard"); set => Q("analyze_wildcard", value); }

		[JsonIgnore]
		public DefaultOperator? DefaultOperator { get => Q<DefaultOperator?>("default_operator"); set => Q("default_operator", value); }

		[JsonIgnore]
		public string? Df { get => Q<string?>("df"); set => Q("df", value); }

		[JsonIgnore]
		public ExpandWildcards? ExpandWildcards { get => Q<ExpandWildcards?>("expand_wildcards"); set => Q("expand_wildcards", value); }

		[JsonIgnore]
		public bool? Explain { get => Q<bool?>("explain"); set => Q("explain", value); }

		[JsonIgnore]
		public bool? IgnoreUnavailable { get => Q<bool?>("ignore_unavailable"); set => Q("ignore_unavailable", value); }

		[JsonIgnore]
		public bool? Lenient { get => Q<bool?>("lenient"); set => Q("lenient", value); }

		[JsonIgnore]
		public string? QueryOnQueryString { get => Q<string?>("query_on_query_string"); set => Q("query_on_query_string", value); }

		[JsonIgnore]
		public bool? Rewrite { get => Q<bool?>("rewrite"); set => Q("rewrite", value); }

		[JsonIgnore]
		public string? QueryLuceneSyntax { get => Q<string?>("q"); set => Q("q", value); }

		[JsonPropertyName("query")]
		public QueryContainer? Query
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}
	}
}