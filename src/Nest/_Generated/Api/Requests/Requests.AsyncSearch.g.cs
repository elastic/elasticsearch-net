// Licensed to Elasticsearch B.V under one or more agreements.
// Elasticsearch B.V licenses this file to you under the Apache 2.0 License.
// See the LICENSE file in the project root for more information.
//
// ███╗   ██╗ ██████╗ ████████╗██╗ ██████╗███████╗
// ████╗  ██║██╔═══██╗╚══██╔══╝██║██╔════╝██╔════╝
// ██╔██╗ ██║██║   ██║   ██║   ██║██║     █████╗
// ██║╚██╗██║██║   ██║   ██║   ██║██║     ██╔══╝
// ██║ ╚████║╚██████╔╝   ██║   ██║╚██████╗███████╗
// ╚═╝  ╚═══╝ ╚═════╝    ╚═╝   ╚═╝ ╚═════╝╚══════╝
// ------------------------------------------------
//
// This file is automatically generated.
// Please do not edit these files manually.
// Run the following in the root of the repository:
//
// ------------------------------------------------

using Elastic.Transport;
using System.Collections.Generic;
using System.Text.Json.Serialization;

#nullable restore
namespace Nest.AsyncSearch
{
	[ConvertAs(typeof(DeleteRequest))]
	public partial interface IDeleteRequest : IRequest<DeleteRequestParameters>
	{
	}

	public partial class DeleteRequest : PlainRequestBase<DeleteRequestParameters>, IDeleteRequest
	{
		protected IDeleteRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.AsyncSearchDelete;
		protected override HttpMethod HttpMethod => HttpMethod.DELETE;
		protected override bool SupportsBody => false;
		protected override bool CanBeEmpty => false;
		protected override bool IsEmpty => false;

		///<summary>/_async_search/{id}</summary>
        public DeleteRequest(Nest.Id id) : base(r => r.Required("id", id))
		{
		}
	}

	[ConvertAs(typeof(GetRequest))]
	public partial interface IGetRequest : IRequest<GetRequestParameters>
	{
	}

	public partial class GetRequest : PlainRequestBase<GetRequestParameters>, IGetRequest
	{
		protected IGetRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.AsyncSearchGet;
		protected override HttpMethod HttpMethod => HttpMethod.GET;
		protected override bool SupportsBody => false;
		protected override bool CanBeEmpty => false;
		protected override bool IsEmpty => false;

		///<summary>/_async_search/{id}</summary>
        public GetRequest(Nest.Id id) : base(r => r.Required("id", id))
		{
		}

		[JsonIgnore]
		public Nest.Time? KeepAlive { get => Q<Nest.Time?>("keep_alive"); set => Q("keep_alive", value); }

		[JsonIgnore]
		public bool? TypedKeys { get => Q<bool?>("typed_keys"); set => Q("typed_keys", value); }

		[JsonIgnore]
		public Nest.Time? WaitForCompletionTimeout { get => Q<Nest.Time?>("wait_for_completion_timeout"); set => Q("wait_for_completion_timeout", value); }
	}

	[ConvertAs(typeof(StatusRequest))]
	public partial interface IStatusRequest : IRequest<StatusRequestParameters>
	{
	}

	public partial class StatusRequest : PlainRequestBase<StatusRequestParameters>, IStatusRequest
	{
		protected IStatusRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.AsyncSearchStatus;
		protected override HttpMethod HttpMethod => HttpMethod.GET;
		protected override bool SupportsBody => false;
		protected override bool CanBeEmpty => false;
		protected override bool IsEmpty => false;

		///<summary>/_async_search/status/{id}</summary>
        public StatusRequest(Nest.Id id) : base(r => r.Required("id", id))
		{
		}
	}

	[ConvertAs(typeof(SubmitRequest))]
	public partial interface ISubmitRequest : IRequest<SubmitRequestParameters>
	{
	}

	public partial class SubmitRequest : PlainRequestBase<SubmitRequestParameters>, ISubmitRequest
	{
		protected ISubmitRequest Self => this;
		internal override ApiUrls ApiUrls => ApiUrlsLookups.AsyncSearchSubmit;
		protected override HttpMethod HttpMethod => HttpMethod.POST;
		protected override bool SupportsBody => true;
		protected override bool CanBeEmpty => true;
		protected override bool IsEmpty => Aggs is null && AllowNoIndices is null && AllowPartialSearchResults is null && Analyzer is null && AnalyzeWildcard is null && Collapse is null && DefaultOperator is null && Df is null && DocvalueFields is null && Explain is null && From is null && Highlight is null && IgnoreThrottled is null && IgnoreUnavailable is null && IndicesBoost is null && KeepAlive is null && Lenient is null && MaxConcurrentShardRequests is null && MinScore is null && PostFilter is null && Preference is null && Profile is null && Pit is null && Query is null && QueryOnQueryString is null && RequestCache is null && Rescore is null && ScriptFields is null && SearchAfter is null && SearchType is null && SequenceNumberPrimaryTerm is null && Size is null && Source is null && Stats is null && StoredFields is null && Suggest is null && SuggestField is null && SuggestMode is null && SuggestSize is null && SuggestText is null && TerminateAfter is null && Timeout is null && TrackScores is null && TrackTotalHits is null && Version is null;

		///<summary>/_async_search</summary>
        public SubmitRequest() : base()
		{
		}

		///<summary>/{index}/_async_search</summary>
        public SubmitRequest(Nest.Indices? index) : base(r => r.Optional("index", index))
		{
		}

		[JsonIgnore]
		public long? BatchedReduceSize { get => Q<long?>("batched_reduce_size"); set => Q("batched_reduce_size", value); }

		[JsonIgnore]
		public Nest.Time? WaitForCompletionTimeout { get => Q<Nest.Time?>("wait_for_completion_timeout"); set => Q("wait_for_completion_timeout", value); }

		[JsonIgnore]
		public bool? KeepOnCompletion { get => Q<bool?>("keep_on_completion"); set => Q("keep_on_completion", value); }

		[JsonIgnore]
		public bool? TypedKeys { get => Q<bool?>("typed_keys"); set => Q("typed_keys", value); }

		[JsonPropertyName("aggs")]
		public Dictionary<string, Nest.Aggregations.AggregationContainer>? Aggs
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("allow_no_indices")]
		public bool? AllowNoIndices
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("allow_partial_search_results")]
		public bool? AllowPartialSearchResults
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("analyzer")]
		public string? Analyzer
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("analyze_wildcard")]
		public bool? AnalyzeWildcard
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("collapse")]
		public Nest.Global.Search.FieldCollapse? Collapse
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("default_operator")]
		public Nest.DefaultOperator? DefaultOperator
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("df")]
		public string? Df
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("docvalue_fields")]
		public Nest.Fields? DocvalueFields
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("explain")]
		public bool? Explain
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("from")]
		public int? From
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("highlight")]
		public Nest.Global.Search.Highlight? Highlight
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("ignore_throttled")]
		public bool? IgnoreThrottled
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("ignore_unavailable")]
		public bool? IgnoreUnavailable
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("indices_boost")]
		public IReadOnlyCollection<Dictionary<Nest.IndexName, double>>? IndicesBoost
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("keep_alive")]
		public Nest.Time? KeepAlive
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("lenient")]
		public bool? Lenient
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("max_concurrent_shard_requests")]
		public long? MaxConcurrentShardRequests
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("min_score")]
		public double? MinScore
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("post_filter")]
		public Nest.QueryDsl.QueryContainer? PostFilter
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("preference")]
		public string? Preference
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("profile")]
		public bool? Profile
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("pit")]
		public Nest.Global.Search.PointInTimeReference? Pit
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("query")]
		public Nest.QueryDsl.QueryContainer? Query
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("query_on_query_string")]
		public string? QueryOnQueryString
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("request_cache")]
		public bool? RequestCache
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("rescore")]
		public IReadOnlyCollection<Nest.Global.Search.Rescore>? Rescore
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("script_fields")]
		public Dictionary<string, Nest.ScriptField>? ScriptFields
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("search_after")]
		public Nest.Global.Search.SortResults? SearchAfter
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("search_type")]
		public Nest.SearchType? SearchType
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("sequence_number_primary_term")]
		public bool? SequenceNumberPrimaryTerm
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("size")]
		public int? Size
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("_source")]
		public Union<bool, Nest.Global.Search.SourceFilter>? Source
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("stats")]
		public IReadOnlyCollection<string>? Stats
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("stored_fields")]
		public Nest.Fields? StoredFields
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("suggest")]
		public Dictionary<string, Nest.Global.Search.SuggestContainer>? Suggest
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("suggest_field")]
		public Nest.Field? SuggestField
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("suggest_mode")]
		public Nest.SuggestMode? SuggestMode
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("suggest_size")]
		public long? SuggestSize
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("suggest_text")]
		public string? SuggestText
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("terminate_after")]
		public long? TerminateAfter
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("timeout")]
		public string? Timeout
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("track_scores")]
		public bool? TrackScores
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("track_total_hits")]
		public bool? TrackTotalHits
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("version")]
		public bool? Version
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}
	}
}