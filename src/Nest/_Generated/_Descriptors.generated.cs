using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Linq.Expressions;
using Elasticsearch.Net;

//This file lays the base for all the descriptors based on the query string parameters in the spec for IElasticClient.
//This file is automatically generated from https://github.com/elastic/elasticsearch/tree/master/rest-api-spec
namespace Nest
{
	public abstract partial class RequestDescriptorBase<TDescriptor, TParameters, TInterface>
	{
		///<summary>Include the stack trace of returned errors.</summary>
		public TDescriptor ErrorTrace(bool? errorTrace = true) => Qs("error_trace", errorTrace);
		///<summary>A comma-separated list of filters used to reduce the response.<para>Use of response filtering can result in a response from Elasticsearch that cannot be correctly deserialized to the respective response type for the request. In such situations, use the low level client to issue the request and handle response deserialization</para></summary>
		public TDescriptor FilterPath(string[] filterPath) => Qs("filter_path", filterPath);
		///<summary>Return human readable values for statistics.</summary>
		public TDescriptor Human(bool? human = true) => Qs("human", human);
		///<summary>Pretty format the returned JSON response.</summary>
		public TDescriptor Pretty(bool? pretty = true) => Qs("pretty", pretty);
		///<summary>The URL-encoded request definition. Useful for libraries that do not accept a request body for non-POST requests.</summary>
		public TDescriptor SourceQueryString(string sourceQueryString) => Qs("source", sourceQueryString);
	}

	///<summary>descriptor for Bulk <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-bulk.html</pre></summary>
	public partial class BulkDescriptor : RequestDescriptorBase<BulkDescriptor, BulkRequestParameters, IBulkRequest>, IBulkRequest
	{
		internal override ApiUrls ApiUrls => BulkRequest.Urls;
		///<summary>/_bulk</summary>
		public BulkDescriptor(): base()
		{
		}

		///<summary>/{index}/_bulk</summary>
		///<param name = "index">Optional, accepts null</param>
		public BulkDescriptor(IndexName index): base(r => r.Optional("index", index))
		{
		}

		// values part of the url path
		IndexName IBulkRequest.Index => Self.RouteValues.Get<IndexName>("index");
		///<summary>Default index for items which don't provide one</summary>
		public BulkDescriptor Index(IndexName index) => Assign(index, (a, v) => a.RouteValues.Optional("index", v));
		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public BulkDescriptor Index<TOther>()
			where TOther : class => Assign(typeof(TOther), (a, v) => a.RouteValues.Optional("index", (IndexName)v));
		// Request parameters
		///<summary>The pipeline id to preprocess incoming documents with</summary>
		public BulkDescriptor Pipeline(string pipeline) => Qs("pipeline", pipeline);
		///<summary>If `true` then refresh the effected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` (the default) then do nothing with refreshes.</summary>
		public BulkDescriptor Refresh(Refresh? refresh) => Qs("refresh", refresh);
		///<summary>
		/// A document is routed to a particular shard in an index using the following formula
		/// <para> shard_num = hash(_routing) % num_primary_shards</para>
		/// <para>Elasticsearch will use the document id if not provided. </para>
		/// <para>For requests that are constructed from/for a document NEST will automatically infer the routing key
		/// if that document has a <see cref = "Nest.JoinField"/> or a routing mapping on for its type exists on <see cref = "Nest.ConnectionSettings"/></para> 
		///</summary>
		public BulkDescriptor Routing(Routing routing) => Qs("routing", routing);
		///<summary>Whether the _source should be included in the response.</summary>
		public BulkDescriptor SourceEnabled(bool? sourceEnabled = true) => Qs("_source", sourceEnabled);
		///<summary>Default list of fields to exclude from the returned _source field, can be overridden on each sub-request</summary>
		public BulkDescriptor SourceExcludes(Fields sourceExcludes) => Qs("_source_excludes", sourceExcludes);
		///<summary>Default list of fields to exclude from the returned _source field, can be overridden on each sub-request</summary>
		public BulkDescriptor SourceExcludes<T>(params Expression<Func<T, object>>[] fields)
			where T : class => Qs("_source_excludes", fields?.Select(e => (Field)e));
		///<summary>Default list of fields to extract and return from the _source field, can be overridden on each sub-request</summary>
		public BulkDescriptor SourceIncludes(Fields sourceIncludes) => Qs("_source_includes", sourceIncludes);
		///<summary>Default list of fields to extract and return from the _source field, can be overridden on each sub-request</summary>
		public BulkDescriptor SourceIncludes<T>(params Expression<Func<T, object>>[] fields)
			where T : class => Qs("_source_includes", fields?.Select(e => (Field)e));
		///<summary>Explicit operation timeout</summary>
		public BulkDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
		///<summary>Default document type for items which don't provide one</summary>
		public BulkDescriptor TypeQueryString(string typeQueryString) => Qs("type", typeQueryString);
		///<summary>Sets the number of shard copies that must be active before proceeding with the bulk operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1)</summary>
		public BulkDescriptor WaitForActiveShards(string waitForActiveShards) => Qs("wait_for_active_shards", waitForActiveShards);
	}

	///<summary>descriptor for Aliases <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-alias.html</pre></summary>
	public partial class CatAliasesDescriptor : RequestDescriptorBase<CatAliasesDescriptor, CatAliasesRequestParameters, ICatAliasesRequest>, ICatAliasesRequest
	{
		internal override ApiUrls ApiUrls => CatAliasesRequest.Urls;
		///<summary>/_cat/aliases</summary>
		public CatAliasesDescriptor(): base()
		{
		}

		///<summary>/_cat/aliases/{name}</summary>
		///<param name = "name">Optional, accepts null</param>
		public CatAliasesDescriptor(Names name): base(r => r.Optional("name", name))
		{
		}

		// values part of the url path
		Names ICatAliasesRequest.Name => Self.RouteValues.Get<Names>("name");
		///<summary>A comma-separated list of alias names to return</summary>
		public CatAliasesDescriptor Name(Names name) => Assign(name, (a, v) => a.RouteValues.Optional("name", v));
		// Request parameters
		///<summary>a short version of the Accept header, e.g. json, yaml</summary>
		public CatAliasesDescriptor Format(string format) => Qs("format", format);
		///<summary>Comma-separated list of column names to display</summary>
		public CatAliasesDescriptor Headers(params string[] headers) => Qs("h", headers);
		///<summary>Return help information</summary>
		public CatAliasesDescriptor Help(bool? help = true) => Qs("help", help);
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public CatAliasesDescriptor Local(bool? local = true) => Qs("local", local);
		///<summary>Explicit operation timeout for connection to master node</summary>
		public CatAliasesDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Comma-separated list of column names or column aliases to sort by</summary>
		public CatAliasesDescriptor SortByColumns(params string[] sortByColumns) => Qs("s", sortByColumns);
		///<summary>Verbose mode. Display column headers</summary>
		public CatAliasesDescriptor Verbose(bool? verbose = true) => Qs("v", verbose);
	}

	///<summary>descriptor for Allocation <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-allocation.html</pre></summary>
	public partial class CatAllocationDescriptor : RequestDescriptorBase<CatAllocationDescriptor, CatAllocationRequestParameters, ICatAllocationRequest>, ICatAllocationRequest
	{
		internal override ApiUrls ApiUrls => CatAllocationRequest.Urls;
		///<summary>/_cat/allocation</summary>
		public CatAllocationDescriptor(): base()
		{
		}

		///<summary>/_cat/allocation/{node_id}</summary>
		///<param name = "node_id">Optional, accepts null</param>
		public CatAllocationDescriptor(NodeIds node_id): base(r => r.Optional("node_id", node_id))
		{
		}

		// values part of the url path
		NodeIds ICatAllocationRequest.NodeId => Self.RouteValues.Get<NodeIds>("node_id");
		///<summary>A comma-separated list of node IDs or names to limit the returned information</summary>
		public CatAllocationDescriptor NodeId(NodeIds nodeId) => Assign(nodeId, (a, v) => a.RouteValues.Optional("node_id", v));
		// Request parameters
		///<summary>The unit in which to display byte values</summary>
		public CatAllocationDescriptor Bytes(Bytes? bytes) => Qs("bytes", bytes);
		///<summary>a short version of the Accept header, e.g. json, yaml</summary>
		public CatAllocationDescriptor Format(string format) => Qs("format", format);
		///<summary>Comma-separated list of column names to display</summary>
		public CatAllocationDescriptor Headers(params string[] headers) => Qs("h", headers);
		///<summary>Return help information</summary>
		public CatAllocationDescriptor Help(bool? help = true) => Qs("help", help);
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public CatAllocationDescriptor Local(bool? local = true) => Qs("local", local);
		///<summary>Explicit operation timeout for connection to master node</summary>
		public CatAllocationDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Comma-separated list of column names or column aliases to sort by</summary>
		public CatAllocationDescriptor SortByColumns(params string[] sortByColumns) => Qs("s", sortByColumns);
		///<summary>Verbose mode. Display column headers</summary>
		public CatAllocationDescriptor Verbose(bool? verbose = true) => Qs("v", verbose);
	}

	///<summary>descriptor for Count <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-count.html</pre></summary>
	public partial class CatCountDescriptor : RequestDescriptorBase<CatCountDescriptor, CatCountRequestParameters, ICatCountRequest>, ICatCountRequest
	{
		internal override ApiUrls ApiUrls => CatCountRequest.Urls;
		///<summary>/_cat/count</summary>
		public CatCountDescriptor(): base()
		{
		}

		///<summary>/_cat/count/{index}</summary>
		///<param name = "index">Optional, accepts null</param>
		public CatCountDescriptor(Indices index): base(r => r.Optional("index", index))
		{
		}

		// values part of the url path
		Indices ICatCountRequest.Index => Self.RouteValues.Get<Indices>("index");
		///<summary>A comma-separated list of index names to limit the returned information</summary>
		public CatCountDescriptor Index(Indices index) => Assign(index, (a, v) => a.RouteValues.Optional("index", v));
		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public CatCountDescriptor Index<TOther>()
			where TOther : class => Assign(typeof(TOther), (a, v) => a.RouteValues.Optional("index", (Indices)v));
		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public CatCountDescriptor AllIndices() => this.Index(Indices.All);
		// Request parameters
		///<summary>a short version of the Accept header, e.g. json, yaml</summary>
		public CatCountDescriptor Format(string format) => Qs("format", format);
		///<summary>Comma-separated list of column names to display</summary>
		public CatCountDescriptor Headers(params string[] headers) => Qs("h", headers);
		///<summary>Return help information</summary>
		public CatCountDescriptor Help(bool? help = true) => Qs("help", help);
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public CatCountDescriptor Local(bool? local = true) => Qs("local", local);
		///<summary>Explicit operation timeout for connection to master node</summary>
		public CatCountDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Comma-separated list of column names or column aliases to sort by</summary>
		public CatCountDescriptor SortByColumns(params string[] sortByColumns) => Qs("s", sortByColumns);
		///<summary>Verbose mode. Display column headers</summary>
		public CatCountDescriptor Verbose(bool? verbose = true) => Qs("v", verbose);
	}

	///<summary>descriptor for Fielddata <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-fielddata.html</pre></summary>
	public partial class CatFielddataDescriptor : RequestDescriptorBase<CatFielddataDescriptor, CatFielddataRequestParameters, ICatFielddataRequest>, ICatFielddataRequest
	{
		internal override ApiUrls ApiUrls => CatFielddataRequest.Urls;
		///<summary>/_cat/fielddata</summary>
		public CatFielddataDescriptor(): base()
		{
		}

		///<summary>/_cat/fielddata/{fields}</summary>
		///<param name = "fields">Optional, accepts null</param>
		public CatFielddataDescriptor(Fields fields): base(r => r.Optional("fields", fields))
		{
		}

		// values part of the url path
		Fields ICatFielddataRequest.Fields => Self.RouteValues.Get<Fields>("fields");
		///<summary>A comma-separated list of fields to return the fielddata size</summary>
		public CatFielddataDescriptor Fields(Fields fields) => Assign(fields, (a, v) => a.RouteValues.Optional("fields", v));
		///<summary>A comma-separated list of fields to return the fielddata size</summary>
		public CatFielddataDescriptor Fields<T>(params Expression<Func<T, object>>[] fields) => Assign(fields, (a, v) => a.RouteValues.Optional("fields", (Fields)v));
		// Request parameters
		///<summary>The unit in which to display byte values</summary>
		public CatFielddataDescriptor Bytes(Bytes? bytes) => Qs("bytes", bytes);
		///<summary>a short version of the Accept header, e.g. json, yaml</summary>
		public CatFielddataDescriptor Format(string format) => Qs("format", format);
		///<summary>Comma-separated list of column names to display</summary>
		public CatFielddataDescriptor Headers(params string[] headers) => Qs("h", headers);
		///<summary>Return help information</summary>
		public CatFielddataDescriptor Help(bool? help = true) => Qs("help", help);
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public CatFielddataDescriptor Local(bool? local = true) => Qs("local", local);
		///<summary>Explicit operation timeout for connection to master node</summary>
		public CatFielddataDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Comma-separated list of column names or column aliases to sort by</summary>
		public CatFielddataDescriptor SortByColumns(params string[] sortByColumns) => Qs("s", sortByColumns);
		///<summary>Verbose mode. Display column headers</summary>
		public CatFielddataDescriptor Verbose(bool? verbose = true) => Qs("v", verbose);
	}

	///<summary>descriptor for Health <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-health.html</pre></summary>
	public partial class CatHealthDescriptor : RequestDescriptorBase<CatHealthDescriptor, CatHealthRequestParameters, ICatHealthRequest>, ICatHealthRequest
	{
		internal override ApiUrls ApiUrls => CatHealthRequest.Urls;
		// values part of the url path
		// Request parameters
		///<summary>a short version of the Accept header, e.g. json, yaml</summary>
		public CatHealthDescriptor Format(string format) => Qs("format", format);
		///<summary>Comma-separated list of column names to display</summary>
		public CatHealthDescriptor Headers(params string[] headers) => Qs("h", headers);
		///<summary>Return help information</summary>
		public CatHealthDescriptor Help(bool? help = true) => Qs("help", help);
		///<summary>Set to false to disable timestamping</summary>
		public CatHealthDescriptor IncludeTimestamp(bool? includeTimestamp = true) => Qs("ts", includeTimestamp);
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public CatHealthDescriptor Local(bool? local = true) => Qs("local", local);
		///<summary>Explicit operation timeout for connection to master node</summary>
		public CatHealthDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Comma-separated list of column names or column aliases to sort by</summary>
		public CatHealthDescriptor SortByColumns(params string[] sortByColumns) => Qs("s", sortByColumns);
		///<summary>Verbose mode. Display column headers</summary>
		public CatHealthDescriptor Verbose(bool? verbose = true) => Qs("v", verbose);
	}

	///<summary>descriptor for Help <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat.html</pre></summary>
	public partial class CatHelpDescriptor : RequestDescriptorBase<CatHelpDescriptor, CatHelpRequestParameters, ICatHelpRequest>, ICatHelpRequest
	{
		internal override ApiUrls ApiUrls => CatHelpRequest.Urls;
		// values part of the url path
		// Request parameters
		///<summary>Return help information</summary>
		public CatHelpDescriptor Help(bool? help = true) => Qs("help", help);
		///<summary>Comma-separated list of column names or column aliases to sort by</summary>
		public CatHelpDescriptor SortByColumns(params string[] sortByColumns) => Qs("s", sortByColumns);
	}

	///<summary>descriptor for Indices <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-indices.html</pre></summary>
	public partial class CatIndicesDescriptor : RequestDescriptorBase<CatIndicesDescriptor, CatIndicesRequestParameters, ICatIndicesRequest>, ICatIndicesRequest
	{
		internal override ApiUrls ApiUrls => CatIndicesRequest.Urls;
		///<summary>/_cat/indices</summary>
		public CatIndicesDescriptor(): base()
		{
		}

		///<summary>/_cat/indices/{index}</summary>
		///<param name = "index">Optional, accepts null</param>
		public CatIndicesDescriptor(Indices index): base(r => r.Optional("index", index))
		{
		}

		// values part of the url path
		Indices ICatIndicesRequest.Index => Self.RouteValues.Get<Indices>("index");
		///<summary>A comma-separated list of index names to limit the returned information</summary>
		public CatIndicesDescriptor Index(Indices index) => Assign(index, (a, v) => a.RouteValues.Optional("index", v));
		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public CatIndicesDescriptor Index<TOther>()
			where TOther : class => Assign(typeof(TOther), (a, v) => a.RouteValues.Optional("index", (Indices)v));
		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public CatIndicesDescriptor AllIndices() => this.Index(Indices.All);
		// Request parameters
		///<summary>The unit in which to display byte values</summary>
		public CatIndicesDescriptor Bytes(Bytes? bytes) => Qs("bytes", bytes);
		///<summary>a short version of the Accept header, e.g. json, yaml</summary>
		public CatIndicesDescriptor Format(string format) => Qs("format", format);
		///<summary>Comma-separated list of column names to display</summary>
		public CatIndicesDescriptor Headers(params string[] headers) => Qs("h", headers);
		///<summary>A health status ("green", "yellow", or "red" to filter only indices matching the specified health status</summary>
		public CatIndicesDescriptor Health(Health? health) => Qs("health", health);
		///<summary>Return help information</summary>
		public CatIndicesDescriptor Help(bool? help = true) => Qs("help", help);
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public CatIndicesDescriptor Local(bool? local = true) => Qs("local", local);
		///<summary>Explicit operation timeout for connection to master node</summary>
		public CatIndicesDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Set to true to return stats only for primary shards</summary>
		public CatIndicesDescriptor Pri(bool? pri = true) => Qs("pri", pri);
		///<summary>Comma-separated list of column names or column aliases to sort by</summary>
		public CatIndicesDescriptor SortByColumns(params string[] sortByColumns) => Qs("s", sortByColumns);
		///<summary>Verbose mode. Display column headers</summary>
		public CatIndicesDescriptor Verbose(bool? verbose = true) => Qs("v", verbose);
	}

	///<summary>descriptor for Master <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-master.html</pre></summary>
	public partial class CatMasterDescriptor : RequestDescriptorBase<CatMasterDescriptor, CatMasterRequestParameters, ICatMasterRequest>, ICatMasterRequest
	{
		internal override ApiUrls ApiUrls => CatMasterRequest.Urls;
		// values part of the url path
		// Request parameters
		///<summary>a short version of the Accept header, e.g. json, yaml</summary>
		public CatMasterDescriptor Format(string format) => Qs("format", format);
		///<summary>Comma-separated list of column names to display</summary>
		public CatMasterDescriptor Headers(params string[] headers) => Qs("h", headers);
		///<summary>Return help information</summary>
		public CatMasterDescriptor Help(bool? help = true) => Qs("help", help);
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public CatMasterDescriptor Local(bool? local = true) => Qs("local", local);
		///<summary>Explicit operation timeout for connection to master node</summary>
		public CatMasterDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Comma-separated list of column names or column aliases to sort by</summary>
		public CatMasterDescriptor SortByColumns(params string[] sortByColumns) => Qs("s", sortByColumns);
		///<summary>Verbose mode. Display column headers</summary>
		public CatMasterDescriptor Verbose(bool? verbose = true) => Qs("v", verbose);
	}

	///<summary>descriptor for NodeAttributes <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-nodeattrs.html</pre></summary>
	public partial class CatNodeAttributesDescriptor : RequestDescriptorBase<CatNodeAttributesDescriptor, CatNodeAttributesRequestParameters, ICatNodeAttributesRequest>, ICatNodeAttributesRequest
	{
		internal override ApiUrls ApiUrls => CatNodeAttributesRequest.Urls;
		// values part of the url path
		// Request parameters
		///<summary>a short version of the Accept header, e.g. json, yaml</summary>
		public CatNodeAttributesDescriptor Format(string format) => Qs("format", format);
		///<summary>Comma-separated list of column names to display</summary>
		public CatNodeAttributesDescriptor Headers(params string[] headers) => Qs("h", headers);
		///<summary>Return help information</summary>
		public CatNodeAttributesDescriptor Help(bool? help = true) => Qs("help", help);
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public CatNodeAttributesDescriptor Local(bool? local = true) => Qs("local", local);
		///<summary>Explicit operation timeout for connection to master node</summary>
		public CatNodeAttributesDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Comma-separated list of column names or column aliases to sort by</summary>
		public CatNodeAttributesDescriptor SortByColumns(params string[] sortByColumns) => Qs("s", sortByColumns);
		///<summary>Verbose mode. Display column headers</summary>
		public CatNodeAttributesDescriptor Verbose(bool? verbose = true) => Qs("v", verbose);
	}

	///<summary>descriptor for Nodes <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-nodes.html</pre></summary>
	public partial class CatNodesDescriptor : RequestDescriptorBase<CatNodesDescriptor, CatNodesRequestParameters, ICatNodesRequest>, ICatNodesRequest
	{
		internal override ApiUrls ApiUrls => CatNodesRequest.Urls;
		// values part of the url path
		// Request parameters
		///<summary>a short version of the Accept header, e.g. json, yaml</summary>
		public CatNodesDescriptor Format(string format) => Qs("format", format);
		///<summary>Return the full node ID instead of the shortened version (default: false)</summary>
		public CatNodesDescriptor FullId(bool? fullId = true) => Qs("full_id", fullId);
		///<summary>Comma-separated list of column names to display</summary>
		public CatNodesDescriptor Headers(params string[] headers) => Qs("h", headers);
		///<summary>Return help information</summary>
		public CatNodesDescriptor Help(bool? help = true) => Qs("help", help);
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public CatNodesDescriptor Local(bool? local = true) => Qs("local", local);
		///<summary>Explicit operation timeout for connection to master node</summary>
		public CatNodesDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Comma-separated list of column names or column aliases to sort by</summary>
		public CatNodesDescriptor SortByColumns(params string[] sortByColumns) => Qs("s", sortByColumns);
		///<summary>Verbose mode. Display column headers</summary>
		public CatNodesDescriptor Verbose(bool? verbose = true) => Qs("v", verbose);
	}

	///<summary>descriptor for PendingTasks <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-pending-tasks.html</pre></summary>
	public partial class CatPendingTasksDescriptor : RequestDescriptorBase<CatPendingTasksDescriptor, CatPendingTasksRequestParameters, ICatPendingTasksRequest>, ICatPendingTasksRequest
	{
		internal override ApiUrls ApiUrls => CatPendingTasksRequest.Urls;
		// values part of the url path
		// Request parameters
		///<summary>a short version of the Accept header, e.g. json, yaml</summary>
		public CatPendingTasksDescriptor Format(string format) => Qs("format", format);
		///<summary>Comma-separated list of column names to display</summary>
		public CatPendingTasksDescriptor Headers(params string[] headers) => Qs("h", headers);
		///<summary>Return help information</summary>
		public CatPendingTasksDescriptor Help(bool? help = true) => Qs("help", help);
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public CatPendingTasksDescriptor Local(bool? local = true) => Qs("local", local);
		///<summary>Explicit operation timeout for connection to master node</summary>
		public CatPendingTasksDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Comma-separated list of column names or column aliases to sort by</summary>
		public CatPendingTasksDescriptor SortByColumns(params string[] sortByColumns) => Qs("s", sortByColumns);
		///<summary>Verbose mode. Display column headers</summary>
		public CatPendingTasksDescriptor Verbose(bool? verbose = true) => Qs("v", verbose);
	}

	///<summary>descriptor for Plugins <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-plugins.html</pre></summary>
	public partial class CatPluginsDescriptor : RequestDescriptorBase<CatPluginsDescriptor, CatPluginsRequestParameters, ICatPluginsRequest>, ICatPluginsRequest
	{
		internal override ApiUrls ApiUrls => CatPluginsRequest.Urls;
		// values part of the url path
		// Request parameters
		///<summary>a short version of the Accept header, e.g. json, yaml</summary>
		public CatPluginsDescriptor Format(string format) => Qs("format", format);
		///<summary>Comma-separated list of column names to display</summary>
		public CatPluginsDescriptor Headers(params string[] headers) => Qs("h", headers);
		///<summary>Return help information</summary>
		public CatPluginsDescriptor Help(bool? help = true) => Qs("help", help);
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public CatPluginsDescriptor Local(bool? local = true) => Qs("local", local);
		///<summary>Explicit operation timeout for connection to master node</summary>
		public CatPluginsDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Comma-separated list of column names or column aliases to sort by</summary>
		public CatPluginsDescriptor SortByColumns(params string[] sortByColumns) => Qs("s", sortByColumns);
		///<summary>Verbose mode. Display column headers</summary>
		public CatPluginsDescriptor Verbose(bool? verbose = true) => Qs("v", verbose);
	}

	///<summary>descriptor for Recovery <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-recovery.html</pre></summary>
	public partial class CatRecoveryDescriptor : RequestDescriptorBase<CatRecoveryDescriptor, CatRecoveryRequestParameters, ICatRecoveryRequest>, ICatRecoveryRequest
	{
		internal override ApiUrls ApiUrls => CatRecoveryRequest.Urls;
		///<summary>/_cat/recovery</summary>
		public CatRecoveryDescriptor(): base()
		{
		}

		///<summary>/_cat/recovery/{index}</summary>
		///<param name = "index">Optional, accepts null</param>
		public CatRecoveryDescriptor(Indices index): base(r => r.Optional("index", index))
		{
		}

		// values part of the url path
		Indices ICatRecoveryRequest.Index => Self.RouteValues.Get<Indices>("index");
		///<summary>A comma-separated list of index names to limit the returned information</summary>
		public CatRecoveryDescriptor Index(Indices index) => Assign(index, (a, v) => a.RouteValues.Optional("index", v));
		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public CatRecoveryDescriptor Index<TOther>()
			where TOther : class => Assign(typeof(TOther), (a, v) => a.RouteValues.Optional("index", (Indices)v));
		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public CatRecoveryDescriptor AllIndices() => this.Index(Indices.All);
		// Request parameters
		///<summary>The unit in which to display byte values</summary>
		public CatRecoveryDescriptor Bytes(Bytes? bytes) => Qs("bytes", bytes);
		///<summary>a short version of the Accept header, e.g. json, yaml</summary>
		public CatRecoveryDescriptor Format(string format) => Qs("format", format);
		///<summary>Comma-separated list of column names to display</summary>
		public CatRecoveryDescriptor Headers(params string[] headers) => Qs("h", headers);
		///<summary>Return help information</summary>
		public CatRecoveryDescriptor Help(bool? help = true) => Qs("help", help);
		///<summary>Explicit operation timeout for connection to master node</summary>
		public CatRecoveryDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Comma-separated list of column names or column aliases to sort by</summary>
		public CatRecoveryDescriptor SortByColumns(params string[] sortByColumns) => Qs("s", sortByColumns);
		///<summary>Verbose mode. Display column headers</summary>
		public CatRecoveryDescriptor Verbose(bool? verbose = true) => Qs("v", verbose);
	}

	///<summary>descriptor for Repositories <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-repositories.html</pre></summary>
	public partial class CatRepositoriesDescriptor : RequestDescriptorBase<CatRepositoriesDescriptor, CatRepositoriesRequestParameters, ICatRepositoriesRequest>, ICatRepositoriesRequest
	{
		internal override ApiUrls ApiUrls => CatRepositoriesRequest.Urls;
		// values part of the url path
		// Request parameters
		///<summary>a short version of the Accept header, e.g. json, yaml</summary>
		public CatRepositoriesDescriptor Format(string format) => Qs("format", format);
		///<summary>Comma-separated list of column names to display</summary>
		public CatRepositoriesDescriptor Headers(params string[] headers) => Qs("h", headers);
		///<summary>Return help information</summary>
		public CatRepositoriesDescriptor Help(bool? help = true) => Qs("help", help);
		///<summary>Return local information, do not retrieve the state from master node</summary>
		public CatRepositoriesDescriptor Local(bool? local = true) => Qs("local", local);
		///<summary>Explicit operation timeout for connection to master node</summary>
		public CatRepositoriesDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Comma-separated list of column names or column aliases to sort by</summary>
		public CatRepositoriesDescriptor SortByColumns(params string[] sortByColumns) => Qs("s", sortByColumns);
		///<summary>Verbose mode. Display column headers</summary>
		public CatRepositoriesDescriptor Verbose(bool? verbose = true) => Qs("v", verbose);
	}

	///<summary>descriptor for Segments <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-segments.html</pre></summary>
	public partial class CatSegmentsDescriptor : RequestDescriptorBase<CatSegmentsDescriptor, CatSegmentsRequestParameters, ICatSegmentsRequest>, ICatSegmentsRequest
	{
		internal override ApiUrls ApiUrls => CatSegmentsRequest.Urls;
		///<summary>/_cat/segments</summary>
		public CatSegmentsDescriptor(): base()
		{
		}

		///<summary>/_cat/segments/{index}</summary>
		///<param name = "index">Optional, accepts null</param>
		public CatSegmentsDescriptor(Indices index): base(r => r.Optional("index", index))
		{
		}

		// values part of the url path
		Indices ICatSegmentsRequest.Index => Self.RouteValues.Get<Indices>("index");
		///<summary>A comma-separated list of index names to limit the returned information</summary>
		public CatSegmentsDescriptor Index(Indices index) => Assign(index, (a, v) => a.RouteValues.Optional("index", v));
		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public CatSegmentsDescriptor Index<TOther>()
			where TOther : class => Assign(typeof(TOther), (a, v) => a.RouteValues.Optional("index", (Indices)v));
		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public CatSegmentsDescriptor AllIndices() => this.Index(Indices.All);
		// Request parameters
		///<summary>The unit in which to display byte values</summary>
		public CatSegmentsDescriptor Bytes(Bytes? bytes) => Qs("bytes", bytes);
		///<summary>a short version of the Accept header, e.g. json, yaml</summary>
		public CatSegmentsDescriptor Format(string format) => Qs("format", format);
		///<summary>Comma-separated list of column names to display</summary>
		public CatSegmentsDescriptor Headers(params string[] headers) => Qs("h", headers);
		///<summary>Return help information</summary>
		public CatSegmentsDescriptor Help(bool? help = true) => Qs("help", help);
		///<summary>Comma-separated list of column names or column aliases to sort by</summary>
		public CatSegmentsDescriptor SortByColumns(params string[] sortByColumns) => Qs("s", sortByColumns);
		///<summary>Verbose mode. Display column headers</summary>
		public CatSegmentsDescriptor Verbose(bool? verbose = true) => Qs("v", verbose);
	}

	///<summary>descriptor for Shards <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-shards.html</pre></summary>
	public partial class CatShardsDescriptor : RequestDescriptorBase<CatShardsDescriptor, CatShardsRequestParameters, ICatShardsRequest>, ICatShardsRequest
	{
		internal override ApiUrls ApiUrls => CatShardsRequest.Urls;
		///<summary>/_cat/shards</summary>
		public CatShardsDescriptor(): base()
		{
		}

		///<summary>/_cat/shards/{index}</summary>
		///<param name = "index">Optional, accepts null</param>
		public CatShardsDescriptor(Indices index): base(r => r.Optional("index", index))
		{
		}

		// values part of the url path
		Indices ICatShardsRequest.Index => Self.RouteValues.Get<Indices>("index");
		///<summary>A comma-separated list of index names to limit the returned information</summary>
		public CatShardsDescriptor Index(Indices index) => Assign(index, (a, v) => a.RouteValues.Optional("index", v));
		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public CatShardsDescriptor Index<TOther>()
			where TOther : class => Assign(typeof(TOther), (a, v) => a.RouteValues.Optional("index", (Indices)v));
		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public CatShardsDescriptor AllIndices() => this.Index(Indices.All);
		// Request parameters
		///<summary>The unit in which to display byte values</summary>
		public CatShardsDescriptor Bytes(Bytes? bytes) => Qs("bytes", bytes);
		///<summary>a short version of the Accept header, e.g. json, yaml</summary>
		public CatShardsDescriptor Format(string format) => Qs("format", format);
		///<summary>Comma-separated list of column names to display</summary>
		public CatShardsDescriptor Headers(params string[] headers) => Qs("h", headers);
		///<summary>Return help information</summary>
		public CatShardsDescriptor Help(bool? help = true) => Qs("help", help);
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public CatShardsDescriptor Local(bool? local = true) => Qs("local", local);
		///<summary>Explicit operation timeout for connection to master node</summary>
		public CatShardsDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Comma-separated list of column names or column aliases to sort by</summary>
		public CatShardsDescriptor SortByColumns(params string[] sortByColumns) => Qs("s", sortByColumns);
		///<summary>Verbose mode. Display column headers</summary>
		public CatShardsDescriptor Verbose(bool? verbose = true) => Qs("v", verbose);
	}

	///<summary>descriptor for Snapshots <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-snapshots.html</pre></summary>
	public partial class CatSnapshotsDescriptor : RequestDescriptorBase<CatSnapshotsDescriptor, CatSnapshotsRequestParameters, ICatSnapshotsRequest>, ICatSnapshotsRequest
	{
		internal override ApiUrls ApiUrls => CatSnapshotsRequest.Urls;
		///<summary>/_cat/snapshots</summary>
		public CatSnapshotsDescriptor(): base()
		{
		}

		///<summary>/_cat/snapshots/{repository}</summary>
		///<param name = "repository">Optional, accepts null</param>
		public CatSnapshotsDescriptor(Names repository): base(r => r.Optional("repository", repository))
		{
		}

		// values part of the url path
		Names ICatSnapshotsRequest.RepositoryName => Self.RouteValues.Get<Names>("repository");
		///<summary>Name of repository from which to fetch the snapshot information</summary>
		public CatSnapshotsDescriptor RepositoryName(Names repository) => Assign(repository, (a, v) => a.RouteValues.Optional("repository", v));
		// Request parameters
		///<summary>a short version of the Accept header, e.g. json, yaml</summary>
		public CatSnapshotsDescriptor Format(string format) => Qs("format", format);
		///<summary>Comma-separated list of column names to display</summary>
		public CatSnapshotsDescriptor Headers(params string[] headers) => Qs("h", headers);
		///<summary>Return help information</summary>
		public CatSnapshotsDescriptor Help(bool? help = true) => Qs("help", help);
		///<summary>Set to true to ignore unavailable snapshots</summary>
		public CatSnapshotsDescriptor IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
		///<summary>Explicit operation timeout for connection to master node</summary>
		public CatSnapshotsDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Comma-separated list of column names or column aliases to sort by</summary>
		public CatSnapshotsDescriptor SortByColumns(params string[] sortByColumns) => Qs("s", sortByColumns);
		///<summary>Verbose mode. Display column headers</summary>
		public CatSnapshotsDescriptor Verbose(bool? verbose = true) => Qs("v", verbose);
	}

	///<summary>descriptor for Tasks <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/tasks.html</pre></summary>
	public partial class CatTasksDescriptor : RequestDescriptorBase<CatTasksDescriptor, CatTasksRequestParameters, ICatTasksRequest>, ICatTasksRequest
	{
		internal override ApiUrls ApiUrls => CatTasksRequest.Urls;
		// values part of the url path
		// Request parameters
		///<summary>A comma-separated list of actions that should be returned. Leave empty to return all.</summary>
		public CatTasksDescriptor Actions(params string[] actions) => Qs("actions", actions);
		///<summary>Return detailed task information (default: false)</summary>
		public CatTasksDescriptor Detailed(bool? detailed = true) => Qs("detailed", detailed);
		///<summary>a short version of the Accept header, e.g. json, yaml</summary>
		public CatTasksDescriptor Format(string format) => Qs("format", format);
		///<summary>Comma-separated list of column names to display</summary>
		public CatTasksDescriptor Headers(params string[] headers) => Qs("h", headers);
		///<summary>Return help information</summary>
		public CatTasksDescriptor Help(bool? help = true) => Qs("help", help);
		///<summary>A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes</summary>
		public CatTasksDescriptor NodeId(params string[] nodeId) => Qs("node_id", nodeId);
		///<summary>Return tasks with specified parent task id. Set to -1 to return all.</summary>
		public CatTasksDescriptor ParentTask(long? parentTask) => Qs("parent_task", parentTask);
		///<summary>Comma-separated list of column names or column aliases to sort by</summary>
		public CatTasksDescriptor SortByColumns(params string[] sortByColumns) => Qs("s", sortByColumns);
		///<summary>Verbose mode. Display column headers</summary>
		public CatTasksDescriptor Verbose(bool? verbose = true) => Qs("v", verbose);
	}

	///<summary>descriptor for Templates <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-templates.html</pre></summary>
	public partial class CatTemplatesDescriptor : RequestDescriptorBase<CatTemplatesDescriptor, CatTemplatesRequestParameters, ICatTemplatesRequest>, ICatTemplatesRequest
	{
		internal override ApiUrls ApiUrls => CatTemplatesRequest.Urls;
		///<summary>/_cat/templates</summary>
		public CatTemplatesDescriptor(): base()
		{
		}

		///<summary>/_cat/templates/{name}</summary>
		///<param name = "name">Optional, accepts null</param>
		public CatTemplatesDescriptor(Name name): base(r => r.Optional("name", name))
		{
		}

		// values part of the url path
		Name ICatTemplatesRequest.Name => Self.RouteValues.Get<Name>("name");
		///<summary>A pattern that returned template names must match</summary>
		public CatTemplatesDescriptor Name(Name name) => Assign(name, (a, v) => a.RouteValues.Optional("name", v));
		// Request parameters
		///<summary>a short version of the Accept header, e.g. json, yaml</summary>
		public CatTemplatesDescriptor Format(string format) => Qs("format", format);
		///<summary>Comma-separated list of column names to display</summary>
		public CatTemplatesDescriptor Headers(params string[] headers) => Qs("h", headers);
		///<summary>Return help information</summary>
		public CatTemplatesDescriptor Help(bool? help = true) => Qs("help", help);
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public CatTemplatesDescriptor Local(bool? local = true) => Qs("local", local);
		///<summary>Explicit operation timeout for connection to master node</summary>
		public CatTemplatesDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Comma-separated list of column names or column aliases to sort by</summary>
		public CatTemplatesDescriptor SortByColumns(params string[] sortByColumns) => Qs("s", sortByColumns);
		///<summary>Verbose mode. Display column headers</summary>
		public CatTemplatesDescriptor Verbose(bool? verbose = true) => Qs("v", verbose);
	}

	///<summary>descriptor for ThreadPool <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-thread-pool.html</pre></summary>
	public partial class CatThreadPoolDescriptor : RequestDescriptorBase<CatThreadPoolDescriptor, CatThreadPoolRequestParameters, ICatThreadPoolRequest>, ICatThreadPoolRequest
	{
		internal override ApiUrls ApiUrls => CatThreadPoolRequest.Urls;
		///<summary>/_cat/thread_pool</summary>
		public CatThreadPoolDescriptor(): base()
		{
		}

		///<summary>/_cat/thread_pool/{thread_pool_patterns}</summary>
		///<param name = "thread_pool_patterns">Optional, accepts null</param>
		public CatThreadPoolDescriptor(Names thread_pool_patterns): base(r => r.Optional("thread_pool_patterns", thread_pool_patterns))
		{
		}

		// values part of the url path
		Names ICatThreadPoolRequest.ThreadPoolPatterns => Self.RouteValues.Get<Names>("thread_pool_patterns");
		///<summary>A comma-separated list of regular-expressions to filter the thread pools in the output</summary>
		public CatThreadPoolDescriptor ThreadPoolPatterns(Names threadPoolPatterns) => Assign(threadPoolPatterns, (a, v) => a.RouteValues.Optional("thread_pool_patterns", v));
		// Request parameters
		///<summary>a short version of the Accept header, e.g. json, yaml</summary>
		public CatThreadPoolDescriptor Format(string format) => Qs("format", format);
		///<summary>Comma-separated list of column names to display</summary>
		public CatThreadPoolDescriptor Headers(params string[] headers) => Qs("h", headers);
		///<summary>Return help information</summary>
		public CatThreadPoolDescriptor Help(bool? help = true) => Qs("help", help);
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public CatThreadPoolDescriptor Local(bool? local = true) => Qs("local", local);
		///<summary>Explicit operation timeout for connection to master node</summary>
		public CatThreadPoolDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>The multiplier in which to display values</summary>
		public CatThreadPoolDescriptor Size(Size? size) => Qs("size", size);
		///<summary>Comma-separated list of column names or column aliases to sort by</summary>
		public CatThreadPoolDescriptor SortByColumns(params string[] sortByColumns) => Qs("s", sortByColumns);
		///<summary>Verbose mode. Display column headers</summary>
		public CatThreadPoolDescriptor Verbose(bool? verbose = true) => Qs("v", verbose);
	}

	///<summary>descriptor for DeleteAutoFollowPattern <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/ccr-delete-auto-follow-pattern.html</pre></summary>
	public partial class DeleteAutoFollowPatternDescriptor : RequestDescriptorBase<DeleteAutoFollowPatternDescriptor, DeleteAutoFollowPatternRequestParameters, IDeleteAutoFollowPatternRequest>, IDeleteAutoFollowPatternRequest
	{
		internal override ApiUrls ApiUrls => DeleteAutoFollowPatternRequest.Urls;
		///<summary>/_ccr/auto_follow/{name}</summary>
		///<param name = "name">this parameter is required</param>
		public DeleteAutoFollowPatternDescriptor(Name name): base(r => r.Required("name", name))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal DeleteAutoFollowPatternDescriptor(): base()
		{
		}

		// values part of the url path
		Name IDeleteAutoFollowPatternRequest.Name => Self.RouteValues.Get<Name>("name");
	// Request parameters
	}

	///<summary>descriptor for CreateFollowIndex <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/ccr-put-follow.html</pre></summary>
	public partial class CreateFollowIndexDescriptor : RequestDescriptorBase<CreateFollowIndexDescriptor, CreateFollowIndexRequestParameters, ICreateFollowIndexRequest>, ICreateFollowIndexRequest
	{
		internal override ApiUrls ApiUrls => CreateFollowIndexRequest.Urls;
		///<summary>/{index}/_ccr/follow</summary>
		///<param name = "index">this parameter is required</param>
		public CreateFollowIndexDescriptor(IndexName index): base(r => r.Required("index", index))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal CreateFollowIndexDescriptor(): base()
		{
		}

		// values part of the url path
		IndexName ICreateFollowIndexRequest.Index => Self.RouteValues.Get<IndexName>("index");
		///<summary>The name of the follower index</summary>
		public CreateFollowIndexDescriptor Index(IndexName index) => Assign(index, (a, v) => a.RouteValues.Required("index", v));
		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public CreateFollowIndexDescriptor Index<TOther>()
			where TOther : class => Assign(typeof(TOther), (a, v) => a.RouteValues.Required("index", (IndexName)v));
		// Request parameters
		///<summary>Sets the number of shard copies that must be active before returning. Defaults to 0. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1)</summary>
		public CreateFollowIndexDescriptor WaitForActiveShards(string waitForActiveShards) => Qs("wait_for_active_shards", waitForActiveShards);
	}

	///<summary>descriptor for FollowIndexStats <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/ccr-get-follow-stats.html</pre></summary>
	public partial class FollowIndexStatsDescriptor : RequestDescriptorBase<FollowIndexStatsDescriptor, FollowIndexStatsRequestParameters, IFollowIndexStatsRequest>, IFollowIndexStatsRequest
	{
		internal override ApiUrls ApiUrls => FollowIndexStatsRequest.Urls;
		///<summary>/{index}/_ccr/stats</summary>
		///<param name = "index">this parameter is required</param>
		public FollowIndexStatsDescriptor(Indices index): base(r => r.Required("index", index))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal FollowIndexStatsDescriptor(): base()
		{
		}

		// values part of the url path
		Indices IFollowIndexStatsRequest.Index => Self.RouteValues.Get<Indices>("index");
		///<summary>A comma-separated list of index patterns; use `_all` to perform the operation on all indices</summary>
		public FollowIndexStatsDescriptor Index(Indices index) => Assign(index, (a, v) => a.RouteValues.Required("index", v));
		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public FollowIndexStatsDescriptor Index<TOther>()
			where TOther : class => Assign(typeof(TOther), (a, v) => a.RouteValues.Required("index", (Indices)v));
		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public FollowIndexStatsDescriptor AllIndices() => this.Index(Indices.All);
	// Request parameters
	}

	///<summary>descriptor for GetAutoFollowPattern <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/ccr-get-auto-follow-pattern.html</pre></summary>
	public partial class GetAutoFollowPatternDescriptor : RequestDescriptorBase<GetAutoFollowPatternDescriptor, GetAutoFollowPatternRequestParameters, IGetAutoFollowPatternRequest>, IGetAutoFollowPatternRequest
	{
		internal override ApiUrls ApiUrls => GetAutoFollowPatternRequest.Urls;
		///<summary>/_ccr/auto_follow</summary>
		public GetAutoFollowPatternDescriptor(): base()
		{
		}

		///<summary>/_ccr/auto_follow/{name}</summary>
		///<param name = "name">Optional, accepts null</param>
		public GetAutoFollowPatternDescriptor(Name name): base(r => r.Optional("name", name))
		{
		}

		// values part of the url path
		Name IGetAutoFollowPatternRequest.Name => Self.RouteValues.Get<Name>("name");
		///<summary>The name of the auto follow pattern.</summary>
		public GetAutoFollowPatternDescriptor Name(Name name) => Assign(name, (a, v) => a.RouteValues.Optional("name", v));
	// Request parameters
	}

	///<summary>descriptor for PauseFollowIndex <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/ccr-post-pause-follow.html</pre></summary>
	public partial class PauseFollowIndexDescriptor : RequestDescriptorBase<PauseFollowIndexDescriptor, PauseFollowIndexRequestParameters, IPauseFollowIndexRequest>, IPauseFollowIndexRequest
	{
		internal override ApiUrls ApiUrls => PauseFollowIndexRequest.Urls;
		///<summary>/{index}/_ccr/pause_follow</summary>
		///<param name = "index">this parameter is required</param>
		public PauseFollowIndexDescriptor(IndexName index): base(r => r.Required("index", index))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal PauseFollowIndexDescriptor(): base()
		{
		}

		// values part of the url path
		IndexName IPauseFollowIndexRequest.Index => Self.RouteValues.Get<IndexName>("index");
		///<summary>The name of the follower index that should pause following its leader index.</summary>
		public PauseFollowIndexDescriptor Index(IndexName index) => Assign(index, (a, v) => a.RouteValues.Required("index", v));
		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public PauseFollowIndexDescriptor Index<TOther>()
			where TOther : class => Assign(typeof(TOther), (a, v) => a.RouteValues.Required("index", (IndexName)v));
	// Request parameters
	}

	///<summary>descriptor for CreateAutoFollowPattern <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/ccr-put-auto-follow-pattern.html</pre></summary>
	public partial class CreateAutoFollowPatternDescriptor : RequestDescriptorBase<CreateAutoFollowPatternDescriptor, CreateAutoFollowPatternRequestParameters, ICreateAutoFollowPatternRequest>, ICreateAutoFollowPatternRequest
	{
		internal override ApiUrls ApiUrls => CreateAutoFollowPatternRequest.Urls;
		///<summary>/_ccr/auto_follow/{name}</summary>
		///<param name = "name">this parameter is required</param>
		public CreateAutoFollowPatternDescriptor(Name name): base(r => r.Required("name", name))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal CreateAutoFollowPatternDescriptor(): base()
		{
		}

		// values part of the url path
		Name ICreateAutoFollowPatternRequest.Name => Self.RouteValues.Get<Name>("name");
	// Request parameters
	}

	///<summary>descriptor for ResumeFollowIndex <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/ccr-post-resume-follow.html</pre></summary>
	public partial class ResumeFollowIndexDescriptor : RequestDescriptorBase<ResumeFollowIndexDescriptor, ResumeFollowIndexRequestParameters, IResumeFollowIndexRequest>, IResumeFollowIndexRequest
	{
		internal override ApiUrls ApiUrls => ResumeFollowIndexRequest.Urls;
		///<summary>/{index}/_ccr/resume_follow</summary>
		///<param name = "index">this parameter is required</param>
		public ResumeFollowIndexDescriptor(IndexName index): base(r => r.Required("index", index))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal ResumeFollowIndexDescriptor(): base()
		{
		}

		// values part of the url path
		IndexName IResumeFollowIndexRequest.Index => Self.RouteValues.Get<IndexName>("index");
		///<summary>The name of the follow index to resume following.</summary>
		public ResumeFollowIndexDescriptor Index(IndexName index) => Assign(index, (a, v) => a.RouteValues.Required("index", v));
		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public ResumeFollowIndexDescriptor Index<TOther>()
			where TOther : class => Assign(typeof(TOther), (a, v) => a.RouteValues.Required("index", (IndexName)v));
	// Request parameters
	}

	///<summary>descriptor for CcrStats <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/ccr-get-stats.html</pre></summary>
	public partial class CcrStatsDescriptor : RequestDescriptorBase<CcrStatsDescriptor, CcrStatsRequestParameters, ICcrStatsRequest>, ICcrStatsRequest
	{
		internal override ApiUrls ApiUrls => CcrStatsRequest.Urls;
	// values part of the url path
	// Request parameters
	}

	///<summary>descriptor for UnfollowIndex <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current</pre></summary>
	public partial class UnfollowIndexDescriptor : RequestDescriptorBase<UnfollowIndexDescriptor, UnfollowIndexRequestParameters, IUnfollowIndexRequest>, IUnfollowIndexRequest
	{
		internal override ApiUrls ApiUrls => UnfollowIndexRequest.Urls;
		///<summary>/{index}/_ccr/unfollow</summary>
		///<param name = "index">this parameter is required</param>
		public UnfollowIndexDescriptor(IndexName index): base(r => r.Required("index", index))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal UnfollowIndexDescriptor(): base()
		{
		}

		// values part of the url path
		IndexName IUnfollowIndexRequest.Index => Self.RouteValues.Get<IndexName>("index");
		///<summary>The name of the follower index that should be turned into a regular index.</summary>
		public UnfollowIndexDescriptor Index(IndexName index) => Assign(index, (a, v) => a.RouteValues.Required("index", v));
		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public UnfollowIndexDescriptor Index<TOther>()
			where TOther : class => Assign(typeof(TOther), (a, v) => a.RouteValues.Required("index", (IndexName)v));
	// Request parameters
	}

	///<summary>descriptor for ClearScroll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/search-request-scroll.html</pre></summary>
	public partial class ClearScrollDescriptor : RequestDescriptorBase<ClearScrollDescriptor, ClearScrollRequestParameters, IClearScrollRequest>, IClearScrollRequest
	{
		internal override ApiUrls ApiUrls => ClearScrollRequest.Urls;
	// values part of the url path
	// Request parameters
	}

	///<summary>descriptor for AllocationExplain <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-allocation-explain.html</pre></summary>
	public partial class ClusterAllocationExplainDescriptor : RequestDescriptorBase<ClusterAllocationExplainDescriptor, ClusterAllocationExplainRequestParameters, IClusterAllocationExplainRequest>, IClusterAllocationExplainRequest
	{
		internal override ApiUrls ApiUrls => ClusterAllocationExplainRequest.Urls;
		// values part of the url path
		// Request parameters
		///<summary>Return information about disk usage and shard sizes (default: false)</summary>
		public ClusterAllocationExplainDescriptor IncludeDiskInfo(bool? includeDiskInfo = true) => Qs("include_disk_info", includeDiskInfo);
		///<summary>Return 'YES' decisions in explanation (default: false)</summary>
		public ClusterAllocationExplainDescriptor IncludeYesDecisions(bool? includeYesDecisions = true) => Qs("include_yes_decisions", includeYesDecisions);
	}

	///<summary>descriptor for GetSettings <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-update-settings.html</pre></summary>
	public partial class ClusterGetSettingsDescriptor : RequestDescriptorBase<ClusterGetSettingsDescriptor, ClusterGetSettingsRequestParameters, IClusterGetSettingsRequest>, IClusterGetSettingsRequest
	{
		internal override ApiUrls ApiUrls => ClusterGetSettingsRequest.Urls;
		// values part of the url path
		// Request parameters
		///<summary>Return settings in flat format (default: false)</summary>
		public ClusterGetSettingsDescriptor FlatSettings(bool? flatSettings = true) => Qs("flat_settings", flatSettings);
		///<summary>Whether to return all default clusters setting.</summary>
		public ClusterGetSettingsDescriptor IncludeDefaults(bool? includeDefaults = true) => Qs("include_defaults", includeDefaults);
		///<summary>Explicit operation timeout for connection to master node</summary>
		public ClusterGetSettingsDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Explicit operation timeout</summary>
		public ClusterGetSettingsDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
	}

	///<summary>descriptor for Health <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-health.html</pre></summary>
	public partial class ClusterHealthDescriptor : RequestDescriptorBase<ClusterHealthDescriptor, ClusterHealthRequestParameters, IClusterHealthRequest>, IClusterHealthRequest
	{
		internal override ApiUrls ApiUrls => ClusterHealthRequest.Urls;
		///<summary>/_cluster/health</summary>
		public ClusterHealthDescriptor(): base()
		{
		}

		///<summary>/_cluster/health/{index}</summary>
		///<param name = "index">Optional, accepts null</param>
		public ClusterHealthDescriptor(Indices index): base(r => r.Optional("index", index))
		{
		}

		// values part of the url path
		Indices IClusterHealthRequest.Index => Self.RouteValues.Get<Indices>("index");
		///<summary>Limit the information returned to a specific index</summary>
		public ClusterHealthDescriptor Index(Indices index) => Assign(index, (a, v) => a.RouteValues.Optional("index", v));
		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public ClusterHealthDescriptor Index<TOther>()
			where TOther : class => Assign(typeof(TOther), (a, v) => a.RouteValues.Optional("index", (Indices)v));
		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public ClusterHealthDescriptor AllIndices() => this.Index(Indices.All);
		// Request parameters
		///<summary>Specify the level of detail for returned information</summary>
		public ClusterHealthDescriptor Level(Level? level) => Qs("level", level);
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public ClusterHealthDescriptor Local(bool? local = true) => Qs("local", local);
		///<summary>Explicit operation timeout for connection to master node</summary>
		public ClusterHealthDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Explicit operation timeout</summary>
		public ClusterHealthDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
		///<summary>Wait until the specified number of shards is active</summary>
		public ClusterHealthDescriptor WaitForActiveShards(string waitForActiveShards) => Qs("wait_for_active_shards", waitForActiveShards);
		///<summary>Wait until all currently queued events with the given priority are processed</summary>
		public ClusterHealthDescriptor WaitForEvents(WaitForEvents? waitForEvents) => Qs("wait_for_events", waitForEvents);
		///<summary>Whether to wait until there are no initializing shards in the cluster</summary>
		public ClusterHealthDescriptor WaitForNoInitializingShards(bool? waitForNoInitializingShards = true) => Qs("wait_for_no_initializing_shards", waitForNoInitializingShards);
		///<summary>Whether to wait until there are no relocating shards in the cluster</summary>
		public ClusterHealthDescriptor WaitForNoRelocatingShards(bool? waitForNoRelocatingShards = true) => Qs("wait_for_no_relocating_shards", waitForNoRelocatingShards);
		///<summary>Wait until the specified number of nodes is available</summary>
		public ClusterHealthDescriptor WaitForNodes(string waitForNodes) => Qs("wait_for_nodes", waitForNodes);
		///<summary>Wait until cluster is in a specific state</summary>
		public ClusterHealthDescriptor WaitForStatus(WaitForStatus? waitForStatus) => Qs("wait_for_status", waitForStatus);
	}

	///<summary>descriptor for PendingTasks <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-pending.html</pre></summary>
	public partial class ClusterPendingTasksDescriptor : RequestDescriptorBase<ClusterPendingTasksDescriptor, ClusterPendingTasksRequestParameters, IClusterPendingTasksRequest>, IClusterPendingTasksRequest
	{
		internal override ApiUrls ApiUrls => ClusterPendingTasksRequest.Urls;
		// values part of the url path
		// Request parameters
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public ClusterPendingTasksDescriptor Local(bool? local = true) => Qs("local", local);
		///<summary>Specify timeout for connection to master</summary>
		public ClusterPendingTasksDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
	}

	///<summary>descriptor for PutSettings <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-update-settings.html</pre></summary>
	public partial class ClusterPutSettingsDescriptor : RequestDescriptorBase<ClusterPutSettingsDescriptor, ClusterPutSettingsRequestParameters, IClusterPutSettingsRequest>, IClusterPutSettingsRequest
	{
		internal override ApiUrls ApiUrls => ClusterPutSettingsRequest.Urls;
		// values part of the url path
		// Request parameters
		///<summary>Return settings in flat format (default: false)</summary>
		public ClusterPutSettingsDescriptor FlatSettings(bool? flatSettings = true) => Qs("flat_settings", flatSettings);
		///<summary>Explicit operation timeout for connection to master node</summary>
		public ClusterPutSettingsDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Explicit operation timeout</summary>
		public ClusterPutSettingsDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
	}

	///<summary>descriptor for RemoteInfo <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-remote-info.html</pre></summary>
	public partial class RemoteInfoDescriptor : RequestDescriptorBase<RemoteInfoDescriptor, RemoteInfoRequestParameters, IRemoteInfoRequest>, IRemoteInfoRequest
	{
		internal override ApiUrls ApiUrls => RemoteInfoRequest.Urls;
	// values part of the url path
	// Request parameters
	}

	///<summary>descriptor for Reroute <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-reroute.html</pre></summary>
	public partial class ClusterRerouteDescriptor : RequestDescriptorBase<ClusterRerouteDescriptor, ClusterRerouteRequestParameters, IClusterRerouteRequest>, IClusterRerouteRequest
	{
		internal override ApiUrls ApiUrls => ClusterRerouteRequest.Urls;
		// values part of the url path
		// Request parameters
		///<summary>Simulate the operation only and return the resulting state</summary>
		public ClusterRerouteDescriptor DryRun(bool? dryRun = true) => Qs("dry_run", dryRun);
		///<summary>Return an explanation of why the commands can or cannot be executed</summary>
		public ClusterRerouteDescriptor Explain(bool? explain = true) => Qs("explain", explain);
		///<summary>Explicit operation timeout for connection to master node</summary>
		public ClusterRerouteDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Limit the information returned to the specified metrics. Defaults to all but metadata</summary>
		public ClusterRerouteDescriptor Metric(params string[] metric) => Qs("metric", metric);
		///<summary>Retries allocation of shards that are blocked due to too many subsequent allocation failures</summary>
		public ClusterRerouteDescriptor RetryFailed(bool? retryFailed = true) => Qs("retry_failed", retryFailed);
		///<summary>Explicit operation timeout</summary>
		public ClusterRerouteDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
	}

	///<summary>descriptor for State <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-state.html</pre></summary>
	public partial class ClusterStateDescriptor : RequestDescriptorBase<ClusterStateDescriptor, ClusterStateRequestParameters, IClusterStateRequest>, IClusterStateRequest
	{
		internal override ApiUrls ApiUrls => ClusterStateRequest.Urls;
		///<summary>/_cluster/state</summary>
		public ClusterStateDescriptor(): base()
		{
		}

		///<summary>/_cluster/state/{metric}</summary>
		///<param name = "metric">Optional, accepts null</param>
		public ClusterStateDescriptor(Metrics metric): base(r => r.Optional("metric", metric))
		{
		}

		///<summary>/_cluster/state/{metric}/{index}</summary>
		///<param name = "metric">Optional, accepts null</param>
		///<param name = "index">Optional, accepts null</param>
		public ClusterStateDescriptor(Metrics metric, Indices index): base(r => r.Optional("metric", metric).Optional("index", index))
		{
		}

		// values part of the url path
		Metrics IClusterStateRequest.Metric => Self.RouteValues.Get<Metrics>("metric");
		Indices IClusterStateRequest.Index => Self.RouteValues.Get<Indices>("index");
		///<summary>Limit the information returned to the specified metrics</summary>
		public ClusterStateDescriptor Metric(Metrics metric) => Assign(metric, (a, v) => a.RouteValues.Optional("metric", (Metrics)v));
		///<summary>A comma-separated list of index names; use the special string `_all` or Indices.All to perform the operation on all indices</summary>
		public ClusterStateDescriptor Index(Indices index) => Assign(index, (a, v) => a.RouteValues.Optional("index", v));
		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public ClusterStateDescriptor Index<TOther>()
			where TOther : class => Assign(typeof(TOther), (a, v) => a.RouteValues.Optional("index", (Indices)v));
		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public ClusterStateDescriptor AllIndices() => this.Index(Indices.All);
		// Request parameters
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public ClusterStateDescriptor AllowNoIndices(bool? allowNoIndices = true) => Qs("allow_no_indices", allowNoIndices);
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ClusterStateDescriptor ExpandWildcards(ExpandWildcards? expandWildcards) => Qs("expand_wildcards", expandWildcards);
		///<summary>Return settings in flat format (default: false)</summary>
		public ClusterStateDescriptor FlatSettings(bool? flatSettings = true) => Qs("flat_settings", flatSettings);
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public ClusterStateDescriptor IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public ClusterStateDescriptor Local(bool? local = true) => Qs("local", local);
		///<summary>Specify timeout for connection to master</summary>
		public ClusterStateDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Wait for the metadata version to be equal or greater than the specified metadata version</summary>
		public ClusterStateDescriptor WaitForMetadataVersion(long? waitForMetadataVersion) => Qs("wait_for_metadata_version", waitForMetadataVersion);
		///<summary>The maximum time to wait for wait_for_metadata_version before timing out</summary>
		public ClusterStateDescriptor WaitForTimeout(Time waitForTimeout) => Qs("wait_for_timeout", waitForTimeout);
	}

	///<summary>descriptor for Stats <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-stats.html</pre></summary>
	public partial class ClusterStatsDescriptor : RequestDescriptorBase<ClusterStatsDescriptor, ClusterStatsRequestParameters, IClusterStatsRequest>, IClusterStatsRequest
	{
		internal override ApiUrls ApiUrls => ClusterStatsRequest.Urls;
		///<summary>/_cluster/stats</summary>
		public ClusterStatsDescriptor(): base()
		{
		}

		///<summary>/_cluster/stats/nodes/{node_id}</summary>
		///<param name = "node_id">Optional, accepts null</param>
		public ClusterStatsDescriptor(NodeIds node_id): base(r => r.Optional("node_id", node_id))
		{
		}

		// values part of the url path
		NodeIds IClusterStatsRequest.NodeId => Self.RouteValues.Get<NodeIds>("node_id");
		///<summary>A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes</summary>
		public ClusterStatsDescriptor NodeId(NodeIds nodeId) => Assign(nodeId, (a, v) => a.RouteValues.Optional("node_id", v));
		// Request parameters
		///<summary>Return settings in flat format (default: false)</summary>
		public ClusterStatsDescriptor FlatSettings(bool? flatSettings = true) => Qs("flat_settings", flatSettings);
		///<summary>Explicit operation timeout</summary>
		public ClusterStatsDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
	}

	///<summary>descriptor for Count <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/search-count.html</pre></summary>
	public partial class CountDescriptor<T> : RequestDescriptorBase<CountDescriptor<T>, CountRequestParameters, ICountRequest<T>>, ICountRequest<T>
	{
		internal override ApiUrls ApiUrls => CountRequest.Urls;
		///<summary>/{index}/_count</summary>
		public CountDescriptor(): this(typeof(T))
		{
		}

		///<summary>/{index}/_count</summary>
		///<param name = "index">Optional, accepts null</param>
		public CountDescriptor(Indices index): base(r => r.Optional("index", index))
		{
		}

		// values part of the url path
		Indices ICountRequest.Index => Self.RouteValues.Get<Indices>("index");
		///<summary>A comma-separated list of indices to restrict the results</summary>
		public CountDescriptor<T> Index(Indices index) => Assign(index, (a, v) => a.RouteValues.Optional("index", v));
		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public CountDescriptor<T> Index<TOther>()
			where TOther : class => Assign(typeof(TOther), (a, v) => a.RouteValues.Optional("index", (Indices)v));
		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public CountDescriptor<T> AllIndices() => this.Index(Indices.All);
		// Request parameters
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public CountDescriptor<T> AllowNoIndices(bool? allowNoIndices = true) => Qs("allow_no_indices", allowNoIndices);
		///<summary>Specify whether wildcard and prefix queries should be analyzed (default: false)</summary>
		public CountDescriptor<T> AnalyzeWildcard(bool? analyzeWildcard = true) => Qs("analyze_wildcard", analyzeWildcard);
		///<summary>The analyzer to use for the query string</summary>
		public CountDescriptor<T> Analyzer(string analyzer) => Qs("analyzer", analyzer);
		///<summary>The default operator for query string query (AND or OR)</summary>
		public CountDescriptor<T> DefaultOperator(DefaultOperator? defaultOperator) => Qs("default_operator", defaultOperator);
		///<summary>The field to use as default where no field prefix is given in the query string</summary>
		public CountDescriptor<T> Df(string df) => Qs("df", df);
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public CountDescriptor<T> ExpandWildcards(ExpandWildcards? expandWildcards) => Qs("expand_wildcards", expandWildcards);
		///<summary>Whether specified concrete, expanded or aliased indices should be ignored when throttled</summary>
		public CountDescriptor<T> IgnoreThrottled(bool? ignoreThrottled = true) => Qs("ignore_throttled", ignoreThrottled);
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public CountDescriptor<T> IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
		///<summary>Specify whether format-based query failures (such as providing text to a numeric field) should be ignored</summary>
		public CountDescriptor<T> Lenient(bool? lenient = true) => Qs("lenient", lenient);
		///<summary>Include only documents with a specific `_score` value in the result</summary>
		public CountDescriptor<T> MinScore(double? minScore) => Qs("min_score", minScore);
		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public CountDescriptor<T> Preference(string preference) => Qs("preference", preference);
		///<summary>Query in the Lucene query string syntax</summary>
		public CountDescriptor<T> QueryOnQueryString(string queryOnQueryString) => Qs("q", queryOnQueryString);
		///<summary>
		/// A document is routed to a particular shard in an index using the following formula
		/// <para> shard_num = hash(_routing) % num_primary_shards</para>
		/// <para>Elasticsearch will use the document id if not provided. </para>
		/// <para>For requests that are constructed from/for a document NEST will automatically infer the routing key
		/// if that document has a <see cref = "Nest.JoinField"/> or a routing mapping on for its type exists on <see cref = "Nest.ConnectionSettings"/></para> 
		///</summary>
		public CountDescriptor<T> Routing(Routing routing) => Qs("routing", routing);
		///<summary>The maximum count for each shard, upon reaching which the query execution will terminate early</summary>
		public CountDescriptor<T> TerminateAfter(long? terminateAfter) => Qs("terminate_after", terminateAfter);
	}

	///<summary>descriptor for Create <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-index_.html</pre></summary>
	public partial class CreateDescriptor<TDocument> : RequestDescriptorBase<CreateDescriptor<TDocument>, CreateRequestParameters, ICreateRequest<TDocument>>, ICreateRequest<TDocument>
	{
		internal override ApiUrls ApiUrls => CreateRequest.Urls;
		///<summary>/{index}/_create/{id}</summary>
		///<param name = "index">this parameter is required</param>
		///<param name = "id">this parameter is required</param>
		public CreateDescriptor(IndexName index, Id id): base(r => r.Required("index", index).Required("id", id))
		{
		}

		///<summary>/{index}/_create/{id}</summary>
		///<param name = "id">this parameter is required</param>
		public CreateDescriptor(Id id): this(typeof(TDocument), id)
		{
		}

		///<summary>/{index}/_create/{id}</summary>
		///<param name = "id">The document used to resolve the path from</param>
		public CreateDescriptor(TDocument documentWithId, IndexName index = null, Id id = null): this(index ?? typeof(TDocument), id ?? Nest.Id.From(documentWithId)) => DocumentFromPath(documentWithId);
		partial void DocumentFromPath(TDocument document);
		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal CreateDescriptor(): base()
		{
		}

		// values part of the url path
		IndexName ICreateRequest.Index => Self.RouteValues.Get<IndexName>("index");
		Id ICreateRequest.Id => Self.RouteValues.Get<Id>("id");
		///<summary>The name of the index</summary>
		public CreateDescriptor<TDocument> Index(IndexName index) => Assign(index, (a, v) => a.RouteValues.Required("index", v));
		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public CreateDescriptor<TDocument> Index<TOther>()
			where TOther : class => Assign(typeof(TOther), (a, v) => a.RouteValues.Required("index", (IndexName)v));
		// Request parameters
		///<summary>The pipeline id to preprocess incoming documents with</summary>
		public CreateDescriptor<TDocument> Pipeline(string pipeline) => Qs("pipeline", pipeline);
		///<summary>If `true` then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` (the default) then do nothing with refreshes.</summary>
		public CreateDescriptor<TDocument> Refresh(Refresh? refresh) => Qs("refresh", refresh);
		///<summary>
		/// A document is routed to a particular shard in an index using the following formula
		/// <para> shard_num = hash(_routing) % num_primary_shards</para>
		/// <para>Elasticsearch will use the document id if not provided. </para>
		/// <para>For requests that are constructed from/for a document NEST will automatically infer the routing key
		/// if that document has a <see cref = "Nest.JoinField"/> or a routing mapping on for its type exists on <see cref = "Nest.ConnectionSettings"/></para> 
		///</summary>
		public CreateDescriptor<TDocument> Routing(Routing routing) => Qs("routing", routing);
		///<summary>Explicit operation timeout</summary>
		public CreateDescriptor<TDocument> Timeout(Time timeout) => Qs("timeout", timeout);
		///<summary>Explicit version number for concurrency control</summary>
		public CreateDescriptor<TDocument> Version(long? version) => Qs("version", version);
		///<summary>Specific version type</summary>
		public CreateDescriptor<TDocument> VersionType(VersionType? versionType) => Qs("version_type", versionType);
		///<summary>Sets the number of shard copies that must be active before proceeding with the index operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1)</summary>
		public CreateDescriptor<TDocument> WaitForActiveShards(string waitForActiveShards) => Qs("wait_for_active_shards", waitForActiveShards);
	}

	///<summary>descriptor for Delete <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-delete.html</pre></summary>
	public partial class DeleteDescriptor<TDocument> : RequestDescriptorBase<DeleteDescriptor<TDocument>, DeleteRequestParameters, IDeleteRequest<TDocument>>, IDeleteRequest<TDocument>
	{
		internal override ApiUrls ApiUrls => DeleteRequest.Urls;
		///<summary>/{index}/_doc/{id}</summary>
		///<param name = "index">this parameter is required</param>
		///<param name = "id">this parameter is required</param>
		public DeleteDescriptor(IndexName index, Id id): base(r => r.Required("index", index).Required("id", id))
		{
		}

		///<summary>/{index}/_doc/{id}</summary>
		///<param name = "id">this parameter is required</param>
		public DeleteDescriptor(Id id): this(typeof(TDocument), id)
		{
		}

		///<summary>/{index}/_doc/{id}</summary>
		///<param name = "id">The document used to resolve the path from</param>
		public DeleteDescriptor(TDocument documentWithId, IndexName index = null, Id id = null): this(index ?? typeof(TDocument), id ?? Nest.Id.From(documentWithId)) => DocumentFromPath(documentWithId);
		partial void DocumentFromPath(TDocument document);
		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal DeleteDescriptor(): base()
		{
		}

		// values part of the url path
		IndexName IDeleteRequest.Index => Self.RouteValues.Get<IndexName>("index");
		Id IDeleteRequest.Id => Self.RouteValues.Get<Id>("id");
		///<summary>The name of the index</summary>
		public DeleteDescriptor<TDocument> Index(IndexName index) => Assign(index, (a, v) => a.RouteValues.Required("index", v));
		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public DeleteDescriptor<TDocument> Index<TOther>()
			where TOther : class => Assign(typeof(TOther), (a, v) => a.RouteValues.Required("index", (IndexName)v));
		// Request parameters
		///<summary>only perform the delete operation if the last operation that has changed the document has the specified primary term</summary>
		public DeleteDescriptor<TDocument> IfPrimaryTerm(long? ifPrimaryTerm) => Qs("if_primary_term", ifPrimaryTerm);
		///<summary>only perform the delete operation if the last operation that has changed the document has the specified sequence number</summary>
		public DeleteDescriptor<TDocument> IfSequenceNumber(long? ifSequenceNumber) => Qs("if_seq_no", ifSequenceNumber);
		///<summary>If `true` then refresh the effected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` (the default) then do nothing with refreshes.</summary>
		public DeleteDescriptor<TDocument> Refresh(Refresh? refresh) => Qs("refresh", refresh);
		///<summary>
		/// A document is routed to a particular shard in an index using the following formula
		/// <para> shard_num = hash(_routing) % num_primary_shards</para>
		/// <para>Elasticsearch will use the document id if not provided. </para>
		/// <para>For requests that are constructed from/for a document NEST will automatically infer the routing key
		/// if that document has a <see cref = "Nest.JoinField"/> or a routing mapping on for its type exists on <see cref = "Nest.ConnectionSettings"/></para> 
		///</summary>
		public DeleteDescriptor<TDocument> Routing(Routing routing) => Qs("routing", routing);
		///<summary>Explicit operation timeout</summary>
		public DeleteDescriptor<TDocument> Timeout(Time timeout) => Qs("timeout", timeout);
		///<summary>Explicit version number for concurrency control</summary>
		public DeleteDescriptor<TDocument> Version(long? version) => Qs("version", version);
		///<summary>Specific version type</summary>
		public DeleteDescriptor<TDocument> VersionType(VersionType? versionType) => Qs("version_type", versionType);
		///<summary>Sets the number of shard copies that must be active before proceeding with the delete operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1)</summary>
		public DeleteDescriptor<TDocument> WaitForActiveShards(string waitForActiveShards) => Qs("wait_for_active_shards", waitForActiveShards);
	}

	///<summary>descriptor for DeleteByQuery <pre>https://www.elastic.co/guide/en/elasticsearch/reference/master/docs-delete-by-query.html</pre></summary>
	public partial class DeleteByQueryDescriptor<T> : RequestDescriptorBase<DeleteByQueryDescriptor<T>, DeleteByQueryRequestParameters, IDeleteByQueryRequest<T>>, IDeleteByQueryRequest<T>
	{
		internal override ApiUrls ApiUrls => DeleteByQueryRequest.Urls;
		///<summary>/{index}/_delete_by_query</summary>
		///<param name = "index">this parameter is required</param>
		public DeleteByQueryDescriptor(Indices index): base(r => r.Required("index", index))
		{
		}

		///<summary>/{index}/_delete_by_query</summary>
		public DeleteByQueryDescriptor(): this(typeof(T))
		{
		}

		// values part of the url path
		Indices IDeleteByQueryRequest.Index => Self.RouteValues.Get<Indices>("index");
		///<summary>A comma-separated list of index names to search; use the special string `_all` or Indices.All to perform the operation on all indices</summary>
		public DeleteByQueryDescriptor<T> Index(Indices index) => Assign(index, (a, v) => a.RouteValues.Required("index", v));
		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public DeleteByQueryDescriptor<T> Index<TOther>()
			where TOther : class => Assign(typeof(TOther), (a, v) => a.RouteValues.Required("index", (Indices)v));
		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public DeleteByQueryDescriptor<T> AllIndices() => this.Index(Indices.All);
		// Request parameters
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public DeleteByQueryDescriptor<T> AllowNoIndices(bool? allowNoIndices = true) => Qs("allow_no_indices", allowNoIndices);
		///<summary>Specify whether wildcard and prefix queries should be analyzed (default: false)</summary>
		public DeleteByQueryDescriptor<T> AnalyzeWildcard(bool? analyzeWildcard = true) => Qs("analyze_wildcard", analyzeWildcard);
		///<summary>The analyzer to use for the query string</summary>
		public DeleteByQueryDescriptor<T> Analyzer(string analyzer) => Qs("analyzer", analyzer);
		///<summary>What to do when the delete by query hits version conflicts?</summary>
		public DeleteByQueryDescriptor<T> Conflicts(Conflicts? conflicts) => Qs("conflicts", conflicts);
		///<summary>The default operator for query string query (AND or OR)</summary>
		public DeleteByQueryDescriptor<T> DefaultOperator(DefaultOperator? defaultOperator) => Qs("default_operator", defaultOperator);
		///<summary>The field to use as default where no field prefix is given in the query string</summary>
		public DeleteByQueryDescriptor<T> Df(string df) => Qs("df", df);
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public DeleteByQueryDescriptor<T> ExpandWildcards(ExpandWildcards? expandWildcards) => Qs("expand_wildcards", expandWildcards);
		///<summary>Starting offset (default: 0)</summary>
		public DeleteByQueryDescriptor<T> From(long? from) => Qs("from", from);
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public DeleteByQueryDescriptor<T> IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
		///<summary>Specify whether format-based query failures (such as providing text to a numeric field) should be ignored</summary>
		public DeleteByQueryDescriptor<T> Lenient(bool? lenient = true) => Qs("lenient", lenient);
		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public DeleteByQueryDescriptor<T> Preference(string preference) => Qs("preference", preference);
		///<summary>Query in the Lucene query string syntax</summary>
		public DeleteByQueryDescriptor<T> QueryOnQueryString(string queryOnQueryString) => Qs("q", queryOnQueryString);
		///<summary>Should the effected indexes be refreshed?</summary>
		public DeleteByQueryDescriptor<T> Refresh(bool? refresh = true) => Qs("refresh", refresh);
		///<summary>Specify if request cache should be used for this request or not, defaults to index level setting</summary>
		public DeleteByQueryDescriptor<T> RequestCache(bool? requestCache = true) => Qs("request_cache", requestCache);
		///<summary>The throttle for this request in sub-requests per second. -1 means no throttle.</summary>
		public DeleteByQueryDescriptor<T> RequestsPerSecond(long? requestsPerSecond) => Qs("requests_per_second", requestsPerSecond);
		///<summary>
		/// A document is routed to a particular shard in an index using the following formula
		/// <para> shard_num = hash(_routing) % num_primary_shards</para>
		/// <para>Elasticsearch will use the document id if not provided. </para>
		/// <para>For requests that are constructed from/for a document NEST will automatically infer the routing key
		/// if that document has a <see cref = "Nest.JoinField"/> or a routing mapping on for its type exists on <see cref = "Nest.ConnectionSettings"/></para> 
		///</summary>
		public DeleteByQueryDescriptor<T> Routing(Routing routing) => Qs("routing", routing);
		///<summary>Specify how long a consistent view of the index should be maintained for scrolled search</summary>
		public DeleteByQueryDescriptor<T> Scroll(Time scroll) => Qs("scroll", scroll);
		///<summary>Size on the scroll request powering the delete by query</summary>
		public DeleteByQueryDescriptor<T> ScrollSize(long? scrollSize) => Qs("scroll_size", scrollSize);
		///<summary>Explicit timeout for each search request. Defaults to no timeout.</summary>
		public DeleteByQueryDescriptor<T> SearchTimeout(Time searchTimeout) => Qs("search_timeout", searchTimeout);
		///<summary>Search operation type</summary>
		public DeleteByQueryDescriptor<T> SearchType(SearchType? searchType) => Qs("search_type", searchType);
		///<summary>Number of hits to return (default: 10)</summary>
		public DeleteByQueryDescriptor<T> Size(long? size) => Qs("size", size);
		///<summary>The number of slices this task should be divided into. Defaults to 1 meaning the task isn't sliced into subtasks.</summary>
		public DeleteByQueryDescriptor<T> Slices(long? slices) => Qs("slices", slices);
		///<summary>A comma-separated list of <field>:<direction> pairs</summary>
		public DeleteByQueryDescriptor<T> Sort(params string[] sort) => Qs("sort", sort);
		///<summary>Whether the _source should be included in the response.</summary>
		public DeleteByQueryDescriptor<T> SourceEnabled(bool? sourceEnabled = true) => Qs("_source", sourceEnabled);
		///<summary>A list of fields to exclude from the returned _source field</summary>
		public DeleteByQueryDescriptor<T> SourceExcludes(Fields sourceExcludes) => Qs("_source_excludes", sourceExcludes);
		///<summary>A list of fields to exclude from the returned _source field</summary>
		public DeleteByQueryDescriptor<T> SourceExcludes(params Expression<Func<T, object>>[] fields) => Qs("_source_excludes", fields?.Select(e => (Field)e));
		///<summary>A list of fields to extract and return from the _source field</summary>
		public DeleteByQueryDescriptor<T> SourceIncludes(Fields sourceIncludes) => Qs("_source_includes", sourceIncludes);
		///<summary>A list of fields to extract and return from the _source field</summary>
		public DeleteByQueryDescriptor<T> SourceIncludes(params Expression<Func<T, object>>[] fields) => Qs("_source_includes", fields?.Select(e => (Field)e));
		///<summary>Specific 'tag' of the request for logging and statistical purposes</summary>
		public DeleteByQueryDescriptor<T> Stats(params string[] stats) => Qs("stats", stats);
		///<summary>The maximum number of documents to collect for each shard, upon reaching which the query execution will terminate early.</summary>
		public DeleteByQueryDescriptor<T> TerminateAfter(long? terminateAfter) => Qs("terminate_after", terminateAfter);
		///<summary>Time each individual bulk request should wait for shards that are unavailable.</summary>
		public DeleteByQueryDescriptor<T> Timeout(Time timeout) => Qs("timeout", timeout);
		///<summary>Specify whether to return document version as part of a hit</summary>
		public DeleteByQueryDescriptor<T> Version(bool? version = true) => Qs("version", version);
		///<summary>Sets the number of shard copies that must be active before proceeding with the delete by query operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1)</summary>
		public DeleteByQueryDescriptor<T> WaitForActiveShards(string waitForActiveShards) => Qs("wait_for_active_shards", waitForActiveShards);
		///<summary>Should the request should block until the delete by query is complete.</summary>
		public DeleteByQueryDescriptor<T> WaitForCompletion(bool? waitForCompletion = true) => Qs("wait_for_completion", waitForCompletion);
	}

	///<summary>descriptor for DeleteByQueryRethrottle <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-delete-by-query.html</pre></summary>
	public partial class DeleteByQueryRethrottleDescriptor : RequestDescriptorBase<DeleteByQueryRethrottleDescriptor, DeleteByQueryRethrottleRequestParameters, IDeleteByQueryRethrottleRequest>, IDeleteByQueryRethrottleRequest
	{
		internal override ApiUrls ApiUrls => DeleteByQueryRethrottleRequest.Urls;
		///<summary>/_delete_by_query/{task_id}/_rethrottle</summary>
		///<param name = "task_id">this parameter is required</param>
		public DeleteByQueryRethrottleDescriptor(TaskId task_id): base(r => r.Required("task_id", task_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal DeleteByQueryRethrottleDescriptor(): base()
		{
		}

		// values part of the url path
		TaskId IDeleteByQueryRethrottleRequest.TaskId => Self.RouteValues.Get<TaskId>("task_id");
		// Request parameters
		///<summary>The throttle to set on this request in floating sub-requests per second. -1 means set no throttle.</summary>
		public DeleteByQueryRethrottleDescriptor RequestsPerSecond(long? requestsPerSecond) => Qs("requests_per_second", requestsPerSecond);
	}

	///<summary>descriptor for DeleteScript <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-scripting.html</pre></summary>
	public partial class DeleteScriptDescriptor : RequestDescriptorBase<DeleteScriptDescriptor, DeleteScriptRequestParameters, IDeleteScriptRequest>, IDeleteScriptRequest
	{
		internal override ApiUrls ApiUrls => DeleteScriptRequest.Urls;
		///<summary>/_scripts/{id}</summary>
		///<param name = "id">this parameter is required</param>
		public DeleteScriptDescriptor(Id id): base(r => r.Required("id", id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal DeleteScriptDescriptor(): base()
		{
		}

		// values part of the url path
		Id IDeleteScriptRequest.Id => Self.RouteValues.Get<Id>("id");
		// Request parameters
		///<summary>Specify timeout for connection to master</summary>
		public DeleteScriptDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Explicit operation timeout</summary>
		public DeleteScriptDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
	}

	///<summary>descriptor for DocumentExists <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-get.html</pre></summary>
	public partial class DocumentExistsDescriptor<TDocument> : RequestDescriptorBase<DocumentExistsDescriptor<TDocument>, DocumentExistsRequestParameters, IDocumentExistsRequest<TDocument>>, IDocumentExistsRequest<TDocument>
	{
		internal override ApiUrls ApiUrls => DocumentExistsRequest.Urls;
		///<summary>/{index}/_doc/{id}</summary>
		///<param name = "index">this parameter is required</param>
		///<param name = "id">this parameter is required</param>
		public DocumentExistsDescriptor(IndexName index, Id id): base(r => r.Required("index", index).Required("id", id))
		{
		}

		///<summary>/{index}/_doc/{id}</summary>
		///<param name = "id">this parameter is required</param>
		public DocumentExistsDescriptor(Id id): this(typeof(TDocument), id)
		{
		}

		///<summary>/{index}/_doc/{id}</summary>
		///<param name = "id">The document used to resolve the path from</param>
		public DocumentExistsDescriptor(TDocument documentWithId, IndexName index = null, Id id = null): this(index ?? typeof(TDocument), id ?? Nest.Id.From(documentWithId)) => DocumentFromPath(documentWithId);
		partial void DocumentFromPath(TDocument document);
		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal DocumentExistsDescriptor(): base()
		{
		}

		// values part of the url path
		IndexName IDocumentExistsRequest.Index => Self.RouteValues.Get<IndexName>("index");
		Id IDocumentExistsRequest.Id => Self.RouteValues.Get<Id>("id");
		///<summary>The name of the index</summary>
		public DocumentExistsDescriptor<TDocument> Index(IndexName index) => Assign(index, (a, v) => a.RouteValues.Required("index", v));
		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public DocumentExistsDescriptor<TDocument> Index<TOther>()
			where TOther : class => Assign(typeof(TOther), (a, v) => a.RouteValues.Required("index", (IndexName)v));
		// Request parameters
		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public DocumentExistsDescriptor<TDocument> Preference(string preference) => Qs("preference", preference);
		///<summary>Specify whether to perform the operation in realtime or search mode</summary>
		public DocumentExistsDescriptor<TDocument> Realtime(bool? realtime = true) => Qs("realtime", realtime);
		///<summary>Refresh the shard containing the document before performing the operation</summary>
		public DocumentExistsDescriptor<TDocument> Refresh(bool? refresh = true) => Qs("refresh", refresh);
		///<summary>
		/// A document is routed to a particular shard in an index using the following formula
		/// <para> shard_num = hash(_routing) % num_primary_shards</para>
		/// <para>Elasticsearch will use the document id if not provided. </para>
		/// <para>For requests that are constructed from/for a document NEST will automatically infer the routing key
		/// if that document has a <see cref = "Nest.JoinField"/> or a routing mapping on for its type exists on <see cref = "Nest.ConnectionSettings"/></para> 
		///</summary>
		public DocumentExistsDescriptor<TDocument> Routing(Routing routing) => Qs("routing", routing);
		///<summary>Whether the _source should be included in the response.</summary>
		public DocumentExistsDescriptor<TDocument> SourceEnabled(bool? sourceEnabled = true) => Qs("_source", sourceEnabled);
		///<summary>A list of fields to exclude from the returned _source field</summary>
		public DocumentExistsDescriptor<TDocument> SourceExcludes(Fields sourceExcludes) => Qs("_source_excludes", sourceExcludes);
		///<summary>A list of fields to exclude from the returned _source field</summary>
		public DocumentExistsDescriptor<TDocument> SourceExcludes(params Expression<Func<TDocument, object>>[] fields) => Qs("_source_excludes", fields?.Select(e => (Field)e));
		///<summary>A list of fields to extract and return from the _source field</summary>
		public DocumentExistsDescriptor<TDocument> SourceIncludes(Fields sourceIncludes) => Qs("_source_includes", sourceIncludes);
		///<summary>A list of fields to extract and return from the _source field</summary>
		public DocumentExistsDescriptor<TDocument> SourceIncludes(params Expression<Func<TDocument, object>>[] fields) => Qs("_source_includes", fields?.Select(e => (Field)e));
		///<summary>A comma-separated list of stored fields to return in the response</summary>
		public DocumentExistsDescriptor<TDocument> StoredFields(Fields storedFields) => Qs("stored_fields", storedFields);
		///<summary>A comma-separated list of stored fields to return in the response</summary>
		public DocumentExistsDescriptor<TDocument> StoredFields(params Expression<Func<TDocument, object>>[] fields) => Qs("stored_fields", fields?.Select(e => (Field)e));
		///<summary>Explicit version number for concurrency control</summary>
		public DocumentExistsDescriptor<TDocument> Version(long? version) => Qs("version", version);
		///<summary>Specific version type</summary>
		public DocumentExistsDescriptor<TDocument> VersionType(VersionType? versionType) => Qs("version_type", versionType);
	}

	///<summary>descriptor for SourceExists <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-get.html</pre></summary>
	public partial class SourceExistsDescriptor<TDocument> : RequestDescriptorBase<SourceExistsDescriptor<TDocument>, SourceExistsRequestParameters, ISourceExistsRequest<TDocument>>, ISourceExistsRequest<TDocument>
	{
		internal override ApiUrls ApiUrls => SourceExistsRequest.Urls;
		///<summary>/{index}/_source/{id}</summary>
		///<param name = "index">this parameter is required</param>
		///<param name = "id">this parameter is required</param>
		public SourceExistsDescriptor(IndexName index, Id id): base(r => r.Required("index", index).Required("id", id))
		{
		}

		///<summary>/{index}/_source/{id}</summary>
		///<param name = "id">this parameter is required</param>
		public SourceExistsDescriptor(Id id): this(typeof(TDocument), id)
		{
		}

		///<summary>/{index}/_source/{id}</summary>
		///<param name = "id">The document used to resolve the path from</param>
		public SourceExistsDescriptor(TDocument documentWithId, IndexName index = null, Id id = null): this(index ?? typeof(TDocument), id ?? Nest.Id.From(documentWithId)) => DocumentFromPath(documentWithId);
		partial void DocumentFromPath(TDocument document);
		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal SourceExistsDescriptor(): base()
		{
		}

		// values part of the url path
		IndexName ISourceExistsRequest.Index => Self.RouteValues.Get<IndexName>("index");
		Id ISourceExistsRequest.Id => Self.RouteValues.Get<Id>("id");
		///<summary>The name of the index</summary>
		public SourceExistsDescriptor<TDocument> Index(IndexName index) => Assign(index, (a, v) => a.RouteValues.Required("index", v));
		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public SourceExistsDescriptor<TDocument> Index<TOther>()
			where TOther : class => Assign(typeof(TOther), (a, v) => a.RouteValues.Required("index", (IndexName)v));
		// Request parameters
		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public SourceExistsDescriptor<TDocument> Preference(string preference) => Qs("preference", preference);
		///<summary>Specify whether to perform the operation in realtime or search mode</summary>
		public SourceExistsDescriptor<TDocument> Realtime(bool? realtime = true) => Qs("realtime", realtime);
		///<summary>Refresh the shard containing the document before performing the operation</summary>
		public SourceExistsDescriptor<TDocument> Refresh(bool? refresh = true) => Qs("refresh", refresh);
		///<summary>
		/// A document is routed to a particular shard in an index using the following formula
		/// <para> shard_num = hash(_routing) % num_primary_shards</para>
		/// <para>Elasticsearch will use the document id if not provided. </para>
		/// <para>For requests that are constructed from/for a document NEST will automatically infer the routing key
		/// if that document has a <see cref = "Nest.JoinField"/> or a routing mapping on for its type exists on <see cref = "Nest.ConnectionSettings"/></para> 
		///</summary>
		public SourceExistsDescriptor<TDocument> Routing(Routing routing) => Qs("routing", routing);
		///<summary>Whether the _source should be included in the response.</summary>
		public SourceExistsDescriptor<TDocument> SourceEnabled(bool? sourceEnabled = true) => Qs("_source", sourceEnabled);
		///<summary>A list of fields to exclude from the returned _source field</summary>
		public SourceExistsDescriptor<TDocument> SourceExcludes(Fields sourceExcludes) => Qs("_source_excludes", sourceExcludes);
		///<summary>A list of fields to exclude from the returned _source field</summary>
		public SourceExistsDescriptor<TDocument> SourceExcludes(params Expression<Func<TDocument, object>>[] fields) => Qs("_source_excludes", fields?.Select(e => (Field)e));
		///<summary>A list of fields to extract and return from the _source field</summary>
		public SourceExistsDescriptor<TDocument> SourceIncludes(Fields sourceIncludes) => Qs("_source_includes", sourceIncludes);
		///<summary>A list of fields to extract and return from the _source field</summary>
		public SourceExistsDescriptor<TDocument> SourceIncludes(params Expression<Func<TDocument, object>>[] fields) => Qs("_source_includes", fields?.Select(e => (Field)e));
		///<summary>Explicit version number for concurrency control</summary>
		public SourceExistsDescriptor<TDocument> Version(long? version) => Qs("version", version);
		///<summary>Specific version type</summary>
		public SourceExistsDescriptor<TDocument> VersionType(VersionType? versionType) => Qs("version_type", versionType);
	}

	///<summary>descriptor for Explain <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/search-explain.html</pre></summary>
	public partial class ExplainDescriptor<TDocument> : RequestDescriptorBase<ExplainDescriptor<TDocument>, ExplainRequestParameters, IExplainRequest<TDocument>>, IExplainRequest<TDocument>
	{
		internal override ApiUrls ApiUrls => ExplainRequest.Urls;
		///<summary>/{index}/_explain/{id}</summary>
		///<param name = "index">this parameter is required</param>
		///<param name = "id">this parameter is required</param>
		public ExplainDescriptor(IndexName index, Id id): base(r => r.Required("index", index).Required("id", id))
		{
		}

		///<summary>/{index}/_explain/{id}</summary>
		///<param name = "id">this parameter is required</param>
		public ExplainDescriptor(Id id): this(typeof(TDocument), id)
		{
		}

		///<summary>/{index}/_explain/{id}</summary>
		///<param name = "id">The document used to resolve the path from</param>
		public ExplainDescriptor(TDocument documentWithId, IndexName index = null, Id id = null): this(index ?? typeof(TDocument), id ?? Nest.Id.From(documentWithId)) => DocumentFromPath(documentWithId);
		partial void DocumentFromPath(TDocument document);
		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal ExplainDescriptor(): base()
		{
		}

		// values part of the url path
		IndexName IExplainRequest.Index => Self.RouteValues.Get<IndexName>("index");
		Id IExplainRequest.Id => Self.RouteValues.Get<Id>("id");
		///<summary>The name of the index</summary>
		public ExplainDescriptor<TDocument> Index(IndexName index) => Assign(index, (a, v) => a.RouteValues.Required("index", v));
		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public ExplainDescriptor<TDocument> Index<TOther>()
			where TOther : class => Assign(typeof(TOther), (a, v) => a.RouteValues.Required("index", (IndexName)v));
		// Request parameters
		///<summary>Specify whether wildcards and prefix queries in the query string query should be analyzed (default: false)</summary>
		public ExplainDescriptor<TDocument> AnalyzeWildcard(bool? analyzeWildcard = true) => Qs("analyze_wildcard", analyzeWildcard);
		///<summary>The analyzer for the query string query</summary>
		public ExplainDescriptor<TDocument> Analyzer(string analyzer) => Qs("analyzer", analyzer);
		///<summary>The default operator for query string query (AND or OR)</summary>
		public ExplainDescriptor<TDocument> DefaultOperator(DefaultOperator? defaultOperator) => Qs("default_operator", defaultOperator);
		///<summary>The default field for query string query (default: _all)</summary>
		public ExplainDescriptor<TDocument> Df(string df) => Qs("df", df);
		///<summary>Specify whether format-based query failures (such as providing text to a numeric field) should be ignored</summary>
		public ExplainDescriptor<TDocument> Lenient(bool? lenient = true) => Qs("lenient", lenient);
		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public ExplainDescriptor<TDocument> Preference(string preference) => Qs("preference", preference);
		///<summary>Query in the Lucene query string syntax</summary>
		public ExplainDescriptor<TDocument> QueryOnQueryString(string queryOnQueryString) => Qs("q", queryOnQueryString);
		///<summary>
		/// A document is routed to a particular shard in an index using the following formula
		/// <para> shard_num = hash(_routing) % num_primary_shards</para>
		/// <para>Elasticsearch will use the document id if not provided. </para>
		/// <para>For requests that are constructed from/for a document NEST will automatically infer the routing key
		/// if that document has a <see cref = "Nest.JoinField"/> or a routing mapping on for its type exists on <see cref = "Nest.ConnectionSettings"/></para> 
		///</summary>
		public ExplainDescriptor<TDocument> Routing(Routing routing) => Qs("routing", routing);
		///<summary>Whether the _source should be included in the response.</summary>
		public ExplainDescriptor<TDocument> SourceEnabled(bool? sourceEnabled = true) => Qs("_source", sourceEnabled);
		///<summary>A list of fields to exclude from the returned _source field</summary>
		public ExplainDescriptor<TDocument> SourceExcludes(Fields sourceExcludes) => Qs("_source_excludes", sourceExcludes);
		///<summary>A list of fields to exclude from the returned _source field</summary>
		public ExplainDescriptor<TDocument> SourceExcludes(params Expression<Func<TDocument, object>>[] fields) => Qs("_source_excludes", fields?.Select(e => (Field)e));
		///<summary>A list of fields to extract and return from the _source field</summary>
		public ExplainDescriptor<TDocument> SourceIncludes(Fields sourceIncludes) => Qs("_source_includes", sourceIncludes);
		///<summary>A list of fields to extract and return from the _source field</summary>
		public ExplainDescriptor<TDocument> SourceIncludes(params Expression<Func<TDocument, object>>[] fields) => Qs("_source_includes", fields?.Select(e => (Field)e));
	}

	///<summary>descriptor for FieldCapabilities <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/search-field-caps.html</pre></summary>
	public partial class FieldCapabilitiesDescriptor : RequestDescriptorBase<FieldCapabilitiesDescriptor, FieldCapabilitiesRequestParameters, IFieldCapabilitiesRequest>, IFieldCapabilitiesRequest
	{
		internal override ApiUrls ApiUrls => FieldCapabilitiesRequest.Urls;
		///<summary>/_field_caps</summary>
		public FieldCapabilitiesDescriptor(): base()
		{
		}

		///<summary>/{index}/_field_caps</summary>
		///<param name = "index">Optional, accepts null</param>
		public FieldCapabilitiesDescriptor(Indices index): base(r => r.Optional("index", index))
		{
		}

		// values part of the url path
		Indices IFieldCapabilitiesRequest.Index => Self.RouteValues.Get<Indices>("index");
		///<summary>A comma-separated list of index names; use the special string `_all` or Indices.All to perform the operation on all indices</summary>
		public FieldCapabilitiesDescriptor Index(Indices index) => Assign(index, (a, v) => a.RouteValues.Optional("index", v));
		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public FieldCapabilitiesDescriptor Index<TOther>()
			where TOther : class => Assign(typeof(TOther), (a, v) => a.RouteValues.Optional("index", (Indices)v));
		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public FieldCapabilitiesDescriptor AllIndices() => this.Index(Indices.All);
		// Request parameters
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public FieldCapabilitiesDescriptor AllowNoIndices(bool? allowNoIndices = true) => Qs("allow_no_indices", allowNoIndices);
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public FieldCapabilitiesDescriptor ExpandWildcards(ExpandWildcards? expandWildcards) => Qs("expand_wildcards", expandWildcards);
		///<summary>A comma-separated list of field names</summary>
		public FieldCapabilitiesDescriptor Fields(Fields fields) => Qs("fields", fields);
		///<summary>A comma-separated list of field names</summary>
		public FieldCapabilitiesDescriptor Fields<T>(params Expression<Func<T, object>>[] fields)
			where T : class => Qs("fields", fields?.Select(e => (Field)e));
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public FieldCapabilitiesDescriptor IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
	}

	///<summary>descriptor for Get <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-get.html</pre></summary>
	public partial class GetDescriptor<TDocument> : RequestDescriptorBase<GetDescriptor<TDocument>, GetRequestParameters, IGetRequest<TDocument>>, IGetRequest<TDocument>
	{
		internal override ApiUrls ApiUrls => GetRequest.Urls;
		///<summary>/{index}/_doc/{id}</summary>
		///<param name = "index">this parameter is required</param>
		///<param name = "id">this parameter is required</param>
		public GetDescriptor(IndexName index, Id id): base(r => r.Required("index", index).Required("id", id))
		{
		}

		///<summary>/{index}/_doc/{id}</summary>
		///<param name = "id">this parameter is required</param>
		public GetDescriptor(Id id): this(typeof(TDocument), id)
		{
		}

		///<summary>/{index}/_doc/{id}</summary>
		///<param name = "id">The document used to resolve the path from</param>
		public GetDescriptor(TDocument documentWithId, IndexName index = null, Id id = null): this(index ?? typeof(TDocument), id ?? Nest.Id.From(documentWithId)) => DocumentFromPath(documentWithId);
		partial void DocumentFromPath(TDocument document);
		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal GetDescriptor(): base()
		{
		}

		// values part of the url path
		IndexName IGetRequest.Index => Self.RouteValues.Get<IndexName>("index");
		Id IGetRequest.Id => Self.RouteValues.Get<Id>("id");
		///<summary>The name of the index</summary>
		public GetDescriptor<TDocument> Index(IndexName index) => Assign(index, (a, v) => a.RouteValues.Required("index", v));
		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public GetDescriptor<TDocument> Index<TOther>()
			where TOther : class => Assign(typeof(TOther), (a, v) => a.RouteValues.Required("index", (IndexName)v));
		// Request parameters
		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public GetDescriptor<TDocument> Preference(string preference) => Qs("preference", preference);
		///<summary>Specify whether to perform the operation in realtime or search mode</summary>
		public GetDescriptor<TDocument> Realtime(bool? realtime = true) => Qs("realtime", realtime);
		///<summary>Refresh the shard containing the document before performing the operation</summary>
		public GetDescriptor<TDocument> Refresh(bool? refresh = true) => Qs("refresh", refresh);
		///<summary>
		/// A document is routed to a particular shard in an index using the following formula
		/// <para> shard_num = hash(_routing) % num_primary_shards</para>
		/// <para>Elasticsearch will use the document id if not provided. </para>
		/// <para>For requests that are constructed from/for a document NEST will automatically infer the routing key
		/// if that document has a <see cref = "Nest.JoinField"/> or a routing mapping on for its type exists on <see cref = "Nest.ConnectionSettings"/></para> 
		///</summary>
		public GetDescriptor<TDocument> Routing(Routing routing) => Qs("routing", routing);
		///<summary>Whether the _source should be included in the response.</summary>
		public GetDescriptor<TDocument> SourceEnabled(bool? sourceEnabled = true) => Qs("_source", sourceEnabled);
		///<summary>A list of fields to exclude from the returned _source field</summary>
		public GetDescriptor<TDocument> SourceExcludes(Fields sourceExcludes) => Qs("_source_excludes", sourceExcludes);
		///<summary>A list of fields to exclude from the returned _source field</summary>
		public GetDescriptor<TDocument> SourceExcludes(params Expression<Func<TDocument, object>>[] fields) => Qs("_source_excludes", fields?.Select(e => (Field)e));
		///<summary>A list of fields to extract and return from the _source field</summary>
		public GetDescriptor<TDocument> SourceIncludes(Fields sourceIncludes) => Qs("_source_includes", sourceIncludes);
		///<summary>A list of fields to extract and return from the _source field</summary>
		public GetDescriptor<TDocument> SourceIncludes(params Expression<Func<TDocument, object>>[] fields) => Qs("_source_includes", fields?.Select(e => (Field)e));
		///<summary>A comma-separated list of stored fields to return in the response</summary>
		public GetDescriptor<TDocument> StoredFields(Fields storedFields) => Qs("stored_fields", storedFields);
		///<summary>A comma-separated list of stored fields to return in the response</summary>
		public GetDescriptor<TDocument> StoredFields(params Expression<Func<TDocument, object>>[] fields) => Qs("stored_fields", fields?.Select(e => (Field)e));
		///<summary>Explicit version number for concurrency control</summary>
		public GetDescriptor<TDocument> Version(long? version) => Qs("version", version);
		///<summary>Specific version type</summary>
		public GetDescriptor<TDocument> VersionType(VersionType? versionType) => Qs("version_type", versionType);
	}

	///<summary>descriptor for GetScript <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-scripting.html</pre></summary>
	public partial class GetScriptDescriptor : RequestDescriptorBase<GetScriptDescriptor, GetScriptRequestParameters, IGetScriptRequest>, IGetScriptRequest
	{
		internal override ApiUrls ApiUrls => GetScriptRequest.Urls;
		///<summary>/_scripts/{id}</summary>
		///<param name = "id">this parameter is required</param>
		public GetScriptDescriptor(Id id): base(r => r.Required("id", id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal GetScriptDescriptor(): base()
		{
		}

		// values part of the url path
		Id IGetScriptRequest.Id => Self.RouteValues.Get<Id>("id");
		// Request parameters
		///<summary>Specify timeout for connection to master</summary>
		public GetScriptDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
	}

	///<summary>descriptor for Source <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-get.html</pre></summary>
	public partial class SourceDescriptor<TDocument> : RequestDescriptorBase<SourceDescriptor<TDocument>, SourceRequestParameters, ISourceRequest<TDocument>>, ISourceRequest<TDocument>
	{
		internal override ApiUrls ApiUrls => SourceRequest.Urls;
		///<summary>/{index}/_source/{id}</summary>
		///<param name = "index">this parameter is required</param>
		///<param name = "id">this parameter is required</param>
		public SourceDescriptor(IndexName index, Id id): base(r => r.Required("index", index).Required("id", id))
		{
		}

		///<summary>/{index}/_source/{id}</summary>
		///<param name = "id">this parameter is required</param>
		public SourceDescriptor(Id id): this(typeof(TDocument), id)
		{
		}

		///<summary>/{index}/_source/{id}</summary>
		///<param name = "id">The document used to resolve the path from</param>
		public SourceDescriptor(TDocument documentWithId, IndexName index = null, Id id = null): this(index ?? typeof(TDocument), id ?? Nest.Id.From(documentWithId)) => DocumentFromPath(documentWithId);
		partial void DocumentFromPath(TDocument document);
		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal SourceDescriptor(): base()
		{
		}

		// values part of the url path
		IndexName ISourceRequest.Index => Self.RouteValues.Get<IndexName>("index");
		Id ISourceRequest.Id => Self.RouteValues.Get<Id>("id");
		///<summary>The name of the index</summary>
		public SourceDescriptor<TDocument> Index(IndexName index) => Assign(index, (a, v) => a.RouteValues.Required("index", v));
		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public SourceDescriptor<TDocument> Index<TOther>()
			where TOther : class => Assign(typeof(TOther), (a, v) => a.RouteValues.Required("index", (IndexName)v));
		// Request parameters
		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public SourceDescriptor<TDocument> Preference(string preference) => Qs("preference", preference);
		///<summary>Specify whether to perform the operation in realtime or search mode</summary>
		public SourceDescriptor<TDocument> Realtime(bool? realtime = true) => Qs("realtime", realtime);
		///<summary>Refresh the shard containing the document before performing the operation</summary>
		public SourceDescriptor<TDocument> Refresh(bool? refresh = true) => Qs("refresh", refresh);
		///<summary>
		/// A document is routed to a particular shard in an index using the following formula
		/// <para> shard_num = hash(_routing) % num_primary_shards</para>
		/// <para>Elasticsearch will use the document id if not provided. </para>
		/// <para>For requests that are constructed from/for a document NEST will automatically infer the routing key
		/// if that document has a <see cref = "Nest.JoinField"/> or a routing mapping on for its type exists on <see cref = "Nest.ConnectionSettings"/></para> 
		///</summary>
		public SourceDescriptor<TDocument> Routing(Routing routing) => Qs("routing", routing);
		///<summary>Whether the _source should be included in the response.</summary>
		public SourceDescriptor<TDocument> SourceEnabled(bool? sourceEnabled = true) => Qs("_source", sourceEnabled);
		///<summary>A list of fields to exclude from the returned _source field</summary>
		public SourceDescriptor<TDocument> SourceExcludes(Fields sourceExcludes) => Qs("_source_excludes", sourceExcludes);
		///<summary>A list of fields to exclude from the returned _source field</summary>
		public SourceDescriptor<TDocument> SourceExcludes(params Expression<Func<TDocument, object>>[] fields) => Qs("_source_excludes", fields?.Select(e => (Field)e));
		///<summary>A list of fields to extract and return from the _source field</summary>
		public SourceDescriptor<TDocument> SourceIncludes(Fields sourceIncludes) => Qs("_source_includes", sourceIncludes);
		///<summary>A list of fields to extract and return from the _source field</summary>
		public SourceDescriptor<TDocument> SourceIncludes(params Expression<Func<TDocument, object>>[] fields) => Qs("_source_includes", fields?.Select(e => (Field)e));
		///<summary>Explicit version number for concurrency control</summary>
		public SourceDescriptor<TDocument> Version(long? version) => Qs("version", version);
		///<summary>Specific version type</summary>
		public SourceDescriptor<TDocument> VersionType(VersionType? versionType) => Qs("version_type", versionType);
	}

	///<summary>descriptor for Explore <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/graph-explore-api.html</pre></summary>
	public partial class GraphExploreDescriptor<T> : RequestDescriptorBase<GraphExploreDescriptor<T>, GraphExploreRequestParameters, IGraphExploreRequest<T>>, IGraphExploreRequest<T>
	{
		internal override ApiUrls ApiUrls => GraphExploreRequest.Urls;
		///<summary>/{index}/_graph/explore</summary>
		///<param name = "index">this parameter is required</param>
		public GraphExploreDescriptor(Indices index): base(r => r.Required("index", index))
		{
		}

		///<summary>/{index}/_graph/explore</summary>
		public GraphExploreDescriptor(): this(typeof(T))
		{
		}

		// values part of the url path
		Indices IGraphExploreRequest.Index => Self.RouteValues.Get<Indices>("index");
		///<summary>A comma-separated list of index names to search; use the special string `_all` or Indices.All to perform the operation on all indices</summary>
		public GraphExploreDescriptor<T> Index(Indices index) => Assign(index, (a, v) => a.RouteValues.Required("index", v));
		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public GraphExploreDescriptor<T> Index<TOther>()
			where TOther : class => Assign(typeof(TOther), (a, v) => a.RouteValues.Required("index", (Indices)v));
		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public GraphExploreDescriptor<T> AllIndices() => this.Index(Indices.All);
		// Request parameters
		///<summary>
		/// A document is routed to a particular shard in an index using the following formula
		/// <para> shard_num = hash(_routing) % num_primary_shards</para>
		/// <para>Elasticsearch will use the document id if not provided. </para>
		/// <para>For requests that are constructed from/for a document NEST will automatically infer the routing key
		/// if that document has a <see cref = "Nest.JoinField"/> or a routing mapping on for its type exists on <see cref = "Nest.ConnectionSettings"/></para> 
		///</summary>
		public GraphExploreDescriptor<T> Routing(Routing routing) => Qs("routing", routing);
		///<summary>Explicit operation timeout</summary>
		public GraphExploreDescriptor<T> Timeout(Time timeout) => Qs("timeout", timeout);
	}

	///<summary>descriptor for DeleteLifecycle <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/ilm-delete-lifecycle.html</pre></summary>
	public partial class DeleteLifecycleDescriptor : RequestDescriptorBase<DeleteLifecycleDescriptor, DeleteLifecycleRequestParameters, IDeleteLifecycleRequest>, IDeleteLifecycleRequest
	{
		internal override ApiUrls ApiUrls => DeleteLifecycleRequest.Urls;
		///<summary>/_ilm/policy/{policy_id}</summary>
		///<param name = "policy_id">this parameter is required</param>
		public DeleteLifecycleDescriptor(PolicyId policy_id): base(r => r.Required("policy_id", policy_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal DeleteLifecycleDescriptor(): base()
		{
		}

		// values part of the url path
		PolicyId IDeleteLifecycleRequest.PolicyId => Self.RouteValues.Get<PolicyId>("policy_id");
	// Request parameters
	}

	///<summary>descriptor for ExplainLifecycle <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/ilm-explain-lifecycle.html</pre></summary>
	public partial class ExplainLifecycleDescriptor : RequestDescriptorBase<ExplainLifecycleDescriptor, ExplainLifecycleRequestParameters, IExplainLifecycleRequest>, IExplainLifecycleRequest
	{
		internal override ApiUrls ApiUrls => ExplainLifecycleRequest.Urls;
		///<summary>/{index}/_ilm/explain</summary>
		///<param name = "index">this parameter is required</param>
		public ExplainLifecycleDescriptor(IndexName index): base(r => r.Required("index", index))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal ExplainLifecycleDescriptor(): base()
		{
		}

		// values part of the url path
		IndexName IExplainLifecycleRequest.Index => Self.RouteValues.Get<IndexName>("index");
		///<summary>The name of the index to explain</summary>
		public ExplainLifecycleDescriptor Index(IndexName index) => Assign(index, (a, v) => a.RouteValues.Required("index", v));
		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public ExplainLifecycleDescriptor Index<TOther>()
			where TOther : class => Assign(typeof(TOther), (a, v) => a.RouteValues.Required("index", (IndexName)v));
	// Request parameters
	}

	///<summary>descriptor for GetLifecycle <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/ilm-get-lifecycle.html</pre></summary>
	public partial class GetLifecycleDescriptor : RequestDescriptorBase<GetLifecycleDescriptor, GetLifecycleRequestParameters, IGetLifecycleRequest>, IGetLifecycleRequest
	{
		internal override ApiUrls ApiUrls => GetLifecycleRequest.Urls;
		///<summary>/_ilm/policy/{policy_id}</summary>
		///<param name = "policy_id">Optional, accepts null</param>
		public GetLifecycleDescriptor(PolicyId policy_id): base(r => r.Optional("policy_id", policy_id))
		{
		}

		///<summary>/_ilm/policy</summary>
		public GetLifecycleDescriptor(): base()
		{
		}

		// values part of the url path
		PolicyId IGetLifecycleRequest.PolicyId => Self.RouteValues.Get<PolicyId>("policy_id");
		///<summary>The name of the index lifecycle policy</summary>
		public GetLifecycleDescriptor PolicyId(PolicyId policyId) => Assign(policyId, (a, v) => a.RouteValues.Optional("policy_id", v));
	// Request parameters
	}

	///<summary>descriptor for GetIlmStatus <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/ilm-get-status.html</pre></summary>
	public partial class GetIlmStatusDescriptor : RequestDescriptorBase<GetIlmStatusDescriptor, GetIlmStatusRequestParameters, IGetIlmStatusRequest>, IGetIlmStatusRequest
	{
		internal override ApiUrls ApiUrls => GetIlmStatusRequest.Urls;
	// values part of the url path
	// Request parameters
	}

	///<summary>descriptor for MoveToStep <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/ilm-move-to-step.html</pre></summary>
	public partial class MoveToStepDescriptor : RequestDescriptorBase<MoveToStepDescriptor, MoveToStepRequestParameters, IMoveToStepRequest>, IMoveToStepRequest
	{
		internal override ApiUrls ApiUrls => MoveToStepRequest.Urls;
		///<summary>/_ilm/move/{index}</summary>
		///<param name = "index">this parameter is required</param>
		public MoveToStepDescriptor(IndexName index): base(r => r.Required("index", index))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal MoveToStepDescriptor(): base()
		{
		}

		// values part of the url path
		IndexName IMoveToStepRequest.Index => Self.RouteValues.Get<IndexName>("index");
		///<summary>The name of the index whose lifecycle step is to change</summary>
		public MoveToStepDescriptor Index(IndexName index) => Assign(index, (a, v) => a.RouteValues.Required("index", v));
		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public MoveToStepDescriptor Index<TOther>()
			where TOther : class => Assign(typeof(TOther), (a, v) => a.RouteValues.Required("index", (IndexName)v));
	// Request parameters
	//TODO THIS METHOD IS UNMAPPED!
	}

	///<summary>descriptor for PutLifecycle <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/ilm-put-lifecycle.html</pre></summary>
	public partial class PutLifecycleDescriptor : RequestDescriptorBase<PutLifecycleDescriptor, PutLifecycleRequestParameters, IPutLifecycleRequest>, IPutLifecycleRequest
	{
		internal override ApiUrls ApiUrls => PutLifecycleRequest.Urls;
		///<summary>/_ilm/policy/{policy_id}</summary>
		///<param name = "policy_id">this parameter is required</param>
		public PutLifecycleDescriptor(PolicyId policy_id): base(r => r.Required("policy_id", policy_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal PutLifecycleDescriptor(): base()
		{
		}

		// values part of the url path
		PolicyId IPutLifecycleRequest.PolicyId => Self.RouteValues.Get<PolicyId>("policy_id");
	// Request parameters
	}

	///<summary>descriptor for RemovePolicy <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/ilm-remove-policy.html</pre></summary>
	public partial class RemovePolicyDescriptor : RequestDescriptorBase<RemovePolicyDescriptor, RemovePolicyRequestParameters, IRemovePolicyRequest>, IRemovePolicyRequest
	{
		internal override ApiUrls ApiUrls => RemovePolicyRequest.Urls;
		///<summary>/{index}/_ilm/remove</summary>
		///<param name = "index">this parameter is required</param>
		public RemovePolicyDescriptor(IndexName index): base(r => r.Required("index", index))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal RemovePolicyDescriptor(): base()
		{
		}

		// values part of the url path
		IndexName IRemovePolicyRequest.Index => Self.RouteValues.Get<IndexName>("index");
		///<summary>The name of the index to remove policy on</summary>
		public RemovePolicyDescriptor Index(IndexName index) => Assign(index, (a, v) => a.RouteValues.Required("index", v));
		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public RemovePolicyDescriptor Index<TOther>()
			where TOther : class => Assign(typeof(TOther), (a, v) => a.RouteValues.Required("index", (IndexName)v));
	// Request parameters
	}

	///<summary>descriptor for RetryIlm <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/ilm-retry-policy.html</pre></summary>
	public partial class RetryIlmDescriptor : RequestDescriptorBase<RetryIlmDescriptor, RetryIlmRequestParameters, IRetryIlmRequest>, IRetryIlmRequest
	{
		internal override ApiUrls ApiUrls => RetryIlmRequest.Urls;
		///<summary>/{index}/_ilm/retry</summary>
		///<param name = "index">this parameter is required</param>
		public RetryIlmDescriptor(IndexName index): base(r => r.Required("index", index))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal RetryIlmDescriptor(): base()
		{
		}

		// values part of the url path
		IndexName IRetryIlmRequest.Index => Self.RouteValues.Get<IndexName>("index");
		///<summary>The name of the indices (comma-separated) whose failed lifecycle step is to be retry</summary>
		public RetryIlmDescriptor Index(IndexName index) => Assign(index, (a, v) => a.RouteValues.Required("index", v));
		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public RetryIlmDescriptor Index<TOther>()
			where TOther : class => Assign(typeof(TOther), (a, v) => a.RouteValues.Required("index", (IndexName)v));
	// Request parameters
	}

	///<summary>descriptor for StartIlm <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/ilm-start.html</pre></summary>
	public partial class StartIlmDescriptor : RequestDescriptorBase<StartIlmDescriptor, StartIlmRequestParameters, IStartIlmRequest>, IStartIlmRequest
	{
		internal override ApiUrls ApiUrls => StartIlmRequest.Urls;
	// values part of the url path
	// Request parameters
	}

	///<summary>descriptor for StopIlm <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/ilm-stop.html</pre></summary>
	public partial class StopIlmDescriptor : RequestDescriptorBase<StopIlmDescriptor, StopIlmRequestParameters, IStopIlmRequest>, IStopIlmRequest
	{
		internal override ApiUrls ApiUrls => StopIlmRequest.Urls;
	// values part of the url path
	// Request parameters
	}

	///<summary>descriptor for Index <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-index_.html</pre></summary>
	public partial class IndexDescriptor<TDocument> : RequestDescriptorBase<IndexDescriptor<TDocument>, IndexRequestParameters, IIndexRequest<TDocument>>, IIndexRequest<TDocument>
	{
		internal override ApiUrls ApiUrls => IndexRequest.Urls;
		///<summary>/{index}/_doc/{id}</summary>
		///<param name = "index">this parameter is required</param>
		///<param name = "id">Optional, accepts null</param>
		public IndexDescriptor(IndexName index, Id id): base(r => r.Required("index", index).Optional("id", id))
		{
		}

		///<summary>/{index}/_doc</summary>
		///<param name = "index">this parameter is required</param>
		public IndexDescriptor(IndexName index): base(r => r.Required("index", index))
		{
		}

		///<summary>/{index}/_doc/{id}</summary>
		///<param name = "id">Optional, accepts null</param>
		public IndexDescriptor(Id id): this(typeof(TDocument), id)
		{
		}

		///<summary>/{index}/_doc</summary>
		public IndexDescriptor(): this(typeof(TDocument))
		{
		}

		///<summary>/{index}/_doc/{id}</summary>
		///<param name = "id">The document used to resolve the path from</param>
		public IndexDescriptor(TDocument documentWithId, IndexName index = null, Id id = null): this(index ?? typeof(TDocument), id ?? Nest.Id.From(documentWithId)) => DocumentFromPath(documentWithId);
		partial void DocumentFromPath(TDocument document);
		// values part of the url path
		IndexName IIndexRequest.Index => Self.RouteValues.Get<IndexName>("index");
		Id IIndexRequest.Id => Self.RouteValues.Get<Id>("id");
		///<summary>The name of the index</summary>
		public IndexDescriptor<TDocument> Index(IndexName index) => Assign(index, (a, v) => a.RouteValues.Required("index", v));
		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public IndexDescriptor<TDocument> Index<TOther>()
			where TOther : class => Assign(typeof(TOther), (a, v) => a.RouteValues.Required("index", (IndexName)v));
		///<summary>Document ID</summary>
		public IndexDescriptor<TDocument> Id(Id id) => Assign(id, (a, v) => a.RouteValues.Optional("id", v));
		// Request parameters
		///<summary>only perform the index operation if the last operation that has changed the document has the specified primary term</summary>
		public IndexDescriptor<TDocument> IfPrimaryTerm(long? ifPrimaryTerm) => Qs("if_primary_term", ifPrimaryTerm);
		///<summary>only perform the index operation if the last operation that has changed the document has the specified sequence number</summary>
		public IndexDescriptor<TDocument> IfSequenceNumber(long? ifSequenceNumber) => Qs("if_seq_no", ifSequenceNumber);
		///<summary>Explicit operation type</summary>
		public IndexDescriptor<TDocument> OpType(OpType? opType) => Qs("op_type", opType);
		///<summary>The pipeline id to preprocess incoming documents with</summary>
		public IndexDescriptor<TDocument> Pipeline(string pipeline) => Qs("pipeline", pipeline);
		///<summary>If `true` then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` (the default) then do nothing with refreshes.</summary>
		public IndexDescriptor<TDocument> Refresh(Refresh? refresh) => Qs("refresh", refresh);
		///<summary>
		/// A document is routed to a particular shard in an index using the following formula
		/// <para> shard_num = hash(_routing) % num_primary_shards</para>
		/// <para>Elasticsearch will use the document id if not provided. </para>
		/// <para>For requests that are constructed from/for a document NEST will automatically infer the routing key
		/// if that document has a <see cref = "Nest.JoinField"/> or a routing mapping on for its type exists on <see cref = "Nest.ConnectionSettings"/></para> 
		///</summary>
		public IndexDescriptor<TDocument> Routing(Routing routing) => Qs("routing", routing);
		///<summary>Explicit operation timeout</summary>
		public IndexDescriptor<TDocument> Timeout(Time timeout) => Qs("timeout", timeout);
		///<summary>Explicit version number for concurrency control</summary>
		public IndexDescriptor<TDocument> Version(long? version) => Qs("version", version);
		///<summary>Specific version type</summary>
		public IndexDescriptor<TDocument> VersionType(VersionType? versionType) => Qs("version_type", versionType);
		///<summary>Sets the number of shard copies that must be active before proceeding with the index operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1)</summary>
		public IndexDescriptor<TDocument> WaitForActiveShards(string waitForActiveShards) => Qs("wait_for_active_shards", waitForActiveShards);
	}

	///<summary>descriptor for Analyze <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-analyze.html</pre></summary>
	public partial class AnalyzeDescriptor : RequestDescriptorBase<AnalyzeDescriptor, AnalyzeRequestParameters, IAnalyzeRequest>, IAnalyzeRequest
	{
		internal override ApiUrls ApiUrls => AnalyzeRequest.Urls;
		///<summary>/_analyze</summary>
		public AnalyzeDescriptor(): base()
		{
		}

		///<summary>/{index}/_analyze</summary>
		///<param name = "index">Optional, accepts null</param>
		public AnalyzeDescriptor(IndexName index): base(r => r.Optional("index", index))
		{
		}

		// values part of the url path
		IndexName IAnalyzeRequest.Index => Self.RouteValues.Get<IndexName>("index");
		///<summary>The name of the index to scope the operation</summary>
		public AnalyzeDescriptor Index(IndexName index) => Assign(index, (a, v) => a.RouteValues.Optional("index", v));
		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public AnalyzeDescriptor Index<TOther>()
			where TOther : class => Assign(typeof(TOther), (a, v) => a.RouteValues.Optional("index", (IndexName)v));
	// Request parameters
	}

	///<summary>descriptor for ClearCache <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-clearcache.html</pre></summary>
	public partial class ClearCacheDescriptor : RequestDescriptorBase<ClearCacheDescriptor, ClearCacheRequestParameters, IClearCacheRequest>, IClearCacheRequest
	{
		internal override ApiUrls ApiUrls => ClearCacheRequest.Urls;
		///<summary>/_cache/clear</summary>
		public ClearCacheDescriptor(): base()
		{
		}

		///<summary>/{index}/_cache/clear</summary>
		///<param name = "index">Optional, accepts null</param>
		public ClearCacheDescriptor(Indices index): base(r => r.Optional("index", index))
		{
		}

		// values part of the url path
		Indices IClearCacheRequest.Index => Self.RouteValues.Get<Indices>("index");
		///<summary>A comma-separated list of index name to limit the operation</summary>
		public ClearCacheDescriptor Index(Indices index) => Assign(index, (a, v) => a.RouteValues.Optional("index", v));
		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public ClearCacheDescriptor Index<TOther>()
			where TOther : class => Assign(typeof(TOther), (a, v) => a.RouteValues.Optional("index", (Indices)v));
		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public ClearCacheDescriptor AllIndices() => this.Index(Indices.All);
		// Request parameters
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public ClearCacheDescriptor AllowNoIndices(bool? allowNoIndices = true) => Qs("allow_no_indices", allowNoIndices);
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ClearCacheDescriptor ExpandWildcards(ExpandWildcards? expandWildcards) => Qs("expand_wildcards", expandWildcards);
		///<summary>Clear field data</summary>
		public ClearCacheDescriptor Fielddata(bool? fielddata = true) => Qs("fielddata", fielddata);
		///<summary>A comma-separated list of fields to clear when using the `fielddata` parameter (default: all)</summary>
		public ClearCacheDescriptor Fields(Fields fields) => Qs("fields", fields);
		///<summary>A comma-separated list of fields to clear when using the `fielddata` parameter (default: all)</summary>
		public ClearCacheDescriptor Fields<T>(params Expression<Func<T, object>>[] fields)
			where T : class => Qs("fields", fields?.Select(e => (Field)e));
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public ClearCacheDescriptor IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
		///<summary>Clear query caches</summary>
		public ClearCacheDescriptor Query(bool? query = true) => Qs("query", query);
		///<summary>Clear request cache</summary>
		public ClearCacheDescriptor Request(bool? request = true) => Qs("request", request);
	}

	///<summary>descriptor for CloseIndex <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-open-close.html</pre></summary>
	public partial class CloseIndexDescriptor : RequestDescriptorBase<CloseIndexDescriptor, CloseIndexRequestParameters, ICloseIndexRequest>, ICloseIndexRequest
	{
		internal override ApiUrls ApiUrls => CloseIndexRequest.Urls;
		///<summary>/{index}/_close</summary>
		///<param name = "index">this parameter is required</param>
		public CloseIndexDescriptor(Indices index): base(r => r.Required("index", index))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal CloseIndexDescriptor(): base()
		{
		}

		// values part of the url path
		Indices ICloseIndexRequest.Index => Self.RouteValues.Get<Indices>("index");
		///<summary>A comma separated list of indices to close</summary>
		public CloseIndexDescriptor Index(Indices index) => Assign(index, (a, v) => a.RouteValues.Required("index", v));
		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public CloseIndexDescriptor Index<TOther>()
			where TOther : class => Assign(typeof(TOther), (a, v) => a.RouteValues.Required("index", (Indices)v));
		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public CloseIndexDescriptor AllIndices() => this.Index(Indices.All);
		// Request parameters
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public CloseIndexDescriptor AllowNoIndices(bool? allowNoIndices = true) => Qs("allow_no_indices", allowNoIndices);
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public CloseIndexDescriptor ExpandWildcards(ExpandWildcards? expandWildcards) => Qs("expand_wildcards", expandWildcards);
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public CloseIndexDescriptor IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
		///<summary>Specify timeout for connection to master</summary>
		public CloseIndexDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Explicit operation timeout</summary>
		public CloseIndexDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
	}

	///<summary>descriptor for CreateIndex <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-create-index.html</pre></summary>
	public partial class CreateIndexDescriptor : RequestDescriptorBase<CreateIndexDescriptor, CreateIndexRequestParameters, ICreateIndexRequest>, ICreateIndexRequest
	{
		internal override ApiUrls ApiUrls => CreateIndexRequest.Urls;
		///<summary>/{index}</summary>
		///<param name = "index">this parameter is required</param>
		public CreateIndexDescriptor(IndexName index): base(r => r.Required("index", index))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal CreateIndexDescriptor(): base()
		{
		}

		// values part of the url path
		IndexName ICreateIndexRequest.Index => Self.RouteValues.Get<IndexName>("index");
		///<summary>The name of the index</summary>
		public CreateIndexDescriptor Index(IndexName index) => Assign(index, (a, v) => a.RouteValues.Required("index", v));
		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public CreateIndexDescriptor Index<TOther>()
			where TOther : class => Assign(typeof(TOther), (a, v) => a.RouteValues.Required("index", (IndexName)v));
		// Request parameters
		///<summary>Whether a type should be expected in the body of the mappings.</summary>
		public CreateIndexDescriptor IncludeTypeName(bool? includeTypeName = true) => Qs("include_type_name", includeTypeName);
		///<summary>Specify timeout for connection to master</summary>
		public CreateIndexDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Explicit operation timeout</summary>
		public CreateIndexDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
		///<summary>Set the number of active shards to wait for before the operation returns.</summary>
		public CreateIndexDescriptor WaitForActiveShards(string waitForActiveShards) => Qs("wait_for_active_shards", waitForActiveShards);
	}

	///<summary>descriptor for DeleteIndex <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-delete-index.html</pre></summary>
	public partial class DeleteIndexDescriptor : RequestDescriptorBase<DeleteIndexDescriptor, DeleteIndexRequestParameters, IDeleteIndexRequest>, IDeleteIndexRequest
	{
		internal override ApiUrls ApiUrls => DeleteIndexRequest.Urls;
		///<summary>/{index}</summary>
		///<param name = "index">this parameter is required</param>
		public DeleteIndexDescriptor(Indices index): base(r => r.Required("index", index))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal DeleteIndexDescriptor(): base()
		{
		}

		// values part of the url path
		Indices IDeleteIndexRequest.Index => Self.RouteValues.Get<Indices>("index");
		///<summary>A comma-separated list of indices to delete; use `_all` or `*` string to delete all indices</summary>
		public DeleteIndexDescriptor Index(Indices index) => Assign(index, (a, v) => a.RouteValues.Required("index", v));
		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public DeleteIndexDescriptor Index<TOther>()
			where TOther : class => Assign(typeof(TOther), (a, v) => a.RouteValues.Required("index", (Indices)v));
		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public DeleteIndexDescriptor AllIndices() => this.Index(Indices.All);
		// Request parameters
		///<summary>Ignore if a wildcard expression resolves to no concrete indices (default: false)</summary>
		public DeleteIndexDescriptor AllowNoIndices(bool? allowNoIndices = true) => Qs("allow_no_indices", allowNoIndices);
		///<summary>Whether wildcard expressions should get expanded to open or closed indices (default: open)</summary>
		public DeleteIndexDescriptor ExpandWildcards(ExpandWildcards? expandWildcards) => Qs("expand_wildcards", expandWildcards);
		///<summary>Ignore unavailable indexes (default: false)</summary>
		public DeleteIndexDescriptor IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
		///<summary>Specify timeout for connection to master</summary>
		public DeleteIndexDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Explicit operation timeout</summary>
		public DeleteIndexDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
	}

	///<summary>descriptor for DeleteAlias <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-aliases.html</pre></summary>
	public partial class DeleteAliasDescriptor : RequestDescriptorBase<DeleteAliasDescriptor, DeleteAliasRequestParameters, IDeleteAliasRequest>, IDeleteAliasRequest
	{
		internal override ApiUrls ApiUrls => DeleteAliasRequest.Urls;
		///<summary>/{index}/_alias/{name}</summary>
		///<param name = "index">this parameter is required</param>
		///<param name = "name">this parameter is required</param>
		public DeleteAliasDescriptor(Indices index, Names name): base(r => r.Required("index", index).Required("name", name))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal DeleteAliasDescriptor(): base()
		{
		}

		// values part of the url path
		Indices IDeleteAliasRequest.Index => Self.RouteValues.Get<Indices>("index");
		Names IDeleteAliasRequest.Name => Self.RouteValues.Get<Names>("name");
		///<summary>A comma-separated list of index names (supports wildcards); use `_all` for all indices</summary>
		public DeleteAliasDescriptor Index(Indices index) => Assign(index, (a, v) => a.RouteValues.Required("index", v));
		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public DeleteAliasDescriptor Index<TOther>()
			where TOther : class => Assign(typeof(TOther), (a, v) => a.RouteValues.Required("index", (Indices)v));
		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public DeleteAliasDescriptor AllIndices() => this.Index(Indices.All);
		// Request parameters
		///<summary>Specify timeout for connection to master</summary>
		public DeleteAliasDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Explicit timestamp for the document</summary>
		public DeleteAliasDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
	}

	///<summary>descriptor for DeleteIndexTemplate <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-templates.html</pre></summary>
	public partial class DeleteIndexTemplateDescriptor : RequestDescriptorBase<DeleteIndexTemplateDescriptor, DeleteIndexTemplateRequestParameters, IDeleteIndexTemplateRequest>, IDeleteIndexTemplateRequest
	{
		internal override ApiUrls ApiUrls => DeleteIndexTemplateRequest.Urls;
		///<summary>/_template/{name}</summary>
		///<param name = "name">this parameter is required</param>
		public DeleteIndexTemplateDescriptor(Name name): base(r => r.Required("name", name))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal DeleteIndexTemplateDescriptor(): base()
		{
		}

		// values part of the url path
		Name IDeleteIndexTemplateRequest.Name => Self.RouteValues.Get<Name>("name");
		// Request parameters
		///<summary>Specify timeout for connection to master</summary>
		public DeleteIndexTemplateDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Explicit operation timeout</summary>
		public DeleteIndexTemplateDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
	}

	///<summary>descriptor for IndexExists <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-exists.html</pre></summary>
	public partial class IndexExistsDescriptor : RequestDescriptorBase<IndexExistsDescriptor, IndexExistsRequestParameters, IIndexExistsRequest>, IIndexExistsRequest
	{
		internal override ApiUrls ApiUrls => IndexExistsRequest.Urls;
		///<summary>/{index}</summary>
		///<param name = "index">this parameter is required</param>
		public IndexExistsDescriptor(Indices index): base(r => r.Required("index", index))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal IndexExistsDescriptor(): base()
		{
		}

		// values part of the url path
		Indices IIndexExistsRequest.Index => Self.RouteValues.Get<Indices>("index");
		///<summary>A comma-separated list of index names</summary>
		public IndexExistsDescriptor Index(Indices index) => Assign(index, (a, v) => a.RouteValues.Required("index", v));
		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public IndexExistsDescriptor Index<TOther>()
			where TOther : class => Assign(typeof(TOther), (a, v) => a.RouteValues.Required("index", (Indices)v));
		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public IndexExistsDescriptor AllIndices() => this.Index(Indices.All);
		// Request parameters
		///<summary>Ignore if a wildcard expression resolves to no concrete indices (default: false)</summary>
		public IndexExistsDescriptor AllowNoIndices(bool? allowNoIndices = true) => Qs("allow_no_indices", allowNoIndices);
		///<summary>Whether wildcard expressions should get expanded to open or closed indices (default: open)</summary>
		public IndexExistsDescriptor ExpandWildcards(ExpandWildcards? expandWildcards) => Qs("expand_wildcards", expandWildcards);
		///<summary>Return settings in flat format (default: false)</summary>
		public IndexExistsDescriptor FlatSettings(bool? flatSettings = true) => Qs("flat_settings", flatSettings);
		///<summary>Ignore unavailable indexes (default: false)</summary>
		public IndexExistsDescriptor IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
		///<summary>Whether to return all default setting for each of the indices.</summary>
		public IndexExistsDescriptor IncludeDefaults(bool? includeDefaults = true) => Qs("include_defaults", includeDefaults);
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public IndexExistsDescriptor Local(bool? local = true) => Qs("local", local);
	}

	///<summary>descriptor for AliasExists <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-aliases.html</pre></summary>
	public partial class AliasExistsDescriptor : RequestDescriptorBase<AliasExistsDescriptor, AliasExistsRequestParameters, IAliasExistsRequest>, IAliasExistsRequest
	{
		internal override ApiUrls ApiUrls => AliasExistsRequest.Urls;
		///<summary>/_alias/{name}</summary>
		///<param name = "name">this parameter is required</param>
		public AliasExistsDescriptor(Names name): base(r => r.Required("name", name))
		{
		}

		///<summary>/{index}/_alias/{name}</summary>
		///<param name = "index">Optional, accepts null</param>
		///<param name = "name">this parameter is required</param>
		public AliasExistsDescriptor(Indices index, Names name): base(r => r.Optional("index", index).Required("name", name))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal AliasExistsDescriptor(): base()
		{
		}

		// values part of the url path
		Names IAliasExistsRequest.Name => Self.RouteValues.Get<Names>("name");
		Indices IAliasExistsRequest.Index => Self.RouteValues.Get<Indices>("index");
		///<summary>A comma-separated list of index names to filter aliases</summary>
		public AliasExistsDescriptor Index(Indices index) => Assign(index, (a, v) => a.RouteValues.Optional("index", v));
		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public AliasExistsDescriptor Index<TOther>()
			where TOther : class => Assign(typeof(TOther), (a, v) => a.RouteValues.Optional("index", (Indices)v));
		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public AliasExistsDescriptor AllIndices() => this.Index(Indices.All);
		// Request parameters
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public AliasExistsDescriptor AllowNoIndices(bool? allowNoIndices = true) => Qs("allow_no_indices", allowNoIndices);
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public AliasExistsDescriptor ExpandWildcards(ExpandWildcards? expandWildcards) => Qs("expand_wildcards", expandWildcards);
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public AliasExistsDescriptor IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public AliasExistsDescriptor Local(bool? local = true) => Qs("local", local);
	}

	///<summary>descriptor for IndexTemplateExists <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-templates.html</pre></summary>
	public partial class IndexTemplateExistsDescriptor : RequestDescriptorBase<IndexTemplateExistsDescriptor, IndexTemplateExistsRequestParameters, IIndexTemplateExistsRequest>, IIndexTemplateExistsRequest
	{
		internal override ApiUrls ApiUrls => IndexTemplateExistsRequest.Urls;
		///<summary>/_template/{name}</summary>
		///<param name = "name">this parameter is required</param>
		public IndexTemplateExistsDescriptor(Names name): base(r => r.Required("name", name))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal IndexTemplateExistsDescriptor(): base()
		{
		}

		// values part of the url path
		Names IIndexTemplateExistsRequest.Name => Self.RouteValues.Get<Names>("name");
		// Request parameters
		///<summary>Return settings in flat format (default: false)</summary>
		public IndexTemplateExistsDescriptor FlatSettings(bool? flatSettings = true) => Qs("flat_settings", flatSettings);
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public IndexTemplateExistsDescriptor Local(bool? local = true) => Qs("local", local);
		///<summary>Explicit operation timeout for connection to master node</summary>
		public IndexTemplateExistsDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
	}

	///<summary>descriptor for TypeExists <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-types-exists.html</pre></summary>
	public partial class TypeExistsDescriptor : RequestDescriptorBase<TypeExistsDescriptor, TypeExistsRequestParameters, ITypeExistsRequest>, ITypeExistsRequest
	{
		internal override ApiUrls ApiUrls => TypeExistsRequest.Urls;
		///<summary>/{index}/_mapping/{type}</summary>
		///<param name = "index">this parameter is required</param>
		///<param name = "type">this parameter is required</param>
		public TypeExistsDescriptor(Indices index, Names type): base(r => r.Required("index", index).Required("type", type))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal TypeExistsDescriptor(): base()
		{
		}

		// values part of the url path
		Indices ITypeExistsRequest.Index => Self.RouteValues.Get<Indices>("index");
		Names ITypeExistsRequest.Type => Self.RouteValues.Get<Names>("type");
		///<summary>A comma-separated list of index names; use `_all` to check the types across all indices</summary>
		public TypeExistsDescriptor Index(Indices index) => Assign(index, (a, v) => a.RouteValues.Required("index", v));
		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public TypeExistsDescriptor Index<TOther>()
			where TOther : class => Assign(typeof(TOther), (a, v) => a.RouteValues.Required("index", (Indices)v));
		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public TypeExistsDescriptor AllIndices() => this.Index(Indices.All);
		// Request parameters
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public TypeExistsDescriptor AllowNoIndices(bool? allowNoIndices = true) => Qs("allow_no_indices", allowNoIndices);
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public TypeExistsDescriptor ExpandWildcards(ExpandWildcards? expandWildcards) => Qs("expand_wildcards", expandWildcards);
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public TypeExistsDescriptor IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public TypeExistsDescriptor Local(bool? local = true) => Qs("local", local);
	}

	///<summary>descriptor for Flush <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-flush.html</pre></summary>
	public partial class FlushDescriptor : RequestDescriptorBase<FlushDescriptor, FlushRequestParameters, IFlushRequest>, IFlushRequest
	{
		internal override ApiUrls ApiUrls => FlushRequest.Urls;
		///<summary>/_flush</summary>
		public FlushDescriptor(): base()
		{
		}

		///<summary>/{index}/_flush</summary>
		///<param name = "index">Optional, accepts null</param>
		public FlushDescriptor(Indices index): base(r => r.Optional("index", index))
		{
		}

		// values part of the url path
		Indices IFlushRequest.Index => Self.RouteValues.Get<Indices>("index");
		///<summary>A comma-separated list of index names; use the special string `_all` or Indices.All for all indices</summary>
		public FlushDescriptor Index(Indices index) => Assign(index, (a, v) => a.RouteValues.Optional("index", v));
		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public FlushDescriptor Index<TOther>()
			where TOther : class => Assign(typeof(TOther), (a, v) => a.RouteValues.Optional("index", (Indices)v));
		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public FlushDescriptor AllIndices() => this.Index(Indices.All);
		// Request parameters
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public FlushDescriptor AllowNoIndices(bool? allowNoIndices = true) => Qs("allow_no_indices", allowNoIndices);
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public FlushDescriptor ExpandWildcards(ExpandWildcards? expandWildcards) => Qs("expand_wildcards", expandWildcards);
		///<summary>Whether a flush should be forced even if it is not necessarily needed ie. if no changes will be committed to the index. This is useful if transaction log IDs should be incremented even if no uncommitted changes are present. (This setting can be considered as internal)</summary>
		public FlushDescriptor Force(bool? force = true) => Qs("force", force);
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public FlushDescriptor IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
		///<summary>If set to true the flush operation will block until the flush can be executed if another flush operation is already executing. The default is true. If set to false the flush will be skipped iff if another flush operation is already running.</summary>
		public FlushDescriptor WaitIfOngoing(bool? waitIfOngoing = true) => Qs("wait_if_ongoing", waitIfOngoing);
	}

	///<summary>descriptor for SyncedFlush <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-synced-flush.html</pre></summary>
	public partial class SyncedFlushDescriptor : RequestDescriptorBase<SyncedFlushDescriptor, SyncedFlushRequestParameters, ISyncedFlushRequest>, ISyncedFlushRequest
	{
		internal override ApiUrls ApiUrls => SyncedFlushRequest.Urls;
		///<summary>/_flush/synced</summary>
		public SyncedFlushDescriptor(): base()
		{
		}

		///<summary>/{index}/_flush/synced</summary>
		///<param name = "index">Optional, accepts null</param>
		public SyncedFlushDescriptor(Indices index): base(r => r.Optional("index", index))
		{
		}

		// values part of the url path
		Indices ISyncedFlushRequest.Index => Self.RouteValues.Get<Indices>("index");
		///<summary>A comma-separated list of index names; use the special string `_all` or Indices.All for all indices</summary>
		public SyncedFlushDescriptor Index(Indices index) => Assign(index, (a, v) => a.RouteValues.Optional("index", v));
		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public SyncedFlushDescriptor Index<TOther>()
			where TOther : class => Assign(typeof(TOther), (a, v) => a.RouteValues.Optional("index", (Indices)v));
		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public SyncedFlushDescriptor AllIndices() => this.Index(Indices.All);
		// Request parameters
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public SyncedFlushDescriptor AllowNoIndices(bool? allowNoIndices = true) => Qs("allow_no_indices", allowNoIndices);
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public SyncedFlushDescriptor ExpandWildcards(ExpandWildcards? expandWildcards) => Qs("expand_wildcards", expandWildcards);
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public SyncedFlushDescriptor IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
	}

	///<summary>descriptor for ForceMerge <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-forcemerge.html</pre></summary>
	public partial class ForceMergeDescriptor : RequestDescriptorBase<ForceMergeDescriptor, ForceMergeRequestParameters, IForceMergeRequest>, IForceMergeRequest
	{
		internal override ApiUrls ApiUrls => ForceMergeRequest.Urls;
		///<summary>/_forcemerge</summary>
		public ForceMergeDescriptor(): base()
		{
		}

		///<summary>/{index}/_forcemerge</summary>
		///<param name = "index">Optional, accepts null</param>
		public ForceMergeDescriptor(Indices index): base(r => r.Optional("index", index))
		{
		}

		// values part of the url path
		Indices IForceMergeRequest.Index => Self.RouteValues.Get<Indices>("index");
		///<summary>A comma-separated list of index names; use the special string `_all` or Indices.All to perform the operation on all indices</summary>
		public ForceMergeDescriptor Index(Indices index) => Assign(index, (a, v) => a.RouteValues.Optional("index", v));
		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public ForceMergeDescriptor Index<TOther>()
			where TOther : class => Assign(typeof(TOther), (a, v) => a.RouteValues.Optional("index", (Indices)v));
		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public ForceMergeDescriptor AllIndices() => this.Index(Indices.All);
		// Request parameters
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public ForceMergeDescriptor AllowNoIndices(bool? allowNoIndices = true) => Qs("allow_no_indices", allowNoIndices);
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ForceMergeDescriptor ExpandWildcards(ExpandWildcards? expandWildcards) => Qs("expand_wildcards", expandWildcards);
		///<summary>Specify whether the index should be flushed after performing the operation (default: true)</summary>
		public ForceMergeDescriptor Flush(bool? flush = true) => Qs("flush", flush);
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public ForceMergeDescriptor IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
		///<summary>The number of segments the index should be merged into (default: dynamic)</summary>
		public ForceMergeDescriptor MaxNumSegments(long? maxNumSegments) => Qs("max_num_segments", maxNumSegments);
		///<summary>Specify whether the operation should only expunge deleted documents</summary>
		public ForceMergeDescriptor OnlyExpungeDeletes(bool? onlyExpungeDeletes = true) => Qs("only_expunge_deletes", onlyExpungeDeletes);
	}

	///<summary>descriptor for GetIndex <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-get-index.html</pre></summary>
	public partial class GetIndexDescriptor : RequestDescriptorBase<GetIndexDescriptor, GetIndexRequestParameters, IGetIndexRequest>, IGetIndexRequest
	{
		internal override ApiUrls ApiUrls => GetIndexRequest.Urls;
		///<summary>/{index}</summary>
		///<param name = "index">this parameter is required</param>
		public GetIndexDescriptor(Indices index): base(r => r.Required("index", index))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal GetIndexDescriptor(): base()
		{
		}

		// values part of the url path
		Indices IGetIndexRequest.Index => Self.RouteValues.Get<Indices>("index");
		///<summary>A comma-separated list of index names</summary>
		public GetIndexDescriptor Index(Indices index) => Assign(index, (a, v) => a.RouteValues.Required("index", v));
		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public GetIndexDescriptor Index<TOther>()
			where TOther : class => Assign(typeof(TOther), (a, v) => a.RouteValues.Required("index", (Indices)v));
		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public GetIndexDescriptor AllIndices() => this.Index(Indices.All);
		// Request parameters
		///<summary>Ignore if a wildcard expression resolves to no concrete indices (default: false)</summary>
		public GetIndexDescriptor AllowNoIndices(bool? allowNoIndices = true) => Qs("allow_no_indices", allowNoIndices);
		///<summary>Whether wildcard expressions should get expanded to open or closed indices (default: open)</summary>
		public GetIndexDescriptor ExpandWildcards(ExpandWildcards? expandWildcards) => Qs("expand_wildcards", expandWildcards);
		///<summary>Return settings in flat format (default: false)</summary>
		public GetIndexDescriptor FlatSettings(bool? flatSettings = true) => Qs("flat_settings", flatSettings);
		///<summary>Ignore unavailable indexes (default: false)</summary>
		public GetIndexDescriptor IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
		///<summary>Whether to return all default setting for each of the indices.</summary>
		public GetIndexDescriptor IncludeDefaults(bool? includeDefaults = true) => Qs("include_defaults", includeDefaults);
		///<summary>Whether to add the type name to the response (default: false)</summary>
		public GetIndexDescriptor IncludeTypeName(bool? includeTypeName = true) => Qs("include_type_name", includeTypeName);
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public GetIndexDescriptor Local(bool? local = true) => Qs("local", local);
		///<summary>Specify timeout for connection to master</summary>
		public GetIndexDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
	}

	///<summary>descriptor for GetAlias <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-aliases.html</pre></summary>
	public partial class GetAliasDescriptor : RequestDescriptorBase<GetAliasDescriptor, GetAliasRequestParameters, IGetAliasRequest>, IGetAliasRequest
	{
		internal override ApiUrls ApiUrls => GetAliasRequest.Urls;
		///<summary>/_alias</summary>
		public GetAliasDescriptor(): base()
		{
		}

		///<summary>/_alias/{name}</summary>
		///<param name = "name">Optional, accepts null</param>
		public GetAliasDescriptor(Names name): base(r => r.Optional("name", name))
		{
		}

		///<summary>/{index}/_alias/{name}</summary>
		///<param name = "index">Optional, accepts null</param>
		///<param name = "name">Optional, accepts null</param>
		public GetAliasDescriptor(Indices index, Names name): base(r => r.Optional("index", index).Optional("name", name))
		{
		}

		///<summary>/{index}/_alias</summary>
		///<param name = "index">Optional, accepts null</param>
		public GetAliasDescriptor(Indices index): base(r => r.Optional("index", index))
		{
		}

		// values part of the url path
		Names IGetAliasRequest.Name => Self.RouteValues.Get<Names>("name");
		Indices IGetAliasRequest.Index => Self.RouteValues.Get<Indices>("index");
		///<summary>A comma-separated list of alias names to return</summary>
		public GetAliasDescriptor Name(Names name) => Assign(name, (a, v) => a.RouteValues.Optional("name", v));
		///<summary>A comma-separated list of index names to filter aliases</summary>
		public GetAliasDescriptor Index(Indices index) => Assign(index, (a, v) => a.RouteValues.Optional("index", v));
		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public GetAliasDescriptor Index<TOther>()
			where TOther : class => Assign(typeof(TOther), (a, v) => a.RouteValues.Optional("index", (Indices)v));
		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public GetAliasDescriptor AllIndices() => this.Index(Indices.All);
		// Request parameters
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public GetAliasDescriptor AllowNoIndices(bool? allowNoIndices = true) => Qs("allow_no_indices", allowNoIndices);
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public GetAliasDescriptor ExpandWildcards(ExpandWildcards? expandWildcards) => Qs("expand_wildcards", expandWildcards);
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public GetAliasDescriptor IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public GetAliasDescriptor Local(bool? local = true) => Qs("local", local);
	}

	///<summary>descriptor for GetFieldMapping <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-get-field-mapping.html</pre></summary>
	public partial class GetFieldMappingDescriptor<T> : RequestDescriptorBase<GetFieldMappingDescriptor<T>, GetFieldMappingRequestParameters, IGetFieldMappingRequest>, IGetFieldMappingRequest
	{
		internal override ApiUrls ApiUrls => GetFieldMappingRequest.Urls;
		///<summary>/{index}/_mapping/field/{fields}</summary>
		///<param name = "fields">this parameter is required</param>
		public GetFieldMappingDescriptor(Fields fields): this(typeof(T), fields)
		{
		}

		///<summary>/{index}/_mapping/field/{fields}</summary>
		///<param name = "index">Optional, accepts null</param>
		///<param name = "fields">this parameter is required</param>
		public GetFieldMappingDescriptor(Indices index, Fields fields): base(r => r.Optional("index", index).Required("fields", fields))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal GetFieldMappingDescriptor(): base()
		{
		}

		// values part of the url path
		Fields IGetFieldMappingRequest.Fields => Self.RouteValues.Get<Fields>("fields");
		Indices IGetFieldMappingRequest.Index => Self.RouteValues.Get<Indices>("index");
		///<summary>A comma-separated list of index names</summary>
		public GetFieldMappingDescriptor<T> Index(Indices index) => Assign(index, (a, v) => a.RouteValues.Optional("index", v));
		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public GetFieldMappingDescriptor<T> Index<TOther>()
			where TOther : class => Assign(typeof(TOther), (a, v) => a.RouteValues.Optional("index", (Indices)v));
		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public GetFieldMappingDescriptor<T> AllIndices() => this.Index(Indices.All);
		// Request parameters
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public GetFieldMappingDescriptor<T> AllowNoIndices(bool? allowNoIndices = true) => Qs("allow_no_indices", allowNoIndices);
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public GetFieldMappingDescriptor<T> ExpandWildcards(ExpandWildcards? expandWildcards) => Qs("expand_wildcards", expandWildcards);
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public GetFieldMappingDescriptor<T> IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
		///<summary>Whether the default mapping values should be returned as well</summary>
		public GetFieldMappingDescriptor<T> IncludeDefaults(bool? includeDefaults = true) => Qs("include_defaults", includeDefaults);
		///<summary>Whether a type should be returned in the body of the mappings.</summary>
		public GetFieldMappingDescriptor<T> IncludeTypeName(bool? includeTypeName = true) => Qs("include_type_name", includeTypeName);
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public GetFieldMappingDescriptor<T> Local(bool? local = true) => Qs("local", local);
	}

	///<summary>descriptor for GetMapping <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-get-mapping.html</pre></summary>
	public partial class GetMappingDescriptor<T> : RequestDescriptorBase<GetMappingDescriptor<T>, GetMappingRequestParameters, IGetMappingRequest>, IGetMappingRequest
	{
		internal override ApiUrls ApiUrls => GetMappingRequest.Urls;
		///<summary>/{index}/_mapping</summary>
		public GetMappingDescriptor(): this(typeof(T))
		{
		}

		///<summary>/{index}/_mapping</summary>
		///<param name = "index">Optional, accepts null</param>
		public GetMappingDescriptor(Indices index): base(r => r.Optional("index", index))
		{
		}

		// values part of the url path
		Indices IGetMappingRequest.Index => Self.RouteValues.Get<Indices>("index");
		///<summary>A comma-separated list of index names</summary>
		public GetMappingDescriptor<T> Index(Indices index) => Assign(index, (a, v) => a.RouteValues.Optional("index", v));
		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public GetMappingDescriptor<T> Index<TOther>()
			where TOther : class => Assign(typeof(TOther), (a, v) => a.RouteValues.Optional("index", (Indices)v));
		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public GetMappingDescriptor<T> AllIndices() => this.Index(Indices.All);
		// Request parameters
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public GetMappingDescriptor<T> AllowNoIndices(bool? allowNoIndices = true) => Qs("allow_no_indices", allowNoIndices);
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public GetMappingDescriptor<T> ExpandWildcards(ExpandWildcards? expandWildcards) => Qs("expand_wildcards", expandWildcards);
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public GetMappingDescriptor<T> IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
		///<summary>Whether to add the type name to the response (default: false)</summary>
		public GetMappingDescriptor<T> IncludeTypeName(bool? includeTypeName = true) => Qs("include_type_name", includeTypeName);
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public GetMappingDescriptor<T> Local(bool? local = true) => Qs("local", local);
		///<summary>Specify timeout for connection to master</summary>
		public GetMappingDescriptor<T> MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
	}

	///<summary>descriptor for GetIndexSettings <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-get-settings.html</pre></summary>
	public partial class GetIndexSettingsDescriptor : RequestDescriptorBase<GetIndexSettingsDescriptor, GetIndexSettingsRequestParameters, IGetIndexSettingsRequest>, IGetIndexSettingsRequest
	{
		internal override ApiUrls ApiUrls => GetIndexSettingsRequest.Urls;
		///<summary>/_settings</summary>
		public GetIndexSettingsDescriptor(): base()
		{
		}

		///<summary>/{index}/_settings</summary>
		///<param name = "index">Optional, accepts null</param>
		public GetIndexSettingsDescriptor(Indices index): base(r => r.Optional("index", index))
		{
		}

		///<summary>/{index}/_settings/{name}</summary>
		///<param name = "index">Optional, accepts null</param>
		///<param name = "name">Optional, accepts null</param>
		public GetIndexSettingsDescriptor(Indices index, Names name): base(r => r.Optional("index", index).Optional("name", name))
		{
		}

		///<summary>/_settings/{name}</summary>
		///<param name = "name">Optional, accepts null</param>
		public GetIndexSettingsDescriptor(Names name): base(r => r.Optional("name", name))
		{
		}

		// values part of the url path
		Indices IGetIndexSettingsRequest.Index => Self.RouteValues.Get<Indices>("index");
		Names IGetIndexSettingsRequest.Name => Self.RouteValues.Get<Names>("name");
		///<summary>A comma-separated list of index names; use the special string `_all` or Indices.All to perform the operation on all indices</summary>
		public GetIndexSettingsDescriptor Index(Indices index) => Assign(index, (a, v) => a.RouteValues.Optional("index", v));
		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public GetIndexSettingsDescriptor Index<TOther>()
			where TOther : class => Assign(typeof(TOther), (a, v) => a.RouteValues.Optional("index", (Indices)v));
		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public GetIndexSettingsDescriptor AllIndices() => this.Index(Indices.All);
		///<summary>The name of the settings that should be included</summary>
		public GetIndexSettingsDescriptor Name(Names name) => Assign(name, (a, v) => a.RouteValues.Optional("name", v));
		// Request parameters
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public GetIndexSettingsDescriptor AllowNoIndices(bool? allowNoIndices = true) => Qs("allow_no_indices", allowNoIndices);
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public GetIndexSettingsDescriptor ExpandWildcards(ExpandWildcards? expandWildcards) => Qs("expand_wildcards", expandWildcards);
		///<summary>Return settings in flat format (default: false)</summary>
		public GetIndexSettingsDescriptor FlatSettings(bool? flatSettings = true) => Qs("flat_settings", flatSettings);
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public GetIndexSettingsDescriptor IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
		///<summary>Whether to return all default setting for each of the indices.</summary>
		public GetIndexSettingsDescriptor IncludeDefaults(bool? includeDefaults = true) => Qs("include_defaults", includeDefaults);
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public GetIndexSettingsDescriptor Local(bool? local = true) => Qs("local", local);
		///<summary>Specify timeout for connection to master</summary>
		public GetIndexSettingsDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
	}

	///<summary>descriptor for GetIndexTemplate <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-templates.html</pre></summary>
	public partial class GetIndexTemplateDescriptor : RequestDescriptorBase<GetIndexTemplateDescriptor, GetIndexTemplateRequestParameters, IGetIndexTemplateRequest>, IGetIndexTemplateRequest
	{
		internal override ApiUrls ApiUrls => GetIndexTemplateRequest.Urls;
		///<summary>/_template</summary>
		public GetIndexTemplateDescriptor(): base()
		{
		}

		///<summary>/_template/{name}</summary>
		///<param name = "name">Optional, accepts null</param>
		public GetIndexTemplateDescriptor(Names name): base(r => r.Optional("name", name))
		{
		}

		// values part of the url path
		Names IGetIndexTemplateRequest.Name => Self.RouteValues.Get<Names>("name");
		///<summary>The comma separated names of the index templates</summary>
		public GetIndexTemplateDescriptor Name(Names name) => Assign(name, (a, v) => a.RouteValues.Optional("name", v));
		// Request parameters
		///<summary>Return settings in flat format (default: false)</summary>
		public GetIndexTemplateDescriptor FlatSettings(bool? flatSettings = true) => Qs("flat_settings", flatSettings);
		///<summary>Whether a type should be returned in the body of the mappings.</summary>
		public GetIndexTemplateDescriptor IncludeTypeName(bool? includeTypeName = true) => Qs("include_type_name", includeTypeName);
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public GetIndexTemplateDescriptor Local(bool? local = true) => Qs("local", local);
		///<summary>Explicit operation timeout for connection to master node</summary>
		public GetIndexTemplateDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
	}

	///<summary>descriptor for UpgradeStatus <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-upgrade.html</pre></summary>
	public partial class UpgradeStatusDescriptor : RequestDescriptorBase<UpgradeStatusDescriptor, UpgradeStatusRequestParameters, IUpgradeStatusRequest>, IUpgradeStatusRequest
	{
		internal override ApiUrls ApiUrls => UpgradeStatusRequest.Urls;
		///<summary>/_upgrade</summary>
		public UpgradeStatusDescriptor(): base()
		{
		}

		///<summary>/{index}/_upgrade</summary>
		///<param name = "index">Optional, accepts null</param>
		public UpgradeStatusDescriptor(Indices index): base(r => r.Optional("index", index))
		{
		}

		// values part of the url path
		Indices IUpgradeStatusRequest.Index => Self.RouteValues.Get<Indices>("index");
		///<summary>A comma-separated list of index names; use the special string `_all` or Indices.All to perform the operation on all indices</summary>
		public UpgradeStatusDescriptor Index(Indices index) => Assign(index, (a, v) => a.RouteValues.Optional("index", v));
		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public UpgradeStatusDescriptor Index<TOther>()
			where TOther : class => Assign(typeof(TOther), (a, v) => a.RouteValues.Optional("index", (Indices)v));
		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public UpgradeStatusDescriptor AllIndices() => this.Index(Indices.All);
		// Request parameters
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public UpgradeStatusDescriptor AllowNoIndices(bool? allowNoIndices = true) => Qs("allow_no_indices", allowNoIndices);
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public UpgradeStatusDescriptor ExpandWildcards(ExpandWildcards? expandWildcards) => Qs("expand_wildcards", expandWildcards);
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public UpgradeStatusDescriptor IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
	}

	///<summary>descriptor for OpenIndex <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-open-close.html</pre></summary>
	public partial class OpenIndexDescriptor : RequestDescriptorBase<OpenIndexDescriptor, OpenIndexRequestParameters, IOpenIndexRequest>, IOpenIndexRequest
	{
		internal override ApiUrls ApiUrls => OpenIndexRequest.Urls;
		///<summary>/{index}/_open</summary>
		///<param name = "index">this parameter is required</param>
		public OpenIndexDescriptor(Indices index): base(r => r.Required("index", index))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal OpenIndexDescriptor(): base()
		{
		}

		// values part of the url path
		Indices IOpenIndexRequest.Index => Self.RouteValues.Get<Indices>("index");
		///<summary>A comma separated list of indices to open</summary>
		public OpenIndexDescriptor Index(Indices index) => Assign(index, (a, v) => a.RouteValues.Required("index", v));
		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public OpenIndexDescriptor Index<TOther>()
			where TOther : class => Assign(typeof(TOther), (a, v) => a.RouteValues.Required("index", (Indices)v));
		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public OpenIndexDescriptor AllIndices() => this.Index(Indices.All);
		// Request parameters
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public OpenIndexDescriptor AllowNoIndices(bool? allowNoIndices = true) => Qs("allow_no_indices", allowNoIndices);
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public OpenIndexDescriptor ExpandWildcards(ExpandWildcards? expandWildcards) => Qs("expand_wildcards", expandWildcards);
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public OpenIndexDescriptor IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
		///<summary>Specify timeout for connection to master</summary>
		public OpenIndexDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Explicit operation timeout</summary>
		public OpenIndexDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
		///<summary>Sets the number of active shards to wait for before the operation returns.</summary>
		public OpenIndexDescriptor WaitForActiveShards(string waitForActiveShards) => Qs("wait_for_active_shards", waitForActiveShards);
	}

	///<summary>descriptor for PutAlias <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-aliases.html</pre></summary>
	public partial class PutAliasDescriptor : RequestDescriptorBase<PutAliasDescriptor, PutAliasRequestParameters, IPutAliasRequest>, IPutAliasRequest
	{
		internal override ApiUrls ApiUrls => PutAliasRequest.Urls;
		///<summary>/{index}/_alias/{name}</summary>
		///<param name = "index">this parameter is required</param>
		///<param name = "name">this parameter is required</param>
		public PutAliasDescriptor(Indices index, Name name): base(r => r.Required("index", index).Required("name", name))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal PutAliasDescriptor(): base()
		{
		}

		// values part of the url path
		Indices IPutAliasRequest.Index => Self.RouteValues.Get<Indices>("index");
		Name IPutAliasRequest.Name => Self.RouteValues.Get<Name>("name");
		///<summary>A comma-separated list of index names the alias should point to (supports wildcards); use `_all` to perform the operation on all indices.</summary>
		public PutAliasDescriptor Index(Indices index) => Assign(index, (a, v) => a.RouteValues.Required("index", v));
		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public PutAliasDescriptor Index<TOther>()
			where TOther : class => Assign(typeof(TOther), (a, v) => a.RouteValues.Required("index", (Indices)v));
		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public PutAliasDescriptor AllIndices() => this.Index(Indices.All);
		// Request parameters
		///<summary>Specify timeout for connection to master</summary>
		public PutAliasDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Explicit timestamp for the document</summary>
		public PutAliasDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
	}

	///<summary>descriptor for PutMapping <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-put-mapping.html</pre></summary>
	public partial class PutMappingDescriptor<T> : RequestDescriptorBase<PutMappingDescriptor<T>, PutMappingRequestParameters, IPutMappingRequest<T>>, IPutMappingRequest<T>
	{
		internal override ApiUrls ApiUrls => PutMappingRequest.Urls;
		///<summary>/{index}/_mapping</summary>
		///<param name = "index">this parameter is required</param>
		public PutMappingDescriptor(Indices index): base(r => r.Required("index", index))
		{
		}

		///<summary>/{index}/_mapping</summary>
		public PutMappingDescriptor(): this(typeof(T))
		{
		}

		// values part of the url path
		Indices IPutMappingRequest.Index => Self.RouteValues.Get<Indices>("index");
		///<summary>A comma-separated list of index names the mapping should be added to (supports wildcards); use `_all` or omit to add the mapping on all indices.</summary>
		public PutMappingDescriptor<T> Index(Indices index) => Assign(index, (a, v) => a.RouteValues.Required("index", v));
		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public PutMappingDescriptor<T> Index<TOther>()
			where TOther : class => Assign(typeof(TOther), (a, v) => a.RouteValues.Required("index", (Indices)v));
		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public PutMappingDescriptor<T> AllIndices() => this.Index(Indices.All);
		// Request parameters
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public PutMappingDescriptor<T> AllowNoIndices(bool? allowNoIndices = true) => Qs("allow_no_indices", allowNoIndices);
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public PutMappingDescriptor<T> ExpandWildcards(ExpandWildcards? expandWildcards) => Qs("expand_wildcards", expandWildcards);
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public PutMappingDescriptor<T> IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
		///<summary>Whether a type should be expected in the body of the mappings.</summary>
		public PutMappingDescriptor<T> IncludeTypeName(bool? includeTypeName = true) => Qs("include_type_name", includeTypeName);
		///<summary>Specify timeout for connection to master</summary>
		public PutMappingDescriptor<T> MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Explicit operation timeout</summary>
		public PutMappingDescriptor<T> Timeout(Time timeout) => Qs("timeout", timeout);
	}

	///<summary>descriptor for UpdateIndexSettings <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-update-settings.html</pre></summary>
	public partial class UpdateIndexSettingsDescriptor : RequestDescriptorBase<UpdateIndexSettingsDescriptor, UpdateIndexSettingsRequestParameters, IUpdateIndexSettingsRequest>, IUpdateIndexSettingsRequest
	{
		internal override ApiUrls ApiUrls => UpdateIndexSettingsRequest.Urls;
		///<summary>/_settings</summary>
		public UpdateIndexSettingsDescriptor(): base()
		{
		}

		///<summary>/{index}/_settings</summary>
		///<param name = "index">Optional, accepts null</param>
		public UpdateIndexSettingsDescriptor(Indices index): base(r => r.Optional("index", index))
		{
		}

		// values part of the url path
		Indices IUpdateIndexSettingsRequest.Index => Self.RouteValues.Get<Indices>("index");
		///<summary>A comma-separated list of index names; use the special string `_all` or Indices.All to perform the operation on all indices</summary>
		public UpdateIndexSettingsDescriptor Index(Indices index) => Assign(index, (a, v) => a.RouteValues.Optional("index", v));
		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public UpdateIndexSettingsDescriptor Index<TOther>()
			where TOther : class => Assign(typeof(TOther), (a, v) => a.RouteValues.Optional("index", (Indices)v));
		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public UpdateIndexSettingsDescriptor AllIndices() => this.Index(Indices.All);
		// Request parameters
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public UpdateIndexSettingsDescriptor AllowNoIndices(bool? allowNoIndices = true) => Qs("allow_no_indices", allowNoIndices);
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public UpdateIndexSettingsDescriptor ExpandWildcards(ExpandWildcards? expandWildcards) => Qs("expand_wildcards", expandWildcards);
		///<summary>Return settings in flat format (default: false)</summary>
		public UpdateIndexSettingsDescriptor FlatSettings(bool? flatSettings = true) => Qs("flat_settings", flatSettings);
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public UpdateIndexSettingsDescriptor IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
		///<summary>Specify timeout for connection to master</summary>
		public UpdateIndexSettingsDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Whether to update existing settings. If set to `true` existing settings on an index remain unchanged, the default is `false`</summary>
		public UpdateIndexSettingsDescriptor PreserveExisting(bool? preserveExisting = true) => Qs("preserve_existing", preserveExisting);
		///<summary>Explicit operation timeout</summary>
		public UpdateIndexSettingsDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
	}

	///<summary>descriptor for PutIndexTemplate <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-templates.html</pre></summary>
	public partial class PutIndexTemplateDescriptor : RequestDescriptorBase<PutIndexTemplateDescriptor, PutIndexTemplateRequestParameters, IPutIndexTemplateRequest>, IPutIndexTemplateRequest
	{
		internal override ApiUrls ApiUrls => PutIndexTemplateRequest.Urls;
		///<summary>/_template/{name}</summary>
		///<param name = "name">this parameter is required</param>
		public PutIndexTemplateDescriptor(Name name): base(r => r.Required("name", name))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal PutIndexTemplateDescriptor(): base()
		{
		}

		// values part of the url path
		Name IPutIndexTemplateRequest.Name => Self.RouteValues.Get<Name>("name");
		// Request parameters
		///<summary>Whether the index template should only be added if new or can also replace an existing one</summary>
		public PutIndexTemplateDescriptor Create(bool? create = true) => Qs("create", create);
		///<summary>Return settings in flat format (default: false)</summary>
		public PutIndexTemplateDescriptor FlatSettings(bool? flatSettings = true) => Qs("flat_settings", flatSettings);
		///<summary>Whether a type should be returned in the body of the mappings.</summary>
		public PutIndexTemplateDescriptor IncludeTypeName(bool? includeTypeName = true) => Qs("include_type_name", includeTypeName);
		///<summary>Specify timeout for connection to master</summary>
		public PutIndexTemplateDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Explicit operation timeout</summary>
		public PutIndexTemplateDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
	}

	///<summary>descriptor for RecoveryStatus <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-recovery.html</pre></summary>
	public partial class RecoveryStatusDescriptor : RequestDescriptorBase<RecoveryStatusDescriptor, RecoveryStatusRequestParameters, IRecoveryStatusRequest>, IRecoveryStatusRequest
	{
		internal override ApiUrls ApiUrls => RecoveryStatusRequest.Urls;
		///<summary>/_recovery</summary>
		public RecoveryStatusDescriptor(): base()
		{
		}

		///<summary>/{index}/_recovery</summary>
		///<param name = "index">Optional, accepts null</param>
		public RecoveryStatusDescriptor(Indices index): base(r => r.Optional("index", index))
		{
		}

		// values part of the url path
		Indices IRecoveryStatusRequest.Index => Self.RouteValues.Get<Indices>("index");
		///<summary>A comma-separated list of index names; use the special string `_all` or Indices.All to perform the operation on all indices</summary>
		public RecoveryStatusDescriptor Index(Indices index) => Assign(index, (a, v) => a.RouteValues.Optional("index", v));
		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public RecoveryStatusDescriptor Index<TOther>()
			where TOther : class => Assign(typeof(TOther), (a, v) => a.RouteValues.Optional("index", (Indices)v));
		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public RecoveryStatusDescriptor AllIndices() => this.Index(Indices.All);
		// Request parameters
		///<summary>Display only those recoveries that are currently on-going</summary>
		public RecoveryStatusDescriptor ActiveOnly(bool? activeOnly = true) => Qs("active_only", activeOnly);
		///<summary>Whether to display detailed information about shard recovery</summary>
		public RecoveryStatusDescriptor Detailed(bool? detailed = true) => Qs("detailed", detailed);
	}

	///<summary>descriptor for Refresh <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-refresh.html</pre></summary>
	public partial class RefreshDescriptor : RequestDescriptorBase<RefreshDescriptor, RefreshRequestParameters, IRefreshRequest>, IRefreshRequest
	{
		internal override ApiUrls ApiUrls => RefreshRequest.Urls;
		///<summary>/_refresh</summary>
		public RefreshDescriptor(): base()
		{
		}

		///<summary>/{index}/_refresh</summary>
		///<param name = "index">Optional, accepts null</param>
		public RefreshDescriptor(Indices index): base(r => r.Optional("index", index))
		{
		}

		// values part of the url path
		Indices IRefreshRequest.Index => Self.RouteValues.Get<Indices>("index");
		///<summary>A comma-separated list of index names; use the special string `_all` or Indices.All to perform the operation on all indices</summary>
		public RefreshDescriptor Index(Indices index) => Assign(index, (a, v) => a.RouteValues.Optional("index", v));
		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public RefreshDescriptor Index<TOther>()
			where TOther : class => Assign(typeof(TOther), (a, v) => a.RouteValues.Optional("index", (Indices)v));
		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public RefreshDescriptor AllIndices() => this.Index(Indices.All);
		// Request parameters
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public RefreshDescriptor AllowNoIndices(bool? allowNoIndices = true) => Qs("allow_no_indices", allowNoIndices);
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public RefreshDescriptor ExpandWildcards(ExpandWildcards? expandWildcards) => Qs("expand_wildcards", expandWildcards);
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public RefreshDescriptor IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
	}

	///<summary>descriptor for RolloverIndex <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-rollover-index.html</pre></summary>
	public partial class RolloverIndexDescriptor : RequestDescriptorBase<RolloverIndexDescriptor, RolloverIndexRequestParameters, IRolloverIndexRequest>, IRolloverIndexRequest
	{
		internal override ApiUrls ApiUrls => RolloverIndexRequest.Urls;
		///<summary>/{alias}/_rollover</summary>
		///<param name = "alias">this parameter is required</param>
		public RolloverIndexDescriptor(Name alias): base(r => r.Required("alias", alias))
		{
		}

		///<summary>/{alias}/_rollover/{new_index}</summary>
		///<param name = "alias">this parameter is required</param>
		///<param name = "new_index">Optional, accepts null</param>
		public RolloverIndexDescriptor(Name alias, IndexName new_index): base(r => r.Required("alias", alias).Optional("new_index", new_index))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal RolloverIndexDescriptor(): base()
		{
		}

		// values part of the url path
		Name IRolloverIndexRequest.Alias => Self.RouteValues.Get<Name>("alias");
		IndexName IRolloverIndexRequest.NewIndex => Self.RouteValues.Get<IndexName>("new_index");
		///<summary>The name of the rollover index</summary>
		public RolloverIndexDescriptor NewIndex(IndexName newIndex) => Assign(newIndex, (a, v) => a.RouteValues.Optional("new_index", v));
		// Request parameters
		///<summary>If set to true the rollover action will only be validated but not actually performed even if a condition matches. The default is false</summary>
		public RolloverIndexDescriptor DryRun(bool? dryRun = true) => Qs("dry_run", dryRun);
		///<summary>Whether a type should be included in the body of the mappings.</summary>
		public RolloverIndexDescriptor IncludeTypeName(bool? includeTypeName = true) => Qs("include_type_name", includeTypeName);
		///<summary>Specify timeout for connection to master</summary>
		public RolloverIndexDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Explicit operation timeout</summary>
		public RolloverIndexDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
		///<summary>Set the number of active shards to wait for on the newly created rollover index before the operation returns.</summary>
		public RolloverIndexDescriptor WaitForActiveShards(string waitForActiveShards) => Qs("wait_for_active_shards", waitForActiveShards);
	}

	///<summary>descriptor for Segments <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-segments.html</pre></summary>
	public partial class SegmentsDescriptor : RequestDescriptorBase<SegmentsDescriptor, SegmentsRequestParameters, ISegmentsRequest>, ISegmentsRequest
	{
		internal override ApiUrls ApiUrls => SegmentsRequest.Urls;
		///<summary>/_segments</summary>
		public SegmentsDescriptor(): base()
		{
		}

		///<summary>/{index}/_segments</summary>
		///<param name = "index">Optional, accepts null</param>
		public SegmentsDescriptor(Indices index): base(r => r.Optional("index", index))
		{
		}

		// values part of the url path
		Indices ISegmentsRequest.Index => Self.RouteValues.Get<Indices>("index");
		///<summary>A comma-separated list of index names; use the special string `_all` or Indices.All to perform the operation on all indices</summary>
		public SegmentsDescriptor Index(Indices index) => Assign(index, (a, v) => a.RouteValues.Optional("index", v));
		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public SegmentsDescriptor Index<TOther>()
			where TOther : class => Assign(typeof(TOther), (a, v) => a.RouteValues.Optional("index", (Indices)v));
		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public SegmentsDescriptor AllIndices() => this.Index(Indices.All);
		// Request parameters
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public SegmentsDescriptor AllowNoIndices(bool? allowNoIndices = true) => Qs("allow_no_indices", allowNoIndices);
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public SegmentsDescriptor ExpandWildcards(ExpandWildcards? expandWildcards) => Qs("expand_wildcards", expandWildcards);
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public SegmentsDescriptor IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
		///<summary>Includes detailed memory usage by Lucene.</summary>
		public SegmentsDescriptor Verbose(bool? verbose = true) => Qs("verbose", verbose);
	}

	///<summary>descriptor for ShardStores <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-shards-stores.html</pre></summary>
	public partial class IndicesShardStoresDescriptor : RequestDescriptorBase<IndicesShardStoresDescriptor, IndicesShardStoresRequestParameters, IIndicesShardStoresRequest>, IIndicesShardStoresRequest
	{
		internal override ApiUrls ApiUrls => IndicesShardStoresRequest.Urls;
		///<summary>/_shard_stores</summary>
		public IndicesShardStoresDescriptor(): base()
		{
		}

		///<summary>/{index}/_shard_stores</summary>
		///<param name = "index">Optional, accepts null</param>
		public IndicesShardStoresDescriptor(Indices index): base(r => r.Optional("index", index))
		{
		}

		// values part of the url path
		Indices IIndicesShardStoresRequest.Index => Self.RouteValues.Get<Indices>("index");
		///<summary>A comma-separated list of index names; use the special string `_all` or Indices.All to perform the operation on all indices</summary>
		public IndicesShardStoresDescriptor Index(Indices index) => Assign(index, (a, v) => a.RouteValues.Optional("index", v));
		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public IndicesShardStoresDescriptor Index<TOther>()
			where TOther : class => Assign(typeof(TOther), (a, v) => a.RouteValues.Optional("index", (Indices)v));
		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public IndicesShardStoresDescriptor AllIndices() => this.Index(Indices.All);
		// Request parameters
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public IndicesShardStoresDescriptor AllowNoIndices(bool? allowNoIndices = true) => Qs("allow_no_indices", allowNoIndices);
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public IndicesShardStoresDescriptor ExpandWildcards(ExpandWildcards? expandWildcards) => Qs("expand_wildcards", expandWildcards);
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public IndicesShardStoresDescriptor IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
		///<summary>A comma-separated list of statuses used to filter on shards to get store information for</summary>
		public IndicesShardStoresDescriptor Status(params string[] status) => Qs("status", status);
	}

	///<summary>descriptor for ShrinkIndex <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-shrink-index.html</pre></summary>
	public partial class ShrinkIndexDescriptor : RequestDescriptorBase<ShrinkIndexDescriptor, ShrinkIndexRequestParameters, IShrinkIndexRequest>, IShrinkIndexRequest
	{
		internal override ApiUrls ApiUrls => ShrinkIndexRequest.Urls;
		///<summary>/{index}/_shrink/{target}</summary>
		///<param name = "index">this parameter is required</param>
		///<param name = "target">this parameter is required</param>
		public ShrinkIndexDescriptor(IndexName index, IndexName target): base(r => r.Required("index", index).Required("target", target))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal ShrinkIndexDescriptor(): base()
		{
		}

		// values part of the url path
		IndexName IShrinkIndexRequest.Index => Self.RouteValues.Get<IndexName>("index");
		IndexName IShrinkIndexRequest.Target => Self.RouteValues.Get<IndexName>("target");
		///<summary>The name of the source index to shrink</summary>
		public ShrinkIndexDescriptor Index(IndexName index) => Assign(index, (a, v) => a.RouteValues.Required("index", v));
		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public ShrinkIndexDescriptor Index<TOther>()
			where TOther : class => Assign(typeof(TOther), (a, v) => a.RouteValues.Required("index", (IndexName)v));
		// Request parameters
		///<summary>Specify timeout for connection to master</summary>
		public ShrinkIndexDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Explicit operation timeout</summary>
		public ShrinkIndexDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
		///<summary>Set the number of active shards to wait for on the shrunken index before the operation returns.</summary>
		public ShrinkIndexDescriptor WaitForActiveShards(string waitForActiveShards) => Qs("wait_for_active_shards", waitForActiveShards);
	}

	///<summary>descriptor for SplitIndex <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-split-index.html</pre></summary>
	public partial class SplitIndexDescriptor : RequestDescriptorBase<SplitIndexDescriptor, SplitIndexRequestParameters, ISplitIndexRequest>, ISplitIndexRequest
	{
		internal override ApiUrls ApiUrls => SplitIndexRequest.Urls;
		///<summary>/{index}/_split/{target}</summary>
		///<param name = "index">this parameter is required</param>
		///<param name = "target">this parameter is required</param>
		public SplitIndexDescriptor(IndexName index, IndexName target): base(r => r.Required("index", index).Required("target", target))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal SplitIndexDescriptor(): base()
		{
		}

		// values part of the url path
		IndexName ISplitIndexRequest.Index => Self.RouteValues.Get<IndexName>("index");
		IndexName ISplitIndexRequest.Target => Self.RouteValues.Get<IndexName>("target");
		///<summary>The name of the source index to split</summary>
		public SplitIndexDescriptor Index(IndexName index) => Assign(index, (a, v) => a.RouteValues.Required("index", v));
		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public SplitIndexDescriptor Index<TOther>()
			where TOther : class => Assign(typeof(TOther), (a, v) => a.RouteValues.Required("index", (IndexName)v));
		// Request parameters
		///<summary>Specify timeout for connection to master</summary>
		public SplitIndexDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Explicit operation timeout</summary>
		public SplitIndexDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
		///<summary>Set the number of active shards to wait for on the shrunken index before the operation returns.</summary>
		public SplitIndexDescriptor WaitForActiveShards(string waitForActiveShards) => Qs("wait_for_active_shards", waitForActiveShards);
	}

	///<summary>descriptor for Stats <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-stats.html</pre></summary>
	public partial class IndicesStatsDescriptor : RequestDescriptorBase<IndicesStatsDescriptor, IndicesStatsRequestParameters, IIndicesStatsRequest>, IIndicesStatsRequest
	{
		internal override ApiUrls ApiUrls => IndicesStatsRequest.Urls;
		///<summary>/_stats</summary>
		public IndicesStatsDescriptor(): base()
		{
		}

		///<summary>/_stats/{metric}</summary>
		///<param name = "metric">Optional, accepts null</param>
		public IndicesStatsDescriptor(Metrics metric): base(r => r.Optional("metric", metric))
		{
		}

		///<summary>/{index}/_stats</summary>
		///<param name = "index">Optional, accepts null</param>
		public IndicesStatsDescriptor(Indices index): base(r => r.Optional("index", index))
		{
		}

		///<summary>/{index}/_stats/{metric}</summary>
		///<param name = "index">Optional, accepts null</param>
		///<param name = "metric">Optional, accepts null</param>
		public IndicesStatsDescriptor(Indices index, Metrics metric): base(r => r.Optional("index", index).Optional("metric", metric))
		{
		}

		// values part of the url path
		Metrics IIndicesStatsRequest.Metric => Self.RouteValues.Get<Metrics>("metric");
		Indices IIndicesStatsRequest.Index => Self.RouteValues.Get<Indices>("index");
		///<summary>Limit the information returned the specific metrics.</summary>
		public IndicesStatsDescriptor Metric(Metrics metric) => Assign(metric, (a, v) => a.RouteValues.Optional("metric", (Metrics)v));
		///<summary>A comma-separated list of index names; use the special string `_all` or Indices.All to perform the operation on all indices</summary>
		public IndicesStatsDescriptor Index(Indices index) => Assign(index, (a, v) => a.RouteValues.Optional("index", v));
		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public IndicesStatsDescriptor Index<TOther>()
			where TOther : class => Assign(typeof(TOther), (a, v) => a.RouteValues.Optional("index", (Indices)v));
		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public IndicesStatsDescriptor AllIndices() => this.Index(Indices.All);
		// Request parameters
		///<summary>A comma-separated list of fields for `fielddata` and `suggest` index metric (supports wildcards)</summary>
		public IndicesStatsDescriptor CompletionFields(Fields completionFields) => Qs("completion_fields", completionFields);
		///<summary>A comma-separated list of fields for `fielddata` and `suggest` index metric (supports wildcards)</summary>
		public IndicesStatsDescriptor CompletionFields<T>(params Expression<Func<T, object>>[] fields)
			where T : class => Qs("completion_fields", fields?.Select(e => (Field)e));
		///<summary>A comma-separated list of fields for `fielddata` index metric (supports wildcards)</summary>
		public IndicesStatsDescriptor FielddataFields(Fields fielddataFields) => Qs("fielddata_fields", fielddataFields);
		///<summary>A comma-separated list of fields for `fielddata` index metric (supports wildcards)</summary>
		public IndicesStatsDescriptor FielddataFields<T>(params Expression<Func<T, object>>[] fields)
			where T : class => Qs("fielddata_fields", fields?.Select(e => (Field)e));
		///<summary>A comma-separated list of fields for `fielddata` and `completion` index metric (supports wildcards)</summary>
		public IndicesStatsDescriptor Fields(Fields fields) => Qs("fields", fields);
		///<summary>A comma-separated list of fields for `fielddata` and `completion` index metric (supports wildcards)</summary>
		public IndicesStatsDescriptor Fields<T>(params Expression<Func<T, object>>[] fields)
			where T : class => Qs("fields", fields?.Select(e => (Field)e));
		///<summary>A comma-separated list of search groups for `search` index metric</summary>
		public IndicesStatsDescriptor Groups(params string[] groups) => Qs("groups", groups);
		///<summary>Whether to report the aggregated disk usage of each one of the Lucene index files (only applies if segment stats are requested)</summary>
		public IndicesStatsDescriptor IncludeSegmentFileSizes(bool? includeSegmentFileSizes = true) => Qs("include_segment_file_sizes", includeSegmentFileSizes);
		///<summary>Return stats aggregated at cluster, index or shard level</summary>
		public IndicesStatsDescriptor Level(Level? level) => Qs("level", level);
	}

	///<summary>descriptor for BulkAlias <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-aliases.html</pre></summary>
	public partial class BulkAliasDescriptor : RequestDescriptorBase<BulkAliasDescriptor, BulkAliasRequestParameters, IBulkAliasRequest>, IBulkAliasRequest
	{
		internal override ApiUrls ApiUrls => BulkAliasRequest.Urls;
		// values part of the url path
		// Request parameters
		///<summary>Specify timeout for connection to master</summary>
		public BulkAliasDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Request timeout</summary>
		public BulkAliasDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
	}

	///<summary>descriptor for Upgrade <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-upgrade.html</pre></summary>
	public partial class UpgradeDescriptor : RequestDescriptorBase<UpgradeDescriptor, UpgradeRequestParameters, IUpgradeRequest>, IUpgradeRequest
	{
		internal override ApiUrls ApiUrls => UpgradeRequest.Urls;
		///<summary>/_upgrade</summary>
		public UpgradeDescriptor(): base()
		{
		}

		///<summary>/{index}/_upgrade</summary>
		///<param name = "index">Optional, accepts null</param>
		public UpgradeDescriptor(Indices index): base(r => r.Optional("index", index))
		{
		}

		// values part of the url path
		Indices IUpgradeRequest.Index => Self.RouteValues.Get<Indices>("index");
		///<summary>A comma-separated list of index names; use the special string `_all` or Indices.All to perform the operation on all indices</summary>
		public UpgradeDescriptor Index(Indices index) => Assign(index, (a, v) => a.RouteValues.Optional("index", v));
		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public UpgradeDescriptor Index<TOther>()
			where TOther : class => Assign(typeof(TOther), (a, v) => a.RouteValues.Optional("index", (Indices)v));
		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public UpgradeDescriptor AllIndices() => this.Index(Indices.All);
		// Request parameters
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public UpgradeDescriptor AllowNoIndices(bool? allowNoIndices = true) => Qs("allow_no_indices", allowNoIndices);
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public UpgradeDescriptor ExpandWildcards(ExpandWildcards? expandWildcards) => Qs("expand_wildcards", expandWildcards);
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public UpgradeDescriptor IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
		///<summary>If true, only ancient (an older Lucene major release) segments will be upgraded</summary>
		public UpgradeDescriptor OnlyAncientSegments(bool? onlyAncientSegments = true) => Qs("only_ancient_segments", onlyAncientSegments);
		///<summary>Specify whether the request should block until the all segments are upgraded (default: false)</summary>
		public UpgradeDescriptor WaitForCompletion(bool? waitForCompletion = true) => Qs("wait_for_completion", waitForCompletion);
	}

	///<summary>descriptor for ValidateQuery <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/search-validate.html</pre></summary>
	public partial class ValidateQueryDescriptor<T> : RequestDescriptorBase<ValidateQueryDescriptor<T>, ValidateQueryRequestParameters, IValidateQueryRequest<T>>, IValidateQueryRequest<T>
	{
		internal override ApiUrls ApiUrls => ValidateQueryRequest.Urls;
		///<summary>/{index}/_validate/query</summary>
		public ValidateQueryDescriptor(): this(typeof(T))
		{
		}

		///<summary>/{index}/_validate/query</summary>
		///<param name = "index">Optional, accepts null</param>
		public ValidateQueryDescriptor(Indices index): base(r => r.Optional("index", index))
		{
		}

		// values part of the url path
		Indices IValidateQueryRequest.Index => Self.RouteValues.Get<Indices>("index");
		///<summary>A comma-separated list of index names to restrict the operation; use the special string `_all` or Indices.All to perform the operation on all indices</summary>
		public ValidateQueryDescriptor<T> Index(Indices index) => Assign(index, (a, v) => a.RouteValues.Optional("index", v));
		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public ValidateQueryDescriptor<T> Index<TOther>()
			where TOther : class => Assign(typeof(TOther), (a, v) => a.RouteValues.Optional("index", (Indices)v));
		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public ValidateQueryDescriptor<T> AllIndices() => this.Index(Indices.All);
		// Request parameters
		///<summary>Execute validation on all shards instead of one random shard per index</summary>
		public ValidateQueryDescriptor<T> AllShards(bool? allShards = true) => Qs("all_shards", allShards);
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public ValidateQueryDescriptor<T> AllowNoIndices(bool? allowNoIndices = true) => Qs("allow_no_indices", allowNoIndices);
		///<summary>Specify whether wildcard and prefix queries should be analyzed (default: false)</summary>
		public ValidateQueryDescriptor<T> AnalyzeWildcard(bool? analyzeWildcard = true) => Qs("analyze_wildcard", analyzeWildcard);
		///<summary>The analyzer to use for the query string</summary>
		public ValidateQueryDescriptor<T> Analyzer(string analyzer) => Qs("analyzer", analyzer);
		///<summary>The default operator for query string query (AND or OR)</summary>
		public ValidateQueryDescriptor<T> DefaultOperator(DefaultOperator? defaultOperator) => Qs("default_operator", defaultOperator);
		///<summary>The field to use as default where no field prefix is given in the query string</summary>
		public ValidateQueryDescriptor<T> Df(string df) => Qs("df", df);
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ValidateQueryDescriptor<T> ExpandWildcards(ExpandWildcards? expandWildcards) => Qs("expand_wildcards", expandWildcards);
		///<summary>Return detailed information about the error</summary>
		public ValidateQueryDescriptor<T> Explain(bool? explain = true) => Qs("explain", explain);
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public ValidateQueryDescriptor<T> IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
		///<summary>Specify whether format-based query failures (such as providing text to a numeric field) should be ignored</summary>
		public ValidateQueryDescriptor<T> Lenient(bool? lenient = true) => Qs("lenient", lenient);
		///<summary>Query in the Lucene query string syntax</summary>
		public ValidateQueryDescriptor<T> QueryOnQueryString(string queryOnQueryString) => Qs("q", queryOnQueryString);
		///<summary>Provide a more detailed explanation showing the actual Lucene query that will be executed.</summary>
		public ValidateQueryDescriptor<T> Rewrite(bool? rewrite = true) => Qs("rewrite", rewrite);
	}

	///<summary>descriptor for RootNodeInfo <pre>http://www.elastic.co/guide/</pre></summary>
	public partial class RootNodeInfoDescriptor : RequestDescriptorBase<RootNodeInfoDescriptor, RootNodeInfoRequestParameters, IRootNodeInfoRequest>, IRootNodeInfoRequest
	{
		internal override ApiUrls ApiUrls => RootNodeInfoRequest.Urls;
	// values part of the url path
	// Request parameters
	}

	///<summary>descriptor for DeletePipeline <pre>https://www.elastic.co/guide/en/elasticsearch/plugins/master/ingest.html</pre></summary>
	public partial class DeletePipelineDescriptor : RequestDescriptorBase<DeletePipelineDescriptor, DeletePipelineRequestParameters, IDeletePipelineRequest>, IDeletePipelineRequest
	{
		internal override ApiUrls ApiUrls => DeletePipelineRequest.Urls;
		///<summary>/_ingest/pipeline/{id}</summary>
		///<param name = "id">this parameter is required</param>
		public DeletePipelineDescriptor(Id id): base(r => r.Required("id", id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal DeletePipelineDescriptor(): base()
		{
		}

		// values part of the url path
		Id IDeletePipelineRequest.Id => Self.RouteValues.Get<Id>("id");
		// Request parameters
		///<summary>Explicit operation timeout for connection to master node</summary>
		public DeletePipelineDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Explicit operation timeout</summary>
		public DeletePipelineDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
	}

	///<summary>descriptor for GetPipeline <pre>https://www.elastic.co/guide/en/elasticsearch/plugins/master/ingest.html</pre></summary>
	public partial class GetPipelineDescriptor : RequestDescriptorBase<GetPipelineDescriptor, GetPipelineRequestParameters, IGetPipelineRequest>, IGetPipelineRequest
	{
		internal override ApiUrls ApiUrls => GetPipelineRequest.Urls;
		///<summary>/_ingest/pipeline</summary>
		public GetPipelineDescriptor(): base()
		{
		}

		///<summary>/_ingest/pipeline/{id}</summary>
		///<param name = "id">Optional, accepts null</param>
		public GetPipelineDescriptor(Id id): base(r => r.Optional("id", id))
		{
		}

		// values part of the url path
		Id IGetPipelineRequest.Id => Self.RouteValues.Get<Id>("id");
		///<summary>Comma separated list of pipeline ids. Wildcards supported</summary>
		public GetPipelineDescriptor Id(Id id) => Assign(id, (a, v) => a.RouteValues.Optional("id", v));
		// Request parameters
		///<summary>Explicit operation timeout for connection to master node</summary>
		public GetPipelineDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
	}

	///<summary>descriptor for GrokProcessorPatterns <pre>https://www.elastic.co/guide/en/elasticsearch/plugins/master/ingest.html</pre></summary>
	public partial class GrokProcessorPatternsDescriptor : RequestDescriptorBase<GrokProcessorPatternsDescriptor, GrokProcessorPatternsRequestParameters, IGrokProcessorPatternsRequest>, IGrokProcessorPatternsRequest
	{
		internal override ApiUrls ApiUrls => GrokProcessorPatternsRequest.Urls;
	// values part of the url path
	// Request parameters
	}

	///<summary>descriptor for PutPipeline <pre>https://www.elastic.co/guide/en/elasticsearch/plugins/master/ingest.html</pre></summary>
	public partial class PutPipelineDescriptor : RequestDescriptorBase<PutPipelineDescriptor, PutPipelineRequestParameters, IPutPipelineRequest>, IPutPipelineRequest
	{
		internal override ApiUrls ApiUrls => PutPipelineRequest.Urls;
		///<summary>/_ingest/pipeline/{id}</summary>
		///<param name = "id">this parameter is required</param>
		public PutPipelineDescriptor(Id id): base(r => r.Required("id", id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal PutPipelineDescriptor(): base()
		{
		}

		// values part of the url path
		Id IPutPipelineRequest.Id => Self.RouteValues.Get<Id>("id");
		// Request parameters
		///<summary>Explicit operation timeout for connection to master node</summary>
		public PutPipelineDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Explicit operation timeout</summary>
		public PutPipelineDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
	}

	///<summary>descriptor for SimulatePipeline <pre>https://www.elastic.co/guide/en/elasticsearch/plugins/master/ingest.html</pre></summary>
	public partial class SimulatePipelineDescriptor : RequestDescriptorBase<SimulatePipelineDescriptor, SimulatePipelineRequestParameters, ISimulatePipelineRequest>, ISimulatePipelineRequest
	{
		internal override ApiUrls ApiUrls => SimulatePipelineRequest.Urls;
		///<summary>/_ingest/pipeline/_simulate</summary>
		public SimulatePipelineDescriptor(): base()
		{
		}

		///<summary>/_ingest/pipeline/{id}/_simulate</summary>
		///<param name = "id">Optional, accepts null</param>
		public SimulatePipelineDescriptor(Id id): base(r => r.Optional("id", id))
		{
		}

		// values part of the url path
		Id ISimulatePipelineRequest.Id => Self.RouteValues.Get<Id>("id");
		///<summary>Pipeline ID</summary>
		public SimulatePipelineDescriptor Id(Id id) => Assign(id, (a, v) => a.RouteValues.Optional("id", v));
		// Request parameters
		///<summary>Verbose mode. Display data output for each processor in executed pipeline</summary>
		public SimulatePipelineDescriptor Verbose(bool? verbose = true) => Qs("verbose", verbose);
	}

	///<summary>descriptor for DeleteLicense <pre>https://www.elastic.co/guide/en/x-pack/current/license-management.html</pre></summary>
	public partial class DeleteLicenseDescriptor : RequestDescriptorBase<DeleteLicenseDescriptor, DeleteLicenseRequestParameters, IDeleteLicenseRequest>, IDeleteLicenseRequest
	{
		internal override ApiUrls ApiUrls => DeleteLicenseRequest.Urls;
	// values part of the url path
	// Request parameters
	}

	///<summary>descriptor for GetLicense <pre>https://www.elastic.co/guide/en/x-pack/current/license-management.html</pre></summary>
	public partial class GetLicenseDescriptor : RequestDescriptorBase<GetLicenseDescriptor, GetLicenseRequestParameters, IGetLicenseRequest>, IGetLicenseRequest
	{
		internal override ApiUrls ApiUrls => GetLicenseRequest.Urls;
		// values part of the url path
		// Request parameters
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public GetLicenseDescriptor Local(bool? local = true) => Qs("local", local);
	}

	///<summary>descriptor for GetBasicLicenseStatus <pre>https://www.elastic.co/guide/en/x-pack/current/license-management.html</pre></summary>
	public partial class GetBasicLicenseStatusDescriptor : RequestDescriptorBase<GetBasicLicenseStatusDescriptor, GetBasicLicenseStatusRequestParameters, IGetBasicLicenseStatusRequest>, IGetBasicLicenseStatusRequest
	{
		internal override ApiUrls ApiUrls => GetBasicLicenseStatusRequest.Urls;
	// values part of the url path
	// Request parameters
	}

	///<summary>descriptor for GetTrialLicenseStatus <pre>https://www.elastic.co/guide/en/x-pack/current/license-management.html</pre></summary>
	public partial class GetTrialLicenseStatusDescriptor : RequestDescriptorBase<GetTrialLicenseStatusDescriptor, GetTrialLicenseStatusRequestParameters, IGetTrialLicenseStatusRequest>, IGetTrialLicenseStatusRequest
	{
		internal override ApiUrls ApiUrls => GetTrialLicenseStatusRequest.Urls;
	// values part of the url path
	// Request parameters
	}

	///<summary>descriptor for PostLicense <pre>https://www.elastic.co/guide/en/x-pack/current/license-management.html</pre></summary>
	public partial class PostLicenseDescriptor : RequestDescriptorBase<PostLicenseDescriptor, PostLicenseRequestParameters, IPostLicenseRequest>, IPostLicenseRequest
	{
		internal override ApiUrls ApiUrls => PostLicenseRequest.Urls;
		// values part of the url path
		// Request parameters
		///<summary>whether the user has acknowledged acknowledge messages (default: false)</summary>
		public PostLicenseDescriptor Acknowledge(bool? acknowledge = true) => Qs("acknowledge", acknowledge);
	}

	///<summary>descriptor for StartBasicLicense <pre>https://www.elastic.co/guide/en/x-pack/current/license-management.html</pre></summary>
	public partial class StartBasicLicenseDescriptor : RequestDescriptorBase<StartBasicLicenseDescriptor, StartBasicLicenseRequestParameters, IStartBasicLicenseRequest>, IStartBasicLicenseRequest
	{
		internal override ApiUrls ApiUrls => StartBasicLicenseRequest.Urls;
		// values part of the url path
		// Request parameters
		///<summary>whether the user has acknowledged acknowledge messages (default: false)</summary>
		public StartBasicLicenseDescriptor Acknowledge(bool? acknowledge = true) => Qs("acknowledge", acknowledge);
	}

	///<summary>descriptor for StartTrialLicense <pre>https://www.elastic.co/guide/en/x-pack/current/license-management.html</pre></summary>
	public partial class StartTrialLicenseDescriptor : RequestDescriptorBase<StartTrialLicenseDescriptor, StartTrialLicenseRequestParameters, IStartTrialLicenseRequest>, IStartTrialLicenseRequest
	{
		internal override ApiUrls ApiUrls => StartTrialLicenseRequest.Urls;
		// values part of the url path
		// Request parameters
		///<summary>whether the user has acknowledged acknowledge messages (default: false)</summary>
		public StartTrialLicenseDescriptor Acknowledge(bool? acknowledge = true) => Qs("acknowledge", acknowledge);
		///<summary>The type of trial license to generate (default: "trial")</summary>
		public StartTrialLicenseDescriptor TypeQueryString(string typeQueryString) => Qs("type", typeQueryString);
	}

	///<summary>descriptor for MultiGet <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-multi-get.html</pre></summary>
	public partial class MultiGetDescriptor : RequestDescriptorBase<MultiGetDescriptor, MultiGetRequestParameters, IMultiGetRequest>, IMultiGetRequest
	{
		internal override ApiUrls ApiUrls => MultiGetRequest.Urls;
		///<summary>/_mget</summary>
		public MultiGetDescriptor(): base()
		{
		}

		///<summary>/{index}/_mget</summary>
		///<param name = "index">Optional, accepts null</param>
		public MultiGetDescriptor(IndexName index): base(r => r.Optional("index", index))
		{
		}

		// values part of the url path
		IndexName IMultiGetRequest.Index => Self.RouteValues.Get<IndexName>("index");
		///<summary>The name of the index</summary>
		public MultiGetDescriptor Index(IndexName index) => Assign(index, (a, v) => a.RouteValues.Optional("index", v));
		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public MultiGetDescriptor Index<TOther>()
			where TOther : class => Assign(typeof(TOther), (a, v) => a.RouteValues.Optional("index", (IndexName)v));
		// Request parameters
		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public MultiGetDescriptor Preference(string preference) => Qs("preference", preference);
		///<summary>Specify whether to perform the operation in realtime or search mode</summary>
		public MultiGetDescriptor Realtime(bool? realtime = true) => Qs("realtime", realtime);
		///<summary>Refresh the shard containing the document before performing the operation</summary>
		public MultiGetDescriptor Refresh(bool? refresh = true) => Qs("refresh", refresh);
		///<summary>
		/// A document is routed to a particular shard in an index using the following formula
		/// <para> shard_num = hash(_routing) % num_primary_shards</para>
		/// <para>Elasticsearch will use the document id if not provided. </para>
		/// <para>For requests that are constructed from/for a document NEST will automatically infer the routing key
		/// if that document has a <see cref = "Nest.JoinField"/> or a routing mapping on for its type exists on <see cref = "Nest.ConnectionSettings"/></para> 
		///</summary>
		public MultiGetDescriptor Routing(Routing routing) => Qs("routing", routing);
		///<summary>Whether the _source should be included in the response.</summary>
		public MultiGetDescriptor SourceEnabled(bool? sourceEnabled = true) => Qs("_source", sourceEnabled);
		///<summary>A list of fields to exclude from the returned _source field</summary>
		public MultiGetDescriptor SourceExcludes(Fields sourceExcludes) => Qs("_source_excludes", sourceExcludes);
		///<summary>A list of fields to exclude from the returned _source field</summary>
		public MultiGetDescriptor SourceExcludes<T>(params Expression<Func<T, object>>[] fields)
			where T : class => Qs("_source_excludes", fields?.Select(e => (Field)e));
		///<summary>A list of fields to extract and return from the _source field</summary>
		public MultiGetDescriptor SourceIncludes(Fields sourceIncludes) => Qs("_source_includes", sourceIncludes);
		///<summary>A list of fields to extract and return from the _source field</summary>
		public MultiGetDescriptor SourceIncludes<T>(params Expression<Func<T, object>>[] fields)
			where T : class => Qs("_source_includes", fields?.Select(e => (Field)e));
	}

	///<summary>descriptor for DeprecationInfo <pre>http://www.elastic.co/guide/en/migration/current/migration-api-deprecation.html</pre></summary>
	public partial class DeprecationInfoDescriptor : RequestDescriptorBase<DeprecationInfoDescriptor, DeprecationInfoRequestParameters, IDeprecationInfoRequest>, IDeprecationInfoRequest
	{
		internal override ApiUrls ApiUrls => DeprecationInfoRequest.Urls;
		///<summary>/_migration/deprecations</summary>
		public DeprecationInfoDescriptor(): base()
		{
		}

		///<summary>/{index}/_migration/deprecations</summary>
		///<param name = "index">Optional, accepts null</param>
		public DeprecationInfoDescriptor(IndexName index): base(r => r.Optional("index", index))
		{
		}

		// values part of the url path
		IndexName IDeprecationInfoRequest.Index => Self.RouteValues.Get<IndexName>("index");
		///<summary>Index pattern</summary>
		public DeprecationInfoDescriptor Index(IndexName index) => Assign(index, (a, v) => a.RouteValues.Optional("index", v));
		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public DeprecationInfoDescriptor Index<TOther>()
			where TOther : class => Assign(typeof(TOther), (a, v) => a.RouteValues.Optional("index", (IndexName)v));
	// Request parameters
	}

	///<summary>descriptor for Assistance <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/migration-api-assistance.html</pre></summary>
	public partial class MigrationAssistanceDescriptor : RequestDescriptorBase<MigrationAssistanceDescriptor, MigrationAssistanceRequestParameters, IMigrationAssistanceRequest>, IMigrationAssistanceRequest
	{
		internal override ApiUrls ApiUrls => MigrationAssistanceRequest.Urls;
		///<summary>/_migration/assistance</summary>
		public MigrationAssistanceDescriptor(): base()
		{
		}

		///<summary>/_migration/assistance/{index}</summary>
		///<param name = "index">Optional, accepts null</param>
		public MigrationAssistanceDescriptor(Indices index): base(r => r.Optional("index", index))
		{
		}

		// values part of the url path
		Indices IMigrationAssistanceRequest.Index => Self.RouteValues.Get<Indices>("index");
		///<summary>A comma-separated list of index names; use the special string `_all` or Indices.All to perform the operation on all indices</summary>
		public MigrationAssistanceDescriptor Index(Indices index) => Assign(index, (a, v) => a.RouteValues.Optional("index", v));
		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public MigrationAssistanceDescriptor Index<TOther>()
			where TOther : class => Assign(typeof(TOther), (a, v) => a.RouteValues.Optional("index", (Indices)v));
		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public MigrationAssistanceDescriptor AllIndices() => this.Index(Indices.All);
		// Request parameters
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public MigrationAssistanceDescriptor AllowNoIndices(bool? allowNoIndices = true) => Qs("allow_no_indices", allowNoIndices);
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public MigrationAssistanceDescriptor ExpandWildcards(ExpandWildcards? expandWildcards) => Qs("expand_wildcards", expandWildcards);
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public MigrationAssistanceDescriptor IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
	}

	///<summary>descriptor for Upgrade <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/migration-api-upgrade.html</pre></summary>
	public partial class MigrationUpgradeDescriptor : RequestDescriptorBase<MigrationUpgradeDescriptor, MigrationUpgradeRequestParameters, IMigrationUpgradeRequest>, IMigrationUpgradeRequest
	{
		internal override ApiUrls ApiUrls => MigrationUpgradeRequest.Urls;
		///<summary>/_migration/upgrade/{index}</summary>
		///<param name = "index">this parameter is required</param>
		public MigrationUpgradeDescriptor(IndexName index): base(r => r.Required("index", index))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal MigrationUpgradeDescriptor(): base()
		{
		}

		// values part of the url path
		IndexName IMigrationUpgradeRequest.Index => Self.RouteValues.Get<IndexName>("index");
		///<summary>The name of the index</summary>
		public MigrationUpgradeDescriptor Index(IndexName index) => Assign(index, (a, v) => a.RouteValues.Required("index", v));
		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public MigrationUpgradeDescriptor Index<TOther>()
			where TOther : class => Assign(typeof(TOther), (a, v) => a.RouteValues.Required("index", (IndexName)v));
		// Request parameters
		///<summary>Should the request block until the upgrade operation is completed</summary>
		public MigrationUpgradeDescriptor WaitForCompletion(bool? waitForCompletion = true) => Qs("wait_for_completion", waitForCompletion);
	}

	///<summary>descriptor for CloseJob <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/ml-close-job.html</pre></summary>
	public partial class CloseJobDescriptor : RequestDescriptorBase<CloseJobDescriptor, CloseJobRequestParameters, ICloseJobRequest>, ICloseJobRequest
	{
		internal override ApiUrls ApiUrls => CloseJobRequest.Urls;
		///<summary>/_ml/anomaly_detectors/{job_id}/_close</summary>
		///<param name = "job_id">this parameter is required</param>
		public CloseJobDescriptor(Id job_id): base(r => r.Required("job_id", job_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal CloseJobDescriptor(): base()
		{
		}

		// values part of the url path
		Id ICloseJobRequest.JobId => Self.RouteValues.Get<Id>("job_id");
		// Request parameters
		///<summary>Whether to ignore if a wildcard expression matches no jobs. (This includes `_all` string or when no jobs have been specified)</summary>
		public CloseJobDescriptor AllowNoJobs(bool? allowNoJobs = true) => Qs("allow_no_jobs", allowNoJobs);
		///<summary>True if the job should be forcefully closed</summary>
		public CloseJobDescriptor Force(bool? force = true) => Qs("force", force);
		///<summary>Controls the time to wait until a job has closed. Default to 30 minutes</summary>
		public CloseJobDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
	}

	///<summary>descriptor for DeleteCalendar <pre></pre></summary>
	public partial class DeleteCalendarDescriptor : RequestDescriptorBase<DeleteCalendarDescriptor, DeleteCalendarRequestParameters, IDeleteCalendarRequest>, IDeleteCalendarRequest
	{
		internal override ApiUrls ApiUrls => DeleteCalendarRequest.Urls;
		///<summary>/_ml/calendars/{calendar_id}</summary>
		///<param name = "calendar_id">this parameter is required</param>
		public DeleteCalendarDescriptor(Id calendar_id): base(r => r.Required("calendar_id", calendar_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal DeleteCalendarDescriptor(): base()
		{
		}

		// values part of the url path
		Id IDeleteCalendarRequest.CalendarId => Self.RouteValues.Get<Id>("calendar_id");
	// Request parameters
	}

	///<summary>descriptor for DeleteCalendarEvent <pre></pre></summary>
	public partial class DeleteCalendarEventDescriptor : RequestDescriptorBase<DeleteCalendarEventDescriptor, DeleteCalendarEventRequestParameters, IDeleteCalendarEventRequest>, IDeleteCalendarEventRequest
	{
		internal override ApiUrls ApiUrls => DeleteCalendarEventRequest.Urls;
		///<summary>/_ml/calendars/{calendar_id}/events/{event_id}</summary>
		///<param name = "calendar_id">this parameter is required</param>
		///<param name = "event_id">this parameter is required</param>
		public DeleteCalendarEventDescriptor(Id calendar_id, Id event_id): base(r => r.Required("calendar_id", calendar_id).Required("event_id", event_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal DeleteCalendarEventDescriptor(): base()
		{
		}

		// values part of the url path
		Id IDeleteCalendarEventRequest.CalendarId => Self.RouteValues.Get<Id>("calendar_id");
		Id IDeleteCalendarEventRequest.EventId => Self.RouteValues.Get<Id>("event_id");
	// Request parameters
	}

	///<summary>descriptor for DeleteCalendarJob <pre></pre></summary>
	public partial class DeleteCalendarJobDescriptor : RequestDescriptorBase<DeleteCalendarJobDescriptor, DeleteCalendarJobRequestParameters, IDeleteCalendarJobRequest>, IDeleteCalendarJobRequest
	{
		internal override ApiUrls ApiUrls => DeleteCalendarJobRequest.Urls;
		///<summary>/_ml/calendars/{calendar_id}/jobs/{job_id}</summary>
		///<param name = "calendar_id">this parameter is required</param>
		///<param name = "job_id">this parameter is required</param>
		public DeleteCalendarJobDescriptor(Id calendar_id, Id job_id): base(r => r.Required("calendar_id", calendar_id).Required("job_id", job_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal DeleteCalendarJobDescriptor(): base()
		{
		}

		// values part of the url path
		Id IDeleteCalendarJobRequest.CalendarId => Self.RouteValues.Get<Id>("calendar_id");
		Id IDeleteCalendarJobRequest.JobId => Self.RouteValues.Get<Id>("job_id");
	// Request parameters
	}

	///<summary>descriptor for DeleteDatafeed <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/ml-delete-datafeed.html</pre></summary>
	public partial class DeleteDatafeedDescriptor : RequestDescriptorBase<DeleteDatafeedDescriptor, DeleteDatafeedRequestParameters, IDeleteDatafeedRequest>, IDeleteDatafeedRequest
	{
		internal override ApiUrls ApiUrls => DeleteDatafeedRequest.Urls;
		///<summary>/_ml/datafeeds/{datafeed_id}</summary>
		///<param name = "datafeed_id">this parameter is required</param>
		public DeleteDatafeedDescriptor(Id datafeed_id): base(r => r.Required("datafeed_id", datafeed_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal DeleteDatafeedDescriptor(): base()
		{
		}

		// values part of the url path
		Id IDeleteDatafeedRequest.DatafeedId => Self.RouteValues.Get<Id>("datafeed_id");
		// Request parameters
		///<summary>True if the datafeed should be forcefully deleted</summary>
		public DeleteDatafeedDescriptor Force(bool? force = true) => Qs("force", force);
	}

	///<summary>descriptor for DeleteExpiredData <pre></pre></summary>
	public partial class DeleteExpiredDataDescriptor : RequestDescriptorBase<DeleteExpiredDataDescriptor, DeleteExpiredDataRequestParameters, IDeleteExpiredDataRequest>, IDeleteExpiredDataRequest
	{
		internal override ApiUrls ApiUrls => DeleteExpiredDataRequest.Urls;
	// values part of the url path
	// Request parameters
	}

	///<summary>descriptor for DeleteFilter <pre></pre></summary>
	public partial class DeleteFilterDescriptor : RequestDescriptorBase<DeleteFilterDescriptor, DeleteFilterRequestParameters, IDeleteFilterRequest>, IDeleteFilterRequest
	{
		internal override ApiUrls ApiUrls => DeleteFilterRequest.Urls;
		///<summary>/_ml/filters/{filter_id}</summary>
		///<param name = "filter_id">this parameter is required</param>
		public DeleteFilterDescriptor(Id filter_id): base(r => r.Required("filter_id", filter_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal DeleteFilterDescriptor(): base()
		{
		}

		// values part of the url path
		Id IDeleteFilterRequest.FilterId => Self.RouteValues.Get<Id>("filter_id");
	// Request parameters
	}

	///<summary>descriptor for DeleteForecast <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/ml-delete-forecast.html</pre></summary>
	public partial class DeleteForecastDescriptor : RequestDescriptorBase<DeleteForecastDescriptor, DeleteForecastRequestParameters, IDeleteForecastRequest>, IDeleteForecastRequest
	{
		internal override ApiUrls ApiUrls => DeleteForecastRequest.Urls;
		///<summary>/_ml/anomaly_detectors/{job_id}/_forecast/{forecast_id}</summary>
		///<param name = "job_id">this parameter is required</param>
		///<param name = "forecast_id">this parameter is required</param>
		public DeleteForecastDescriptor(Id job_id, ForecastIds forecast_id): base(r => r.Required("job_id", job_id).Required("forecast_id", forecast_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal DeleteForecastDescriptor(): base()
		{
		}

		// values part of the url path
		Id IDeleteForecastRequest.JobId => Self.RouteValues.Get<Id>("job_id");
		ForecastIds IDeleteForecastRequest.ForecastId => Self.RouteValues.Get<ForecastIds>("forecast_id");
		// Request parameters
		///<summary>Whether to ignore if `_all` matches no forecasts</summary>
		public DeleteForecastDescriptor AllowNoForecasts(bool? allowNoForecasts = true) => Qs("allow_no_forecasts", allowNoForecasts);
		///<summary>Controls the time to wait until the forecast(s) are deleted. Default to 30 seconds</summary>
		public DeleteForecastDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
	}

	///<summary>descriptor for DeleteJob <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/ml-delete-job.html</pre></summary>
	public partial class DeleteJobDescriptor : RequestDescriptorBase<DeleteJobDescriptor, DeleteJobRequestParameters, IDeleteJobRequest>, IDeleteJobRequest
	{
		internal override ApiUrls ApiUrls => DeleteJobRequest.Urls;
		///<summary>/_ml/anomaly_detectors/{job_id}</summary>
		///<param name = "job_id">this parameter is required</param>
		public DeleteJobDescriptor(Id job_id): base(r => r.Required("job_id", job_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal DeleteJobDescriptor(): base()
		{
		}

		// values part of the url path
		Id IDeleteJobRequest.JobId => Self.RouteValues.Get<Id>("job_id");
		// Request parameters
		///<summary>True if the job should be forcefully deleted</summary>
		public DeleteJobDescriptor Force(bool? force = true) => Qs("force", force);
		///<summary>Should this request wait until the operation has completed before returning</summary>
		public DeleteJobDescriptor WaitForCompletion(bool? waitForCompletion = true) => Qs("wait_for_completion", waitForCompletion);
	}

	///<summary>descriptor for DeleteModelSnapshot <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/ml-delete-snapshot.html</pre></summary>
	public partial class DeleteModelSnapshotDescriptor : RequestDescriptorBase<DeleteModelSnapshotDescriptor, DeleteModelSnapshotRequestParameters, IDeleteModelSnapshotRequest>, IDeleteModelSnapshotRequest
	{
		internal override ApiUrls ApiUrls => DeleteModelSnapshotRequest.Urls;
		///<summary>/_ml/anomaly_detectors/{job_id}/model_snapshots/{snapshot_id}</summary>
		///<param name = "job_id">this parameter is required</param>
		///<param name = "snapshot_id">this parameter is required</param>
		public DeleteModelSnapshotDescriptor(Id job_id, Id snapshot_id): base(r => r.Required("job_id", job_id).Required("snapshot_id", snapshot_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal DeleteModelSnapshotDescriptor(): base()
		{
		}

		// values part of the url path
		Id IDeleteModelSnapshotRequest.JobId => Self.RouteValues.Get<Id>("job_id");
		Id IDeleteModelSnapshotRequest.SnapshotId => Self.RouteValues.Get<Id>("snapshot_id");
	// Request parameters
	}

	///<summary>descriptor for FlushJob <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/ml-flush-job.html</pre></summary>
	public partial class FlushJobDescriptor : RequestDescriptorBase<FlushJobDescriptor, FlushJobRequestParameters, IFlushJobRequest>, IFlushJobRequest
	{
		internal override ApiUrls ApiUrls => FlushJobRequest.Urls;
		///<summary>/_ml/anomaly_detectors/{job_id}/_flush</summary>
		///<param name = "job_id">this parameter is required</param>
		public FlushJobDescriptor(Id job_id): base(r => r.Required("job_id", job_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal FlushJobDescriptor(): base()
		{
		}

		// values part of the url path
		Id IFlushJobRequest.JobId => Self.RouteValues.Get<Id>("job_id");
		// Request parameters
		///<summary>Skips time to the given value without generating results or updating the model for the skipped interval</summary>
		public FlushJobDescriptor SkipTime(string skipTime) => Qs("skip_time", skipTime);
	}

	///<summary>descriptor for ForecastJob <pre></pre></summary>
	public partial class ForecastJobDescriptor : RequestDescriptorBase<ForecastJobDescriptor, ForecastJobRequestParameters, IForecastJobRequest>, IForecastJobRequest
	{
		internal override ApiUrls ApiUrls => ForecastJobRequest.Urls;
		///<summary>/_ml/anomaly_detectors/{job_id}/_forecast</summary>
		///<param name = "job_id">this parameter is required</param>
		public ForecastJobDescriptor(Id job_id): base(r => r.Required("job_id", job_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal ForecastJobDescriptor(): base()
		{
		}

		// values part of the url path
		Id IForecastJobRequest.JobId => Self.RouteValues.Get<Id>("job_id");
	// Request parameters
	}

	///<summary>descriptor for GetBuckets <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/ml-get-bucket.html</pre></summary>
	public partial class GetBucketsDescriptor : RequestDescriptorBase<GetBucketsDescriptor, GetBucketsRequestParameters, IGetBucketsRequest>, IGetBucketsRequest
	{
		internal override ApiUrls ApiUrls => GetBucketsRequest.Urls;
		///<summary>/_ml/anomaly_detectors/{job_id}/results/buckets/{timestamp}</summary>
		///<param name = "job_id">this parameter is required</param>
		///<param name = "timestamp">Optional, accepts null</param>
		public GetBucketsDescriptor(Id job_id, Timestamp timestamp): base(r => r.Required("job_id", job_id).Optional("timestamp", timestamp))
		{
		}

		///<summary>/_ml/anomaly_detectors/{job_id}/results/buckets</summary>
		///<param name = "job_id">this parameter is required</param>
		public GetBucketsDescriptor(Id job_id): base(r => r.Required("job_id", job_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal GetBucketsDescriptor(): base()
		{
		}

		// values part of the url path
		Id IGetBucketsRequest.JobId => Self.RouteValues.Get<Id>("job_id");
		Timestamp IGetBucketsRequest.Timestamp => Self.RouteValues.Get<Timestamp>("timestamp");
		///<summary>The timestamp of the desired single bucket result</summary>
		public GetBucketsDescriptor Timestamp(Timestamp timestamp) => Assign(timestamp, (a, v) => a.RouteValues.Optional("timestamp", v));
	// Request parameters
	}

	///<summary>descriptor for GetCalendarEvents <pre></pre></summary>
	public partial class GetCalendarEventsDescriptor : RequestDescriptorBase<GetCalendarEventsDescriptor, GetCalendarEventsRequestParameters, IGetCalendarEventsRequest>, IGetCalendarEventsRequest
	{
		internal override ApiUrls ApiUrls => GetCalendarEventsRequest.Urls;
		///<summary>/_ml/calendars/{calendar_id}/events</summary>
		///<param name = "calendar_id">this parameter is required</param>
		public GetCalendarEventsDescriptor(Id calendar_id): base(r => r.Required("calendar_id", calendar_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal GetCalendarEventsDescriptor(): base()
		{
		}

		// values part of the url path
		Id IGetCalendarEventsRequest.CalendarId => Self.RouteValues.Get<Id>("calendar_id");
		// Request parameters
		///<summary>Get events before this time</summary>
		public GetCalendarEventsDescriptor End(DateTimeOffset? end) => Qs("end", end);
		///<summary>Get events for the job. When this option is used calendar_id must be '_all'</summary>
		public GetCalendarEventsDescriptor JobId(string jobId) => Qs("job_id", jobId);
		///<summary>Get events after this time</summary>
		public GetCalendarEventsDescriptor Start(string start) => Qs("start", start);
	}

	///<summary>descriptor for GetCalendars <pre></pre></summary>
	public partial class GetCalendarsDescriptor : RequestDescriptorBase<GetCalendarsDescriptor, GetCalendarsRequestParameters, IGetCalendarsRequest>, IGetCalendarsRequest
	{
		internal override ApiUrls ApiUrls => GetCalendarsRequest.Urls;
		///<summary>/_ml/calendars</summary>
		public GetCalendarsDescriptor(): base()
		{
		}

		///<summary>/_ml/calendars/{calendar_id}</summary>
		///<param name = "calendar_id">Optional, accepts null</param>
		public GetCalendarsDescriptor(Id calendar_id): base(r => r.Optional("calendar_id", calendar_id))
		{
		}

		// values part of the url path
		Id IGetCalendarsRequest.CalendarId => Self.RouteValues.Get<Id>("calendar_id");
		///<summary>The ID of the calendar to fetch</summary>
		public GetCalendarsDescriptor CalendarId(Id calendarId) => Assign(calendarId, (a, v) => a.RouteValues.Optional("calendar_id", v));
	// Request parameters
	}

	///<summary>descriptor for GetCategories <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/ml-get-category.html</pre></summary>
	public partial class GetCategoriesDescriptor : RequestDescriptorBase<GetCategoriesDescriptor, GetCategoriesRequestParameters, IGetCategoriesRequest>, IGetCategoriesRequest
	{
		internal override ApiUrls ApiUrls => GetCategoriesRequest.Urls;
		///<summary>/_ml/anomaly_detectors/{job_id}/results/categories/{category_id}</summary>
		///<param name = "job_id">this parameter is required</param>
		///<param name = "category_id">Optional, accepts null</param>
		public GetCategoriesDescriptor(Id job_id, CategoryId category_id): base(r => r.Required("job_id", job_id).Optional("category_id", category_id))
		{
		}

		///<summary>/_ml/anomaly_detectors/{job_id}/results/categories/</summary>
		///<param name = "job_id">this parameter is required</param>
		public GetCategoriesDescriptor(Id job_id): base(r => r.Required("job_id", job_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal GetCategoriesDescriptor(): base()
		{
		}

		// values part of the url path
		Id IGetCategoriesRequest.JobId => Self.RouteValues.Get<Id>("job_id");
		CategoryId IGetCategoriesRequest.CategoryId => Self.RouteValues.Get<CategoryId>("category_id");
		///<summary>The identifier of the category definition of interest</summary>
		public GetCategoriesDescriptor CategoryId(CategoryId categoryId) => Assign(categoryId, (a, v) => a.RouteValues.Optional("category_id", v));
	// Request parameters
	}

	///<summary>descriptor for GetDatafeedStats <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/ml-get-datafeed-stats.html</pre></summary>
	public partial class GetDatafeedStatsDescriptor : RequestDescriptorBase<GetDatafeedStatsDescriptor, GetDatafeedStatsRequestParameters, IGetDatafeedStatsRequest>, IGetDatafeedStatsRequest
	{
		internal override ApiUrls ApiUrls => GetDatafeedStatsRequest.Urls;
		///<summary>/_ml/datafeeds/{datafeed_id}/_stats</summary>
		///<param name = "datafeed_id">Optional, accepts null</param>
		public GetDatafeedStatsDescriptor(Id datafeed_id): base(r => r.Optional("datafeed_id", datafeed_id))
		{
		}

		///<summary>/_ml/datafeeds/_stats</summary>
		public GetDatafeedStatsDescriptor(): base()
		{
		}

		// values part of the url path
		Id IGetDatafeedStatsRequest.DatafeedId => Self.RouteValues.Get<Id>("datafeed_id");
		///<summary>The ID of the datafeeds stats to fetch</summary>
		public GetDatafeedStatsDescriptor DatafeedId(Id datafeedId) => Assign(datafeedId, (a, v) => a.RouteValues.Optional("datafeed_id", v));
		// Request parameters
		///<summary>Whether to ignore if a wildcard expression matches no datafeeds. (This includes `_all` string or when no datafeeds have been specified)</summary>
		public GetDatafeedStatsDescriptor AllowNoDatafeeds(bool? allowNoDatafeeds = true) => Qs("allow_no_datafeeds", allowNoDatafeeds);
	}

	///<summary>descriptor for GetDatafeeds <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/ml-get-datafeed.html</pre></summary>
	public partial class GetDatafeedsDescriptor : RequestDescriptorBase<GetDatafeedsDescriptor, GetDatafeedsRequestParameters, IGetDatafeedsRequest>, IGetDatafeedsRequest
	{
		internal override ApiUrls ApiUrls => GetDatafeedsRequest.Urls;
		///<summary>/_ml/datafeeds/{datafeed_id}</summary>
		///<param name = "datafeed_id">Optional, accepts null</param>
		public GetDatafeedsDescriptor(Id datafeed_id): base(r => r.Optional("datafeed_id", datafeed_id))
		{
		}

		///<summary>/_ml/datafeeds</summary>
		public GetDatafeedsDescriptor(): base()
		{
		}

		// values part of the url path
		Id IGetDatafeedsRequest.DatafeedId => Self.RouteValues.Get<Id>("datafeed_id");
		///<summary>The ID of the datafeeds to fetch</summary>
		public GetDatafeedsDescriptor DatafeedId(Id datafeedId) => Assign(datafeedId, (a, v) => a.RouteValues.Optional("datafeed_id", v));
		// Request parameters
		///<summary>Whether to ignore if a wildcard expression matches no datafeeds. (This includes `_all` string or when no datafeeds have been specified)</summary>
		public GetDatafeedsDescriptor AllowNoDatafeeds(bool? allowNoDatafeeds = true) => Qs("allow_no_datafeeds", allowNoDatafeeds);
	}

	///<summary>descriptor for GetFilters <pre></pre></summary>
	public partial class GetFiltersDescriptor : RequestDescriptorBase<GetFiltersDescriptor, GetFiltersRequestParameters, IGetFiltersRequest>, IGetFiltersRequest
	{
		internal override ApiUrls ApiUrls => GetFiltersRequest.Urls;
		///<summary>/_ml/filters</summary>
		public GetFiltersDescriptor(): base()
		{
		}

		///<summary>/_ml/filters/{filter_id}</summary>
		///<param name = "filter_id">Optional, accepts null</param>
		public GetFiltersDescriptor(Id filter_id): base(r => r.Optional("filter_id", filter_id))
		{
		}

		// values part of the url path
		Id IGetFiltersRequest.FilterId => Self.RouteValues.Get<Id>("filter_id");
		///<summary>The ID of the filter to fetch</summary>
		public GetFiltersDescriptor FilterId(Id filterId) => Assign(filterId, (a, v) => a.RouteValues.Optional("filter_id", v));
		// Request parameters
		///<summary>skips a number of filters</summary>
		public GetFiltersDescriptor From(int? from) => Qs("from", from);
		///<summary>specifies a max number of filters to get</summary>
		public GetFiltersDescriptor Size(int? size) => Qs("size", size);
	}

	///<summary>descriptor for GetInfluencers <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/ml-get-influencer.html</pre></summary>
	public partial class GetInfluencersDescriptor : RequestDescriptorBase<GetInfluencersDescriptor, GetInfluencersRequestParameters, IGetInfluencersRequest>, IGetInfluencersRequest
	{
		internal override ApiUrls ApiUrls => GetInfluencersRequest.Urls;
		///<summary>/_ml/anomaly_detectors/{job_id}/results/influencers</summary>
		///<param name = "job_id">this parameter is required</param>
		public GetInfluencersDescriptor(Id job_id): base(r => r.Required("job_id", job_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal GetInfluencersDescriptor(): base()
		{
		}

		// values part of the url path
		Id IGetInfluencersRequest.JobId => Self.RouteValues.Get<Id>("job_id");
	// Request parameters
	}

	///<summary>descriptor for GetJobStats <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/ml-get-job-stats.html</pre></summary>
	public partial class GetJobStatsDescriptor : RequestDescriptorBase<GetJobStatsDescriptor, GetJobStatsRequestParameters, IGetJobStatsRequest>, IGetJobStatsRequest
	{
		internal override ApiUrls ApiUrls => GetJobStatsRequest.Urls;
		///<summary>/_ml/anomaly_detectors/_stats</summary>
		public GetJobStatsDescriptor(): base()
		{
		}

		///<summary>/_ml/anomaly_detectors/{job_id}/_stats</summary>
		///<param name = "job_id">Optional, accepts null</param>
		public GetJobStatsDescriptor(Id job_id): base(r => r.Optional("job_id", job_id))
		{
		}

		// values part of the url path
		Id IGetJobStatsRequest.JobId => Self.RouteValues.Get<Id>("job_id");
		///<summary>The ID of the jobs stats to fetch</summary>
		public GetJobStatsDescriptor JobId(Id jobId) => Assign(jobId, (a, v) => a.RouteValues.Optional("job_id", v));
		// Request parameters
		///<summary>Whether to ignore if a wildcard expression matches no jobs. (This includes `_all` string or when no jobs have been specified)</summary>
		public GetJobStatsDescriptor AllowNoJobs(bool? allowNoJobs = true) => Qs("allow_no_jobs", allowNoJobs);
	}

	///<summary>descriptor for GetJobs <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/ml-get-job.html</pre></summary>
	public partial class GetJobsDescriptor : RequestDescriptorBase<GetJobsDescriptor, GetJobsRequestParameters, IGetJobsRequest>, IGetJobsRequest
	{
		internal override ApiUrls ApiUrls => GetJobsRequest.Urls;
		///<summary>/_ml/anomaly_detectors/{job_id}</summary>
		///<param name = "job_id">Optional, accepts null</param>
		public GetJobsDescriptor(Id job_id): base(r => r.Optional("job_id", job_id))
		{
		}

		///<summary>/_ml/anomaly_detectors</summary>
		public GetJobsDescriptor(): base()
		{
		}

		// values part of the url path
		Id IGetJobsRequest.JobId => Self.RouteValues.Get<Id>("job_id");
		///<summary>The ID of the jobs to fetch</summary>
		public GetJobsDescriptor JobId(Id jobId) => Assign(jobId, (a, v) => a.RouteValues.Optional("job_id", v));
		// Request parameters
		///<summary>Whether to ignore if a wildcard expression matches no jobs. (This includes `_all` string or when no jobs have been specified)</summary>
		public GetJobsDescriptor AllowNoJobs(bool? allowNoJobs = true) => Qs("allow_no_jobs", allowNoJobs);
	}

	///<summary>descriptor for GetModelSnapshots <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/ml-get-snapshot.html</pre></summary>
	public partial class GetModelSnapshotsDescriptor : RequestDescriptorBase<GetModelSnapshotsDescriptor, GetModelSnapshotsRequestParameters, IGetModelSnapshotsRequest>, IGetModelSnapshotsRequest
	{
		internal override ApiUrls ApiUrls => GetModelSnapshotsRequest.Urls;
		///<summary>/_ml/anomaly_detectors/{job_id}/model_snapshots/{snapshot_id}</summary>
		///<param name = "job_id">this parameter is required</param>
		///<param name = "snapshot_id">Optional, accepts null</param>
		public GetModelSnapshotsDescriptor(Id job_id, Id snapshot_id): base(r => r.Required("job_id", job_id).Optional("snapshot_id", snapshot_id))
		{
		}

		///<summary>/_ml/anomaly_detectors/{job_id}/model_snapshots</summary>
		///<param name = "job_id">this parameter is required</param>
		public GetModelSnapshotsDescriptor(Id job_id): base(r => r.Required("job_id", job_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal GetModelSnapshotsDescriptor(): base()
		{
		}

		// values part of the url path
		Id IGetModelSnapshotsRequest.JobId => Self.RouteValues.Get<Id>("job_id");
		Id IGetModelSnapshotsRequest.SnapshotId => Self.RouteValues.Get<Id>("snapshot_id");
		///<summary>The ID of the snapshot to fetch</summary>
		public GetModelSnapshotsDescriptor SnapshotId(Id snapshotId) => Assign(snapshotId, (a, v) => a.RouteValues.Optional("snapshot_id", v));
	// Request parameters
	}

	///<summary>descriptor for GetOverallBuckets <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/ml-get-overall-buckets.html</pre></summary>
	public partial class GetOverallBucketsDescriptor : RequestDescriptorBase<GetOverallBucketsDescriptor, GetOverallBucketsRequestParameters, IGetOverallBucketsRequest>, IGetOverallBucketsRequest
	{
		internal override ApiUrls ApiUrls => GetOverallBucketsRequest.Urls;
		///<summary>/_ml/anomaly_detectors/{job_id}/results/overall_buckets</summary>
		///<param name = "job_id">this parameter is required</param>
		public GetOverallBucketsDescriptor(Id job_id): base(r => r.Required("job_id", job_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal GetOverallBucketsDescriptor(): base()
		{
		}

		// values part of the url path
		Id IGetOverallBucketsRequest.JobId => Self.RouteValues.Get<Id>("job_id");
	// Request parameters
	}

	///<summary>descriptor for GetAnomalyRecords <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/ml-get-record.html</pre></summary>
	public partial class GetAnomalyRecordsDescriptor : RequestDescriptorBase<GetAnomalyRecordsDescriptor, GetAnomalyRecordsRequestParameters, IGetAnomalyRecordsRequest>, IGetAnomalyRecordsRequest
	{
		internal override ApiUrls ApiUrls => GetAnomalyRecordsRequest.Urls;
		///<summary>/_ml/anomaly_detectors/{job_id}/results/records</summary>
		///<param name = "job_id">this parameter is required</param>
		public GetAnomalyRecordsDescriptor(Id job_id): base(r => r.Required("job_id", job_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal GetAnomalyRecordsDescriptor(): base()
		{
		}

		// values part of the url path
		Id IGetAnomalyRecordsRequest.JobId => Self.RouteValues.Get<Id>("job_id");
	// Request parameters
	}

	///<summary>descriptor for Info <pre></pre></summary>
	public partial class MachineLearningInfoDescriptor : RequestDescriptorBase<MachineLearningInfoDescriptor, MachineLearningInfoRequestParameters, IMachineLearningInfoRequest>, IMachineLearningInfoRequest
	{
		internal override ApiUrls ApiUrls => MachineLearningInfoRequest.Urls;
	// values part of the url path
	// Request parameters
	}

	///<summary>descriptor for OpenJob <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/ml-open-job.html</pre></summary>
	public partial class OpenJobDescriptor : RequestDescriptorBase<OpenJobDescriptor, OpenJobRequestParameters, IOpenJobRequest>, IOpenJobRequest
	{
		internal override ApiUrls ApiUrls => OpenJobRequest.Urls;
		///<summary>/_ml/anomaly_detectors/{job_id}/_open</summary>
		///<param name = "job_id">this parameter is required</param>
		public OpenJobDescriptor(Id job_id): base(r => r.Required("job_id", job_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal OpenJobDescriptor(): base()
		{
		}

		// values part of the url path
		Id IOpenJobRequest.JobId => Self.RouteValues.Get<Id>("job_id");
	// Request parameters
	}

	///<summary>descriptor for PostCalendarEvents <pre></pre></summary>
	public partial class PostCalendarEventsDescriptor : RequestDescriptorBase<PostCalendarEventsDescriptor, PostCalendarEventsRequestParameters, IPostCalendarEventsRequest>, IPostCalendarEventsRequest
	{
		internal override ApiUrls ApiUrls => PostCalendarEventsRequest.Urls;
		///<summary>/_ml/calendars/{calendar_id}/events</summary>
		///<param name = "calendar_id">this parameter is required</param>
		public PostCalendarEventsDescriptor(Id calendar_id): base(r => r.Required("calendar_id", calendar_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal PostCalendarEventsDescriptor(): base()
		{
		}

		// values part of the url path
		Id IPostCalendarEventsRequest.CalendarId => Self.RouteValues.Get<Id>("calendar_id");
	// Request parameters
	}

	///<summary>descriptor for PostJobData <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/ml-post-data.html</pre></summary>
	public partial class PostJobDataDescriptor : RequestDescriptorBase<PostJobDataDescriptor, PostJobDataRequestParameters, IPostJobDataRequest>, IPostJobDataRequest
	{
		internal override ApiUrls ApiUrls => PostJobDataRequest.Urls;
		///<summary>/_ml/anomaly_detectors/{job_id}/_data</summary>
		///<param name = "job_id">this parameter is required</param>
		public PostJobDataDescriptor(Id job_id): base(r => r.Required("job_id", job_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal PostJobDataDescriptor(): base()
		{
		}

		// values part of the url path
		Id IPostJobDataRequest.JobId => Self.RouteValues.Get<Id>("job_id");
		// Request parameters
		///<summary>Optional parameter to specify the end of the bucket resetting range</summary>
		public PostJobDataDescriptor ResetEnd(DateTimeOffset? resetEnd) => Qs("reset_end", resetEnd);
		///<summary>Optional parameter to specify the start of the bucket resetting range</summary>
		public PostJobDataDescriptor ResetStart(DateTimeOffset? resetStart) => Qs("reset_start", resetStart);
	}

	///<summary>descriptor for PreviewDatafeed <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/ml-preview-datafeed.html</pre></summary>
	public partial class PreviewDatafeedDescriptor : RequestDescriptorBase<PreviewDatafeedDescriptor, PreviewDatafeedRequestParameters, IPreviewDatafeedRequest>, IPreviewDatafeedRequest
	{
		internal override ApiUrls ApiUrls => PreviewDatafeedRequest.Urls;
		///<summary>/_ml/datafeeds/{datafeed_id}/_preview</summary>
		///<param name = "datafeed_id">this parameter is required</param>
		public PreviewDatafeedDescriptor(Id datafeed_id): base(r => r.Required("datafeed_id", datafeed_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal PreviewDatafeedDescriptor(): base()
		{
		}

		// values part of the url path
		Id IPreviewDatafeedRequest.DatafeedId => Self.RouteValues.Get<Id>("datafeed_id");
	// Request parameters
	}

	///<summary>descriptor for PutCalendar <pre></pre></summary>
	public partial class PutCalendarDescriptor : RequestDescriptorBase<PutCalendarDescriptor, PutCalendarRequestParameters, IPutCalendarRequest>, IPutCalendarRequest
	{
		internal override ApiUrls ApiUrls => PutCalendarRequest.Urls;
		///<summary>/_ml/calendars/{calendar_id}</summary>
		///<param name = "calendar_id">this parameter is required</param>
		public PutCalendarDescriptor(Id calendar_id): base(r => r.Required("calendar_id", calendar_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal PutCalendarDescriptor(): base()
		{
		}

		// values part of the url path
		Id IPutCalendarRequest.CalendarId => Self.RouteValues.Get<Id>("calendar_id");
	// Request parameters
	}

	///<summary>descriptor for PutCalendarJob <pre></pre></summary>
	public partial class PutCalendarJobDescriptor : RequestDescriptorBase<PutCalendarJobDescriptor, PutCalendarJobRequestParameters, IPutCalendarJobRequest>, IPutCalendarJobRequest
	{
		internal override ApiUrls ApiUrls => PutCalendarJobRequest.Urls;
		///<summary>/_ml/calendars/{calendar_id}/jobs/{job_id}</summary>
		///<param name = "calendar_id">this parameter is required</param>
		///<param name = "job_id">this parameter is required</param>
		public PutCalendarJobDescriptor(Id calendar_id, Id job_id): base(r => r.Required("calendar_id", calendar_id).Required("job_id", job_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal PutCalendarJobDescriptor(): base()
		{
		}

		// values part of the url path
		Id IPutCalendarJobRequest.CalendarId => Self.RouteValues.Get<Id>("calendar_id");
		Id IPutCalendarJobRequest.JobId => Self.RouteValues.Get<Id>("job_id");
	// Request parameters
	}

	///<summary>descriptor for PutDatafeed <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/ml-put-datafeed.html</pre></summary>
	public partial class PutDatafeedDescriptor<T> : RequestDescriptorBase<PutDatafeedDescriptor<T>, PutDatafeedRequestParameters, IPutDatafeedRequest>, IPutDatafeedRequest
	{
		internal override ApiUrls ApiUrls => PutDatafeedRequest.Urls;
		///<summary>/_ml/datafeeds/{datafeed_id}</summary>
		///<param name = "datafeed_id">this parameter is required</param>
		public PutDatafeedDescriptor(Id datafeed_id): base(r => r.Required("datafeed_id", datafeed_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal PutDatafeedDescriptor(): base()
		{
		}

		// values part of the url path
		Id IPutDatafeedRequest.DatafeedId => Self.RouteValues.Get<Id>("datafeed_id");
	// Request parameters
	}

	///<summary>descriptor for PutFilter <pre></pre></summary>
	public partial class PutFilterDescriptor : RequestDescriptorBase<PutFilterDescriptor, PutFilterRequestParameters, IPutFilterRequest>, IPutFilterRequest
	{
		internal override ApiUrls ApiUrls => PutFilterRequest.Urls;
		///<summary>/_ml/filters/{filter_id}</summary>
		///<param name = "filter_id">this parameter is required</param>
		public PutFilterDescriptor(Id filter_id): base(r => r.Required("filter_id", filter_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal PutFilterDescriptor(): base()
		{
		}

		// values part of the url path
		Id IPutFilterRequest.FilterId => Self.RouteValues.Get<Id>("filter_id");
	// Request parameters
	}

	///<summary>descriptor for PutJob <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/ml-put-job.html</pre></summary>
	public partial class PutJobDescriptor<T> : RequestDescriptorBase<PutJobDescriptor<T>, PutJobRequestParameters, IPutJobRequest>, IPutJobRequest
	{
		internal override ApiUrls ApiUrls => PutJobRequest.Urls;
		///<summary>/_ml/anomaly_detectors/{job_id}</summary>
		///<param name = "job_id">this parameter is required</param>
		public PutJobDescriptor(Id job_id): base(r => r.Required("job_id", job_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal PutJobDescriptor(): base()
		{
		}

		// values part of the url path
		Id IPutJobRequest.JobId => Self.RouteValues.Get<Id>("job_id");
	// Request parameters
	}

	///<summary>descriptor for RevertModelSnapshot <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/ml-revert-snapshot.html</pre></summary>
	public partial class RevertModelSnapshotDescriptor : RequestDescriptorBase<RevertModelSnapshotDescriptor, RevertModelSnapshotRequestParameters, IRevertModelSnapshotRequest>, IRevertModelSnapshotRequest
	{
		internal override ApiUrls ApiUrls => RevertModelSnapshotRequest.Urls;
		///<summary>/_ml/anomaly_detectors/{job_id}/model_snapshots/{snapshot_id}/_revert</summary>
		///<param name = "job_id">this parameter is required</param>
		///<param name = "snapshot_id">this parameter is required</param>
		public RevertModelSnapshotDescriptor(Id job_id, Id snapshot_id): base(r => r.Required("job_id", job_id).Required("snapshot_id", snapshot_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal RevertModelSnapshotDescriptor(): base()
		{
		}

		// values part of the url path
		Id IRevertModelSnapshotRequest.JobId => Self.RouteValues.Get<Id>("job_id");
		Id IRevertModelSnapshotRequest.SnapshotId => Self.RouteValues.Get<Id>("snapshot_id");
	// Request parameters
	}

	///<summary>descriptor for StartDatafeed <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/ml-start-datafeed.html</pre></summary>
	public partial class StartDatafeedDescriptor : RequestDescriptorBase<StartDatafeedDescriptor, StartDatafeedRequestParameters, IStartDatafeedRequest>, IStartDatafeedRequest
	{
		internal override ApiUrls ApiUrls => StartDatafeedRequest.Urls;
		///<summary>/_ml/datafeeds/{datafeed_id}/_start</summary>
		///<param name = "datafeed_id">this parameter is required</param>
		public StartDatafeedDescriptor(Id datafeed_id): base(r => r.Required("datafeed_id", datafeed_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal StartDatafeedDescriptor(): base()
		{
		}

		// values part of the url path
		Id IStartDatafeedRequest.DatafeedId => Self.RouteValues.Get<Id>("datafeed_id");
	// Request parameters
	}

	///<summary>descriptor for StopDatafeed <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/ml-stop-datafeed.html</pre></summary>
	public partial class StopDatafeedDescriptor : RequestDescriptorBase<StopDatafeedDescriptor, StopDatafeedRequestParameters, IStopDatafeedRequest>, IStopDatafeedRequest
	{
		internal override ApiUrls ApiUrls => StopDatafeedRequest.Urls;
		///<summary>/_ml/datafeeds/{datafeed_id}/_stop</summary>
		///<param name = "datafeed_id">this parameter is required</param>
		public StopDatafeedDescriptor(Id datafeed_id): base(r => r.Required("datafeed_id", datafeed_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal StopDatafeedDescriptor(): base()
		{
		}

		// values part of the url path
		Id IStopDatafeedRequest.DatafeedId => Self.RouteValues.Get<Id>("datafeed_id");
		// Request parameters
		///<summary>Whether to ignore if a wildcard expression matches no datafeeds. (This includes `_all` string or when no datafeeds have been specified)</summary>
		public StopDatafeedDescriptor AllowNoDatafeeds(bool? allowNoDatafeeds = true) => Qs("allow_no_datafeeds", allowNoDatafeeds);
	}

	///<summary>descriptor for UpdateDatafeed <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/ml-update-datafeed.html</pre></summary>
	public partial class UpdateDatafeedDescriptor<T> : RequestDescriptorBase<UpdateDatafeedDescriptor<T>, UpdateDatafeedRequestParameters, IUpdateDatafeedRequest>, IUpdateDatafeedRequest
	{
		internal override ApiUrls ApiUrls => UpdateDatafeedRequest.Urls;
		///<summary>/_ml/datafeeds/{datafeed_id}/_update</summary>
		///<param name = "datafeed_id">this parameter is required</param>
		public UpdateDatafeedDescriptor(Id datafeed_id): base(r => r.Required("datafeed_id", datafeed_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal UpdateDatafeedDescriptor(): base()
		{
		}

		// values part of the url path
		Id IUpdateDatafeedRequest.DatafeedId => Self.RouteValues.Get<Id>("datafeed_id");
	// Request parameters
	}

	///<summary>descriptor for UpdateFilter <pre></pre></summary>
	public partial class UpdateFilterDescriptor : RequestDescriptorBase<UpdateFilterDescriptor, UpdateFilterRequestParameters, IUpdateFilterRequest>, IUpdateFilterRequest
	{
		internal override ApiUrls ApiUrls => UpdateFilterRequest.Urls;
		///<summary>/_ml/filters/{filter_id}/_update</summary>
		///<param name = "filter_id">this parameter is required</param>
		public UpdateFilterDescriptor(Id filter_id): base(r => r.Required("filter_id", filter_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal UpdateFilterDescriptor(): base()
		{
		}

		// values part of the url path
		Id IUpdateFilterRequest.FilterId => Self.RouteValues.Get<Id>("filter_id");
	// Request parameters
	}

	///<summary>descriptor for UpdateJob <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/ml-update-job.html</pre></summary>
	public partial class UpdateJobDescriptor<T> : RequestDescriptorBase<UpdateJobDescriptor<T>, UpdateJobRequestParameters, IUpdateJobRequest>, IUpdateJobRequest
	{
		internal override ApiUrls ApiUrls => UpdateJobRequest.Urls;
		///<summary>/_ml/anomaly_detectors/{job_id}/_update</summary>
		///<param name = "job_id">this parameter is required</param>
		public UpdateJobDescriptor(Id job_id): base(r => r.Required("job_id", job_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal UpdateJobDescriptor(): base()
		{
		}

		// values part of the url path
		Id IUpdateJobRequest.JobId => Self.RouteValues.Get<Id>("job_id");
	// Request parameters
	}

	///<summary>descriptor for UpdateModelSnapshot <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/ml-update-snapshot.html</pre></summary>
	public partial class UpdateModelSnapshotDescriptor : RequestDescriptorBase<UpdateModelSnapshotDescriptor, UpdateModelSnapshotRequestParameters, IUpdateModelSnapshotRequest>, IUpdateModelSnapshotRequest
	{
		internal override ApiUrls ApiUrls => UpdateModelSnapshotRequest.Urls;
		///<summary>/_ml/anomaly_detectors/{job_id}/model_snapshots/{snapshot_id}/_update</summary>
		///<param name = "job_id">this parameter is required</param>
		///<param name = "snapshot_id">this parameter is required</param>
		public UpdateModelSnapshotDescriptor(Id job_id, Id snapshot_id): base(r => r.Required("job_id", job_id).Required("snapshot_id", snapshot_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal UpdateModelSnapshotDescriptor(): base()
		{
		}

		// values part of the url path
		Id IUpdateModelSnapshotRequest.JobId => Self.RouteValues.Get<Id>("job_id");
		Id IUpdateModelSnapshotRequest.SnapshotId => Self.RouteValues.Get<Id>("snapshot_id");
	// Request parameters
	}

	///<summary>descriptor for ValidateJob <pre></pre></summary>
	public partial class ValidateJobDescriptor<T> : RequestDescriptorBase<ValidateJobDescriptor<T>, ValidateJobRequestParameters, IValidateJobRequest>, IValidateJobRequest
	{
		internal override ApiUrls ApiUrls => ValidateJobRequest.Urls;
	// values part of the url path
	// Request parameters
	}

	///<summary>descriptor for ValidateDetector <pre></pre></summary>
	public partial class ValidateDetectorDescriptor<T> : RequestDescriptorBase<ValidateDetectorDescriptor<T>, ValidateDetectorRequestParameters, IValidateDetectorRequest>, IValidateDetectorRequest
	{
		internal override ApiUrls ApiUrls => ValidateDetectorRequest.Urls;
	// values part of the url path
	// Request parameters
	}

	///<summary>descriptor for MultiSearch <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/search-multi-search.html</pre></summary>
	public partial class MultiSearchDescriptor : RequestDescriptorBase<MultiSearchDescriptor, MultiSearchRequestParameters, IMultiSearchRequest>, IMultiSearchRequest
	{
		internal override ApiUrls ApiUrls => MultiSearchRequest.Urls;
		///<summary>/_msearch</summary>
		public MultiSearchDescriptor(): base()
		{
		}

		///<summary>/{index}/_msearch</summary>
		///<param name = "index">Optional, accepts null</param>
		public MultiSearchDescriptor(Indices index): base(r => r.Optional("index", index))
		{
		}

		// values part of the url path
		Indices IMultiSearchRequest.Index => Self.RouteValues.Get<Indices>("index");
		///<summary>A comma-separated list of index names to use as default</summary>
		public MultiSearchDescriptor Index(Indices index) => Assign(index, (a, v) => a.RouteValues.Optional("index", v));
		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public MultiSearchDescriptor Index<TOther>()
			where TOther : class => Assign(typeof(TOther), (a, v) => a.RouteValues.Optional("index", (Indices)v));
		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public MultiSearchDescriptor AllIndices() => this.Index(Indices.All);
		// Request parameters
		///<summary>Indicates whether network round-trips should be minimized as part of cross-cluster search requests execution</summary>
		public MultiSearchDescriptor CcsMinimizeRoundtrips(bool? ccsMinimizeRoundtrips = true) => Qs("ccs_minimize_roundtrips", ccsMinimizeRoundtrips);
		///<summary>Controls the maximum number of concurrent searches the multi search api will execute</summary>
		public MultiSearchDescriptor MaxConcurrentSearches(long? maxConcurrentSearches) => Qs("max_concurrent_searches", maxConcurrentSearches);
		///<summary>The number of concurrent shard requests each sub search executes concurrently. This value should be used to limit the impact of the search on the cluster in order to limit the number of concurrent shard requests</summary>
		public MultiSearchDescriptor MaxConcurrentShardRequests(long? maxConcurrentShardRequests) => Qs("max_concurrent_shard_requests", maxConcurrentShardRequests);
		///<summary>A threshold that enforces a pre-filter roundtrip to prefilter search shards based on query rewriting if thenumber of shards the search request expands to exceeds the threshold. This filter roundtrip can limit the number of shards significantly if for instance a shard can not match any documents based on it's rewrite method ie. if date filters are mandatory to match but the shard bounds and the query are disjoint.</summary>
		public MultiSearchDescriptor PreFilterShardSize(long? preFilterShardSize) => Qs("pre_filter_shard_size", preFilterShardSize);
		///<summary>Search operation type</summary>
		public MultiSearchDescriptor SearchType(SearchType? searchType) => Qs("search_type", searchType);
		///<summary>Indicates whether hits.total should be rendered as an integer or an object in the rest search response</summary>
		public MultiSearchDescriptor TotalHitsAsInteger(bool? totalHitsAsInteger = true) => Qs("rest_total_hits_as_int", totalHitsAsInteger);
		///<summary>Specify whether aggregation and suggester names should be prefixed by their respective types in the response</summary>
		public MultiSearchDescriptor TypedKeys(bool? typedKeys = true) => Qs("typed_keys", typedKeys);
	}

	///<summary>descriptor for MultiSearchTemplate <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/search-multi-search.html</pre></summary>
	public partial class MultiSearchTemplateDescriptor : RequestDescriptorBase<MultiSearchTemplateDescriptor, MultiSearchTemplateRequestParameters, IMultiSearchTemplateRequest>, IMultiSearchTemplateRequest
	{
		internal override ApiUrls ApiUrls => MultiSearchTemplateRequest.Urls;
		///<summary>/_msearch/template</summary>
		public MultiSearchTemplateDescriptor(): base()
		{
		}

		///<summary>/{index}/_msearch/template</summary>
		///<param name = "index">Optional, accepts null</param>
		public MultiSearchTemplateDescriptor(Indices index): base(r => r.Optional("index", index))
		{
		}

		// values part of the url path
		Indices IMultiSearchTemplateRequest.Index => Self.RouteValues.Get<Indices>("index");
		///<summary>A comma-separated list of index names to use as default</summary>
		public MultiSearchTemplateDescriptor Index(Indices index) => Assign(index, (a, v) => a.RouteValues.Optional("index", v));
		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public MultiSearchTemplateDescriptor Index<TOther>()
			where TOther : class => Assign(typeof(TOther), (a, v) => a.RouteValues.Optional("index", (Indices)v));
		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public MultiSearchTemplateDescriptor AllIndices() => this.Index(Indices.All);
		// Request parameters
		///<summary>Indicates whether network round-trips should be minimized as part of cross-cluster search requests execution</summary>
		public MultiSearchTemplateDescriptor CcsMinimizeRoundtrips(bool? ccsMinimizeRoundtrips = true) => Qs("ccs_minimize_roundtrips", ccsMinimizeRoundtrips);
		///<summary>Controls the maximum number of concurrent searches the multi search api will execute</summary>
		public MultiSearchTemplateDescriptor MaxConcurrentSearches(long? maxConcurrentSearches) => Qs("max_concurrent_searches", maxConcurrentSearches);
		///<summary>Search operation type</summary>
		public MultiSearchTemplateDescriptor SearchType(SearchType? searchType) => Qs("search_type", searchType);
		///<summary>Indicates whether hits.total should be rendered as an integer or an object in the rest search response</summary>
		public MultiSearchTemplateDescriptor TotalHitsAsInteger(bool? totalHitsAsInteger = true) => Qs("rest_total_hits_as_int", totalHitsAsInteger);
		///<summary>Specify whether aggregation and suggester names should be prefixed by their respective types in the response</summary>
		public MultiSearchTemplateDescriptor TypedKeys(bool? typedKeys = true) => Qs("typed_keys", typedKeys);
	}

	///<summary>descriptor for MultiTermVectors <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-multi-termvectors.html</pre></summary>
	public partial class MultiTermVectorsDescriptor : RequestDescriptorBase<MultiTermVectorsDescriptor, MultiTermVectorsRequestParameters, IMultiTermVectorsRequest>, IMultiTermVectorsRequest
	{
		internal override ApiUrls ApiUrls => MultiTermVectorsRequest.Urls;
		///<summary>/_mtermvectors</summary>
		public MultiTermVectorsDescriptor(): base()
		{
		}

		///<summary>/{index}/_mtermvectors</summary>
		///<param name = "index">Optional, accepts null</param>
		public MultiTermVectorsDescriptor(IndexName index): base(r => r.Optional("index", index))
		{
		}

		// values part of the url path
		IndexName IMultiTermVectorsRequest.Index => Self.RouteValues.Get<IndexName>("index");
		///<summary>The index in which the document resides.</summary>
		public MultiTermVectorsDescriptor Index(IndexName index) => Assign(index, (a, v) => a.RouteValues.Optional("index", v));
		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public MultiTermVectorsDescriptor Index<TOther>()
			where TOther : class => Assign(typeof(TOther), (a, v) => a.RouteValues.Optional("index", (IndexName)v));
		// Request parameters
		///<summary>Specifies if document count, sum of document frequencies and sum of total term frequencies should be returned. Applies to all returned documents unless otherwise specified in body "params" or "docs".</summary>
		public MultiTermVectorsDescriptor FieldStatistics(bool? fieldStatistics = true) => Qs("field_statistics", fieldStatistics);
		///<summary>A comma-separated list of fields to return. Applies to all returned documents unless otherwise specified in body "params" or "docs".</summary>
		public MultiTermVectorsDescriptor Fields(Fields fields) => Qs("fields", fields);
		///<summary>A comma-separated list of fields to return. Applies to all returned documents unless otherwise specified in body &quot;params&quot; or &quot;docs&quot;.</summary>
		public MultiTermVectorsDescriptor Fields<T>(params Expression<Func<T, object>>[] fields)
			where T : class => Qs("fields", fields?.Select(e => (Field)e));
		///<summary>Specifies if term offsets should be returned. Applies to all returned documents unless otherwise specified in body "params" or "docs".</summary>
		public MultiTermVectorsDescriptor Offsets(bool? offsets = true) => Qs("offsets", offsets);
		///<summary>Specifies if term payloads should be returned. Applies to all returned documents unless otherwise specified in body "params" or "docs".</summary>
		public MultiTermVectorsDescriptor Payloads(bool? payloads = true) => Qs("payloads", payloads);
		///<summary>Specifies if term positions should be returned. Applies to all returned documents unless otherwise specified in body "params" or "docs".</summary>
		public MultiTermVectorsDescriptor Positions(bool? positions = true) => Qs("positions", positions);
		///<summary>Specify the node or shard the operation should be performed on (default: random) .Applies to all returned documents unless otherwise specified in body "params" or "docs".</summary>
		public MultiTermVectorsDescriptor Preference(string preference) => Qs("preference", preference);
		///<summary>Specifies if requests are real-time as opposed to near-real-time (default: true).</summary>
		public MultiTermVectorsDescriptor Realtime(bool? realtime = true) => Qs("realtime", realtime);
		///<summary>
		/// A document is routed to a particular shard in an index using the following formula
		/// <para> shard_num = hash(_routing) % num_primary_shards</para>
		/// <para>Elasticsearch will use the document id if not provided. </para>
		/// <para>For requests that are constructed from/for a document NEST will automatically infer the routing key
		/// if that document has a <see cref = "Nest.JoinField"/> or a routing mapping on for its type exists on <see cref = "Nest.ConnectionSettings"/></para> 
		///</summary>
		public MultiTermVectorsDescriptor Routing(Routing routing) => Qs("routing", routing);
		///<summary>Specifies if total term frequency and document frequency should be returned. Applies to all returned documents unless otherwise specified in body "params" or "docs".</summary>
		public MultiTermVectorsDescriptor TermStatistics(bool? termStatistics = true) => Qs("term_statistics", termStatistics);
		///<summary>Explicit version number for concurrency control</summary>
		public MultiTermVectorsDescriptor Version(long? version) => Qs("version", version);
		///<summary>Specific version type</summary>
		public MultiTermVectorsDescriptor VersionType(VersionType? versionType) => Qs("version_type", versionType);
	}

	///<summary>descriptor for HotThreads <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-nodes-hot-threads.html</pre></summary>
	public partial class NodesHotThreadsDescriptor : RequestDescriptorBase<NodesHotThreadsDescriptor, NodesHotThreadsRequestParameters, INodesHotThreadsRequest>, INodesHotThreadsRequest
	{
		internal override ApiUrls ApiUrls => NodesHotThreadsRequest.Urls;
		///<summary>/_nodes/hot_threads</summary>
		public NodesHotThreadsDescriptor(): base()
		{
		}

		///<summary>/_nodes/{node_id}/hot_threads</summary>
		///<param name = "node_id">Optional, accepts null</param>
		public NodesHotThreadsDescriptor(NodeIds node_id): base(r => r.Optional("node_id", node_id))
		{
		}

		// values part of the url path
		NodeIds INodesHotThreadsRequest.NodeId => Self.RouteValues.Get<NodeIds>("node_id");
		///<summary>A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes</summary>
		public NodesHotThreadsDescriptor NodeId(NodeIds nodeId) => Assign(nodeId, (a, v) => a.RouteValues.Optional("node_id", v));
		// Request parameters
		///<summary>Don't show threads that are in known-idle places, such as waiting on a socket select or pulling from an empty task queue (default: true)</summary>
		public NodesHotThreadsDescriptor IgnoreIdleThreads(bool? ignoreIdleThreads = true) => Qs("ignore_idle_threads", ignoreIdleThreads);
		///<summary>The interval for the second sampling of threads</summary>
		public NodesHotThreadsDescriptor Interval(Time interval) => Qs("interval", interval);
		///<summary>Number of samples of thread stacktrace (default: 10)</summary>
		public NodesHotThreadsDescriptor Snapshots(long? snapshots) => Qs("snapshots", snapshots);
		///<summary>The type to sample (default: cpu)</summary>
		public NodesHotThreadsDescriptor ThreadType(ThreadType? threadType) => Qs("type", threadType);
		///<summary>Specify the number of threads to provide information for (default: 3)</summary>
		public NodesHotThreadsDescriptor Threads(long? threads) => Qs("threads", threads);
		///<summary>Explicit operation timeout</summary>
		public NodesHotThreadsDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
	}

	///<summary>descriptor for Info <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-nodes-info.html</pre></summary>
	public partial class NodesInfoDescriptor : RequestDescriptorBase<NodesInfoDescriptor, NodesInfoRequestParameters, INodesInfoRequest>, INodesInfoRequest
	{
		internal override ApiUrls ApiUrls => NodesInfoRequest.Urls;
		///<summary>/_nodes</summary>
		public NodesInfoDescriptor(): base()
		{
		}

		///<summary>/_nodes/{node_id}</summary>
		///<param name = "node_id">Optional, accepts null</param>
		public NodesInfoDescriptor(NodeIds node_id): base(r => r.Optional("node_id", node_id))
		{
		}

		///<summary>/_nodes/{metric}</summary>
		///<param name = "metric">Optional, accepts null</param>
		public NodesInfoDescriptor(Metrics metric): base(r => r.Optional("metric", metric))
		{
		}

		///<summary>/_nodes/{node_id}/{metric}</summary>
		///<param name = "node_id">Optional, accepts null</param>
		///<param name = "metric">Optional, accepts null</param>
		public NodesInfoDescriptor(NodeIds node_id, Metrics metric): base(r => r.Optional("node_id", node_id).Optional("metric", metric))
		{
		}

		// values part of the url path
		NodeIds INodesInfoRequest.NodeId => Self.RouteValues.Get<NodeIds>("node_id");
		Metrics INodesInfoRequest.Metric => Self.RouteValues.Get<Metrics>("metric");
		///<summary>A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes</summary>
		public NodesInfoDescriptor NodeId(NodeIds nodeId) => Assign(nodeId, (a, v) => a.RouteValues.Optional("node_id", v));
		///<summary>A comma-separated list of metrics you wish returned. Leave empty to return all.</summary>
		public NodesInfoDescriptor Metric(Metrics metric) => Assign(metric, (a, v) => a.RouteValues.Optional("metric", (Metrics)v));
		// Request parameters
		///<summary>Return settings in flat format (default: false)</summary>
		public NodesInfoDescriptor FlatSettings(bool? flatSettings = true) => Qs("flat_settings", flatSettings);
		///<summary>Explicit operation timeout</summary>
		public NodesInfoDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
	}

	///<summary>descriptor for ReloadSecureSettings <pre>https://www.elastic.co/guide/en/elasticsearch/reference/master/secure-settings.html#reloadable-secure-settings</pre></summary>
	public partial class ReloadSecureSettingsDescriptor : RequestDescriptorBase<ReloadSecureSettingsDescriptor, ReloadSecureSettingsRequestParameters, IReloadSecureSettingsRequest>, IReloadSecureSettingsRequest
	{
		internal override ApiUrls ApiUrls => ReloadSecureSettingsRequest.Urls;
		///<summary>/_nodes/reload_secure_settings</summary>
		public ReloadSecureSettingsDescriptor(): base()
		{
		}

		///<summary>/_nodes/{node_id}/reload_secure_settings</summary>
		///<param name = "node_id">Optional, accepts null</param>
		public ReloadSecureSettingsDescriptor(NodeIds node_id): base(r => r.Optional("node_id", node_id))
		{
		}

		// values part of the url path
		NodeIds IReloadSecureSettingsRequest.NodeId => Self.RouteValues.Get<NodeIds>("node_id");
		///<summary>A comma-separated list of node IDs to span the reload/reinit call. Should stay empty because reloading usually involves all cluster nodes.</summary>
		public ReloadSecureSettingsDescriptor NodeId(NodeIds nodeId) => Assign(nodeId, (a, v) => a.RouteValues.Optional("node_id", v));
		// Request parameters
		///<summary>Explicit operation timeout</summary>
		public ReloadSecureSettingsDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
	}

	///<summary>descriptor for Stats <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-nodes-stats.html</pre></summary>
	public partial class NodesStatsDescriptor : RequestDescriptorBase<NodesStatsDescriptor, NodesStatsRequestParameters, INodesStatsRequest>, INodesStatsRequest
	{
		internal override ApiUrls ApiUrls => NodesStatsRequest.Urls;
		///<summary>/_nodes/stats</summary>
		public NodesStatsDescriptor(): base()
		{
		}

		///<summary>/_nodes/{node_id}/stats</summary>
		///<param name = "node_id">Optional, accepts null</param>
		public NodesStatsDescriptor(NodeIds node_id): base(r => r.Optional("node_id", node_id))
		{
		}

		///<summary>/_nodes/stats/{metric}</summary>
		///<param name = "metric">Optional, accepts null</param>
		public NodesStatsDescriptor(Metrics metric): base(r => r.Optional("metric", metric))
		{
		}

		///<summary>/_nodes/{node_id}/stats/{metric}</summary>
		///<param name = "node_id">Optional, accepts null</param>
		///<param name = "metric">Optional, accepts null</param>
		public NodesStatsDescriptor(NodeIds node_id, Metrics metric): base(r => r.Optional("node_id", node_id).Optional("metric", metric))
		{
		}

		///<summary>/_nodes/stats/{metric}/{index_metric}</summary>
		///<param name = "metric">Optional, accepts null</param>
		///<param name = "index_metric">Optional, accepts null</param>
		public NodesStatsDescriptor(Metrics metric, IndexMetrics index_metric): base(r => r.Optional("metric", metric).Optional("index_metric", index_metric))
		{
		}

		///<summary>/_nodes/{node_id}/stats/{metric}/{index_metric}</summary>
		///<param name = "node_id">Optional, accepts null</param>
		///<param name = "metric">Optional, accepts null</param>
		///<param name = "index_metric">Optional, accepts null</param>
		public NodesStatsDescriptor(NodeIds node_id, Metrics metric, IndexMetrics index_metric): base(r => r.Optional("node_id", node_id).Optional("metric", metric).Optional("index_metric", index_metric))
		{
		}

		// values part of the url path
		NodeIds INodesStatsRequest.NodeId => Self.RouteValues.Get<NodeIds>("node_id");
		Metrics INodesStatsRequest.Metric => Self.RouteValues.Get<Metrics>("metric");
		IndexMetrics INodesStatsRequest.IndexMetric => Self.RouteValues.Get<IndexMetrics>("index_metric");
		///<summary>A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes</summary>
		public NodesStatsDescriptor NodeId(NodeIds nodeId) => Assign(nodeId, (a, v) => a.RouteValues.Optional("node_id", v));
		///<summary>Limit the information returned to the specified metrics</summary>
		public NodesStatsDescriptor Metric(Metrics metric) => Assign(metric, (a, v) => a.RouteValues.Optional("metric", (Metrics)v));
		///<summary>Limit the information returned for `indices` metric to the specific index metrics. Isn't used if `indices` (or `all`) metric isn't specified.</summary>
		public NodesStatsDescriptor IndexMetric(IndexMetrics indexMetric) => Assign(indexMetric, (a, v) => a.RouteValues.Optional("index_metric", (IndexMetrics)v));
		// Request parameters
		///<summary>A comma-separated list of fields for `fielddata` and `suggest` index metric (supports wildcards)</summary>
		public NodesStatsDescriptor CompletionFields(Fields completionFields) => Qs("completion_fields", completionFields);
		///<summary>A comma-separated list of fields for `fielddata` and `suggest` index metric (supports wildcards)</summary>
		public NodesStatsDescriptor CompletionFields<T>(params Expression<Func<T, object>>[] fields)
			where T : class => Qs("completion_fields", fields?.Select(e => (Field)e));
		///<summary>A comma-separated list of fields for `fielddata` index metric (supports wildcards)</summary>
		public NodesStatsDescriptor FielddataFields(Fields fielddataFields) => Qs("fielddata_fields", fielddataFields);
		///<summary>A comma-separated list of fields for `fielddata` index metric (supports wildcards)</summary>
		public NodesStatsDescriptor FielddataFields<T>(params Expression<Func<T, object>>[] fields)
			where T : class => Qs("fielddata_fields", fields?.Select(e => (Field)e));
		///<summary>A comma-separated list of fields for `fielddata` and `completion` index metric (supports wildcards)</summary>
		public NodesStatsDescriptor Fields(Fields fields) => Qs("fields", fields);
		///<summary>A comma-separated list of fields for `fielddata` and `completion` index metric (supports wildcards)</summary>
		public NodesStatsDescriptor Fields<T>(params Expression<Func<T, object>>[] fields)
			where T : class => Qs("fields", fields?.Select(e => (Field)e));
		///<summary>A comma-separated list of search groups for `search` index metric</summary>
		public NodesStatsDescriptor Groups(bool? groups = true) => Qs("groups", groups);
		///<summary>Whether to report the aggregated disk usage of each one of the Lucene index files (only applies if segment stats are requested)</summary>
		public NodesStatsDescriptor IncludeSegmentFileSizes(bool? includeSegmentFileSizes = true) => Qs("include_segment_file_sizes", includeSegmentFileSizes);
		///<summary>Return indices stats aggregated at index, node or shard level</summary>
		public NodesStatsDescriptor Level(Level? level) => Qs("level", level);
		///<summary>Explicit operation timeout</summary>
		public NodesStatsDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
		///<summary>A comma-separated list of document types for the `indexing` index metric</summary>
		public NodesStatsDescriptor Types(params string[] types) => Qs("types", types);
	}

	///<summary>descriptor for Usage <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-nodes-usage.html</pre></summary>
	public partial class NodesUsageDescriptor : RequestDescriptorBase<NodesUsageDescriptor, NodesUsageRequestParameters, INodesUsageRequest>, INodesUsageRequest
	{
		internal override ApiUrls ApiUrls => NodesUsageRequest.Urls;
		///<summary>/_nodes/usage</summary>
		public NodesUsageDescriptor(): base()
		{
		}

		///<summary>/_nodes/{node_id}/usage</summary>
		///<param name = "node_id">Optional, accepts null</param>
		public NodesUsageDescriptor(NodeIds node_id): base(r => r.Optional("node_id", node_id))
		{
		}

		///<summary>/_nodes/usage/{metric}</summary>
		///<param name = "metric">Optional, accepts null</param>
		public NodesUsageDescriptor(Metrics metric): base(r => r.Optional("metric", metric))
		{
		}

		///<summary>/_nodes/{node_id}/usage/{metric}</summary>
		///<param name = "node_id">Optional, accepts null</param>
		///<param name = "metric">Optional, accepts null</param>
		public NodesUsageDescriptor(NodeIds node_id, Metrics metric): base(r => r.Optional("node_id", node_id).Optional("metric", metric))
		{
		}

		// values part of the url path
		NodeIds INodesUsageRequest.NodeId => Self.RouteValues.Get<NodeIds>("node_id");
		Metrics INodesUsageRequest.Metric => Self.RouteValues.Get<Metrics>("metric");
		///<summary>A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes</summary>
		public NodesUsageDescriptor NodeId(NodeIds nodeId) => Assign(nodeId, (a, v) => a.RouteValues.Optional("node_id", v));
		///<summary>Limit the information returned to the specified metrics</summary>
		public NodesUsageDescriptor Metric(Metrics metric) => Assign(metric, (a, v) => a.RouteValues.Optional("metric", (Metrics)v));
		// Request parameters
		///<summary>Explicit operation timeout</summary>
		public NodesUsageDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
	}

	///<summary>descriptor for Ping <pre>http://www.elastic.co/guide/</pre></summary>
	public partial class PingDescriptor : RequestDescriptorBase<PingDescriptor, PingRequestParameters, IPingRequest>, IPingRequest
	{
		internal override ApiUrls ApiUrls => PingRequest.Urls;
	// values part of the url path
	// Request parameters
	}

	///<summary>descriptor for PutScript <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-scripting.html</pre></summary>
	public partial class PutScriptDescriptor : RequestDescriptorBase<PutScriptDescriptor, PutScriptRequestParameters, IPutScriptRequest>, IPutScriptRequest
	{
		internal override ApiUrls ApiUrls => PutScriptRequest.Urls;
		///<summary>/_scripts/{id}</summary>
		///<param name = "id">this parameter is required</param>
		public PutScriptDescriptor(Id id): base(r => r.Required("id", id))
		{
		}

		///<summary>/_scripts/{id}/{context}</summary>
		///<param name = "id">this parameter is required</param>
		///<param name = "context">Optional, accepts null</param>
		public PutScriptDescriptor(Id id, Name context): base(r => r.Required("id", id).Optional("context", context))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal PutScriptDescriptor(): base()
		{
		}

		// values part of the url path
		Id IPutScriptRequest.Id => Self.RouteValues.Get<Id>("id");
		Name IPutScriptRequest.Context => Self.RouteValues.Get<Name>("context");
		///<summary>Script context</summary>
		public PutScriptDescriptor Context(Name context) => Assign(context, (a, v) => a.RouteValues.Optional("context", v));
		// Request parameters
		///<summary>Specify timeout for connection to master</summary>
		public PutScriptDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Explicit operation timeout</summary>
		public PutScriptDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
	}

	///<summary>descriptor for ReindexOnServer <pre>https://www.elastic.co/guide/en/elasticsearch/reference/master/docs-reindex.html</pre></summary>
	public partial class ReindexOnServerDescriptor : RequestDescriptorBase<ReindexOnServerDescriptor, ReindexOnServerRequestParameters, IReindexOnServerRequest>, IReindexOnServerRequest
	{
		internal override ApiUrls ApiUrls => ReindexOnServerRequest.Urls;
		// values part of the url path
		// Request parameters
		///<summary>Should the effected indexes be refreshed?</summary>
		public ReindexOnServerDescriptor Refresh(bool? refresh = true) => Qs("refresh", refresh);
		///<summary>The throttle to set on this request in sub-requests per second. -1 means no throttle.</summary>
		public ReindexOnServerDescriptor RequestsPerSecond(long? requestsPerSecond) => Qs("requests_per_second", requestsPerSecond);
		///<summary>Control how long to keep the search context alive</summary>
		public ReindexOnServerDescriptor Scroll(Time scroll) => Qs("scroll", scroll);
		///<summary>The number of slices this task should be divided into. Defaults to 1 meaning the task isn't sliced into subtasks.</summary>
		public ReindexOnServerDescriptor Slices(long? slices) => Qs("slices", slices);
		///<summary>Time each individual bulk request should wait for shards that are unavailable.</summary>
		public ReindexOnServerDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
		///<summary>Sets the number of shard copies that must be active before proceeding with the reindex operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1)</summary>
		public ReindexOnServerDescriptor WaitForActiveShards(string waitForActiveShards) => Qs("wait_for_active_shards", waitForActiveShards);
		///<summary>Should the request should block until the reindex is complete.</summary>
		public ReindexOnServerDescriptor WaitForCompletion(bool? waitForCompletion = true) => Qs("wait_for_completion", waitForCompletion);
	}

	///<summary>descriptor for ReindexRethrottle <pre>https://www.elastic.co/guide/en/elasticsearch/reference/master/docs-reindex.html</pre></summary>
	public partial class ReindexRethrottleDescriptor : RequestDescriptorBase<ReindexRethrottleDescriptor, ReindexRethrottleRequestParameters, IReindexRethrottleRequest>, IReindexRethrottleRequest
	{
		internal override ApiUrls ApiUrls => ReindexRethrottleRequest.Urls;
		///<summary>/_reindex/{task_id}/_rethrottle</summary>
		///<param name = "task_id">this parameter is required</param>
		public ReindexRethrottleDescriptor(TaskId task_id): base(r => r.Required("task_id", task_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal ReindexRethrottleDescriptor(): base()
		{
		}

		// values part of the url path
		TaskId IReindexRethrottleRequest.TaskId => Self.RouteValues.Get<TaskId>("task_id");
		// Request parameters
		///<summary>The throttle to set on this request in floating sub-requests per second. -1 means set no throttle.</summary>
		public ReindexRethrottleDescriptor RequestsPerSecond(long? requestsPerSecond) => Qs("requests_per_second", requestsPerSecond);
	}

	///<summary>descriptor for RenderSearchTemplate <pre>http://www.elasticsearch.org/guide/en/elasticsearch/reference/master/search-template.html</pre></summary>
	public partial class RenderSearchTemplateDescriptor : RequestDescriptorBase<RenderSearchTemplateDescriptor, RenderSearchTemplateRequestParameters, IRenderSearchTemplateRequest>, IRenderSearchTemplateRequest
	{
		internal override ApiUrls ApiUrls => RenderSearchTemplateRequest.Urls;
		///<summary>/_render/template</summary>
		public RenderSearchTemplateDescriptor(): base()
		{
		}

		///<summary>/_render/template/{id}</summary>
		///<param name = "id">Optional, accepts null</param>
		public RenderSearchTemplateDescriptor(Id id): base(r => r.Optional("id", id))
		{
		}

		// values part of the url path
		Id IRenderSearchTemplateRequest.Id => Self.RouteValues.Get<Id>("id");
		///<summary>The id of the stored search template</summary>
		public RenderSearchTemplateDescriptor Id(Id id) => Assign(id, (a, v) => a.RouteValues.Optional("id", v));
	// Request parameters
	}

	///<summary>descriptor for DeleteRollupJob <pre></pre></summary>
	public partial class DeleteRollupJobDescriptor : RequestDescriptorBase<DeleteRollupJobDescriptor, DeleteRollupJobRequestParameters, IDeleteRollupJobRequest>, IDeleteRollupJobRequest
	{
		internal override ApiUrls ApiUrls => DeleteRollupJobRequest.Urls;
		///<summary>/_rollup/job/{id}</summary>
		///<param name = "id">this parameter is required</param>
		public DeleteRollupJobDescriptor(Id id): base(r => r.Required("id", id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal DeleteRollupJobDescriptor(): base()
		{
		}

		// values part of the url path
		Id IDeleteRollupJobRequest.Id => Self.RouteValues.Get<Id>("id");
	// Request parameters
	}

	///<summary>descriptor for GetRollupJob <pre></pre></summary>
	public partial class GetRollupJobDescriptor : RequestDescriptorBase<GetRollupJobDescriptor, GetRollupJobRequestParameters, IGetRollupJobRequest>, IGetRollupJobRequest
	{
		internal override ApiUrls ApiUrls => GetRollupJobRequest.Urls;
		///<summary>/_rollup/job/{id}</summary>
		///<param name = "id">Optional, accepts null</param>
		public GetRollupJobDescriptor(Id id): base(r => r.Optional("id", id))
		{
		}

		///<summary>/_rollup/job/</summary>
		public GetRollupJobDescriptor(): base()
		{
		}

		// values part of the url path
		Id IGetRollupJobRequest.Id => Self.RouteValues.Get<Id>("id");
		///<summary>The ID of the job(s) to fetch. Accepts glob patterns, or left blank for all jobs</summary>
		public GetRollupJobDescriptor Id(Id id) => Assign(id, (a, v) => a.RouteValues.Optional("id", v));
	// Request parameters
	}

	///<summary>descriptor for GetRollupCapabilities <pre></pre></summary>
	public partial class GetRollupCapabilitiesDescriptor : RequestDescriptorBase<GetRollupCapabilitiesDescriptor, GetRollupCapabilitiesRequestParameters, IGetRollupCapabilitiesRequest>, IGetRollupCapabilitiesRequest
	{
		internal override ApiUrls ApiUrls => GetRollupCapabilitiesRequest.Urls;
		///<summary>/_rollup/data/{id}</summary>
		///<param name = "id">Optional, accepts null</param>
		public GetRollupCapabilitiesDescriptor(Id id): base(r => r.Optional("id", id))
		{
		}

		///<summary>/_rollup/data/</summary>
		public GetRollupCapabilitiesDescriptor(): base()
		{
		}

		// values part of the url path
		Id IGetRollupCapabilitiesRequest.Id => Self.RouteValues.Get<Id>("id");
		///<summary>The ID of the index to check rollup capabilities on, or left blank for all jobs</summary>
		public GetRollupCapabilitiesDescriptor Id(Id id) => Assign(id, (a, v) => a.RouteValues.Optional("id", v));
	// Request parameters
	}

	///<summary>descriptor for GetRollupIndexCapabilities <pre></pre></summary>
	public partial class GetRollupIndexCapabilitiesDescriptor : RequestDescriptorBase<GetRollupIndexCapabilitiesDescriptor, GetRollupIndexCapabilitiesRequestParameters, IGetRollupIndexCapabilitiesRequest>, IGetRollupIndexCapabilitiesRequest
	{
		internal override ApiUrls ApiUrls => GetRollupIndexCapabilitiesRequest.Urls;
		///<summary>/{index}/_rollup/data</summary>
		///<param name = "index">this parameter is required</param>
		public GetRollupIndexCapabilitiesDescriptor(IndexName index): base(r => r.Required("index", index))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal GetRollupIndexCapabilitiesDescriptor(): base()
		{
		}

		// values part of the url path
		IndexName IGetRollupIndexCapabilitiesRequest.Index => Self.RouteValues.Get<IndexName>("index");
		///<summary>The rollup index or index pattern to obtain rollup capabilities from.</summary>
		public GetRollupIndexCapabilitiesDescriptor Index(IndexName index) => Assign(index, (a, v) => a.RouteValues.Required("index", v));
		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public GetRollupIndexCapabilitiesDescriptor Index<TOther>()
			where TOther : class => Assign(typeof(TOther), (a, v) => a.RouteValues.Required("index", (IndexName)v));
	// Request parameters
	}

	///<summary>descriptor for CreateRollupJob <pre></pre></summary>
	public partial class CreateRollupJobDescriptor<T> : RequestDescriptorBase<CreateRollupJobDescriptor<T>, CreateRollupJobRequestParameters, ICreateRollupJobRequest>, ICreateRollupJobRequest
	{
		internal override ApiUrls ApiUrls => CreateRollupJobRequest.Urls;
		///<summary>/_rollup/job/{id}</summary>
		///<param name = "id">this parameter is required</param>
		public CreateRollupJobDescriptor(Id id): base(r => r.Required("id", id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal CreateRollupJobDescriptor(): base()
		{
		}

		// values part of the url path
		Id ICreateRollupJobRequest.Id => Self.RouteValues.Get<Id>("id");
	// Request parameters
	}

	///<summary>descriptor for Search <pre></pre></summary>
	public partial class RollupSearchDescriptor<T> : RequestDescriptorBase<RollupSearchDescriptor<T>, RollupSearchRequestParameters, IRollupSearchRequest>, IRollupSearchRequest
	{
		internal override ApiUrls ApiUrls => RollupSearchRequest.Urls;
		///<summary>/{index}/_rollup_search</summary>
		///<param name = "index">this parameter is required</param>
		public RollupSearchDescriptor(Indices index): base(r => r.Required("index", index))
		{
		}

		///<summary>/{index}/_rollup_search</summary>
		public RollupSearchDescriptor(): this(typeof(T))
		{
		}

		// values part of the url path
		Indices IRollupSearchRequest.Index => Self.RouteValues.Get<Indices>("index");
		///<summary>The indices or index-pattern(s) (containing rollup or regular data) that should be searched</summary>
		public RollupSearchDescriptor<T> Index(Indices index) => Assign(index, (a, v) => a.RouteValues.Required("index", v));
		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public RollupSearchDescriptor<T> Index<TOther>()
			where TOther : class => Assign(typeof(TOther), (a, v) => a.RouteValues.Required("index", (Indices)v));
		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public RollupSearchDescriptor<T> AllIndices() => this.Index(Indices.All);
		// Request parameters
		///<summary>Indicates whether hits.total should be rendered as an integer or an object in the rest search response</summary>
		public RollupSearchDescriptor<T> TotalHitsAsInteger(bool? totalHitsAsInteger = true) => Qs("rest_total_hits_as_int", totalHitsAsInteger);
		///<summary>Specify whether aggregation and suggester names should be prefixed by their respective types in the response</summary>
		public RollupSearchDescriptor<T> TypedKeys(bool? typedKeys = true) => Qs("typed_keys", typedKeys);
	}

	///<summary>descriptor for StartRollupJob <pre></pre></summary>
	public partial class StartRollupJobDescriptor : RequestDescriptorBase<StartRollupJobDescriptor, StartRollupJobRequestParameters, IStartRollupJobRequest>, IStartRollupJobRequest
	{
		internal override ApiUrls ApiUrls => StartRollupJobRequest.Urls;
		///<summary>/_rollup/job/{id}/_start</summary>
		///<param name = "id">this parameter is required</param>
		public StartRollupJobDescriptor(Id id): base(r => r.Required("id", id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal StartRollupJobDescriptor(): base()
		{
		}

		// values part of the url path
		Id IStartRollupJobRequest.Id => Self.RouteValues.Get<Id>("id");
	// Request parameters
	}

	///<summary>descriptor for StopRollupJob <pre></pre></summary>
	public partial class StopRollupJobDescriptor : RequestDescriptorBase<StopRollupJobDescriptor, StopRollupJobRequestParameters, IStopRollupJobRequest>, IStopRollupJobRequest
	{
		internal override ApiUrls ApiUrls => StopRollupJobRequest.Urls;
		///<summary>/_rollup/job/{id}/_stop</summary>
		///<param name = "id">this parameter is required</param>
		public StopRollupJobDescriptor(Id id): base(r => r.Required("id", id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal StopRollupJobDescriptor(): base()
		{
		}

		// values part of the url path
		Id IStopRollupJobRequest.Id => Self.RouteValues.Get<Id>("id");
		// Request parameters
		///<summary>Block for (at maximum) the specified duration while waiting for the job to stop.  Defaults to 30s.</summary>
		public StopRollupJobDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
		///<summary>True if the API should block until the job has fully stopped, false if should be executed async. Defaults to false.</summary>
		public StopRollupJobDescriptor WaitForCompletion(bool? waitForCompletion = true) => Qs("wait_for_completion", waitForCompletion);
	}

	///<summary>descriptor for ExecutePainlessScript <pre>https://www.elastic.co/guide/en/elasticsearch/painless/master/painless-execute-api.html</pre></summary>
	public partial class ExecutePainlessScriptDescriptor : RequestDescriptorBase<ExecutePainlessScriptDescriptor, ExecutePainlessScriptRequestParameters, IExecutePainlessScriptRequest>, IExecutePainlessScriptRequest
	{
		internal override ApiUrls ApiUrls => ExecutePainlessScriptRequest.Urls;
	// values part of the url path
	// Request parameters
	}

	///<summary>descriptor for Scroll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/search-request-scroll.html</pre></summary>
	public partial class ScrollDescriptor<T> : RequestDescriptorBase<ScrollDescriptor<T>, ScrollRequestParameters, IScrollRequest>, IScrollRequest
	{
		internal override ApiUrls ApiUrls => ScrollRequest.Urls;
		// values part of the url path
		// Request parameters
		///<summary>Indicates whether hits.total should be rendered as an integer or an object in the rest search response</summary>
		public ScrollDescriptor<T> TotalHitsAsInteger(bool? totalHitsAsInteger = true) => Qs("rest_total_hits_as_int", totalHitsAsInteger);
	}

	///<summary>descriptor for Search <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/search-search.html</pre></summary>
	public partial class SearchDescriptor<T> : RequestDescriptorBase<SearchDescriptor<T>, SearchRequestParameters, ISearchRequest<T>>, ISearchRequest<T>
	{
		internal override ApiUrls ApiUrls => SearchRequest.Urls;
		///<summary>/{index}/_search</summary>
		public SearchDescriptor(): this(typeof(T))
		{
		}

		///<summary>/{index}/_search</summary>
		///<param name = "index">Optional, accepts null</param>
		public SearchDescriptor(Indices index): base(r => r.Optional("index", index))
		{
		}

		// values part of the url path
		Indices ISearchRequest.Index => Self.RouteValues.Get<Indices>("index");
		///<summary>A comma-separated list of index names to search; use the special string `_all` or Indices.All to perform the operation on all indices</summary>
		public SearchDescriptor<T> Index(Indices index) => Assign(index, (a, v) => a.RouteValues.Optional("index", v));
		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public SearchDescriptor<T> Index<TOther>()
			where TOther : class => Assign(typeof(TOther), (a, v) => a.RouteValues.Optional("index", (Indices)v));
		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public SearchDescriptor<T> AllIndices() => this.Index(Indices.All);
		// Request parameters
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public SearchDescriptor<T> AllowNoIndices(bool? allowNoIndices = true) => Qs("allow_no_indices", allowNoIndices);
		///<summary>Indicate if an error should be returned if there is a partial search failure or timeout</summary>
		public SearchDescriptor<T> AllowPartialSearchResults(bool? allowPartialSearchResults = true) => Qs("allow_partial_search_results", allowPartialSearchResults);
		///<summary>Specify whether wildcard and prefix queries should be analyzed (default: false)</summary>
		public SearchDescriptor<T> AnalyzeWildcard(bool? analyzeWildcard = true) => Qs("analyze_wildcard", analyzeWildcard);
		///<summary>The analyzer to use for the query string</summary>
		public SearchDescriptor<T> Analyzer(string analyzer) => Qs("analyzer", analyzer);
		///<summary>The number of shard results that should be reduced at once on the coordinating node. This value should be used as a protection mechanism to reduce the memory overhead per search request if the potential number of shards in the request can be large.</summary>
		public SearchDescriptor<T> BatchedReduceSize(long? batchedReduceSize) => Qs("batched_reduce_size", batchedReduceSize);
		///<summary>Indicates whether network round-trips should be minimized as part of cross-cluster search requests execution</summary>
		public SearchDescriptor<T> CcsMinimizeRoundtrips(bool? ccsMinimizeRoundtrips = true) => Qs("ccs_minimize_roundtrips", ccsMinimizeRoundtrips);
		///<summary>The default operator for query string query (AND or OR)</summary>
		public SearchDescriptor<T> DefaultOperator(DefaultOperator? defaultOperator) => Qs("default_operator", defaultOperator);
		///<summary>The field to use as default where no field prefix is given in the query string</summary>
		public SearchDescriptor<T> Df(string df) => Qs("df", df);
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public SearchDescriptor<T> ExpandWildcards(ExpandWildcards? expandWildcards) => Qs("expand_wildcards", expandWildcards);
		///<summary>Whether specified concrete, expanded or aliased indices should be ignored when throttled</summary>
		public SearchDescriptor<T> IgnoreThrottled(bool? ignoreThrottled = true) => Qs("ignore_throttled", ignoreThrottled);
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public SearchDescriptor<T> IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
		///<summary>Specify whether format-based query failures (such as providing text to a numeric field) should be ignored</summary>
		public SearchDescriptor<T> Lenient(bool? lenient = true) => Qs("lenient", lenient);
		///<summary>The number of concurrent shard requests per node this search executes concurrently. This value should be used to limit the impact of the search on the cluster in order to limit the number of concurrent shard requests</summary>
		public SearchDescriptor<T> MaxConcurrentShardRequests(long? maxConcurrentShardRequests) => Qs("max_concurrent_shard_requests", maxConcurrentShardRequests);
		///<summary>A threshold that enforces a pre-filter roundtrip to prefilter search shards based on query rewriting if thenumber of shards the search request expands to exceeds the threshold. This filter roundtrip can limit the number of shards significantly if for instance a shard can not match any documents based on it's rewrite method ie. if date filters are mandatory to match but the shard bounds and the query are disjoint.</summary>
		public SearchDescriptor<T> PreFilterShardSize(long? preFilterShardSize) => Qs("pre_filter_shard_size", preFilterShardSize);
		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public SearchDescriptor<T> Preference(string preference) => Qs("preference", preference);
		///<summary>Specify if request cache should be used for this request or not, defaults to index level setting</summary>
		public SearchDescriptor<T> RequestCache(bool? requestCache = true) => Qs("request_cache", requestCache);
		///<summary>
		/// A document is routed to a particular shard in an index using the following formula
		/// <para> shard_num = hash(_routing) % num_primary_shards</para>
		/// <para>Elasticsearch will use the document id if not provided. </para>
		/// <para>For requests that are constructed from/for a document NEST will automatically infer the routing key
		/// if that document has a <see cref = "Nest.JoinField"/> or a routing mapping on for its type exists on <see cref = "Nest.ConnectionSettings"/></para> 
		///</summary>
		public SearchDescriptor<T> Routing(Routing routing) => Qs("routing", routing);
		///<summary>Specify how long a consistent view of the index should be maintained for scrolled search</summary>
		public SearchDescriptor<T> Scroll(Time scroll) => Qs("scroll", scroll);
		///<summary>Search operation type</summary>
		public SearchDescriptor<T> SearchType(SearchType? searchType) => Qs("search_type", searchType);
		///<summary>Specify whether to return sequence number and primary term of the last modification of each hit</summary>
		public SearchDescriptor<T> SequenceNumberPrimaryTerm(bool? sequenceNumberPrimaryTerm = true) => Qs("seq_no_primary_term", sequenceNumberPrimaryTerm);
		///<summary>Specific 'tag' of the request for logging and statistical purposes</summary>
		public SearchDescriptor<T> Stats(params string[] stats) => Qs("stats", stats);
		///<summary>Specify which field to use for suggestions</summary>
		public SearchDescriptor<T> SuggestField(Field suggestField) => Qs("suggest_field", suggestField);
		///<summary>Specify which field to use for suggestions</summary>
		public SearchDescriptor<T> SuggestField(Expression<Func<T, object>> field) => Qs("suggest_field", (Field)field);
		///<summary>Specify suggest mode</summary>
		public SearchDescriptor<T> SuggestMode(SuggestMode? suggestMode) => Qs("suggest_mode", suggestMode);
		///<summary>How many suggestions to return in response</summary>
		public SearchDescriptor<T> SuggestSize(long? suggestSize) => Qs("suggest_size", suggestSize);
		///<summary>The source text for which the suggestions should be returned</summary>
		public SearchDescriptor<T> SuggestText(string suggestText) => Qs("suggest_text", suggestText);
		///<summary>Indicates whether hits.total should be rendered as an integer or an object in the rest search response</summary>
		public SearchDescriptor<T> TotalHitsAsInteger(bool? totalHitsAsInteger = true) => Qs("rest_total_hits_as_int", totalHitsAsInteger);
		///<summary>Indicate if the number of documents that match the query should be tracked</summary>
		public SearchDescriptor<T> TrackTotalHits(bool? trackTotalHits = true) => Qs("track_total_hits", trackTotalHits);
		///<summary>Specify whether aggregation and suggester names should be prefixed by their respective types in the response</summary>
		public SearchDescriptor<T> TypedKeys(bool? typedKeys = true) => Qs("typed_keys", typedKeys);
	}

	///<summary>descriptor for SearchShards <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/search-shards.html</pre></summary>
	public partial class SearchShardsDescriptor<T> : RequestDescriptorBase<SearchShardsDescriptor<T>, SearchShardsRequestParameters, ISearchShardsRequest<T>>, ISearchShardsRequest<T>
	{
		internal override ApiUrls ApiUrls => SearchShardsRequest.Urls;
		///<summary>/{index}/_search_shards</summary>
		public SearchShardsDescriptor(): this(typeof(T))
		{
		}

		///<summary>/{index}/_search_shards</summary>
		///<param name = "index">Optional, accepts null</param>
		public SearchShardsDescriptor(Indices index): base(r => r.Optional("index", index))
		{
		}

		// values part of the url path
		Indices ISearchShardsRequest.Index => Self.RouteValues.Get<Indices>("index");
		///<summary>A comma-separated list of index names to search; use the special string `_all` or Indices.All to perform the operation on all indices</summary>
		public SearchShardsDescriptor<T> Index(Indices index) => Assign(index, (a, v) => a.RouteValues.Optional("index", v));
		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public SearchShardsDescriptor<T> Index<TOther>()
			where TOther : class => Assign(typeof(TOther), (a, v) => a.RouteValues.Optional("index", (Indices)v));
		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public SearchShardsDescriptor<T> AllIndices() => this.Index(Indices.All);
		// Request parameters
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public SearchShardsDescriptor<T> AllowNoIndices(bool? allowNoIndices = true) => Qs("allow_no_indices", allowNoIndices);
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public SearchShardsDescriptor<T> ExpandWildcards(ExpandWildcards? expandWildcards) => Qs("expand_wildcards", expandWildcards);
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public SearchShardsDescriptor<T> IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public SearchShardsDescriptor<T> Local(bool? local = true) => Qs("local", local);
		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public SearchShardsDescriptor<T> Preference(string preference) => Qs("preference", preference);
		///<summary>
		/// A document is routed to a particular shard in an index using the following formula
		/// <para> shard_num = hash(_routing) % num_primary_shards</para>
		/// <para>Elasticsearch will use the document id if not provided. </para>
		/// <para>For requests that are constructed from/for a document NEST will automatically infer the routing key
		/// if that document has a <see cref = "Nest.JoinField"/> or a routing mapping on for its type exists on <see cref = "Nest.ConnectionSettings"/></para> 
		///</summary>
		public SearchShardsDescriptor<T> Routing(Routing routing) => Qs("routing", routing);
	}

	///<summary>descriptor for SearchTemplate <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/search-template.html</pre></summary>
	public partial class SearchTemplateDescriptor<T> : RequestDescriptorBase<SearchTemplateDescriptor<T>, SearchTemplateRequestParameters, ISearchTemplateRequest>, ISearchTemplateRequest
	{
		internal override ApiUrls ApiUrls => SearchTemplateRequest.Urls;
		///<summary>/{index}/_search/template</summary>
		public SearchTemplateDescriptor(): this(typeof(T))
		{
		}

		///<summary>/{index}/_search/template</summary>
		///<param name = "index">Optional, accepts null</param>
		public SearchTemplateDescriptor(Indices index): base(r => r.Optional("index", index))
		{
		}

		// values part of the url path
		Indices ISearchTemplateRequest.Index => Self.RouteValues.Get<Indices>("index");
		///<summary>A comma-separated list of index names to search; use the special string `_all` or Indices.All to perform the operation on all indices</summary>
		public SearchTemplateDescriptor<T> Index(Indices index) => Assign(index, (a, v) => a.RouteValues.Optional("index", v));
		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public SearchTemplateDescriptor<T> Index<TOther>()
			where TOther : class => Assign(typeof(TOther), (a, v) => a.RouteValues.Optional("index", (Indices)v));
		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public SearchTemplateDescriptor<T> AllIndices() => this.Index(Indices.All);
		// Request parameters
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public SearchTemplateDescriptor<T> AllowNoIndices(bool? allowNoIndices = true) => Qs("allow_no_indices", allowNoIndices);
		///<summary>Indicates whether network round-trips should be minimized as part of cross-cluster search requests execution</summary>
		public SearchTemplateDescriptor<T> CcsMinimizeRoundtrips(bool? ccsMinimizeRoundtrips = true) => Qs("ccs_minimize_roundtrips", ccsMinimizeRoundtrips);
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public SearchTemplateDescriptor<T> ExpandWildcards(ExpandWildcards? expandWildcards) => Qs("expand_wildcards", expandWildcards);
		///<summary>Specify whether to return detailed information about score computation as part of a hit</summary>
		public SearchTemplateDescriptor<T> Explain(bool? explain = true) => Qs("explain", explain);
		///<summary>Whether specified concrete, expanded or aliased indices should be ignored when throttled</summary>
		public SearchTemplateDescriptor<T> IgnoreThrottled(bool? ignoreThrottled = true) => Qs("ignore_throttled", ignoreThrottled);
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public SearchTemplateDescriptor<T> IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public SearchTemplateDescriptor<T> Preference(string preference) => Qs("preference", preference);
		///<summary>Specify whether to profile the query execution</summary>
		public SearchTemplateDescriptor<T> Profile(bool? profile = true) => Qs("profile", profile);
		///<summary>
		/// A document is routed to a particular shard in an index using the following formula
		/// <para> shard_num = hash(_routing) % num_primary_shards</para>
		/// <para>Elasticsearch will use the document id if not provided. </para>
		/// <para>For requests that are constructed from/for a document NEST will automatically infer the routing key
		/// if that document has a <see cref = "Nest.JoinField"/> or a routing mapping on for its type exists on <see cref = "Nest.ConnectionSettings"/></para> 
		///</summary>
		public SearchTemplateDescriptor<T> Routing(Routing routing) => Qs("routing", routing);
		///<summary>Specify how long a consistent view of the index should be maintained for scrolled search</summary>
		public SearchTemplateDescriptor<T> Scroll(Time scroll) => Qs("scroll", scroll);
		///<summary>Search operation type</summary>
		public SearchTemplateDescriptor<T> SearchType(SearchType? searchType) => Qs("search_type", searchType);
		///<summary>Indicates whether hits.total should be rendered as an integer or an object in the rest search response</summary>
		public SearchTemplateDescriptor<T> TotalHitsAsInteger(bool? totalHitsAsInteger = true) => Qs("rest_total_hits_as_int", totalHitsAsInteger);
		///<summary>Specify whether aggregation and suggester names should be prefixed by their respective types in the response</summary>
		public SearchTemplateDescriptor<T> TypedKeys(bool? typedKeys = true) => Qs("typed_keys", typedKeys);
	}

	///<summary>descriptor for Authenticate <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-authenticate.html</pre></summary>
	public partial class AuthenticateDescriptor : RequestDescriptorBase<AuthenticateDescriptor, AuthenticateRequestParameters, IAuthenticateRequest>, IAuthenticateRequest
	{
		internal override ApiUrls ApiUrls => AuthenticateRequest.Urls;
	// values part of the url path
	// Request parameters
	}

	///<summary>descriptor for ChangePassword <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-change-password.html</pre></summary>
	public partial class ChangePasswordDescriptor : RequestDescriptorBase<ChangePasswordDescriptor, ChangePasswordRequestParameters, IChangePasswordRequest>, IChangePasswordRequest
	{
		internal override ApiUrls ApiUrls => ChangePasswordRequest.Urls;
		///<summary>/_security/user/{username}/_password</summary>
		///<param name = "username">Optional, accepts null</param>
		public ChangePasswordDescriptor(Name username): base(r => r.Optional("username", username))
		{
		}

		///<summary>/_security/user/_password</summary>
		public ChangePasswordDescriptor(): base()
		{
		}

		// values part of the url path
		Name IChangePasswordRequest.Username => Self.RouteValues.Get<Name>("username");
		///<summary>The username of the user to change the password for</summary>
		public ChangePasswordDescriptor Username(Name username) => Assign(username, (a, v) => a.RouteValues.Optional("username", v));
		// Request parameters
		///<summary>If `true` (the default) then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` then do nothing with refreshes.</summary>
		public ChangePasswordDescriptor Refresh(Refresh? refresh) => Qs("refresh", refresh);
	}

	///<summary>descriptor for ClearCachedRealms <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-clear-cache.html</pre></summary>
	public partial class ClearCachedRealmsDescriptor : RequestDescriptorBase<ClearCachedRealmsDescriptor, ClearCachedRealmsRequestParameters, IClearCachedRealmsRequest>, IClearCachedRealmsRequest
	{
		internal override ApiUrls ApiUrls => ClearCachedRealmsRequest.Urls;
		///<summary>/_security/realm/{realms}/_clear_cache</summary>
		///<param name = "realms">this parameter is required</param>
		public ClearCachedRealmsDescriptor(Names realms): base(r => r.Required("realms", realms))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal ClearCachedRealmsDescriptor(): base()
		{
		}

		// values part of the url path
		Names IClearCachedRealmsRequest.Realms => Self.RouteValues.Get<Names>("realms");
		// Request parameters
		///<summary>Comma-separated list of usernames to clear from the cache</summary>
		public ClearCachedRealmsDescriptor Usernames(params string[] usernames) => Qs("usernames", usernames);
	}

	///<summary>descriptor for ClearCachedRoles <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-clear-role-cache.html</pre></summary>
	public partial class ClearCachedRolesDescriptor : RequestDescriptorBase<ClearCachedRolesDescriptor, ClearCachedRolesRequestParameters, IClearCachedRolesRequest>, IClearCachedRolesRequest
	{
		internal override ApiUrls ApiUrls => ClearCachedRolesRequest.Urls;
		///<summary>/_security/role/{name}/_clear_cache</summary>
		///<param name = "name">this parameter is required</param>
		public ClearCachedRolesDescriptor(Names name): base(r => r.Required("name", name))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal ClearCachedRolesDescriptor(): base()
		{
		}

		// values part of the url path
		Names IClearCachedRolesRequest.Name => Self.RouteValues.Get<Names>("name");
	// Request parameters
	}

	///<summary>descriptor for CreateApiKey <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-create-api-key.html</pre></summary>
	public partial class CreateApiKeyDescriptor : RequestDescriptorBase<CreateApiKeyDescriptor, CreateApiKeyRequestParameters, ICreateApiKeyRequest>, ICreateApiKeyRequest
	{
		internal override ApiUrls ApiUrls => CreateApiKeyRequest.Urls;
		// values part of the url path
		// Request parameters
		///<summary>If `true` (the default) then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` then do nothing with refreshes.</summary>
		public CreateApiKeyDescriptor Refresh(Refresh? refresh) => Qs("refresh", refresh);
	}

	///<summary>descriptor for DeletePrivileges <pre>TODO</pre></summary>
	public partial class DeletePrivilegesDescriptor : RequestDescriptorBase<DeletePrivilegesDescriptor, DeletePrivilegesRequestParameters, IDeletePrivilegesRequest>, IDeletePrivilegesRequest
	{
		internal override ApiUrls ApiUrls => DeletePrivilegesRequest.Urls;
		///<summary>/_security/privilege/{application}/{name}</summary>
		///<param name = "application">this parameter is required</param>
		///<param name = "name">this parameter is required</param>
		public DeletePrivilegesDescriptor(Name application, Name name): base(r => r.Required("application", application).Required("name", name))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal DeletePrivilegesDescriptor(): base()
		{
		}

		// values part of the url path
		Name IDeletePrivilegesRequest.Application => Self.RouteValues.Get<Name>("application");
		Name IDeletePrivilegesRequest.Name => Self.RouteValues.Get<Name>("name");
		// Request parameters
		///<summary>If `true` (the default) then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` then do nothing with refreshes.</summary>
		public DeletePrivilegesDescriptor Refresh(Refresh? refresh) => Qs("refresh", refresh);
	}

	///<summary>descriptor for DeleteRole <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-delete-role.html</pre></summary>
	public partial class DeleteRoleDescriptor : RequestDescriptorBase<DeleteRoleDescriptor, DeleteRoleRequestParameters, IDeleteRoleRequest>, IDeleteRoleRequest
	{
		internal override ApiUrls ApiUrls => DeleteRoleRequest.Urls;
		///<summary>/_security/role/{name}</summary>
		///<param name = "name">this parameter is required</param>
		public DeleteRoleDescriptor(Name name): base(r => r.Required("name", name))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal DeleteRoleDescriptor(): base()
		{
		}

		// values part of the url path
		Name IDeleteRoleRequest.Name => Self.RouteValues.Get<Name>("name");
		// Request parameters
		///<summary>If `true` (the default) then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` then do nothing with refreshes.</summary>
		public DeleteRoleDescriptor Refresh(Refresh? refresh) => Qs("refresh", refresh);
	}

	///<summary>descriptor for DeleteRoleMapping <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-delete-role-mapping.html</pre></summary>
	public partial class DeleteRoleMappingDescriptor : RequestDescriptorBase<DeleteRoleMappingDescriptor, DeleteRoleMappingRequestParameters, IDeleteRoleMappingRequest>, IDeleteRoleMappingRequest
	{
		internal override ApiUrls ApiUrls => DeleteRoleMappingRequest.Urls;
		///<summary>/_security/role_mapping/{name}</summary>
		///<param name = "name">this parameter is required</param>
		public DeleteRoleMappingDescriptor(Name name): base(r => r.Required("name", name))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal DeleteRoleMappingDescriptor(): base()
		{
		}

		// values part of the url path
		Name IDeleteRoleMappingRequest.Name => Self.RouteValues.Get<Name>("name");
		// Request parameters
		///<summary>If `true` (the default) then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` then do nothing with refreshes.</summary>
		public DeleteRoleMappingDescriptor Refresh(Refresh? refresh) => Qs("refresh", refresh);
	}

	///<summary>descriptor for DeleteUser <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-delete-user.html</pre></summary>
	public partial class DeleteUserDescriptor : RequestDescriptorBase<DeleteUserDescriptor, DeleteUserRequestParameters, IDeleteUserRequest>, IDeleteUserRequest
	{
		internal override ApiUrls ApiUrls => DeleteUserRequest.Urls;
		///<summary>/_security/user/{username}</summary>
		///<param name = "username">this parameter is required</param>
		public DeleteUserDescriptor(Name username): base(r => r.Required("username", username))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal DeleteUserDescriptor(): base()
		{
		}

		// values part of the url path
		Name IDeleteUserRequest.Username => Self.RouteValues.Get<Name>("username");
		// Request parameters
		///<summary>If `true` (the default) then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` then do nothing with refreshes.</summary>
		public DeleteUserDescriptor Refresh(Refresh? refresh) => Qs("refresh", refresh);
	}

	///<summary>descriptor for DisableUser <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-disable-user.html</pre></summary>
	public partial class DisableUserDescriptor : RequestDescriptorBase<DisableUserDescriptor, DisableUserRequestParameters, IDisableUserRequest>, IDisableUserRequest
	{
		internal override ApiUrls ApiUrls => DisableUserRequest.Urls;
		///<summary>/_security/user/{username}/_disable</summary>
		///<param name = "username">this parameter is required</param>
		public DisableUserDescriptor(Name username): base(r => r.Required("username", username))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal DisableUserDescriptor(): base()
		{
		}

		// values part of the url path
		Name IDisableUserRequest.Username => Self.RouteValues.Get<Name>("username");
		// Request parameters
		///<summary>If `true` (the default) then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` then do nothing with refreshes.</summary>
		public DisableUserDescriptor Refresh(Refresh? refresh) => Qs("refresh", refresh);
	}

	///<summary>descriptor for EnableUser <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-enable-user.html</pre></summary>
	public partial class EnableUserDescriptor : RequestDescriptorBase<EnableUserDescriptor, EnableUserRequestParameters, IEnableUserRequest>, IEnableUserRequest
	{
		internal override ApiUrls ApiUrls => EnableUserRequest.Urls;
		///<summary>/_security/user/{username}/_enable</summary>
		///<param name = "username">this parameter is required</param>
		public EnableUserDescriptor(Name username): base(r => r.Required("username", username))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal EnableUserDescriptor(): base()
		{
		}

		// values part of the url path
		Name IEnableUserRequest.Username => Self.RouteValues.Get<Name>("username");
		// Request parameters
		///<summary>If `true` (the default) then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` then do nothing with refreshes.</summary>
		public EnableUserDescriptor Refresh(Refresh? refresh) => Qs("refresh", refresh);
	}

	///<summary>descriptor for GetApiKey <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-get-api-key.html</pre></summary>
	public partial class GetApiKeyDescriptor : RequestDescriptorBase<GetApiKeyDescriptor, GetApiKeyRequestParameters, IGetApiKeyRequest>, IGetApiKeyRequest
	{
		internal override ApiUrls ApiUrls => GetApiKeyRequest.Urls;
		// values part of the url path
		// Request parameters
		///<summary>API key id of the API key to be retrieved</summary>
		public GetApiKeyDescriptor Id(string id) => Qs("id", id);
		///<summary>API key name of the API key to be retrieved</summary>
		public GetApiKeyDescriptor Name(string name) => Qs("name", name);
		///<summary>realm name of the user who created this API key to be retrieved</summary>
		public GetApiKeyDescriptor RealmName(string realmName) => Qs("realm_name", realmName);
		///<summary>user name of the user who created this API key to be retrieved</summary>
		public GetApiKeyDescriptor Username(string username) => Qs("username", username);
	}

	///<summary>descriptor for GetPrivileges <pre>TODO</pre></summary>
	public partial class GetPrivilegesDescriptor : RequestDescriptorBase<GetPrivilegesDescriptor, GetPrivilegesRequestParameters, IGetPrivilegesRequest>, IGetPrivilegesRequest
	{
		internal override ApiUrls ApiUrls => GetPrivilegesRequest.Urls;
		///<summary>/_security/privilege</summary>
		public GetPrivilegesDescriptor(): base()
		{
		}

		///<summary>/_security/privilege/{application}</summary>
		///<param name = "application">Optional, accepts null</param>
		public GetPrivilegesDescriptor(Name application): base(r => r.Optional("application", application))
		{
		}

		///<summary>/_security/privilege/{application}/{name}</summary>
		///<param name = "application">Optional, accepts null</param>
		///<param name = "name">Optional, accepts null</param>
		public GetPrivilegesDescriptor(Name application, Name name): base(r => r.Optional("application", application).Optional("name", name))
		{
		}

		// values part of the url path
		Name IGetPrivilegesRequest.Application => Self.RouteValues.Get<Name>("application");
		Name IGetPrivilegesRequest.Name => Self.RouteValues.Get<Name>("name");
		///<summary>Application name</summary>
		public GetPrivilegesDescriptor Application(Name application) => Assign(application, (a, v) => a.RouteValues.Optional("application", v));
		///<summary>Privilege name</summary>
		public GetPrivilegesDescriptor Name(Name name) => Assign(name, (a, v) => a.RouteValues.Optional("name", v));
	// Request parameters
	}

	///<summary>descriptor for GetRole <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-get-role.html</pre></summary>
	public partial class GetRoleDescriptor : RequestDescriptorBase<GetRoleDescriptor, GetRoleRequestParameters, IGetRoleRequest>, IGetRoleRequest
	{
		internal override ApiUrls ApiUrls => GetRoleRequest.Urls;
		///<summary>/_security/role/{name}</summary>
		///<param name = "name">Optional, accepts null</param>
		public GetRoleDescriptor(Name name): base(r => r.Optional("name", name))
		{
		}

		///<summary>/_security/role</summary>
		public GetRoleDescriptor(): base()
		{
		}

		// values part of the url path
		Name IGetRoleRequest.Name => Self.RouteValues.Get<Name>("name");
		///<summary>Role name</summary>
		public GetRoleDescriptor Name(Name name) => Assign(name, (a, v) => a.RouteValues.Optional("name", v));
	// Request parameters
	}

	///<summary>descriptor for GetRoleMapping <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-get-role-mapping.html</pre></summary>
	public partial class GetRoleMappingDescriptor : RequestDescriptorBase<GetRoleMappingDescriptor, GetRoleMappingRequestParameters, IGetRoleMappingRequest>, IGetRoleMappingRequest
	{
		internal override ApiUrls ApiUrls => GetRoleMappingRequest.Urls;
		///<summary>/_security/role_mapping/{name}</summary>
		///<param name = "name">Optional, accepts null</param>
		public GetRoleMappingDescriptor(Name name): base(r => r.Optional("name", name))
		{
		}

		///<summary>/_security/role_mapping</summary>
		public GetRoleMappingDescriptor(): base()
		{
		}

		// values part of the url path
		Name IGetRoleMappingRequest.Name => Self.RouteValues.Get<Name>("name");
		///<summary>Role-Mapping name</summary>
		public GetRoleMappingDescriptor Name(Name name) => Assign(name, (a, v) => a.RouteValues.Optional("name", v));
	// Request parameters
	}

	///<summary>descriptor for GetUserAccessToken <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-get-token.html</pre></summary>
	public partial class GetUserAccessTokenDescriptor : RequestDescriptorBase<GetUserAccessTokenDescriptor, GetUserAccessTokenRequestParameters, IGetUserAccessTokenRequest>, IGetUserAccessTokenRequest
	{
		internal override ApiUrls ApiUrls => GetUserAccessTokenRequest.Urls;
	// values part of the url path
	// Request parameters
	}

	///<summary>descriptor for GetUser <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-get-user.html</pre></summary>
	public partial class GetUserDescriptor : RequestDescriptorBase<GetUserDescriptor, GetUserRequestParameters, IGetUserRequest>, IGetUserRequest
	{
		internal override ApiUrls ApiUrls => GetUserRequest.Urls;
		///<summary>/_security/user/{username}</summary>
		///<param name = "username">Optional, accepts null</param>
		public GetUserDescriptor(Names username): base(r => r.Optional("username", username))
		{
		}

		///<summary>/_security/user</summary>
		public GetUserDescriptor(): base()
		{
		}

		// values part of the url path
		Names IGetUserRequest.Username => Self.RouteValues.Get<Names>("username");
		///<summary>A comma-separated list of usernames</summary>
		public GetUserDescriptor Username(Names username) => Assign(username, (a, v) => a.RouteValues.Optional("username", v));
	// Request parameters
	}

	///<summary>descriptor for GetUserPrivileges <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-get-user-privileges.html</pre></summary>
	public partial class GetUserPrivilegesDescriptor : RequestDescriptorBase<GetUserPrivilegesDescriptor, GetUserPrivilegesRequestParameters, IGetUserPrivilegesRequest>, IGetUserPrivilegesRequest
	{
		internal override ApiUrls ApiUrls => GetUserPrivilegesRequest.Urls;
	// values part of the url path
	// Request parameters
	}

	///<summary>descriptor for HasPrivileges <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-has-privileges.html</pre></summary>
	public partial class HasPrivilegesDescriptor : RequestDescriptorBase<HasPrivilegesDescriptor, HasPrivilegesRequestParameters, IHasPrivilegesRequest>, IHasPrivilegesRequest
	{
		internal override ApiUrls ApiUrls => HasPrivilegesRequest.Urls;
		///<summary>/_security/user/_has_privileges</summary>
		public HasPrivilegesDescriptor(): base()
		{
		}

		///<summary>/_security/user/{user}/_has_privileges</summary>
		///<param name = "user">Optional, accepts null</param>
		public HasPrivilegesDescriptor(Name user): base(r => r.Optional("user", user))
		{
		}

		// values part of the url path
		Name IHasPrivilegesRequest.User => Self.RouteValues.Get<Name>("user");
		///<summary>Username</summary>
		public HasPrivilegesDescriptor User(Name user) => Assign(user, (a, v) => a.RouteValues.Optional("user", v));
	// Request parameters
	//TODO THIS METHOD IS UNMAPPED!
	}

	///<summary>descriptor for InvalidateApiKey <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-invalidate-api-key.html</pre></summary>
	public partial class InvalidateApiKeyDescriptor : RequestDescriptorBase<InvalidateApiKeyDescriptor, InvalidateApiKeyRequestParameters, IInvalidateApiKeyRequest>, IInvalidateApiKeyRequest
	{
		internal override ApiUrls ApiUrls => InvalidateApiKeyRequest.Urls;
	// values part of the url path
	// Request parameters
	}

	///<summary>descriptor for InvalidateUserAccessToken <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-invalidate-token.html</pre></summary>
	public partial class InvalidateUserAccessTokenDescriptor : RequestDescriptorBase<InvalidateUserAccessTokenDescriptor, InvalidateUserAccessTokenRequestParameters, IInvalidateUserAccessTokenRequest>, IInvalidateUserAccessTokenRequest
	{
		internal override ApiUrls ApiUrls => InvalidateUserAccessTokenRequest.Urls;
	// values part of the url path
	// Request parameters
	}

	///<summary>descriptor for PutPrivileges <pre>TODO</pre></summary>
	public partial class PutPrivilegesDescriptor : RequestDescriptorBase<PutPrivilegesDescriptor, PutPrivilegesRequestParameters, IPutPrivilegesRequest>, IPutPrivilegesRequest
	{
		internal override ApiUrls ApiUrls => PutPrivilegesRequest.Urls;
		// values part of the url path
		// Request parameters
		///<summary>If `true` (the default) then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` then do nothing with refreshes.</summary>
		public PutPrivilegesDescriptor Refresh(Refresh? refresh) => Qs("refresh", refresh);
	}

	///<summary>descriptor for PutRole <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-put-role.html</pre></summary>
	public partial class PutRoleDescriptor : RequestDescriptorBase<PutRoleDescriptor, PutRoleRequestParameters, IPutRoleRequest>, IPutRoleRequest
	{
		internal override ApiUrls ApiUrls => PutRoleRequest.Urls;
		///<summary>/_security/role/{name}</summary>
		///<param name = "name">this parameter is required</param>
		public PutRoleDescriptor(Name name): base(r => r.Required("name", name))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal PutRoleDescriptor(): base()
		{
		}

		// values part of the url path
		Name IPutRoleRequest.Name => Self.RouteValues.Get<Name>("name");
		// Request parameters
		///<summary>If `true` (the default) then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` then do nothing with refreshes.</summary>
		public PutRoleDescriptor Refresh(Refresh? refresh) => Qs("refresh", refresh);
	}

	///<summary>descriptor for PutRoleMapping <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-put-role-mapping.html</pre></summary>
	public partial class PutRoleMappingDescriptor : RequestDescriptorBase<PutRoleMappingDescriptor, PutRoleMappingRequestParameters, IPutRoleMappingRequest>, IPutRoleMappingRequest
	{
		internal override ApiUrls ApiUrls => PutRoleMappingRequest.Urls;
		///<summary>/_security/role_mapping/{name}</summary>
		///<param name = "name">this parameter is required</param>
		public PutRoleMappingDescriptor(Name name): base(r => r.Required("name", name))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal PutRoleMappingDescriptor(): base()
		{
		}

		// values part of the url path
		Name IPutRoleMappingRequest.Name => Self.RouteValues.Get<Name>("name");
		// Request parameters
		///<summary>If `true` (the default) then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` then do nothing with refreshes.</summary>
		public PutRoleMappingDescriptor Refresh(Refresh? refresh) => Qs("refresh", refresh);
	}

	///<summary>descriptor for PutUser <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-put-user.html</pre></summary>
	public partial class PutUserDescriptor : RequestDescriptorBase<PutUserDescriptor, PutUserRequestParameters, IPutUserRequest>, IPutUserRequest
	{
		internal override ApiUrls ApiUrls => PutUserRequest.Urls;
		///<summary>/_security/user/{username}</summary>
		///<param name = "username">this parameter is required</param>
		public PutUserDescriptor(Name username): base(r => r.Required("username", username))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal PutUserDescriptor(): base()
		{
		}

		// values part of the url path
		Name IPutUserRequest.Username => Self.RouteValues.Get<Name>("username");
		// Request parameters
		///<summary>If `true` (the default) then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` then do nothing with refreshes.</summary>
		public PutUserDescriptor Refresh(Refresh? refresh) => Qs("refresh", refresh);
	}

	///<summary>descriptor for Snapshot <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-snapshots.html</pre></summary>
	public partial class SnapshotDescriptor : RequestDescriptorBase<SnapshotDescriptor, SnapshotRequestParameters, ISnapshotRequest>, ISnapshotRequest
	{
		internal override ApiUrls ApiUrls => SnapshotRequest.Urls;
		///<summary>/_snapshot/{repository}/{snapshot}</summary>
		///<param name = "repository">this parameter is required</param>
		///<param name = "snapshot">this parameter is required</param>
		public SnapshotDescriptor(Name repository, Name snapshot): base(r => r.Required("repository", repository).Required("snapshot", snapshot))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal SnapshotDescriptor(): base()
		{
		}

		// values part of the url path
		Name ISnapshotRequest.RepositoryName => Self.RouteValues.Get<Name>("repository");
		Name ISnapshotRequest.Snapshot => Self.RouteValues.Get<Name>("snapshot");
		// Request parameters
		///<summary>Explicit operation timeout for connection to master node</summary>
		public SnapshotDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Should this request wait until the operation has completed before returning</summary>
		public SnapshotDescriptor WaitForCompletion(bool? waitForCompletion = true) => Qs("wait_for_completion", waitForCompletion);
	}

	///<summary>descriptor for CreateRepository <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-snapshots.html</pre></summary>
	public partial class CreateRepositoryDescriptor : RequestDescriptorBase<CreateRepositoryDescriptor, CreateRepositoryRequestParameters, ICreateRepositoryRequest>, ICreateRepositoryRequest
	{
		internal override ApiUrls ApiUrls => CreateRepositoryRequest.Urls;
		///<summary>/_snapshot/{repository}</summary>
		///<param name = "repository">this parameter is required</param>
		public CreateRepositoryDescriptor(Name repository): base(r => r.Required("repository", repository))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal CreateRepositoryDescriptor(): base()
		{
		}

		// values part of the url path
		Name ICreateRepositoryRequest.RepositoryName => Self.RouteValues.Get<Name>("repository");
		// Request parameters
		///<summary>Explicit operation timeout for connection to master node</summary>
		public CreateRepositoryDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Explicit operation timeout</summary>
		public CreateRepositoryDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
		///<summary>Whether to verify the repository after creation</summary>
		public CreateRepositoryDescriptor Verify(bool? verify = true) => Qs("verify", verify);
	}

	///<summary>descriptor for DeleteSnapshot <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-snapshots.html</pre></summary>
	public partial class DeleteSnapshotDescriptor : RequestDescriptorBase<DeleteSnapshotDescriptor, DeleteSnapshotRequestParameters, IDeleteSnapshotRequest>, IDeleteSnapshotRequest
	{
		internal override ApiUrls ApiUrls => DeleteSnapshotRequest.Urls;
		///<summary>/_snapshot/{repository}/{snapshot}</summary>
		///<param name = "repository">this parameter is required</param>
		///<param name = "snapshot">this parameter is required</param>
		public DeleteSnapshotDescriptor(Name repository, Name snapshot): base(r => r.Required("repository", repository).Required("snapshot", snapshot))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal DeleteSnapshotDescriptor(): base()
		{
		}

		// values part of the url path
		Name IDeleteSnapshotRequest.RepositoryName => Self.RouteValues.Get<Name>("repository");
		Name IDeleteSnapshotRequest.Snapshot => Self.RouteValues.Get<Name>("snapshot");
		// Request parameters
		///<summary>Explicit operation timeout for connection to master node</summary>
		public DeleteSnapshotDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
	}

	///<summary>descriptor for DeleteRepository <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-snapshots.html</pre></summary>
	public partial class DeleteRepositoryDescriptor : RequestDescriptorBase<DeleteRepositoryDescriptor, DeleteRepositoryRequestParameters, IDeleteRepositoryRequest>, IDeleteRepositoryRequest
	{
		internal override ApiUrls ApiUrls => DeleteRepositoryRequest.Urls;
		///<summary>/_snapshot/{repository}</summary>
		///<param name = "repository">this parameter is required</param>
		public DeleteRepositoryDescriptor(Names repository): base(r => r.Required("repository", repository))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal DeleteRepositoryDescriptor(): base()
		{
		}

		// values part of the url path
		Names IDeleteRepositoryRequest.RepositoryName => Self.RouteValues.Get<Names>("repository");
		// Request parameters
		///<summary>Explicit operation timeout for connection to master node</summary>
		public DeleteRepositoryDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Explicit operation timeout</summary>
		public DeleteRepositoryDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
	}

	///<summary>descriptor for GetSnapshot <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-snapshots.html</pre></summary>
	public partial class GetSnapshotDescriptor : RequestDescriptorBase<GetSnapshotDescriptor, GetSnapshotRequestParameters, IGetSnapshotRequest>, IGetSnapshotRequest
	{
		internal override ApiUrls ApiUrls => GetSnapshotRequest.Urls;
		///<summary>/_snapshot/{repository}/{snapshot}</summary>
		///<param name = "repository">this parameter is required</param>
		///<param name = "snapshot">this parameter is required</param>
		public GetSnapshotDescriptor(Name repository, Names snapshot): base(r => r.Required("repository", repository).Required("snapshot", snapshot))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal GetSnapshotDescriptor(): base()
		{
		}

		// values part of the url path
		Name IGetSnapshotRequest.RepositoryName => Self.RouteValues.Get<Name>("repository");
		Names IGetSnapshotRequest.Snapshot => Self.RouteValues.Get<Names>("snapshot");
		// Request parameters
		///<summary>Whether to ignore unavailable snapshots, defaults to false which means a SnapshotMissingException is thrown</summary>
		public GetSnapshotDescriptor IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
		///<summary>Explicit operation timeout for connection to master node</summary>
		public GetSnapshotDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Whether to show verbose snapshot info or only show the basic info found in the repository index blob</summary>
		public GetSnapshotDescriptor Verbose(bool? verbose = true) => Qs("verbose", verbose);
	}

	///<summary>descriptor for GetRepository <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-snapshots.html</pre></summary>
	public partial class GetRepositoryDescriptor : RequestDescriptorBase<GetRepositoryDescriptor, GetRepositoryRequestParameters, IGetRepositoryRequest>, IGetRepositoryRequest
	{
		internal override ApiUrls ApiUrls => GetRepositoryRequest.Urls;
		///<summary>/_snapshot</summary>
		public GetRepositoryDescriptor(): base()
		{
		}

		///<summary>/_snapshot/{repository}</summary>
		///<param name = "repository">Optional, accepts null</param>
		public GetRepositoryDescriptor(Names repository): base(r => r.Optional("repository", repository))
		{
		}

		// values part of the url path
		Names IGetRepositoryRequest.RepositoryName => Self.RouteValues.Get<Names>("repository");
		///<summary>A comma-separated list of repository names</summary>
		public GetRepositoryDescriptor RepositoryName(Names repository) => Assign(repository, (a, v) => a.RouteValues.Optional("repository", v));
		// Request parameters
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public GetRepositoryDescriptor Local(bool? local = true) => Qs("local", local);
		///<summary>Explicit operation timeout for connection to master node</summary>
		public GetRepositoryDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
	}

	///<summary>descriptor for Restore <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-snapshots.html</pre></summary>
	public partial class RestoreDescriptor : RequestDescriptorBase<RestoreDescriptor, RestoreRequestParameters, IRestoreRequest>, IRestoreRequest
	{
		internal override ApiUrls ApiUrls => RestoreRequest.Urls;
		///<summary>/_snapshot/{repository}/{snapshot}/_restore</summary>
		///<param name = "repository">this parameter is required</param>
		///<param name = "snapshot">this parameter is required</param>
		public RestoreDescriptor(Name repository, Name snapshot): base(r => r.Required("repository", repository).Required("snapshot", snapshot))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal RestoreDescriptor(): base()
		{
		}

		// values part of the url path
		Name IRestoreRequest.RepositoryName => Self.RouteValues.Get<Name>("repository");
		Name IRestoreRequest.Snapshot => Self.RouteValues.Get<Name>("snapshot");
		// Request parameters
		///<summary>Explicit operation timeout for connection to master node</summary>
		public RestoreDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Should this request wait until the operation has completed before returning</summary>
		public RestoreDescriptor WaitForCompletion(bool? waitForCompletion = true) => Qs("wait_for_completion", waitForCompletion);
	}

	///<summary>descriptor for Status <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-snapshots.html</pre></summary>
	public partial class SnapshotStatusDescriptor : RequestDescriptorBase<SnapshotStatusDescriptor, SnapshotStatusRequestParameters, ISnapshotStatusRequest>, ISnapshotStatusRequest
	{
		internal override ApiUrls ApiUrls => SnapshotStatusRequest.Urls;
		///<summary>/_snapshot/_status</summary>
		public SnapshotStatusDescriptor(): base()
		{
		}

		///<summary>/_snapshot/{repository}/_status</summary>
		///<param name = "repository">Optional, accepts null</param>
		public SnapshotStatusDescriptor(Name repository): base(r => r.Optional("repository", repository))
		{
		}

		///<summary>/_snapshot/{repository}/{snapshot}/_status</summary>
		///<param name = "repository">Optional, accepts null</param>
		///<param name = "snapshot">Optional, accepts null</param>
		public SnapshotStatusDescriptor(Name repository, Names snapshot): base(r => r.Optional("repository", repository).Optional("snapshot", snapshot))
		{
		}

		// values part of the url path
		Name ISnapshotStatusRequest.RepositoryName => Self.RouteValues.Get<Name>("repository");
		Names ISnapshotStatusRequest.Snapshot => Self.RouteValues.Get<Names>("snapshot");
		///<summary>A repository name</summary>
		public SnapshotStatusDescriptor RepositoryName(Name repository) => Assign(repository, (a, v) => a.RouteValues.Optional("repository", v));
		///<summary>A comma-separated list of snapshot names</summary>
		public SnapshotStatusDescriptor Snapshot(Names snapshot) => Assign(snapshot, (a, v) => a.RouteValues.Optional("snapshot", v));
		// Request parameters
		///<summary>Whether to ignore unavailable snapshots, defaults to false which means a SnapshotMissingException is thrown</summary>
		public SnapshotStatusDescriptor IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
		///<summary>Explicit operation timeout for connection to master node</summary>
		public SnapshotStatusDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
	}

	///<summary>descriptor for VerifyRepository <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-snapshots.html</pre></summary>
	public partial class VerifyRepositoryDescriptor : RequestDescriptorBase<VerifyRepositoryDescriptor, VerifyRepositoryRequestParameters, IVerifyRepositoryRequest>, IVerifyRepositoryRequest
	{
		internal override ApiUrls ApiUrls => VerifyRepositoryRequest.Urls;
		///<summary>/_snapshot/{repository}/_verify</summary>
		///<param name = "repository">this parameter is required</param>
		public VerifyRepositoryDescriptor(Name repository): base(r => r.Required("repository", repository))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal VerifyRepositoryDescriptor(): base()
		{
		}

		// values part of the url path
		Name IVerifyRepositoryRequest.RepositoryName => Self.RouteValues.Get<Name>("repository");
		// Request parameters
		///<summary>Explicit operation timeout for connection to master node</summary>
		public VerifyRepositoryDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
		///<summary>Explicit operation timeout</summary>
		public VerifyRepositoryDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
	}

	///<summary>descriptor for ClearSqlCursor <pre>Clear SQL cursor</pre></summary>
	public partial class ClearSqlCursorDescriptor : RequestDescriptorBase<ClearSqlCursorDescriptor, ClearSqlCursorRequestParameters, IClearSqlCursorRequest>, IClearSqlCursorRequest
	{
		internal override ApiUrls ApiUrls => ClearSqlCursorRequest.Urls;
	// values part of the url path
	// Request parameters
	}

	///<summary>descriptor for QuerySql <pre>Execute SQL</pre></summary>
	public partial class QuerySqlDescriptor : RequestDescriptorBase<QuerySqlDescriptor, QuerySqlRequestParameters, IQuerySqlRequest>, IQuerySqlRequest
	{
		internal override ApiUrls ApiUrls => QuerySqlRequest.Urls;
		// values part of the url path
		// Request parameters
		///<summary>a short version of the Accept header, e.g. json, yaml</summary>
		public QuerySqlDescriptor Format(string format) => Qs("format", format);
	}

	///<summary>descriptor for TranslateSql <pre>Translate SQL into Elasticsearch queries</pre></summary>
	public partial class TranslateSqlDescriptor : RequestDescriptorBase<TranslateSqlDescriptor, TranslateSqlRequestParameters, ITranslateSqlRequest>, ITranslateSqlRequest
	{
		internal override ApiUrls ApiUrls => TranslateSqlRequest.Urls;
	// values part of the url path
	// Request parameters
	}

	///<summary>descriptor for GetCertificates <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-ssl.html</pre></summary>
	public partial class GetCertificatesDescriptor : RequestDescriptorBase<GetCertificatesDescriptor, GetCertificatesRequestParameters, IGetCertificatesRequest>, IGetCertificatesRequest
	{
		internal override ApiUrls ApiUrls => GetCertificatesRequest.Urls;
	// values part of the url path
	// Request parameters
	}

	///<summary>descriptor for CancelTasks <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/tasks.html</pre></summary>
	public partial class CancelTasksDescriptor : RequestDescriptorBase<CancelTasksDescriptor, CancelTasksRequestParameters, ICancelTasksRequest>, ICancelTasksRequest
	{
		internal override ApiUrls ApiUrls => CancelTasksRequest.Urls;
		///<summary>/_tasks/_cancel</summary>
		public CancelTasksDescriptor(): base()
		{
		}

		///<summary>/_tasks/{task_id}/_cancel</summary>
		///<param name = "task_id">Optional, accepts null</param>
		public CancelTasksDescriptor(TaskId task_id): base(r => r.Optional("task_id", task_id))
		{
		}

		// values part of the url path
		TaskId ICancelTasksRequest.TaskId => Self.RouteValues.Get<TaskId>("task_id");
		///<summary>Cancel the task with specified task id (node_id:task_number)</summary>
		public CancelTasksDescriptor TaskId(TaskId taskId) => Assign(taskId, (a, v) => a.RouteValues.Optional("task_id", v));
		// Request parameters
		///<summary>A comma-separated list of actions that should be cancelled. Leave empty to cancel all.</summary>
		public CancelTasksDescriptor Actions(params string[] actions) => Qs("actions", actions);
		///<summary>A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes</summary>
		public CancelTasksDescriptor Nodes(params string[] nodes) => Qs("nodes", nodes);
		///<summary>Cancel tasks with specified parent task id (node_id:task_number). Set to -1 to cancel all.</summary>
		public CancelTasksDescriptor ParentTaskId(string parentTaskId) => Qs("parent_task_id", parentTaskId);
	}

	///<summary>descriptor for GetTask <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/tasks.html</pre></summary>
	public partial class GetTaskDescriptor : RequestDescriptorBase<GetTaskDescriptor, GetTaskRequestParameters, IGetTaskRequest>, IGetTaskRequest
	{
		internal override ApiUrls ApiUrls => GetTaskRequest.Urls;
		///<summary>/_tasks/{task_id}</summary>
		///<param name = "task_id">this parameter is required</param>
		public GetTaskDescriptor(TaskId task_id): base(r => r.Required("task_id", task_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal GetTaskDescriptor(): base()
		{
		}

		// values part of the url path
		TaskId IGetTaskRequest.TaskId => Self.RouteValues.Get<TaskId>("task_id");
		// Request parameters
		///<summary>Explicit operation timeout</summary>
		public GetTaskDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
		///<summary>Wait for the matching tasks to complete (default: false)</summary>
		public GetTaskDescriptor WaitForCompletion(bool? waitForCompletion = true) => Qs("wait_for_completion", waitForCompletion);
	}

	///<summary>descriptor for ListTasks <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/tasks.html</pre></summary>
	public partial class ListTasksDescriptor : RequestDescriptorBase<ListTasksDescriptor, ListTasksRequestParameters, IListTasksRequest>, IListTasksRequest
	{
		internal override ApiUrls ApiUrls => ListTasksRequest.Urls;
		// values part of the url path
		// Request parameters
		///<summary>A comma-separated list of actions that should be returned. Leave empty to return all.</summary>
		public ListTasksDescriptor Actions(params string[] actions) => Qs("actions", actions);
		///<summary>Return detailed task information (default: false)</summary>
		public ListTasksDescriptor Detailed(bool? detailed = true) => Qs("detailed", detailed);
		///<summary>Group tasks by nodes or parent/child relationships</summary>
		public ListTasksDescriptor GroupBy(GroupBy? groupBy) => Qs("group_by", groupBy);
		///<summary>A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes</summary>
		public ListTasksDescriptor Nodes(params string[] nodes) => Qs("nodes", nodes);
		///<summary>Return tasks with specified parent task id (node_id:task_number). Set to -1 to return all.</summary>
		public ListTasksDescriptor ParentTaskId(string parentTaskId) => Qs("parent_task_id", parentTaskId);
		///<summary>Explicit operation timeout</summary>
		public ListTasksDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
		///<summary>Wait for the matching tasks to complete (default: false)</summary>
		public ListTasksDescriptor WaitForCompletion(bool? waitForCompletion = true) => Qs("wait_for_completion", waitForCompletion);
	}

	///<summary>descriptor for TermVectors <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-termvectors.html</pre></summary>
	public partial class TermVectorsDescriptor<TDocument> : RequestDescriptorBase<TermVectorsDescriptor<TDocument>, TermVectorsRequestParameters, ITermVectorsRequest<TDocument>>, ITermVectorsRequest<TDocument>
	{
		internal override ApiUrls ApiUrls => TermVectorsRequest.Urls;
		///<summary>/{index}/_termvectors/{id}</summary>
		///<param name = "index">this parameter is required</param>
		///<param name = "id">Optional, accepts null</param>
		public TermVectorsDescriptor(IndexName index, Id id): base(r => r.Required("index", index).Optional("id", id))
		{
		}

		///<summary>/{index}/_termvectors</summary>
		///<param name = "index">this parameter is required</param>
		public TermVectorsDescriptor(IndexName index): base(r => r.Required("index", index))
		{
		}

		///<summary>/{index}/_termvectors/{id}</summary>
		///<param name = "id">Optional, accepts null</param>
		public TermVectorsDescriptor(Id id): this(typeof(TDocument), id)
		{
		}

		///<summary>/{index}/_termvectors</summary>
		public TermVectorsDescriptor(): this(typeof(TDocument))
		{
		}

		///<summary>/{index}/_termvectors/{id}</summary>
		///<param name = "id">The document used to resolve the path from</param>
		public TermVectorsDescriptor(TDocument documentWithId, IndexName index = null, Id id = null): this(index ?? typeof(TDocument), id ?? Nest.Id.From(documentWithId)) => DocumentFromPath(documentWithId);
		partial void DocumentFromPath(TDocument document);
		// values part of the url path
		IndexName ITermVectorsRequest.Index => Self.RouteValues.Get<IndexName>("index");
		Id ITermVectorsRequest.Id => Self.RouteValues.Get<Id>("id");
		///<summary>The index in which the document resides.</summary>
		public TermVectorsDescriptor<TDocument> Index(IndexName index) => Assign(index, (a, v) => a.RouteValues.Required("index", v));
		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public TermVectorsDescriptor<TDocument> Index<TOther>()
			where TOther : class => Assign(typeof(TOther), (a, v) => a.RouteValues.Required("index", (IndexName)v));
		///<summary>The id of the document, when not specified a doc param should be supplied.</summary>
		public TermVectorsDescriptor<TDocument> Id(Id id) => Assign(id, (a, v) => a.RouteValues.Optional("id", v));
		// Request parameters
		///<summary>Specifies if document count, sum of document frequencies and sum of total term frequencies should be returned.</summary>
		public TermVectorsDescriptor<TDocument> FieldStatistics(bool? fieldStatistics = true) => Qs("field_statistics", fieldStatistics);
		///<summary>A comma-separated list of fields to return.</summary>
		public TermVectorsDescriptor<TDocument> Fields(Fields fields) => Qs("fields", fields);
		///<summary>A comma-separated list of fields to return.</summary>
		public TermVectorsDescriptor<TDocument> Fields(params Expression<Func<TDocument, object>>[] fields) => Qs("fields", fields?.Select(e => (Field)e));
		///<summary>Specifies if term offsets should be returned.</summary>
		public TermVectorsDescriptor<TDocument> Offsets(bool? offsets = true) => Qs("offsets", offsets);
		///<summary>Specifies if term payloads should be returned.</summary>
		public TermVectorsDescriptor<TDocument> Payloads(bool? payloads = true) => Qs("payloads", payloads);
		///<summary>Specifies if term positions should be returned.</summary>
		public TermVectorsDescriptor<TDocument> Positions(bool? positions = true) => Qs("positions", positions);
		///<summary>Specify the node or shard the operation should be performed on (default: random).</summary>
		public TermVectorsDescriptor<TDocument> Preference(string preference) => Qs("preference", preference);
		///<summary>Specifies if request is real-time as opposed to near-real-time (default: true).</summary>
		public TermVectorsDescriptor<TDocument> Realtime(bool? realtime = true) => Qs("realtime", realtime);
		///<summary>
		/// A document is routed to a particular shard in an index using the following formula
		/// <para> shard_num = hash(_routing) % num_primary_shards</para>
		/// <para>Elasticsearch will use the document id if not provided. </para>
		/// <para>For requests that are constructed from/for a document NEST will automatically infer the routing key
		/// if that document has a <see cref = "Nest.JoinField"/> or a routing mapping on for its type exists on <see cref = "Nest.ConnectionSettings"/></para> 
		///</summary>
		public TermVectorsDescriptor<TDocument> Routing(Routing routing) => Qs("routing", routing);
		///<summary>Specifies if total term frequency and document frequency should be returned.</summary>
		public TermVectorsDescriptor<TDocument> TermStatistics(bool? termStatistics = true) => Qs("term_statistics", termStatistics);
		///<summary>Explicit version number for concurrency control</summary>
		public TermVectorsDescriptor<TDocument> Version(long? version) => Qs("version", version);
		///<summary>Specific version type</summary>
		public TermVectorsDescriptor<TDocument> VersionType(VersionType? versionType) => Qs("version_type", versionType);
	}

	///<summary>descriptor for Update <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-update.html</pre></summary>
	public partial class UpdateDescriptor<TDocument, TPartialDocument> : RequestDescriptorBase<UpdateDescriptor<TDocument, TPartialDocument>, UpdateRequestParameters, IUpdateRequest<TDocument, TPartialDocument>>, IUpdateRequest<TDocument, TPartialDocument>
	{
		internal override ApiUrls ApiUrls => UpdateRequest.Urls;
		///<summary>/{index}/_update/{id}</summary>
		///<param name = "index">this parameter is required</param>
		///<param name = "id">this parameter is required</param>
		public UpdateDescriptor(IndexName index, Id id): base(r => r.Required("index", index).Required("id", id))
		{
		}

		///<summary>/{index}/_update/{id}</summary>
		///<param name = "id">this parameter is required</param>
		public UpdateDescriptor(Id id): this(typeof(TDocument), id)
		{
		}

		///<summary>/{index}/_update/{id}</summary>
		///<param name = "id">The document used to resolve the path from</param>
		public UpdateDescriptor(TDocument documentWithId, IndexName index = null, Id id = null): this(index ?? typeof(TDocument), id ?? Nest.Id.From(documentWithId)) => DocumentFromPath(documentWithId);
		partial void DocumentFromPath(TDocument document);
		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal UpdateDescriptor(): base()
		{
		}

		// values part of the url path
		IndexName IUpdateRequest.Index => Self.RouteValues.Get<IndexName>("index");
		Id IUpdateRequest.Id => Self.RouteValues.Get<Id>("id");
		///<summary>The name of the index</summary>
		public UpdateDescriptor<TDocument, TPartialDocument> Index(IndexName index) => Assign(index, (a, v) => a.RouteValues.Required("index", v));
		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public UpdateDescriptor<TDocument, TPartialDocument> Index<TOther>()
			where TOther : class => Assign(typeof(TOther), (a, v) => a.RouteValues.Required("index", (IndexName)v));
		// Request parameters
		///<summary>only perform the update operation if the last operation that has changed the document has the specified primary term</summary>
		public UpdateDescriptor<TDocument, TPartialDocument> IfPrimaryTerm(long? ifPrimaryTerm) => Qs("if_primary_term", ifPrimaryTerm);
		///<summary>only perform the update operation if the last operation that has changed the document has the specified sequence number</summary>
		public UpdateDescriptor<TDocument, TPartialDocument> IfSequenceNumber(long? ifSequenceNumber) => Qs("if_seq_no", ifSequenceNumber);
		///<summary>The script language (default: painless)</summary>
		public UpdateDescriptor<TDocument, TPartialDocument> Lang(string lang) => Qs("lang", lang);
		///<summary>If `true` then refresh the effected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` (the default) then do nothing with refreshes.</summary>
		public UpdateDescriptor<TDocument, TPartialDocument> Refresh(Refresh? refresh) => Qs("refresh", refresh);
		///<summary>Specify how many times should the operation be retried when a conflict occurs (default: 0)</summary>
		public UpdateDescriptor<TDocument, TPartialDocument> RetryOnConflict(long? retryOnConflict) => Qs("retry_on_conflict", retryOnConflict);
		///<summary>
		/// A document is routed to a particular shard in an index using the following formula
		/// <para> shard_num = hash(_routing) % num_primary_shards</para>
		/// <para>Elasticsearch will use the document id if not provided. </para>
		/// <para>For requests that are constructed from/for a document NEST will automatically infer the routing key
		/// if that document has a <see cref = "Nest.JoinField"/> or a routing mapping on for its type exists on <see cref = "Nest.ConnectionSettings"/></para> 
		///</summary>
		public UpdateDescriptor<TDocument, TPartialDocument> Routing(Routing routing) => Qs("routing", routing);
		///<summary>Whether the _source should be included in the response.</summary>
		public UpdateDescriptor<TDocument, TPartialDocument> SourceEnabled(bool? sourceEnabled = true) => Qs("_source", sourceEnabled);
		///<summary>Explicit operation timeout</summary>
		public UpdateDescriptor<TDocument, TPartialDocument> Timeout(Time timeout) => Qs("timeout", timeout);
		///<summary>Sets the number of shard copies that must be active before proceeding with the update operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1)</summary>
		public UpdateDescriptor<TDocument, TPartialDocument> WaitForActiveShards(string waitForActiveShards) => Qs("wait_for_active_shards", waitForActiveShards);
	}

	///<summary>descriptor for UpdateByQuery <pre>https://www.elastic.co/guide/en/elasticsearch/reference/master/docs-update-by-query.html</pre></summary>
	public partial class UpdateByQueryDescriptor<T> : RequestDescriptorBase<UpdateByQueryDescriptor<T>, UpdateByQueryRequestParameters, IUpdateByQueryRequest<T>>, IUpdateByQueryRequest<T>
	{
		internal override ApiUrls ApiUrls => UpdateByQueryRequest.Urls;
		///<summary>/{index}/_update_by_query</summary>
		///<param name = "index">this parameter is required</param>
		public UpdateByQueryDescriptor(Indices index): base(r => r.Required("index", index))
		{
		}

		///<summary>/{index}/_update_by_query</summary>
		public UpdateByQueryDescriptor(): this(typeof(T))
		{
		}

		// values part of the url path
		Indices IUpdateByQueryRequest.Index => Self.RouteValues.Get<Indices>("index");
		///<summary>A comma-separated list of index names to search; use the special string `_all` or Indices.All to perform the operation on all indices</summary>
		public UpdateByQueryDescriptor<T> Index(Indices index) => Assign(index, (a, v) => a.RouteValues.Required("index", v));
		///<summary>a shortcut into calling Index(typeof(TOther))</summary>
		public UpdateByQueryDescriptor<T> Index<TOther>()
			where TOther : class => Assign(typeof(TOther), (a, v) => a.RouteValues.Required("index", (Indices)v));
		///<summary>A shortcut into calling Index(Indices.All)</summary>
		public UpdateByQueryDescriptor<T> AllIndices() => this.Index(Indices.All);
		// Request parameters
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public UpdateByQueryDescriptor<T> AllowNoIndices(bool? allowNoIndices = true) => Qs("allow_no_indices", allowNoIndices);
		///<summary>Specify whether wildcard and prefix queries should be analyzed (default: false)</summary>
		public UpdateByQueryDescriptor<T> AnalyzeWildcard(bool? analyzeWildcard = true) => Qs("analyze_wildcard", analyzeWildcard);
		///<summary>The analyzer to use for the query string</summary>
		public UpdateByQueryDescriptor<T> Analyzer(string analyzer) => Qs("analyzer", analyzer);
		///<summary>What to do when the update by query hits version conflicts?</summary>
		public UpdateByQueryDescriptor<T> Conflicts(Conflicts? conflicts) => Qs("conflicts", conflicts);
		///<summary>The default operator for query string query (AND or OR)</summary>
		public UpdateByQueryDescriptor<T> DefaultOperator(DefaultOperator? defaultOperator) => Qs("default_operator", defaultOperator);
		///<summary>The field to use as default where no field prefix is given in the query string</summary>
		public UpdateByQueryDescriptor<T> Df(string df) => Qs("df", df);
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public UpdateByQueryDescriptor<T> ExpandWildcards(ExpandWildcards? expandWildcards) => Qs("expand_wildcards", expandWildcards);
		///<summary>Starting offset (default: 0)</summary>
		public UpdateByQueryDescriptor<T> From(long? from) => Qs("from", from);
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public UpdateByQueryDescriptor<T> IgnoreUnavailable(bool? ignoreUnavailable = true) => Qs("ignore_unavailable", ignoreUnavailable);
		///<summary>Specify whether format-based query failures (such as providing text to a numeric field) should be ignored</summary>
		public UpdateByQueryDescriptor<T> Lenient(bool? lenient = true) => Qs("lenient", lenient);
		///<summary>Ingest pipeline to set on index requests made by this action. (default: none)</summary>
		public UpdateByQueryDescriptor<T> Pipeline(string pipeline) => Qs("pipeline", pipeline);
		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public UpdateByQueryDescriptor<T> Preference(string preference) => Qs("preference", preference);
		///<summary>Query in the Lucene query string syntax</summary>
		public UpdateByQueryDescriptor<T> QueryOnQueryString(string queryOnQueryString) => Qs("q", queryOnQueryString);
		///<summary>Should the effected indexes be refreshed?</summary>
		public UpdateByQueryDescriptor<T> Refresh(bool? refresh = true) => Qs("refresh", refresh);
		///<summary>Specify if request cache should be used for this request or not, defaults to index level setting</summary>
		public UpdateByQueryDescriptor<T> RequestCache(bool? requestCache = true) => Qs("request_cache", requestCache);
		///<summary>The throttle to set on this request in sub-requests per second. -1 means no throttle.</summary>
		public UpdateByQueryDescriptor<T> RequestsPerSecond(long? requestsPerSecond) => Qs("requests_per_second", requestsPerSecond);
		///<summary>
		/// A document is routed to a particular shard in an index using the following formula
		/// <para> shard_num = hash(_routing) % num_primary_shards</para>
		/// <para>Elasticsearch will use the document id if not provided. </para>
		/// <para>For requests that are constructed from/for a document NEST will automatically infer the routing key
		/// if that document has a <see cref = "Nest.JoinField"/> or a routing mapping on for its type exists on <see cref = "Nest.ConnectionSettings"/></para> 
		///</summary>
		public UpdateByQueryDescriptor<T> Routing(Routing routing) => Qs("routing", routing);
		///<summary>Specify how long a consistent view of the index should be maintained for scrolled search</summary>
		public UpdateByQueryDescriptor<T> Scroll(Time scroll) => Qs("scroll", scroll);
		///<summary>Size on the scroll request powering the update by query</summary>
		public UpdateByQueryDescriptor<T> ScrollSize(long? scrollSize) => Qs("scroll_size", scrollSize);
		///<summary>Explicit timeout for each search request. Defaults to no timeout.</summary>
		public UpdateByQueryDescriptor<T> SearchTimeout(Time searchTimeout) => Qs("search_timeout", searchTimeout);
		///<summary>Search operation type</summary>
		public UpdateByQueryDescriptor<T> SearchType(SearchType? searchType) => Qs("search_type", searchType);
		///<summary>Number of hits to return (default: 10)</summary>
		public UpdateByQueryDescriptor<T> Size(long? size) => Qs("size", size);
		///<summary>The number of slices this task should be divided into. Defaults to 1 meaning the task isn't sliced into subtasks.</summary>
		public UpdateByQueryDescriptor<T> Slices(long? slices) => Qs("slices", slices);
		///<summary>A comma-separated list of <field>:<direction> pairs</summary>
		public UpdateByQueryDescriptor<T> Sort(params string[] sort) => Qs("sort", sort);
		///<summary>Whether the _source should be included in the response.</summary>
		public UpdateByQueryDescriptor<T> SourceEnabled(bool? sourceEnabled = true) => Qs("_source", sourceEnabled);
		///<summary>A list of fields to exclude from the returned _source field</summary>
		public UpdateByQueryDescriptor<T> SourceExcludes(Fields sourceExcludes) => Qs("_source_excludes", sourceExcludes);
		///<summary>A list of fields to exclude from the returned _source field</summary>
		public UpdateByQueryDescriptor<T> SourceExcludes(params Expression<Func<T, object>>[] fields) => Qs("_source_excludes", fields?.Select(e => (Field)e));
		///<summary>A list of fields to extract and return from the _source field</summary>
		public UpdateByQueryDescriptor<T> SourceIncludes(Fields sourceIncludes) => Qs("_source_includes", sourceIncludes);
		///<summary>A list of fields to extract and return from the _source field</summary>
		public UpdateByQueryDescriptor<T> SourceIncludes(params Expression<Func<T, object>>[] fields) => Qs("_source_includes", fields?.Select(e => (Field)e));
		///<summary>Specific 'tag' of the request for logging and statistical purposes</summary>
		public UpdateByQueryDescriptor<T> Stats(params string[] stats) => Qs("stats", stats);
		///<summary>The maximum number of documents to collect for each shard, upon reaching which the query execution will terminate early.</summary>
		public UpdateByQueryDescriptor<T> TerminateAfter(long? terminateAfter) => Qs("terminate_after", terminateAfter);
		///<summary>Time each individual bulk request should wait for shards that are unavailable.</summary>
		public UpdateByQueryDescriptor<T> Timeout(Time timeout) => Qs("timeout", timeout);
		///<summary>Specify whether to return document version as part of a hit</summary>
		public UpdateByQueryDescriptor<T> Version(bool? version = true) => Qs("version", version);
		///<summary>Should the document increment the version number (internal) on hit or not (reindex)</summary>
		public UpdateByQueryDescriptor<T> VersionType(bool? versionType = true) => Qs("version_type", versionType);
		///<summary>Sets the number of shard copies that must be active before proceeding with the update by query operation. Defaults to 1, meaning the primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1)</summary>
		public UpdateByQueryDescriptor<T> WaitForActiveShards(string waitForActiveShards) => Qs("wait_for_active_shards", waitForActiveShards);
		///<summary>Should the request should block until the update by query operation is complete.</summary>
		public UpdateByQueryDescriptor<T> WaitForCompletion(bool? waitForCompletion = true) => Qs("wait_for_completion", waitForCompletion);
	}

	///<summary>descriptor for UpdateByQueryRethrottle <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-update-by-query.html</pre></summary>
	public partial class UpdateByQueryRethrottleDescriptor : RequestDescriptorBase<UpdateByQueryRethrottleDescriptor, UpdateByQueryRethrottleRequestParameters, IUpdateByQueryRethrottleRequest>, IUpdateByQueryRethrottleRequest
	{
		internal override ApiUrls ApiUrls => UpdateByQueryRethrottleRequest.Urls;
		///<summary>/_update_by_query/{task_id}/_rethrottle</summary>
		///<param name = "task_id">this parameter is required</param>
		public UpdateByQueryRethrottleDescriptor(TaskId task_id): base(r => r.Required("task_id", task_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal UpdateByQueryRethrottleDescriptor(): base()
		{
		}

		// values part of the url path
		TaskId IUpdateByQueryRethrottleRequest.TaskId => Self.RouteValues.Get<TaskId>("task_id");
		// Request parameters
		///<summary>The throttle to set on this request in floating sub-requests per second. -1 means set no throttle.</summary>
		public UpdateByQueryRethrottleDescriptor RequestsPerSecond(long? requestsPerSecond) => Qs("requests_per_second", requestsPerSecond);
	}

	///<summary>descriptor for AcknowledgeWatch <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/watcher-api-ack-watch.html</pre></summary>
	public partial class AcknowledgeWatchDescriptor : RequestDescriptorBase<AcknowledgeWatchDescriptor, AcknowledgeWatchRequestParameters, IAcknowledgeWatchRequest>, IAcknowledgeWatchRequest
	{
		internal override ApiUrls ApiUrls => AcknowledgeWatchRequest.Urls;
		///<summary>/_watcher/watch/{watch_id}/_ack</summary>
		///<param name = "watch_id">this parameter is required</param>
		public AcknowledgeWatchDescriptor(Id watch_id): base(r => r.Required("watch_id", watch_id))
		{
		}

		///<summary>/_watcher/watch/{watch_id}/_ack/{action_id}</summary>
		///<param name = "watch_id">this parameter is required</param>
		///<param name = "action_id">Optional, accepts null</param>
		public AcknowledgeWatchDescriptor(Id watch_id, ActionIds action_id): base(r => r.Required("watch_id", watch_id).Optional("action_id", action_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal AcknowledgeWatchDescriptor(): base()
		{
		}

		// values part of the url path
		Id IAcknowledgeWatchRequest.WatchId => Self.RouteValues.Get<Id>("watch_id");
		ActionIds IAcknowledgeWatchRequest.ActionId => Self.RouteValues.Get<ActionIds>("action_id");
		///<summary>A comma-separated list of the action ids to be acked</summary>
		public AcknowledgeWatchDescriptor ActionId(ActionIds actionId) => Assign(actionId, (a, v) => a.RouteValues.Optional("action_id", v));
	// Request parameters
	}

	///<summary>descriptor for ActivateWatch <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/watcher-api-activate-watch.html</pre></summary>
	public partial class ActivateWatchDescriptor : RequestDescriptorBase<ActivateWatchDescriptor, ActivateWatchRequestParameters, IActivateWatchRequest>, IActivateWatchRequest
	{
		internal override ApiUrls ApiUrls => ActivateWatchRequest.Urls;
		///<summary>/_watcher/watch/{watch_id}/_activate</summary>
		///<param name = "watch_id">this parameter is required</param>
		public ActivateWatchDescriptor(Id watch_id): base(r => r.Required("watch_id", watch_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal ActivateWatchDescriptor(): base()
		{
		}

		// values part of the url path
		Id IActivateWatchRequest.WatchId => Self.RouteValues.Get<Id>("watch_id");
	// Request parameters
	}

	///<summary>descriptor for DeactivateWatch <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/watcher-api-deactivate-watch.html</pre></summary>
	public partial class DeactivateWatchDescriptor : RequestDescriptorBase<DeactivateWatchDescriptor, DeactivateWatchRequestParameters, IDeactivateWatchRequest>, IDeactivateWatchRequest
	{
		internal override ApiUrls ApiUrls => DeactivateWatchRequest.Urls;
		///<summary>/_watcher/watch/{watch_id}/_deactivate</summary>
		///<param name = "watch_id">this parameter is required</param>
		public DeactivateWatchDescriptor(Id watch_id): base(r => r.Required("watch_id", watch_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal DeactivateWatchDescriptor(): base()
		{
		}

		// values part of the url path
		Id IDeactivateWatchRequest.WatchId => Self.RouteValues.Get<Id>("watch_id");
	// Request parameters
	}

	///<summary>descriptor for DeleteWatch <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/watcher-api-delete-watch.html</pre></summary>
	public partial class DeleteWatchDescriptor : RequestDescriptorBase<DeleteWatchDescriptor, DeleteWatchRequestParameters, IDeleteWatchRequest>, IDeleteWatchRequest
	{
		internal override ApiUrls ApiUrls => DeleteWatchRequest.Urls;
		///<summary>/_watcher/watch/{id}</summary>
		///<param name = "id">this parameter is required</param>
		public DeleteWatchDescriptor(Id id): base(r => r.Required("id", id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal DeleteWatchDescriptor(): base()
		{
		}

		// values part of the url path
		Id IDeleteWatchRequest.Id => Self.RouteValues.Get<Id>("id");
	// Request parameters
	}

	///<summary>descriptor for ExecuteWatch <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/watcher-api-execute-watch.html</pre></summary>
	public partial class ExecuteWatchDescriptor : RequestDescriptorBase<ExecuteWatchDescriptor, ExecuteWatchRequestParameters, IExecuteWatchRequest>, IExecuteWatchRequest
	{
		internal override ApiUrls ApiUrls => ExecuteWatchRequest.Urls;
		///<summary>/_watcher/watch/{id}/_execute</summary>
		///<param name = "id">Optional, accepts null</param>
		public ExecuteWatchDescriptor(Id id): base(r => r.Optional("id", id))
		{
		}

		///<summary>/_watcher/watch/_execute</summary>
		public ExecuteWatchDescriptor(): base()
		{
		}

		// values part of the url path
		Id IExecuteWatchRequest.Id => Self.RouteValues.Get<Id>("id");
		///<summary>Watch ID</summary>
		public ExecuteWatchDescriptor Id(Id id) => Assign(id, (a, v) => a.RouteValues.Optional("id", v));
		// Request parameters
		///<summary>indicates whether the watch should execute in debug mode</summary>
		public ExecuteWatchDescriptor Debug(bool? debug = true) => Qs("debug", debug);
	}

	///<summary>descriptor for GetWatch <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/watcher-api-get-watch.html</pre></summary>
	public partial class GetWatchDescriptor : RequestDescriptorBase<GetWatchDescriptor, GetWatchRequestParameters, IGetWatchRequest>, IGetWatchRequest
	{
		internal override ApiUrls ApiUrls => GetWatchRequest.Urls;
		///<summary>/_watcher/watch/{id}</summary>
		///<param name = "id">this parameter is required</param>
		public GetWatchDescriptor(Id id): base(r => r.Required("id", id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal GetWatchDescriptor(): base()
		{
		}

		// values part of the url path
		Id IGetWatchRequest.Id => Self.RouteValues.Get<Id>("id");
	// Request parameters
	}

	///<summary>descriptor for PutWatch <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/watcher-api-put-watch.html</pre></summary>
	public partial class PutWatchDescriptor : RequestDescriptorBase<PutWatchDescriptor, PutWatchRequestParameters, IPutWatchRequest>, IPutWatchRequest
	{
		internal override ApiUrls ApiUrls => PutWatchRequest.Urls;
		///<summary>/_watcher/watch/{id}</summary>
		///<param name = "id">this parameter is required</param>
		public PutWatchDescriptor(Id id): base(r => r.Required("id", id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal PutWatchDescriptor(): base()
		{
		}

		// values part of the url path
		Id IPutWatchRequest.Id => Self.RouteValues.Get<Id>("id");
		// Request parameters
		///<summary>Specify whether the watch is in/active by default</summary>
		public PutWatchDescriptor Active(bool? active = true) => Qs("active", active);
		///<summary>only update the watch if the last operation that has changed the watch has the specified primary term</summary>
		public PutWatchDescriptor IfPrimaryTerm(long? ifPrimaryTerm) => Qs("if_primary_term", ifPrimaryTerm);
		///<summary>only update the watch if the last operation that has changed the watch has the specified sequence number</summary>
		public PutWatchDescriptor IfSequenceNumber(long? ifSequenceNumber) => Qs("if_seq_no", ifSequenceNumber);
		///<summary>Explicit version number for concurrency control</summary>
		public PutWatchDescriptor Version(long? version) => Qs("version", version);
	}

	///<summary>descriptor for StartWatcher <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/watcher-api-start.html</pre></summary>
	public partial class StartWatcherDescriptor : RequestDescriptorBase<StartWatcherDescriptor, StartWatcherRequestParameters, IStartWatcherRequest>, IStartWatcherRequest
	{
		internal override ApiUrls ApiUrls => StartWatcherRequest.Urls;
	// values part of the url path
	// Request parameters
	}

	///<summary>descriptor for Stats <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/watcher-api-stats.html</pre></summary>
	public partial class WatcherStatsDescriptor : RequestDescriptorBase<WatcherStatsDescriptor, WatcherStatsRequestParameters, IWatcherStatsRequest>, IWatcherStatsRequest
	{
		internal override ApiUrls ApiUrls => WatcherStatsRequest.Urls;
		///<summary>/_watcher/stats</summary>
		public WatcherStatsDescriptor(): base()
		{
		}

		///<summary>/_watcher/stats/{metric}</summary>
		///<param name = "metric">Optional, accepts null</param>
		public WatcherStatsDescriptor(Metrics metric): base(r => r.Optional("metric", metric))
		{
		}

		// values part of the url path
		Metrics IWatcherStatsRequest.Metric => Self.RouteValues.Get<Metrics>("metric");
		///<summary>Controls what additional stat metrics should be include in the response</summary>
		public WatcherStatsDescriptor Metric(Metrics metric) => Assign(metric, (a, v) => a.RouteValues.Optional("metric", (Metrics)v));
		// Request parameters
		///<summary>Emits stack traces of currently running watches</summary>
		public WatcherStatsDescriptor EmitStacktraces(bool? emitStacktraces = true) => Qs("emit_stacktraces", emitStacktraces);
	}

	///<summary>descriptor for StopWatcher <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/watcher-api-stop.html</pre></summary>
	public partial class StopWatcherDescriptor : RequestDescriptorBase<StopWatcherDescriptor, StopWatcherRequestParameters, IStopWatcherRequest>, IStopWatcherRequest
	{
		internal override ApiUrls ApiUrls => StopWatcherRequest.Urls;
	// values part of the url path
	// Request parameters
	}

	///<summary>descriptor for XPackInfo <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/info-api.html</pre></summary>
	public partial class XPackInfoDescriptor : RequestDescriptorBase<XPackInfoDescriptor, XPackInfoRequestParameters, IXPackInfoRequest>, IXPackInfoRequest
	{
		internal override ApiUrls ApiUrls => XPackInfoRequest.Urls;
		// values part of the url path
		// Request parameters
		///<summary>Comma-separated list of info categories. Can be any of: build, license, features</summary>
		public XPackInfoDescriptor Categories(params string[] categories) => Qs("categories", categories);
	}

	///<summary>descriptor for XPackUsage <pre>Retrieve information about xpack features usage</pre></summary>
	public partial class XPackUsageDescriptor : RequestDescriptorBase<XPackUsageDescriptor, XPackUsageRequestParameters, IXPackUsageRequest>, IXPackUsageRequest
	{
		internal override ApiUrls ApiUrls => XPackUsageRequest.Urls;
		// values part of the url path
		// Request parameters
		///<summary>Specify timeout for watch write operation</summary>
		public XPackUsageDescriptor MasterTimeout(Time masterTimeout) => Qs("master_timeout", masterTimeout);
	}
}