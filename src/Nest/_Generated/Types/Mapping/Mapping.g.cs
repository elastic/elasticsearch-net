// Licensed to Elasticsearch B.V under one or more agreements.
// Elasticsearch B.V licenses this file to you under the Apache 2.0 License.
// See the LICENSE file in the project root for more information.
//
// ███╗   ██╗ ██████╗ ████████╗██╗ ██████╗███████╗
// ████╗  ██║██╔═══██╗╚══██╔══╝██║██╔════╝██╔════╝
// ██╔██╗ ██║██║   ██║   ██║   ██║██║     █████╗
// ██║╚██╗██║██║   ██║   ██║   ██║██║     ██╔══╝
// ██║ ╚████║╚██████╔╝   ██║   ██║╚██████╗███████╗
// ╚═╝  ╚═══╝ ╚═════╝    ╚═╝   ╚═╝ ╚═════╝╚══════╝
// ------------------------------------------------
//
// This file is automatically generated.
// Please do not edit these files manually.
//
// ------------------------------------------------

using Elastic.Transport.Products.Elasticsearch.Failures;
using OneOf;
using System;
using System.Collections.Generic;
using System.Text.Json.Serialization;

#nullable restore
namespace Nest.Mapping
{
	public partial class AllField
	{
		[JsonPropertyName("analyzer")]
		public string Analyzer { get; set; }

		[JsonPropertyName("enabled")]
		public bool Enabled { get; set; }

		[JsonPropertyName("omit_norms")]
		public bool OmitNorms { get; set; }

		[JsonPropertyName("search_analyzer")]
		public string SearchAnalyzer { get; set; }

		[JsonPropertyName("similarity")]
		public string Similarity { get; set; }

		[JsonPropertyName("store")]
		public bool Store { get; set; }

		[JsonPropertyName("store_term_vector_offsets")]
		public bool StoreTermVectorOffsets { get; set; }

		[JsonPropertyName("store_term_vector_payloads")]
		public bool StoreTermVectorPayloads { get; set; }

		[JsonPropertyName("store_term_vector_positions")]
		public bool StoreTermVectorPositions { get; set; }

		[JsonPropertyName("store_term_vectors")]
		public bool StoreTermVectors { get; set; }
	}

	public partial class BinaryProperty
	{
		[JsonPropertyName("type")]
		public string Type => "binary";
	}

	public partial class BooleanProperty
	{
		[JsonPropertyName("boost")]
		public double? Boost
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("fielddata")]
		public Nest.IndexManagement.NumericFielddata? Fielddata
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("index")]
		public bool? Index
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("null_value")]
		public bool? NullValue
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("type")]
		public string Type => "boolean";
	}

	public partial class CompletionProperty
	{
		[JsonPropertyName("analyzer")]
		public string? Analyzer
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("contexts")]
		public IReadOnlyCollection<Nest.Mapping.SuggestContext>? Contexts
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("max_input_length")]
		public int? MaxInputLength
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("preserve_position_increments")]
		public bool? PreservePositionIncrements
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("preserve_separators")]
		public bool? PreserveSeparators
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("search_analyzer")]
		public string? SearchAnalyzer
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("type")]
		public string Type => "completion";
	}

	public partial class ConstantKeywordProperty : Mapping.PropertyBase
	{
		[JsonPropertyName("type")]
		public string Type => "constant_keyword";
		[JsonPropertyName("value")]
		public object? Value
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}
	}

	public partial class DateNanosProperty
	{
		[JsonPropertyName("boost")]
		public double? Boost
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("format")]
		public string? Format
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("ignore_malformed")]
		public bool? IgnoreMalformed
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("index")]
		public bool? Index
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("null_value")]
		public Nest.DateString? NullValue
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("precision_step")]
		public int? PrecisionStep
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("type")]
		public string Type => "date_nanos";
	}

	public partial class DateProperty
	{
		[JsonPropertyName("boost")]
		public double? Boost
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("fielddata")]
		public Nest.IndexManagement.NumericFielddata? Fielddata
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("format")]
		public string? Format
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("ignore_malformed")]
		public bool? IgnoreMalformed
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("index")]
		public bool? Index
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("null_value")]
		public Nest.DateString? NullValue
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("precision_step")]
		public int? PrecisionStep
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("type")]
		public string Type => "date";
	}

	public partial class DateRangeProperty
	{
		[JsonPropertyName("format")]
		public string? Format
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("type")]
		public string Type => "date_range";
	}

	public partial class DoubleRangeProperty
	{
		[JsonPropertyName("type")]
		public string Type => "double_range";
	}

	public partial class DynamicTemplate
	{
		[JsonPropertyName("mapping")]
		public Nest.Mapping.PropertyBase? Mapping { get; set; }

		[JsonPropertyName("match")]
		public string? Match { get; set; }

		[JsonPropertyName("match_mapping_type")]
		public string? MatchMappingType { get; set; }

		[JsonPropertyName("match_pattern")]
		public Nest.Mapping.MatchType? MatchPattern { get; set; }

		[JsonPropertyName("path_match")]
		public string? PathMatch { get; set; }

		[JsonPropertyName("path_unmatch")]
		public string? PathUnmatch { get; set; }

		[JsonPropertyName("unmatch")]
		public string? Unmatch { get; set; }
	}

	public partial class FieldAliasProperty : Mapping.PropertyBase
	{
		[JsonPropertyName("path")]
		public Nest.Field? Path
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("type")]
		public string Type => "alias";
	}

	public partial class FieldMapping
	{
	}

	public partial class FieldNamesField
	{
		[JsonPropertyName("enabled")]
		public bool Enabled { get; set; }
	}

	public partial class FlattenedProperty : Mapping.PropertyBase
	{
		[JsonPropertyName("boost")]
		public double? Boost
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("depth_limit")]
		public int? DepthLimit
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("doc_values")]
		public bool? DocValues
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("eager_global_ordinals")]
		public bool? EagerGlobalOrdinals
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("index")]
		public bool? Index
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("index_options")]
		public Nest.Mapping.IndexOptions? IndexOptions
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("null_value")]
		public string? NullValue
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("similarity")]
		public string? Similarity
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("split_queries_on_whitespace")]
		public bool? SplitQueriesOnWhitespace
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("type")]
		public string Type => "flattened";
	}

	public partial class FloatRangeProperty
	{
		[JsonPropertyName("type")]
		public string Type => "float_range";
	}

	public partial class GenericProperty
	{
		[JsonPropertyName("analyzer")]
		public string Analyzer
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("boost")]
		public double Boost
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("fielddata")]
		public Nest.IndexManagement.StringFielddata Fielddata
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("ignore_malformed")]
		public bool IgnoreMalformed
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("index")]
		public bool Index
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("index_options")]
		public Nest.Mapping.IndexOptions IndexOptions
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("norms")]
		public bool Norms
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("null_value")]
		public string NullValue
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("position_increment_gap")]
		public int PositionIncrementGap
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("search_analyzer")]
		public string SearchAnalyzer
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("term_vector")]
		public Nest.Mapping.TermVectorOption TermVector
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("type")]
		public string Type
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}
	}

	public partial class GeoPointProperty
	{
		[JsonPropertyName("ignore_malformed")]
		public bool? IgnoreMalformed
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("ignore_z_value")]
		public bool? IgnoreZValue
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("null_value")]
		public Nest.QueryDsl.GeoLocation? NullValue
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("type")]
		public string Type => "geo_point";
	}

	public partial class GeoShapeProperty
	{
		[JsonPropertyName("coerce")]
		public bool? Coerce
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("ignore_malformed")]
		public bool? IgnoreMalformed
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("ignore_z_value")]
		public bool? IgnoreZValue
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("orientation")]
		public Nest.Mapping.GeoOrientation? Orientation
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("strategy")]
		public Nest.Mapping.GeoStrategy? Strategy
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("type")]
		public string Type => "geo_shape";
	}

	public partial class HistogramProperty : Mapping.PropertyBase
	{
		[JsonPropertyName("ignore_malformed")]
		public bool? IgnoreMalformed
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("type")]
		public string Type => "histogram";
	}

	public partial class IndexField
	{
		[JsonPropertyName("enabled")]
		public bool Enabled { get; set; }
	}

	public partial class IntegerRangeProperty
	{
		[JsonPropertyName("type")]
		public string Type => "integer_range";
	}

	public partial class IpProperty
	{
		[JsonPropertyName("boost")]
		public double? Boost
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("index")]
		public bool? Index
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("null_value")]
		public string? NullValue
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("type")]
		public string Type => "ip";
	}

	public partial class IpRangeProperty
	{
		[JsonPropertyName("type")]
		public string Type => "ip_range";
	}

	public partial class JoinProperty : Mapping.PropertyBase
	{
		[JsonPropertyName("relations")]
		public Dictionary<Nest.RelationName, Union<Nest.RelationName, IReadOnlyCollection<Nest.RelationName>>>? Relations
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("type")]
		public string Type => "join";
	}

	public partial class KeywordProperty
	{
		[JsonPropertyName("boost")]
		public double? Boost
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("eager_global_ordinals")]
		public bool? EagerGlobalOrdinals
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("index")]
		public bool? Index
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("index_options")]
		public Nest.Mapping.IndexOptions? IndexOptions
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("normalizer")]
		public string? Normalizer
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("norms")]
		public bool? Norms
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("null_value")]
		public string? NullValue
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("split_queries_on_whitespace")]
		public bool? SplitQueriesOnWhitespace
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("type")]
		public string Type => "keyword";
	}

	public partial class LongRangeProperty
	{
		[JsonPropertyName("type")]
		public string Type => "long_range";
	}

	public partial class Murmur3HashProperty
	{
		[JsonPropertyName("type")]
		public string Type => "murmur3";
	}

	public partial class NestedProperty
	{
		[JsonPropertyName("enabled")]
		public bool? Enabled
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("include_in_parent")]
		public bool? IncludeInParent
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("include_in_root")]
		public bool? IncludeInRoot
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("type")]
		public string Type => "nested";
	}

	public partial class NumberProperty
	{
		[JsonPropertyName("boost")]
		public double? Boost
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("coerce")]
		public bool? Coerce
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("fielddata")]
		public Nest.IndexManagement.NumericFielddata? Fielddata
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("ignore_malformed")]
		public bool? IgnoreMalformed
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("index")]
		public bool? Index
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("null_value")]
		public double? NullValue
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("scaling_factor")]
		public double? ScalingFactor
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("type")]
		public Nest.Mapping.NumberType Type
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}
	}

	public partial class ObjectProperty
	{
		[JsonPropertyName("enabled")]
		public bool? Enabled
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("type")]
		public string Type => "object";
	}

	public partial class PercolatorProperty : Mapping.PropertyBase
	{
		[JsonPropertyName("type")]
		public string Type => "percolator";
	}

	public partial class PointProperty
	{
		[JsonPropertyName("ignore_malformed")]
		public bool? IgnoreMalformed
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("ignore_z_value")]
		public bool? IgnoreZValue
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("null_value")]
		public string? NullValue
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("type")]
		public string Type => "point";
	}

	public partial class PropertyBase
	{
		[JsonPropertyName("dynamic")]
		public Union<bool, Nest.Mapping.DynamicMapping>? Dynamic { get; set; }

		[JsonPropertyName("fields")]
		public Dictionary<Nest.PropertyName, Nest.Mapping.Property>? Fields { get; set; }

		[JsonPropertyName("ignore_above")]
		public int? IgnoreAbove { get; set; }

		[JsonPropertyName("local_metadata")]
		public Nest.Metadata? LocalMetadata { get; set; }

		[JsonPropertyName("meta")]
		public Dictionary<string, string>? Meta { get; set; }

		[JsonPropertyName("name")]
		public Nest.PropertyName? Name { get; set; }

		[JsonPropertyName("properties")]
		public Dictionary<Nest.PropertyName, Nest.Mapping.Property>? Properties { get; set; }
	}

	public partial class RankFeatureProperty : Mapping.PropertyBase
	{
		[JsonPropertyName("positive_score_impact")]
		public bool? PositiveScoreImpact
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("type")]
		public string Type => "rank_feature";
	}

	public partial class RankFeaturesProperty : Mapping.PropertyBase
	{
		[JsonPropertyName("type")]
		public string Type => "rank_features";
	}

	public partial class RoutingField
	{
		[JsonPropertyName("required")]
		public bool Required { get; set; }
	}

	public partial class RuntimeField
	{
		[JsonPropertyName("format")]
		public string? Format { get; set; }

		[JsonPropertyName("script")]
		public Nest.Script? Script { get; set; }

		[JsonPropertyName("type")]
		public Nest.Mapping.RuntimeFieldType Type { get; set; }
	}

	public partial class SearchAsYouTypeProperty
	{
		[JsonPropertyName("analyzer")]
		public string? Analyzer
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("index")]
		public bool? Index
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("index_options")]
		public Nest.Mapping.IndexOptions? IndexOptions
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("max_shingle_size")]
		public int? MaxShingleSize
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("norms")]
		public bool? Norms
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("search_analyzer")]
		public string? SearchAnalyzer
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("search_quote_analyzer")]
		public string? SearchQuoteAnalyzer
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("term_vector")]
		public Nest.Mapping.TermVectorOption? TermVector
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("type")]
		public string Type => "search_as_you_type";
	}

	public partial class ShapeProperty
	{
		[JsonPropertyName("coerce")]
		public bool? Coerce
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("ignore_malformed")]
		public bool? IgnoreMalformed
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("ignore_z_value")]
		public bool? IgnoreZValue
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("orientation")]
		public Nest.Mapping.ShapeOrientation? Orientation
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("type")]
		public string Type => "shape";
	}

	public partial class SizeField
	{
		[JsonPropertyName("enabled")]
		public bool Enabled { get; set; }
	}

	public partial class SourceField
	{
		[JsonPropertyName("compress")]
		public bool? Compress { get; set; }

		[JsonPropertyName("compress_threshold")]
		public string? CompressThreshold { get; set; }

		[JsonPropertyName("enabled")]
		public bool Enabled { get; set; }

		[JsonPropertyName("excludes")]
		public IEnumerable<string>? Excludes { get; set; }

		[JsonPropertyName("includes")]
		public IEnumerable<string>? Includes { get; set; }
	}

	public partial class SuggestContext
	{
		[JsonPropertyName("name")]
		public Nest.Name Name
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("path")]
		public Nest.Field? Path
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("precision")]
		public int? Precision
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("type")]
		public string Type
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}
	}

	public partial class TextIndexPrefixes
	{
		[JsonPropertyName("max_chars")]
		public int MaxChars
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("min_chars")]
		public int MinChars
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}
	}

	public partial class TextProperty
	{
		[JsonPropertyName("analyzer")]
		public string? Analyzer
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("boost")]
		public double? Boost
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("eager_global_ordinals")]
		public bool? EagerGlobalOrdinals
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("fielddata")]
		public bool? Fielddata
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("fielddata_frequency_filter")]
		public Nest.IndexManagement.FielddataFrequencyFilter? FielddataFrequencyFilter
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("index")]
		public bool? Index
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("index_options")]
		public Nest.Mapping.IndexOptions? IndexOptions
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("index_phrases")]
		public bool? IndexPhrases
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("index_prefixes")]
		public Nest.Mapping.TextIndexPrefixes? IndexPrefixes
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("norms")]
		public bool? Norms
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("position_increment_gap")]
		public int? PositionIncrementGap
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("search_analyzer")]
		public string? SearchAnalyzer
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("search_quote_analyzer")]
		public string? SearchQuoteAnalyzer
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("term_vector")]
		public Nest.Mapping.TermVectorOption? TermVector
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("type")]
		public string Type => "text";
	}

	public partial class TokenCountProperty
	{
		[JsonPropertyName("analyzer")]
		public string? Analyzer
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("boost")]
		public double? Boost
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("enable_position_increments")]
		public bool? EnablePositionIncrements
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("index")]
		public bool? Index
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("null_value")]
		public double? NullValue
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("type")]
		public string Type => "token_count";
	}

	public partial class TypeMapping
	{
		[JsonPropertyName("all_field")]
		public Nest.Mapping.AllField? AllField { get; set; }

		[JsonPropertyName("date_detection")]
		public bool? DateDetection { get; set; }

		[JsonPropertyName("dynamic")]
		public Union<bool, Nest.Mapping.DynamicMapping>? Dynamic { get; set; }

		[JsonPropertyName("dynamic_date_formats")]
		public IEnumerable<string>? DynamicDateFormats { get; set; }

		[JsonPropertyName("dynamic_templates")]
		public Union<Dictionary<string, Nest.Mapping.DynamicTemplate>, IEnumerable<Dictionary<string, Nest.Mapping.DynamicTemplate>>>? DynamicTemplates { get; set; }

		[JsonPropertyName("_field_names")]
		public Nest.Mapping.FieldNamesField? FieldNames { get; set; }

		[JsonPropertyName("index_field")]
		public Nest.Mapping.IndexField? IndexField { get; set; }

		[JsonPropertyName("_meta")]
		public Nest.Metadata? Meta { get; set; }

		[JsonPropertyName("numeric_detection")]
		public bool? NumericDetection { get; set; }

		[JsonPropertyName("properties")]
		public Dictionary<Nest.PropertyName, Nest.Mapping.Property>? Properties { get; set; }

		[JsonPropertyName("_routing")]
		public Nest.Mapping.RoutingField? Routing { get; set; }

		[JsonPropertyName("runtime")]
		public Dictionary<string, Nest.Mapping.RuntimeField>? Runtime { get; set; }

		[JsonPropertyName("_size")]
		public Nest.Mapping.SizeField? Size { get; set; }

		[JsonPropertyName("_source")]
		public Nest.Mapping.SourceField? Source { get; set; }
	}

	public partial class VersionProperty
	{
		[JsonPropertyName("type")]
		public string Type => "version";
	}

	public partial class WildcardProperty
	{
		[JsonPropertyName("type")]
		public string Type => "wildcard";
	}
}