// Licensed to Elasticsearch B.V under one or more agreements.
// Elasticsearch B.V licenses this file to you under the Apache 2.0 License.
// See the LICENSE file in the project root for more information.
//
// ███╗   ██╗ ██████╗ ████████╗██╗ ██████╗███████╗
// ████╗  ██║██╔═══██╗╚══██╔══╝██║██╔════╝██╔════╝
// ██╔██╗ ██║██║   ██║   ██║   ██║██║     █████╗
// ██║╚██╗██║██║   ██║   ██║   ██║██║     ██╔══╝
// ██║ ╚████║╚██████╔╝   ██║   ██║╚██████╗███████╗
// ╚═╝  ╚═══╝ ╚═════╝    ╚═╝   ╚═╝ ╚═════╝╚══════╝
// ------------------------------------------------
//
// This file is automatically generated.
// Please do not edit these files manually.
// Run the following in the root of the repository:
//
// ------------------------------------------------

using Elastic.Transport.Products.Elasticsearch.Failures;
using OneOf;
using System;
using System.Collections.Generic;
using System.Text.Json.Serialization;

#nullable restore
namespace Nest.Analysis
{
	public partial class AsciiFoldingTokenFilter
	{
		[JsonPropertyName("preserve_original")]
		public bool PreserveOriginal
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}
	}

	public partial class CharGroupTokenizer
	{
		[JsonPropertyName("tokenize_on_chars")]
		public IReadOnlyCollection<string> TokenizeOnChars
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}
	}

	public partial class CommonGramsTokenFilter
	{
		[JsonPropertyName("common_words")]
		public IReadOnlyCollection<string> CommonWords
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("common_words_path")]
		public string CommonWordsPath
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("ignore_case")]
		public bool IgnoreCase
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("query_mode")]
		public bool QueryMode
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}
	}

	public partial class ConditionTokenFilter
	{
		[JsonPropertyName("filter")]
		public IReadOnlyCollection<string> Filter
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("script")]
		public Nest.Script Script
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}
	}

	public partial class DelimitedPayloadTokenFilter
	{
		[JsonPropertyName("delimiter")]
		public string Delimiter
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("encoding")]
		public Nest.Analysis.DelimitedPayloadEncoding Encoding
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}
	}

	public partial class EdgeNGramTokenFilter
	{
		[JsonPropertyName("max_gram")]
		public int MaxGram
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("min_gram")]
		public int MinGram
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("side")]
		public Nest.Analysis.EdgeNGramSide Side
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}
	}

	public partial class EdgeNGramTokenizer
	{
		[JsonPropertyName("custom_token_chars")]
		public string CustomTokenChars
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("max_gram")]
		public int MaxGram
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("min_gram")]
		public int MinGram
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("token_chars")]
		public IReadOnlyCollection<Nest.Analysis.TokenChar> TokenChars
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}
	}

	public partial class ElisionTokenFilter
	{
		[JsonPropertyName("articles")]
		public IReadOnlyCollection<string> Articles
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("articles_case")]
		public bool ArticlesCase
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}
	}

	public partial class FingerprintTokenFilter
	{
		[JsonPropertyName("max_output_size")]
		public int MaxOutputSize
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("separator")]
		public string Separator
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}
	}

	public partial class HtmlStripCharFilter
	{
	}

	public partial class HunspellTokenFilter
	{
		[JsonPropertyName("dedup")]
		public bool Dedup
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("dictionary")]
		public string Dictionary
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("locale")]
		public string Locale
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("longest_only")]
		public bool LongestOnly
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}
	}

	public partial class HyphenationDecompounderTokenFilter
	{
	}

	public partial class KStemTokenFilter
	{
	}

	public partial class KeepTypesTokenFilter
	{
		[JsonPropertyName("mode")]
		public Nest.Analysis.KeepTypesMode Mode
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("types")]
		public IReadOnlyCollection<string> Types
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}
	}

	public partial class KeepWordsTokenFilter
	{
		[JsonPropertyName("keep_words")]
		public IReadOnlyCollection<string> KeepWords
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("keep_words_case")]
		public bool KeepWordsCase
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("keep_words_path")]
		public string KeepWordsPath
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}
	}

	public partial class KeywordMarkerTokenFilter
	{
		[JsonPropertyName("ignore_case")]
		public bool IgnoreCase
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("keywords")]
		public IReadOnlyCollection<string> Keywords
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("keywords_path")]
		public string KeywordsPath
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("keywords_pattern")]
		public string KeywordsPattern
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}
	}

	public partial class KeywordTokenizer
	{
		[JsonPropertyName("buffer_size")]
		public int BufferSize
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}
	}

	public partial class LengthTokenFilter
	{
		[JsonPropertyName("max")]
		public int Max
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("min")]
		public int Min
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}
	}

	public partial class LetterTokenizer
	{
	}

	public partial class LimitTokenCountTokenFilter
	{
		[JsonPropertyName("consume_all_tokens")]
		public bool ConsumeAllTokens
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("max_token_count")]
		public int MaxTokenCount
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}
	}

	public partial class LowercaseTokenFilter
	{
		[JsonPropertyName("language")]
		public string Language
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}
	}

	public partial class LowercaseTokenizer
	{
	}

	public partial class MappingCharFilter
	{
		[JsonPropertyName("mappings")]
		public IReadOnlyCollection<string> Mappings
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("mappings_path")]
		public string MappingsPath
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}
	}

	public partial class MultiplexerTokenFilter
	{
		[JsonPropertyName("filters")]
		public IReadOnlyCollection<string> Filters
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("preserve_original")]
		public bool PreserveOriginal
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}
	}

	public partial class NGramTokenFilter
	{
		[JsonPropertyName("max_gram")]
		public int MaxGram
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("min_gram")]
		public int MinGram
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}
	}

	public partial class NGramTokenizer
	{
		[JsonPropertyName("custom_token_chars")]
		public string CustomTokenChars
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("max_gram")]
		public int MaxGram
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("min_gram")]
		public int MinGram
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("token_chars")]
		public IReadOnlyCollection<Nest.Analysis.TokenChar> TokenChars
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}
	}

	public partial class NoriPartOfSpeechTokenFilter
	{
		[JsonPropertyName("stoptags")]
		public IReadOnlyCollection<string> Stoptags
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}
	}

	public partial class NoriTokenizer
	{
		[JsonPropertyName("decompound_mode")]
		public Nest.Analysis.NoriDecompoundMode DecompoundMode
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("discard_punctuation")]
		public bool DiscardPunctuation
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("user_dictionary")]
		public string UserDictionary
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("user_dictionary_rules")]
		public IReadOnlyCollection<string> UserDictionaryRules
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}
	}

	public partial class PathHierarchyTokenizer
	{
		[JsonPropertyName("buffer_size")]
		public int BufferSize
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("delimiter")]
		public string Delimiter
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("replacement")]
		public string Replacement
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("reverse")]
		public bool Reverse
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("skip")]
		public int Skip
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}
	}

	public partial class PatternCaptureTokenFilter
	{
		[JsonPropertyName("patterns")]
		public IReadOnlyCollection<string> Patterns
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("preserve_original")]
		public bool PreserveOriginal
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}
	}

	public partial class PatternReplaceTokenFilter
	{
		[JsonPropertyName("flags")]
		public string Flags
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("pattern")]
		public string Pattern
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("replacement")]
		public string Replacement
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}
	}

	public partial class PorterStemTokenFilter
	{
	}

	public partial class PredicateTokenFilter
	{
		[JsonPropertyName("script")]
		public Nest.Script Script
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}
	}

	public partial class RemoveDuplicatesTokenFilter
	{
	}

	public partial class ReverseTokenFilter
	{
	}

	public partial class ShingleTokenFilter
	{
		[JsonPropertyName("filler_token")]
		public string FillerToken
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("max_shingle_size")]
		public int MaxShingleSize
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("min_shingle_size")]
		public int MinShingleSize
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("output_unigrams")]
		public bool OutputUnigrams
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("output_unigrams_if_no_shingles")]
		public bool OutputUnigramsIfNoShingles
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("token_separator")]
		public string TokenSeparator
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}
	}

	public partial class SnowballTokenFilter
	{
		[JsonPropertyName("language")]
		public Nest.Analysis.SnowballLanguage Language
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}
	}

	public partial class StandardTokenizer
	{
		[JsonPropertyName("max_token_length")]
		public int MaxTokenLength
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}
	}

	public partial class StemmerOverrideTokenFilter
	{
		[JsonPropertyName("rules")]
		public IReadOnlyCollection<string> Rules
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("rules_path")]
		public string RulesPath
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}
	}

	public partial class StemmerTokenFilter
	{
		[JsonPropertyName("language")]
		public string Language
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}
	}

	public partial class StopTokenFilter
	{
		[JsonPropertyName("ignore_case")]
		public bool? IgnoreCase
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("remove_trailing")]
		public bool? RemoveTrailing
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("stopwords")]
		public Nest.Analysis.StopWords Stopwords
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("stopwords_path")]
		public string? StopwordsPath
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}
	}

	public partial class SynonymGraphTokenFilter
	{
		[JsonPropertyName("expand")]
		public bool Expand
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("format")]
		public Nest.Analysis.SynonymFormat Format
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("lenient")]
		public bool Lenient
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("synonyms")]
		public IReadOnlyCollection<string> Synonyms
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("synonyms_path")]
		public string SynonymsPath
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("tokenizer")]
		public string Tokenizer
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("updateable")]
		public bool Updateable
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}
	}

	public partial class SynonymTokenFilter
	{
		[JsonPropertyName("expand")]
		public bool Expand
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("format")]
		public Nest.Analysis.SynonymFormat Format
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("lenient")]
		public bool Lenient
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("synonyms")]
		public IReadOnlyCollection<string> Synonyms
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("synonyms_path")]
		public string SynonymsPath
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("tokenizer")]
		public string Tokenizer
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("updateable")]
		public bool Updateable
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}
	}

	public partial class TrimTokenFilter
	{
	}

	public partial class TruncateTokenFilter
	{
		[JsonPropertyName("length")]
		public int Length
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}
	}

	public partial class UaxEmailUrlTokenizer
	{
		[JsonPropertyName("max_token_length")]
		public int MaxTokenLength
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}
	}

	public partial class UniqueTokenFilter
	{
		[JsonPropertyName("only_on_same_position")]
		public bool OnlyOnSamePosition
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}
	}

	public partial class UppercaseTokenFilter
	{
	}

	public partial class WhitespaceTokenizer
	{
		[JsonPropertyName("max_token_length")]
		public int MaxTokenLength
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}
	}

	public partial class WordDelimiterGraphTokenFilter
	{
		[JsonPropertyName("adjust_offsets")]
		public bool AdjustOffsets
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("catenate_all")]
		public bool CatenateAll
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("catenate_numbers")]
		public bool CatenateNumbers
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("catenate_words")]
		public bool CatenateWords
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("generate_number_parts")]
		public bool GenerateNumberParts
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("generate_word_parts")]
		public bool GenerateWordParts
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("preserve_original")]
		public bool PreserveOriginal
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("protected_words")]
		public IReadOnlyCollection<string> ProtectedWords
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("protected_words_path")]
		public string ProtectedWordsPath
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("split_on_case_change")]
		public bool SplitOnCaseChange
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("split_on_numerics")]
		public bool SplitOnNumerics
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("stem_english_possessive")]
		public bool StemEnglishPossessive
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("type_table")]
		public IReadOnlyCollection<string> TypeTable
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("type_table_path")]
		public string TypeTablePath
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}
	}

	public partial class WordDelimiterTokenFilter
	{
		[JsonPropertyName("catenate_all")]
		public bool CatenateAll
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("catenate_numbers")]
		public bool CatenateNumbers
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("catenate_words")]
		public bool CatenateWords
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("generate_number_parts")]
		public bool GenerateNumberParts
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("generate_word_parts")]
		public bool GenerateWordParts
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("preserve_original")]
		public bool PreserveOriginal
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("protected_words")]
		public IReadOnlyCollection<string> ProtectedWords
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("protected_words_path")]
		public string ProtectedWordsPath
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("split_on_case_change")]
		public bool SplitOnCaseChange
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("split_on_numerics")]
		public bool SplitOnNumerics
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("stem_english_possessive")]
		public bool StemEnglishPossessive
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("type_table")]
		public IReadOnlyCollection<string> TypeTable
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}

		[JsonPropertyName("type_table_path")]
		public string TypeTablePath
		{
			get;
#if NET5_0
			init;
#else
			internal set;
#endif
		}
	}
}