using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Linq.Expressions;
using System.Runtime.Serialization;
using Elasticsearch.Net;

//This file contains all the typed querystring parameters that are generated of the client spec.
//This file is automatically generated from https://github.com/elastic/elasticsearch/tree/master/rest-api-spec
namespace Nest
{
	public abstract partial class PlainRequestBase<TParameters>
	{
		///<summary>Include the stack trace of returned errors.</summary>
		public bool? ErrorTrace
		{
			get => Q<bool? >("error_trace");
			set => Q("error_trace", value);
		}

		///<summary>
		/// A comma-separated list of filters used to reduce the response.
		/// <para>Use of response filtering can result in a response from Elasticsearch
		/// that cannot be correctly deserialized to the respective response type for the request.
		/// In such situations, use the low level client to issue the request and handle response deserialization</para>
		///</summary>
		public string[] FilterPath
		{
			get => Q<string[]>("filter_path");
			set => Q("filter_path", value);
		}

		///<summary>Return human readable values for statistics.</summary>
		public bool? Human
		{
			get => Q<bool? >("human");
			set => Q("human", value);
		}

		///<summary>Pretty format the returned JSON response.</summary>
		public bool? Pretty
		{
			get => Q<bool? >("pretty");
			set => Q("pretty", value);
		}

		///<summary>The URL-encoded request definition. Useful for libraries that do not accept a request body for non-POST requests.</summary>
		public string SourceQueryString
		{
			get => Q<string>("source");
			set => Q("source", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IBulkRequest : IRequest<BulkRequestParameters>
	{
		[IgnoreDataMember]
		IndexName Index
		{
			get;
		}
	}

	///<summary>Request for Bulk <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-bulk.html</pre></summary>
	public partial class BulkRequest : PlainRequestBase<BulkRequestParameters>, IBulkRequest
	{
		protected IBulkRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_bulk", "{index}/_bulk"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_bulk</summary>
		public BulkRequest(): base()
		{
		}

		///<summary>/{index}/_bulk</summary>
		///<param name = "index">Optional, accepts null</param>
		public BulkRequest(IndexName index): base(r => r.Optional("index", index))
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		IndexName IBulkRequest.Index => Self.RouteValues.Get<IndexName>("index");
		// Request parameters
		///<summary>The pipeline id to preprocess incoming documents with</summary>
		public string Pipeline
		{
			get => Q<string>("pipeline");
			set => Q("pipeline", value);
		}

		///<summary>
		/// If `true` then refresh the effected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this
		/// operation visible to search, if `false` (the default) then do nothing with refreshes.
		///</summary>
		public Refresh? Refresh
		{
			get => Q<Refresh? >("refresh");
			set => Q("refresh", value);
		}

		///<summary>
		/// A document is routed to a particular shard in an index using the following formula
		/// <para> shard_num = hash(_routing) % num_primary_shards</para>
		/// <para>Elasticsearch will use the document id if not provided. </para>
		/// <para>For requests that are constructed from/for a document NEST will automatically infer the routing key
		/// if that document has a <see cref = "Nest.JoinField"/> or a routing mapping on for its type exists on <see cref = "Nest.ConnectionSettings"
		////></para>
		///</summary>
		public Routing Routing
		{
			get => Q<Routing>("routing");
			set => Q("routing", value);
		}

		///<summary>Whether the _source should be included in the response.</summary>
		public bool? SourceEnabled
		{
			get => Q<bool? >("_source");
			set => Q("_source", value);
		}

		///<summary>Default list of fields to exclude from the returned _source field, can be overridden on each sub-request</summary>
		public Fields SourceExcludes
		{
			get => Q<Fields>("_source_excludes");
			set => Q("_source_excludes", value);
		}

		///<summary>Default list of fields to extract and return from the _source field, can be overridden on each sub-request</summary>
		public Fields SourceIncludes
		{
			get => Q<Fields>("_source_includes");
			set => Q("_source_includes", value);
		}

		///<summary>Explicit operation timeout</summary>
		public Time Timeout
		{
			get => Q<Time>("timeout");
			set => Q("timeout", value);
		}

		///<summary>Default document type for items which don't provide one</summary>
		public string TypeQueryString
		{
			get => Q<string>("type");
			set => Q("type", value);
		}

		///<summary>
		/// Sets the number of shard copies that must be active before proceeding with the bulk operation. Defaults to 1, meaning the primary shard
		/// only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the
		/// shard (number of replicas + 1)
		///</summary>
		public string WaitForActiveShards
		{
			get => Q<string>("wait_for_active_shards");
			set => Q("wait_for_active_shards", value);
		}
	}

	[InterfaceDataContract]
	public partial interface ICatAliasesRequest : IRequest<CatAliasesRequestParameters>
	{
		[IgnoreDataMember]
		Names Name
		{
			get;
		}
	}

	///<summary>Request for Aliases <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-alias.html</pre></summary>
	public partial class CatAliasesRequest : PlainRequestBase<CatAliasesRequestParameters>, ICatAliasesRequest
	{
		protected ICatAliasesRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_cat/aliases", "_cat/aliases/{name}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_cat/aliases</summary>
		public CatAliasesRequest(): base()
		{
		}

		///<summary>/_cat/aliases/{name}</summary>
		///<param name = "name">Optional, accepts null</param>
		public CatAliasesRequest(Names name): base(r => r.Optional("name", name))
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Names ICatAliasesRequest.Name => Self.RouteValues.Get<Names>("name");
		// Request parameters
		///<summary>a short version of the Accept header, e.g. json, yaml</summary>
		public string Format
		{
			get => Q<string>("format");
			set => Q("format", value);
		}

		///<summary>Comma-separated list of column names to display</summary>
		public string[] Headers
		{
			get => Q<string[]>("h");
			set => Q("h", value);
		}

		///<summary>Return help information</summary>
		public bool? Help
		{
			get => Q<bool? >("help");
			set => Q("help", value);
		}

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public bool? Local
		{
			get => Q<bool? >("local");
			set => Q("local", value);
		}

		///<summary>Explicit operation timeout for connection to master node</summary>
		public Time MasterTimeout
		{
			get => Q<Time>("master_timeout");
			set => Q("master_timeout", value);
		}

		///<summary>Comma-separated list of column names or column aliases to sort by</summary>
		public string[] SortByColumns
		{
			get => Q<string[]>("s");
			set => Q("s", value);
		}

		///<summary>Verbose mode. Display column headers</summary>
		public bool? Verbose
		{
			get => Q<bool? >("v");
			set => Q("v", value);
		}
	}

	[InterfaceDataContract]
	public partial interface ICatAllocationRequest : IRequest<CatAllocationRequestParameters>
	{
		[IgnoreDataMember]
		NodeIds NodeId
		{
			get;
		}
	}

	///<summary>Request for Allocation <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-allocation.html</pre></summary>
	public partial class CatAllocationRequest : PlainRequestBase<CatAllocationRequestParameters>, ICatAllocationRequest
	{
		protected ICatAllocationRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_cat/allocation", "_cat/allocation/{node_id}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_cat/allocation</summary>
		public CatAllocationRequest(): base()
		{
		}

		///<summary>/_cat/allocation/{node_id}</summary>
		///<param name = "node_id">Optional, accepts null</param>
		public CatAllocationRequest(NodeIds node_id): base(r => r.Optional("node_id", node_id))
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		NodeIds ICatAllocationRequest.NodeId => Self.RouteValues.Get<NodeIds>("node_id");
		// Request parameters
		///<summary>The unit in which to display byte values</summary>
		public Bytes? Bytes
		{
			get => Q<Bytes? >("bytes");
			set => Q("bytes", value);
		}

		///<summary>a short version of the Accept header, e.g. json, yaml</summary>
		public string Format
		{
			get => Q<string>("format");
			set => Q("format", value);
		}

		///<summary>Comma-separated list of column names to display</summary>
		public string[] Headers
		{
			get => Q<string[]>("h");
			set => Q("h", value);
		}

		///<summary>Return help information</summary>
		public bool? Help
		{
			get => Q<bool? >("help");
			set => Q("help", value);
		}

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public bool? Local
		{
			get => Q<bool? >("local");
			set => Q("local", value);
		}

		///<summary>Explicit operation timeout for connection to master node</summary>
		public Time MasterTimeout
		{
			get => Q<Time>("master_timeout");
			set => Q("master_timeout", value);
		}

		///<summary>Comma-separated list of column names or column aliases to sort by</summary>
		public string[] SortByColumns
		{
			get => Q<string[]>("s");
			set => Q("s", value);
		}

		///<summary>Verbose mode. Display column headers</summary>
		public bool? Verbose
		{
			get => Q<bool? >("v");
			set => Q("v", value);
		}
	}

	[InterfaceDataContract]
	public partial interface ICatCountRequest : IRequest<CatCountRequestParameters>
	{
		[IgnoreDataMember]
		Indices Index
		{
			get;
		}
	}

	///<summary>Request for Count <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-count.html</pre></summary>
	public partial class CatCountRequest : PlainRequestBase<CatCountRequestParameters>, ICatCountRequest
	{
		protected ICatCountRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_cat/count", "_cat/count/{index}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_cat/count</summary>
		public CatCountRequest(): base()
		{
		}

		///<summary>/_cat/count/{index}</summary>
		///<param name = "index">Optional, accepts null</param>
		public CatCountRequest(Indices index): base(r => r.Optional("index", index))
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Indices ICatCountRequest.Index => Self.RouteValues.Get<Indices>("index");
		// Request parameters
		///<summary>a short version of the Accept header, e.g. json, yaml</summary>
		public string Format
		{
			get => Q<string>("format");
			set => Q("format", value);
		}

		///<summary>Comma-separated list of column names to display</summary>
		public string[] Headers
		{
			get => Q<string[]>("h");
			set => Q("h", value);
		}

		///<summary>Return help information</summary>
		public bool? Help
		{
			get => Q<bool? >("help");
			set => Q("help", value);
		}

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public bool? Local
		{
			get => Q<bool? >("local");
			set => Q("local", value);
		}

		///<summary>Explicit operation timeout for connection to master node</summary>
		public Time MasterTimeout
		{
			get => Q<Time>("master_timeout");
			set => Q("master_timeout", value);
		}

		///<summary>Comma-separated list of column names or column aliases to sort by</summary>
		public string[] SortByColumns
		{
			get => Q<string[]>("s");
			set => Q("s", value);
		}

		///<summary>Verbose mode. Display column headers</summary>
		public bool? Verbose
		{
			get => Q<bool? >("v");
			set => Q("v", value);
		}
	}

	[InterfaceDataContract]
	public partial interface ICatFielddataRequest : IRequest<CatFielddataRequestParameters>
	{
		[IgnoreDataMember]
		Fields Fields
		{
			get;
		}
	}

	///<summary>Request for Fielddata <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-fielddata.html</pre></summary>
	public partial class CatFielddataRequest : PlainRequestBase<CatFielddataRequestParameters>, ICatFielddataRequest
	{
		protected ICatFielddataRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_cat/fielddata", "_cat/fielddata/{fields}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_cat/fielddata</summary>
		public CatFielddataRequest(): base()
		{
		}

		///<summary>/_cat/fielddata/{fields}</summary>
		///<param name = "fields">Optional, accepts null</param>
		public CatFielddataRequest(Fields fields): base(r => r.Optional("fields", fields))
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Fields ICatFielddataRequest.Fields => Self.RouteValues.Get<Fields>("fields");
		// Request parameters
		///<summary>The unit in which to display byte values</summary>
		public Bytes? Bytes
		{
			get => Q<Bytes? >("bytes");
			set => Q("bytes", value);
		}

		///<summary>a short version of the Accept header, e.g. json, yaml</summary>
		public string Format
		{
			get => Q<string>("format");
			set => Q("format", value);
		}

		///<summary>Comma-separated list of column names to display</summary>
		public string[] Headers
		{
			get => Q<string[]>("h");
			set => Q("h", value);
		}

		///<summary>Return help information</summary>
		public bool? Help
		{
			get => Q<bool? >("help");
			set => Q("help", value);
		}

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public bool? Local
		{
			get => Q<bool? >("local");
			set => Q("local", value);
		}

		///<summary>Explicit operation timeout for connection to master node</summary>
		public Time MasterTimeout
		{
			get => Q<Time>("master_timeout");
			set => Q("master_timeout", value);
		}

		///<summary>Comma-separated list of column names or column aliases to sort by</summary>
		public string[] SortByColumns
		{
			get => Q<string[]>("s");
			set => Q("s", value);
		}

		///<summary>Verbose mode. Display column headers</summary>
		public bool? Verbose
		{
			get => Q<bool? >("v");
			set => Q("v", value);
		}
	}

	[InterfaceDataContract]
	public partial interface ICatHealthRequest : IRequest<CatHealthRequestParameters>
	{
	}

	///<summary>Request for Health <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-health.html</pre></summary>
	public partial class CatHealthRequest : PlainRequestBase<CatHealthRequestParameters>, ICatHealthRequest
	{
		protected ICatHealthRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_cat/health"});
		internal override ApiUrls ApiUrls => Urls;
		// values part of the url path
		// Request parameters
		///<summary>a short version of the Accept header, e.g. json, yaml</summary>
		public string Format
		{
			get => Q<string>("format");
			set => Q("format", value);
		}

		///<summary>Comma-separated list of column names to display</summary>
		public string[] Headers
		{
			get => Q<string[]>("h");
			set => Q("h", value);
		}

		///<summary>Return help information</summary>
		public bool? Help
		{
			get => Q<bool? >("help");
			set => Q("help", value);
		}

		///<summary>Set to false to disable timestamping</summary>
		public bool? IncludeTimestamp
		{
			get => Q<bool? >("ts");
			set => Q("ts", value);
		}

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public bool? Local
		{
			get => Q<bool? >("local");
			set => Q("local", value);
		}

		///<summary>Explicit operation timeout for connection to master node</summary>
		public Time MasterTimeout
		{
			get => Q<Time>("master_timeout");
			set => Q("master_timeout", value);
		}

		///<summary>Comma-separated list of column names or column aliases to sort by</summary>
		public string[] SortByColumns
		{
			get => Q<string[]>("s");
			set => Q("s", value);
		}

		///<summary>Verbose mode. Display column headers</summary>
		public bool? Verbose
		{
			get => Q<bool? >("v");
			set => Q("v", value);
		}
	}

	[InterfaceDataContract]
	public partial interface ICatHelpRequest : IRequest<CatHelpRequestParameters>
	{
	}

	///<summary>Request for Help <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat.html</pre></summary>
	public partial class CatHelpRequest : PlainRequestBase<CatHelpRequestParameters>, ICatHelpRequest
	{
		protected ICatHelpRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_cat"});
		internal override ApiUrls ApiUrls => Urls;
		// values part of the url path
		// Request parameters
		///<summary>Return help information</summary>
		public bool? Help
		{
			get => Q<bool? >("help");
			set => Q("help", value);
		}

		///<summary>Comma-separated list of column names or column aliases to sort by</summary>
		public string[] SortByColumns
		{
			get => Q<string[]>("s");
			set => Q("s", value);
		}
	}

	[InterfaceDataContract]
	public partial interface ICatIndicesRequest : IRequest<CatIndicesRequestParameters>
	{
		[IgnoreDataMember]
		Indices Index
		{
			get;
		}
	}

	///<summary>Request for Indices <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-indices.html</pre></summary>
	public partial class CatIndicesRequest : PlainRequestBase<CatIndicesRequestParameters>, ICatIndicesRequest
	{
		protected ICatIndicesRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_cat/indices", "_cat/indices/{index}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_cat/indices</summary>
		public CatIndicesRequest(): base()
		{
		}

		///<summary>/_cat/indices/{index}</summary>
		///<param name = "index">Optional, accepts null</param>
		public CatIndicesRequest(Indices index): base(r => r.Optional("index", index))
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Indices ICatIndicesRequest.Index => Self.RouteValues.Get<Indices>("index");
		// Request parameters
		///<summary>The unit in which to display byte values</summary>
		public Bytes? Bytes
		{
			get => Q<Bytes? >("bytes");
			set => Q("bytes", value);
		}

		///<summary>a short version of the Accept header, e.g. json, yaml</summary>
		public string Format
		{
			get => Q<string>("format");
			set => Q("format", value);
		}

		///<summary>Comma-separated list of column names to display</summary>
		public string[] Headers
		{
			get => Q<string[]>("h");
			set => Q("h", value);
		}

		///<summary>A health status ("green", "yellow", or "red" to filter only indices matching the specified health status</summary>
		public Health? Health
		{
			get => Q<Health? >("health");
			set => Q("health", value);
		}

		///<summary>Return help information</summary>
		public bool? Help
		{
			get => Q<bool? >("help");
			set => Q("help", value);
		}

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public bool? Local
		{
			get => Q<bool? >("local");
			set => Q("local", value);
		}

		///<summary>Explicit operation timeout for connection to master node</summary>
		public Time MasterTimeout
		{
			get => Q<Time>("master_timeout");
			set => Q("master_timeout", value);
		}

		///<summary>Set to true to return stats only for primary shards</summary>
		public bool? Pri
		{
			get => Q<bool? >("pri");
			set => Q("pri", value);
		}

		///<summary>Comma-separated list of column names or column aliases to sort by</summary>
		public string[] SortByColumns
		{
			get => Q<string[]>("s");
			set => Q("s", value);
		}

		///<summary>Verbose mode. Display column headers</summary>
		public bool? Verbose
		{
			get => Q<bool? >("v");
			set => Q("v", value);
		}
	}

	[InterfaceDataContract]
	public partial interface ICatMasterRequest : IRequest<CatMasterRequestParameters>
	{
	}

	///<summary>Request for Master <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-master.html</pre></summary>
	public partial class CatMasterRequest : PlainRequestBase<CatMasterRequestParameters>, ICatMasterRequest
	{
		protected ICatMasterRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_cat/master"});
		internal override ApiUrls ApiUrls => Urls;
		// values part of the url path
		// Request parameters
		///<summary>a short version of the Accept header, e.g. json, yaml</summary>
		public string Format
		{
			get => Q<string>("format");
			set => Q("format", value);
		}

		///<summary>Comma-separated list of column names to display</summary>
		public string[] Headers
		{
			get => Q<string[]>("h");
			set => Q("h", value);
		}

		///<summary>Return help information</summary>
		public bool? Help
		{
			get => Q<bool? >("help");
			set => Q("help", value);
		}

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public bool? Local
		{
			get => Q<bool? >("local");
			set => Q("local", value);
		}

		///<summary>Explicit operation timeout for connection to master node</summary>
		public Time MasterTimeout
		{
			get => Q<Time>("master_timeout");
			set => Q("master_timeout", value);
		}

		///<summary>Comma-separated list of column names or column aliases to sort by</summary>
		public string[] SortByColumns
		{
			get => Q<string[]>("s");
			set => Q("s", value);
		}

		///<summary>Verbose mode. Display column headers</summary>
		public bool? Verbose
		{
			get => Q<bool? >("v");
			set => Q("v", value);
		}
	}

	[InterfaceDataContract]
	public partial interface ICatNodeAttributesRequest : IRequest<CatNodeAttributesRequestParameters>
	{
	}

	///<summary>Request for NodeAttributes <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-nodeattrs.html</pre></summary>
	public partial class CatNodeAttributesRequest : PlainRequestBase<CatNodeAttributesRequestParameters>, ICatNodeAttributesRequest
	{
		protected ICatNodeAttributesRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_cat/nodeattrs"});
		internal override ApiUrls ApiUrls => Urls;
		// values part of the url path
		// Request parameters
		///<summary>a short version of the Accept header, e.g. json, yaml</summary>
		public string Format
		{
			get => Q<string>("format");
			set => Q("format", value);
		}

		///<summary>Comma-separated list of column names to display</summary>
		public string[] Headers
		{
			get => Q<string[]>("h");
			set => Q("h", value);
		}

		///<summary>Return help information</summary>
		public bool? Help
		{
			get => Q<bool? >("help");
			set => Q("help", value);
		}

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public bool? Local
		{
			get => Q<bool? >("local");
			set => Q("local", value);
		}

		///<summary>Explicit operation timeout for connection to master node</summary>
		public Time MasterTimeout
		{
			get => Q<Time>("master_timeout");
			set => Q("master_timeout", value);
		}

		///<summary>Comma-separated list of column names or column aliases to sort by</summary>
		public string[] SortByColumns
		{
			get => Q<string[]>("s");
			set => Q("s", value);
		}

		///<summary>Verbose mode. Display column headers</summary>
		public bool? Verbose
		{
			get => Q<bool? >("v");
			set => Q("v", value);
		}
	}

	[InterfaceDataContract]
	public partial interface ICatNodesRequest : IRequest<CatNodesRequestParameters>
	{
	}

	///<summary>Request for Nodes <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-nodes.html</pre></summary>
	public partial class CatNodesRequest : PlainRequestBase<CatNodesRequestParameters>, ICatNodesRequest
	{
		protected ICatNodesRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_cat/nodes"});
		internal override ApiUrls ApiUrls => Urls;
		// values part of the url path
		// Request parameters
		///<summary>a short version of the Accept header, e.g. json, yaml</summary>
		public string Format
		{
			get => Q<string>("format");
			set => Q("format", value);
		}

		///<summary>Return the full node ID instead of the shortened version (default: false)</summary>
		public bool? FullId
		{
			get => Q<bool? >("full_id");
			set => Q("full_id", value);
		}

		///<summary>Comma-separated list of column names to display</summary>
		public string[] Headers
		{
			get => Q<string[]>("h");
			set => Q("h", value);
		}

		///<summary>Return help information</summary>
		public bool? Help
		{
			get => Q<bool? >("help");
			set => Q("help", value);
		}

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public bool? Local
		{
			get => Q<bool? >("local");
			set => Q("local", value);
		}

		///<summary>Explicit operation timeout for connection to master node</summary>
		public Time MasterTimeout
		{
			get => Q<Time>("master_timeout");
			set => Q("master_timeout", value);
		}

		///<summary>Comma-separated list of column names or column aliases to sort by</summary>
		public string[] SortByColumns
		{
			get => Q<string[]>("s");
			set => Q("s", value);
		}

		///<summary>Verbose mode. Display column headers</summary>
		public bool? Verbose
		{
			get => Q<bool? >("v");
			set => Q("v", value);
		}
	}

	[InterfaceDataContract]
	public partial interface ICatPendingTasksRequest : IRequest<CatPendingTasksRequestParameters>
	{
	}

	///<summary>Request for PendingTasks <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-pending-tasks.html</pre></summary>
	public partial class CatPendingTasksRequest : PlainRequestBase<CatPendingTasksRequestParameters>, ICatPendingTasksRequest
	{
		protected ICatPendingTasksRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_cat/pending_tasks"});
		internal override ApiUrls ApiUrls => Urls;
		// values part of the url path
		// Request parameters
		///<summary>a short version of the Accept header, e.g. json, yaml</summary>
		public string Format
		{
			get => Q<string>("format");
			set => Q("format", value);
		}

		///<summary>Comma-separated list of column names to display</summary>
		public string[] Headers
		{
			get => Q<string[]>("h");
			set => Q("h", value);
		}

		///<summary>Return help information</summary>
		public bool? Help
		{
			get => Q<bool? >("help");
			set => Q("help", value);
		}

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public bool? Local
		{
			get => Q<bool? >("local");
			set => Q("local", value);
		}

		///<summary>Explicit operation timeout for connection to master node</summary>
		public Time MasterTimeout
		{
			get => Q<Time>("master_timeout");
			set => Q("master_timeout", value);
		}

		///<summary>Comma-separated list of column names or column aliases to sort by</summary>
		public string[] SortByColumns
		{
			get => Q<string[]>("s");
			set => Q("s", value);
		}

		///<summary>Verbose mode. Display column headers</summary>
		public bool? Verbose
		{
			get => Q<bool? >("v");
			set => Q("v", value);
		}
	}

	[InterfaceDataContract]
	public partial interface ICatPluginsRequest : IRequest<CatPluginsRequestParameters>
	{
	}

	///<summary>Request for Plugins <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-plugins.html</pre></summary>
	public partial class CatPluginsRequest : PlainRequestBase<CatPluginsRequestParameters>, ICatPluginsRequest
	{
		protected ICatPluginsRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_cat/plugins"});
		internal override ApiUrls ApiUrls => Urls;
		// values part of the url path
		// Request parameters
		///<summary>a short version of the Accept header, e.g. json, yaml</summary>
		public string Format
		{
			get => Q<string>("format");
			set => Q("format", value);
		}

		///<summary>Comma-separated list of column names to display</summary>
		public string[] Headers
		{
			get => Q<string[]>("h");
			set => Q("h", value);
		}

		///<summary>Return help information</summary>
		public bool? Help
		{
			get => Q<bool? >("help");
			set => Q("help", value);
		}

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public bool? Local
		{
			get => Q<bool? >("local");
			set => Q("local", value);
		}

		///<summary>Explicit operation timeout for connection to master node</summary>
		public Time MasterTimeout
		{
			get => Q<Time>("master_timeout");
			set => Q("master_timeout", value);
		}

		///<summary>Comma-separated list of column names or column aliases to sort by</summary>
		public string[] SortByColumns
		{
			get => Q<string[]>("s");
			set => Q("s", value);
		}

		///<summary>Verbose mode. Display column headers</summary>
		public bool? Verbose
		{
			get => Q<bool? >("v");
			set => Q("v", value);
		}
	}

	[InterfaceDataContract]
	public partial interface ICatRecoveryRequest : IRequest<CatRecoveryRequestParameters>
	{
		[IgnoreDataMember]
		Indices Index
		{
			get;
		}
	}

	///<summary>Request for Recovery <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-recovery.html</pre></summary>
	public partial class CatRecoveryRequest : PlainRequestBase<CatRecoveryRequestParameters>, ICatRecoveryRequest
	{
		protected ICatRecoveryRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_cat/recovery", "_cat/recovery/{index}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_cat/recovery</summary>
		public CatRecoveryRequest(): base()
		{
		}

		///<summary>/_cat/recovery/{index}</summary>
		///<param name = "index">Optional, accepts null</param>
		public CatRecoveryRequest(Indices index): base(r => r.Optional("index", index))
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Indices ICatRecoveryRequest.Index => Self.RouteValues.Get<Indices>("index");
		// Request parameters
		///<summary>The unit in which to display byte values</summary>
		public Bytes? Bytes
		{
			get => Q<Bytes? >("bytes");
			set => Q("bytes", value);
		}

		///<summary>a short version of the Accept header, e.g. json, yaml</summary>
		public string Format
		{
			get => Q<string>("format");
			set => Q("format", value);
		}

		///<summary>Comma-separated list of column names to display</summary>
		public string[] Headers
		{
			get => Q<string[]>("h");
			set => Q("h", value);
		}

		///<summary>Return help information</summary>
		public bool? Help
		{
			get => Q<bool? >("help");
			set => Q("help", value);
		}

		///<summary>Explicit operation timeout for connection to master node</summary>
		public Time MasterTimeout
		{
			get => Q<Time>("master_timeout");
			set => Q("master_timeout", value);
		}

		///<summary>Comma-separated list of column names or column aliases to sort by</summary>
		public string[] SortByColumns
		{
			get => Q<string[]>("s");
			set => Q("s", value);
		}

		///<summary>Verbose mode. Display column headers</summary>
		public bool? Verbose
		{
			get => Q<bool? >("v");
			set => Q("v", value);
		}
	}

	[InterfaceDataContract]
	public partial interface ICatRepositoriesRequest : IRequest<CatRepositoriesRequestParameters>
	{
	}

	///<summary>Request for Repositories <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-repositories.html</pre></summary>
	public partial class CatRepositoriesRequest : PlainRequestBase<CatRepositoriesRequestParameters>, ICatRepositoriesRequest
	{
		protected ICatRepositoriesRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_cat/repositories"});
		internal override ApiUrls ApiUrls => Urls;
		// values part of the url path
		// Request parameters
		///<summary>a short version of the Accept header, e.g. json, yaml</summary>
		public string Format
		{
			get => Q<string>("format");
			set => Q("format", value);
		}

		///<summary>Comma-separated list of column names to display</summary>
		public string[] Headers
		{
			get => Q<string[]>("h");
			set => Q("h", value);
		}

		///<summary>Return help information</summary>
		public bool? Help
		{
			get => Q<bool? >("help");
			set => Q("help", value);
		}

		///<summary>Return local information, do not retrieve the state from master node</summary>
		public bool? Local
		{
			get => Q<bool? >("local");
			set => Q("local", value);
		}

		///<summary>Explicit operation timeout for connection to master node</summary>
		public Time MasterTimeout
		{
			get => Q<Time>("master_timeout");
			set => Q("master_timeout", value);
		}

		///<summary>Comma-separated list of column names or column aliases to sort by</summary>
		public string[] SortByColumns
		{
			get => Q<string[]>("s");
			set => Q("s", value);
		}

		///<summary>Verbose mode. Display column headers</summary>
		public bool? Verbose
		{
			get => Q<bool? >("v");
			set => Q("v", value);
		}
	}

	[InterfaceDataContract]
	public partial interface ICatSegmentsRequest : IRequest<CatSegmentsRequestParameters>
	{
		[IgnoreDataMember]
		Indices Index
		{
			get;
		}
	}

	///<summary>Request for Segments <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-segments.html</pre></summary>
	public partial class CatSegmentsRequest : PlainRequestBase<CatSegmentsRequestParameters>, ICatSegmentsRequest
	{
		protected ICatSegmentsRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_cat/segments", "_cat/segments/{index}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_cat/segments</summary>
		public CatSegmentsRequest(): base()
		{
		}

		///<summary>/_cat/segments/{index}</summary>
		///<param name = "index">Optional, accepts null</param>
		public CatSegmentsRequest(Indices index): base(r => r.Optional("index", index))
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Indices ICatSegmentsRequest.Index => Self.RouteValues.Get<Indices>("index");
		// Request parameters
		///<summary>The unit in which to display byte values</summary>
		public Bytes? Bytes
		{
			get => Q<Bytes? >("bytes");
			set => Q("bytes", value);
		}

		///<summary>a short version of the Accept header, e.g. json, yaml</summary>
		public string Format
		{
			get => Q<string>("format");
			set => Q("format", value);
		}

		///<summary>Comma-separated list of column names to display</summary>
		public string[] Headers
		{
			get => Q<string[]>("h");
			set => Q("h", value);
		}

		///<summary>Return help information</summary>
		public bool? Help
		{
			get => Q<bool? >("help");
			set => Q("help", value);
		}

		///<summary>Comma-separated list of column names or column aliases to sort by</summary>
		public string[] SortByColumns
		{
			get => Q<string[]>("s");
			set => Q("s", value);
		}

		///<summary>Verbose mode. Display column headers</summary>
		public bool? Verbose
		{
			get => Q<bool? >("v");
			set => Q("v", value);
		}
	}

	[InterfaceDataContract]
	public partial interface ICatShardsRequest : IRequest<CatShardsRequestParameters>
	{
		[IgnoreDataMember]
		Indices Index
		{
			get;
		}
	}

	///<summary>Request for Shards <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-shards.html</pre></summary>
	public partial class CatShardsRequest : PlainRequestBase<CatShardsRequestParameters>, ICatShardsRequest
	{
		protected ICatShardsRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_cat/shards", "_cat/shards/{index}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_cat/shards</summary>
		public CatShardsRequest(): base()
		{
		}

		///<summary>/_cat/shards/{index}</summary>
		///<param name = "index">Optional, accepts null</param>
		public CatShardsRequest(Indices index): base(r => r.Optional("index", index))
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Indices ICatShardsRequest.Index => Self.RouteValues.Get<Indices>("index");
		// Request parameters
		///<summary>The unit in which to display byte values</summary>
		public Bytes? Bytes
		{
			get => Q<Bytes? >("bytes");
			set => Q("bytes", value);
		}

		///<summary>a short version of the Accept header, e.g. json, yaml</summary>
		public string Format
		{
			get => Q<string>("format");
			set => Q("format", value);
		}

		///<summary>Comma-separated list of column names to display</summary>
		public string[] Headers
		{
			get => Q<string[]>("h");
			set => Q("h", value);
		}

		///<summary>Return help information</summary>
		public bool? Help
		{
			get => Q<bool? >("help");
			set => Q("help", value);
		}

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public bool? Local
		{
			get => Q<bool? >("local");
			set => Q("local", value);
		}

		///<summary>Explicit operation timeout for connection to master node</summary>
		public Time MasterTimeout
		{
			get => Q<Time>("master_timeout");
			set => Q("master_timeout", value);
		}

		///<summary>Comma-separated list of column names or column aliases to sort by</summary>
		public string[] SortByColumns
		{
			get => Q<string[]>("s");
			set => Q("s", value);
		}

		///<summary>Verbose mode. Display column headers</summary>
		public bool? Verbose
		{
			get => Q<bool? >("v");
			set => Q("v", value);
		}
	}

	[InterfaceDataContract]
	public partial interface ICatSnapshotsRequest : IRequest<CatSnapshotsRequestParameters>
	{
		[IgnoreDataMember]
		Names RepositoryName
		{
			get;
		}
	}

	///<summary>Request for Snapshots <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-snapshots.html</pre></summary>
	public partial class CatSnapshotsRequest : PlainRequestBase<CatSnapshotsRequestParameters>, ICatSnapshotsRequest
	{
		protected ICatSnapshotsRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_cat/snapshots", "_cat/snapshots/{repository}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_cat/snapshots</summary>
		public CatSnapshotsRequest(): base()
		{
		}

		///<summary>/_cat/snapshots/{repository}</summary>
		///<param name = "repository">Optional, accepts null</param>
		public CatSnapshotsRequest(Names repository): base(r => r.Optional("repository", repository))
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Names ICatSnapshotsRequest.RepositoryName => Self.RouteValues.Get<Names>("repository");
		// Request parameters
		///<summary>a short version of the Accept header, e.g. json, yaml</summary>
		public string Format
		{
			get => Q<string>("format");
			set => Q("format", value);
		}

		///<summary>Comma-separated list of column names to display</summary>
		public string[] Headers
		{
			get => Q<string[]>("h");
			set => Q("h", value);
		}

		///<summary>Return help information</summary>
		public bool? Help
		{
			get => Q<bool? >("help");
			set => Q("help", value);
		}

		///<summary>Set to true to ignore unavailable snapshots</summary>
		public bool? IgnoreUnavailable
		{
			get => Q<bool? >("ignore_unavailable");
			set => Q("ignore_unavailable", value);
		}

		///<summary>Explicit operation timeout for connection to master node</summary>
		public Time MasterTimeout
		{
			get => Q<Time>("master_timeout");
			set => Q("master_timeout", value);
		}

		///<summary>Comma-separated list of column names or column aliases to sort by</summary>
		public string[] SortByColumns
		{
			get => Q<string[]>("s");
			set => Q("s", value);
		}

		///<summary>Verbose mode. Display column headers</summary>
		public bool? Verbose
		{
			get => Q<bool? >("v");
			set => Q("v", value);
		}
	}

	[InterfaceDataContract]
	public partial interface ICatTasksRequest : IRequest<CatTasksRequestParameters>
	{
	}

	///<summary>Request for Tasks <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/tasks.html</pre></summary>
	public partial class CatTasksRequest : PlainRequestBase<CatTasksRequestParameters>, ICatTasksRequest
	{
		protected ICatTasksRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_cat/tasks"});
		internal override ApiUrls ApiUrls => Urls;
		// values part of the url path
		// Request parameters
		///<summary>A comma-separated list of actions that should be returned. Leave empty to return all.</summary>
		public string[] Actions
		{
			get => Q<string[]>("actions");
			set => Q("actions", value);
		}

		///<summary>Return detailed task information (default: false)</summary>
		public bool? Detailed
		{
			get => Q<bool? >("detailed");
			set => Q("detailed", value);
		}

		///<summary>a short version of the Accept header, e.g. json, yaml</summary>
		public string Format
		{
			get => Q<string>("format");
			set => Q("format", value);
		}

		///<summary>Comma-separated list of column names to display</summary>
		public string[] Headers
		{
			get => Q<string[]>("h");
			set => Q("h", value);
		}

		///<summary>Return help information</summary>
		public bool? Help
		{
			get => Q<bool? >("help");
			set => Q("help", value);
		}

		///<summary>
		/// A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're
		/// connecting to, leave empty to get information from all nodes
		///</summary>
		public string[] NodeId
		{
			get => Q<string[]>("node_id");
			set => Q("node_id", value);
		}

		///<summary>Return tasks with specified parent task id. Set to -1 to return all.</summary>
		public long? ParentTask
		{
			get => Q<long? >("parent_task");
			set => Q("parent_task", value);
		}

		///<summary>Comma-separated list of column names or column aliases to sort by</summary>
		public string[] SortByColumns
		{
			get => Q<string[]>("s");
			set => Q("s", value);
		}

		///<summary>Verbose mode. Display column headers</summary>
		public bool? Verbose
		{
			get => Q<bool? >("v");
			set => Q("v", value);
		}
	}

	[InterfaceDataContract]
	public partial interface ICatTemplatesRequest : IRequest<CatTemplatesRequestParameters>
	{
		[IgnoreDataMember]
		Name Name
		{
			get;
		}
	}

	///<summary>Request for Templates <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-templates.html</pre></summary>
	public partial class CatTemplatesRequest : PlainRequestBase<CatTemplatesRequestParameters>, ICatTemplatesRequest
	{
		protected ICatTemplatesRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_cat/templates", "_cat/templates/{name}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_cat/templates</summary>
		public CatTemplatesRequest(): base()
		{
		}

		///<summary>/_cat/templates/{name}</summary>
		///<param name = "name">Optional, accepts null</param>
		public CatTemplatesRequest(Name name): base(r => r.Optional("name", name))
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Name ICatTemplatesRequest.Name => Self.RouteValues.Get<Name>("name");
		// Request parameters
		///<summary>a short version of the Accept header, e.g. json, yaml</summary>
		public string Format
		{
			get => Q<string>("format");
			set => Q("format", value);
		}

		///<summary>Comma-separated list of column names to display</summary>
		public string[] Headers
		{
			get => Q<string[]>("h");
			set => Q("h", value);
		}

		///<summary>Return help information</summary>
		public bool? Help
		{
			get => Q<bool? >("help");
			set => Q("help", value);
		}

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public bool? Local
		{
			get => Q<bool? >("local");
			set => Q("local", value);
		}

		///<summary>Explicit operation timeout for connection to master node</summary>
		public Time MasterTimeout
		{
			get => Q<Time>("master_timeout");
			set => Q("master_timeout", value);
		}

		///<summary>Comma-separated list of column names or column aliases to sort by</summary>
		public string[] SortByColumns
		{
			get => Q<string[]>("s");
			set => Q("s", value);
		}

		///<summary>Verbose mode. Display column headers</summary>
		public bool? Verbose
		{
			get => Q<bool? >("v");
			set => Q("v", value);
		}
	}

	[InterfaceDataContract]
	public partial interface ICatThreadPoolRequest : IRequest<CatThreadPoolRequestParameters>
	{
		[IgnoreDataMember]
		Names ThreadPoolPatterns
		{
			get;
		}
	}

	///<summary>Request for ThreadPool <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-thread-pool.html</pre></summary>
	public partial class CatThreadPoolRequest : PlainRequestBase<CatThreadPoolRequestParameters>, ICatThreadPoolRequest
	{
		protected ICatThreadPoolRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_cat/thread_pool", "_cat/thread_pool/{thread_pool_patterns}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_cat/thread_pool</summary>
		public CatThreadPoolRequest(): base()
		{
		}

		///<summary>/_cat/thread_pool/{thread_pool_patterns}</summary>
		///<param name = "thread_pool_patterns">Optional, accepts null</param>
		public CatThreadPoolRequest(Names thread_pool_patterns): base(r => r.Optional("thread_pool_patterns", thread_pool_patterns))
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Names ICatThreadPoolRequest.ThreadPoolPatterns => Self.RouteValues.Get<Names>("thread_pool_patterns");
		// Request parameters
		///<summary>a short version of the Accept header, e.g. json, yaml</summary>
		public string Format
		{
			get => Q<string>("format");
			set => Q("format", value);
		}

		///<summary>Comma-separated list of column names to display</summary>
		public string[] Headers
		{
			get => Q<string[]>("h");
			set => Q("h", value);
		}

		///<summary>Return help information</summary>
		public bool? Help
		{
			get => Q<bool? >("help");
			set => Q("help", value);
		}

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public bool? Local
		{
			get => Q<bool? >("local");
			set => Q("local", value);
		}

		///<summary>Explicit operation timeout for connection to master node</summary>
		public Time MasterTimeout
		{
			get => Q<Time>("master_timeout");
			set => Q("master_timeout", value);
		}

		///<summary>The multiplier in which to display values</summary>
		public Size? Size
		{
			get => Q<Size? >("size");
			set => Q("size", value);
		}

		///<summary>Comma-separated list of column names or column aliases to sort by</summary>
		public string[] SortByColumns
		{
			get => Q<string[]>("s");
			set => Q("s", value);
		}

		///<summary>Verbose mode. Display column headers</summary>
		public bool? Verbose
		{
			get => Q<bool? >("v");
			set => Q("v", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IDeleteAutoFollowPatternRequest : IRequest<DeleteAutoFollowPatternRequestParameters>
	{
		[IgnoreDataMember]
		Name Name
		{
			get;
		}
	}

	///<summary>Request for DeleteAutoFollowPattern <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/ccr-delete-auto-follow-pattern.html</pre></summary>
	public partial class DeleteAutoFollowPatternRequest : PlainRequestBase<DeleteAutoFollowPatternRequestParameters>, IDeleteAutoFollowPatternRequest
	{
		protected IDeleteAutoFollowPatternRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_ccr/auto_follow/{name}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_ccr/auto_follow/{name}</summary>
		///<param name = "name">this parameter is required</param>
		public DeleteAutoFollowPatternRequest(Name name): base(r => r.Required("name", name))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal DeleteAutoFollowPatternRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Name IDeleteAutoFollowPatternRequest.Name => Self.RouteValues.Get<Name>("name");
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface ICreateFollowIndexRequest : IRequest<CreateFollowIndexRequestParameters>
	{
		[IgnoreDataMember]
		IndexName Index
		{
			get;
		}
	}

	///<summary>Request for CreateFollowIndex <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/ccr-put-follow.html</pre></summary>
	public partial class CreateFollowIndexRequest : PlainRequestBase<CreateFollowIndexRequestParameters>, ICreateFollowIndexRequest
	{
		protected ICreateFollowIndexRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"{index}/_ccr/follow"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/{index}/_ccr/follow</summary>
		///<param name = "index">this parameter is required</param>
		public CreateFollowIndexRequest(IndexName index): base(r => r.Required("index", index))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal CreateFollowIndexRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		IndexName ICreateFollowIndexRequest.Index => Self.RouteValues.Get<IndexName>("index");
		// Request parameters
		///<summary>
		/// Sets the number of shard copies that must be active before returning. Defaults to 0. Set to `all` for all shard copies, otherwise set to
		/// any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1)
		///</summary>
		public string WaitForActiveShards
		{
			get => Q<string>("wait_for_active_shards");
			set => Q("wait_for_active_shards", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IFollowIndexStatsRequest : IRequest<FollowIndexStatsRequestParameters>
	{
		[IgnoreDataMember]
		Indices Index
		{
			get;
		}
	}

	///<summary>Request for FollowIndexStats <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/ccr-get-follow-stats.html</pre></summary>
	public partial class FollowIndexStatsRequest : PlainRequestBase<FollowIndexStatsRequestParameters>, IFollowIndexStatsRequest
	{
		protected IFollowIndexStatsRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"{index}/_ccr/stats"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/{index}/_ccr/stats</summary>
		///<param name = "index">this parameter is required</param>
		public FollowIndexStatsRequest(Indices index): base(r => r.Required("index", index))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal FollowIndexStatsRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Indices IFollowIndexStatsRequest.Index => Self.RouteValues.Get<Indices>("index");
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IGetAutoFollowPatternRequest : IRequest<GetAutoFollowPatternRequestParameters>
	{
		[IgnoreDataMember]
		Name Name
		{
			get;
		}
	}

	///<summary>Request for GetAutoFollowPattern <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/ccr-get-auto-follow-pattern.html</pre></summary>
	public partial class GetAutoFollowPatternRequest : PlainRequestBase<GetAutoFollowPatternRequestParameters>, IGetAutoFollowPatternRequest
	{
		protected IGetAutoFollowPatternRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_ccr/auto_follow", "_ccr/auto_follow/{name}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_ccr/auto_follow</summary>
		public GetAutoFollowPatternRequest(): base()
		{
		}

		///<summary>/_ccr/auto_follow/{name}</summary>
		///<param name = "name">Optional, accepts null</param>
		public GetAutoFollowPatternRequest(Name name): base(r => r.Optional("name", name))
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Name IGetAutoFollowPatternRequest.Name => Self.RouteValues.Get<Name>("name");
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IPauseFollowIndexRequest : IRequest<PauseFollowIndexRequestParameters>
	{
		[IgnoreDataMember]
		IndexName Index
		{
			get;
		}
	}

	///<summary>Request for PauseFollowIndex <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/ccr-post-pause-follow.html</pre></summary>
	public partial class PauseFollowIndexRequest : PlainRequestBase<PauseFollowIndexRequestParameters>, IPauseFollowIndexRequest
	{
		protected IPauseFollowIndexRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"{index}/_ccr/pause_follow"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/{index}/_ccr/pause_follow</summary>
		///<param name = "index">this parameter is required</param>
		public PauseFollowIndexRequest(IndexName index): base(r => r.Required("index", index))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal PauseFollowIndexRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		IndexName IPauseFollowIndexRequest.Index => Self.RouteValues.Get<IndexName>("index");
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface ICreateAutoFollowPatternRequest : IRequest<CreateAutoFollowPatternRequestParameters>
	{
		[IgnoreDataMember]
		Name Name
		{
			get;
		}
	}

	///<summary>Request for CreateAutoFollowPattern <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/ccr-put-auto-follow-pattern.html</pre></summary>
	public partial class CreateAutoFollowPatternRequest : PlainRequestBase<CreateAutoFollowPatternRequestParameters>, ICreateAutoFollowPatternRequest
	{
		protected ICreateAutoFollowPatternRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_ccr/auto_follow/{name}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_ccr/auto_follow/{name}</summary>
		///<param name = "name">this parameter is required</param>
		public CreateAutoFollowPatternRequest(Name name): base(r => r.Required("name", name))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal CreateAutoFollowPatternRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Name ICreateAutoFollowPatternRequest.Name => Self.RouteValues.Get<Name>("name");
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IResumeFollowIndexRequest : IRequest<ResumeFollowIndexRequestParameters>
	{
		[IgnoreDataMember]
		IndexName Index
		{
			get;
		}
	}

	///<summary>Request for ResumeFollowIndex <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/ccr-post-resume-follow.html</pre></summary>
	public partial class ResumeFollowIndexRequest : PlainRequestBase<ResumeFollowIndexRequestParameters>, IResumeFollowIndexRequest
	{
		protected IResumeFollowIndexRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"{index}/_ccr/resume_follow"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/{index}/_ccr/resume_follow</summary>
		///<param name = "index">this parameter is required</param>
		public ResumeFollowIndexRequest(IndexName index): base(r => r.Required("index", index))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal ResumeFollowIndexRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		IndexName IResumeFollowIndexRequest.Index => Self.RouteValues.Get<IndexName>("index");
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface ICcrStatsRequest : IRequest<CcrStatsRequestParameters>
	{
	}

	///<summary>Request for CcrStats <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/ccr-get-stats.html</pre></summary>
	public partial class CcrStatsRequest : PlainRequestBase<CcrStatsRequestParameters>, ICcrStatsRequest
	{
		protected ICcrStatsRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_ccr/stats"});
		internal override ApiUrls ApiUrls => Urls;
	// values part of the url path
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IUnfollowIndexRequest : IRequest<UnfollowIndexRequestParameters>
	{
		[IgnoreDataMember]
		IndexName Index
		{
			get;
		}
	}

	///<summary>Request for UnfollowIndex <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current</pre></summary>
	public partial class UnfollowIndexRequest : PlainRequestBase<UnfollowIndexRequestParameters>, IUnfollowIndexRequest
	{
		protected IUnfollowIndexRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"{index}/_ccr/unfollow"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/{index}/_ccr/unfollow</summary>
		///<param name = "index">this parameter is required</param>
		public UnfollowIndexRequest(IndexName index): base(r => r.Required("index", index))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal UnfollowIndexRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		IndexName IUnfollowIndexRequest.Index => Self.RouteValues.Get<IndexName>("index");
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IClearScrollRequest : IRequest<ClearScrollRequestParameters>
	{
	}

	///<summary>Request for ClearScroll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/search-request-scroll.html</pre></summary>
	public partial class ClearScrollRequest : PlainRequestBase<ClearScrollRequestParameters>, IClearScrollRequest
	{
		protected IClearScrollRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_search/scroll"});
		internal override ApiUrls ApiUrls => Urls;
	// values part of the url path
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IClusterAllocationExplainRequest : IRequest<ClusterAllocationExplainRequestParameters>
	{
	}

	///<summary>Request for AllocationExplain <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-allocation-explain.html</pre></summary>
	public partial class ClusterAllocationExplainRequest : PlainRequestBase<ClusterAllocationExplainRequestParameters>, IClusterAllocationExplainRequest
	{
		protected IClusterAllocationExplainRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_cluster/allocation/explain"});
		internal override ApiUrls ApiUrls => Urls;
		// values part of the url path
		// Request parameters
		///<summary>Return information about disk usage and shard sizes (default: false)</summary>
		public bool? IncludeDiskInfo
		{
			get => Q<bool? >("include_disk_info");
			set => Q("include_disk_info", value);
		}

		///<summary>Return 'YES' decisions in explanation (default: false)</summary>
		public bool? IncludeYesDecisions
		{
			get => Q<bool? >("include_yes_decisions");
			set => Q("include_yes_decisions", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IClusterGetSettingsRequest : IRequest<ClusterGetSettingsRequestParameters>
	{
	}

	///<summary>Request for GetSettings <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-update-settings.html</pre></summary>
	public partial class ClusterGetSettingsRequest : PlainRequestBase<ClusterGetSettingsRequestParameters>, IClusterGetSettingsRequest
	{
		protected IClusterGetSettingsRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_cluster/settings"});
		internal override ApiUrls ApiUrls => Urls;
		// values part of the url path
		// Request parameters
		///<summary>Return settings in flat format (default: false)</summary>
		public bool? FlatSettings
		{
			get => Q<bool? >("flat_settings");
			set => Q("flat_settings", value);
		}

		///<summary>Whether to return all default clusters setting.</summary>
		public bool? IncludeDefaults
		{
			get => Q<bool? >("include_defaults");
			set => Q("include_defaults", value);
		}

		///<summary>Explicit operation timeout for connection to master node</summary>
		public Time MasterTimeout
		{
			get => Q<Time>("master_timeout");
			set => Q("master_timeout", value);
		}

		///<summary>Explicit operation timeout</summary>
		public Time Timeout
		{
			get => Q<Time>("timeout");
			set => Q("timeout", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IClusterHealthRequest : IRequest<ClusterHealthRequestParameters>
	{
		[IgnoreDataMember]
		Indices Index
		{
			get;
		}
	}

	///<summary>Request for Health <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-health.html</pre></summary>
	public partial class ClusterHealthRequest : PlainRequestBase<ClusterHealthRequestParameters>, IClusterHealthRequest
	{
		protected IClusterHealthRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_cluster/health", "_cluster/health/{index}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_cluster/health</summary>
		public ClusterHealthRequest(): base()
		{
		}

		///<summary>/_cluster/health/{index}</summary>
		///<param name = "index">Optional, accepts null</param>
		public ClusterHealthRequest(Indices index): base(r => r.Optional("index", index))
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Indices IClusterHealthRequest.Index => Self.RouteValues.Get<Indices>("index");
		// Request parameters
		///<summary>Specify the level of detail for returned information</summary>
		public Level? Level
		{
			get => Q<Level? >("level");
			set => Q("level", value);
		}

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public bool? Local
		{
			get => Q<bool? >("local");
			set => Q("local", value);
		}

		///<summary>Explicit operation timeout for connection to master node</summary>
		public Time MasterTimeout
		{
			get => Q<Time>("master_timeout");
			set => Q("master_timeout", value);
		}

		///<summary>Explicit operation timeout</summary>
		public Time Timeout
		{
			get => Q<Time>("timeout");
			set => Q("timeout", value);
		}

		///<summary>Wait until the specified number of shards is active</summary>
		public string WaitForActiveShards
		{
			get => Q<string>("wait_for_active_shards");
			set => Q("wait_for_active_shards", value);
		}

		///<summary>Wait until all currently queued events with the given priority are processed</summary>
		public WaitForEvents? WaitForEvents
		{
			get => Q<WaitForEvents? >("wait_for_events");
			set => Q("wait_for_events", value);
		}

		///<summary>Whether to wait until there are no initializing shards in the cluster</summary>
		public bool? WaitForNoInitializingShards
		{
			get => Q<bool? >("wait_for_no_initializing_shards");
			set => Q("wait_for_no_initializing_shards", value);
		}

		///<summary>Whether to wait until there are no relocating shards in the cluster</summary>
		public bool? WaitForNoRelocatingShards
		{
			get => Q<bool? >("wait_for_no_relocating_shards");
			set => Q("wait_for_no_relocating_shards", value);
		}

		///<summary>Wait until the specified number of nodes is available</summary>
		public string WaitForNodes
		{
			get => Q<string>("wait_for_nodes");
			set => Q("wait_for_nodes", value);
		}

		///<summary>Wait until cluster is in a specific state</summary>
		public WaitForStatus? WaitForStatus
		{
			get => Q<WaitForStatus? >("wait_for_status");
			set => Q("wait_for_status", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IClusterPendingTasksRequest : IRequest<ClusterPendingTasksRequestParameters>
	{
	}

	///<summary>Request for PendingTasks <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-pending.html</pre></summary>
	public partial class ClusterPendingTasksRequest : PlainRequestBase<ClusterPendingTasksRequestParameters>, IClusterPendingTasksRequest
	{
		protected IClusterPendingTasksRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_cluster/pending_tasks"});
		internal override ApiUrls ApiUrls => Urls;
		// values part of the url path
		// Request parameters
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public bool? Local
		{
			get => Q<bool? >("local");
			set => Q("local", value);
		}

		///<summary>Specify timeout for connection to master</summary>
		public Time MasterTimeout
		{
			get => Q<Time>("master_timeout");
			set => Q("master_timeout", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IClusterPutSettingsRequest : IRequest<ClusterPutSettingsRequestParameters>
	{
	}

	///<summary>Request for PutSettings <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-update-settings.html</pre></summary>
	public partial class ClusterPutSettingsRequest : PlainRequestBase<ClusterPutSettingsRequestParameters>, IClusterPutSettingsRequest
	{
		protected IClusterPutSettingsRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_cluster/settings"});
		internal override ApiUrls ApiUrls => Urls;
		// values part of the url path
		// Request parameters
		///<summary>Return settings in flat format (default: false)</summary>
		public bool? FlatSettings
		{
			get => Q<bool? >("flat_settings");
			set => Q("flat_settings", value);
		}

		///<summary>Explicit operation timeout for connection to master node</summary>
		public Time MasterTimeout
		{
			get => Q<Time>("master_timeout");
			set => Q("master_timeout", value);
		}

		///<summary>Explicit operation timeout</summary>
		public Time Timeout
		{
			get => Q<Time>("timeout");
			set => Q("timeout", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IRemoteInfoRequest : IRequest<RemoteInfoRequestParameters>
	{
	}

	///<summary>Request for RemoteInfo <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-remote-info.html</pre></summary>
	public partial class RemoteInfoRequest : PlainRequestBase<RemoteInfoRequestParameters>, IRemoteInfoRequest
	{
		protected IRemoteInfoRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_remote/info"});
		internal override ApiUrls ApiUrls => Urls;
	// values part of the url path
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IClusterRerouteRequest : IRequest<ClusterRerouteRequestParameters>
	{
	}

	///<summary>Request for Reroute <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-reroute.html</pre></summary>
	public partial class ClusterRerouteRequest : PlainRequestBase<ClusterRerouteRequestParameters>, IClusterRerouteRequest
	{
		protected IClusterRerouteRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_cluster/reroute"});
		internal override ApiUrls ApiUrls => Urls;
		// values part of the url path
		// Request parameters
		///<summary>Simulate the operation only and return the resulting state</summary>
		public bool? DryRun
		{
			get => Q<bool? >("dry_run");
			set => Q("dry_run", value);
		}

		///<summary>Return an explanation of why the commands can or cannot be executed</summary>
		public bool? Explain
		{
			get => Q<bool? >("explain");
			set => Q("explain", value);
		}

		///<summary>Explicit operation timeout for connection to master node</summary>
		public Time MasterTimeout
		{
			get => Q<Time>("master_timeout");
			set => Q("master_timeout", value);
		}

		///<summary>Limit the information returned to the specified metrics. Defaults to all but metadata</summary>
		public string[] Metric
		{
			get => Q<string[]>("metric");
			set => Q("metric", value);
		}

		///<summary>Retries allocation of shards that are blocked due to too many subsequent allocation failures</summary>
		public bool? RetryFailed
		{
			get => Q<bool? >("retry_failed");
			set => Q("retry_failed", value);
		}

		///<summary>Explicit operation timeout</summary>
		public Time Timeout
		{
			get => Q<Time>("timeout");
			set => Q("timeout", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IClusterStateRequest : IRequest<ClusterStateRequestParameters>
	{
		[IgnoreDataMember]
		Metrics Metric
		{
			get;
		}

		[IgnoreDataMember]
		Indices Index
		{
			get;
		}
	}

	///<summary>Request for State <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-state.html</pre></summary>
	public partial class ClusterStateRequest : PlainRequestBase<ClusterStateRequestParameters>, IClusterStateRequest
	{
		protected IClusterStateRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_cluster/state", "_cluster/state/{metric}", "_cluster/state/{metric}/{index}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_cluster/state</summary>
		public ClusterStateRequest(): base()
		{
		}

		///<summary>/_cluster/state/{metric}</summary>
		///<param name = "metric">Optional, accepts null</param>
		public ClusterStateRequest(Metrics metric): base(r => r.Optional("metric", metric))
		{
		}

		///<summary>/_cluster/state/{metric}/{index}</summary>
		///<param name = "metric">Optional, accepts null</param>
		///<param name = "index">Optional, accepts null</param>
		public ClusterStateRequest(Metrics metric, Indices index): base(r => r.Optional("metric", metric).Optional("index", index))
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Metrics IClusterStateRequest.Metric => Self.RouteValues.Get<Metrics>("metric");
		[IgnoreDataMember]
		Indices IClusterStateRequest.Index => Self.RouteValues.Get<Indices>("index");
		// Request parameters
		///<summary>
		/// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have
		/// been specified)
		///</summary>
		public bool? AllowNoIndices
		{
			get => Q<bool? >("allow_no_indices");
			set => Q("allow_no_indices", value);
		}

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ExpandWildcards? ExpandWildcards
		{
			get => Q<ExpandWildcards? >("expand_wildcards");
			set => Q("expand_wildcards", value);
		}

		///<summary>Return settings in flat format (default: false)</summary>
		public bool? FlatSettings
		{
			get => Q<bool? >("flat_settings");
			set => Q("flat_settings", value);
		}

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public bool? IgnoreUnavailable
		{
			get => Q<bool? >("ignore_unavailable");
			set => Q("ignore_unavailable", value);
		}

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public bool? Local
		{
			get => Q<bool? >("local");
			set => Q("local", value);
		}

		///<summary>Specify timeout for connection to master</summary>
		public Time MasterTimeout
		{
			get => Q<Time>("master_timeout");
			set => Q("master_timeout", value);
		}

		///<summary>Wait for the metadata version to be equal or greater than the specified metadata version</summary>
		public long? WaitForMetadataVersion
		{
			get => Q<long? >("wait_for_metadata_version");
			set => Q("wait_for_metadata_version", value);
		}

		///<summary>The maximum time to wait for wait_for_metadata_version before timing out</summary>
		public Time WaitForTimeout
		{
			get => Q<Time>("wait_for_timeout");
			set => Q("wait_for_timeout", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IClusterStatsRequest : IRequest<ClusterStatsRequestParameters>
	{
		[IgnoreDataMember]
		NodeIds NodeId
		{
			get;
		}
	}

	///<summary>Request for Stats <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-stats.html</pre></summary>
	public partial class ClusterStatsRequest : PlainRequestBase<ClusterStatsRequestParameters>, IClusterStatsRequest
	{
		protected IClusterStatsRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_cluster/stats", "_cluster/stats/nodes/{node_id}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_cluster/stats</summary>
		public ClusterStatsRequest(): base()
		{
		}

		///<summary>/_cluster/stats/nodes/{node_id}</summary>
		///<param name = "node_id">Optional, accepts null</param>
		public ClusterStatsRequest(NodeIds node_id): base(r => r.Optional("node_id", node_id))
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		NodeIds IClusterStatsRequest.NodeId => Self.RouteValues.Get<NodeIds>("node_id");
		// Request parameters
		///<summary>Return settings in flat format (default: false)</summary>
		public bool? FlatSettings
		{
			get => Q<bool? >("flat_settings");
			set => Q("flat_settings", value);
		}

		///<summary>Explicit operation timeout</summary>
		public Time Timeout
		{
			get => Q<Time>("timeout");
			set => Q("timeout", value);
		}
	}

	[InterfaceDataContract]
	public partial interface ICountRequest : IRequest<CountRequestParameters>
	{
		[IgnoreDataMember]
		Indices Index
		{
			get;
		}
	}

	public partial interface ICountRequest<T> : ICountRequest
	{
	}

	///<summary>Request for Count <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/search-count.html</pre></summary>
	public partial class CountRequest : PlainRequestBase<CountRequestParameters>, ICountRequest
	{
		protected ICountRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_count", "{index}/_count"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_count</summary>
		public CountRequest(): base()
		{
		}

		///<summary>/{index}/_count</summary>
		///<param name = "index">Optional, accepts null</param>
		public CountRequest(Indices index): base(r => r.Optional("index", index))
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Indices ICountRequest.Index => Self.RouteValues.Get<Indices>("index");
		// Request parameters
		///<summary>
		/// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have
		/// been specified)
		///</summary>
		public bool? AllowNoIndices
		{
			get => Q<bool? >("allow_no_indices");
			set => Q("allow_no_indices", value);
		}

		///<summary>Specify whether wildcard and prefix queries should be analyzed (default: false)</summary>
		public bool? AnalyzeWildcard
		{
			get => Q<bool? >("analyze_wildcard");
			set => Q("analyze_wildcard", value);
		}

		///<summary>The analyzer to use for the query string</summary>
		public string Analyzer
		{
			get => Q<string>("analyzer");
			set => Q("analyzer", value);
		}

		///<summary>The default operator for query string query (AND or OR)</summary>
		public DefaultOperator? DefaultOperator
		{
			get => Q<DefaultOperator? >("default_operator");
			set => Q("default_operator", value);
		}

		///<summary>The field to use as default where no field prefix is given in the query string</summary>
		public string Df
		{
			get => Q<string>("df");
			set => Q("df", value);
		}

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ExpandWildcards? ExpandWildcards
		{
			get => Q<ExpandWildcards? >("expand_wildcards");
			set => Q("expand_wildcards", value);
		}

		///<summary>Whether specified concrete, expanded or aliased indices should be ignored when throttled</summary>
		public bool? IgnoreThrottled
		{
			get => Q<bool? >("ignore_throttled");
			set => Q("ignore_throttled", value);
		}

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public bool? IgnoreUnavailable
		{
			get => Q<bool? >("ignore_unavailable");
			set => Q("ignore_unavailable", value);
		}

		///<summary>Specify whether format-based query failures (such as providing text to a numeric field) should be ignored</summary>
		public bool? Lenient
		{
			get => Q<bool? >("lenient");
			set => Q("lenient", value);
		}

		///<summary>Include only documents with a specific `_score` value in the result</summary>
		public double? MinScore
		{
			get => Q<double? >("min_score");
			set => Q("min_score", value);
		}

		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public string Preference
		{
			get => Q<string>("preference");
			set => Q("preference", value);
		}

		///<summary>Query in the Lucene query string syntax</summary>
		public string QueryOnQueryString
		{
			get => Q<string>("q");
			set => Q("q", value);
		}

		///<summary>
		/// A document is routed to a particular shard in an index using the following formula
		/// <para> shard_num = hash(_routing) % num_primary_shards</para>
		/// <para>Elasticsearch will use the document id if not provided. </para>
		/// <para>For requests that are constructed from/for a document NEST will automatically infer the routing key
		/// if that document has a <see cref = "Nest.JoinField"/> or a routing mapping on for its type exists on <see cref = "Nest.ConnectionSettings"
		////></para>
		///</summary>
		public Routing Routing
		{
			get => Q<Routing>("routing");
			set => Q("routing", value);
		}

		///<summary>The maximum count for each shard, upon reaching which the query execution will terminate early</summary>
		public long? TerminateAfter
		{
			get => Q<long? >("terminate_after");
			set => Q("terminate_after", value);
		}
	}

	public partial class CountRequest<T> : CountRequest, ICountRequest<T>
	{
		protected ICountRequest<T> TypedSelf => this;
		///<summary>/{index}/_count</summary>
		public CountRequest(): base(typeof(T))
		{
		}

		///<summary>/{index}/_count</summary>
		///<param name = "index">Optional, accepts null</param>
		public CountRequest(Indices index): base(index)
		{
		}
	}

	[InterfaceDataContract]
	public partial interface ICreateRequest : IRequest<CreateRequestParameters>
	{
		[IgnoreDataMember]
		IndexName Index
		{
			get;
		}

		[IgnoreDataMember]
		Id Id
		{
			get;
		}
	}

	public partial interface ICreateRequest<TDocument> : ICreateRequest
	{
	}

	///<summary>Request for Create <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-index_.html</pre></summary>
	public partial class CreateRequest : PlainRequestBase<CreateRequestParameters>, ICreateRequest
	{
		protected ICreateRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"{index}/_create/{id}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/{index}/_create/{id}</summary>
		///<param name = "index">this parameter is required</param>
		///<param name = "id">this parameter is required</param>
		public CreateRequest(IndexName index, Id id): base(r => r.Required("index", index).Required("id", id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal CreateRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		IndexName ICreateRequest.Index => Self.RouteValues.Get<IndexName>("index");
		[IgnoreDataMember]
		Id ICreateRequest.Id => Self.RouteValues.Get<Id>("id");
		// Request parameters
		///<summary>The pipeline id to preprocess incoming documents with</summary>
		public string Pipeline
		{
			get => Q<string>("pipeline");
			set => Q("pipeline", value);
		}

		///<summary>
		/// If `true` then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this
		/// operation visible to search, if `false` (the default) then do nothing with refreshes.
		///</summary>
		public Refresh? Refresh
		{
			get => Q<Refresh? >("refresh");
			set => Q("refresh", value);
		}

		///<summary>
		/// A document is routed to a particular shard in an index using the following formula
		/// <para> shard_num = hash(_routing) % num_primary_shards</para>
		/// <para>Elasticsearch will use the document id if not provided. </para>
		/// <para>For requests that are constructed from/for a document NEST will automatically infer the routing key
		/// if that document has a <see cref = "Nest.JoinField"/> or a routing mapping on for its type exists on <see cref = "Nest.ConnectionSettings"
		////></para>
		///</summary>
		public Routing Routing
		{
			get => Q<Routing>("routing");
			set => Q("routing", value);
		}

		///<summary>Explicit operation timeout</summary>
		public Time Timeout
		{
			get => Q<Time>("timeout");
			set => Q("timeout", value);
		}

		///<summary>Explicit version number for concurrency control</summary>
		public long? Version
		{
			get => Q<long? >("version");
			set => Q("version", value);
		}

		///<summary>Specific version type</summary>
		public VersionType? VersionType
		{
			get => Q<VersionType? >("version_type");
			set => Q("version_type", value);
		}

		///<summary>
		/// Sets the number of shard copies that must be active before proceeding with the index operation. Defaults to 1, meaning the primary shard
		/// only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the
		/// shard (number of replicas + 1)
		///</summary>
		public string WaitForActiveShards
		{
			get => Q<string>("wait_for_active_shards");
			set => Q("wait_for_active_shards", value);
		}
	}

	public partial class CreateRequest<TDocument> : CreateRequest, ICreateRequest<TDocument>
	{
		protected ICreateRequest<TDocument> TypedSelf => this;
		///<summary>/{index}/_create/{id}</summary>
		///<param name = "index">this parameter is required</param>
		///<param name = "id">this parameter is required</param>
		public CreateRequest(IndexName index, Id id): base(index, id)
		{
		}

		///<summary>/{index}/_create/{id}</summary>
		///<param name = "id">this parameter is required</param>
		public CreateRequest(Id id): base(typeof(TDocument), id)
		{
		}

		///<summary>/{index}/_create/{id}</summary>
		///<param name = "id">The document used to resolve the path from</param>
		public CreateRequest(TDocument documentWithId, IndexName index = null, Id id = null): this(index ?? typeof(TDocument), id ?? Nest.Id.From(documentWithId)) => DocumentFromPath(documentWithId);
		partial void DocumentFromPath(TDocument document);
		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal CreateRequest(): base()
		{
		}
	}

	[InterfaceDataContract]
	public partial interface IDeleteRequest : IRequest<DeleteRequestParameters>
	{
		[IgnoreDataMember]
		IndexName Index
		{
			get;
		}

		[IgnoreDataMember]
		Id Id
		{
			get;
		}
	}

	public partial interface IDeleteRequest<TDocument> : IDeleteRequest
	{
	}

	///<summary>Request for Delete <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-delete.html</pre></summary>
	public partial class DeleteRequest : PlainRequestBase<DeleteRequestParameters>, IDeleteRequest
	{
		protected IDeleteRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"{index}/_doc/{id}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/{index}/_doc/{id}</summary>
		///<param name = "index">this parameter is required</param>
		///<param name = "id">this parameter is required</param>
		public DeleteRequest(IndexName index, Id id): base(r => r.Required("index", index).Required("id", id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal DeleteRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		IndexName IDeleteRequest.Index => Self.RouteValues.Get<IndexName>("index");
		[IgnoreDataMember]
		Id IDeleteRequest.Id => Self.RouteValues.Get<Id>("id");
		// Request parameters
		///<summary>only perform the delete operation if the last operation that has changed the document has the specified primary term</summary>
		public long? IfPrimaryTerm
		{
			get => Q<long? >("if_primary_term");
			set => Q("if_primary_term", value);
		}

		///<summary>only perform the delete operation if the last operation that has changed the document has the specified sequence number</summary>
		public long? IfSequenceNumber
		{
			get => Q<long? >("if_seq_no");
			set => Q("if_seq_no", value);
		}

		///<summary>
		/// If `true` then refresh the effected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this
		/// operation visible to search, if `false` (the default) then do nothing with refreshes.
		///</summary>
		public Refresh? Refresh
		{
			get => Q<Refresh? >("refresh");
			set => Q("refresh", value);
		}

		///<summary>
		/// A document is routed to a particular shard in an index using the following formula
		/// <para> shard_num = hash(_routing) % num_primary_shards</para>
		/// <para>Elasticsearch will use the document id if not provided. </para>
		/// <para>For requests that are constructed from/for a document NEST will automatically infer the routing key
		/// if that document has a <see cref = "Nest.JoinField"/> or a routing mapping on for its type exists on <see cref = "Nest.ConnectionSettings"
		////></para>
		///</summary>
		public Routing Routing
		{
			get => Q<Routing>("routing");
			set => Q("routing", value);
		}

		///<summary>Explicit operation timeout</summary>
		public Time Timeout
		{
			get => Q<Time>("timeout");
			set => Q("timeout", value);
		}

		///<summary>Explicit version number for concurrency control</summary>
		public long? Version
		{
			get => Q<long? >("version");
			set => Q("version", value);
		}

		///<summary>Specific version type</summary>
		public VersionType? VersionType
		{
			get => Q<VersionType? >("version_type");
			set => Q("version_type", value);
		}

		///<summary>
		/// Sets the number of shard copies that must be active before proceeding with the delete operation. Defaults to 1, meaning the primary shard
		/// only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the
		/// shard (number of replicas + 1)
		///</summary>
		public string WaitForActiveShards
		{
			get => Q<string>("wait_for_active_shards");
			set => Q("wait_for_active_shards", value);
		}
	}

	public partial class DeleteRequest<TDocument> : DeleteRequest, IDeleteRequest<TDocument>
	{
		protected IDeleteRequest<TDocument> TypedSelf => this;
		///<summary>/{index}/_doc/{id}</summary>
		///<param name = "index">this parameter is required</param>
		///<param name = "id">this parameter is required</param>
		public DeleteRequest(IndexName index, Id id): base(index, id)
		{
		}

		///<summary>/{index}/_doc/{id}</summary>
		///<param name = "id">this parameter is required</param>
		public DeleteRequest(Id id): base(typeof(TDocument), id)
		{
		}

		///<summary>/{index}/_doc/{id}</summary>
		///<param name = "id">The document used to resolve the path from</param>
		public DeleteRequest(TDocument documentWithId, IndexName index = null, Id id = null): this(index ?? typeof(TDocument), id ?? Nest.Id.From(documentWithId)) => DocumentFromPath(documentWithId);
		partial void DocumentFromPath(TDocument document);
		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal DeleteRequest(): base()
		{
		}
	}

	[InterfaceDataContract]
	public partial interface IDeleteByQueryRequest : IRequest<DeleteByQueryRequestParameters>
	{
		[IgnoreDataMember]
		Indices Index
		{
			get;
		}
	}

	public partial interface IDeleteByQueryRequest<T> : IDeleteByQueryRequest
	{
	}

	///<summary>Request for DeleteByQuery <pre>https://www.elastic.co/guide/en/elasticsearch/reference/master/docs-delete-by-query.html</pre></summary>
	public partial class DeleteByQueryRequest : PlainRequestBase<DeleteByQueryRequestParameters>, IDeleteByQueryRequest
	{
		protected IDeleteByQueryRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"{index}/_delete_by_query"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/{index}/_delete_by_query</summary>
		///<param name = "index">this parameter is required</param>
		public DeleteByQueryRequest(Indices index): base(r => r.Required("index", index))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal DeleteByQueryRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Indices IDeleteByQueryRequest.Index => Self.RouteValues.Get<Indices>("index");
		// Request parameters
		///<summary>
		/// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have
		/// been specified)
		///</summary>
		public bool? AllowNoIndices
		{
			get => Q<bool? >("allow_no_indices");
			set => Q("allow_no_indices", value);
		}

		///<summary>Specify whether wildcard and prefix queries should be analyzed (default: false)</summary>
		public bool? AnalyzeWildcard
		{
			get => Q<bool? >("analyze_wildcard");
			set => Q("analyze_wildcard", value);
		}

		///<summary>The analyzer to use for the query string</summary>
		public string Analyzer
		{
			get => Q<string>("analyzer");
			set => Q("analyzer", value);
		}

		///<summary>What to do when the delete by query hits version conflicts?</summary>
		public Conflicts? Conflicts
		{
			get => Q<Conflicts? >("conflicts");
			set => Q("conflicts", value);
		}

		///<summary>The default operator for query string query (AND or OR)</summary>
		public DefaultOperator? DefaultOperator
		{
			get => Q<DefaultOperator? >("default_operator");
			set => Q("default_operator", value);
		}

		///<summary>The field to use as default where no field prefix is given in the query string</summary>
		public string Df
		{
			get => Q<string>("df");
			set => Q("df", value);
		}

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ExpandWildcards? ExpandWildcards
		{
			get => Q<ExpandWildcards? >("expand_wildcards");
			set => Q("expand_wildcards", value);
		}

		///<summary>Starting offset (default: 0)</summary>
		public long? From
		{
			get => Q<long? >("from");
			set => Q("from", value);
		}

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public bool? IgnoreUnavailable
		{
			get => Q<bool? >("ignore_unavailable");
			set => Q("ignore_unavailable", value);
		}

		///<summary>Specify whether format-based query failures (such as providing text to a numeric field) should be ignored</summary>
		public bool? Lenient
		{
			get => Q<bool? >("lenient");
			set => Q("lenient", value);
		}

		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public string Preference
		{
			get => Q<string>("preference");
			set => Q("preference", value);
		}

		///<summary>Query in the Lucene query string syntax</summary>
		public string QueryOnQueryString
		{
			get => Q<string>("q");
			set => Q("q", value);
		}

		///<summary>Should the effected indexes be refreshed?</summary>
		public bool? Refresh
		{
			get => Q<bool? >("refresh");
			set => Q("refresh", value);
		}

		///<summary>Specify if request cache should be used for this request or not, defaults to index level setting</summary>
		public bool? RequestCache
		{
			get => Q<bool? >("request_cache");
			set => Q("request_cache", value);
		}

		///<summary>The throttle for this request in sub-requests per second. -1 means no throttle.</summary>
		public long? RequestsPerSecond
		{
			get => Q<long? >("requests_per_second");
			set => Q("requests_per_second", value);
		}

		///<summary>
		/// A document is routed to a particular shard in an index using the following formula
		/// <para> shard_num = hash(_routing) % num_primary_shards</para>
		/// <para>Elasticsearch will use the document id if not provided. </para>
		/// <para>For requests that are constructed from/for a document NEST will automatically infer the routing key
		/// if that document has a <see cref = "Nest.JoinField"/> or a routing mapping on for its type exists on <see cref = "Nest.ConnectionSettings"
		////></para>
		///</summary>
		public Routing Routing
		{
			get => Q<Routing>("routing");
			set => Q("routing", value);
		}

		///<summary>Specify how long a consistent view of the index should be maintained for scrolled search</summary>
		public Time Scroll
		{
			get => Q<Time>("scroll");
			set => Q("scroll", value);
		}

		///<summary>Size on the scroll request powering the delete by query</summary>
		public long? ScrollSize
		{
			get => Q<long? >("scroll_size");
			set => Q("scroll_size", value);
		}

		///<summary>Explicit timeout for each search request. Defaults to no timeout.</summary>
		public Time SearchTimeout
		{
			get => Q<Time>("search_timeout");
			set => Q("search_timeout", value);
		}

		///<summary>Search operation type</summary>
		public SearchType? SearchType
		{
			get => Q<SearchType? >("search_type");
			set => Q("search_type", value);
		}

		///<summary>Number of hits to return (default: 10)</summary>
		public long? Size
		{
			get => Q<long? >("size");
			set => Q("size", value);
		}

		///<summary>The number of slices this task should be divided into. Defaults to 1 meaning the task isn't sliced into subtasks.</summary>
		public long? Slices
		{
			get => Q<long? >("slices");
			set => Q("slices", value);
		}

		///<summary>A comma-separated list of <field>:<direction> pairs</summary>
		public string[] Sort
		{
			get => Q<string[]>("sort");
			set => Q("sort", value);
		}

		///<summary>Whether the _source should be included in the response.</summary>
		public bool? SourceEnabled
		{
			get => Q<bool? >("_source");
			set => Q("_source", value);
		}

		///<summary>A list of fields to exclude from the returned _source field</summary>
		public Fields SourceExcludes
		{
			get => Q<Fields>("_source_excludes");
			set => Q("_source_excludes", value);
		}

		///<summary>A list of fields to extract and return from the _source field</summary>
		public Fields SourceIncludes
		{
			get => Q<Fields>("_source_includes");
			set => Q("_source_includes", value);
		}

		///<summary>Specific 'tag' of the request for logging and statistical purposes</summary>
		public string[] Stats
		{
			get => Q<string[]>("stats");
			set => Q("stats", value);
		}

		///<summary>The maximum number of documents to collect for each shard, upon reaching which the query execution will terminate early.</summary>
		public long? TerminateAfter
		{
			get => Q<long? >("terminate_after");
			set => Q("terminate_after", value);
		}

		///<summary>Time each individual bulk request should wait for shards that are unavailable.</summary>
		public Time Timeout
		{
			get => Q<Time>("timeout");
			set => Q("timeout", value);
		}

		///<summary>Specify whether to return document version as part of a hit</summary>
		public bool? Version
		{
			get => Q<bool? >("version");
			set => Q("version", value);
		}

		///<summary>
		/// Sets the number of shard copies that must be active before proceeding with the delete by query operation. Defaults to 1, meaning the
		/// primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of
		/// copies for the shard (number of replicas + 1)
		///</summary>
		public string WaitForActiveShards
		{
			get => Q<string>("wait_for_active_shards");
			set => Q("wait_for_active_shards", value);
		}

		///<summary>Should the request should block until the delete by query is complete.</summary>
		public bool? WaitForCompletion
		{
			get => Q<bool? >("wait_for_completion");
			set => Q("wait_for_completion", value);
		}
	}

	public partial class DeleteByQueryRequest<T> : DeleteByQueryRequest, IDeleteByQueryRequest<T>
	{
		protected IDeleteByQueryRequest<T> TypedSelf => this;
		///<summary>/{index}/_delete_by_query</summary>
		///<param name = "index">this parameter is required</param>
		public DeleteByQueryRequest(Indices index): base(index)
		{
		}

		///<summary>/{index}/_delete_by_query</summary>
		public DeleteByQueryRequest(): base(typeof(T))
		{
		}
	}

	[InterfaceDataContract]
	public partial interface IDeleteByQueryRethrottleRequest : IRequest<DeleteByQueryRethrottleRequestParameters>
	{
		[IgnoreDataMember]
		TaskId TaskId
		{
			get;
		}
	}

	///<summary>Request for DeleteByQueryRethrottle <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-delete-by-query.html</pre></summary>
	public partial class DeleteByQueryRethrottleRequest : PlainRequestBase<DeleteByQueryRethrottleRequestParameters>, IDeleteByQueryRethrottleRequest
	{
		protected IDeleteByQueryRethrottleRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_delete_by_query/{task_id}/_rethrottle"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_delete_by_query/{task_id}/_rethrottle</summary>
		///<param name = "task_id">this parameter is required</param>
		public DeleteByQueryRethrottleRequest(TaskId task_id): base(r => r.Required("task_id", task_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal DeleteByQueryRethrottleRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		TaskId IDeleteByQueryRethrottleRequest.TaskId => Self.RouteValues.Get<TaskId>("task_id");
		// Request parameters
		///<summary>The throttle to set on this request in floating sub-requests per second. -1 means set no throttle.</summary>
		public long? RequestsPerSecond
		{
			get => Q<long? >("requests_per_second");
			set => Q("requests_per_second", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IDeleteScriptRequest : IRequest<DeleteScriptRequestParameters>
	{
		[IgnoreDataMember]
		Id Id
		{
			get;
		}
	}

	///<summary>Request for DeleteScript <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-scripting.html</pre></summary>
	public partial class DeleteScriptRequest : PlainRequestBase<DeleteScriptRequestParameters>, IDeleteScriptRequest
	{
		protected IDeleteScriptRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_scripts/{id}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_scripts/{id}</summary>
		///<param name = "id">this parameter is required</param>
		public DeleteScriptRequest(Id id): base(r => r.Required("id", id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal DeleteScriptRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Id IDeleteScriptRequest.Id => Self.RouteValues.Get<Id>("id");
		// Request parameters
		///<summary>Specify timeout for connection to master</summary>
		public Time MasterTimeout
		{
			get => Q<Time>("master_timeout");
			set => Q("master_timeout", value);
		}

		///<summary>Explicit operation timeout</summary>
		public Time Timeout
		{
			get => Q<Time>("timeout");
			set => Q("timeout", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IDocumentExistsRequest : IRequest<DocumentExistsRequestParameters>
	{
		[IgnoreDataMember]
		IndexName Index
		{
			get;
		}

		[IgnoreDataMember]
		Id Id
		{
			get;
		}
	}

	public partial interface IDocumentExistsRequest<TDocument> : IDocumentExistsRequest
	{
	}

	///<summary>Request for DocumentExists <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-get.html</pre></summary>
	public partial class DocumentExistsRequest : PlainRequestBase<DocumentExistsRequestParameters>, IDocumentExistsRequest
	{
		protected IDocumentExistsRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"{index}/_doc/{id}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/{index}/_doc/{id}</summary>
		///<param name = "index">this parameter is required</param>
		///<param name = "id">this parameter is required</param>
		public DocumentExistsRequest(IndexName index, Id id): base(r => r.Required("index", index).Required("id", id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal DocumentExistsRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		IndexName IDocumentExistsRequest.Index => Self.RouteValues.Get<IndexName>("index");
		[IgnoreDataMember]
		Id IDocumentExistsRequest.Id => Self.RouteValues.Get<Id>("id");
		// Request parameters
		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public string Preference
		{
			get => Q<string>("preference");
			set => Q("preference", value);
		}

		///<summary>Specify whether to perform the operation in realtime or search mode</summary>
		public bool? Realtime
		{
			get => Q<bool? >("realtime");
			set => Q("realtime", value);
		}

		///<summary>Refresh the shard containing the document before performing the operation</summary>
		public bool? Refresh
		{
			get => Q<bool? >("refresh");
			set => Q("refresh", value);
		}

		///<summary>
		/// A document is routed to a particular shard in an index using the following formula
		/// <para> shard_num = hash(_routing) % num_primary_shards</para>
		/// <para>Elasticsearch will use the document id if not provided. </para>
		/// <para>For requests that are constructed from/for a document NEST will automatically infer the routing key
		/// if that document has a <see cref = "Nest.JoinField"/> or a routing mapping on for its type exists on <see cref = "Nest.ConnectionSettings"
		////></para>
		///</summary>
		public Routing Routing
		{
			get => Q<Routing>("routing");
			set => Q("routing", value);
		}

		///<summary>Whether the _source should be included in the response.</summary>
		public bool? SourceEnabled
		{
			get => Q<bool? >("_source");
			set => Q("_source", value);
		}

		///<summary>A list of fields to exclude from the returned _source field</summary>
		public Fields SourceExcludes
		{
			get => Q<Fields>("_source_excludes");
			set => Q("_source_excludes", value);
		}

		///<summary>A list of fields to extract and return from the _source field</summary>
		public Fields SourceIncludes
		{
			get => Q<Fields>("_source_includes");
			set => Q("_source_includes", value);
		}

		///<summary>A comma-separated list of stored fields to return in the response</summary>
		public Fields StoredFields
		{
			get => Q<Fields>("stored_fields");
			set => Q("stored_fields", value);
		}

		///<summary>Explicit version number for concurrency control</summary>
		public long? Version
		{
			get => Q<long? >("version");
			set => Q("version", value);
		}

		///<summary>Specific version type</summary>
		public VersionType? VersionType
		{
			get => Q<VersionType? >("version_type");
			set => Q("version_type", value);
		}
	}

	public partial class DocumentExistsRequest<TDocument> : DocumentExistsRequest, IDocumentExistsRequest<TDocument>
	{
		protected IDocumentExistsRequest<TDocument> TypedSelf => this;
		///<summary>/{index}/_doc/{id}</summary>
		///<param name = "index">this parameter is required</param>
		///<param name = "id">this parameter is required</param>
		public DocumentExistsRequest(IndexName index, Id id): base(index, id)
		{
		}

		///<summary>/{index}/_doc/{id}</summary>
		///<param name = "id">this parameter is required</param>
		public DocumentExistsRequest(Id id): base(typeof(TDocument), id)
		{
		}

		///<summary>/{index}/_doc/{id}</summary>
		///<param name = "id">The document used to resolve the path from</param>
		public DocumentExistsRequest(TDocument documentWithId, IndexName index = null, Id id = null): this(index ?? typeof(TDocument), id ?? Nest.Id.From(documentWithId)) => DocumentFromPath(documentWithId);
		partial void DocumentFromPath(TDocument document);
		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal DocumentExistsRequest(): base()
		{
		}
	}

	[InterfaceDataContract]
	public partial interface ISourceExistsRequest : IRequest<SourceExistsRequestParameters>
	{
		[IgnoreDataMember]
		IndexName Index
		{
			get;
		}

		[IgnoreDataMember]
		Id Id
		{
			get;
		}
	}

	public partial interface ISourceExistsRequest<TDocument> : ISourceExistsRequest
	{
	}

	///<summary>Request for SourceExists <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-get.html</pre></summary>
	public partial class SourceExistsRequest : PlainRequestBase<SourceExistsRequestParameters>, ISourceExistsRequest
	{
		protected ISourceExistsRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"{index}/_source/{id}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/{index}/_source/{id}</summary>
		///<param name = "index">this parameter is required</param>
		///<param name = "id">this parameter is required</param>
		public SourceExistsRequest(IndexName index, Id id): base(r => r.Required("index", index).Required("id", id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal SourceExistsRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		IndexName ISourceExistsRequest.Index => Self.RouteValues.Get<IndexName>("index");
		[IgnoreDataMember]
		Id ISourceExistsRequest.Id => Self.RouteValues.Get<Id>("id");
		// Request parameters
		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public string Preference
		{
			get => Q<string>("preference");
			set => Q("preference", value);
		}

		///<summary>Specify whether to perform the operation in realtime or search mode</summary>
		public bool? Realtime
		{
			get => Q<bool? >("realtime");
			set => Q("realtime", value);
		}

		///<summary>Refresh the shard containing the document before performing the operation</summary>
		public bool? Refresh
		{
			get => Q<bool? >("refresh");
			set => Q("refresh", value);
		}

		///<summary>
		/// A document is routed to a particular shard in an index using the following formula
		/// <para> shard_num = hash(_routing) % num_primary_shards</para>
		/// <para>Elasticsearch will use the document id if not provided. </para>
		/// <para>For requests that are constructed from/for a document NEST will automatically infer the routing key
		/// if that document has a <see cref = "Nest.JoinField"/> or a routing mapping on for its type exists on <see cref = "Nest.ConnectionSettings"
		////></para>
		///</summary>
		public Routing Routing
		{
			get => Q<Routing>("routing");
			set => Q("routing", value);
		}

		///<summary>Whether the _source should be included in the response.</summary>
		public bool? SourceEnabled
		{
			get => Q<bool? >("_source");
			set => Q("_source", value);
		}

		///<summary>A list of fields to exclude from the returned _source field</summary>
		public Fields SourceExcludes
		{
			get => Q<Fields>("_source_excludes");
			set => Q("_source_excludes", value);
		}

		///<summary>A list of fields to extract and return from the _source field</summary>
		public Fields SourceIncludes
		{
			get => Q<Fields>("_source_includes");
			set => Q("_source_includes", value);
		}

		///<summary>Explicit version number for concurrency control</summary>
		public long? Version
		{
			get => Q<long? >("version");
			set => Q("version", value);
		}

		///<summary>Specific version type</summary>
		public VersionType? VersionType
		{
			get => Q<VersionType? >("version_type");
			set => Q("version_type", value);
		}
	}

	public partial class SourceExistsRequest<TDocument> : SourceExistsRequest, ISourceExistsRequest<TDocument>
	{
		protected ISourceExistsRequest<TDocument> TypedSelf => this;
		///<summary>/{index}/_source/{id}</summary>
		///<param name = "index">this parameter is required</param>
		///<param name = "id">this parameter is required</param>
		public SourceExistsRequest(IndexName index, Id id): base(index, id)
		{
		}

		///<summary>/{index}/_source/{id}</summary>
		///<param name = "id">this parameter is required</param>
		public SourceExistsRequest(Id id): base(typeof(TDocument), id)
		{
		}

		///<summary>/{index}/_source/{id}</summary>
		///<param name = "id">The document used to resolve the path from</param>
		public SourceExistsRequest(TDocument documentWithId, IndexName index = null, Id id = null): this(index ?? typeof(TDocument), id ?? Nest.Id.From(documentWithId)) => DocumentFromPath(documentWithId);
		partial void DocumentFromPath(TDocument document);
		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal SourceExistsRequest(): base()
		{
		}
	}

	[InterfaceDataContract]
	public partial interface IExplainRequest : IRequest<ExplainRequestParameters>
	{
		[IgnoreDataMember]
		IndexName Index
		{
			get;
		}

		[IgnoreDataMember]
		Id Id
		{
			get;
		}

		[DataMember(Name = "stored_fields")]
		Fields StoredFields
		{
			get;
			set;
		}
	}

	public partial interface IExplainRequest<TDocument> : IExplainRequest
	{
	}

	///<summary>Request for Explain <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/search-explain.html</pre></summary>
	public partial class ExplainRequest : PlainRequestBase<ExplainRequestParameters>, IExplainRequest
	{
		protected IExplainRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"{index}/_explain/{id}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/{index}/_explain/{id}</summary>
		///<param name = "index">this parameter is required</param>
		///<param name = "id">this parameter is required</param>
		public ExplainRequest(IndexName index, Id id): base(r => r.Required("index", index).Required("id", id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal ExplainRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		IndexName IExplainRequest.Index => Self.RouteValues.Get<IndexName>("index");
		[IgnoreDataMember]
		Id IExplainRequest.Id => Self.RouteValues.Get<Id>("id");
		// Request parameters
		///<summary>Specify whether wildcards and prefix queries in the query string query should be analyzed (default: false)</summary>
		public bool? AnalyzeWildcard
		{
			get => Q<bool? >("analyze_wildcard");
			set => Q("analyze_wildcard", value);
		}

		///<summary>The analyzer for the query string query</summary>
		public string Analyzer
		{
			get => Q<string>("analyzer");
			set => Q("analyzer", value);
		}

		///<summary>The default operator for query string query (AND or OR)</summary>
		public DefaultOperator? DefaultOperator
		{
			get => Q<DefaultOperator? >("default_operator");
			set => Q("default_operator", value);
		}

		///<summary>The default field for query string query (default: _all)</summary>
		public string Df
		{
			get => Q<string>("df");
			set => Q("df", value);
		}

		///<summary>Specify whether format-based query failures (such as providing text to a numeric field) should be ignored</summary>
		public bool? Lenient
		{
			get => Q<bool? >("lenient");
			set => Q("lenient", value);
		}

		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public string Preference
		{
			get => Q<string>("preference");
			set => Q("preference", value);
		}

		///<summary>Query in the Lucene query string syntax</summary>
		public string QueryOnQueryString
		{
			get => Q<string>("q");
			set => Q("q", value);
		}

		///<summary>
		/// A document is routed to a particular shard in an index using the following formula
		/// <para> shard_num = hash(_routing) % num_primary_shards</para>
		/// <para>Elasticsearch will use the document id if not provided. </para>
		/// <para>For requests that are constructed from/for a document NEST will automatically infer the routing key
		/// if that document has a <see cref = "Nest.JoinField"/> or a routing mapping on for its type exists on <see cref = "Nest.ConnectionSettings"
		////></para>
		///</summary>
		public Routing Routing
		{
			get => Q<Routing>("routing");
			set => Q("routing", value);
		}

		///<summary>Whether the _source should be included in the response.</summary>
		public bool? SourceEnabled
		{
			get => Q<bool? >("_source");
			set => Q("_source", value);
		}

		///<summary>A list of fields to exclude from the returned _source field</summary>
		public Fields SourceExcludes
		{
			get => Q<Fields>("_source_excludes");
			set => Q("_source_excludes", value);
		}

		///<summary>A list of fields to extract and return from the _source field</summary>
		public Fields SourceIncludes
		{
			get => Q<Fields>("_source_includes");
			set => Q("_source_includes", value);
		}
	}

	public partial class ExplainRequest<TDocument> : ExplainRequest, IExplainRequest<TDocument>
	{
		protected IExplainRequest<TDocument> TypedSelf => this;
		///<summary>/{index}/_explain/{id}</summary>
		///<param name = "index">this parameter is required</param>
		///<param name = "id">this parameter is required</param>
		public ExplainRequest(IndexName index, Id id): base(index, id)
		{
		}

		///<summary>/{index}/_explain/{id}</summary>
		///<param name = "id">this parameter is required</param>
		public ExplainRequest(Id id): base(typeof(TDocument), id)
		{
		}

		///<summary>/{index}/_explain/{id}</summary>
		///<param name = "id">The document used to resolve the path from</param>
		public ExplainRequest(TDocument documentWithId, IndexName index = null, Id id = null): this(index ?? typeof(TDocument), id ?? Nest.Id.From(documentWithId)) => DocumentFromPath(documentWithId);
		partial void DocumentFromPath(TDocument document);
		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal ExplainRequest(): base()
		{
		}
	}

	[InterfaceDataContract]
	public partial interface IFieldCapabilitiesRequest : IRequest<FieldCapabilitiesRequestParameters>
	{
		[IgnoreDataMember]
		Indices Index
		{
			get;
		}
	}

	///<summary>Request for FieldCapabilities <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/search-field-caps.html</pre></summary>
	public partial class FieldCapabilitiesRequest : PlainRequestBase<FieldCapabilitiesRequestParameters>, IFieldCapabilitiesRequest
	{
		protected IFieldCapabilitiesRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_field_caps", "{index}/_field_caps"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_field_caps</summary>
		public FieldCapabilitiesRequest(): base()
		{
		}

		///<summary>/{index}/_field_caps</summary>
		///<param name = "index">Optional, accepts null</param>
		public FieldCapabilitiesRequest(Indices index): base(r => r.Optional("index", index))
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Indices IFieldCapabilitiesRequest.Index => Self.RouteValues.Get<Indices>("index");
		// Request parameters
		///<summary>
		/// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have
		/// been specified)
		///</summary>
		public bool? AllowNoIndices
		{
			get => Q<bool? >("allow_no_indices");
			set => Q("allow_no_indices", value);
		}

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ExpandWildcards? ExpandWildcards
		{
			get => Q<ExpandWildcards? >("expand_wildcards");
			set => Q("expand_wildcards", value);
		}

		///<summary>A comma-separated list of field names</summary>
		public Fields Fields
		{
			get => Q<Fields>("fields");
			set => Q("fields", value);
		}

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public bool? IgnoreUnavailable
		{
			get => Q<bool? >("ignore_unavailable");
			set => Q("ignore_unavailable", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IGetRequest : IRequest<GetRequestParameters>
	{
		[IgnoreDataMember]
		IndexName Index
		{
			get;
		}

		[IgnoreDataMember]
		Id Id
		{
			get;
		}
	}

	public partial interface IGetRequest<TDocument> : IGetRequest
	{
	}

	///<summary>Request for Get <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-get.html</pre></summary>
	public partial class GetRequest : PlainRequestBase<GetRequestParameters>, IGetRequest
	{
		protected IGetRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"{index}/_doc/{id}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/{index}/_doc/{id}</summary>
		///<param name = "index">this parameter is required</param>
		///<param name = "id">this parameter is required</param>
		public GetRequest(IndexName index, Id id): base(r => r.Required("index", index).Required("id", id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal GetRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		IndexName IGetRequest.Index => Self.RouteValues.Get<IndexName>("index");
		[IgnoreDataMember]
		Id IGetRequest.Id => Self.RouteValues.Get<Id>("id");
		// Request parameters
		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public string Preference
		{
			get => Q<string>("preference");
			set => Q("preference", value);
		}

		///<summary>Specify whether to perform the operation in realtime or search mode</summary>
		public bool? Realtime
		{
			get => Q<bool? >("realtime");
			set => Q("realtime", value);
		}

		///<summary>Refresh the shard containing the document before performing the operation</summary>
		public bool? Refresh
		{
			get => Q<bool? >("refresh");
			set => Q("refresh", value);
		}

		///<summary>
		/// A document is routed to a particular shard in an index using the following formula
		/// <para> shard_num = hash(_routing) % num_primary_shards</para>
		/// <para>Elasticsearch will use the document id if not provided. </para>
		/// <para>For requests that are constructed from/for a document NEST will automatically infer the routing key
		/// if that document has a <see cref = "Nest.JoinField"/> or a routing mapping on for its type exists on <see cref = "Nest.ConnectionSettings"
		////></para>
		///</summary>
		public Routing Routing
		{
			get => Q<Routing>("routing");
			set => Q("routing", value);
		}

		///<summary>Whether the _source should be included in the response.</summary>
		public bool? SourceEnabled
		{
			get => Q<bool? >("_source");
			set => Q("_source", value);
		}

		///<summary>A list of fields to exclude from the returned _source field</summary>
		public Fields SourceExcludes
		{
			get => Q<Fields>("_source_excludes");
			set => Q("_source_excludes", value);
		}

		///<summary>A list of fields to extract and return from the _source field</summary>
		public Fields SourceIncludes
		{
			get => Q<Fields>("_source_includes");
			set => Q("_source_includes", value);
		}

		///<summary>A comma-separated list of stored fields to return in the response</summary>
		public Fields StoredFields
		{
			get => Q<Fields>("stored_fields");
			set => Q("stored_fields", value);
		}

		///<summary>Explicit version number for concurrency control</summary>
		public long? Version
		{
			get => Q<long? >("version");
			set => Q("version", value);
		}

		///<summary>Specific version type</summary>
		public VersionType? VersionType
		{
			get => Q<VersionType? >("version_type");
			set => Q("version_type", value);
		}
	}

	public partial class GetRequest<TDocument> : GetRequest, IGetRequest<TDocument>
	{
		protected IGetRequest<TDocument> TypedSelf => this;
		///<summary>/{index}/_doc/{id}</summary>
		///<param name = "index">this parameter is required</param>
		///<param name = "id">this parameter is required</param>
		public GetRequest(IndexName index, Id id): base(index, id)
		{
		}

		///<summary>/{index}/_doc/{id}</summary>
		///<param name = "id">this parameter is required</param>
		public GetRequest(Id id): base(typeof(TDocument), id)
		{
		}

		///<summary>/{index}/_doc/{id}</summary>
		///<param name = "id">The document used to resolve the path from</param>
		public GetRequest(TDocument documentWithId, IndexName index = null, Id id = null): this(index ?? typeof(TDocument), id ?? Nest.Id.From(documentWithId)) => DocumentFromPath(documentWithId);
		partial void DocumentFromPath(TDocument document);
		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal GetRequest(): base()
		{
		}
	}

	[InterfaceDataContract]
	public partial interface IGetScriptRequest : IRequest<GetScriptRequestParameters>
	{
		[IgnoreDataMember]
		Id Id
		{
			get;
		}
	}

	///<summary>Request for GetScript <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-scripting.html</pre></summary>
	public partial class GetScriptRequest : PlainRequestBase<GetScriptRequestParameters>, IGetScriptRequest
	{
		protected IGetScriptRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_scripts/{id}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_scripts/{id}</summary>
		///<param name = "id">this parameter is required</param>
		public GetScriptRequest(Id id): base(r => r.Required("id", id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal GetScriptRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Id IGetScriptRequest.Id => Self.RouteValues.Get<Id>("id");
		// Request parameters
		///<summary>Specify timeout for connection to master</summary>
		public Time MasterTimeout
		{
			get => Q<Time>("master_timeout");
			set => Q("master_timeout", value);
		}
	}

	[InterfaceDataContract]
	public partial interface ISourceRequest : IRequest<SourceRequestParameters>
	{
		[IgnoreDataMember]
		IndexName Index
		{
			get;
		}

		[IgnoreDataMember]
		Id Id
		{
			get;
		}
	}

	public partial interface ISourceRequest<TDocument> : ISourceRequest
	{
	}

	///<summary>Request for Source <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-get.html</pre></summary>
	public partial class SourceRequest : PlainRequestBase<SourceRequestParameters>, ISourceRequest
	{
		protected ISourceRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"{index}/_source/{id}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/{index}/_source/{id}</summary>
		///<param name = "index">this parameter is required</param>
		///<param name = "id">this parameter is required</param>
		public SourceRequest(IndexName index, Id id): base(r => r.Required("index", index).Required("id", id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal SourceRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		IndexName ISourceRequest.Index => Self.RouteValues.Get<IndexName>("index");
		[IgnoreDataMember]
		Id ISourceRequest.Id => Self.RouteValues.Get<Id>("id");
		// Request parameters
		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public string Preference
		{
			get => Q<string>("preference");
			set => Q("preference", value);
		}

		///<summary>Specify whether to perform the operation in realtime or search mode</summary>
		public bool? Realtime
		{
			get => Q<bool? >("realtime");
			set => Q("realtime", value);
		}

		///<summary>Refresh the shard containing the document before performing the operation</summary>
		public bool? Refresh
		{
			get => Q<bool? >("refresh");
			set => Q("refresh", value);
		}

		///<summary>
		/// A document is routed to a particular shard in an index using the following formula
		/// <para> shard_num = hash(_routing) % num_primary_shards</para>
		/// <para>Elasticsearch will use the document id if not provided. </para>
		/// <para>For requests that are constructed from/for a document NEST will automatically infer the routing key
		/// if that document has a <see cref = "Nest.JoinField"/> or a routing mapping on for its type exists on <see cref = "Nest.ConnectionSettings"
		////></para>
		///</summary>
		public Routing Routing
		{
			get => Q<Routing>("routing");
			set => Q("routing", value);
		}

		///<summary>Whether the _source should be included in the response.</summary>
		public bool? SourceEnabled
		{
			get => Q<bool? >("_source");
			set => Q("_source", value);
		}

		///<summary>A list of fields to exclude from the returned _source field</summary>
		public Fields SourceExcludes
		{
			get => Q<Fields>("_source_excludes");
			set => Q("_source_excludes", value);
		}

		///<summary>A list of fields to extract and return from the _source field</summary>
		public Fields SourceIncludes
		{
			get => Q<Fields>("_source_includes");
			set => Q("_source_includes", value);
		}

		///<summary>Explicit version number for concurrency control</summary>
		public long? Version
		{
			get => Q<long? >("version");
			set => Q("version", value);
		}

		///<summary>Specific version type</summary>
		public VersionType? VersionType
		{
			get => Q<VersionType? >("version_type");
			set => Q("version_type", value);
		}
	}

	public partial class SourceRequest<TDocument> : SourceRequest, ISourceRequest<TDocument>
	{
		protected ISourceRequest<TDocument> TypedSelf => this;
		///<summary>/{index}/_source/{id}</summary>
		///<param name = "index">this parameter is required</param>
		///<param name = "id">this parameter is required</param>
		public SourceRequest(IndexName index, Id id): base(index, id)
		{
		}

		///<summary>/{index}/_source/{id}</summary>
		///<param name = "id">this parameter is required</param>
		public SourceRequest(Id id): base(typeof(TDocument), id)
		{
		}

		///<summary>/{index}/_source/{id}</summary>
		///<param name = "id">The document used to resolve the path from</param>
		public SourceRequest(TDocument documentWithId, IndexName index = null, Id id = null): this(index ?? typeof(TDocument), id ?? Nest.Id.From(documentWithId)) => DocumentFromPath(documentWithId);
		partial void DocumentFromPath(TDocument document);
		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal SourceRequest(): base()
		{
		}
	}

	[InterfaceDataContract]
	public partial interface IGraphExploreRequest : IRequest<GraphExploreRequestParameters>
	{
		[IgnoreDataMember]
		Indices Index
		{
			get;
		}
	}

	public partial interface IGraphExploreRequest<T> : IGraphExploreRequest
	{
	}

	///<summary>Request for Explore <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/graph-explore-api.html</pre></summary>
	public partial class GraphExploreRequest : PlainRequestBase<GraphExploreRequestParameters>, IGraphExploreRequest
	{
		protected IGraphExploreRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"{index}/_graph/explore"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/{index}/_graph/explore</summary>
		///<param name = "index">this parameter is required</param>
		public GraphExploreRequest(Indices index): base(r => r.Required("index", index))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal GraphExploreRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Indices IGraphExploreRequest.Index => Self.RouteValues.Get<Indices>("index");
		// Request parameters
		///<summary>
		/// A document is routed to a particular shard in an index using the following formula
		/// <para> shard_num = hash(_routing) % num_primary_shards</para>
		/// <para>Elasticsearch will use the document id if not provided. </para>
		/// <para>For requests that are constructed from/for a document NEST will automatically infer the routing key
		/// if that document has a <see cref = "Nest.JoinField"/> or a routing mapping on for its type exists on <see cref = "Nest.ConnectionSettings"
		////></para>
		///</summary>
		public Routing Routing
		{
			get => Q<Routing>("routing");
			set => Q("routing", value);
		}

		///<summary>Explicit operation timeout</summary>
		public Time Timeout
		{
			get => Q<Time>("timeout");
			set => Q("timeout", value);
		}
	}

	public partial class GraphExploreRequest<T> : GraphExploreRequest, IGraphExploreRequest<T>
	{
		protected IGraphExploreRequest<T> TypedSelf => this;
		///<summary>/{index}/_graph/explore</summary>
		///<param name = "index">this parameter is required</param>
		public GraphExploreRequest(Indices index): base(index)
		{
		}

		///<summary>/{index}/_graph/explore</summary>
		public GraphExploreRequest(): base(typeof(T))
		{
		}
	}

	[InterfaceDataContract]
	public partial interface IDeleteLifecycleRequest : IRequest<DeleteLifecycleRequestParameters>
	{
		[IgnoreDataMember]
		PolicyId PolicyId
		{
			get;
		}
	}

	///<summary>Request for DeleteLifecycle <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/ilm-delete-lifecycle.html</pre></summary>
	public partial class DeleteLifecycleRequest : PlainRequestBase<DeleteLifecycleRequestParameters>, IDeleteLifecycleRequest
	{
		protected IDeleteLifecycleRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_ilm/policy/{policy_id}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_ilm/policy/{policy_id}</summary>
		///<param name = "policy_id">this parameter is required</param>
		public DeleteLifecycleRequest(PolicyId policy_id): base(r => r.Required("policy_id", policy_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal DeleteLifecycleRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		PolicyId IDeleteLifecycleRequest.PolicyId => Self.RouteValues.Get<PolicyId>("policy_id");
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IExplainLifecycleRequest : IRequest<ExplainLifecycleRequestParameters>
	{
		[IgnoreDataMember]
		IndexName Index
		{
			get;
		}
	}

	///<summary>Request for ExplainLifecycle <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/ilm-explain-lifecycle.html</pre></summary>
	public partial class ExplainLifecycleRequest : PlainRequestBase<ExplainLifecycleRequestParameters>, IExplainLifecycleRequest
	{
		protected IExplainLifecycleRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"{index}/_ilm/explain"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/{index}/_ilm/explain</summary>
		///<param name = "index">this parameter is required</param>
		public ExplainLifecycleRequest(IndexName index): base(r => r.Required("index", index))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal ExplainLifecycleRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		IndexName IExplainLifecycleRequest.Index => Self.RouteValues.Get<IndexName>("index");
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IGetLifecycleRequest : IRequest<GetLifecycleRequestParameters>
	{
		[IgnoreDataMember]
		PolicyId PolicyId
		{
			get;
		}
	}

	///<summary>Request for GetLifecycle <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/ilm-get-lifecycle.html</pre></summary>
	public partial class GetLifecycleRequest : PlainRequestBase<GetLifecycleRequestParameters>, IGetLifecycleRequest
	{
		protected IGetLifecycleRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_ilm/policy/{policy_id}", "_ilm/policy"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_ilm/policy/{policy_id}</summary>
		///<param name = "policy_id">Optional, accepts null</param>
		public GetLifecycleRequest(PolicyId policy_id): base(r => r.Optional("policy_id", policy_id))
		{
		}

		///<summary>/_ilm/policy</summary>
		public GetLifecycleRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		PolicyId IGetLifecycleRequest.PolicyId => Self.RouteValues.Get<PolicyId>("policy_id");
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IGetIlmStatusRequest : IRequest<GetIlmStatusRequestParameters>
	{
	}

	///<summary>Request for GetIlmStatus <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/ilm-get-status.html</pre></summary>
	public partial class GetIlmStatusRequest : PlainRequestBase<GetIlmStatusRequestParameters>, IGetIlmStatusRequest
	{
		protected IGetIlmStatusRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_ilm/status"});
		internal override ApiUrls ApiUrls => Urls;
	// values part of the url path
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IMoveToStepRequest : IRequest<MoveToStepRequestParameters>
	{
		[IgnoreDataMember]
		IndexName Index
		{
			get;
		}
	}

	///<summary>Request for MoveToStep <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/ilm-move-to-step.html</pre></summary>
	public partial class MoveToStepRequest : PlainRequestBase<MoveToStepRequestParameters>, IMoveToStepRequest
	{
		protected IMoveToStepRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_ilm/move/{index}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_ilm/move/{index}</summary>
		///<param name = "index">this parameter is required</param>
		public MoveToStepRequest(IndexName index): base(r => r.Required("index", index))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal MoveToStepRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		IndexName IMoveToStepRequest.Index => Self.RouteValues.Get<IndexName>("index");
	// Request parameters
	//TODO THIS METHOD IS UNMAPPED! Expected to find MoveToStepDescriptor and MoveToStepRequest in a file called MoveToStepRequest.cs in NEST's codebase
	}

	[InterfaceDataContract]
	public partial interface IPutLifecycleRequest : IRequest<PutLifecycleRequestParameters>
	{
		[IgnoreDataMember]
		PolicyId PolicyId
		{
			get;
		}
	}

	///<summary>Request for PutLifecycle <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/ilm-put-lifecycle.html</pre></summary>
	public partial class PutLifecycleRequest : PlainRequestBase<PutLifecycleRequestParameters>, IPutLifecycleRequest
	{
		protected IPutLifecycleRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_ilm/policy/{policy_id}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_ilm/policy/{policy_id}</summary>
		///<param name = "policy_id">this parameter is required</param>
		public PutLifecycleRequest(PolicyId policy_id): base(r => r.Required("policy_id", policy_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal PutLifecycleRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		PolicyId IPutLifecycleRequest.PolicyId => Self.RouteValues.Get<PolicyId>("policy_id");
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IRemovePolicyRequest : IRequest<RemovePolicyRequestParameters>
	{
		[IgnoreDataMember]
		IndexName Index
		{
			get;
		}
	}

	///<summary>Request for RemovePolicy <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/ilm-remove-policy.html</pre></summary>
	public partial class RemovePolicyRequest : PlainRequestBase<RemovePolicyRequestParameters>, IRemovePolicyRequest
	{
		protected IRemovePolicyRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"{index}/_ilm/remove"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/{index}/_ilm/remove</summary>
		///<param name = "index">this parameter is required</param>
		public RemovePolicyRequest(IndexName index): base(r => r.Required("index", index))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal RemovePolicyRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		IndexName IRemovePolicyRequest.Index => Self.RouteValues.Get<IndexName>("index");
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IRetryIlmRequest : IRequest<RetryIlmRequestParameters>
	{
		[IgnoreDataMember]
		IndexName Index
		{
			get;
		}
	}

	///<summary>Request for RetryIlm <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/ilm-retry-policy.html</pre></summary>
	public partial class RetryIlmRequest : PlainRequestBase<RetryIlmRequestParameters>, IRetryIlmRequest
	{
		protected IRetryIlmRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"{index}/_ilm/retry"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/{index}/_ilm/retry</summary>
		///<param name = "index">this parameter is required</param>
		public RetryIlmRequest(IndexName index): base(r => r.Required("index", index))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal RetryIlmRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		IndexName IRetryIlmRequest.Index => Self.RouteValues.Get<IndexName>("index");
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IStartIlmRequest : IRequest<StartIlmRequestParameters>
	{
	}

	///<summary>Request for StartIlm <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/ilm-start.html</pre></summary>
	public partial class StartIlmRequest : PlainRequestBase<StartIlmRequestParameters>, IStartIlmRequest
	{
		protected IStartIlmRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_ilm/start"});
		internal override ApiUrls ApiUrls => Urls;
	// values part of the url path
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IStopIlmRequest : IRequest<StopIlmRequestParameters>
	{
	}

	///<summary>Request for StopIlm <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/ilm-stop.html</pre></summary>
	public partial class StopIlmRequest : PlainRequestBase<StopIlmRequestParameters>, IStopIlmRequest
	{
		protected IStopIlmRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_ilm/stop"});
		internal override ApiUrls ApiUrls => Urls;
	// values part of the url path
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IIndexRequest : IRequest<IndexRequestParameters>
	{
		[IgnoreDataMember]
		IndexName Index
		{
			get;
		}

		[IgnoreDataMember]
		Id Id
		{
			get;
		}
	}

	public partial interface IIndexRequest<TDocument> : IIndexRequest
	{
	}

	///<summary>Request for Index <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-index_.html</pre></summary>
	public partial class IndexRequest : PlainRequestBase<IndexRequestParameters>, IIndexRequest
	{
		protected IIndexRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"{index}/_doc/{id}", "{index}/_doc"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/{index}/_doc/{id}</summary>
		///<param name = "index">this parameter is required</param>
		///<param name = "id">Optional, accepts null</param>
		public IndexRequest(IndexName index, Id id): base(r => r.Required("index", index).Optional("id", id))
		{
		}

		///<summary>/{index}/_doc</summary>
		///<param name = "index">this parameter is required</param>
		public IndexRequest(IndexName index): base(r => r.Required("index", index))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal IndexRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		IndexName IIndexRequest.Index => Self.RouteValues.Get<IndexName>("index");
		[IgnoreDataMember]
		Id IIndexRequest.Id => Self.RouteValues.Get<Id>("id");
		// Request parameters
		///<summary>only perform the index operation if the last operation that has changed the document has the specified primary term</summary>
		public long? IfPrimaryTerm
		{
			get => Q<long? >("if_primary_term");
			set => Q("if_primary_term", value);
		}

		///<summary>only perform the index operation if the last operation that has changed the document has the specified sequence number</summary>
		public long? IfSequenceNumber
		{
			get => Q<long? >("if_seq_no");
			set => Q("if_seq_no", value);
		}

		///<summary>Explicit operation type</summary>
		public OpType? OpType
		{
			get => Q<OpType? >("op_type");
			set => Q("op_type", value);
		}

		///<summary>The pipeline id to preprocess incoming documents with</summary>
		public string Pipeline
		{
			get => Q<string>("pipeline");
			set => Q("pipeline", value);
		}

		///<summary>
		/// If `true` then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this
		/// operation visible to search, if `false` (the default) then do nothing with refreshes.
		///</summary>
		public Refresh? Refresh
		{
			get => Q<Refresh? >("refresh");
			set => Q("refresh", value);
		}

		///<summary>
		/// A document is routed to a particular shard in an index using the following formula
		/// <para> shard_num = hash(_routing) % num_primary_shards</para>
		/// <para>Elasticsearch will use the document id if not provided. </para>
		/// <para>For requests that are constructed from/for a document NEST will automatically infer the routing key
		/// if that document has a <see cref = "Nest.JoinField"/> or a routing mapping on for its type exists on <see cref = "Nest.ConnectionSettings"
		////></para>
		///</summary>
		public Routing Routing
		{
			get => Q<Routing>("routing");
			set => Q("routing", value);
		}

		///<summary>Explicit operation timeout</summary>
		public Time Timeout
		{
			get => Q<Time>("timeout");
			set => Q("timeout", value);
		}

		///<summary>Explicit version number for concurrency control</summary>
		public long? Version
		{
			get => Q<long? >("version");
			set => Q("version", value);
		}

		///<summary>Specific version type</summary>
		public VersionType? VersionType
		{
			get => Q<VersionType? >("version_type");
			set => Q("version_type", value);
		}

		///<summary>
		/// Sets the number of shard copies that must be active before proceeding with the index operation. Defaults to 1, meaning the primary shard
		/// only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the
		/// shard (number of replicas + 1)
		///</summary>
		public string WaitForActiveShards
		{
			get => Q<string>("wait_for_active_shards");
			set => Q("wait_for_active_shards", value);
		}
	}

	public partial class IndexRequest<TDocument> : IndexRequest, IIndexRequest<TDocument>
	{
		protected IIndexRequest<TDocument> TypedSelf => this;
		///<summary>/{index}/_doc/{id}</summary>
		///<param name = "index">this parameter is required</param>
		///<param name = "id">Optional, accepts null</param>
		public IndexRequest(IndexName index, Id id): base(index, id)
		{
		}

		///<summary>/{index}/_doc</summary>
		///<param name = "index">this parameter is required</param>
		public IndexRequest(IndexName index): base(index)
		{
		}

		///<summary>/{index}/_doc/{id}</summary>
		///<param name = "id">Optional, accepts null</param>
		public IndexRequest(Id id): base(typeof(TDocument), id)
		{
		}

		///<summary>/{index}/_doc</summary>
		public IndexRequest(): base(typeof(TDocument))
		{
		}

		///<summary>/{index}/_doc/{id}</summary>
		///<param name = "id">The document used to resolve the path from</param>
		public IndexRequest(TDocument documentWithId, IndexName index = null, Id id = null): this(index ?? typeof(TDocument), id ?? Nest.Id.From(documentWithId)) => DocumentFromPath(documentWithId);
		partial void DocumentFromPath(TDocument document);
	}

	[InterfaceDataContract]
	public partial interface IAnalyzeRequest : IRequest<AnalyzeRequestParameters>
	{
		[IgnoreDataMember]
		IndexName Index
		{
			get;
		}
	}

	///<summary>Request for Analyze <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-analyze.html</pre></summary>
	public partial class AnalyzeRequest : PlainRequestBase<AnalyzeRequestParameters>, IAnalyzeRequest
	{
		protected IAnalyzeRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_analyze", "{index}/_analyze"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_analyze</summary>
		public AnalyzeRequest(): base()
		{
		}

		///<summary>/{index}/_analyze</summary>
		///<param name = "index">Optional, accepts null</param>
		public AnalyzeRequest(IndexName index): base(r => r.Optional("index", index))
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		IndexName IAnalyzeRequest.Index => Self.RouteValues.Get<IndexName>("index");
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IClearCacheRequest : IRequest<ClearCacheRequestParameters>
	{
		[IgnoreDataMember]
		Indices Index
		{
			get;
		}
	}

	///<summary>Request for ClearCache <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-clearcache.html</pre></summary>
	public partial class ClearCacheRequest : PlainRequestBase<ClearCacheRequestParameters>, IClearCacheRequest
	{
		protected IClearCacheRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_cache/clear", "{index}/_cache/clear"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_cache/clear</summary>
		public ClearCacheRequest(): base()
		{
		}

		///<summary>/{index}/_cache/clear</summary>
		///<param name = "index">Optional, accepts null</param>
		public ClearCacheRequest(Indices index): base(r => r.Optional("index", index))
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Indices IClearCacheRequest.Index => Self.RouteValues.Get<Indices>("index");
		// Request parameters
		///<summary>
		/// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have
		/// been specified)
		///</summary>
		public bool? AllowNoIndices
		{
			get => Q<bool? >("allow_no_indices");
			set => Q("allow_no_indices", value);
		}

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ExpandWildcards? ExpandWildcards
		{
			get => Q<ExpandWildcards? >("expand_wildcards");
			set => Q("expand_wildcards", value);
		}

		///<summary>Clear field data</summary>
		public bool? Fielddata
		{
			get => Q<bool? >("fielddata");
			set => Q("fielddata", value);
		}

		///<summary>A comma-separated list of fields to clear when using the `fielddata` parameter (default: all)</summary>
		public Fields Fields
		{
			get => Q<Fields>("fields");
			set => Q("fields", value);
		}

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public bool? IgnoreUnavailable
		{
			get => Q<bool? >("ignore_unavailable");
			set => Q("ignore_unavailable", value);
		}

		///<summary>Clear query caches</summary>
		public bool? Query
		{
			get => Q<bool? >("query");
			set => Q("query", value);
		}

		///<summary>Clear request cache</summary>
		public bool? Request
		{
			get => Q<bool? >("request");
			set => Q("request", value);
		}
	}

	[InterfaceDataContract]
	public partial interface ICloseIndexRequest : IRequest<CloseIndexRequestParameters>
	{
		[IgnoreDataMember]
		Indices Index
		{
			get;
		}
	}

	///<summary>Request for CloseIndex <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-open-close.html</pre></summary>
	public partial class CloseIndexRequest : PlainRequestBase<CloseIndexRequestParameters>, ICloseIndexRequest
	{
		protected ICloseIndexRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"{index}/_close"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/{index}/_close</summary>
		///<param name = "index">this parameter is required</param>
		public CloseIndexRequest(Indices index): base(r => r.Required("index", index))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal CloseIndexRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Indices ICloseIndexRequest.Index => Self.RouteValues.Get<Indices>("index");
		// Request parameters
		///<summary>
		/// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have
		/// been specified)
		///</summary>
		public bool? AllowNoIndices
		{
			get => Q<bool? >("allow_no_indices");
			set => Q("allow_no_indices", value);
		}

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ExpandWildcards? ExpandWildcards
		{
			get => Q<ExpandWildcards? >("expand_wildcards");
			set => Q("expand_wildcards", value);
		}

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public bool? IgnoreUnavailable
		{
			get => Q<bool? >("ignore_unavailable");
			set => Q("ignore_unavailable", value);
		}

		///<summary>Specify timeout for connection to master</summary>
		public Time MasterTimeout
		{
			get => Q<Time>("master_timeout");
			set => Q("master_timeout", value);
		}

		///<summary>Explicit operation timeout</summary>
		public Time Timeout
		{
			get => Q<Time>("timeout");
			set => Q("timeout", value);
		}
	}

	[InterfaceDataContract]
	public partial interface ICreateIndexRequest : IRequest<CreateIndexRequestParameters>
	{
		[IgnoreDataMember]
		IndexName Index
		{
			get;
		}
	}

	///<summary>Request for CreateIndex <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-create-index.html</pre></summary>
	public partial class CreateIndexRequest : PlainRequestBase<CreateIndexRequestParameters>, ICreateIndexRequest
	{
		protected ICreateIndexRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"{index}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/{index}</summary>
		///<param name = "index">this parameter is required</param>
		public CreateIndexRequest(IndexName index): base(r => r.Required("index", index))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal CreateIndexRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		IndexName ICreateIndexRequest.Index => Self.RouteValues.Get<IndexName>("index");
		// Request parameters
		///<summary>Whether a type should be expected in the body of the mappings.</summary>
		public bool? IncludeTypeName
		{
			get => Q<bool? >("include_type_name");
			set => Q("include_type_name", value);
		}

		///<summary>Specify timeout for connection to master</summary>
		public Time MasterTimeout
		{
			get => Q<Time>("master_timeout");
			set => Q("master_timeout", value);
		}

		///<summary>Explicit operation timeout</summary>
		public Time Timeout
		{
			get => Q<Time>("timeout");
			set => Q("timeout", value);
		}

		///<summary>Set the number of active shards to wait for before the operation returns.</summary>
		public string WaitForActiveShards
		{
			get => Q<string>("wait_for_active_shards");
			set => Q("wait_for_active_shards", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IDeleteIndexRequest : IRequest<DeleteIndexRequestParameters>
	{
		[IgnoreDataMember]
		Indices Index
		{
			get;
		}
	}

	///<summary>Request for DeleteIndex <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-delete-index.html</pre></summary>
	public partial class DeleteIndexRequest : PlainRequestBase<DeleteIndexRequestParameters>, IDeleteIndexRequest
	{
		protected IDeleteIndexRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"{index}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/{index}</summary>
		///<param name = "index">this parameter is required</param>
		public DeleteIndexRequest(Indices index): base(r => r.Required("index", index))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal DeleteIndexRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Indices IDeleteIndexRequest.Index => Self.RouteValues.Get<Indices>("index");
		// Request parameters
		///<summary>Ignore if a wildcard expression resolves to no concrete indices (default: false)</summary>
		public bool? AllowNoIndices
		{
			get => Q<bool? >("allow_no_indices");
			set => Q("allow_no_indices", value);
		}

		///<summary>Whether wildcard expressions should get expanded to open or closed indices (default: open)</summary>
		public ExpandWildcards? ExpandWildcards
		{
			get => Q<ExpandWildcards? >("expand_wildcards");
			set => Q("expand_wildcards", value);
		}

		///<summary>Ignore unavailable indexes (default: false)</summary>
		public bool? IgnoreUnavailable
		{
			get => Q<bool? >("ignore_unavailable");
			set => Q("ignore_unavailable", value);
		}

		///<summary>Specify timeout for connection to master</summary>
		public Time MasterTimeout
		{
			get => Q<Time>("master_timeout");
			set => Q("master_timeout", value);
		}

		///<summary>Explicit operation timeout</summary>
		public Time Timeout
		{
			get => Q<Time>("timeout");
			set => Q("timeout", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IDeleteAliasRequest : IRequest<DeleteAliasRequestParameters>
	{
		[IgnoreDataMember]
		Indices Index
		{
			get;
		}

		[IgnoreDataMember]
		Names Name
		{
			get;
		}
	}

	///<summary>Request for DeleteAlias <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-aliases.html</pre></summary>
	public partial class DeleteAliasRequest : PlainRequestBase<DeleteAliasRequestParameters>, IDeleteAliasRequest
	{
		protected IDeleteAliasRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"{index}/_alias/{name}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/{index}/_alias/{name}</summary>
		///<param name = "index">this parameter is required</param>
		///<param name = "name">this parameter is required</param>
		public DeleteAliasRequest(Indices index, Names name): base(r => r.Required("index", index).Required("name", name))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal DeleteAliasRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Indices IDeleteAliasRequest.Index => Self.RouteValues.Get<Indices>("index");
		[IgnoreDataMember]
		Names IDeleteAliasRequest.Name => Self.RouteValues.Get<Names>("name");
		// Request parameters
		///<summary>Specify timeout for connection to master</summary>
		public Time MasterTimeout
		{
			get => Q<Time>("master_timeout");
			set => Q("master_timeout", value);
		}

		///<summary>Explicit timestamp for the document</summary>
		public Time Timeout
		{
			get => Q<Time>("timeout");
			set => Q("timeout", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IDeleteIndexTemplateRequest : IRequest<DeleteIndexTemplateRequestParameters>
	{
		[IgnoreDataMember]
		Name Name
		{
			get;
		}
	}

	///<summary>Request for DeleteIndexTemplate <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-templates.html</pre></summary>
	public partial class DeleteIndexTemplateRequest : PlainRequestBase<DeleteIndexTemplateRequestParameters>, IDeleteIndexTemplateRequest
	{
		protected IDeleteIndexTemplateRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_template/{name}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_template/{name}</summary>
		///<param name = "name">this parameter is required</param>
		public DeleteIndexTemplateRequest(Name name): base(r => r.Required("name", name))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal DeleteIndexTemplateRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Name IDeleteIndexTemplateRequest.Name => Self.RouteValues.Get<Name>("name");
		// Request parameters
		///<summary>Specify timeout for connection to master</summary>
		public Time MasterTimeout
		{
			get => Q<Time>("master_timeout");
			set => Q("master_timeout", value);
		}

		///<summary>Explicit operation timeout</summary>
		public Time Timeout
		{
			get => Q<Time>("timeout");
			set => Q("timeout", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IIndexExistsRequest : IRequest<IndexExistsRequestParameters>
	{
		[IgnoreDataMember]
		Indices Index
		{
			get;
		}
	}

	///<summary>Request for IndexExists <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-exists.html</pre></summary>
	public partial class IndexExistsRequest : PlainRequestBase<IndexExistsRequestParameters>, IIndexExistsRequest
	{
		protected IIndexExistsRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"{index}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/{index}</summary>
		///<param name = "index">this parameter is required</param>
		public IndexExistsRequest(Indices index): base(r => r.Required("index", index))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal IndexExistsRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Indices IIndexExistsRequest.Index => Self.RouteValues.Get<Indices>("index");
		// Request parameters
		///<summary>Ignore if a wildcard expression resolves to no concrete indices (default: false)</summary>
		public bool? AllowNoIndices
		{
			get => Q<bool? >("allow_no_indices");
			set => Q("allow_no_indices", value);
		}

		///<summary>Whether wildcard expressions should get expanded to open or closed indices (default: open)</summary>
		public ExpandWildcards? ExpandWildcards
		{
			get => Q<ExpandWildcards? >("expand_wildcards");
			set => Q("expand_wildcards", value);
		}

		///<summary>Return settings in flat format (default: false)</summary>
		public bool? FlatSettings
		{
			get => Q<bool? >("flat_settings");
			set => Q("flat_settings", value);
		}

		///<summary>Ignore unavailable indexes (default: false)</summary>
		public bool? IgnoreUnavailable
		{
			get => Q<bool? >("ignore_unavailable");
			set => Q("ignore_unavailable", value);
		}

		///<summary>Whether to return all default setting for each of the indices.</summary>
		public bool? IncludeDefaults
		{
			get => Q<bool? >("include_defaults");
			set => Q("include_defaults", value);
		}

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public bool? Local
		{
			get => Q<bool? >("local");
			set => Q("local", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IAliasExistsRequest : IRequest<AliasExistsRequestParameters>
	{
		[IgnoreDataMember]
		Names Name
		{
			get;
		}

		[IgnoreDataMember]
		Indices Index
		{
			get;
		}
	}

	///<summary>Request for AliasExists <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-aliases.html</pre></summary>
	public partial class AliasExistsRequest : PlainRequestBase<AliasExistsRequestParameters>, IAliasExistsRequest
	{
		protected IAliasExistsRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_alias/{name}", "{index}/_alias/{name}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_alias/{name}</summary>
		///<param name = "name">this parameter is required</param>
		public AliasExistsRequest(Names name): base(r => r.Required("name", name))
		{
		}

		///<summary>/{index}/_alias/{name}</summary>
		///<param name = "index">Optional, accepts null</param>
		///<param name = "name">this parameter is required</param>
		public AliasExistsRequest(Indices index, Names name): base(r => r.Optional("index", index).Required("name", name))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal AliasExistsRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Names IAliasExistsRequest.Name => Self.RouteValues.Get<Names>("name");
		[IgnoreDataMember]
		Indices IAliasExistsRequest.Index => Self.RouteValues.Get<Indices>("index");
		// Request parameters
		///<summary>
		/// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have
		/// been specified)
		///</summary>
		public bool? AllowNoIndices
		{
			get => Q<bool? >("allow_no_indices");
			set => Q("allow_no_indices", value);
		}

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ExpandWildcards? ExpandWildcards
		{
			get => Q<ExpandWildcards? >("expand_wildcards");
			set => Q("expand_wildcards", value);
		}

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public bool? IgnoreUnavailable
		{
			get => Q<bool? >("ignore_unavailable");
			set => Q("ignore_unavailable", value);
		}

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public bool? Local
		{
			get => Q<bool? >("local");
			set => Q("local", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IIndexTemplateExistsRequest : IRequest<IndexTemplateExistsRequestParameters>
	{
		[IgnoreDataMember]
		Names Name
		{
			get;
		}
	}

	///<summary>Request for IndexTemplateExists <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-templates.html</pre></summary>
	public partial class IndexTemplateExistsRequest : PlainRequestBase<IndexTemplateExistsRequestParameters>, IIndexTemplateExistsRequest
	{
		protected IIndexTemplateExistsRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_template/{name}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_template/{name}</summary>
		///<param name = "name">this parameter is required</param>
		public IndexTemplateExistsRequest(Names name): base(r => r.Required("name", name))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal IndexTemplateExistsRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Names IIndexTemplateExistsRequest.Name => Self.RouteValues.Get<Names>("name");
		// Request parameters
		///<summary>Return settings in flat format (default: false)</summary>
		public bool? FlatSettings
		{
			get => Q<bool? >("flat_settings");
			set => Q("flat_settings", value);
		}

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public bool? Local
		{
			get => Q<bool? >("local");
			set => Q("local", value);
		}

		///<summary>Explicit operation timeout for connection to master node</summary>
		public Time MasterTimeout
		{
			get => Q<Time>("master_timeout");
			set => Q("master_timeout", value);
		}
	}

	[InterfaceDataContract]
	public partial interface ITypeExistsRequest : IRequest<TypeExistsRequestParameters>
	{
		[IgnoreDataMember]
		Indices Index
		{
			get;
		}

		[IgnoreDataMember]
		Names Type
		{
			get;
		}
	}

	///<summary>Request for TypeExists <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-types-exists.html</pre></summary>
	public partial class TypeExistsRequest : PlainRequestBase<TypeExistsRequestParameters>, ITypeExistsRequest
	{
		protected ITypeExistsRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"{index}/_mapping/{type}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/{index}/_mapping/{type}</summary>
		///<param name = "index">this parameter is required</param>
		///<param name = "type">this parameter is required</param>
		public TypeExistsRequest(Indices index, Names type): base(r => r.Required("index", index).Required("type", type))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal TypeExistsRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Indices ITypeExistsRequest.Index => Self.RouteValues.Get<Indices>("index");
		[IgnoreDataMember]
		Names ITypeExistsRequest.Type => Self.RouteValues.Get<Names>("type");
		// Request parameters
		///<summary>
		/// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have
		/// been specified)
		///</summary>
		public bool? AllowNoIndices
		{
			get => Q<bool? >("allow_no_indices");
			set => Q("allow_no_indices", value);
		}

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ExpandWildcards? ExpandWildcards
		{
			get => Q<ExpandWildcards? >("expand_wildcards");
			set => Q("expand_wildcards", value);
		}

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public bool? IgnoreUnavailable
		{
			get => Q<bool? >("ignore_unavailable");
			set => Q("ignore_unavailable", value);
		}

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public bool? Local
		{
			get => Q<bool? >("local");
			set => Q("local", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IFlushRequest : IRequest<FlushRequestParameters>
	{
		[IgnoreDataMember]
		Indices Index
		{
			get;
		}
	}

	///<summary>Request for Flush <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-flush.html</pre></summary>
	public partial class FlushRequest : PlainRequestBase<FlushRequestParameters>, IFlushRequest
	{
		protected IFlushRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_flush", "{index}/_flush"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_flush</summary>
		public FlushRequest(): base()
		{
		}

		///<summary>/{index}/_flush</summary>
		///<param name = "index">Optional, accepts null</param>
		public FlushRequest(Indices index): base(r => r.Optional("index", index))
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Indices IFlushRequest.Index => Self.RouteValues.Get<Indices>("index");
		// Request parameters
		///<summary>
		/// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have
		/// been specified)
		///</summary>
		public bool? AllowNoIndices
		{
			get => Q<bool? >("allow_no_indices");
			set => Q("allow_no_indices", value);
		}

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ExpandWildcards? ExpandWildcards
		{
			get => Q<ExpandWildcards? >("expand_wildcards");
			set => Q("expand_wildcards", value);
		}

		///<summary>
		/// Whether a flush should be forced even if it is not necessarily needed ie. if no changes will be committed to the index. This is useful if
		/// transaction log IDs should be incremented even if no uncommitted changes are present. (This setting can be considered as internal)
		///</summary>
		public bool? Force
		{
			get => Q<bool? >("force");
			set => Q("force", value);
		}

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public bool? IgnoreUnavailable
		{
			get => Q<bool? >("ignore_unavailable");
			set => Q("ignore_unavailable", value);
		}

		///<summary>
		/// If set to true the flush operation will block until the flush can be executed if another flush operation is already executing. The default
		/// is true. If set to false the flush will be skipped iff if another flush operation is already running.
		///</summary>
		public bool? WaitIfOngoing
		{
			get => Q<bool? >("wait_if_ongoing");
			set => Q("wait_if_ongoing", value);
		}
	}

	[InterfaceDataContract]
	public partial interface ISyncedFlushRequest : IRequest<SyncedFlushRequestParameters>
	{
		[IgnoreDataMember]
		Indices Index
		{
			get;
		}
	}

	///<summary>Request for SyncedFlush <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-synced-flush.html</pre></summary>
	public partial class SyncedFlushRequest : PlainRequestBase<SyncedFlushRequestParameters>, ISyncedFlushRequest
	{
		protected ISyncedFlushRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_flush/synced", "{index}/_flush/synced"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_flush/synced</summary>
		public SyncedFlushRequest(): base()
		{
		}

		///<summary>/{index}/_flush/synced</summary>
		///<param name = "index">Optional, accepts null</param>
		public SyncedFlushRequest(Indices index): base(r => r.Optional("index", index))
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Indices ISyncedFlushRequest.Index => Self.RouteValues.Get<Indices>("index");
		// Request parameters
		///<summary>
		/// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have
		/// been specified)
		///</summary>
		public bool? AllowNoIndices
		{
			get => Q<bool? >("allow_no_indices");
			set => Q("allow_no_indices", value);
		}

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ExpandWildcards? ExpandWildcards
		{
			get => Q<ExpandWildcards? >("expand_wildcards");
			set => Q("expand_wildcards", value);
		}

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public bool? IgnoreUnavailable
		{
			get => Q<bool? >("ignore_unavailable");
			set => Q("ignore_unavailable", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IForceMergeRequest : IRequest<ForceMergeRequestParameters>
	{
		[IgnoreDataMember]
		Indices Index
		{
			get;
		}
	}

	///<summary>Request for ForceMerge <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-forcemerge.html</pre></summary>
	public partial class ForceMergeRequest : PlainRequestBase<ForceMergeRequestParameters>, IForceMergeRequest
	{
		protected IForceMergeRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_forcemerge", "{index}/_forcemerge"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_forcemerge</summary>
		public ForceMergeRequest(): base()
		{
		}

		///<summary>/{index}/_forcemerge</summary>
		///<param name = "index">Optional, accepts null</param>
		public ForceMergeRequest(Indices index): base(r => r.Optional("index", index))
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Indices IForceMergeRequest.Index => Self.RouteValues.Get<Indices>("index");
		// Request parameters
		///<summary>
		/// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have
		/// been specified)
		///</summary>
		public bool? AllowNoIndices
		{
			get => Q<bool? >("allow_no_indices");
			set => Q("allow_no_indices", value);
		}

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ExpandWildcards? ExpandWildcards
		{
			get => Q<ExpandWildcards? >("expand_wildcards");
			set => Q("expand_wildcards", value);
		}

		///<summary>Specify whether the index should be flushed after performing the operation (default: true)</summary>
		public bool? Flush
		{
			get => Q<bool? >("flush");
			set => Q("flush", value);
		}

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public bool? IgnoreUnavailable
		{
			get => Q<bool? >("ignore_unavailable");
			set => Q("ignore_unavailable", value);
		}

		///<summary>The number of segments the index should be merged into (default: dynamic)</summary>
		public long? MaxNumSegments
		{
			get => Q<long? >("max_num_segments");
			set => Q("max_num_segments", value);
		}

		///<summary>Specify whether the operation should only expunge deleted documents</summary>
		public bool? OnlyExpungeDeletes
		{
			get => Q<bool? >("only_expunge_deletes");
			set => Q("only_expunge_deletes", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IGetIndexRequest : IRequest<GetIndexRequestParameters>
	{
		[IgnoreDataMember]
		Indices Index
		{
			get;
		}
	}

	///<summary>Request for GetIndex <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-get-index.html</pre></summary>
	public partial class GetIndexRequest : PlainRequestBase<GetIndexRequestParameters>, IGetIndexRequest
	{
		protected IGetIndexRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"{index}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/{index}</summary>
		///<param name = "index">this parameter is required</param>
		public GetIndexRequest(Indices index): base(r => r.Required("index", index))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal GetIndexRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Indices IGetIndexRequest.Index => Self.RouteValues.Get<Indices>("index");
		// Request parameters
		///<summary>Ignore if a wildcard expression resolves to no concrete indices (default: false)</summary>
		public bool? AllowNoIndices
		{
			get => Q<bool? >("allow_no_indices");
			set => Q("allow_no_indices", value);
		}

		///<summary>Whether wildcard expressions should get expanded to open or closed indices (default: open)</summary>
		public ExpandWildcards? ExpandWildcards
		{
			get => Q<ExpandWildcards? >("expand_wildcards");
			set => Q("expand_wildcards", value);
		}

		///<summary>Return settings in flat format (default: false)</summary>
		public bool? FlatSettings
		{
			get => Q<bool? >("flat_settings");
			set => Q("flat_settings", value);
		}

		///<summary>Ignore unavailable indexes (default: false)</summary>
		public bool? IgnoreUnavailable
		{
			get => Q<bool? >("ignore_unavailable");
			set => Q("ignore_unavailable", value);
		}

		///<summary>Whether to return all default setting for each of the indices.</summary>
		public bool? IncludeDefaults
		{
			get => Q<bool? >("include_defaults");
			set => Q("include_defaults", value);
		}

		///<summary>Whether to add the type name to the response (default: false)</summary>
		public bool? IncludeTypeName
		{
			get => Q<bool? >("include_type_name");
			set => Q("include_type_name", value);
		}

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public bool? Local
		{
			get => Q<bool? >("local");
			set => Q("local", value);
		}

		///<summary>Specify timeout for connection to master</summary>
		public Time MasterTimeout
		{
			get => Q<Time>("master_timeout");
			set => Q("master_timeout", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IGetAliasRequest : IRequest<GetAliasRequestParameters>
	{
		[IgnoreDataMember]
		Names Name
		{
			get;
		}

		[IgnoreDataMember]
		Indices Index
		{
			get;
		}
	}

	///<summary>Request for GetAlias <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-aliases.html</pre></summary>
	public partial class GetAliasRequest : PlainRequestBase<GetAliasRequestParameters>, IGetAliasRequest
	{
		protected IGetAliasRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_alias", "_alias/{name}", "{index}/_alias/{name}", "{index}/_alias"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_alias</summary>
		public GetAliasRequest(): base()
		{
		}

		///<summary>/_alias/{name}</summary>
		///<param name = "name">Optional, accepts null</param>
		public GetAliasRequest(Names name): base(r => r.Optional("name", name))
		{
		}

		///<summary>/{index}/_alias/{name}</summary>
		///<param name = "index">Optional, accepts null</param>
		///<param name = "name">Optional, accepts null</param>
		public GetAliasRequest(Indices index, Names name): base(r => r.Optional("index", index).Optional("name", name))
		{
		}

		///<summary>/{index}/_alias</summary>
		///<param name = "index">Optional, accepts null</param>
		public GetAliasRequest(Indices index): base(r => r.Optional("index", index))
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Names IGetAliasRequest.Name => Self.RouteValues.Get<Names>("name");
		[IgnoreDataMember]
		Indices IGetAliasRequest.Index => Self.RouteValues.Get<Indices>("index");
		// Request parameters
		///<summary>
		/// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have
		/// been specified)
		///</summary>
		public bool? AllowNoIndices
		{
			get => Q<bool? >("allow_no_indices");
			set => Q("allow_no_indices", value);
		}

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ExpandWildcards? ExpandWildcards
		{
			get => Q<ExpandWildcards? >("expand_wildcards");
			set => Q("expand_wildcards", value);
		}

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public bool? IgnoreUnavailable
		{
			get => Q<bool? >("ignore_unavailable");
			set => Q("ignore_unavailable", value);
		}

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public bool? Local
		{
			get => Q<bool? >("local");
			set => Q("local", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IGetFieldMappingRequest : IRequest<GetFieldMappingRequestParameters>
	{
		[IgnoreDataMember]
		Fields Fields
		{
			get;
		}

		[IgnoreDataMember]
		Indices Index
		{
			get;
		}
	}

	///<summary>Request for GetFieldMapping <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-get-field-mapping.html</pre></summary>
	public partial class GetFieldMappingRequest : PlainRequestBase<GetFieldMappingRequestParameters>, IGetFieldMappingRequest
	{
		protected IGetFieldMappingRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_mapping/field/{fields}", "{index}/_mapping/field/{fields}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_mapping/field/{fields}</summary>
		///<param name = "fields">this parameter is required</param>
		public GetFieldMappingRequest(Fields fields): base(r => r.Required("fields", fields))
		{
		}

		///<summary>/{index}/_mapping/field/{fields}</summary>
		///<param name = "index">Optional, accepts null</param>
		///<param name = "fields">this parameter is required</param>
		public GetFieldMappingRequest(Indices index, Fields fields): base(r => r.Optional("index", index).Required("fields", fields))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal GetFieldMappingRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Fields IGetFieldMappingRequest.Fields => Self.RouteValues.Get<Fields>("fields");
		[IgnoreDataMember]
		Indices IGetFieldMappingRequest.Index => Self.RouteValues.Get<Indices>("index");
		// Request parameters
		///<summary>
		/// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have
		/// been specified)
		///</summary>
		public bool? AllowNoIndices
		{
			get => Q<bool? >("allow_no_indices");
			set => Q("allow_no_indices", value);
		}

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ExpandWildcards? ExpandWildcards
		{
			get => Q<ExpandWildcards? >("expand_wildcards");
			set => Q("expand_wildcards", value);
		}

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public bool? IgnoreUnavailable
		{
			get => Q<bool? >("ignore_unavailable");
			set => Q("ignore_unavailable", value);
		}

		///<summary>Whether the default mapping values should be returned as well</summary>
		public bool? IncludeDefaults
		{
			get => Q<bool? >("include_defaults");
			set => Q("include_defaults", value);
		}

		///<summary>Whether a type should be returned in the body of the mappings.</summary>
		public bool? IncludeTypeName
		{
			get => Q<bool? >("include_type_name");
			set => Q("include_type_name", value);
		}

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public bool? Local
		{
			get => Q<bool? >("local");
			set => Q("local", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IGetMappingRequest : IRequest<GetMappingRequestParameters>
	{
		[IgnoreDataMember]
		Indices Index
		{
			get;
		}
	}

	///<summary>Request for GetMapping <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-get-mapping.html</pre></summary>
	public partial class GetMappingRequest : PlainRequestBase<GetMappingRequestParameters>, IGetMappingRequest
	{
		protected IGetMappingRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_mapping", "{index}/_mapping"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_mapping</summary>
		public GetMappingRequest(): base()
		{
		}

		///<summary>/{index}/_mapping</summary>
		///<param name = "index">Optional, accepts null</param>
		public GetMappingRequest(Indices index): base(r => r.Optional("index", index))
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Indices IGetMappingRequest.Index => Self.RouteValues.Get<Indices>("index");
		// Request parameters
		///<summary>
		/// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have
		/// been specified)
		///</summary>
		public bool? AllowNoIndices
		{
			get => Q<bool? >("allow_no_indices");
			set => Q("allow_no_indices", value);
		}

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ExpandWildcards? ExpandWildcards
		{
			get => Q<ExpandWildcards? >("expand_wildcards");
			set => Q("expand_wildcards", value);
		}

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public bool? IgnoreUnavailable
		{
			get => Q<bool? >("ignore_unavailable");
			set => Q("ignore_unavailable", value);
		}

		///<summary>Whether to add the type name to the response (default: false)</summary>
		public bool? IncludeTypeName
		{
			get => Q<bool? >("include_type_name");
			set => Q("include_type_name", value);
		}

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public bool? Local
		{
			get => Q<bool? >("local");
			set => Q("local", value);
		}

		///<summary>Specify timeout for connection to master</summary>
		public Time MasterTimeout
		{
			get => Q<Time>("master_timeout");
			set => Q("master_timeout", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IGetIndexSettingsRequest : IRequest<GetIndexSettingsRequestParameters>
	{
		[IgnoreDataMember]
		Indices Index
		{
			get;
		}

		[IgnoreDataMember]
		Names Name
		{
			get;
		}
	}

	///<summary>Request for GetIndexSettings <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-get-settings.html</pre></summary>
	public partial class GetIndexSettingsRequest : PlainRequestBase<GetIndexSettingsRequestParameters>, IGetIndexSettingsRequest
	{
		protected IGetIndexSettingsRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_settings", "{index}/_settings", "{index}/_settings/{name}", "_settings/{name}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_settings</summary>
		public GetIndexSettingsRequest(): base()
		{
		}

		///<summary>/{index}/_settings</summary>
		///<param name = "index">Optional, accepts null</param>
		public GetIndexSettingsRequest(Indices index): base(r => r.Optional("index", index))
		{
		}

		///<summary>/{index}/_settings/{name}</summary>
		///<param name = "index">Optional, accepts null</param>
		///<param name = "name">Optional, accepts null</param>
		public GetIndexSettingsRequest(Indices index, Names name): base(r => r.Optional("index", index).Optional("name", name))
		{
		}

		///<summary>/_settings/{name}</summary>
		///<param name = "name">Optional, accepts null</param>
		public GetIndexSettingsRequest(Names name): base(r => r.Optional("name", name))
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Indices IGetIndexSettingsRequest.Index => Self.RouteValues.Get<Indices>("index");
		[IgnoreDataMember]
		Names IGetIndexSettingsRequest.Name => Self.RouteValues.Get<Names>("name");
		// Request parameters
		///<summary>
		/// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have
		/// been specified)
		///</summary>
		public bool? AllowNoIndices
		{
			get => Q<bool? >("allow_no_indices");
			set => Q("allow_no_indices", value);
		}

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ExpandWildcards? ExpandWildcards
		{
			get => Q<ExpandWildcards? >("expand_wildcards");
			set => Q("expand_wildcards", value);
		}

		///<summary>Return settings in flat format (default: false)</summary>
		public bool? FlatSettings
		{
			get => Q<bool? >("flat_settings");
			set => Q("flat_settings", value);
		}

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public bool? IgnoreUnavailable
		{
			get => Q<bool? >("ignore_unavailable");
			set => Q("ignore_unavailable", value);
		}

		///<summary>Whether to return all default setting for each of the indices.</summary>
		public bool? IncludeDefaults
		{
			get => Q<bool? >("include_defaults");
			set => Q("include_defaults", value);
		}

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public bool? Local
		{
			get => Q<bool? >("local");
			set => Q("local", value);
		}

		///<summary>Specify timeout for connection to master</summary>
		public Time MasterTimeout
		{
			get => Q<Time>("master_timeout");
			set => Q("master_timeout", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IGetIndexTemplateRequest : IRequest<GetIndexTemplateRequestParameters>
	{
		[IgnoreDataMember]
		Names Name
		{
			get;
		}
	}

	///<summary>Request for GetIndexTemplate <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-templates.html</pre></summary>
	public partial class GetIndexTemplateRequest : PlainRequestBase<GetIndexTemplateRequestParameters>, IGetIndexTemplateRequest
	{
		protected IGetIndexTemplateRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_template", "_template/{name}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_template</summary>
		public GetIndexTemplateRequest(): base()
		{
		}

		///<summary>/_template/{name}</summary>
		///<param name = "name">Optional, accepts null</param>
		public GetIndexTemplateRequest(Names name): base(r => r.Optional("name", name))
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Names IGetIndexTemplateRequest.Name => Self.RouteValues.Get<Names>("name");
		// Request parameters
		///<summary>Return settings in flat format (default: false)</summary>
		public bool? FlatSettings
		{
			get => Q<bool? >("flat_settings");
			set => Q("flat_settings", value);
		}

		///<summary>Whether a type should be returned in the body of the mappings.</summary>
		public bool? IncludeTypeName
		{
			get => Q<bool? >("include_type_name");
			set => Q("include_type_name", value);
		}

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public bool? Local
		{
			get => Q<bool? >("local");
			set => Q("local", value);
		}

		///<summary>Explicit operation timeout for connection to master node</summary>
		public Time MasterTimeout
		{
			get => Q<Time>("master_timeout");
			set => Q("master_timeout", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IUpgradeStatusRequest : IRequest<UpgradeStatusRequestParameters>
	{
		[IgnoreDataMember]
		Indices Index
		{
			get;
		}
	}

	///<summary>Request for UpgradeStatus <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-upgrade.html</pre></summary>
	public partial class UpgradeStatusRequest : PlainRequestBase<UpgradeStatusRequestParameters>, IUpgradeStatusRequest
	{
		protected IUpgradeStatusRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_upgrade", "{index}/_upgrade"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_upgrade</summary>
		public UpgradeStatusRequest(): base()
		{
		}

		///<summary>/{index}/_upgrade</summary>
		///<param name = "index">Optional, accepts null</param>
		public UpgradeStatusRequest(Indices index): base(r => r.Optional("index", index))
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Indices IUpgradeStatusRequest.Index => Self.RouteValues.Get<Indices>("index");
		// Request parameters
		///<summary>
		/// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have
		/// been specified)
		///</summary>
		public bool? AllowNoIndices
		{
			get => Q<bool? >("allow_no_indices");
			set => Q("allow_no_indices", value);
		}

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ExpandWildcards? ExpandWildcards
		{
			get => Q<ExpandWildcards? >("expand_wildcards");
			set => Q("expand_wildcards", value);
		}

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public bool? IgnoreUnavailable
		{
			get => Q<bool? >("ignore_unavailable");
			set => Q("ignore_unavailable", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IOpenIndexRequest : IRequest<OpenIndexRequestParameters>
	{
		[IgnoreDataMember]
		Indices Index
		{
			get;
		}
	}

	///<summary>Request for OpenIndex <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-open-close.html</pre></summary>
	public partial class OpenIndexRequest : PlainRequestBase<OpenIndexRequestParameters>, IOpenIndexRequest
	{
		protected IOpenIndexRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"{index}/_open"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/{index}/_open</summary>
		///<param name = "index">this parameter is required</param>
		public OpenIndexRequest(Indices index): base(r => r.Required("index", index))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal OpenIndexRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Indices IOpenIndexRequest.Index => Self.RouteValues.Get<Indices>("index");
		// Request parameters
		///<summary>
		/// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have
		/// been specified)
		///</summary>
		public bool? AllowNoIndices
		{
			get => Q<bool? >("allow_no_indices");
			set => Q("allow_no_indices", value);
		}

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ExpandWildcards? ExpandWildcards
		{
			get => Q<ExpandWildcards? >("expand_wildcards");
			set => Q("expand_wildcards", value);
		}

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public bool? IgnoreUnavailable
		{
			get => Q<bool? >("ignore_unavailable");
			set => Q("ignore_unavailable", value);
		}

		///<summary>Specify timeout for connection to master</summary>
		public Time MasterTimeout
		{
			get => Q<Time>("master_timeout");
			set => Q("master_timeout", value);
		}

		///<summary>Explicit operation timeout</summary>
		public Time Timeout
		{
			get => Q<Time>("timeout");
			set => Q("timeout", value);
		}

		///<summary>Sets the number of active shards to wait for before the operation returns.</summary>
		public string WaitForActiveShards
		{
			get => Q<string>("wait_for_active_shards");
			set => Q("wait_for_active_shards", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IPutAliasRequest : IRequest<PutAliasRequestParameters>
	{
		[IgnoreDataMember]
		Indices Index
		{
			get;
		}

		[IgnoreDataMember]
		Name Name
		{
			get;
		}
	}

	///<summary>Request for PutAlias <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-aliases.html</pre></summary>
	public partial class PutAliasRequest : PlainRequestBase<PutAliasRequestParameters>, IPutAliasRequest
	{
		protected IPutAliasRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"{index}/_alias/{name}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/{index}/_alias/{name}</summary>
		///<param name = "index">this parameter is required</param>
		///<param name = "name">this parameter is required</param>
		public PutAliasRequest(Indices index, Name name): base(r => r.Required("index", index).Required("name", name))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal PutAliasRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Indices IPutAliasRequest.Index => Self.RouteValues.Get<Indices>("index");
		[IgnoreDataMember]
		Name IPutAliasRequest.Name => Self.RouteValues.Get<Name>("name");
		// Request parameters
		///<summary>Specify timeout for connection to master</summary>
		public Time MasterTimeout
		{
			get => Q<Time>("master_timeout");
			set => Q("master_timeout", value);
		}

		///<summary>Explicit timestamp for the document</summary>
		public Time Timeout
		{
			get => Q<Time>("timeout");
			set => Q("timeout", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IPutMappingRequest : IRequest<PutMappingRequestParameters>
	{
		[IgnoreDataMember]
		Indices Index
		{
			get;
		}
	}

	public partial interface IPutMappingRequest<T> : IPutMappingRequest
	{
	}

	///<summary>Request for PutMapping <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-put-mapping.html</pre></summary>
	public partial class PutMappingRequest : PlainRequestBase<PutMappingRequestParameters>, IPutMappingRequest
	{
		protected IPutMappingRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"{index}/_mapping"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/{index}/_mapping</summary>
		///<param name = "index">this parameter is required</param>
		public PutMappingRequest(Indices index): base(r => r.Required("index", index))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal PutMappingRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Indices IPutMappingRequest.Index => Self.RouteValues.Get<Indices>("index");
		// Request parameters
		///<summary>
		/// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have
		/// been specified)
		///</summary>
		public bool? AllowNoIndices
		{
			get => Q<bool? >("allow_no_indices");
			set => Q("allow_no_indices", value);
		}

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ExpandWildcards? ExpandWildcards
		{
			get => Q<ExpandWildcards? >("expand_wildcards");
			set => Q("expand_wildcards", value);
		}

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public bool? IgnoreUnavailable
		{
			get => Q<bool? >("ignore_unavailable");
			set => Q("ignore_unavailable", value);
		}

		///<summary>Whether a type should be expected in the body of the mappings.</summary>
		public bool? IncludeTypeName
		{
			get => Q<bool? >("include_type_name");
			set => Q("include_type_name", value);
		}

		///<summary>Specify timeout for connection to master</summary>
		public Time MasterTimeout
		{
			get => Q<Time>("master_timeout");
			set => Q("master_timeout", value);
		}

		///<summary>Explicit operation timeout</summary>
		public Time Timeout
		{
			get => Q<Time>("timeout");
			set => Q("timeout", value);
		}
	}

	public partial class PutMappingRequest<T> : PutMappingRequest, IPutMappingRequest<T>
	{
		protected IPutMappingRequest<T> TypedSelf => this;
		///<summary>/{index}/_mapping</summary>
		///<param name = "index">this parameter is required</param>
		public PutMappingRequest(Indices index): base(index)
		{
		}

		///<summary>/{index}/_mapping</summary>
		public PutMappingRequest(): base(typeof(T))
		{
		}
	}

	[InterfaceDataContract]
	public partial interface IUpdateIndexSettingsRequest : IRequest<UpdateIndexSettingsRequestParameters>
	{
		[IgnoreDataMember]
		Indices Index
		{
			get;
		}
	}

	///<summary>Request for UpdateIndexSettings <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-update-settings.html</pre></summary>
	public partial class UpdateIndexSettingsRequest : PlainRequestBase<UpdateIndexSettingsRequestParameters>, IUpdateIndexSettingsRequest
	{
		protected IUpdateIndexSettingsRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_settings", "{index}/_settings"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_settings</summary>
		public UpdateIndexSettingsRequest(): base()
		{
		}

		///<summary>/{index}/_settings</summary>
		///<param name = "index">Optional, accepts null</param>
		public UpdateIndexSettingsRequest(Indices index): base(r => r.Optional("index", index))
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Indices IUpdateIndexSettingsRequest.Index => Self.RouteValues.Get<Indices>("index");
		// Request parameters
		///<summary>
		/// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have
		/// been specified)
		///</summary>
		public bool? AllowNoIndices
		{
			get => Q<bool? >("allow_no_indices");
			set => Q("allow_no_indices", value);
		}

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ExpandWildcards? ExpandWildcards
		{
			get => Q<ExpandWildcards? >("expand_wildcards");
			set => Q("expand_wildcards", value);
		}

		///<summary>Return settings in flat format (default: false)</summary>
		public bool? FlatSettings
		{
			get => Q<bool? >("flat_settings");
			set => Q("flat_settings", value);
		}

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public bool? IgnoreUnavailable
		{
			get => Q<bool? >("ignore_unavailable");
			set => Q("ignore_unavailable", value);
		}

		///<summary>Specify timeout for connection to master</summary>
		public Time MasterTimeout
		{
			get => Q<Time>("master_timeout");
			set => Q("master_timeout", value);
		}

		///<summary>Whether to update existing settings. If set to `true` existing settings on an index remain unchanged, the default is `false`</summary>
		public bool? PreserveExisting
		{
			get => Q<bool? >("preserve_existing");
			set => Q("preserve_existing", value);
		}

		///<summary>Explicit operation timeout</summary>
		public Time Timeout
		{
			get => Q<Time>("timeout");
			set => Q("timeout", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IPutIndexTemplateRequest : IRequest<PutIndexTemplateRequestParameters>
	{
		[IgnoreDataMember]
		Name Name
		{
			get;
		}
	}

	///<summary>Request for PutIndexTemplate <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-templates.html</pre></summary>
	public partial class PutIndexTemplateRequest : PlainRequestBase<PutIndexTemplateRequestParameters>, IPutIndexTemplateRequest
	{
		protected IPutIndexTemplateRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_template/{name}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_template/{name}</summary>
		///<param name = "name">this parameter is required</param>
		public PutIndexTemplateRequest(Name name): base(r => r.Required("name", name))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal PutIndexTemplateRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Name IPutIndexTemplateRequest.Name => Self.RouteValues.Get<Name>("name");
		// Request parameters
		///<summary>Whether the index template should only be added if new or can also replace an existing one</summary>
		public bool? Create
		{
			get => Q<bool? >("create");
			set => Q("create", value);
		}

		///<summary>Return settings in flat format (default: false)</summary>
		public bool? FlatSettings
		{
			get => Q<bool? >("flat_settings");
			set => Q("flat_settings", value);
		}

		///<summary>Whether a type should be returned in the body of the mappings.</summary>
		public bool? IncludeTypeName
		{
			get => Q<bool? >("include_type_name");
			set => Q("include_type_name", value);
		}

		///<summary>Specify timeout for connection to master</summary>
		public Time MasterTimeout
		{
			get => Q<Time>("master_timeout");
			set => Q("master_timeout", value);
		}

		///<summary>Explicit operation timeout</summary>
		public Time Timeout
		{
			get => Q<Time>("timeout");
			set => Q("timeout", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IRecoveryStatusRequest : IRequest<RecoveryStatusRequestParameters>
	{
		[IgnoreDataMember]
		Indices Index
		{
			get;
		}
	}

	///<summary>Request for RecoveryStatus <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-recovery.html</pre></summary>
	public partial class RecoveryStatusRequest : PlainRequestBase<RecoveryStatusRequestParameters>, IRecoveryStatusRequest
	{
		protected IRecoveryStatusRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_recovery", "{index}/_recovery"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_recovery</summary>
		public RecoveryStatusRequest(): base()
		{
		}

		///<summary>/{index}/_recovery</summary>
		///<param name = "index">Optional, accepts null</param>
		public RecoveryStatusRequest(Indices index): base(r => r.Optional("index", index))
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Indices IRecoveryStatusRequest.Index => Self.RouteValues.Get<Indices>("index");
		// Request parameters
		///<summary>Display only those recoveries that are currently on-going</summary>
		public bool? ActiveOnly
		{
			get => Q<bool? >("active_only");
			set => Q("active_only", value);
		}

		///<summary>Whether to display detailed information about shard recovery</summary>
		public bool? Detailed
		{
			get => Q<bool? >("detailed");
			set => Q("detailed", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IRefreshRequest : IRequest<RefreshRequestParameters>
	{
		[IgnoreDataMember]
		Indices Index
		{
			get;
		}
	}

	///<summary>Request for Refresh <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-refresh.html</pre></summary>
	public partial class RefreshRequest : PlainRequestBase<RefreshRequestParameters>, IRefreshRequest
	{
		protected IRefreshRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_refresh", "{index}/_refresh"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_refresh</summary>
		public RefreshRequest(): base()
		{
		}

		///<summary>/{index}/_refresh</summary>
		///<param name = "index">Optional, accepts null</param>
		public RefreshRequest(Indices index): base(r => r.Optional("index", index))
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Indices IRefreshRequest.Index => Self.RouteValues.Get<Indices>("index");
		// Request parameters
		///<summary>
		/// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have
		/// been specified)
		///</summary>
		public bool? AllowNoIndices
		{
			get => Q<bool? >("allow_no_indices");
			set => Q("allow_no_indices", value);
		}

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ExpandWildcards? ExpandWildcards
		{
			get => Q<ExpandWildcards? >("expand_wildcards");
			set => Q("expand_wildcards", value);
		}

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public bool? IgnoreUnavailable
		{
			get => Q<bool? >("ignore_unavailable");
			set => Q("ignore_unavailable", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IRolloverIndexRequest : IRequest<RolloverIndexRequestParameters>
	{
		[IgnoreDataMember]
		Name Alias
		{
			get;
		}

		[IgnoreDataMember]
		IndexName NewIndex
		{
			get;
		}
	}

	///<summary>Request for RolloverIndex <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-rollover-index.html</pre></summary>
	public partial class RolloverIndexRequest : PlainRequestBase<RolloverIndexRequestParameters>, IRolloverIndexRequest
	{
		protected IRolloverIndexRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"{alias}/_rollover", "{alias}/_rollover/{new_index}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/{alias}/_rollover</summary>
		///<param name = "alias">this parameter is required</param>
		public RolloverIndexRequest(Name alias): base(r => r.Required("alias", alias))
		{
		}

		///<summary>/{alias}/_rollover/{new_index}</summary>
		///<param name = "alias">this parameter is required</param>
		///<param name = "new_index">Optional, accepts null</param>
		public RolloverIndexRequest(Name alias, IndexName new_index): base(r => r.Required("alias", alias).Optional("new_index", new_index))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal RolloverIndexRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Name IRolloverIndexRequest.Alias => Self.RouteValues.Get<Name>("alias");
		[IgnoreDataMember]
		IndexName IRolloverIndexRequest.NewIndex => Self.RouteValues.Get<IndexName>("new_index");
		// Request parameters
		///<summary>If set to true the rollover action will only be validated but not actually performed even if a condition matches. The default is false</summary>
		public bool? DryRun
		{
			get => Q<bool? >("dry_run");
			set => Q("dry_run", value);
		}

		///<summary>Whether a type should be included in the body of the mappings.</summary>
		public bool? IncludeTypeName
		{
			get => Q<bool? >("include_type_name");
			set => Q("include_type_name", value);
		}

		///<summary>Specify timeout for connection to master</summary>
		public Time MasterTimeout
		{
			get => Q<Time>("master_timeout");
			set => Q("master_timeout", value);
		}

		///<summary>Explicit operation timeout</summary>
		public Time Timeout
		{
			get => Q<Time>("timeout");
			set => Q("timeout", value);
		}

		///<summary>Set the number of active shards to wait for on the newly created rollover index before the operation returns.</summary>
		public string WaitForActiveShards
		{
			get => Q<string>("wait_for_active_shards");
			set => Q("wait_for_active_shards", value);
		}
	}

	[InterfaceDataContract]
	public partial interface ISegmentsRequest : IRequest<SegmentsRequestParameters>
	{
		[IgnoreDataMember]
		Indices Index
		{
			get;
		}
	}

	///<summary>Request for Segments <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-segments.html</pre></summary>
	public partial class SegmentsRequest : PlainRequestBase<SegmentsRequestParameters>, ISegmentsRequest
	{
		protected ISegmentsRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_segments", "{index}/_segments"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_segments</summary>
		public SegmentsRequest(): base()
		{
		}

		///<summary>/{index}/_segments</summary>
		///<param name = "index">Optional, accepts null</param>
		public SegmentsRequest(Indices index): base(r => r.Optional("index", index))
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Indices ISegmentsRequest.Index => Self.RouteValues.Get<Indices>("index");
		// Request parameters
		///<summary>
		/// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have
		/// been specified)
		///</summary>
		public bool? AllowNoIndices
		{
			get => Q<bool? >("allow_no_indices");
			set => Q("allow_no_indices", value);
		}

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ExpandWildcards? ExpandWildcards
		{
			get => Q<ExpandWildcards? >("expand_wildcards");
			set => Q("expand_wildcards", value);
		}

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public bool? IgnoreUnavailable
		{
			get => Q<bool? >("ignore_unavailable");
			set => Q("ignore_unavailable", value);
		}

		///<summary>Includes detailed memory usage by Lucene.</summary>
		public bool? Verbose
		{
			get => Q<bool? >("verbose");
			set => Q("verbose", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IIndicesShardStoresRequest : IRequest<IndicesShardStoresRequestParameters>
	{
		[IgnoreDataMember]
		Indices Index
		{
			get;
		}
	}

	///<summary>Request for ShardStores <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-shards-stores.html</pre></summary>
	public partial class IndicesShardStoresRequest : PlainRequestBase<IndicesShardStoresRequestParameters>, IIndicesShardStoresRequest
	{
		protected IIndicesShardStoresRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_shard_stores", "{index}/_shard_stores"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_shard_stores</summary>
		public IndicesShardStoresRequest(): base()
		{
		}

		///<summary>/{index}/_shard_stores</summary>
		///<param name = "index">Optional, accepts null</param>
		public IndicesShardStoresRequest(Indices index): base(r => r.Optional("index", index))
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Indices IIndicesShardStoresRequest.Index => Self.RouteValues.Get<Indices>("index");
		// Request parameters
		///<summary>
		/// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have
		/// been specified)
		///</summary>
		public bool? AllowNoIndices
		{
			get => Q<bool? >("allow_no_indices");
			set => Q("allow_no_indices", value);
		}

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ExpandWildcards? ExpandWildcards
		{
			get => Q<ExpandWildcards? >("expand_wildcards");
			set => Q("expand_wildcards", value);
		}

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public bool? IgnoreUnavailable
		{
			get => Q<bool? >("ignore_unavailable");
			set => Q("ignore_unavailable", value);
		}

		///<summary>A comma-separated list of statuses used to filter on shards to get store information for</summary>
		public string[] Status
		{
			get => Q<string[]>("status");
			set => Q("status", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IShrinkIndexRequest : IRequest<ShrinkIndexRequestParameters>
	{
		[IgnoreDataMember]
		IndexName Index
		{
			get;
		}

		[IgnoreDataMember]
		IndexName Target
		{
			get;
		}
	}

	///<summary>Request for ShrinkIndex <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-shrink-index.html</pre></summary>
	public partial class ShrinkIndexRequest : PlainRequestBase<ShrinkIndexRequestParameters>, IShrinkIndexRequest
	{
		protected IShrinkIndexRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"{index}/_shrink/{target}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/{index}/_shrink/{target}</summary>
		///<param name = "index">this parameter is required</param>
		///<param name = "target">this parameter is required</param>
		public ShrinkIndexRequest(IndexName index, IndexName target): base(r => r.Required("index", index).Required("target", target))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal ShrinkIndexRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		IndexName IShrinkIndexRequest.Index => Self.RouteValues.Get<IndexName>("index");
		[IgnoreDataMember]
		IndexName IShrinkIndexRequest.Target => Self.RouteValues.Get<IndexName>("target");
		// Request parameters
		///<summary>Specify timeout for connection to master</summary>
		public Time MasterTimeout
		{
			get => Q<Time>("master_timeout");
			set => Q("master_timeout", value);
		}

		///<summary>Explicit operation timeout</summary>
		public Time Timeout
		{
			get => Q<Time>("timeout");
			set => Q("timeout", value);
		}

		///<summary>Set the number of active shards to wait for on the shrunken index before the operation returns.</summary>
		public string WaitForActiveShards
		{
			get => Q<string>("wait_for_active_shards");
			set => Q("wait_for_active_shards", value);
		}
	}

	[InterfaceDataContract]
	public partial interface ISplitIndexRequest : IRequest<SplitIndexRequestParameters>
	{
		[IgnoreDataMember]
		IndexName Index
		{
			get;
		}

		[IgnoreDataMember]
		IndexName Target
		{
			get;
		}
	}

	///<summary>Request for SplitIndex <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-split-index.html</pre></summary>
	public partial class SplitIndexRequest : PlainRequestBase<SplitIndexRequestParameters>, ISplitIndexRequest
	{
		protected ISplitIndexRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"{index}/_split/{target}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/{index}/_split/{target}</summary>
		///<param name = "index">this parameter is required</param>
		///<param name = "target">this parameter is required</param>
		public SplitIndexRequest(IndexName index, IndexName target): base(r => r.Required("index", index).Required("target", target))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal SplitIndexRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		IndexName ISplitIndexRequest.Index => Self.RouteValues.Get<IndexName>("index");
		[IgnoreDataMember]
		IndexName ISplitIndexRequest.Target => Self.RouteValues.Get<IndexName>("target");
		// Request parameters
		///<summary>Specify timeout for connection to master</summary>
		public Time MasterTimeout
		{
			get => Q<Time>("master_timeout");
			set => Q("master_timeout", value);
		}

		///<summary>Explicit operation timeout</summary>
		public Time Timeout
		{
			get => Q<Time>("timeout");
			set => Q("timeout", value);
		}

		///<summary>Set the number of active shards to wait for on the shrunken index before the operation returns.</summary>
		public string WaitForActiveShards
		{
			get => Q<string>("wait_for_active_shards");
			set => Q("wait_for_active_shards", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IIndicesStatsRequest : IRequest<IndicesStatsRequestParameters>
	{
		[IgnoreDataMember]
		Metrics Metric
		{
			get;
		}

		[IgnoreDataMember]
		Indices Index
		{
			get;
		}
	}

	///<summary>Request for Stats <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-stats.html</pre></summary>
	public partial class IndicesStatsRequest : PlainRequestBase<IndicesStatsRequestParameters>, IIndicesStatsRequest
	{
		protected IIndicesStatsRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_stats", "_stats/{metric}", "{index}/_stats", "{index}/_stats/{metric}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_stats</summary>
		public IndicesStatsRequest(): base()
		{
		}

		///<summary>/_stats/{metric}</summary>
		///<param name = "metric">Optional, accepts null</param>
		public IndicesStatsRequest(Metrics metric): base(r => r.Optional("metric", metric))
		{
		}

		///<summary>/{index}/_stats</summary>
		///<param name = "index">Optional, accepts null</param>
		public IndicesStatsRequest(Indices index): base(r => r.Optional("index", index))
		{
		}

		///<summary>/{index}/_stats/{metric}</summary>
		///<param name = "index">Optional, accepts null</param>
		///<param name = "metric">Optional, accepts null</param>
		public IndicesStatsRequest(Indices index, Metrics metric): base(r => r.Optional("index", index).Optional("metric", metric))
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Metrics IIndicesStatsRequest.Metric => Self.RouteValues.Get<Metrics>("metric");
		[IgnoreDataMember]
		Indices IIndicesStatsRequest.Index => Self.RouteValues.Get<Indices>("index");
		// Request parameters
		///<summary>A comma-separated list of fields for `fielddata` and `suggest` index metric (supports wildcards)</summary>
		public Fields CompletionFields
		{
			get => Q<Fields>("completion_fields");
			set => Q("completion_fields", value);
		}

		///<summary>A comma-separated list of fields for `fielddata` index metric (supports wildcards)</summary>
		public Fields FielddataFields
		{
			get => Q<Fields>("fielddata_fields");
			set => Q("fielddata_fields", value);
		}

		///<summary>A comma-separated list of fields for `fielddata` and `completion` index metric (supports wildcards)</summary>
		public Fields Fields
		{
			get => Q<Fields>("fields");
			set => Q("fields", value);
		}

		///<summary>A comma-separated list of search groups for `search` index metric</summary>
		public string[] Groups
		{
			get => Q<string[]>("groups");
			set => Q("groups", value);
		}

		///<summary>Whether to report the aggregated disk usage of each one of the Lucene index files (only applies if segment stats are requested)</summary>
		public bool? IncludeSegmentFileSizes
		{
			get => Q<bool? >("include_segment_file_sizes");
			set => Q("include_segment_file_sizes", value);
		}

		///<summary>Return stats aggregated at cluster, index or shard level</summary>
		public Level? Level
		{
			get => Q<Level? >("level");
			set => Q("level", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IBulkAliasRequest : IRequest<BulkAliasRequestParameters>
	{
	}

	///<summary>Request for BulkAlias <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-aliases.html</pre></summary>
	public partial class BulkAliasRequest : PlainRequestBase<BulkAliasRequestParameters>, IBulkAliasRequest
	{
		protected IBulkAliasRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_aliases"});
		internal override ApiUrls ApiUrls => Urls;
		// values part of the url path
		// Request parameters
		///<summary>Specify timeout for connection to master</summary>
		public Time MasterTimeout
		{
			get => Q<Time>("master_timeout");
			set => Q("master_timeout", value);
		}

		///<summary>Request timeout</summary>
		public Time Timeout
		{
			get => Q<Time>("timeout");
			set => Q("timeout", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IUpgradeRequest : IRequest<UpgradeRequestParameters>
	{
		[IgnoreDataMember]
		Indices Index
		{
			get;
		}
	}

	///<summary>Request for Upgrade <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-upgrade.html</pre></summary>
	public partial class UpgradeRequest : PlainRequestBase<UpgradeRequestParameters>, IUpgradeRequest
	{
		protected IUpgradeRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_upgrade", "{index}/_upgrade"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_upgrade</summary>
		public UpgradeRequest(): base()
		{
		}

		///<summary>/{index}/_upgrade</summary>
		///<param name = "index">Optional, accepts null</param>
		public UpgradeRequest(Indices index): base(r => r.Optional("index", index))
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Indices IUpgradeRequest.Index => Self.RouteValues.Get<Indices>("index");
		// Request parameters
		///<summary>
		/// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have
		/// been specified)
		///</summary>
		public bool? AllowNoIndices
		{
			get => Q<bool? >("allow_no_indices");
			set => Q("allow_no_indices", value);
		}

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ExpandWildcards? ExpandWildcards
		{
			get => Q<ExpandWildcards? >("expand_wildcards");
			set => Q("expand_wildcards", value);
		}

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public bool? IgnoreUnavailable
		{
			get => Q<bool? >("ignore_unavailable");
			set => Q("ignore_unavailable", value);
		}

		///<summary>If true, only ancient (an older Lucene major release) segments will be upgraded</summary>
		public bool? OnlyAncientSegments
		{
			get => Q<bool? >("only_ancient_segments");
			set => Q("only_ancient_segments", value);
		}

		///<summary>Specify whether the request should block until the all segments are upgraded (default: false)</summary>
		public bool? WaitForCompletion
		{
			get => Q<bool? >("wait_for_completion");
			set => Q("wait_for_completion", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IValidateQueryRequest : IRequest<ValidateQueryRequestParameters>
	{
		[IgnoreDataMember]
		Indices Index
		{
			get;
		}
	}

	public partial interface IValidateQueryRequest<T> : IValidateQueryRequest
	{
	}

	///<summary>Request for ValidateQuery <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/search-validate.html</pre></summary>
	public partial class ValidateQueryRequest : PlainRequestBase<ValidateQueryRequestParameters>, IValidateQueryRequest
	{
		protected IValidateQueryRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_validate/query", "{index}/_validate/query"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_validate/query</summary>
		public ValidateQueryRequest(): base()
		{
		}

		///<summary>/{index}/_validate/query</summary>
		///<param name = "index">Optional, accepts null</param>
		public ValidateQueryRequest(Indices index): base(r => r.Optional("index", index))
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Indices IValidateQueryRequest.Index => Self.RouteValues.Get<Indices>("index");
		// Request parameters
		///<summary>Execute validation on all shards instead of one random shard per index</summary>
		public bool? AllShards
		{
			get => Q<bool? >("all_shards");
			set => Q("all_shards", value);
		}

		///<summary>
		/// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have
		/// been specified)
		///</summary>
		public bool? AllowNoIndices
		{
			get => Q<bool? >("allow_no_indices");
			set => Q("allow_no_indices", value);
		}

		///<summary>Specify whether wildcard and prefix queries should be analyzed (default: false)</summary>
		public bool? AnalyzeWildcard
		{
			get => Q<bool? >("analyze_wildcard");
			set => Q("analyze_wildcard", value);
		}

		///<summary>The analyzer to use for the query string</summary>
		public string Analyzer
		{
			get => Q<string>("analyzer");
			set => Q("analyzer", value);
		}

		///<summary>The default operator for query string query (AND or OR)</summary>
		public DefaultOperator? DefaultOperator
		{
			get => Q<DefaultOperator? >("default_operator");
			set => Q("default_operator", value);
		}

		///<summary>The field to use as default where no field prefix is given in the query string</summary>
		public string Df
		{
			get => Q<string>("df");
			set => Q("df", value);
		}

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ExpandWildcards? ExpandWildcards
		{
			get => Q<ExpandWildcards? >("expand_wildcards");
			set => Q("expand_wildcards", value);
		}

		///<summary>Return detailed information about the error</summary>
		public bool? Explain
		{
			get => Q<bool? >("explain");
			set => Q("explain", value);
		}

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public bool? IgnoreUnavailable
		{
			get => Q<bool? >("ignore_unavailable");
			set => Q("ignore_unavailable", value);
		}

		///<summary>Specify whether format-based query failures (such as providing text to a numeric field) should be ignored</summary>
		public bool? Lenient
		{
			get => Q<bool? >("lenient");
			set => Q("lenient", value);
		}

		///<summary>Query in the Lucene query string syntax</summary>
		public string QueryOnQueryString
		{
			get => Q<string>("q");
			set => Q("q", value);
		}

		///<summary>Provide a more detailed explanation showing the actual Lucene query that will be executed.</summary>
		public bool? Rewrite
		{
			get => Q<bool? >("rewrite");
			set => Q("rewrite", value);
		}
	}

	public partial class ValidateQueryRequest<T> : ValidateQueryRequest, IValidateQueryRequest<T>
	{
		protected IValidateQueryRequest<T> TypedSelf => this;
		///<summary>/{index}/_validate/query</summary>
		public ValidateQueryRequest(): base(typeof(T))
		{
		}

		///<summary>/{index}/_validate/query</summary>
		///<param name = "index">Optional, accepts null</param>
		public ValidateQueryRequest(Indices index): base(index)
		{
		}
	}

	[InterfaceDataContract]
	public partial interface IRootNodeInfoRequest : IRequest<RootNodeInfoRequestParameters>
	{
	}

	///<summary>Request for RootNodeInfo <pre>http://www.elastic.co/guide/</pre></summary>
	public partial class RootNodeInfoRequest : PlainRequestBase<RootNodeInfoRequestParameters>, IRootNodeInfoRequest
	{
		protected IRootNodeInfoRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{""});
		internal override ApiUrls ApiUrls => Urls;
	// values part of the url path
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IDeletePipelineRequest : IRequest<DeletePipelineRequestParameters>
	{
		[IgnoreDataMember]
		Id Id
		{
			get;
		}
	}

	///<summary>Request for DeletePipeline <pre>https://www.elastic.co/guide/en/elasticsearch/plugins/master/ingest.html</pre></summary>
	public partial class DeletePipelineRequest : PlainRequestBase<DeletePipelineRequestParameters>, IDeletePipelineRequest
	{
		protected IDeletePipelineRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_ingest/pipeline/{id}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_ingest/pipeline/{id}</summary>
		///<param name = "id">this parameter is required</param>
		public DeletePipelineRequest(Id id): base(r => r.Required("id", id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal DeletePipelineRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Id IDeletePipelineRequest.Id => Self.RouteValues.Get<Id>("id");
		// Request parameters
		///<summary>Explicit operation timeout for connection to master node</summary>
		public Time MasterTimeout
		{
			get => Q<Time>("master_timeout");
			set => Q("master_timeout", value);
		}

		///<summary>Explicit operation timeout</summary>
		public Time Timeout
		{
			get => Q<Time>("timeout");
			set => Q("timeout", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IGetPipelineRequest : IRequest<GetPipelineRequestParameters>
	{
		[IgnoreDataMember]
		Id Id
		{
			get;
		}
	}

	///<summary>Request for GetPipeline <pre>https://www.elastic.co/guide/en/elasticsearch/plugins/master/ingest.html</pre></summary>
	public partial class GetPipelineRequest : PlainRequestBase<GetPipelineRequestParameters>, IGetPipelineRequest
	{
		protected IGetPipelineRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_ingest/pipeline", "_ingest/pipeline/{id}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_ingest/pipeline</summary>
		public GetPipelineRequest(): base()
		{
		}

		///<summary>/_ingest/pipeline/{id}</summary>
		///<param name = "id">Optional, accepts null</param>
		public GetPipelineRequest(Id id): base(r => r.Optional("id", id))
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Id IGetPipelineRequest.Id => Self.RouteValues.Get<Id>("id");
		// Request parameters
		///<summary>Explicit operation timeout for connection to master node</summary>
		public Time MasterTimeout
		{
			get => Q<Time>("master_timeout");
			set => Q("master_timeout", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IGrokProcessorPatternsRequest : IRequest<GrokProcessorPatternsRequestParameters>
	{
	}

	///<summary>Request for GrokProcessorPatterns <pre>https://www.elastic.co/guide/en/elasticsearch/plugins/master/ingest.html</pre></summary>
	public partial class GrokProcessorPatternsRequest : PlainRequestBase<GrokProcessorPatternsRequestParameters>, IGrokProcessorPatternsRequest
	{
		protected IGrokProcessorPatternsRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_ingest/processor/grok"});
		internal override ApiUrls ApiUrls => Urls;
	// values part of the url path
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IPutPipelineRequest : IRequest<PutPipelineRequestParameters>
	{
		[IgnoreDataMember]
		Id Id
		{
			get;
		}
	}

	///<summary>Request for PutPipeline <pre>https://www.elastic.co/guide/en/elasticsearch/plugins/master/ingest.html</pre></summary>
	public partial class PutPipelineRequest : PlainRequestBase<PutPipelineRequestParameters>, IPutPipelineRequest
	{
		protected IPutPipelineRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_ingest/pipeline/{id}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_ingest/pipeline/{id}</summary>
		///<param name = "id">this parameter is required</param>
		public PutPipelineRequest(Id id): base(r => r.Required("id", id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal PutPipelineRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Id IPutPipelineRequest.Id => Self.RouteValues.Get<Id>("id");
		// Request parameters
		///<summary>Explicit operation timeout for connection to master node</summary>
		public Time MasterTimeout
		{
			get => Q<Time>("master_timeout");
			set => Q("master_timeout", value);
		}

		///<summary>Explicit operation timeout</summary>
		public Time Timeout
		{
			get => Q<Time>("timeout");
			set => Q("timeout", value);
		}
	}

	[InterfaceDataContract]
	public partial interface ISimulatePipelineRequest : IRequest<SimulatePipelineRequestParameters>
	{
		[IgnoreDataMember]
		Id Id
		{
			get;
		}
	}

	///<summary>Request for SimulatePipeline <pre>https://www.elastic.co/guide/en/elasticsearch/plugins/master/ingest.html</pre></summary>
	public partial class SimulatePipelineRequest : PlainRequestBase<SimulatePipelineRequestParameters>, ISimulatePipelineRequest
	{
		protected ISimulatePipelineRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_ingest/pipeline/_simulate", "_ingest/pipeline/{id}/_simulate"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_ingest/pipeline/_simulate</summary>
		public SimulatePipelineRequest(): base()
		{
		}

		///<summary>/_ingest/pipeline/{id}/_simulate</summary>
		///<param name = "id">Optional, accepts null</param>
		public SimulatePipelineRequest(Id id): base(r => r.Optional("id", id))
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Id ISimulatePipelineRequest.Id => Self.RouteValues.Get<Id>("id");
		// Request parameters
		///<summary>Verbose mode. Display data output for each processor in executed pipeline</summary>
		public bool? Verbose
		{
			get => Q<bool? >("verbose");
			set => Q("verbose", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IDeleteLicenseRequest : IRequest<DeleteLicenseRequestParameters>
	{
	}

	///<summary>Request for DeleteLicense <pre>https://www.elastic.co/guide/en/x-pack/current/license-management.html</pre></summary>
	public partial class DeleteLicenseRequest : PlainRequestBase<DeleteLicenseRequestParameters>, IDeleteLicenseRequest
	{
		protected IDeleteLicenseRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_license"});
		internal override ApiUrls ApiUrls => Urls;
	// values part of the url path
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IGetLicenseRequest : IRequest<GetLicenseRequestParameters>
	{
	}

	///<summary>Request for GetLicense <pre>https://www.elastic.co/guide/en/x-pack/current/license-management.html</pre></summary>
	public partial class GetLicenseRequest : PlainRequestBase<GetLicenseRequestParameters>, IGetLicenseRequest
	{
		protected IGetLicenseRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_license"});
		internal override ApiUrls ApiUrls => Urls;
		// values part of the url path
		// Request parameters
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public bool? Local
		{
			get => Q<bool? >("local");
			set => Q("local", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IGetBasicLicenseStatusRequest : IRequest<GetBasicLicenseStatusRequestParameters>
	{
	}

	///<summary>Request for GetBasicLicenseStatus <pre>https://www.elastic.co/guide/en/x-pack/current/license-management.html</pre></summary>
	public partial class GetBasicLicenseStatusRequest : PlainRequestBase<GetBasicLicenseStatusRequestParameters>, IGetBasicLicenseStatusRequest
	{
		protected IGetBasicLicenseStatusRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_license/basic_status"});
		internal override ApiUrls ApiUrls => Urls;
	// values part of the url path
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IGetTrialLicenseStatusRequest : IRequest<GetTrialLicenseStatusRequestParameters>
	{
	}

	///<summary>Request for GetTrialLicenseStatus <pre>https://www.elastic.co/guide/en/x-pack/current/license-management.html</pre></summary>
	public partial class GetTrialLicenseStatusRequest : PlainRequestBase<GetTrialLicenseStatusRequestParameters>, IGetTrialLicenseStatusRequest
	{
		protected IGetTrialLicenseStatusRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_license/trial_status"});
		internal override ApiUrls ApiUrls => Urls;
	// values part of the url path
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IPostLicenseRequest : IRequest<PostLicenseRequestParameters>
	{
	}

	///<summary>Request for PostLicense <pre>https://www.elastic.co/guide/en/x-pack/current/license-management.html</pre></summary>
	public partial class PostLicenseRequest : PlainRequestBase<PostLicenseRequestParameters>, IPostLicenseRequest
	{
		protected IPostLicenseRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_license"});
		internal override ApiUrls ApiUrls => Urls;
		// values part of the url path
		// Request parameters
		///<summary>whether the user has acknowledged acknowledge messages (default: false)</summary>
		public bool? Acknowledge
		{
			get => Q<bool? >("acknowledge");
			set => Q("acknowledge", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IStartBasicLicenseRequest : IRequest<StartBasicLicenseRequestParameters>
	{
	}

	///<summary>Request for StartBasicLicense <pre>https://www.elastic.co/guide/en/x-pack/current/license-management.html</pre></summary>
	public partial class StartBasicLicenseRequest : PlainRequestBase<StartBasicLicenseRequestParameters>, IStartBasicLicenseRequest
	{
		protected IStartBasicLicenseRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_license/start_basic"});
		internal override ApiUrls ApiUrls => Urls;
		// values part of the url path
		// Request parameters
		///<summary>whether the user has acknowledged acknowledge messages (default: false)</summary>
		public bool? Acknowledge
		{
			get => Q<bool? >("acknowledge");
			set => Q("acknowledge", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IStartTrialLicenseRequest : IRequest<StartTrialLicenseRequestParameters>
	{
	}

	///<summary>Request for StartTrialLicense <pre>https://www.elastic.co/guide/en/x-pack/current/license-management.html</pre></summary>
	public partial class StartTrialLicenseRequest : PlainRequestBase<StartTrialLicenseRequestParameters>, IStartTrialLicenseRequest
	{
		protected IStartTrialLicenseRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_license/start_trial"});
		internal override ApiUrls ApiUrls => Urls;
		// values part of the url path
		// Request parameters
		///<summary>whether the user has acknowledged acknowledge messages (default: false)</summary>
		public bool? Acknowledge
		{
			get => Q<bool? >("acknowledge");
			set => Q("acknowledge", value);
		}

		///<summary>The type of trial license to generate (default: "trial")</summary>
		public string TypeQueryString
		{
			get => Q<string>("type");
			set => Q("type", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IMultiGetRequest : IRequest<MultiGetRequestParameters>
	{
		[IgnoreDataMember]
		IndexName Index
		{
			get;
		}

		[DataMember(Name = "stored_fields")]
		Fields StoredFields
		{
			get;
			set;
		}
	}

	///<summary>Request for MultiGet <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-multi-get.html</pre></summary>
	public partial class MultiGetRequest : PlainRequestBase<MultiGetRequestParameters>, IMultiGetRequest
	{
		protected IMultiGetRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_mget", "{index}/_mget"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_mget</summary>
		public MultiGetRequest(): base()
		{
		}

		///<summary>/{index}/_mget</summary>
		///<param name = "index">Optional, accepts null</param>
		public MultiGetRequest(IndexName index): base(r => r.Optional("index", index))
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		IndexName IMultiGetRequest.Index => Self.RouteValues.Get<IndexName>("index");
		// Request parameters
		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public string Preference
		{
			get => Q<string>("preference");
			set => Q("preference", value);
		}

		///<summary>Specify whether to perform the operation in realtime or search mode</summary>
		public bool? Realtime
		{
			get => Q<bool? >("realtime");
			set => Q("realtime", value);
		}

		///<summary>Refresh the shard containing the document before performing the operation</summary>
		public bool? Refresh
		{
			get => Q<bool? >("refresh");
			set => Q("refresh", value);
		}

		///<summary>
		/// A document is routed to a particular shard in an index using the following formula
		/// <para> shard_num = hash(_routing) % num_primary_shards</para>
		/// <para>Elasticsearch will use the document id if not provided. </para>
		/// <para>For requests that are constructed from/for a document NEST will automatically infer the routing key
		/// if that document has a <see cref = "Nest.JoinField"/> or a routing mapping on for its type exists on <see cref = "Nest.ConnectionSettings"
		////></para>
		///</summary>
		public Routing Routing
		{
			get => Q<Routing>("routing");
			set => Q("routing", value);
		}

		///<summary>Whether the _source should be included in the response.</summary>
		public bool? SourceEnabled
		{
			get => Q<bool? >("_source");
			set => Q("_source", value);
		}

		///<summary>A list of fields to exclude from the returned _source field</summary>
		public Fields SourceExcludes
		{
			get => Q<Fields>("_source_excludes");
			set => Q("_source_excludes", value);
		}

		///<summary>A list of fields to extract and return from the _source field</summary>
		public Fields SourceIncludes
		{
			get => Q<Fields>("_source_includes");
			set => Q("_source_includes", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IDeprecationInfoRequest : IRequest<DeprecationInfoRequestParameters>
	{
		[IgnoreDataMember]
		IndexName Index
		{
			get;
		}
	}

	///<summary>Request for DeprecationInfo <pre>http://www.elastic.co/guide/en/migration/current/migration-api-deprecation.html</pre></summary>
	public partial class DeprecationInfoRequest : PlainRequestBase<DeprecationInfoRequestParameters>, IDeprecationInfoRequest
	{
		protected IDeprecationInfoRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_migration/deprecations", "{index}/_migration/deprecations"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_migration/deprecations</summary>
		public DeprecationInfoRequest(): base()
		{
		}

		///<summary>/{index}/_migration/deprecations</summary>
		///<param name = "index">Optional, accepts null</param>
		public DeprecationInfoRequest(IndexName index): base(r => r.Optional("index", index))
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		IndexName IDeprecationInfoRequest.Index => Self.RouteValues.Get<IndexName>("index");
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IMigrationAssistanceRequest : IRequest<MigrationAssistanceRequestParameters>
	{
		[IgnoreDataMember]
		Indices Index
		{
			get;
		}
	}

	///<summary>Request for Assistance <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/migration-api-assistance.html</pre></summary>
	public partial class MigrationAssistanceRequest : PlainRequestBase<MigrationAssistanceRequestParameters>, IMigrationAssistanceRequest
	{
		protected IMigrationAssistanceRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_migration/assistance", "_migration/assistance/{index}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_migration/assistance</summary>
		public MigrationAssistanceRequest(): base()
		{
		}

		///<summary>/_migration/assistance/{index}</summary>
		///<param name = "index">Optional, accepts null</param>
		public MigrationAssistanceRequest(Indices index): base(r => r.Optional("index", index))
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Indices IMigrationAssistanceRequest.Index => Self.RouteValues.Get<Indices>("index");
		// Request parameters
		///<summary>
		/// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have
		/// been specified)
		///</summary>
		public bool? AllowNoIndices
		{
			get => Q<bool? >("allow_no_indices");
			set => Q("allow_no_indices", value);
		}

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ExpandWildcards? ExpandWildcards
		{
			get => Q<ExpandWildcards? >("expand_wildcards");
			set => Q("expand_wildcards", value);
		}

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public bool? IgnoreUnavailable
		{
			get => Q<bool? >("ignore_unavailable");
			set => Q("ignore_unavailable", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IMigrationUpgradeRequest : IRequest<MigrationUpgradeRequestParameters>
	{
		[IgnoreDataMember]
		IndexName Index
		{
			get;
		}
	}

	///<summary>Request for Upgrade <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/migration-api-upgrade.html</pre></summary>
	public partial class MigrationUpgradeRequest : PlainRequestBase<MigrationUpgradeRequestParameters>, IMigrationUpgradeRequest
	{
		protected IMigrationUpgradeRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_migration/upgrade/{index}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_migration/upgrade/{index}</summary>
		///<param name = "index">this parameter is required</param>
		public MigrationUpgradeRequest(IndexName index): base(r => r.Required("index", index))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal MigrationUpgradeRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		IndexName IMigrationUpgradeRequest.Index => Self.RouteValues.Get<IndexName>("index");
		// Request parameters
		///<summary>Should the request block until the upgrade operation is completed</summary>
		public bool? WaitForCompletion
		{
			get => Q<bool? >("wait_for_completion");
			set => Q("wait_for_completion", value);
		}
	}

	[InterfaceDataContract]
	public partial interface ICloseJobRequest : IRequest<CloseJobRequestParameters>
	{
		[IgnoreDataMember]
		Id JobId
		{
			get;
		}
	}

	///<summary>Request for CloseJob <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/ml-close-job.html</pre></summary>
	public partial class CloseJobRequest : PlainRequestBase<CloseJobRequestParameters>, ICloseJobRequest
	{
		protected ICloseJobRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_ml/anomaly_detectors/{job_id}/_close"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_ml/anomaly_detectors/{job_id}/_close</summary>
		///<param name = "job_id">this parameter is required</param>
		public CloseJobRequest(Id job_id): base(r => r.Required("job_id", job_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal CloseJobRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Id ICloseJobRequest.JobId => Self.RouteValues.Get<Id>("job_id");
		// Request parameters
		///<summary>Whether to ignore if a wildcard expression matches no jobs. (This includes `_all` string or when no jobs have been specified)</summary>
		public bool? AllowNoJobs
		{
			get => Q<bool? >("allow_no_jobs");
			set => Q("allow_no_jobs", value);
		}

		///<summary>True if the job should be forcefully closed</summary>
		public bool? Force
		{
			get => Q<bool? >("force");
			set => Q("force", value);
		}

		///<summary>Controls the time to wait until a job has closed. Default to 30 minutes</summary>
		public Time Timeout
		{
			get => Q<Time>("timeout");
			set => Q("timeout", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IDeleteCalendarRequest : IRequest<DeleteCalendarRequestParameters>
	{
		[IgnoreDataMember]
		Id CalendarId
		{
			get;
		}
	}

	///<summary>Request for DeleteCalendar <pre></pre></summary>
	public partial class DeleteCalendarRequest : PlainRequestBase<DeleteCalendarRequestParameters>, IDeleteCalendarRequest
	{
		protected IDeleteCalendarRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_ml/calendars/{calendar_id}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_ml/calendars/{calendar_id}</summary>
		///<param name = "calendar_id">this parameter is required</param>
		public DeleteCalendarRequest(Id calendar_id): base(r => r.Required("calendar_id", calendar_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal DeleteCalendarRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Id IDeleteCalendarRequest.CalendarId => Self.RouteValues.Get<Id>("calendar_id");
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IDeleteCalendarEventRequest : IRequest<DeleteCalendarEventRequestParameters>
	{
		[IgnoreDataMember]
		Id CalendarId
		{
			get;
		}

		[IgnoreDataMember]
		Id EventId
		{
			get;
		}
	}

	///<summary>Request for DeleteCalendarEvent <pre></pre></summary>
	public partial class DeleteCalendarEventRequest : PlainRequestBase<DeleteCalendarEventRequestParameters>, IDeleteCalendarEventRequest
	{
		protected IDeleteCalendarEventRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_ml/calendars/{calendar_id}/events/{event_id}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_ml/calendars/{calendar_id}/events/{event_id}</summary>
		///<param name = "calendar_id">this parameter is required</param>
		///<param name = "event_id">this parameter is required</param>
		public DeleteCalendarEventRequest(Id calendar_id, Id event_id): base(r => r.Required("calendar_id", calendar_id).Required("event_id", event_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal DeleteCalendarEventRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Id IDeleteCalendarEventRequest.CalendarId => Self.RouteValues.Get<Id>("calendar_id");
		[IgnoreDataMember]
		Id IDeleteCalendarEventRequest.EventId => Self.RouteValues.Get<Id>("event_id");
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IDeleteCalendarJobRequest : IRequest<DeleteCalendarJobRequestParameters>
	{
		[IgnoreDataMember]
		Id CalendarId
		{
			get;
		}

		[IgnoreDataMember]
		Id JobId
		{
			get;
		}
	}

	///<summary>Request for DeleteCalendarJob <pre></pre></summary>
	public partial class DeleteCalendarJobRequest : PlainRequestBase<DeleteCalendarJobRequestParameters>, IDeleteCalendarJobRequest
	{
		protected IDeleteCalendarJobRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_ml/calendars/{calendar_id}/jobs/{job_id}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_ml/calendars/{calendar_id}/jobs/{job_id}</summary>
		///<param name = "calendar_id">this parameter is required</param>
		///<param name = "job_id">this parameter is required</param>
		public DeleteCalendarJobRequest(Id calendar_id, Id job_id): base(r => r.Required("calendar_id", calendar_id).Required("job_id", job_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal DeleteCalendarJobRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Id IDeleteCalendarJobRequest.CalendarId => Self.RouteValues.Get<Id>("calendar_id");
		[IgnoreDataMember]
		Id IDeleteCalendarJobRequest.JobId => Self.RouteValues.Get<Id>("job_id");
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IDeleteDatafeedRequest : IRequest<DeleteDatafeedRequestParameters>
	{
		[IgnoreDataMember]
		Id DatafeedId
		{
			get;
		}
	}

	///<summary>Request for DeleteDatafeed <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/ml-delete-datafeed.html</pre></summary>
	public partial class DeleteDatafeedRequest : PlainRequestBase<DeleteDatafeedRequestParameters>, IDeleteDatafeedRequest
	{
		protected IDeleteDatafeedRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_ml/datafeeds/{datafeed_id}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_ml/datafeeds/{datafeed_id}</summary>
		///<param name = "datafeed_id">this parameter is required</param>
		public DeleteDatafeedRequest(Id datafeed_id): base(r => r.Required("datafeed_id", datafeed_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal DeleteDatafeedRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Id IDeleteDatafeedRequest.DatafeedId => Self.RouteValues.Get<Id>("datafeed_id");
		// Request parameters
		///<summary>True if the datafeed should be forcefully deleted</summary>
		public bool? Force
		{
			get => Q<bool? >("force");
			set => Q("force", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IDeleteExpiredDataRequest : IRequest<DeleteExpiredDataRequestParameters>
	{
	}

	///<summary>Request for DeleteExpiredData <pre></pre></summary>
	public partial class DeleteExpiredDataRequest : PlainRequestBase<DeleteExpiredDataRequestParameters>, IDeleteExpiredDataRequest
	{
		protected IDeleteExpiredDataRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_ml/_delete_expired_data"});
		internal override ApiUrls ApiUrls => Urls;
	// values part of the url path
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IDeleteFilterRequest : IRequest<DeleteFilterRequestParameters>
	{
		[IgnoreDataMember]
		Id FilterId
		{
			get;
		}
	}

	///<summary>Request for DeleteFilter <pre></pre></summary>
	public partial class DeleteFilterRequest : PlainRequestBase<DeleteFilterRequestParameters>, IDeleteFilterRequest
	{
		protected IDeleteFilterRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_ml/filters/{filter_id}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_ml/filters/{filter_id}</summary>
		///<param name = "filter_id">this parameter is required</param>
		public DeleteFilterRequest(Id filter_id): base(r => r.Required("filter_id", filter_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal DeleteFilterRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Id IDeleteFilterRequest.FilterId => Self.RouteValues.Get<Id>("filter_id");
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IDeleteForecastRequest : IRequest<DeleteForecastRequestParameters>
	{
		[IgnoreDataMember]
		Id JobId
		{
			get;
		}

		[IgnoreDataMember]
		ForecastIds ForecastId
		{
			get;
		}
	}

	///<summary>Request for DeleteForecast <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/ml-delete-forecast.html</pre></summary>
	public partial class DeleteForecastRequest : PlainRequestBase<DeleteForecastRequestParameters>, IDeleteForecastRequest
	{
		protected IDeleteForecastRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_ml/anomaly_detectors/{job_id}/_forecast/{forecast_id}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_ml/anomaly_detectors/{job_id}/_forecast/{forecast_id}</summary>
		///<param name = "job_id">this parameter is required</param>
		///<param name = "forecast_id">this parameter is required</param>
		public DeleteForecastRequest(Id job_id, ForecastIds forecast_id): base(r => r.Required("job_id", job_id).Required("forecast_id", forecast_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal DeleteForecastRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Id IDeleteForecastRequest.JobId => Self.RouteValues.Get<Id>("job_id");
		[IgnoreDataMember]
		ForecastIds IDeleteForecastRequest.ForecastId => Self.RouteValues.Get<ForecastIds>("forecast_id");
		// Request parameters
		///<summary>Whether to ignore if `_all` matches no forecasts</summary>
		public bool? AllowNoForecasts
		{
			get => Q<bool? >("allow_no_forecasts");
			set => Q("allow_no_forecasts", value);
		}

		///<summary>Controls the time to wait until the forecast(s) are deleted. Default to 30 seconds</summary>
		public Time Timeout
		{
			get => Q<Time>("timeout");
			set => Q("timeout", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IDeleteJobRequest : IRequest<DeleteJobRequestParameters>
	{
		[IgnoreDataMember]
		Id JobId
		{
			get;
		}
	}

	///<summary>Request for DeleteJob <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/ml-delete-job.html</pre></summary>
	public partial class DeleteJobRequest : PlainRequestBase<DeleteJobRequestParameters>, IDeleteJobRequest
	{
		protected IDeleteJobRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_ml/anomaly_detectors/{job_id}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_ml/anomaly_detectors/{job_id}</summary>
		///<param name = "job_id">this parameter is required</param>
		public DeleteJobRequest(Id job_id): base(r => r.Required("job_id", job_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal DeleteJobRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Id IDeleteJobRequest.JobId => Self.RouteValues.Get<Id>("job_id");
		// Request parameters
		///<summary>True if the job should be forcefully deleted</summary>
		public bool? Force
		{
			get => Q<bool? >("force");
			set => Q("force", value);
		}

		///<summary>Should this request wait until the operation has completed before returning</summary>
		public bool? WaitForCompletion
		{
			get => Q<bool? >("wait_for_completion");
			set => Q("wait_for_completion", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IDeleteModelSnapshotRequest : IRequest<DeleteModelSnapshotRequestParameters>
	{
		[IgnoreDataMember]
		Id JobId
		{
			get;
		}

		[IgnoreDataMember]
		Id SnapshotId
		{
			get;
		}
	}

	///<summary>Request for DeleteModelSnapshot <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/ml-delete-snapshot.html</pre></summary>
	public partial class DeleteModelSnapshotRequest : PlainRequestBase<DeleteModelSnapshotRequestParameters>, IDeleteModelSnapshotRequest
	{
		protected IDeleteModelSnapshotRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_ml/anomaly_detectors/{job_id}/model_snapshots/{snapshot_id}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_ml/anomaly_detectors/{job_id}/model_snapshots/{snapshot_id}</summary>
		///<param name = "job_id">this parameter is required</param>
		///<param name = "snapshot_id">this parameter is required</param>
		public DeleteModelSnapshotRequest(Id job_id, Id snapshot_id): base(r => r.Required("job_id", job_id).Required("snapshot_id", snapshot_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal DeleteModelSnapshotRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Id IDeleteModelSnapshotRequest.JobId => Self.RouteValues.Get<Id>("job_id");
		[IgnoreDataMember]
		Id IDeleteModelSnapshotRequest.SnapshotId => Self.RouteValues.Get<Id>("snapshot_id");
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IFlushJobRequest : IRequest<FlushJobRequestParameters>
	{
		[IgnoreDataMember]
		Id JobId
		{
			get;
		}
	}

	///<summary>Request for FlushJob <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/ml-flush-job.html</pre></summary>
	public partial class FlushJobRequest : PlainRequestBase<FlushJobRequestParameters>, IFlushJobRequest
	{
		protected IFlushJobRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_ml/anomaly_detectors/{job_id}/_flush"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_ml/anomaly_detectors/{job_id}/_flush</summary>
		///<param name = "job_id">this parameter is required</param>
		public FlushJobRequest(Id job_id): base(r => r.Required("job_id", job_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal FlushJobRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Id IFlushJobRequest.JobId => Self.RouteValues.Get<Id>("job_id");
		// Request parameters
		///<summary>Skips time to the given value without generating results or updating the model for the skipped interval</summary>
		public string SkipTime
		{
			get => Q<string>("skip_time");
			set => Q("skip_time", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IForecastJobRequest : IRequest<ForecastJobRequestParameters>
	{
		[IgnoreDataMember]
		Id JobId
		{
			get;
		}
	}

	///<summary>Request for ForecastJob <pre></pre></summary>
	public partial class ForecastJobRequest : PlainRequestBase<ForecastJobRequestParameters>, IForecastJobRequest
	{
		protected IForecastJobRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_ml/anomaly_detectors/{job_id}/_forecast"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_ml/anomaly_detectors/{job_id}/_forecast</summary>
		///<param name = "job_id">this parameter is required</param>
		public ForecastJobRequest(Id job_id): base(r => r.Required("job_id", job_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal ForecastJobRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Id IForecastJobRequest.JobId => Self.RouteValues.Get<Id>("job_id");
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IGetBucketsRequest : IRequest<GetBucketsRequestParameters>
	{
		[IgnoreDataMember]
		Id JobId
		{
			get;
		}

		[IgnoreDataMember]
		Timestamp Timestamp
		{
			get;
		}
	}

	///<summary>Request for GetBuckets <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/ml-get-bucket.html</pre></summary>
	public partial class GetBucketsRequest : PlainRequestBase<GetBucketsRequestParameters>, IGetBucketsRequest
	{
		protected IGetBucketsRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_ml/anomaly_detectors/{job_id}/results/buckets/{timestamp}", "_ml/anomaly_detectors/{job_id}/results/buckets"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_ml/anomaly_detectors/{job_id}/results/buckets/{timestamp}</summary>
		///<param name = "job_id">this parameter is required</param>
		///<param name = "timestamp">Optional, accepts null</param>
		public GetBucketsRequest(Id job_id, Timestamp timestamp): base(r => r.Required("job_id", job_id).Optional("timestamp", timestamp))
		{
		}

		///<summary>/_ml/anomaly_detectors/{job_id}/results/buckets</summary>
		///<param name = "job_id">this parameter is required</param>
		public GetBucketsRequest(Id job_id): base(r => r.Required("job_id", job_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal GetBucketsRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Id IGetBucketsRequest.JobId => Self.RouteValues.Get<Id>("job_id");
		[IgnoreDataMember]
		Timestamp IGetBucketsRequest.Timestamp => Self.RouteValues.Get<Timestamp>("timestamp");
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IGetCalendarEventsRequest : IRequest<GetCalendarEventsRequestParameters>
	{
		[IgnoreDataMember]
		Id CalendarId
		{
			get;
		}
	}

	///<summary>Request for GetCalendarEvents <pre></pre></summary>
	public partial class GetCalendarEventsRequest : PlainRequestBase<GetCalendarEventsRequestParameters>, IGetCalendarEventsRequest
	{
		protected IGetCalendarEventsRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_ml/calendars/{calendar_id}/events"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_ml/calendars/{calendar_id}/events</summary>
		///<param name = "calendar_id">this parameter is required</param>
		public GetCalendarEventsRequest(Id calendar_id): base(r => r.Required("calendar_id", calendar_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal GetCalendarEventsRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Id IGetCalendarEventsRequest.CalendarId => Self.RouteValues.Get<Id>("calendar_id");
		// Request parameters
		///<summary>Get events before this time</summary>
		public DateTimeOffset? End
		{
			get => Q<DateTimeOffset? >("end");
			set => Q("end", value);
		}

		///<summary>Get events for the job. When this option is used calendar_id must be '_all'</summary>
		public string JobId
		{
			get => Q<string>("job_id");
			set => Q("job_id", value);
		}

		///<summary>Get events after this time</summary>
		public string Start
		{
			get => Q<string>("start");
			set => Q("start", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IGetCalendarsRequest : IRequest<GetCalendarsRequestParameters>
	{
		[IgnoreDataMember]
		Id CalendarId
		{
			get;
		}
	}

	///<summary>Request for GetCalendars <pre></pre></summary>
	public partial class GetCalendarsRequest : PlainRequestBase<GetCalendarsRequestParameters>, IGetCalendarsRequest
	{
		protected IGetCalendarsRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_ml/calendars", "_ml/calendars/{calendar_id}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_ml/calendars</summary>
		public GetCalendarsRequest(): base()
		{
		}

		///<summary>/_ml/calendars/{calendar_id}</summary>
		///<param name = "calendar_id">Optional, accepts null</param>
		public GetCalendarsRequest(Id calendar_id): base(r => r.Optional("calendar_id", calendar_id))
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Id IGetCalendarsRequest.CalendarId => Self.RouteValues.Get<Id>("calendar_id");
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IGetCategoriesRequest : IRequest<GetCategoriesRequestParameters>
	{
		[IgnoreDataMember]
		Id JobId
		{
			get;
		}

		[IgnoreDataMember]
		CategoryId CategoryId
		{
			get;
		}
	}

	///<summary>Request for GetCategories <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/ml-get-category.html</pre></summary>
	public partial class GetCategoriesRequest : PlainRequestBase<GetCategoriesRequestParameters>, IGetCategoriesRequest
	{
		protected IGetCategoriesRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_ml/anomaly_detectors/{job_id}/results/categories/{category_id}", "_ml/anomaly_detectors/{job_id}/results/categories/"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_ml/anomaly_detectors/{job_id}/results/categories/{category_id}</summary>
		///<param name = "job_id">this parameter is required</param>
		///<param name = "category_id">Optional, accepts null</param>
		public GetCategoriesRequest(Id job_id, CategoryId category_id): base(r => r.Required("job_id", job_id).Optional("category_id", category_id))
		{
		}

		///<summary>/_ml/anomaly_detectors/{job_id}/results/categories/</summary>
		///<param name = "job_id">this parameter is required</param>
		public GetCategoriesRequest(Id job_id): base(r => r.Required("job_id", job_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal GetCategoriesRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Id IGetCategoriesRequest.JobId => Self.RouteValues.Get<Id>("job_id");
		[IgnoreDataMember]
		CategoryId IGetCategoriesRequest.CategoryId => Self.RouteValues.Get<CategoryId>("category_id");
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IGetDatafeedStatsRequest : IRequest<GetDatafeedStatsRequestParameters>
	{
		[IgnoreDataMember]
		Id DatafeedId
		{
			get;
		}
	}

	///<summary>Request for GetDatafeedStats <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/ml-get-datafeed-stats.html</pre></summary>
	public partial class GetDatafeedStatsRequest : PlainRequestBase<GetDatafeedStatsRequestParameters>, IGetDatafeedStatsRequest
	{
		protected IGetDatafeedStatsRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_ml/datafeeds/{datafeed_id}/_stats", "_ml/datafeeds/_stats"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_ml/datafeeds/{datafeed_id}/_stats</summary>
		///<param name = "datafeed_id">Optional, accepts null</param>
		public GetDatafeedStatsRequest(Id datafeed_id): base(r => r.Optional("datafeed_id", datafeed_id))
		{
		}

		///<summary>/_ml/datafeeds/_stats</summary>
		public GetDatafeedStatsRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Id IGetDatafeedStatsRequest.DatafeedId => Self.RouteValues.Get<Id>("datafeed_id");
		// Request parameters
		///<summary>Whether to ignore if a wildcard expression matches no datafeeds. (This includes `_all` string or when no datafeeds have been specified)</summary>
		public bool? AllowNoDatafeeds
		{
			get => Q<bool? >("allow_no_datafeeds");
			set => Q("allow_no_datafeeds", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IGetDatafeedsRequest : IRequest<GetDatafeedsRequestParameters>
	{
		[IgnoreDataMember]
		Id DatafeedId
		{
			get;
		}
	}

	///<summary>Request for GetDatafeeds <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/ml-get-datafeed.html</pre></summary>
	public partial class GetDatafeedsRequest : PlainRequestBase<GetDatafeedsRequestParameters>, IGetDatafeedsRequest
	{
		protected IGetDatafeedsRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_ml/datafeeds/{datafeed_id}", "_ml/datafeeds"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_ml/datafeeds/{datafeed_id}</summary>
		///<param name = "datafeed_id">Optional, accepts null</param>
		public GetDatafeedsRequest(Id datafeed_id): base(r => r.Optional("datafeed_id", datafeed_id))
		{
		}

		///<summary>/_ml/datafeeds</summary>
		public GetDatafeedsRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Id IGetDatafeedsRequest.DatafeedId => Self.RouteValues.Get<Id>("datafeed_id");
		// Request parameters
		///<summary>Whether to ignore if a wildcard expression matches no datafeeds. (This includes `_all` string or when no datafeeds have been specified)</summary>
		public bool? AllowNoDatafeeds
		{
			get => Q<bool? >("allow_no_datafeeds");
			set => Q("allow_no_datafeeds", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IGetFiltersRequest : IRequest<GetFiltersRequestParameters>
	{
		[IgnoreDataMember]
		Id FilterId
		{
			get;
		}
	}

	///<summary>Request for GetFilters <pre></pre></summary>
	public partial class GetFiltersRequest : PlainRequestBase<GetFiltersRequestParameters>, IGetFiltersRequest
	{
		protected IGetFiltersRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_ml/filters", "_ml/filters/{filter_id}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_ml/filters</summary>
		public GetFiltersRequest(): base()
		{
		}

		///<summary>/_ml/filters/{filter_id}</summary>
		///<param name = "filter_id">Optional, accepts null</param>
		public GetFiltersRequest(Id filter_id): base(r => r.Optional("filter_id", filter_id))
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Id IGetFiltersRequest.FilterId => Self.RouteValues.Get<Id>("filter_id");
		// Request parameters
		///<summary>skips a number of filters</summary>
		public int? From
		{
			get => Q<int? >("from");
			set => Q("from", value);
		}

		///<summary>specifies a max number of filters to get</summary>
		public int? Size
		{
			get => Q<int? >("size");
			set => Q("size", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IGetInfluencersRequest : IRequest<GetInfluencersRequestParameters>
	{
		[IgnoreDataMember]
		Id JobId
		{
			get;
		}
	}

	///<summary>Request for GetInfluencers <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/ml-get-influencer.html</pre></summary>
	public partial class GetInfluencersRequest : PlainRequestBase<GetInfluencersRequestParameters>, IGetInfluencersRequest
	{
		protected IGetInfluencersRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_ml/anomaly_detectors/{job_id}/results/influencers"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_ml/anomaly_detectors/{job_id}/results/influencers</summary>
		///<param name = "job_id">this parameter is required</param>
		public GetInfluencersRequest(Id job_id): base(r => r.Required("job_id", job_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal GetInfluencersRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Id IGetInfluencersRequest.JobId => Self.RouteValues.Get<Id>("job_id");
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IGetJobStatsRequest : IRequest<GetJobStatsRequestParameters>
	{
		[IgnoreDataMember]
		Id JobId
		{
			get;
		}
	}

	///<summary>Request for GetJobStats <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/ml-get-job-stats.html</pre></summary>
	public partial class GetJobStatsRequest : PlainRequestBase<GetJobStatsRequestParameters>, IGetJobStatsRequest
	{
		protected IGetJobStatsRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_ml/anomaly_detectors/_stats", "_ml/anomaly_detectors/{job_id}/_stats"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_ml/anomaly_detectors/_stats</summary>
		public GetJobStatsRequest(): base()
		{
		}

		///<summary>/_ml/anomaly_detectors/{job_id}/_stats</summary>
		///<param name = "job_id">Optional, accepts null</param>
		public GetJobStatsRequest(Id job_id): base(r => r.Optional("job_id", job_id))
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Id IGetJobStatsRequest.JobId => Self.RouteValues.Get<Id>("job_id");
		// Request parameters
		///<summary>Whether to ignore if a wildcard expression matches no jobs. (This includes `_all` string or when no jobs have been specified)</summary>
		public bool? AllowNoJobs
		{
			get => Q<bool? >("allow_no_jobs");
			set => Q("allow_no_jobs", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IGetJobsRequest : IRequest<GetJobsRequestParameters>
	{
		[IgnoreDataMember]
		Id JobId
		{
			get;
		}
	}

	///<summary>Request for GetJobs <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/ml-get-job.html</pre></summary>
	public partial class GetJobsRequest : PlainRequestBase<GetJobsRequestParameters>, IGetJobsRequest
	{
		protected IGetJobsRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_ml/anomaly_detectors/{job_id}", "_ml/anomaly_detectors"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_ml/anomaly_detectors/{job_id}</summary>
		///<param name = "job_id">Optional, accepts null</param>
		public GetJobsRequest(Id job_id): base(r => r.Optional("job_id", job_id))
		{
		}

		///<summary>/_ml/anomaly_detectors</summary>
		public GetJobsRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Id IGetJobsRequest.JobId => Self.RouteValues.Get<Id>("job_id");
		// Request parameters
		///<summary>Whether to ignore if a wildcard expression matches no jobs. (This includes `_all` string or when no jobs have been specified)</summary>
		public bool? AllowNoJobs
		{
			get => Q<bool? >("allow_no_jobs");
			set => Q("allow_no_jobs", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IGetModelSnapshotsRequest : IRequest<GetModelSnapshotsRequestParameters>
	{
		[IgnoreDataMember]
		Id JobId
		{
			get;
		}

		[IgnoreDataMember]
		Id SnapshotId
		{
			get;
		}
	}

	///<summary>Request for GetModelSnapshots <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/ml-get-snapshot.html</pre></summary>
	public partial class GetModelSnapshotsRequest : PlainRequestBase<GetModelSnapshotsRequestParameters>, IGetModelSnapshotsRequest
	{
		protected IGetModelSnapshotsRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_ml/anomaly_detectors/{job_id}/model_snapshots/{snapshot_id}", "_ml/anomaly_detectors/{job_id}/model_snapshots"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_ml/anomaly_detectors/{job_id}/model_snapshots/{snapshot_id}</summary>
		///<param name = "job_id">this parameter is required</param>
		///<param name = "snapshot_id">Optional, accepts null</param>
		public GetModelSnapshotsRequest(Id job_id, Id snapshot_id): base(r => r.Required("job_id", job_id).Optional("snapshot_id", snapshot_id))
		{
		}

		///<summary>/_ml/anomaly_detectors/{job_id}/model_snapshots</summary>
		///<param name = "job_id">this parameter is required</param>
		public GetModelSnapshotsRequest(Id job_id): base(r => r.Required("job_id", job_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal GetModelSnapshotsRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Id IGetModelSnapshotsRequest.JobId => Self.RouteValues.Get<Id>("job_id");
		[IgnoreDataMember]
		Id IGetModelSnapshotsRequest.SnapshotId => Self.RouteValues.Get<Id>("snapshot_id");
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IGetOverallBucketsRequest : IRequest<GetOverallBucketsRequestParameters>
	{
		[IgnoreDataMember]
		Id JobId
		{
			get;
		}
	}

	///<summary>Request for GetOverallBuckets <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/ml-get-overall-buckets.html</pre></summary>
	public partial class GetOverallBucketsRequest : PlainRequestBase<GetOverallBucketsRequestParameters>, IGetOverallBucketsRequest
	{
		protected IGetOverallBucketsRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_ml/anomaly_detectors/{job_id}/results/overall_buckets"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_ml/anomaly_detectors/{job_id}/results/overall_buckets</summary>
		///<param name = "job_id">this parameter is required</param>
		public GetOverallBucketsRequest(Id job_id): base(r => r.Required("job_id", job_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal GetOverallBucketsRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Id IGetOverallBucketsRequest.JobId => Self.RouteValues.Get<Id>("job_id");
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IGetAnomalyRecordsRequest : IRequest<GetAnomalyRecordsRequestParameters>
	{
		[IgnoreDataMember]
		Id JobId
		{
			get;
		}
	}

	///<summary>Request for GetAnomalyRecords <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/ml-get-record.html</pre></summary>
	public partial class GetAnomalyRecordsRequest : PlainRequestBase<GetAnomalyRecordsRequestParameters>, IGetAnomalyRecordsRequest
	{
		protected IGetAnomalyRecordsRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_ml/anomaly_detectors/{job_id}/results/records"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_ml/anomaly_detectors/{job_id}/results/records</summary>
		///<param name = "job_id">this parameter is required</param>
		public GetAnomalyRecordsRequest(Id job_id): base(r => r.Required("job_id", job_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal GetAnomalyRecordsRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Id IGetAnomalyRecordsRequest.JobId => Self.RouteValues.Get<Id>("job_id");
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IMachineLearningInfoRequest : IRequest<MachineLearningInfoRequestParameters>
	{
	}

	///<summary>Request for Info <pre></pre></summary>
	public partial class MachineLearningInfoRequest : PlainRequestBase<MachineLearningInfoRequestParameters>, IMachineLearningInfoRequest
	{
		protected IMachineLearningInfoRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_ml/info"});
		internal override ApiUrls ApiUrls => Urls;
	// values part of the url path
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IOpenJobRequest : IRequest<OpenJobRequestParameters>
	{
		[IgnoreDataMember]
		Id JobId
		{
			get;
		}
	}

	///<summary>Request for OpenJob <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/ml-open-job.html</pre></summary>
	public partial class OpenJobRequest : PlainRequestBase<OpenJobRequestParameters>, IOpenJobRequest
	{
		protected IOpenJobRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_ml/anomaly_detectors/{job_id}/_open"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_ml/anomaly_detectors/{job_id}/_open</summary>
		///<param name = "job_id">this parameter is required</param>
		public OpenJobRequest(Id job_id): base(r => r.Required("job_id", job_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal OpenJobRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Id IOpenJobRequest.JobId => Self.RouteValues.Get<Id>("job_id");
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IPostCalendarEventsRequest : IRequest<PostCalendarEventsRequestParameters>
	{
		[IgnoreDataMember]
		Id CalendarId
		{
			get;
		}
	}

	///<summary>Request for PostCalendarEvents <pre></pre></summary>
	public partial class PostCalendarEventsRequest : PlainRequestBase<PostCalendarEventsRequestParameters>, IPostCalendarEventsRequest
	{
		protected IPostCalendarEventsRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_ml/calendars/{calendar_id}/events"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_ml/calendars/{calendar_id}/events</summary>
		///<param name = "calendar_id">this parameter is required</param>
		public PostCalendarEventsRequest(Id calendar_id): base(r => r.Required("calendar_id", calendar_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal PostCalendarEventsRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Id IPostCalendarEventsRequest.CalendarId => Self.RouteValues.Get<Id>("calendar_id");
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IPostJobDataRequest : IRequest<PostJobDataRequestParameters>
	{
		[IgnoreDataMember]
		Id JobId
		{
			get;
		}
	}

	///<summary>Request for PostJobData <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/ml-post-data.html</pre></summary>
	public partial class PostJobDataRequest : PlainRequestBase<PostJobDataRequestParameters>, IPostJobDataRequest
	{
		protected IPostJobDataRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_ml/anomaly_detectors/{job_id}/_data"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_ml/anomaly_detectors/{job_id}/_data</summary>
		///<param name = "job_id">this parameter is required</param>
		public PostJobDataRequest(Id job_id): base(r => r.Required("job_id", job_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal PostJobDataRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Id IPostJobDataRequest.JobId => Self.RouteValues.Get<Id>("job_id");
		// Request parameters
		///<summary>Optional parameter to specify the end of the bucket resetting range</summary>
		public DateTimeOffset? ResetEnd
		{
			get => Q<DateTimeOffset? >("reset_end");
			set => Q("reset_end", value);
		}

		///<summary>Optional parameter to specify the start of the bucket resetting range</summary>
		public DateTimeOffset? ResetStart
		{
			get => Q<DateTimeOffset? >("reset_start");
			set => Q("reset_start", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IPreviewDatafeedRequest : IRequest<PreviewDatafeedRequestParameters>
	{
		[IgnoreDataMember]
		Id DatafeedId
		{
			get;
		}
	}

	///<summary>Request for PreviewDatafeed <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/ml-preview-datafeed.html</pre></summary>
	public partial class PreviewDatafeedRequest : PlainRequestBase<PreviewDatafeedRequestParameters>, IPreviewDatafeedRequest
	{
		protected IPreviewDatafeedRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_ml/datafeeds/{datafeed_id}/_preview"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_ml/datafeeds/{datafeed_id}/_preview</summary>
		///<param name = "datafeed_id">this parameter is required</param>
		public PreviewDatafeedRequest(Id datafeed_id): base(r => r.Required("datafeed_id", datafeed_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal PreviewDatafeedRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Id IPreviewDatafeedRequest.DatafeedId => Self.RouteValues.Get<Id>("datafeed_id");
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IPutCalendarRequest : IRequest<PutCalendarRequestParameters>
	{
		[IgnoreDataMember]
		Id CalendarId
		{
			get;
		}
	}

	///<summary>Request for PutCalendar <pre></pre></summary>
	public partial class PutCalendarRequest : PlainRequestBase<PutCalendarRequestParameters>, IPutCalendarRequest
	{
		protected IPutCalendarRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_ml/calendars/{calendar_id}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_ml/calendars/{calendar_id}</summary>
		///<param name = "calendar_id">this parameter is required</param>
		public PutCalendarRequest(Id calendar_id): base(r => r.Required("calendar_id", calendar_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal PutCalendarRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Id IPutCalendarRequest.CalendarId => Self.RouteValues.Get<Id>("calendar_id");
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IPutCalendarJobRequest : IRequest<PutCalendarJobRequestParameters>
	{
		[IgnoreDataMember]
		Id CalendarId
		{
			get;
		}

		[IgnoreDataMember]
		Id JobId
		{
			get;
		}
	}

	///<summary>Request for PutCalendarJob <pre></pre></summary>
	public partial class PutCalendarJobRequest : PlainRequestBase<PutCalendarJobRequestParameters>, IPutCalendarJobRequest
	{
		protected IPutCalendarJobRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_ml/calendars/{calendar_id}/jobs/{job_id}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_ml/calendars/{calendar_id}/jobs/{job_id}</summary>
		///<param name = "calendar_id">this parameter is required</param>
		///<param name = "job_id">this parameter is required</param>
		public PutCalendarJobRequest(Id calendar_id, Id job_id): base(r => r.Required("calendar_id", calendar_id).Required("job_id", job_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal PutCalendarJobRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Id IPutCalendarJobRequest.CalendarId => Self.RouteValues.Get<Id>("calendar_id");
		[IgnoreDataMember]
		Id IPutCalendarJobRequest.JobId => Self.RouteValues.Get<Id>("job_id");
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IPutDatafeedRequest : IRequest<PutDatafeedRequestParameters>
	{
		[IgnoreDataMember]
		Id DatafeedId
		{
			get;
		}
	}

	///<summary>Request for PutDatafeed <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/ml-put-datafeed.html</pre></summary>
	public partial class PutDatafeedRequest : PlainRequestBase<PutDatafeedRequestParameters>, IPutDatafeedRequest
	{
		protected IPutDatafeedRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_ml/datafeeds/{datafeed_id}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_ml/datafeeds/{datafeed_id}</summary>
		///<param name = "datafeed_id">this parameter is required</param>
		public PutDatafeedRequest(Id datafeed_id): base(r => r.Required("datafeed_id", datafeed_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal PutDatafeedRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Id IPutDatafeedRequest.DatafeedId => Self.RouteValues.Get<Id>("datafeed_id");
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IPutFilterRequest : IRequest<PutFilterRequestParameters>
	{
		[IgnoreDataMember]
		Id FilterId
		{
			get;
		}
	}

	///<summary>Request for PutFilter <pre></pre></summary>
	public partial class PutFilterRequest : PlainRequestBase<PutFilterRequestParameters>, IPutFilterRequest
	{
		protected IPutFilterRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_ml/filters/{filter_id}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_ml/filters/{filter_id}</summary>
		///<param name = "filter_id">this parameter is required</param>
		public PutFilterRequest(Id filter_id): base(r => r.Required("filter_id", filter_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal PutFilterRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Id IPutFilterRequest.FilterId => Self.RouteValues.Get<Id>("filter_id");
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IPutJobRequest : IRequest<PutJobRequestParameters>
	{
		[IgnoreDataMember]
		Id JobId
		{
			get;
		}
	}

	///<summary>Request for PutJob <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/ml-put-job.html</pre></summary>
	public partial class PutJobRequest : PlainRequestBase<PutJobRequestParameters>, IPutJobRequest
	{
		protected IPutJobRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_ml/anomaly_detectors/{job_id}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_ml/anomaly_detectors/{job_id}</summary>
		///<param name = "job_id">this parameter is required</param>
		public PutJobRequest(Id job_id): base(r => r.Required("job_id", job_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal PutJobRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Id IPutJobRequest.JobId => Self.RouteValues.Get<Id>("job_id");
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IRevertModelSnapshotRequest : IRequest<RevertModelSnapshotRequestParameters>
	{
		[IgnoreDataMember]
		Id JobId
		{
			get;
		}

		[IgnoreDataMember]
		Id SnapshotId
		{
			get;
		}
	}

	///<summary>Request for RevertModelSnapshot <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/ml-revert-snapshot.html</pre></summary>
	public partial class RevertModelSnapshotRequest : PlainRequestBase<RevertModelSnapshotRequestParameters>, IRevertModelSnapshotRequest
	{
		protected IRevertModelSnapshotRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_ml/anomaly_detectors/{job_id}/model_snapshots/{snapshot_id}/_revert"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_ml/anomaly_detectors/{job_id}/model_snapshots/{snapshot_id}/_revert</summary>
		///<param name = "job_id">this parameter is required</param>
		///<param name = "snapshot_id">this parameter is required</param>
		public RevertModelSnapshotRequest(Id job_id, Id snapshot_id): base(r => r.Required("job_id", job_id).Required("snapshot_id", snapshot_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal RevertModelSnapshotRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Id IRevertModelSnapshotRequest.JobId => Self.RouteValues.Get<Id>("job_id");
		[IgnoreDataMember]
		Id IRevertModelSnapshotRequest.SnapshotId => Self.RouteValues.Get<Id>("snapshot_id");
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IStartDatafeedRequest : IRequest<StartDatafeedRequestParameters>
	{
		[IgnoreDataMember]
		Id DatafeedId
		{
			get;
		}
	}

	///<summary>Request for StartDatafeed <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/ml-start-datafeed.html</pre></summary>
	public partial class StartDatafeedRequest : PlainRequestBase<StartDatafeedRequestParameters>, IStartDatafeedRequest
	{
		protected IStartDatafeedRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_ml/datafeeds/{datafeed_id}/_start"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_ml/datafeeds/{datafeed_id}/_start</summary>
		///<param name = "datafeed_id">this parameter is required</param>
		public StartDatafeedRequest(Id datafeed_id): base(r => r.Required("datafeed_id", datafeed_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal StartDatafeedRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Id IStartDatafeedRequest.DatafeedId => Self.RouteValues.Get<Id>("datafeed_id");
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IStopDatafeedRequest : IRequest<StopDatafeedRequestParameters>
	{
		[IgnoreDataMember]
		Id DatafeedId
		{
			get;
		}
	}

	///<summary>Request for StopDatafeed <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/ml-stop-datafeed.html</pre></summary>
	public partial class StopDatafeedRequest : PlainRequestBase<StopDatafeedRequestParameters>, IStopDatafeedRequest
	{
		protected IStopDatafeedRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_ml/datafeeds/{datafeed_id}/_stop"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_ml/datafeeds/{datafeed_id}/_stop</summary>
		///<param name = "datafeed_id">this parameter is required</param>
		public StopDatafeedRequest(Id datafeed_id): base(r => r.Required("datafeed_id", datafeed_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal StopDatafeedRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Id IStopDatafeedRequest.DatafeedId => Self.RouteValues.Get<Id>("datafeed_id");
		// Request parameters
		///<summary>Whether to ignore if a wildcard expression matches no datafeeds. (This includes `_all` string or when no datafeeds have been specified)</summary>
		public bool? AllowNoDatafeeds
		{
			get => Q<bool? >("allow_no_datafeeds");
			set => Q("allow_no_datafeeds", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IUpdateDatafeedRequest : IRequest<UpdateDatafeedRequestParameters>
	{
		[IgnoreDataMember]
		Id DatafeedId
		{
			get;
		}
	}

	///<summary>Request for UpdateDatafeed <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/ml-update-datafeed.html</pre></summary>
	public partial class UpdateDatafeedRequest : PlainRequestBase<UpdateDatafeedRequestParameters>, IUpdateDatafeedRequest
	{
		protected IUpdateDatafeedRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_ml/datafeeds/{datafeed_id}/_update"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_ml/datafeeds/{datafeed_id}/_update</summary>
		///<param name = "datafeed_id">this parameter is required</param>
		public UpdateDatafeedRequest(Id datafeed_id): base(r => r.Required("datafeed_id", datafeed_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal UpdateDatafeedRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Id IUpdateDatafeedRequest.DatafeedId => Self.RouteValues.Get<Id>("datafeed_id");
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IUpdateFilterRequest : IRequest<UpdateFilterRequestParameters>
	{
		[IgnoreDataMember]
		Id FilterId
		{
			get;
		}
	}

	///<summary>Request for UpdateFilter <pre></pre></summary>
	public partial class UpdateFilterRequest : PlainRequestBase<UpdateFilterRequestParameters>, IUpdateFilterRequest
	{
		protected IUpdateFilterRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_ml/filters/{filter_id}/_update"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_ml/filters/{filter_id}/_update</summary>
		///<param name = "filter_id">this parameter is required</param>
		public UpdateFilterRequest(Id filter_id): base(r => r.Required("filter_id", filter_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal UpdateFilterRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Id IUpdateFilterRequest.FilterId => Self.RouteValues.Get<Id>("filter_id");
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IUpdateJobRequest : IRequest<UpdateJobRequestParameters>
	{
		[IgnoreDataMember]
		Id JobId
		{
			get;
		}
	}

	///<summary>Request for UpdateJob <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/ml-update-job.html</pre></summary>
	public partial class UpdateJobRequest : PlainRequestBase<UpdateJobRequestParameters>, IUpdateJobRequest
	{
		protected IUpdateJobRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_ml/anomaly_detectors/{job_id}/_update"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_ml/anomaly_detectors/{job_id}/_update</summary>
		///<param name = "job_id">this parameter is required</param>
		public UpdateJobRequest(Id job_id): base(r => r.Required("job_id", job_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal UpdateJobRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Id IUpdateJobRequest.JobId => Self.RouteValues.Get<Id>("job_id");
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IUpdateModelSnapshotRequest : IRequest<UpdateModelSnapshotRequestParameters>
	{
		[IgnoreDataMember]
		Id JobId
		{
			get;
		}

		[IgnoreDataMember]
		Id SnapshotId
		{
			get;
		}
	}

	///<summary>Request for UpdateModelSnapshot <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/ml-update-snapshot.html</pre></summary>
	public partial class UpdateModelSnapshotRequest : PlainRequestBase<UpdateModelSnapshotRequestParameters>, IUpdateModelSnapshotRequest
	{
		protected IUpdateModelSnapshotRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_ml/anomaly_detectors/{job_id}/model_snapshots/{snapshot_id}/_update"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_ml/anomaly_detectors/{job_id}/model_snapshots/{snapshot_id}/_update</summary>
		///<param name = "job_id">this parameter is required</param>
		///<param name = "snapshot_id">this parameter is required</param>
		public UpdateModelSnapshotRequest(Id job_id, Id snapshot_id): base(r => r.Required("job_id", job_id).Required("snapshot_id", snapshot_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal UpdateModelSnapshotRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Id IUpdateModelSnapshotRequest.JobId => Self.RouteValues.Get<Id>("job_id");
		[IgnoreDataMember]
		Id IUpdateModelSnapshotRequest.SnapshotId => Self.RouteValues.Get<Id>("snapshot_id");
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IValidateJobRequest : IRequest<ValidateJobRequestParameters>
	{
	}

	///<summary>Request for ValidateJob <pre></pre></summary>
	public partial class ValidateJobRequest : PlainRequestBase<ValidateJobRequestParameters>, IValidateJobRequest
	{
		protected IValidateJobRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_ml/anomaly_detectors/_validate"});
		internal override ApiUrls ApiUrls => Urls;
	// values part of the url path
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IValidateDetectorRequest : IRequest<ValidateDetectorRequestParameters>
	{
	}

	///<summary>Request for ValidateDetector <pre></pre></summary>
	public partial class ValidateDetectorRequest : PlainRequestBase<ValidateDetectorRequestParameters>, IValidateDetectorRequest
	{
		protected IValidateDetectorRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_ml/anomaly_detectors/_validate/detector"});
		internal override ApiUrls ApiUrls => Urls;
	// values part of the url path
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IMultiSearchRequest : IRequest<MultiSearchRequestParameters>
	{
		[IgnoreDataMember]
		Indices Index
		{
			get;
		}
	}

	///<summary>Request for MultiSearch <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/search-multi-search.html</pre></summary>
	public partial class MultiSearchRequest : PlainRequestBase<MultiSearchRequestParameters>, IMultiSearchRequest
	{
		protected IMultiSearchRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_msearch", "{index}/_msearch"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_msearch</summary>
		public MultiSearchRequest(): base()
		{
		}

		///<summary>/{index}/_msearch</summary>
		///<param name = "index">Optional, accepts null</param>
		public MultiSearchRequest(Indices index): base(r => r.Optional("index", index))
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Indices IMultiSearchRequest.Index => Self.RouteValues.Get<Indices>("index");
		// Request parameters
		///<summary>Indicates whether network round-trips should be minimized as part of cross-cluster search requests execution</summary>
		public bool? CcsMinimizeRoundtrips
		{
			get => Q<bool? >("ccs_minimize_roundtrips");
			set => Q("ccs_minimize_roundtrips", value);
		}

		///<summary>Controls the maximum number of concurrent searches the multi search api will execute</summary>
		public long? MaxConcurrentSearches
		{
			get => Q<long? >("max_concurrent_searches");
			set => Q("max_concurrent_searches", value);
		}

		///<summary>
		/// The number of concurrent shard requests each sub search executes concurrently. This value should be used to limit the impact of the search
		/// on the cluster in order to limit the number of concurrent shard requests
		///</summary>
		public long? MaxConcurrentShardRequests
		{
			get => Q<long? >("max_concurrent_shard_requests");
			set => Q("max_concurrent_shard_requests", value);
		}

		///<summary>
		/// A threshold that enforces a pre-filter roundtrip to prefilter search shards based on query rewriting if thenumber of shards the search
		/// request expands to exceeds the threshold. This filter roundtrip can limit the number of shards significantly if for instance a shard can
		/// not match any documents based on it's rewrite method ie. if date filters are mandatory to match but the shard bounds and the query are
		/// disjoint.
		///</summary>
		public long? PreFilterShardSize
		{
			get => Q<long? >("pre_filter_shard_size");
			set => Q("pre_filter_shard_size", value);
		}

		///<summary>Search operation type</summary>
		public SearchType? SearchType
		{
			get => Q<SearchType? >("search_type");
			set => Q("search_type", value);
		}

		///<summary>Indicates whether hits.total should be rendered as an integer or an object in the rest search response</summary>
		public bool? TotalHitsAsInteger
		{
			get => Q<bool? >("rest_total_hits_as_int");
			set => Q("rest_total_hits_as_int", value);
		}

		///<summary>Specify whether aggregation and suggester names should be prefixed by their respective types in the response</summary>
		public bool? TypedKeys
		{
			get => Q<bool? >("typed_keys");
			set => Q("typed_keys", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IMultiSearchTemplateRequest : IRequest<MultiSearchTemplateRequestParameters>
	{
		[IgnoreDataMember]
		Indices Index
		{
			get;
		}
	}

	///<summary>Request for MultiSearchTemplate <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/search-multi-search.html</pre></summary>
	public partial class MultiSearchTemplateRequest : PlainRequestBase<MultiSearchTemplateRequestParameters>, IMultiSearchTemplateRequest
	{
		protected IMultiSearchTemplateRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_msearch/template", "{index}/_msearch/template"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_msearch/template</summary>
		public MultiSearchTemplateRequest(): base()
		{
		}

		///<summary>/{index}/_msearch/template</summary>
		///<param name = "index">Optional, accepts null</param>
		public MultiSearchTemplateRequest(Indices index): base(r => r.Optional("index", index))
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Indices IMultiSearchTemplateRequest.Index => Self.RouteValues.Get<Indices>("index");
		// Request parameters
		///<summary>Indicates whether network round-trips should be minimized as part of cross-cluster search requests execution</summary>
		public bool? CcsMinimizeRoundtrips
		{
			get => Q<bool? >("ccs_minimize_roundtrips");
			set => Q("ccs_minimize_roundtrips", value);
		}

		///<summary>Controls the maximum number of concurrent searches the multi search api will execute</summary>
		public long? MaxConcurrentSearches
		{
			get => Q<long? >("max_concurrent_searches");
			set => Q("max_concurrent_searches", value);
		}

		///<summary>Search operation type</summary>
		public SearchType? SearchType
		{
			get => Q<SearchType? >("search_type");
			set => Q("search_type", value);
		}

		///<summary>Indicates whether hits.total should be rendered as an integer or an object in the rest search response</summary>
		public bool? TotalHitsAsInteger
		{
			get => Q<bool? >("rest_total_hits_as_int");
			set => Q("rest_total_hits_as_int", value);
		}

		///<summary>Specify whether aggregation and suggester names should be prefixed by their respective types in the response</summary>
		public bool? TypedKeys
		{
			get => Q<bool? >("typed_keys");
			set => Q("typed_keys", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IMultiTermVectorsRequest : IRequest<MultiTermVectorsRequestParameters>
	{
		[IgnoreDataMember]
		IndexName Index
		{
			get;
		}
	}

	///<summary>Request for MultiTermVectors <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-multi-termvectors.html</pre></summary>
	public partial class MultiTermVectorsRequest : PlainRequestBase<MultiTermVectorsRequestParameters>, IMultiTermVectorsRequest
	{
		protected IMultiTermVectorsRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_mtermvectors", "{index}/_mtermvectors"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_mtermvectors</summary>
		public MultiTermVectorsRequest(): base()
		{
		}

		///<summary>/{index}/_mtermvectors</summary>
		///<param name = "index">Optional, accepts null</param>
		public MultiTermVectorsRequest(IndexName index): base(r => r.Optional("index", index))
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		IndexName IMultiTermVectorsRequest.Index => Self.RouteValues.Get<IndexName>("index");
		// Request parameters
		///<summary>
		/// Specifies if document count, sum of document frequencies and sum of total term frequencies should be returned. Applies to all returned
		/// documents unless otherwise specified in body "params" or "docs".
		///</summary>
		public bool? FieldStatistics
		{
			get => Q<bool? >("field_statistics");
			set => Q("field_statistics", value);
		}

		///<summary>A comma-separated list of fields to return. Applies to all returned documents unless otherwise specified in body "params" or "docs".</summary>
		public Fields Fields
		{
			get => Q<Fields>("fields");
			set => Q("fields", value);
		}

		///<summary>Specifies if term offsets should be returned. Applies to all returned documents unless otherwise specified in body "params" or "docs".</summary>
		public bool? Offsets
		{
			get => Q<bool? >("offsets");
			set => Q("offsets", value);
		}

		///<summary>Specifies if term payloads should be returned. Applies to all returned documents unless otherwise specified in body "params" or "docs".</summary>
		public bool? Payloads
		{
			get => Q<bool? >("payloads");
			set => Q("payloads", value);
		}

		///<summary>Specifies if term positions should be returned. Applies to all returned documents unless otherwise specified in body "params" or "docs".</summary>
		public bool? Positions
		{
			get => Q<bool? >("positions");
			set => Q("positions", value);
		}

		///<summary>
		/// Specify the node or shard the operation should be performed on (default: random) .Applies to all returned documents unless otherwise
		/// specified in body "params" or "docs".
		///</summary>
		public string Preference
		{
			get => Q<string>("preference");
			set => Q("preference", value);
		}

		///<summary>Specifies if requests are real-time as opposed to near-real-time (default: true).</summary>
		public bool? Realtime
		{
			get => Q<bool? >("realtime");
			set => Q("realtime", value);
		}

		///<summary>
		/// A document is routed to a particular shard in an index using the following formula
		/// <para> shard_num = hash(_routing) % num_primary_shards</para>
		/// <para>Elasticsearch will use the document id if not provided. </para>
		/// <para>For requests that are constructed from/for a document NEST will automatically infer the routing key
		/// if that document has a <see cref = "Nest.JoinField"/> or a routing mapping on for its type exists on <see cref = "Nest.ConnectionSettings"
		////></para>
		///</summary>
		public Routing Routing
		{
			get => Q<Routing>("routing");
			set => Q("routing", value);
		}

		///<summary>
		/// Specifies if total term frequency and document frequency should be returned. Applies to all returned documents unless otherwise specified
		/// in body "params" or "docs".
		///</summary>
		public bool? TermStatistics
		{
			get => Q<bool? >("term_statistics");
			set => Q("term_statistics", value);
		}

		///<summary>Explicit version number for concurrency control</summary>
		public long? Version
		{
			get => Q<long? >("version");
			set => Q("version", value);
		}

		///<summary>Specific version type</summary>
		public VersionType? VersionType
		{
			get => Q<VersionType? >("version_type");
			set => Q("version_type", value);
		}
	}

	[InterfaceDataContract]
	public partial interface INodesHotThreadsRequest : IRequest<NodesHotThreadsRequestParameters>
	{
		[IgnoreDataMember]
		NodeIds NodeId
		{
			get;
		}
	}

	///<summary>Request for HotThreads <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-nodes-hot-threads.html</pre></summary>
	public partial class NodesHotThreadsRequest : PlainRequestBase<NodesHotThreadsRequestParameters>, INodesHotThreadsRequest
	{
		protected INodesHotThreadsRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_nodes/hot_threads", "_nodes/{node_id}/hot_threads"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_nodes/hot_threads</summary>
		public NodesHotThreadsRequest(): base()
		{
		}

		///<summary>/_nodes/{node_id}/hot_threads</summary>
		///<param name = "node_id">Optional, accepts null</param>
		public NodesHotThreadsRequest(NodeIds node_id): base(r => r.Optional("node_id", node_id))
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		NodeIds INodesHotThreadsRequest.NodeId => Self.RouteValues.Get<NodeIds>("node_id");
		// Request parameters
		///<summary>Don't show threads that are in known-idle places, such as waiting on a socket select or pulling from an empty task queue (default: true)</summary>
		public bool? IgnoreIdleThreads
		{
			get => Q<bool? >("ignore_idle_threads");
			set => Q("ignore_idle_threads", value);
		}

		///<summary>The interval for the second sampling of threads</summary>
		public Time Interval
		{
			get => Q<Time>("interval");
			set => Q("interval", value);
		}

		///<summary>Number of samples of thread stacktrace (default: 10)</summary>
		public long? Snapshots
		{
			get => Q<long? >("snapshots");
			set => Q("snapshots", value);
		}

		///<summary>The type to sample (default: cpu)</summary>
		public ThreadType? ThreadType
		{
			get => Q<ThreadType? >("type");
			set => Q("type", value);
		}

		///<summary>Specify the number of threads to provide information for (default: 3)</summary>
		public long? Threads
		{
			get => Q<long? >("threads");
			set => Q("threads", value);
		}

		///<summary>Explicit operation timeout</summary>
		public Time Timeout
		{
			get => Q<Time>("timeout");
			set => Q("timeout", value);
		}
	}

	[InterfaceDataContract]
	public partial interface INodesInfoRequest : IRequest<NodesInfoRequestParameters>
	{
		[IgnoreDataMember]
		NodeIds NodeId
		{
			get;
		}

		[IgnoreDataMember]
		Metrics Metric
		{
			get;
		}
	}

	///<summary>Request for Info <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-nodes-info.html</pre></summary>
	public partial class NodesInfoRequest : PlainRequestBase<NodesInfoRequestParameters>, INodesInfoRequest
	{
		protected INodesInfoRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_nodes", "_nodes/{node_id}", "_nodes/{metric}", "_nodes/{node_id}/{metric}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_nodes</summary>
		public NodesInfoRequest(): base()
		{
		}

		///<summary>/_nodes/{node_id}</summary>
		///<param name = "node_id">Optional, accepts null</param>
		public NodesInfoRequest(NodeIds node_id): base(r => r.Optional("node_id", node_id))
		{
		}

		///<summary>/_nodes/{metric}</summary>
		///<param name = "metric">Optional, accepts null</param>
		public NodesInfoRequest(Metrics metric): base(r => r.Optional("metric", metric))
		{
		}

		///<summary>/_nodes/{node_id}/{metric}</summary>
		///<param name = "node_id">Optional, accepts null</param>
		///<param name = "metric">Optional, accepts null</param>
		public NodesInfoRequest(NodeIds node_id, Metrics metric): base(r => r.Optional("node_id", node_id).Optional("metric", metric))
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		NodeIds INodesInfoRequest.NodeId => Self.RouteValues.Get<NodeIds>("node_id");
		[IgnoreDataMember]
		Metrics INodesInfoRequest.Metric => Self.RouteValues.Get<Metrics>("metric");
		// Request parameters
		///<summary>Return settings in flat format (default: false)</summary>
		public bool? FlatSettings
		{
			get => Q<bool? >("flat_settings");
			set => Q("flat_settings", value);
		}

		///<summary>Explicit operation timeout</summary>
		public Time Timeout
		{
			get => Q<Time>("timeout");
			set => Q("timeout", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IReloadSecureSettingsRequest : IRequest<ReloadSecureSettingsRequestParameters>
	{
		[IgnoreDataMember]
		NodeIds NodeId
		{
			get;
		}
	}

	///<summary>Request for ReloadSecureSettings <pre>https://www.elastic.co/guide/en/elasticsearch/reference/master/secure-settings.html#reloadable-secure-settings</pre></summary>
	public partial class ReloadSecureSettingsRequest : PlainRequestBase<ReloadSecureSettingsRequestParameters>, IReloadSecureSettingsRequest
	{
		protected IReloadSecureSettingsRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_nodes/reload_secure_settings", "_nodes/{node_id}/reload_secure_settings"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_nodes/reload_secure_settings</summary>
		public ReloadSecureSettingsRequest(): base()
		{
		}

		///<summary>/_nodes/{node_id}/reload_secure_settings</summary>
		///<param name = "node_id">Optional, accepts null</param>
		public ReloadSecureSettingsRequest(NodeIds node_id): base(r => r.Optional("node_id", node_id))
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		NodeIds IReloadSecureSettingsRequest.NodeId => Self.RouteValues.Get<NodeIds>("node_id");
		// Request parameters
		///<summary>Explicit operation timeout</summary>
		public Time Timeout
		{
			get => Q<Time>("timeout");
			set => Q("timeout", value);
		}
	}

	[InterfaceDataContract]
	public partial interface INodesStatsRequest : IRequest<NodesStatsRequestParameters>
	{
		[IgnoreDataMember]
		NodeIds NodeId
		{
			get;
		}

		[IgnoreDataMember]
		Metrics Metric
		{
			get;
		}

		[IgnoreDataMember]
		IndexMetrics IndexMetric
		{
			get;
		}
	}

	///<summary>Request for Stats <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-nodes-stats.html</pre></summary>
	public partial class NodesStatsRequest : PlainRequestBase<NodesStatsRequestParameters>, INodesStatsRequest
	{
		protected INodesStatsRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_nodes/stats", "_nodes/{node_id}/stats", "_nodes/stats/{metric}", "_nodes/{node_id}/stats/{metric}", "_nodes/stats/{metric}/{index_metric}", "_nodes/{node_id}/stats/{metric}/{index_metric}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_nodes/stats</summary>
		public NodesStatsRequest(): base()
		{
		}

		///<summary>/_nodes/{node_id}/stats</summary>
		///<param name = "node_id">Optional, accepts null</param>
		public NodesStatsRequest(NodeIds node_id): base(r => r.Optional("node_id", node_id))
		{
		}

		///<summary>/_nodes/stats/{metric}</summary>
		///<param name = "metric">Optional, accepts null</param>
		public NodesStatsRequest(Metrics metric): base(r => r.Optional("metric", metric))
		{
		}

		///<summary>/_nodes/{node_id}/stats/{metric}</summary>
		///<param name = "node_id">Optional, accepts null</param>
		///<param name = "metric">Optional, accepts null</param>
		public NodesStatsRequest(NodeIds node_id, Metrics metric): base(r => r.Optional("node_id", node_id).Optional("metric", metric))
		{
		}

		///<summary>/_nodes/stats/{metric}/{index_metric}</summary>
		///<param name = "metric">Optional, accepts null</param>
		///<param name = "index_metric">Optional, accepts null</param>
		public NodesStatsRequest(Metrics metric, IndexMetrics index_metric): base(r => r.Optional("metric", metric).Optional("index_metric", index_metric))
		{
		}

		///<summary>/_nodes/{node_id}/stats/{metric}/{index_metric}</summary>
		///<param name = "node_id">Optional, accepts null</param>
		///<param name = "metric">Optional, accepts null</param>
		///<param name = "index_metric">Optional, accepts null</param>
		public NodesStatsRequest(NodeIds node_id, Metrics metric, IndexMetrics index_metric): base(r => r.Optional("node_id", node_id).Optional("metric", metric).Optional("index_metric", index_metric))
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		NodeIds INodesStatsRequest.NodeId => Self.RouteValues.Get<NodeIds>("node_id");
		[IgnoreDataMember]
		Metrics INodesStatsRequest.Metric => Self.RouteValues.Get<Metrics>("metric");
		[IgnoreDataMember]
		IndexMetrics INodesStatsRequest.IndexMetric => Self.RouteValues.Get<IndexMetrics>("index_metric");
		// Request parameters
		///<summary>A comma-separated list of fields for `fielddata` and `suggest` index metric (supports wildcards)</summary>
		public Fields CompletionFields
		{
			get => Q<Fields>("completion_fields");
			set => Q("completion_fields", value);
		}

		///<summary>A comma-separated list of fields for `fielddata` index metric (supports wildcards)</summary>
		public Fields FielddataFields
		{
			get => Q<Fields>("fielddata_fields");
			set => Q("fielddata_fields", value);
		}

		///<summary>A comma-separated list of fields for `fielddata` and `completion` index metric (supports wildcards)</summary>
		public Fields Fields
		{
			get => Q<Fields>("fields");
			set => Q("fields", value);
		}

		///<summary>A comma-separated list of search groups for `search` index metric</summary>
		public bool? Groups
		{
			get => Q<bool? >("groups");
			set => Q("groups", value);
		}

		///<summary>Whether to report the aggregated disk usage of each one of the Lucene index files (only applies if segment stats are requested)</summary>
		public bool? IncludeSegmentFileSizes
		{
			get => Q<bool? >("include_segment_file_sizes");
			set => Q("include_segment_file_sizes", value);
		}

		///<summary>Return indices stats aggregated at index, node or shard level</summary>
		public Level? Level
		{
			get => Q<Level? >("level");
			set => Q("level", value);
		}

		///<summary>Explicit operation timeout</summary>
		public Time Timeout
		{
			get => Q<Time>("timeout");
			set => Q("timeout", value);
		}

		///<summary>A comma-separated list of document types for the `indexing` index metric</summary>
		public string[] Types
		{
			get => Q<string[]>("types");
			set => Q("types", value);
		}
	}

	[InterfaceDataContract]
	public partial interface INodesUsageRequest : IRequest<NodesUsageRequestParameters>
	{
		[IgnoreDataMember]
		NodeIds NodeId
		{
			get;
		}

		[IgnoreDataMember]
		Metrics Metric
		{
			get;
		}
	}

	///<summary>Request for Usage <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-nodes-usage.html</pre></summary>
	public partial class NodesUsageRequest : PlainRequestBase<NodesUsageRequestParameters>, INodesUsageRequest
	{
		protected INodesUsageRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_nodes/usage", "_nodes/{node_id}/usage", "_nodes/usage/{metric}", "_nodes/{node_id}/usage/{metric}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_nodes/usage</summary>
		public NodesUsageRequest(): base()
		{
		}

		///<summary>/_nodes/{node_id}/usage</summary>
		///<param name = "node_id">Optional, accepts null</param>
		public NodesUsageRequest(NodeIds node_id): base(r => r.Optional("node_id", node_id))
		{
		}

		///<summary>/_nodes/usage/{metric}</summary>
		///<param name = "metric">Optional, accepts null</param>
		public NodesUsageRequest(Metrics metric): base(r => r.Optional("metric", metric))
		{
		}

		///<summary>/_nodes/{node_id}/usage/{metric}</summary>
		///<param name = "node_id">Optional, accepts null</param>
		///<param name = "metric">Optional, accepts null</param>
		public NodesUsageRequest(NodeIds node_id, Metrics metric): base(r => r.Optional("node_id", node_id).Optional("metric", metric))
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		NodeIds INodesUsageRequest.NodeId => Self.RouteValues.Get<NodeIds>("node_id");
		[IgnoreDataMember]
		Metrics INodesUsageRequest.Metric => Self.RouteValues.Get<Metrics>("metric");
		// Request parameters
		///<summary>Explicit operation timeout</summary>
		public Time Timeout
		{
			get => Q<Time>("timeout");
			set => Q("timeout", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IPingRequest : IRequest<PingRequestParameters>
	{
	}

	///<summary>Request for Ping <pre>http://www.elastic.co/guide/</pre></summary>
	public partial class PingRequest : PlainRequestBase<PingRequestParameters>, IPingRequest
	{
		protected IPingRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{""});
		internal override ApiUrls ApiUrls => Urls;
	// values part of the url path
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IPutScriptRequest : IRequest<PutScriptRequestParameters>
	{
		[IgnoreDataMember]
		Id Id
		{
			get;
		}

		[IgnoreDataMember]
		Name Context
		{
			get;
		}
	}

	///<summary>Request for PutScript <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-scripting.html</pre></summary>
	public partial class PutScriptRequest : PlainRequestBase<PutScriptRequestParameters>, IPutScriptRequest
	{
		protected IPutScriptRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_scripts/{id}", "_scripts/{id}/{context}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_scripts/{id}</summary>
		///<param name = "id">this parameter is required</param>
		public PutScriptRequest(Id id): base(r => r.Required("id", id))
		{
		}

		///<summary>/_scripts/{id}/{context}</summary>
		///<param name = "id">this parameter is required</param>
		///<param name = "context">Optional, accepts null</param>
		public PutScriptRequest(Id id, Name context): base(r => r.Required("id", id).Optional("context", context))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal PutScriptRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Id IPutScriptRequest.Id => Self.RouteValues.Get<Id>("id");
		[IgnoreDataMember]
		Name IPutScriptRequest.Context => Self.RouteValues.Get<Name>("context");
		// Request parameters
		///<summary>Specify timeout for connection to master</summary>
		public Time MasterTimeout
		{
			get => Q<Time>("master_timeout");
			set => Q("master_timeout", value);
		}

		///<summary>Explicit operation timeout</summary>
		public Time Timeout
		{
			get => Q<Time>("timeout");
			set => Q("timeout", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IReindexOnServerRequest : IRequest<ReindexOnServerRequestParameters>
	{
	}

	///<summary>Request for ReindexOnServer <pre>https://www.elastic.co/guide/en/elasticsearch/reference/master/docs-reindex.html</pre></summary>
	public partial class ReindexOnServerRequest : PlainRequestBase<ReindexOnServerRequestParameters>, IReindexOnServerRequest
	{
		protected IReindexOnServerRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_reindex"});
		internal override ApiUrls ApiUrls => Urls;
		// values part of the url path
		// Request parameters
		///<summary>Should the effected indexes be refreshed?</summary>
		public bool? Refresh
		{
			get => Q<bool? >("refresh");
			set => Q("refresh", value);
		}

		///<summary>The throttle to set on this request in sub-requests per second. -1 means no throttle.</summary>
		public long? RequestsPerSecond
		{
			get => Q<long? >("requests_per_second");
			set => Q("requests_per_second", value);
		}

		///<summary>Control how long to keep the search context alive</summary>
		public Time Scroll
		{
			get => Q<Time>("scroll");
			set => Q("scroll", value);
		}

		///<summary>The number of slices this task should be divided into. Defaults to 1 meaning the task isn't sliced into subtasks.</summary>
		public long? Slices
		{
			get => Q<long? >("slices");
			set => Q("slices", value);
		}

		///<summary>Time each individual bulk request should wait for shards that are unavailable.</summary>
		public Time Timeout
		{
			get => Q<Time>("timeout");
			set => Q("timeout", value);
		}

		///<summary>
		/// Sets the number of shard copies that must be active before proceeding with the reindex operation. Defaults to 1, meaning the primary shard
		/// only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the
		/// shard (number of replicas + 1)
		///</summary>
		public string WaitForActiveShards
		{
			get => Q<string>("wait_for_active_shards");
			set => Q("wait_for_active_shards", value);
		}

		///<summary>Should the request should block until the reindex is complete.</summary>
		public bool? WaitForCompletion
		{
			get => Q<bool? >("wait_for_completion");
			set => Q("wait_for_completion", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IReindexRethrottleRequest : IRequest<ReindexRethrottleRequestParameters>
	{
		[IgnoreDataMember]
		TaskId TaskId
		{
			get;
		}
	}

	///<summary>Request for ReindexRethrottle <pre>https://www.elastic.co/guide/en/elasticsearch/reference/master/docs-reindex.html</pre></summary>
	public partial class ReindexRethrottleRequest : PlainRequestBase<ReindexRethrottleRequestParameters>, IReindexRethrottleRequest
	{
		protected IReindexRethrottleRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_reindex/{task_id}/_rethrottle"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_reindex/{task_id}/_rethrottle</summary>
		///<param name = "task_id">this parameter is required</param>
		public ReindexRethrottleRequest(TaskId task_id): base(r => r.Required("task_id", task_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal ReindexRethrottleRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		TaskId IReindexRethrottleRequest.TaskId => Self.RouteValues.Get<TaskId>("task_id");
		// Request parameters
		///<summary>The throttle to set on this request in floating sub-requests per second. -1 means set no throttle.</summary>
		public long? RequestsPerSecond
		{
			get => Q<long? >("requests_per_second");
			set => Q("requests_per_second", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IRenderSearchTemplateRequest : IRequest<RenderSearchTemplateRequestParameters>
	{
		[IgnoreDataMember]
		Id Id
		{
			get;
		}
	}

	///<summary>Request for RenderSearchTemplate <pre>http://www.elasticsearch.org/guide/en/elasticsearch/reference/master/search-template.html</pre></summary>
	public partial class RenderSearchTemplateRequest : PlainRequestBase<RenderSearchTemplateRequestParameters>, IRenderSearchTemplateRequest
	{
		protected IRenderSearchTemplateRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_render/template", "_render/template/{id}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_render/template</summary>
		public RenderSearchTemplateRequest(): base()
		{
		}

		///<summary>/_render/template/{id}</summary>
		///<param name = "id">Optional, accepts null</param>
		public RenderSearchTemplateRequest(Id id): base(r => r.Optional("id", id))
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Id IRenderSearchTemplateRequest.Id => Self.RouteValues.Get<Id>("id");
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IDeleteRollupJobRequest : IRequest<DeleteRollupJobRequestParameters>
	{
		[IgnoreDataMember]
		Id Id
		{
			get;
		}
	}

	///<summary>Request for DeleteRollupJob <pre></pre></summary>
	public partial class DeleteRollupJobRequest : PlainRequestBase<DeleteRollupJobRequestParameters>, IDeleteRollupJobRequest
	{
		protected IDeleteRollupJobRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_rollup/job/{id}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_rollup/job/{id}</summary>
		///<param name = "id">this parameter is required</param>
		public DeleteRollupJobRequest(Id id): base(r => r.Required("id", id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal DeleteRollupJobRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Id IDeleteRollupJobRequest.Id => Self.RouteValues.Get<Id>("id");
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IGetRollupJobRequest : IRequest<GetRollupJobRequestParameters>
	{
		[IgnoreDataMember]
		Id Id
		{
			get;
		}
	}

	///<summary>Request for GetRollupJob <pre></pre></summary>
	public partial class GetRollupJobRequest : PlainRequestBase<GetRollupJobRequestParameters>, IGetRollupJobRequest
	{
		protected IGetRollupJobRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_rollup/job/{id}", "_rollup/job/"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_rollup/job/{id}</summary>
		///<param name = "id">Optional, accepts null</param>
		public GetRollupJobRequest(Id id): base(r => r.Optional("id", id))
		{
		}

		///<summary>/_rollup/job/</summary>
		public GetRollupJobRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Id IGetRollupJobRequest.Id => Self.RouteValues.Get<Id>("id");
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IGetRollupCapabilitiesRequest : IRequest<GetRollupCapabilitiesRequestParameters>
	{
		[IgnoreDataMember]
		Id Id
		{
			get;
		}
	}

	///<summary>Request for GetRollupCapabilities <pre></pre></summary>
	public partial class GetRollupCapabilitiesRequest : PlainRequestBase<GetRollupCapabilitiesRequestParameters>, IGetRollupCapabilitiesRequest
	{
		protected IGetRollupCapabilitiesRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_rollup/data/{id}", "_rollup/data/"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_rollup/data/{id}</summary>
		///<param name = "id">Optional, accepts null</param>
		public GetRollupCapabilitiesRequest(Id id): base(r => r.Optional("id", id))
		{
		}

		///<summary>/_rollup/data/</summary>
		public GetRollupCapabilitiesRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Id IGetRollupCapabilitiesRequest.Id => Self.RouteValues.Get<Id>("id");
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IGetRollupIndexCapabilitiesRequest : IRequest<GetRollupIndexCapabilitiesRequestParameters>
	{
		[IgnoreDataMember]
		IndexName Index
		{
			get;
		}
	}

	///<summary>Request for GetRollupIndexCapabilities <pre></pre></summary>
	public partial class GetRollupIndexCapabilitiesRequest : PlainRequestBase<GetRollupIndexCapabilitiesRequestParameters>, IGetRollupIndexCapabilitiesRequest
	{
		protected IGetRollupIndexCapabilitiesRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"{index}/_rollup/data"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/{index}/_rollup/data</summary>
		///<param name = "index">this parameter is required</param>
		public GetRollupIndexCapabilitiesRequest(IndexName index): base(r => r.Required("index", index))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal GetRollupIndexCapabilitiesRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		IndexName IGetRollupIndexCapabilitiesRequest.Index => Self.RouteValues.Get<IndexName>("index");
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface ICreateRollupJobRequest : IRequest<CreateRollupJobRequestParameters>
	{
		[IgnoreDataMember]
		Id Id
		{
			get;
		}
	}

	///<summary>Request for CreateRollupJob <pre></pre></summary>
	public partial class CreateRollupJobRequest : PlainRequestBase<CreateRollupJobRequestParameters>, ICreateRollupJobRequest
	{
		protected ICreateRollupJobRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_rollup/job/{id}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_rollup/job/{id}</summary>
		///<param name = "id">this parameter is required</param>
		public CreateRollupJobRequest(Id id): base(r => r.Required("id", id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal CreateRollupJobRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Id ICreateRollupJobRequest.Id => Self.RouteValues.Get<Id>("id");
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IRollupSearchRequest : IRequest<RollupSearchRequestParameters>
	{
		[IgnoreDataMember]
		Indices Index
		{
			get;
		}
	}

	///<summary>Request for Search <pre></pre></summary>
	public partial class RollupSearchRequest : PlainRequestBase<RollupSearchRequestParameters>, IRollupSearchRequest
	{
		protected IRollupSearchRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"{index}/_rollup_search"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/{index}/_rollup_search</summary>
		///<param name = "index">this parameter is required</param>
		public RollupSearchRequest(Indices index): base(r => r.Required("index", index))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal RollupSearchRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Indices IRollupSearchRequest.Index => Self.RouteValues.Get<Indices>("index");
		// Request parameters
		///<summary>Indicates whether hits.total should be rendered as an integer or an object in the rest search response</summary>
		public bool? TotalHitsAsInteger
		{
			get => Q<bool? >("rest_total_hits_as_int");
			set => Q("rest_total_hits_as_int", value);
		}

		///<summary>Specify whether aggregation and suggester names should be prefixed by their respective types in the response</summary>
		public bool? TypedKeys
		{
			get => Q<bool? >("typed_keys");
			set => Q("typed_keys", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IStartRollupJobRequest : IRequest<StartRollupJobRequestParameters>
	{
		[IgnoreDataMember]
		Id Id
		{
			get;
		}
	}

	///<summary>Request for StartRollupJob <pre></pre></summary>
	public partial class StartRollupJobRequest : PlainRequestBase<StartRollupJobRequestParameters>, IStartRollupJobRequest
	{
		protected IStartRollupJobRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_rollup/job/{id}/_start"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_rollup/job/{id}/_start</summary>
		///<param name = "id">this parameter is required</param>
		public StartRollupJobRequest(Id id): base(r => r.Required("id", id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal StartRollupJobRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Id IStartRollupJobRequest.Id => Self.RouteValues.Get<Id>("id");
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IStopRollupJobRequest : IRequest<StopRollupJobRequestParameters>
	{
		[IgnoreDataMember]
		Id Id
		{
			get;
		}
	}

	///<summary>Request for StopRollupJob <pre></pre></summary>
	public partial class StopRollupJobRequest : PlainRequestBase<StopRollupJobRequestParameters>, IStopRollupJobRequest
	{
		protected IStopRollupJobRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_rollup/job/{id}/_stop"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_rollup/job/{id}/_stop</summary>
		///<param name = "id">this parameter is required</param>
		public StopRollupJobRequest(Id id): base(r => r.Required("id", id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal StopRollupJobRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Id IStopRollupJobRequest.Id => Self.RouteValues.Get<Id>("id");
		// Request parameters
		///<summary>Block for (at maximum) the specified duration while waiting for the job to stop. Defaults to 30s.</summary>
		public Time Timeout
		{
			get => Q<Time>("timeout");
			set => Q("timeout", value);
		}

		///<summary>True if the API should block until the job has fully stopped, false if should be executed async. Defaults to false.</summary>
		public bool? WaitForCompletion
		{
			get => Q<bool? >("wait_for_completion");
			set => Q("wait_for_completion", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IExecutePainlessScriptRequest : IRequest<ExecutePainlessScriptRequestParameters>
	{
	}

	///<summary>Request for ExecutePainlessScript <pre>https://www.elastic.co/guide/en/elasticsearch/painless/master/painless-execute-api.html</pre></summary>
	public partial class ExecutePainlessScriptRequest : PlainRequestBase<ExecutePainlessScriptRequestParameters>, IExecutePainlessScriptRequest
	{
		protected IExecutePainlessScriptRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_scripts/painless/_execute"});
		internal override ApiUrls ApiUrls => Urls;
	// values part of the url path
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IScrollRequest : IRequest<ScrollRequestParameters>
	{
	}

	///<summary>Request for Scroll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/search-request-scroll.html</pre></summary>
	public partial class ScrollRequest : PlainRequestBase<ScrollRequestParameters>, IScrollRequest
	{
		protected IScrollRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_search/scroll"});
		internal override ApiUrls ApiUrls => Urls;
		// values part of the url path
		// Request parameters
		///<summary>Indicates whether hits.total should be rendered as an integer or an object in the rest search response</summary>
		public bool? TotalHitsAsInteger
		{
			get => Q<bool? >("rest_total_hits_as_int");
			set => Q("rest_total_hits_as_int", value);
		}
	}

	[InterfaceDataContract]
	public partial interface ISearchRequest : IRequest<SearchRequestParameters>
	{
		[IgnoreDataMember]
		Indices Index
		{
			get;
		}

		[DataMember(Name = "docvalue_fields")]
		Fields DocValueFields
		{
			get;
			set;
		}

		[DataMember(Name = "stored_fields")]
		Fields StoredFields
		{
			get;
			set;
		}
	}

	public partial interface ISearchRequest<T> : ISearchRequest
	{
	}

	///<summary>Request for Search <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/search-search.html</pre></summary>
	public partial class SearchRequest : PlainRequestBase<SearchRequestParameters>, ISearchRequest
	{
		protected ISearchRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_search", "{index}/_search"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_search</summary>
		public SearchRequest(): base()
		{
		}

		///<summary>/{index}/_search</summary>
		///<param name = "index">Optional, accepts null</param>
		public SearchRequest(Indices index): base(r => r.Optional("index", index))
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Indices ISearchRequest.Index => Self.RouteValues.Get<Indices>("index");
		// Request parameters
		///<summary>
		/// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have
		/// been specified)
		///</summary>
		public bool? AllowNoIndices
		{
			get => Q<bool? >("allow_no_indices");
			set => Q("allow_no_indices", value);
		}

		///<summary>Indicate if an error should be returned if there is a partial search failure or timeout</summary>
		public bool? AllowPartialSearchResults
		{
			get => Q<bool? >("allow_partial_search_results");
			set => Q("allow_partial_search_results", value);
		}

		///<summary>Specify whether wildcard and prefix queries should be analyzed (default: false)</summary>
		public bool? AnalyzeWildcard
		{
			get => Q<bool? >("analyze_wildcard");
			set => Q("analyze_wildcard", value);
		}

		///<summary>The analyzer to use for the query string</summary>
		public string Analyzer
		{
			get => Q<string>("analyzer");
			set => Q("analyzer", value);
		}

		///<summary>
		/// The number of shard results that should be reduced at once on the coordinating node. This value should be used as a protection mechanism
		/// to reduce the memory overhead per search request if the potential number of shards in the request can be large.
		///</summary>
		public long? BatchedReduceSize
		{
			get => Q<long? >("batched_reduce_size");
			set => Q("batched_reduce_size", value);
		}

		///<summary>Indicates whether network round-trips should be minimized as part of cross-cluster search requests execution</summary>
		public bool? CcsMinimizeRoundtrips
		{
			get => Q<bool? >("ccs_minimize_roundtrips");
			set => Q("ccs_minimize_roundtrips", value);
		}

		///<summary>The default operator for query string query (AND or OR)</summary>
		public DefaultOperator? DefaultOperator
		{
			get => Q<DefaultOperator? >("default_operator");
			set => Q("default_operator", value);
		}

		///<summary>The field to use as default where no field prefix is given in the query string</summary>
		public string Df
		{
			get => Q<string>("df");
			set => Q("df", value);
		}

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ExpandWildcards? ExpandWildcards
		{
			get => Q<ExpandWildcards? >("expand_wildcards");
			set => Q("expand_wildcards", value);
		}

		///<summary>Whether specified concrete, expanded or aliased indices should be ignored when throttled</summary>
		public bool? IgnoreThrottled
		{
			get => Q<bool? >("ignore_throttled");
			set => Q("ignore_throttled", value);
		}

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public bool? IgnoreUnavailable
		{
			get => Q<bool? >("ignore_unavailable");
			set => Q("ignore_unavailable", value);
		}

		///<summary>Specify whether format-based query failures (such as providing text to a numeric field) should be ignored</summary>
		public bool? Lenient
		{
			get => Q<bool? >("lenient");
			set => Q("lenient", value);
		}

		///<summary>
		/// The number of concurrent shard requests per node this search executes concurrently. This value should be used to limit the impact of the
		/// search on the cluster in order to limit the number of concurrent shard requests
		///</summary>
		public long? MaxConcurrentShardRequests
		{
			get => Q<long? >("max_concurrent_shard_requests");
			set => Q("max_concurrent_shard_requests", value);
		}

		///<summary>
		/// A threshold that enforces a pre-filter roundtrip to prefilter search shards based on query rewriting if thenumber of shards the search
		/// request expands to exceeds the threshold. This filter roundtrip can limit the number of shards significantly if for instance a shard can
		/// not match any documents based on it's rewrite method ie. if date filters are mandatory to match but the shard bounds and the query are
		/// disjoint.
		///</summary>
		public long? PreFilterShardSize
		{
			get => Q<long? >("pre_filter_shard_size");
			set => Q("pre_filter_shard_size", value);
		}

		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public string Preference
		{
			get => Q<string>("preference");
			set => Q("preference", value);
		}

		///<summary>Specify if request cache should be used for this request or not, defaults to index level setting</summary>
		public bool? RequestCache
		{
			get => Q<bool? >("request_cache");
			set => Q("request_cache", value);
		}

		///<summary>
		/// A document is routed to a particular shard in an index using the following formula
		/// <para> shard_num = hash(_routing) % num_primary_shards</para>
		/// <para>Elasticsearch will use the document id if not provided. </para>
		/// <para>For requests that are constructed from/for a document NEST will automatically infer the routing key
		/// if that document has a <see cref = "Nest.JoinField"/> or a routing mapping on for its type exists on <see cref = "Nest.ConnectionSettings"
		////></para>
		///</summary>
		public Routing Routing
		{
			get => Q<Routing>("routing");
			set => Q("routing", value);
		}

		///<summary>Specify how long a consistent view of the index should be maintained for scrolled search</summary>
		public Time Scroll
		{
			get => Q<Time>("scroll");
			set => Q("scroll", value);
		}

		///<summary>Search operation type</summary>
		public SearchType? SearchType
		{
			get => Q<SearchType? >("search_type");
			set => Q("search_type", value);
		}

		///<summary>Specify whether to return sequence number and primary term of the last modification of each hit</summary>
		public bool? SequenceNumberPrimaryTerm
		{
			get => Q<bool? >("seq_no_primary_term");
			set => Q("seq_no_primary_term", value);
		}

		///<summary>Specific 'tag' of the request for logging and statistical purposes</summary>
		public string[] Stats
		{
			get => Q<string[]>("stats");
			set => Q("stats", value);
		}

		///<summary>Specify which field to use for suggestions</summary>
		public Field SuggestField
		{
			get => Q<Field>("suggest_field");
			set => Q("suggest_field", value);
		}

		///<summary>Specify suggest mode</summary>
		public SuggestMode? SuggestMode
		{
			get => Q<SuggestMode? >("suggest_mode");
			set => Q("suggest_mode", value);
		}

		///<summary>How many suggestions to return in response</summary>
		public long? SuggestSize
		{
			get => Q<long? >("suggest_size");
			set => Q("suggest_size", value);
		}

		///<summary>The source text for which the suggestions should be returned</summary>
		public string SuggestText
		{
			get => Q<string>("suggest_text");
			set => Q("suggest_text", value);
		}

		///<summary>Indicates whether hits.total should be rendered as an integer or an object in the rest search response</summary>
		public bool? TotalHitsAsInteger
		{
			get => Q<bool? >("rest_total_hits_as_int");
			set => Q("rest_total_hits_as_int", value);
		}

		///<summary>Indicate if the number of documents that match the query should be tracked</summary>
		public bool? TrackTotalHits
		{
			get => Q<bool? >("track_total_hits");
			set => Q("track_total_hits", value);
		}

		///<summary>Specify whether aggregation and suggester names should be prefixed by their respective types in the response</summary>
		public bool? TypedKeys
		{
			get => Q<bool? >("typed_keys");
			set => Q("typed_keys", value);
		}
	}

	public partial class SearchRequest<T> : SearchRequest, ISearchRequest<T>
	{
		protected ISearchRequest<T> TypedSelf => this;
		///<summary>/{index}/_search</summary>
		public SearchRequest(): base(typeof(T))
		{
		}

		///<summary>/{index}/_search</summary>
		///<param name = "index">Optional, accepts null</param>
		public SearchRequest(Indices index): base(index)
		{
		}
	}

	[InterfaceDataContract]
	public partial interface ISearchShardsRequest : IRequest<SearchShardsRequestParameters>
	{
		[IgnoreDataMember]
		Indices Index
		{
			get;
		}
	}

	public partial interface ISearchShardsRequest<T> : ISearchShardsRequest
	{
	}

	///<summary>Request for SearchShards <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/search-shards.html</pre></summary>
	public partial class SearchShardsRequest : PlainRequestBase<SearchShardsRequestParameters>, ISearchShardsRequest
	{
		protected ISearchShardsRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_search_shards", "{index}/_search_shards"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_search_shards</summary>
		public SearchShardsRequest(): base()
		{
		}

		///<summary>/{index}/_search_shards</summary>
		///<param name = "index">Optional, accepts null</param>
		public SearchShardsRequest(Indices index): base(r => r.Optional("index", index))
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Indices ISearchShardsRequest.Index => Self.RouteValues.Get<Indices>("index");
		// Request parameters
		///<summary>
		/// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have
		/// been specified)
		///</summary>
		public bool? AllowNoIndices
		{
			get => Q<bool? >("allow_no_indices");
			set => Q("allow_no_indices", value);
		}

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ExpandWildcards? ExpandWildcards
		{
			get => Q<ExpandWildcards? >("expand_wildcards");
			set => Q("expand_wildcards", value);
		}

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public bool? IgnoreUnavailable
		{
			get => Q<bool? >("ignore_unavailable");
			set => Q("ignore_unavailable", value);
		}

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public bool? Local
		{
			get => Q<bool? >("local");
			set => Q("local", value);
		}

		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public string Preference
		{
			get => Q<string>("preference");
			set => Q("preference", value);
		}

		///<summary>
		/// A document is routed to a particular shard in an index using the following formula
		/// <para> shard_num = hash(_routing) % num_primary_shards</para>
		/// <para>Elasticsearch will use the document id if not provided. </para>
		/// <para>For requests that are constructed from/for a document NEST will automatically infer the routing key
		/// if that document has a <see cref = "Nest.JoinField"/> or a routing mapping on for its type exists on <see cref = "Nest.ConnectionSettings"
		////></para>
		///</summary>
		public Routing Routing
		{
			get => Q<Routing>("routing");
			set => Q("routing", value);
		}
	}

	public partial class SearchShardsRequest<T> : SearchShardsRequest, ISearchShardsRequest<T>
	{
		protected ISearchShardsRequest<T> TypedSelf => this;
		///<summary>/{index}/_search_shards</summary>
		public SearchShardsRequest(): base(typeof(T))
		{
		}

		///<summary>/{index}/_search_shards</summary>
		///<param name = "index">Optional, accepts null</param>
		public SearchShardsRequest(Indices index): base(index)
		{
		}
	}

	[InterfaceDataContract]
	public partial interface ISearchTemplateRequest : IRequest<SearchTemplateRequestParameters>
	{
		[IgnoreDataMember]
		Indices Index
		{
			get;
		}
	}

	///<summary>Request for SearchTemplate <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/search-template.html</pre></summary>
	public partial class SearchTemplateRequest : PlainRequestBase<SearchTemplateRequestParameters>, ISearchTemplateRequest
	{
		protected ISearchTemplateRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_search/template", "{index}/_search/template"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_search/template</summary>
		public SearchTemplateRequest(): base()
		{
		}

		///<summary>/{index}/_search/template</summary>
		///<param name = "index">Optional, accepts null</param>
		public SearchTemplateRequest(Indices index): base(r => r.Optional("index", index))
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Indices ISearchTemplateRequest.Index => Self.RouteValues.Get<Indices>("index");
		// Request parameters
		///<summary>
		/// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have
		/// been specified)
		///</summary>
		public bool? AllowNoIndices
		{
			get => Q<bool? >("allow_no_indices");
			set => Q("allow_no_indices", value);
		}

		///<summary>Indicates whether network round-trips should be minimized as part of cross-cluster search requests execution</summary>
		public bool? CcsMinimizeRoundtrips
		{
			get => Q<bool? >("ccs_minimize_roundtrips");
			set => Q("ccs_minimize_roundtrips", value);
		}

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ExpandWildcards? ExpandWildcards
		{
			get => Q<ExpandWildcards? >("expand_wildcards");
			set => Q("expand_wildcards", value);
		}

		///<summary>Specify whether to return detailed information about score computation as part of a hit</summary>
		public bool? Explain
		{
			get => Q<bool? >("explain");
			set => Q("explain", value);
		}

		///<summary>Whether specified concrete, expanded or aliased indices should be ignored when throttled</summary>
		public bool? IgnoreThrottled
		{
			get => Q<bool? >("ignore_throttled");
			set => Q("ignore_throttled", value);
		}

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public bool? IgnoreUnavailable
		{
			get => Q<bool? >("ignore_unavailable");
			set => Q("ignore_unavailable", value);
		}

		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public string Preference
		{
			get => Q<string>("preference");
			set => Q("preference", value);
		}

		///<summary>Specify whether to profile the query execution</summary>
		public bool? Profile
		{
			get => Q<bool? >("profile");
			set => Q("profile", value);
		}

		///<summary>
		/// A document is routed to a particular shard in an index using the following formula
		/// <para> shard_num = hash(_routing) % num_primary_shards</para>
		/// <para>Elasticsearch will use the document id if not provided. </para>
		/// <para>For requests that are constructed from/for a document NEST will automatically infer the routing key
		/// if that document has a <see cref = "Nest.JoinField"/> or a routing mapping on for its type exists on <see cref = "Nest.ConnectionSettings"
		////></para>
		///</summary>
		public Routing Routing
		{
			get => Q<Routing>("routing");
			set => Q("routing", value);
		}

		///<summary>Specify how long a consistent view of the index should be maintained for scrolled search</summary>
		public Time Scroll
		{
			get => Q<Time>("scroll");
			set => Q("scroll", value);
		}

		///<summary>Search operation type</summary>
		public SearchType? SearchType
		{
			get => Q<SearchType? >("search_type");
			set => Q("search_type", value);
		}

		///<summary>Indicates whether hits.total should be rendered as an integer or an object in the rest search response</summary>
		public bool? TotalHitsAsInteger
		{
			get => Q<bool? >("rest_total_hits_as_int");
			set => Q("rest_total_hits_as_int", value);
		}

		///<summary>Specify whether aggregation and suggester names should be prefixed by their respective types in the response</summary>
		public bool? TypedKeys
		{
			get => Q<bool? >("typed_keys");
			set => Q("typed_keys", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IAuthenticateRequest : IRequest<AuthenticateRequestParameters>
	{
	}

	///<summary>Request for Authenticate <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-authenticate.html</pre></summary>
	public partial class AuthenticateRequest : PlainRequestBase<AuthenticateRequestParameters>, IAuthenticateRequest
	{
		protected IAuthenticateRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_security/_authenticate"});
		internal override ApiUrls ApiUrls => Urls;
	// values part of the url path
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IChangePasswordRequest : IRequest<ChangePasswordRequestParameters>
	{
		[IgnoreDataMember]
		Name Username
		{
			get;
		}
	}

	///<summary>Request for ChangePassword <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-change-password.html</pre></summary>
	public partial class ChangePasswordRequest : PlainRequestBase<ChangePasswordRequestParameters>, IChangePasswordRequest
	{
		protected IChangePasswordRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_security/user/{username}/_password", "_security/user/_password"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_security/user/{username}/_password</summary>
		///<param name = "username">Optional, accepts null</param>
		public ChangePasswordRequest(Name username): base(r => r.Optional("username", username))
		{
		}

		///<summary>/_security/user/_password</summary>
		public ChangePasswordRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Name IChangePasswordRequest.Username => Self.RouteValues.Get<Name>("username");
		// Request parameters
		///<summary>
		/// If `true` (the default) then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh
		/// to make this operation visible to search, if `false` then do nothing with refreshes.
		///</summary>
		public Refresh? Refresh
		{
			get => Q<Refresh? >("refresh");
			set => Q("refresh", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IClearCachedRealmsRequest : IRequest<ClearCachedRealmsRequestParameters>
	{
		[IgnoreDataMember]
		Names Realms
		{
			get;
		}
	}

	///<summary>Request for ClearCachedRealms <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-clear-cache.html</pre></summary>
	public partial class ClearCachedRealmsRequest : PlainRequestBase<ClearCachedRealmsRequestParameters>, IClearCachedRealmsRequest
	{
		protected IClearCachedRealmsRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_security/realm/{realms}/_clear_cache"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_security/realm/{realms}/_clear_cache</summary>
		///<param name = "realms">this parameter is required</param>
		public ClearCachedRealmsRequest(Names realms): base(r => r.Required("realms", realms))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal ClearCachedRealmsRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Names IClearCachedRealmsRequest.Realms => Self.RouteValues.Get<Names>("realms");
		// Request parameters
		///<summary>Comma-separated list of usernames to clear from the cache</summary>
		public string[] Usernames
		{
			get => Q<string[]>("usernames");
			set => Q("usernames", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IClearCachedRolesRequest : IRequest<ClearCachedRolesRequestParameters>
	{
		[IgnoreDataMember]
		Names Name
		{
			get;
		}
	}

	///<summary>Request for ClearCachedRoles <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-clear-role-cache.html</pre></summary>
	public partial class ClearCachedRolesRequest : PlainRequestBase<ClearCachedRolesRequestParameters>, IClearCachedRolesRequest
	{
		protected IClearCachedRolesRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_security/role/{name}/_clear_cache"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_security/role/{name}/_clear_cache</summary>
		///<param name = "name">this parameter is required</param>
		public ClearCachedRolesRequest(Names name): base(r => r.Required("name", name))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal ClearCachedRolesRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Names IClearCachedRolesRequest.Name => Self.RouteValues.Get<Names>("name");
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface ICreateApiKeyRequest : IRequest<CreateApiKeyRequestParameters>
	{
	}

	///<summary>Request for CreateApiKey <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-create-api-key.html</pre></summary>
	public partial class CreateApiKeyRequest : PlainRequestBase<CreateApiKeyRequestParameters>, ICreateApiKeyRequest
	{
		protected ICreateApiKeyRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_security/api_key"});
		internal override ApiUrls ApiUrls => Urls;
		// values part of the url path
		// Request parameters
		///<summary>
		/// If `true` (the default) then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh
		/// to make this operation visible to search, if `false` then do nothing with refreshes.
		///</summary>
		public Refresh? Refresh
		{
			get => Q<Refresh? >("refresh");
			set => Q("refresh", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IDeletePrivilegesRequest : IRequest<DeletePrivilegesRequestParameters>
	{
		[IgnoreDataMember]
		Name Application
		{
			get;
		}

		[IgnoreDataMember]
		Name Name
		{
			get;
		}
	}

	///<summary>Request for DeletePrivileges <pre>TODO</pre></summary>
	public partial class DeletePrivilegesRequest : PlainRequestBase<DeletePrivilegesRequestParameters>, IDeletePrivilegesRequest
	{
		protected IDeletePrivilegesRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_security/privilege/{application}/{name}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_security/privilege/{application}/{name}</summary>
		///<param name = "application">this parameter is required</param>
		///<param name = "name">this parameter is required</param>
		public DeletePrivilegesRequest(Name application, Name name): base(r => r.Required("application", application).Required("name", name))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal DeletePrivilegesRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Name IDeletePrivilegesRequest.Application => Self.RouteValues.Get<Name>("application");
		[IgnoreDataMember]
		Name IDeletePrivilegesRequest.Name => Self.RouteValues.Get<Name>("name");
		// Request parameters
		///<summary>
		/// If `true` (the default) then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh
		/// to make this operation visible to search, if `false` then do nothing with refreshes.
		///</summary>
		public Refresh? Refresh
		{
			get => Q<Refresh? >("refresh");
			set => Q("refresh", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IDeleteRoleRequest : IRequest<DeleteRoleRequestParameters>
	{
		[IgnoreDataMember]
		Name Name
		{
			get;
		}
	}

	///<summary>Request for DeleteRole <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-delete-role.html</pre></summary>
	public partial class DeleteRoleRequest : PlainRequestBase<DeleteRoleRequestParameters>, IDeleteRoleRequest
	{
		protected IDeleteRoleRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_security/role/{name}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_security/role/{name}</summary>
		///<param name = "name">this parameter is required</param>
		public DeleteRoleRequest(Name name): base(r => r.Required("name", name))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal DeleteRoleRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Name IDeleteRoleRequest.Name => Self.RouteValues.Get<Name>("name");
		// Request parameters
		///<summary>
		/// If `true` (the default) then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh
		/// to make this operation visible to search, if `false` then do nothing with refreshes.
		///</summary>
		public Refresh? Refresh
		{
			get => Q<Refresh? >("refresh");
			set => Q("refresh", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IDeleteRoleMappingRequest : IRequest<DeleteRoleMappingRequestParameters>
	{
		[IgnoreDataMember]
		Name Name
		{
			get;
		}
	}

	///<summary>Request for DeleteRoleMapping <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-delete-role-mapping.html</pre></summary>
	public partial class DeleteRoleMappingRequest : PlainRequestBase<DeleteRoleMappingRequestParameters>, IDeleteRoleMappingRequest
	{
		protected IDeleteRoleMappingRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_security/role_mapping/{name}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_security/role_mapping/{name}</summary>
		///<param name = "name">this parameter is required</param>
		public DeleteRoleMappingRequest(Name name): base(r => r.Required("name", name))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal DeleteRoleMappingRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Name IDeleteRoleMappingRequest.Name => Self.RouteValues.Get<Name>("name");
		// Request parameters
		///<summary>
		/// If `true` (the default) then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh
		/// to make this operation visible to search, if `false` then do nothing with refreshes.
		///</summary>
		public Refresh? Refresh
		{
			get => Q<Refresh? >("refresh");
			set => Q("refresh", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IDeleteUserRequest : IRequest<DeleteUserRequestParameters>
	{
		[IgnoreDataMember]
		Name Username
		{
			get;
		}
	}

	///<summary>Request for DeleteUser <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-delete-user.html</pre></summary>
	public partial class DeleteUserRequest : PlainRequestBase<DeleteUserRequestParameters>, IDeleteUserRequest
	{
		protected IDeleteUserRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_security/user/{username}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_security/user/{username}</summary>
		///<param name = "username">this parameter is required</param>
		public DeleteUserRequest(Name username): base(r => r.Required("username", username))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal DeleteUserRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Name IDeleteUserRequest.Username => Self.RouteValues.Get<Name>("username");
		// Request parameters
		///<summary>
		/// If `true` (the default) then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh
		/// to make this operation visible to search, if `false` then do nothing with refreshes.
		///</summary>
		public Refresh? Refresh
		{
			get => Q<Refresh? >("refresh");
			set => Q("refresh", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IDisableUserRequest : IRequest<DisableUserRequestParameters>
	{
		[IgnoreDataMember]
		Name Username
		{
			get;
		}
	}

	///<summary>Request for DisableUser <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-disable-user.html</pre></summary>
	public partial class DisableUserRequest : PlainRequestBase<DisableUserRequestParameters>, IDisableUserRequest
	{
		protected IDisableUserRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_security/user/{username}/_disable"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_security/user/{username}/_disable</summary>
		///<param name = "username">this parameter is required</param>
		public DisableUserRequest(Name username): base(r => r.Required("username", username))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal DisableUserRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Name IDisableUserRequest.Username => Self.RouteValues.Get<Name>("username");
		// Request parameters
		///<summary>
		/// If `true` (the default) then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh
		/// to make this operation visible to search, if `false` then do nothing with refreshes.
		///</summary>
		public Refresh? Refresh
		{
			get => Q<Refresh? >("refresh");
			set => Q("refresh", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IEnableUserRequest : IRequest<EnableUserRequestParameters>
	{
		[IgnoreDataMember]
		Name Username
		{
			get;
		}
	}

	///<summary>Request for EnableUser <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-enable-user.html</pre></summary>
	public partial class EnableUserRequest : PlainRequestBase<EnableUserRequestParameters>, IEnableUserRequest
	{
		protected IEnableUserRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_security/user/{username}/_enable"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_security/user/{username}/_enable</summary>
		///<param name = "username">this parameter is required</param>
		public EnableUserRequest(Name username): base(r => r.Required("username", username))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal EnableUserRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Name IEnableUserRequest.Username => Self.RouteValues.Get<Name>("username");
		// Request parameters
		///<summary>
		/// If `true` (the default) then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh
		/// to make this operation visible to search, if `false` then do nothing with refreshes.
		///</summary>
		public Refresh? Refresh
		{
			get => Q<Refresh? >("refresh");
			set => Q("refresh", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IGetApiKeyRequest : IRequest<GetApiKeyRequestParameters>
	{
	}

	///<summary>Request for GetApiKey <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-get-api-key.html</pre></summary>
	public partial class GetApiKeyRequest : PlainRequestBase<GetApiKeyRequestParameters>, IGetApiKeyRequest
	{
		protected IGetApiKeyRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_security/api_key"});
		internal override ApiUrls ApiUrls => Urls;
		// values part of the url path
		// Request parameters
		///<summary>API key id of the API key to be retrieved</summary>
		public string Id
		{
			get => Q<string>("id");
			set => Q("id", value);
		}

		///<summary>API key name of the API key to be retrieved</summary>
		public string Name
		{
			get => Q<string>("name");
			set => Q("name", value);
		}

		///<summary>realm name of the user who created this API key to be retrieved</summary>
		public string RealmName
		{
			get => Q<string>("realm_name");
			set => Q("realm_name", value);
		}

		///<summary>user name of the user who created this API key to be retrieved</summary>
		public string Username
		{
			get => Q<string>("username");
			set => Q("username", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IGetPrivilegesRequest : IRequest<GetPrivilegesRequestParameters>
	{
		[IgnoreDataMember]
		Name Application
		{
			get;
		}

		[IgnoreDataMember]
		Name Name
		{
			get;
		}
	}

	///<summary>Request for GetPrivileges <pre>TODO</pre></summary>
	public partial class GetPrivilegesRequest : PlainRequestBase<GetPrivilegesRequestParameters>, IGetPrivilegesRequest
	{
		protected IGetPrivilegesRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_security/privilege", "_security/privilege/{application}", "_security/privilege/{application}/{name}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_security/privilege</summary>
		public GetPrivilegesRequest(): base()
		{
		}

		///<summary>/_security/privilege/{application}</summary>
		///<param name = "application">Optional, accepts null</param>
		public GetPrivilegesRequest(Name application): base(r => r.Optional("application", application))
		{
		}

		///<summary>/_security/privilege/{application}/{name}</summary>
		///<param name = "application">Optional, accepts null</param>
		///<param name = "name">Optional, accepts null</param>
		public GetPrivilegesRequest(Name application, Name name): base(r => r.Optional("application", application).Optional("name", name))
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Name IGetPrivilegesRequest.Application => Self.RouteValues.Get<Name>("application");
		[IgnoreDataMember]
		Name IGetPrivilegesRequest.Name => Self.RouteValues.Get<Name>("name");
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IGetRoleRequest : IRequest<GetRoleRequestParameters>
	{
		[IgnoreDataMember]
		Name Name
		{
			get;
		}
	}

	///<summary>Request for GetRole <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-get-role.html</pre></summary>
	public partial class GetRoleRequest : PlainRequestBase<GetRoleRequestParameters>, IGetRoleRequest
	{
		protected IGetRoleRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_security/role/{name}", "_security/role"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_security/role/{name}</summary>
		///<param name = "name">Optional, accepts null</param>
		public GetRoleRequest(Name name): base(r => r.Optional("name", name))
		{
		}

		///<summary>/_security/role</summary>
		public GetRoleRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Name IGetRoleRequest.Name => Self.RouteValues.Get<Name>("name");
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IGetRoleMappingRequest : IRequest<GetRoleMappingRequestParameters>
	{
		[IgnoreDataMember]
		Name Name
		{
			get;
		}
	}

	///<summary>Request for GetRoleMapping <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-get-role-mapping.html</pre></summary>
	public partial class GetRoleMappingRequest : PlainRequestBase<GetRoleMappingRequestParameters>, IGetRoleMappingRequest
	{
		protected IGetRoleMappingRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_security/role_mapping/{name}", "_security/role_mapping"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_security/role_mapping/{name}</summary>
		///<param name = "name">Optional, accepts null</param>
		public GetRoleMappingRequest(Name name): base(r => r.Optional("name", name))
		{
		}

		///<summary>/_security/role_mapping</summary>
		public GetRoleMappingRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Name IGetRoleMappingRequest.Name => Self.RouteValues.Get<Name>("name");
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IGetUserAccessTokenRequest : IRequest<GetUserAccessTokenRequestParameters>
	{
	}

	///<summary>Request for GetUserAccessToken <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-get-token.html</pre></summary>
	public partial class GetUserAccessTokenRequest : PlainRequestBase<GetUserAccessTokenRequestParameters>, IGetUserAccessTokenRequest
	{
		protected IGetUserAccessTokenRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_security/oauth2/token"});
		internal override ApiUrls ApiUrls => Urls;
	// values part of the url path
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IGetUserRequest : IRequest<GetUserRequestParameters>
	{
		[IgnoreDataMember]
		Names Username
		{
			get;
		}
	}

	///<summary>Request for GetUser <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-get-user.html</pre></summary>
	public partial class GetUserRequest : PlainRequestBase<GetUserRequestParameters>, IGetUserRequest
	{
		protected IGetUserRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_security/user/{username}", "_security/user"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_security/user/{username}</summary>
		///<param name = "username">Optional, accepts null</param>
		public GetUserRequest(Names username): base(r => r.Optional("username", username))
		{
		}

		///<summary>/_security/user</summary>
		public GetUserRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Names IGetUserRequest.Username => Self.RouteValues.Get<Names>("username");
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IGetUserPrivilegesRequest : IRequest<GetUserPrivilegesRequestParameters>
	{
	}

	///<summary>Request for GetUserPrivileges <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-get-user-privileges.html</pre></summary>
	public partial class GetUserPrivilegesRequest : PlainRequestBase<GetUserPrivilegesRequestParameters>, IGetUserPrivilegesRequest
	{
		protected IGetUserPrivilegesRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_security/user/_privileges"});
		internal override ApiUrls ApiUrls => Urls;
	// values part of the url path
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IHasPrivilegesRequest : IRequest<HasPrivilegesRequestParameters>
	{
		[IgnoreDataMember]
		Name User
		{
			get;
		}
	}

	///<summary>Request for HasPrivileges <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-has-privileges.html</pre></summary>
	public partial class HasPrivilegesRequest : PlainRequestBase<HasPrivilegesRequestParameters>, IHasPrivilegesRequest
	{
		protected IHasPrivilegesRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_security/user/_has_privileges", "_security/user/{user}/_has_privileges"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_security/user/_has_privileges</summary>
		public HasPrivilegesRequest(): base()
		{
		}

		///<summary>/_security/user/{user}/_has_privileges</summary>
		///<param name = "user">Optional, accepts null</param>
		public HasPrivilegesRequest(Name user): base(r => r.Optional("user", user))
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Name IHasPrivilegesRequest.User => Self.RouteValues.Get<Name>("user");
	// Request parameters
	//TODO THIS METHOD IS UNMAPPED! Expected to find HasPrivilegesDescriptor and HasPrivilegesRequest in a file called HasPrivilegesRequest.cs in NEST's codebase
	}

	[InterfaceDataContract]
	public partial interface IInvalidateApiKeyRequest : IRequest<InvalidateApiKeyRequestParameters>
	{
	}

	///<summary>Request for InvalidateApiKey <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-invalidate-api-key.html</pre></summary>
	public partial class InvalidateApiKeyRequest : PlainRequestBase<InvalidateApiKeyRequestParameters>, IInvalidateApiKeyRequest
	{
		protected IInvalidateApiKeyRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_security/api_key"});
		internal override ApiUrls ApiUrls => Urls;
	// values part of the url path
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IInvalidateUserAccessTokenRequest : IRequest<InvalidateUserAccessTokenRequestParameters>
	{
	}

	///<summary>Request for InvalidateUserAccessToken <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-invalidate-token.html</pre></summary>
	public partial class InvalidateUserAccessTokenRequest : PlainRequestBase<InvalidateUserAccessTokenRequestParameters>, IInvalidateUserAccessTokenRequest
	{
		protected IInvalidateUserAccessTokenRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_security/oauth2/token"});
		internal override ApiUrls ApiUrls => Urls;
	// values part of the url path
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IPutPrivilegesRequest : IRequest<PutPrivilegesRequestParameters>
	{
	}

	///<summary>Request for PutPrivileges <pre>TODO</pre></summary>
	public partial class PutPrivilegesRequest : PlainRequestBase<PutPrivilegesRequestParameters>, IPutPrivilegesRequest
	{
		protected IPutPrivilegesRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_security/privilege/"});
		internal override ApiUrls ApiUrls => Urls;
		// values part of the url path
		// Request parameters
		///<summary>
		/// If `true` (the default) then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh
		/// to make this operation visible to search, if `false` then do nothing with refreshes.
		///</summary>
		public Refresh? Refresh
		{
			get => Q<Refresh? >("refresh");
			set => Q("refresh", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IPutRoleRequest : IRequest<PutRoleRequestParameters>
	{
		[IgnoreDataMember]
		Name Name
		{
			get;
		}
	}

	///<summary>Request for PutRole <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-put-role.html</pre></summary>
	public partial class PutRoleRequest : PlainRequestBase<PutRoleRequestParameters>, IPutRoleRequest
	{
		protected IPutRoleRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_security/role/{name}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_security/role/{name}</summary>
		///<param name = "name">this parameter is required</param>
		public PutRoleRequest(Name name): base(r => r.Required("name", name))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal PutRoleRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Name IPutRoleRequest.Name => Self.RouteValues.Get<Name>("name");
		// Request parameters
		///<summary>
		/// If `true` (the default) then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh
		/// to make this operation visible to search, if `false` then do nothing with refreshes.
		///</summary>
		public Refresh? Refresh
		{
			get => Q<Refresh? >("refresh");
			set => Q("refresh", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IPutRoleMappingRequest : IRequest<PutRoleMappingRequestParameters>
	{
		[IgnoreDataMember]
		Name Name
		{
			get;
		}
	}

	///<summary>Request for PutRoleMapping <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-put-role-mapping.html</pre></summary>
	public partial class PutRoleMappingRequest : PlainRequestBase<PutRoleMappingRequestParameters>, IPutRoleMappingRequest
	{
		protected IPutRoleMappingRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_security/role_mapping/{name}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_security/role_mapping/{name}</summary>
		///<param name = "name">this parameter is required</param>
		public PutRoleMappingRequest(Name name): base(r => r.Required("name", name))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal PutRoleMappingRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Name IPutRoleMappingRequest.Name => Self.RouteValues.Get<Name>("name");
		// Request parameters
		///<summary>
		/// If `true` (the default) then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh
		/// to make this operation visible to search, if `false` then do nothing with refreshes.
		///</summary>
		public Refresh? Refresh
		{
			get => Q<Refresh? >("refresh");
			set => Q("refresh", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IPutUserRequest : IRequest<PutUserRequestParameters>
	{
		[IgnoreDataMember]
		Name Username
		{
			get;
		}
	}

	///<summary>Request for PutUser <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-put-user.html</pre></summary>
	public partial class PutUserRequest : PlainRequestBase<PutUserRequestParameters>, IPutUserRequest
	{
		protected IPutUserRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_security/user/{username}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_security/user/{username}</summary>
		///<param name = "username">this parameter is required</param>
		public PutUserRequest(Name username): base(r => r.Required("username", username))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal PutUserRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Name IPutUserRequest.Username => Self.RouteValues.Get<Name>("username");
		// Request parameters
		///<summary>
		/// If `true` (the default) then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh
		/// to make this operation visible to search, if `false` then do nothing with refreshes.
		///</summary>
		public Refresh? Refresh
		{
			get => Q<Refresh? >("refresh");
			set => Q("refresh", value);
		}
	}

	[InterfaceDataContract]
	public partial interface ISnapshotRequest : IRequest<SnapshotRequestParameters>
	{
		[IgnoreDataMember]
		Name RepositoryName
		{
			get;
		}

		[IgnoreDataMember]
		Name Snapshot
		{
			get;
		}
	}

	///<summary>Request for Snapshot <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-snapshots.html</pre></summary>
	public partial class SnapshotRequest : PlainRequestBase<SnapshotRequestParameters>, ISnapshotRequest
	{
		protected ISnapshotRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_snapshot/{repository}/{snapshot}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_snapshot/{repository}/{snapshot}</summary>
		///<param name = "repository">this parameter is required</param>
		///<param name = "snapshot">this parameter is required</param>
		public SnapshotRequest(Name repository, Name snapshot): base(r => r.Required("repository", repository).Required("snapshot", snapshot))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal SnapshotRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Name ISnapshotRequest.RepositoryName => Self.RouteValues.Get<Name>("repository");
		[IgnoreDataMember]
		Name ISnapshotRequest.Snapshot => Self.RouteValues.Get<Name>("snapshot");
		// Request parameters
		///<summary>Explicit operation timeout for connection to master node</summary>
		public Time MasterTimeout
		{
			get => Q<Time>("master_timeout");
			set => Q("master_timeout", value);
		}

		///<summary>Should this request wait until the operation has completed before returning</summary>
		public bool? WaitForCompletion
		{
			get => Q<bool? >("wait_for_completion");
			set => Q("wait_for_completion", value);
		}
	}

	[InterfaceDataContract]
	public partial interface ICreateRepositoryRequest : IRequest<CreateRepositoryRequestParameters>
	{
		[IgnoreDataMember]
		Name RepositoryName
		{
			get;
		}
	}

	///<summary>Request for CreateRepository <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-snapshots.html</pre></summary>
	public partial class CreateRepositoryRequest : PlainRequestBase<CreateRepositoryRequestParameters>, ICreateRepositoryRequest
	{
		protected ICreateRepositoryRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_snapshot/{repository}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_snapshot/{repository}</summary>
		///<param name = "repository">this parameter is required</param>
		public CreateRepositoryRequest(Name repository): base(r => r.Required("repository", repository))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal CreateRepositoryRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Name ICreateRepositoryRequest.RepositoryName => Self.RouteValues.Get<Name>("repository");
		// Request parameters
		///<summary>Explicit operation timeout for connection to master node</summary>
		public Time MasterTimeout
		{
			get => Q<Time>("master_timeout");
			set => Q("master_timeout", value);
		}

		///<summary>Explicit operation timeout</summary>
		public Time Timeout
		{
			get => Q<Time>("timeout");
			set => Q("timeout", value);
		}

		///<summary>Whether to verify the repository after creation</summary>
		public bool? Verify
		{
			get => Q<bool? >("verify");
			set => Q("verify", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IDeleteSnapshotRequest : IRequest<DeleteSnapshotRequestParameters>
	{
		[IgnoreDataMember]
		Name RepositoryName
		{
			get;
		}

		[IgnoreDataMember]
		Name Snapshot
		{
			get;
		}
	}

	///<summary>Request for DeleteSnapshot <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-snapshots.html</pre></summary>
	public partial class DeleteSnapshotRequest : PlainRequestBase<DeleteSnapshotRequestParameters>, IDeleteSnapshotRequest
	{
		protected IDeleteSnapshotRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_snapshot/{repository}/{snapshot}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_snapshot/{repository}/{snapshot}</summary>
		///<param name = "repository">this parameter is required</param>
		///<param name = "snapshot">this parameter is required</param>
		public DeleteSnapshotRequest(Name repository, Name snapshot): base(r => r.Required("repository", repository).Required("snapshot", snapshot))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal DeleteSnapshotRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Name IDeleteSnapshotRequest.RepositoryName => Self.RouteValues.Get<Name>("repository");
		[IgnoreDataMember]
		Name IDeleteSnapshotRequest.Snapshot => Self.RouteValues.Get<Name>("snapshot");
		// Request parameters
		///<summary>Explicit operation timeout for connection to master node</summary>
		public Time MasterTimeout
		{
			get => Q<Time>("master_timeout");
			set => Q("master_timeout", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IDeleteRepositoryRequest : IRequest<DeleteRepositoryRequestParameters>
	{
		[IgnoreDataMember]
		Names RepositoryName
		{
			get;
		}
	}

	///<summary>Request for DeleteRepository <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-snapshots.html</pre></summary>
	public partial class DeleteRepositoryRequest : PlainRequestBase<DeleteRepositoryRequestParameters>, IDeleteRepositoryRequest
	{
		protected IDeleteRepositoryRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_snapshot/{repository}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_snapshot/{repository}</summary>
		///<param name = "repository">this parameter is required</param>
		public DeleteRepositoryRequest(Names repository): base(r => r.Required("repository", repository))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal DeleteRepositoryRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Names IDeleteRepositoryRequest.RepositoryName => Self.RouteValues.Get<Names>("repository");
		// Request parameters
		///<summary>Explicit operation timeout for connection to master node</summary>
		public Time MasterTimeout
		{
			get => Q<Time>("master_timeout");
			set => Q("master_timeout", value);
		}

		///<summary>Explicit operation timeout</summary>
		public Time Timeout
		{
			get => Q<Time>("timeout");
			set => Q("timeout", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IGetSnapshotRequest : IRequest<GetSnapshotRequestParameters>
	{
		[IgnoreDataMember]
		Name RepositoryName
		{
			get;
		}

		[IgnoreDataMember]
		Names Snapshot
		{
			get;
		}
	}

	///<summary>Request for GetSnapshot <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-snapshots.html</pre></summary>
	public partial class GetSnapshotRequest : PlainRequestBase<GetSnapshotRequestParameters>, IGetSnapshotRequest
	{
		protected IGetSnapshotRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_snapshot/{repository}/{snapshot}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_snapshot/{repository}/{snapshot}</summary>
		///<param name = "repository">this parameter is required</param>
		///<param name = "snapshot">this parameter is required</param>
		public GetSnapshotRequest(Name repository, Names snapshot): base(r => r.Required("repository", repository).Required("snapshot", snapshot))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal GetSnapshotRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Name IGetSnapshotRequest.RepositoryName => Self.RouteValues.Get<Name>("repository");
		[IgnoreDataMember]
		Names IGetSnapshotRequest.Snapshot => Self.RouteValues.Get<Names>("snapshot");
		// Request parameters
		///<summary>Whether to ignore unavailable snapshots, defaults to false which means a SnapshotMissingException is thrown</summary>
		public bool? IgnoreUnavailable
		{
			get => Q<bool? >("ignore_unavailable");
			set => Q("ignore_unavailable", value);
		}

		///<summary>Explicit operation timeout for connection to master node</summary>
		public Time MasterTimeout
		{
			get => Q<Time>("master_timeout");
			set => Q("master_timeout", value);
		}

		///<summary>Whether to show verbose snapshot info or only show the basic info found in the repository index blob</summary>
		public bool? Verbose
		{
			get => Q<bool? >("verbose");
			set => Q("verbose", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IGetRepositoryRequest : IRequest<GetRepositoryRequestParameters>
	{
		[IgnoreDataMember]
		Names RepositoryName
		{
			get;
		}
	}

	///<summary>Request for GetRepository <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-snapshots.html</pre></summary>
	public partial class GetRepositoryRequest : PlainRequestBase<GetRepositoryRequestParameters>, IGetRepositoryRequest
	{
		protected IGetRepositoryRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_snapshot", "_snapshot/{repository}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_snapshot</summary>
		public GetRepositoryRequest(): base()
		{
		}

		///<summary>/_snapshot/{repository}</summary>
		///<param name = "repository">Optional, accepts null</param>
		public GetRepositoryRequest(Names repository): base(r => r.Optional("repository", repository))
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Names IGetRepositoryRequest.RepositoryName => Self.RouteValues.Get<Names>("repository");
		// Request parameters
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public bool? Local
		{
			get => Q<bool? >("local");
			set => Q("local", value);
		}

		///<summary>Explicit operation timeout for connection to master node</summary>
		public Time MasterTimeout
		{
			get => Q<Time>("master_timeout");
			set => Q("master_timeout", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IRestoreRequest : IRequest<RestoreRequestParameters>
	{
		[IgnoreDataMember]
		Name RepositoryName
		{
			get;
		}

		[IgnoreDataMember]
		Name Snapshot
		{
			get;
		}
	}

	///<summary>Request for Restore <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-snapshots.html</pre></summary>
	public partial class RestoreRequest : PlainRequestBase<RestoreRequestParameters>, IRestoreRequest
	{
		protected IRestoreRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_snapshot/{repository}/{snapshot}/_restore"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_snapshot/{repository}/{snapshot}/_restore</summary>
		///<param name = "repository">this parameter is required</param>
		///<param name = "snapshot">this parameter is required</param>
		public RestoreRequest(Name repository, Name snapshot): base(r => r.Required("repository", repository).Required("snapshot", snapshot))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal RestoreRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Name IRestoreRequest.RepositoryName => Self.RouteValues.Get<Name>("repository");
		[IgnoreDataMember]
		Name IRestoreRequest.Snapshot => Self.RouteValues.Get<Name>("snapshot");
		// Request parameters
		///<summary>Explicit operation timeout for connection to master node</summary>
		public Time MasterTimeout
		{
			get => Q<Time>("master_timeout");
			set => Q("master_timeout", value);
		}

		///<summary>Should this request wait until the operation has completed before returning</summary>
		public bool? WaitForCompletion
		{
			get => Q<bool? >("wait_for_completion");
			set => Q("wait_for_completion", value);
		}
	}

	[InterfaceDataContract]
	public partial interface ISnapshotStatusRequest : IRequest<SnapshotStatusRequestParameters>
	{
		[IgnoreDataMember]
		Name RepositoryName
		{
			get;
		}

		[IgnoreDataMember]
		Names Snapshot
		{
			get;
		}
	}

	///<summary>Request for Status <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-snapshots.html</pre></summary>
	public partial class SnapshotStatusRequest : PlainRequestBase<SnapshotStatusRequestParameters>, ISnapshotStatusRequest
	{
		protected ISnapshotStatusRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_snapshot/_status", "_snapshot/{repository}/_status", "_snapshot/{repository}/{snapshot}/_status"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_snapshot/_status</summary>
		public SnapshotStatusRequest(): base()
		{
		}

		///<summary>/_snapshot/{repository}/_status</summary>
		///<param name = "repository">Optional, accepts null</param>
		public SnapshotStatusRequest(Name repository): base(r => r.Optional("repository", repository))
		{
		}

		///<summary>/_snapshot/{repository}/{snapshot}/_status</summary>
		///<param name = "repository">Optional, accepts null</param>
		///<param name = "snapshot">Optional, accepts null</param>
		public SnapshotStatusRequest(Name repository, Names snapshot): base(r => r.Optional("repository", repository).Optional("snapshot", snapshot))
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Name ISnapshotStatusRequest.RepositoryName => Self.RouteValues.Get<Name>("repository");
		[IgnoreDataMember]
		Names ISnapshotStatusRequest.Snapshot => Self.RouteValues.Get<Names>("snapshot");
		// Request parameters
		///<summary>Whether to ignore unavailable snapshots, defaults to false which means a SnapshotMissingException is thrown</summary>
		public bool? IgnoreUnavailable
		{
			get => Q<bool? >("ignore_unavailable");
			set => Q("ignore_unavailable", value);
		}

		///<summary>Explicit operation timeout for connection to master node</summary>
		public Time MasterTimeout
		{
			get => Q<Time>("master_timeout");
			set => Q("master_timeout", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IVerifyRepositoryRequest : IRequest<VerifyRepositoryRequestParameters>
	{
		[IgnoreDataMember]
		Name RepositoryName
		{
			get;
		}
	}

	///<summary>Request for VerifyRepository <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-snapshots.html</pre></summary>
	public partial class VerifyRepositoryRequest : PlainRequestBase<VerifyRepositoryRequestParameters>, IVerifyRepositoryRequest
	{
		protected IVerifyRepositoryRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_snapshot/{repository}/_verify"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_snapshot/{repository}/_verify</summary>
		///<param name = "repository">this parameter is required</param>
		public VerifyRepositoryRequest(Name repository): base(r => r.Required("repository", repository))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal VerifyRepositoryRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Name IVerifyRepositoryRequest.RepositoryName => Self.RouteValues.Get<Name>("repository");
		// Request parameters
		///<summary>Explicit operation timeout for connection to master node</summary>
		public Time MasterTimeout
		{
			get => Q<Time>("master_timeout");
			set => Q("master_timeout", value);
		}

		///<summary>Explicit operation timeout</summary>
		public Time Timeout
		{
			get => Q<Time>("timeout");
			set => Q("timeout", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IClearSqlCursorRequest : IRequest<ClearSqlCursorRequestParameters>
	{
	}

	///<summary>Request for ClearSqlCursor <pre>Clear SQL cursor</pre></summary>
	public partial class ClearSqlCursorRequest : PlainRequestBase<ClearSqlCursorRequestParameters>, IClearSqlCursorRequest
	{
		protected IClearSqlCursorRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_sql/close"});
		internal override ApiUrls ApiUrls => Urls;
	// values part of the url path
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IQuerySqlRequest : IRequest<QuerySqlRequestParameters>
	{
	}

	///<summary>Request for QuerySql <pre>Execute SQL</pre></summary>
	public partial class QuerySqlRequest : PlainRequestBase<QuerySqlRequestParameters>, IQuerySqlRequest
	{
		protected IQuerySqlRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_sql"});
		internal override ApiUrls ApiUrls => Urls;
		// values part of the url path
		// Request parameters
		///<summary>a short version of the Accept header, e.g. json, yaml</summary>
		public string Format
		{
			get => Q<string>("format");
			set => Q("format", value);
		}
	}

	[InterfaceDataContract]
	public partial interface ITranslateSqlRequest : IRequest<TranslateSqlRequestParameters>
	{
	}

	///<summary>Request for TranslateSql <pre>Translate SQL into Elasticsearch queries</pre></summary>
	public partial class TranslateSqlRequest : PlainRequestBase<TranslateSqlRequestParameters>, ITranslateSqlRequest
	{
		protected ITranslateSqlRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_sql/translate"});
		internal override ApiUrls ApiUrls => Urls;
	// values part of the url path
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IGetCertificatesRequest : IRequest<GetCertificatesRequestParameters>
	{
	}

	///<summary>Request for GetCertificates <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-ssl.html</pre></summary>
	public partial class GetCertificatesRequest : PlainRequestBase<GetCertificatesRequestParameters>, IGetCertificatesRequest
	{
		protected IGetCertificatesRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_ssl/certificates"});
		internal override ApiUrls ApiUrls => Urls;
	// values part of the url path
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface ICancelTasksRequest : IRequest<CancelTasksRequestParameters>
	{
		[IgnoreDataMember]
		TaskId TaskId
		{
			get;
		}
	}

	///<summary>Request for CancelTasks <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/tasks.html</pre></summary>
	public partial class CancelTasksRequest : PlainRequestBase<CancelTasksRequestParameters>, ICancelTasksRequest
	{
		protected ICancelTasksRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_tasks/_cancel", "_tasks/{task_id}/_cancel"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_tasks/_cancel</summary>
		public CancelTasksRequest(): base()
		{
		}

		///<summary>/_tasks/{task_id}/_cancel</summary>
		///<param name = "task_id">Optional, accepts null</param>
		public CancelTasksRequest(TaskId task_id): base(r => r.Optional("task_id", task_id))
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		TaskId ICancelTasksRequest.TaskId => Self.RouteValues.Get<TaskId>("task_id");
		// Request parameters
		///<summary>A comma-separated list of actions that should be cancelled. Leave empty to cancel all.</summary>
		public string[] Actions
		{
			get => Q<string[]>("actions");
			set => Q("actions", value);
		}

		///<summary>
		/// A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're
		/// connecting to, leave empty to get information from all nodes
		///</summary>
		public string[] Nodes
		{
			get => Q<string[]>("nodes");
			set => Q("nodes", value);
		}

		///<summary>Cancel tasks with specified parent task id (node_id:task_number). Set to -1 to cancel all.</summary>
		public string ParentTaskId
		{
			get => Q<string>("parent_task_id");
			set => Q("parent_task_id", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IGetTaskRequest : IRequest<GetTaskRequestParameters>
	{
		[IgnoreDataMember]
		TaskId TaskId
		{
			get;
		}
	}

	///<summary>Request for GetTask <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/tasks.html</pre></summary>
	public partial class GetTaskRequest : PlainRequestBase<GetTaskRequestParameters>, IGetTaskRequest
	{
		protected IGetTaskRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_tasks/{task_id}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_tasks/{task_id}</summary>
		///<param name = "task_id">this parameter is required</param>
		public GetTaskRequest(TaskId task_id): base(r => r.Required("task_id", task_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal GetTaskRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		TaskId IGetTaskRequest.TaskId => Self.RouteValues.Get<TaskId>("task_id");
		// Request parameters
		///<summary>Explicit operation timeout</summary>
		public Time Timeout
		{
			get => Q<Time>("timeout");
			set => Q("timeout", value);
		}

		///<summary>Wait for the matching tasks to complete (default: false)</summary>
		public bool? WaitForCompletion
		{
			get => Q<bool? >("wait_for_completion");
			set => Q("wait_for_completion", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IListTasksRequest : IRequest<ListTasksRequestParameters>
	{
	}

	///<summary>Request for ListTasks <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/tasks.html</pre></summary>
	public partial class ListTasksRequest : PlainRequestBase<ListTasksRequestParameters>, IListTasksRequest
	{
		protected IListTasksRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_tasks"});
		internal override ApiUrls ApiUrls => Urls;
		// values part of the url path
		// Request parameters
		///<summary>A comma-separated list of actions that should be returned. Leave empty to return all.</summary>
		public string[] Actions
		{
			get => Q<string[]>("actions");
			set => Q("actions", value);
		}

		///<summary>Return detailed task information (default: false)</summary>
		public bool? Detailed
		{
			get => Q<bool? >("detailed");
			set => Q("detailed", value);
		}

		///<summary>Group tasks by nodes or parent/child relationships</summary>
		public GroupBy? GroupBy
		{
			get => Q<GroupBy? >("group_by");
			set => Q("group_by", value);
		}

		///<summary>
		/// A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're
		/// connecting to, leave empty to get information from all nodes
		///</summary>
		public string[] Nodes
		{
			get => Q<string[]>("nodes");
			set => Q("nodes", value);
		}

		///<summary>Return tasks with specified parent task id (node_id:task_number). Set to -1 to return all.</summary>
		public string ParentTaskId
		{
			get => Q<string>("parent_task_id");
			set => Q("parent_task_id", value);
		}

		///<summary>Explicit operation timeout</summary>
		public Time Timeout
		{
			get => Q<Time>("timeout");
			set => Q("timeout", value);
		}

		///<summary>Wait for the matching tasks to complete (default: false)</summary>
		public bool? WaitForCompletion
		{
			get => Q<bool? >("wait_for_completion");
			set => Q("wait_for_completion", value);
		}
	}

	[InterfaceDataContract]
	public partial interface ITermVectorsRequest : IRequest<TermVectorsRequestParameters>
	{
		[IgnoreDataMember]
		IndexName Index
		{
			get;
		}

		[IgnoreDataMember]
		Id Id
		{
			get;
		}
	}

	public partial interface ITermVectorsRequest<TDocument> : ITermVectorsRequest
	{
	}

	///<summary>Request for TermVectors <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-termvectors.html</pre></summary>
	public partial class TermVectorsRequest : PlainRequestBase<TermVectorsRequestParameters>, ITermVectorsRequest
	{
		protected ITermVectorsRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"{index}/_termvectors/{id}", "{index}/_termvectors"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/{index}/_termvectors/{id}</summary>
		///<param name = "index">this parameter is required</param>
		///<param name = "id">Optional, accepts null</param>
		public TermVectorsRequest(IndexName index, Id id): base(r => r.Required("index", index).Optional("id", id))
		{
		}

		///<summary>/{index}/_termvectors</summary>
		///<param name = "index">this parameter is required</param>
		public TermVectorsRequest(IndexName index): base(r => r.Required("index", index))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal TermVectorsRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		IndexName ITermVectorsRequest.Index => Self.RouteValues.Get<IndexName>("index");
		[IgnoreDataMember]
		Id ITermVectorsRequest.Id => Self.RouteValues.Get<Id>("id");
		// Request parameters
		///<summary>Specifies if document count, sum of document frequencies and sum of total term frequencies should be returned.</summary>
		public bool? FieldStatistics
		{
			get => Q<bool? >("field_statistics");
			set => Q("field_statistics", value);
		}

		///<summary>A comma-separated list of fields to return.</summary>
		public Fields Fields
		{
			get => Q<Fields>("fields");
			set => Q("fields", value);
		}

		///<summary>Specifies if term offsets should be returned.</summary>
		public bool? Offsets
		{
			get => Q<bool? >("offsets");
			set => Q("offsets", value);
		}

		///<summary>Specifies if term payloads should be returned.</summary>
		public bool? Payloads
		{
			get => Q<bool? >("payloads");
			set => Q("payloads", value);
		}

		///<summary>Specifies if term positions should be returned.</summary>
		public bool? Positions
		{
			get => Q<bool? >("positions");
			set => Q("positions", value);
		}

		///<summary>Specify the node or shard the operation should be performed on (default: random).</summary>
		public string Preference
		{
			get => Q<string>("preference");
			set => Q("preference", value);
		}

		///<summary>Specifies if request is real-time as opposed to near-real-time (default: true).</summary>
		public bool? Realtime
		{
			get => Q<bool? >("realtime");
			set => Q("realtime", value);
		}

		///<summary>
		/// A document is routed to a particular shard in an index using the following formula
		/// <para> shard_num = hash(_routing) % num_primary_shards</para>
		/// <para>Elasticsearch will use the document id if not provided. </para>
		/// <para>For requests that are constructed from/for a document NEST will automatically infer the routing key
		/// if that document has a <see cref = "Nest.JoinField"/> or a routing mapping on for its type exists on <see cref = "Nest.ConnectionSettings"
		////></para>
		///</summary>
		public Routing Routing
		{
			get => Q<Routing>("routing");
			set => Q("routing", value);
		}

		///<summary>Specifies if total term frequency and document frequency should be returned.</summary>
		public bool? TermStatistics
		{
			get => Q<bool? >("term_statistics");
			set => Q("term_statistics", value);
		}

		///<summary>Explicit version number for concurrency control</summary>
		public long? Version
		{
			get => Q<long? >("version");
			set => Q("version", value);
		}

		///<summary>Specific version type</summary>
		public VersionType? VersionType
		{
			get => Q<VersionType? >("version_type");
			set => Q("version_type", value);
		}
	}

	public partial class TermVectorsRequest<TDocument> : TermVectorsRequest, ITermVectorsRequest<TDocument>
	{
		protected ITermVectorsRequest<TDocument> TypedSelf => this;
		///<summary>/{index}/_termvectors/{id}</summary>
		///<param name = "index">this parameter is required</param>
		///<param name = "id">Optional, accepts null</param>
		public TermVectorsRequest(IndexName index, Id id): base(index, id)
		{
		}

		///<summary>/{index}/_termvectors</summary>
		///<param name = "index">this parameter is required</param>
		public TermVectorsRequest(IndexName index): base(index)
		{
		}

		///<summary>/{index}/_termvectors/{id}</summary>
		///<param name = "id">Optional, accepts null</param>
		public TermVectorsRequest(Id id): base(typeof(TDocument), id)
		{
		}

		///<summary>/{index}/_termvectors</summary>
		public TermVectorsRequest(): base(typeof(TDocument))
		{
		}

		///<summary>/{index}/_termvectors/{id}</summary>
		///<param name = "id">The document used to resolve the path from</param>
		public TermVectorsRequest(TDocument documentWithId, IndexName index = null, Id id = null): this(index ?? typeof(TDocument), id ?? Nest.Id.From(documentWithId)) => DocumentFromPath(documentWithId);
		partial void DocumentFromPath(TDocument document);
	}

	[InterfaceDataContract]
	public partial interface IUpdateRequest : IRequest<UpdateRequestParameters>
	{
		[IgnoreDataMember]
		IndexName Index
		{
			get;
		}

		[IgnoreDataMember]
		Id Id
		{
			get;
		}
	}

	public partial interface IUpdateRequest<TDocument, TPartialDocument> : IUpdateRequest
	{
	}

	///<summary>Request for Update <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-update.html</pre></summary>
	public partial class UpdateRequest : PlainRequestBase<UpdateRequestParameters>, IUpdateRequest
	{
		protected IUpdateRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"{index}/_update/{id}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/{index}/_update/{id}</summary>
		///<param name = "index">this parameter is required</param>
		///<param name = "id">this parameter is required</param>
		public UpdateRequest(IndexName index, Id id): base(r => r.Required("index", index).Required("id", id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal UpdateRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		IndexName IUpdateRequest.Index => Self.RouteValues.Get<IndexName>("index");
		[IgnoreDataMember]
		Id IUpdateRequest.Id => Self.RouteValues.Get<Id>("id");
		// Request parameters
		///<summary>only perform the update operation if the last operation that has changed the document has the specified primary term</summary>
		public long? IfPrimaryTerm
		{
			get => Q<long? >("if_primary_term");
			set => Q("if_primary_term", value);
		}

		///<summary>only perform the update operation if the last operation that has changed the document has the specified sequence number</summary>
		public long? IfSequenceNumber
		{
			get => Q<long? >("if_seq_no");
			set => Q("if_seq_no", value);
		}

		///<summary>The script language (default: painless)</summary>
		public string Lang
		{
			get => Q<string>("lang");
			set => Q("lang", value);
		}

		///<summary>
		/// If `true` then refresh the effected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this
		/// operation visible to search, if `false` (the default) then do nothing with refreshes.
		///</summary>
		public Refresh? Refresh
		{
			get => Q<Refresh? >("refresh");
			set => Q("refresh", value);
		}

		///<summary>Specify how many times should the operation be retried when a conflict occurs (default: 0)</summary>
		public long? RetryOnConflict
		{
			get => Q<long? >("retry_on_conflict");
			set => Q("retry_on_conflict", value);
		}

		///<summary>
		/// A document is routed to a particular shard in an index using the following formula
		/// <para> shard_num = hash(_routing) % num_primary_shards</para>
		/// <para>Elasticsearch will use the document id if not provided. </para>
		/// <para>For requests that are constructed from/for a document NEST will automatically infer the routing key
		/// if that document has a <see cref = "Nest.JoinField"/> or a routing mapping on for its type exists on <see cref = "Nest.ConnectionSettings"
		////></para>
		///</summary>
		public Routing Routing
		{
			get => Q<Routing>("routing");
			set => Q("routing", value);
		}

		///<summary>Whether the _source should be included in the response.</summary>
		public bool? SourceEnabled
		{
			get => Q<bool? >("_source");
			set => Q("_source", value);
		}

		///<summary>Explicit operation timeout</summary>
		public Time Timeout
		{
			get => Q<Time>("timeout");
			set => Q("timeout", value);
		}

		///<summary>
		/// Sets the number of shard copies that must be active before proceeding with the update operation. Defaults to 1, meaning the primary shard
		/// only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the
		/// shard (number of replicas + 1)
		///</summary>
		public string WaitForActiveShards
		{
			get => Q<string>("wait_for_active_shards");
			set => Q("wait_for_active_shards", value);
		}
	}

	public partial class UpdateRequest<TDocument, TPartialDocument> : UpdateRequest, IUpdateRequest<TDocument, TPartialDocument>
	{
		protected IUpdateRequest<TDocument, TPartialDocument> TypedSelf => this;
		///<summary>/{index}/_update/{id}</summary>
		///<param name = "index">this parameter is required</param>
		///<param name = "id">this parameter is required</param>
		public UpdateRequest(IndexName index, Id id): base(index, id)
		{
		}

		///<summary>/{index}/_update/{id}</summary>
		///<param name = "id">this parameter is required</param>
		public UpdateRequest(Id id): base(typeof(TDocument), id)
		{
		}

		///<summary>/{index}/_update/{id}</summary>
		///<param name = "id">The document used to resolve the path from</param>
		public UpdateRequest(TDocument documentWithId, IndexName index = null, Id id = null): this(index ?? typeof(TDocument), id ?? Nest.Id.From(documentWithId)) => DocumentFromPath(documentWithId);
		partial void DocumentFromPath(TDocument document);
		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal UpdateRequest(): base()
		{
		}
	}

	[InterfaceDataContract]
	public partial interface IUpdateByQueryRequest : IRequest<UpdateByQueryRequestParameters>
	{
		[IgnoreDataMember]
		Indices Index
		{
			get;
		}
	}

	public partial interface IUpdateByQueryRequest<T> : IUpdateByQueryRequest
	{
	}

	///<summary>Request for UpdateByQuery <pre>https://www.elastic.co/guide/en/elasticsearch/reference/master/docs-update-by-query.html</pre></summary>
	public partial class UpdateByQueryRequest : PlainRequestBase<UpdateByQueryRequestParameters>, IUpdateByQueryRequest
	{
		protected IUpdateByQueryRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"{index}/_update_by_query"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/{index}/_update_by_query</summary>
		///<param name = "index">this parameter is required</param>
		public UpdateByQueryRequest(Indices index): base(r => r.Required("index", index))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal UpdateByQueryRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Indices IUpdateByQueryRequest.Index => Self.RouteValues.Get<Indices>("index");
		// Request parameters
		///<summary>
		/// Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have
		/// been specified)
		///</summary>
		public bool? AllowNoIndices
		{
			get => Q<bool? >("allow_no_indices");
			set => Q("allow_no_indices", value);
		}

		///<summary>Specify whether wildcard and prefix queries should be analyzed (default: false)</summary>
		public bool? AnalyzeWildcard
		{
			get => Q<bool? >("analyze_wildcard");
			set => Q("analyze_wildcard", value);
		}

		///<summary>The analyzer to use for the query string</summary>
		public string Analyzer
		{
			get => Q<string>("analyzer");
			set => Q("analyzer", value);
		}

		///<summary>What to do when the update by query hits version conflicts?</summary>
		public Conflicts? Conflicts
		{
			get => Q<Conflicts? >("conflicts");
			set => Q("conflicts", value);
		}

		///<summary>The default operator for query string query (AND or OR)</summary>
		public DefaultOperator? DefaultOperator
		{
			get => Q<DefaultOperator? >("default_operator");
			set => Q("default_operator", value);
		}

		///<summary>The field to use as default where no field prefix is given in the query string</summary>
		public string Df
		{
			get => Q<string>("df");
			set => Q("df", value);
		}

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ExpandWildcards? ExpandWildcards
		{
			get => Q<ExpandWildcards? >("expand_wildcards");
			set => Q("expand_wildcards", value);
		}

		///<summary>Starting offset (default: 0)</summary>
		public long? From
		{
			get => Q<long? >("from");
			set => Q("from", value);
		}

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public bool? IgnoreUnavailable
		{
			get => Q<bool? >("ignore_unavailable");
			set => Q("ignore_unavailable", value);
		}

		///<summary>Specify whether format-based query failures (such as providing text to a numeric field) should be ignored</summary>
		public bool? Lenient
		{
			get => Q<bool? >("lenient");
			set => Q("lenient", value);
		}

		///<summary>Ingest pipeline to set on index requests made by this action. (default: none)</summary>
		public string Pipeline
		{
			get => Q<string>("pipeline");
			set => Q("pipeline", value);
		}

		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public string Preference
		{
			get => Q<string>("preference");
			set => Q("preference", value);
		}

		///<summary>Query in the Lucene query string syntax</summary>
		public string QueryOnQueryString
		{
			get => Q<string>("q");
			set => Q("q", value);
		}

		///<summary>Should the effected indexes be refreshed?</summary>
		public bool? Refresh
		{
			get => Q<bool? >("refresh");
			set => Q("refresh", value);
		}

		///<summary>Specify if request cache should be used for this request or not, defaults to index level setting</summary>
		public bool? RequestCache
		{
			get => Q<bool? >("request_cache");
			set => Q("request_cache", value);
		}

		///<summary>The throttle to set on this request in sub-requests per second. -1 means no throttle.</summary>
		public long? RequestsPerSecond
		{
			get => Q<long? >("requests_per_second");
			set => Q("requests_per_second", value);
		}

		///<summary>
		/// A document is routed to a particular shard in an index using the following formula
		/// <para> shard_num = hash(_routing) % num_primary_shards</para>
		/// <para>Elasticsearch will use the document id if not provided. </para>
		/// <para>For requests that are constructed from/for a document NEST will automatically infer the routing key
		/// if that document has a <see cref = "Nest.JoinField"/> or a routing mapping on for its type exists on <see cref = "Nest.ConnectionSettings"
		////></para>
		///</summary>
		public Routing Routing
		{
			get => Q<Routing>("routing");
			set => Q("routing", value);
		}

		///<summary>Specify how long a consistent view of the index should be maintained for scrolled search</summary>
		public Time Scroll
		{
			get => Q<Time>("scroll");
			set => Q("scroll", value);
		}

		///<summary>Size on the scroll request powering the update by query</summary>
		public long? ScrollSize
		{
			get => Q<long? >("scroll_size");
			set => Q("scroll_size", value);
		}

		///<summary>Explicit timeout for each search request. Defaults to no timeout.</summary>
		public Time SearchTimeout
		{
			get => Q<Time>("search_timeout");
			set => Q("search_timeout", value);
		}

		///<summary>Search operation type</summary>
		public SearchType? SearchType
		{
			get => Q<SearchType? >("search_type");
			set => Q("search_type", value);
		}

		///<summary>Number of hits to return (default: 10)</summary>
		public long? Size
		{
			get => Q<long? >("size");
			set => Q("size", value);
		}

		///<summary>The number of slices this task should be divided into. Defaults to 1 meaning the task isn't sliced into subtasks.</summary>
		public long? Slices
		{
			get => Q<long? >("slices");
			set => Q("slices", value);
		}

		///<summary>A comma-separated list of <field>:<direction> pairs</summary>
		public string[] Sort
		{
			get => Q<string[]>("sort");
			set => Q("sort", value);
		}

		///<summary>Whether the _source should be included in the response.</summary>
		public bool? SourceEnabled
		{
			get => Q<bool? >("_source");
			set => Q("_source", value);
		}

		///<summary>A list of fields to exclude from the returned _source field</summary>
		public Fields SourceExcludes
		{
			get => Q<Fields>("_source_excludes");
			set => Q("_source_excludes", value);
		}

		///<summary>A list of fields to extract and return from the _source field</summary>
		public Fields SourceIncludes
		{
			get => Q<Fields>("_source_includes");
			set => Q("_source_includes", value);
		}

		///<summary>Specific 'tag' of the request for logging and statistical purposes</summary>
		public string[] Stats
		{
			get => Q<string[]>("stats");
			set => Q("stats", value);
		}

		///<summary>The maximum number of documents to collect for each shard, upon reaching which the query execution will terminate early.</summary>
		public long? TerminateAfter
		{
			get => Q<long? >("terminate_after");
			set => Q("terminate_after", value);
		}

		///<summary>Time each individual bulk request should wait for shards that are unavailable.</summary>
		public Time Timeout
		{
			get => Q<Time>("timeout");
			set => Q("timeout", value);
		}

		///<summary>Specify whether to return document version as part of a hit</summary>
		public bool? Version
		{
			get => Q<bool? >("version");
			set => Q("version", value);
		}

		///<summary>Should the document increment the version number (internal) on hit or not (reindex)</summary>
		public bool? VersionType
		{
			get => Q<bool? >("version_type");
			set => Q("version_type", value);
		}

		///<summary>
		/// Sets the number of shard copies that must be active before proceeding with the update by query operation. Defaults to 1, meaning the
		/// primary shard only. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of
		/// copies for the shard (number of replicas + 1)
		///</summary>
		public string WaitForActiveShards
		{
			get => Q<string>("wait_for_active_shards");
			set => Q("wait_for_active_shards", value);
		}

		///<summary>Should the request should block until the update by query operation is complete.</summary>
		public bool? WaitForCompletion
		{
			get => Q<bool? >("wait_for_completion");
			set => Q("wait_for_completion", value);
		}
	}

	public partial class UpdateByQueryRequest<T> : UpdateByQueryRequest, IUpdateByQueryRequest<T>
	{
		protected IUpdateByQueryRequest<T> TypedSelf => this;
		///<summary>/{index}/_update_by_query</summary>
		///<param name = "index">this parameter is required</param>
		public UpdateByQueryRequest(Indices index): base(index)
		{
		}

		///<summary>/{index}/_update_by_query</summary>
		public UpdateByQueryRequest(): base(typeof(T))
		{
		}
	}

	[InterfaceDataContract]
	public partial interface IUpdateByQueryRethrottleRequest : IRequest<UpdateByQueryRethrottleRequestParameters>
	{
		[IgnoreDataMember]
		TaskId TaskId
		{
			get;
		}
	}

	///<summary>Request for UpdateByQueryRethrottle <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-update-by-query.html</pre></summary>
	public partial class UpdateByQueryRethrottleRequest : PlainRequestBase<UpdateByQueryRethrottleRequestParameters>, IUpdateByQueryRethrottleRequest
	{
		protected IUpdateByQueryRethrottleRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_update_by_query/{task_id}/_rethrottle"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_update_by_query/{task_id}/_rethrottle</summary>
		///<param name = "task_id">this parameter is required</param>
		public UpdateByQueryRethrottleRequest(TaskId task_id): base(r => r.Required("task_id", task_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal UpdateByQueryRethrottleRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		TaskId IUpdateByQueryRethrottleRequest.TaskId => Self.RouteValues.Get<TaskId>("task_id");
		// Request parameters
		///<summary>The throttle to set on this request in floating sub-requests per second. -1 means set no throttle.</summary>
		public long? RequestsPerSecond
		{
			get => Q<long? >("requests_per_second");
			set => Q("requests_per_second", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IAcknowledgeWatchRequest : IRequest<AcknowledgeWatchRequestParameters>
	{
		[IgnoreDataMember]
		Id WatchId
		{
			get;
		}

		[IgnoreDataMember]
		ActionIds ActionId
		{
			get;
		}
	}

	///<summary>Request for AcknowledgeWatch <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/watcher-api-ack-watch.html</pre></summary>
	public partial class AcknowledgeWatchRequest : PlainRequestBase<AcknowledgeWatchRequestParameters>, IAcknowledgeWatchRequest
	{
		protected IAcknowledgeWatchRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_watcher/watch/{watch_id}/_ack", "_watcher/watch/{watch_id}/_ack/{action_id}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_watcher/watch/{watch_id}/_ack</summary>
		///<param name = "watch_id">this parameter is required</param>
		public AcknowledgeWatchRequest(Id watch_id): base(r => r.Required("watch_id", watch_id))
		{
		}

		///<summary>/_watcher/watch/{watch_id}/_ack/{action_id}</summary>
		///<param name = "watch_id">this parameter is required</param>
		///<param name = "action_id">Optional, accepts null</param>
		public AcknowledgeWatchRequest(Id watch_id, ActionIds action_id): base(r => r.Required("watch_id", watch_id).Optional("action_id", action_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal AcknowledgeWatchRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Id IAcknowledgeWatchRequest.WatchId => Self.RouteValues.Get<Id>("watch_id");
		[IgnoreDataMember]
		ActionIds IAcknowledgeWatchRequest.ActionId => Self.RouteValues.Get<ActionIds>("action_id");
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IActivateWatchRequest : IRequest<ActivateWatchRequestParameters>
	{
		[IgnoreDataMember]
		Id WatchId
		{
			get;
		}
	}

	///<summary>Request for ActivateWatch <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/watcher-api-activate-watch.html</pre></summary>
	public partial class ActivateWatchRequest : PlainRequestBase<ActivateWatchRequestParameters>, IActivateWatchRequest
	{
		protected IActivateWatchRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_watcher/watch/{watch_id}/_activate"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_watcher/watch/{watch_id}/_activate</summary>
		///<param name = "watch_id">this parameter is required</param>
		public ActivateWatchRequest(Id watch_id): base(r => r.Required("watch_id", watch_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal ActivateWatchRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Id IActivateWatchRequest.WatchId => Self.RouteValues.Get<Id>("watch_id");
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IDeactivateWatchRequest : IRequest<DeactivateWatchRequestParameters>
	{
		[IgnoreDataMember]
		Id WatchId
		{
			get;
		}
	}

	///<summary>Request for DeactivateWatch <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/watcher-api-deactivate-watch.html</pre></summary>
	public partial class DeactivateWatchRequest : PlainRequestBase<DeactivateWatchRequestParameters>, IDeactivateWatchRequest
	{
		protected IDeactivateWatchRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_watcher/watch/{watch_id}/_deactivate"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_watcher/watch/{watch_id}/_deactivate</summary>
		///<param name = "watch_id">this parameter is required</param>
		public DeactivateWatchRequest(Id watch_id): base(r => r.Required("watch_id", watch_id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal DeactivateWatchRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Id IDeactivateWatchRequest.WatchId => Self.RouteValues.Get<Id>("watch_id");
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IDeleteWatchRequest : IRequest<DeleteWatchRequestParameters>
	{
		[IgnoreDataMember]
		Id Id
		{
			get;
		}
	}

	///<summary>Request for DeleteWatch <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/watcher-api-delete-watch.html</pre></summary>
	public partial class DeleteWatchRequest : PlainRequestBase<DeleteWatchRequestParameters>, IDeleteWatchRequest
	{
		protected IDeleteWatchRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_watcher/watch/{id}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_watcher/watch/{id}</summary>
		///<param name = "id">this parameter is required</param>
		public DeleteWatchRequest(Id id): base(r => r.Required("id", id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal DeleteWatchRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Id IDeleteWatchRequest.Id => Self.RouteValues.Get<Id>("id");
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IExecuteWatchRequest : IRequest<ExecuteWatchRequestParameters>
	{
		[IgnoreDataMember]
		Id Id
		{
			get;
		}
	}

	///<summary>Request for ExecuteWatch <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/watcher-api-execute-watch.html</pre></summary>
	public partial class ExecuteWatchRequest : PlainRequestBase<ExecuteWatchRequestParameters>, IExecuteWatchRequest
	{
		protected IExecuteWatchRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_watcher/watch/{id}/_execute", "_watcher/watch/_execute"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_watcher/watch/{id}/_execute</summary>
		///<param name = "id">Optional, accepts null</param>
		public ExecuteWatchRequest(Id id): base(r => r.Optional("id", id))
		{
		}

		///<summary>/_watcher/watch/_execute</summary>
		public ExecuteWatchRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Id IExecuteWatchRequest.Id => Self.RouteValues.Get<Id>("id");
		// Request parameters
		///<summary>indicates whether the watch should execute in debug mode</summary>
		public bool? Debug
		{
			get => Q<bool? >("debug");
			set => Q("debug", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IGetWatchRequest : IRequest<GetWatchRequestParameters>
	{
		[IgnoreDataMember]
		Id Id
		{
			get;
		}
	}

	///<summary>Request for GetWatch <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/watcher-api-get-watch.html</pre></summary>
	public partial class GetWatchRequest : PlainRequestBase<GetWatchRequestParameters>, IGetWatchRequest
	{
		protected IGetWatchRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_watcher/watch/{id}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_watcher/watch/{id}</summary>
		///<param name = "id">this parameter is required</param>
		public GetWatchRequest(Id id): base(r => r.Required("id", id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal GetWatchRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Id IGetWatchRequest.Id => Self.RouteValues.Get<Id>("id");
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IPutWatchRequest : IRequest<PutWatchRequestParameters>
	{
		[IgnoreDataMember]
		Id Id
		{
			get;
		}
	}

	///<summary>Request for PutWatch <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/watcher-api-put-watch.html</pre></summary>
	public partial class PutWatchRequest : PlainRequestBase<PutWatchRequestParameters>, IPutWatchRequest
	{
		protected IPutWatchRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_watcher/watch/{id}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_watcher/watch/{id}</summary>
		///<param name = "id">this parameter is required</param>
		public PutWatchRequest(Id id): base(r => r.Required("id", id))
		{
		}

		///<summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
		[SerializationConstructor]
		internal PutWatchRequest(): base()
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Id IPutWatchRequest.Id => Self.RouteValues.Get<Id>("id");
		// Request parameters
		///<summary>Specify whether the watch is in/active by default</summary>
		public bool? Active
		{
			get => Q<bool? >("active");
			set => Q("active", value);
		}

		///<summary>only update the watch if the last operation that has changed the watch has the specified primary term</summary>
		public long? IfPrimaryTerm
		{
			get => Q<long? >("if_primary_term");
			set => Q("if_primary_term", value);
		}

		///<summary>only update the watch if the last operation that has changed the watch has the specified sequence number</summary>
		public long? IfSequenceNumber
		{
			get => Q<long? >("if_seq_no");
			set => Q("if_seq_no", value);
		}

		///<summary>Explicit version number for concurrency control</summary>
		public long? Version
		{
			get => Q<long? >("version");
			set => Q("version", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IStartWatcherRequest : IRequest<StartWatcherRequestParameters>
	{
	}

	///<summary>Request for StartWatcher <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/watcher-api-start.html</pre></summary>
	public partial class StartWatcherRequest : PlainRequestBase<StartWatcherRequestParameters>, IStartWatcherRequest
	{
		protected IStartWatcherRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_watcher/_start"});
		internal override ApiUrls ApiUrls => Urls;
	// values part of the url path
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IWatcherStatsRequest : IRequest<WatcherStatsRequestParameters>
	{
		[IgnoreDataMember]
		Metrics Metric
		{
			get;
		}
	}

	///<summary>Request for Stats <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/watcher-api-stats.html</pre></summary>
	public partial class WatcherStatsRequest : PlainRequestBase<WatcherStatsRequestParameters>, IWatcherStatsRequest
	{
		protected IWatcherStatsRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_watcher/stats", "_watcher/stats/{metric}"});
		internal override ApiUrls ApiUrls => Urls;
		///<summary>/_watcher/stats</summary>
		public WatcherStatsRequest(): base()
		{
		}

		///<summary>/_watcher/stats/{metric}</summary>
		///<param name = "metric">Optional, accepts null</param>
		public WatcherStatsRequest(Metrics metric): base(r => r.Optional("metric", metric))
		{
		}

		// values part of the url path
		[IgnoreDataMember]
		Metrics IWatcherStatsRequest.Metric => Self.RouteValues.Get<Metrics>("metric");
		// Request parameters
		///<summary>Emits stack traces of currently running watches</summary>
		public bool? EmitStacktraces
		{
			get => Q<bool? >("emit_stacktraces");
			set => Q("emit_stacktraces", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IStopWatcherRequest : IRequest<StopWatcherRequestParameters>
	{
	}

	///<summary>Request for StopWatcher <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/watcher-api-stop.html</pre></summary>
	public partial class StopWatcherRequest : PlainRequestBase<StopWatcherRequestParameters>, IStopWatcherRequest
	{
		protected IStopWatcherRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_watcher/_stop"});
		internal override ApiUrls ApiUrls => Urls;
	// values part of the url path
	// Request parameters
	}

	[InterfaceDataContract]
	public partial interface IXPackInfoRequest : IRequest<XPackInfoRequestParameters>
	{
	}

	///<summary>Request for XPackInfo <pre>https://www.elastic.co/guide/en/elasticsearch/reference/current/info-api.html</pre></summary>
	public partial class XPackInfoRequest : PlainRequestBase<XPackInfoRequestParameters>, IXPackInfoRequest
	{
		protected IXPackInfoRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_xpack"});
		internal override ApiUrls ApiUrls => Urls;
		// values part of the url path
		// Request parameters
		///<summary>Comma-separated list of info categories. Can be any of: build, license, features</summary>
		public string[] Categories
		{
			get => Q<string[]>("categories");
			set => Q("categories", value);
		}
	}

	[InterfaceDataContract]
	public partial interface IXPackUsageRequest : IRequest<XPackUsageRequestParameters>
	{
	}

	///<summary>Request for XPackUsage <pre>Retrieve information about xpack features usage</pre></summary>
	public partial class XPackUsageRequest : PlainRequestBase<XPackUsageRequestParameters>, IXPackUsageRequest
	{
		protected IXPackUsageRequest Self => this;
		internal static ApiUrls Urls = new ApiUrls(new[]{"_xpack/usage"});
		internal override ApiUrls ApiUrls => Urls;
		// values part of the url path
		// Request parameters
		///<summary>Specify timeout for watch write operation</summary>
		public Time MasterTimeout
		{
			get => Q<Time>("master_timeout");
			set => Q("master_timeout", value);
		}
	}
}